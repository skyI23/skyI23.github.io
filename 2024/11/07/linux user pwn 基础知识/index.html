<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="sky123">
    
    <!-- Completely eliminate flash of wrong theme -->
    <script>
        (function() {
            const THEME_KEY = "REDEFINE-THEME-STATUS";
            const DARK = "dark", LIGHT = "light";
            
            // Get preferred theme
            function getTheme() {
                try {
                    const saved = localStorage.getItem(THEME_KEY);
                    if (saved) {
                        const { isDark } = JSON.parse(saved);
                        return isDark ? DARK : LIGHT;
                    }
                } catch (e) {}
                
                return matchMedia("(prefers-color-scheme: dark)").matches ? DARK : LIGHT;
            }
            
            // Apply theme to document
            function applyTheme(theme) {
                const isDark = theme === DARK;
                const root = document.documentElement;
                
                // Set data attribute for CSS variables
                root.setAttribute("data-theme", theme);
                
                // Set classes for compatibility
                root.classList.add(theme);
                root.classList.remove(isDark ? LIGHT : DARK);
                root.style.colorScheme = theme;
            }
            
            // Initial application
            const theme = getTheme();
            applyTheme(theme);
            
            // Listen for system preference changes
            matchMedia("(prefers-color-scheme: dark)").addEventListener("change", ({ matches }) => {
                // Only update if using system preference (no localStorage entry)
                if (!localStorage.getItem(THEME_KEY)) {
                    applyTheme(matches ? DARK : LIGHT);
                }
            });
            
            // Set body classes once DOM is ready
            if (document.readyState !== "loading") {
                document.body.classList.add(theme + "-mode");
            } else {
                document.addEventListener("DOMContentLoaded", () => {
                    document.body.classList.add(theme + "-mode");
                    document.body.classList.remove((theme === DARK ? LIGHT : DARK) + "-mode");
                });
            }
        })();
    </script>
    
    <!-- Critical CSS to prevent flash -->
    <style>
        :root[data-theme="dark"] {
            --background-color: #202124;
            --background-color-transparent: rgba(32, 33, 36, 0.6);
            --second-background-color: #2d2e32;
            --third-background-color: #34353a;
            --third-background-color-transparent: rgba(32, 33, 36, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #ffffff;
            --second-text-color: #eeeeee;
            --third-text-color: #bebec6;
            --fourth-text-color: #999999;
            --default-text-color: #bebec6;
            --invert-text-color: #373D3F;
            --border-color: rgba(255, 255, 255, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(255, 255, 255, 0.08);
            --shadow-color-2: rgba(255, 255, 255, 0.05);
        }
        
        :root[data-theme="light"] {
            --background-color: #fff;
            --background-color-transparent: rgba(255, 255, 255, 0.6);
            --second-background-color: #f8f8f8;
            --third-background-color: #f2f2f2;
            --third-background-color-transparent: rgba(241, 241, 241, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #16171a;
            --second-text-color: #2f3037;
            --third-text-color: #5e5e5e;
            --fourth-text-color: #eeeeee;
            --default-text-color: #373D3F;
            --invert-text-color: #bebec6;
            --border-color: rgba(0, 0, 0, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(0, 0, 0, 0.08);
            --shadow-color-2: rgba(0, 0, 0, 0.05);
        }
        
        body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
        
        /* Apply body classes as soon as DOM is ready */
        :root[data-theme="dark"] body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
    </style>
    
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://skyi23.github.io/2024/11/07/linux user pwn 基础知识/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/null" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/null">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/null">
    <!--- Page Info-->
    
    <title>
        
            linux user pwn 基础知识 | sky123&#39;s site
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/css/build/tailwind.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" rel="stylesheet">
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"skyi23.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":true,"family":"JetBrains Mono","url":"https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap"}},"toc":{"enable":true,"max_depth":5,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"side_tools":{"gear_rotation":true,"auto_expand":false},"open_graph":{"enable":false,"image":"/images/redefine-og.webp","description":"Hexo Theme Redefine, Redefine Your Hexo Journey."},"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"sky123's blog","subtitle":{"text":["书有未曾经我读，事无不可对人言"],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":true,"version":"11.4.1"}},"version":"2.8.5","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"分类":{"icon":"fa-solid fa-folder","path":"/categories/"},"标签":{"icon":"fa-solid fa-tags","path":"/tags/"},"书签":{"icon":"fa-solid fa-bookmark","path":"/bookmarks/"}},"search":{"enable":true,"preload":true}},"page_templates":{"bookmarks_column":3,"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2024/11/7 00:00:00"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha256-TThEtR+XalhWKkfF383YLOrI50NGNeIqrzS+q08afrY=" crossorigin="anonymous"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>



<body>
	<div class="progress-bar-container">
	
	<span class="scroll-progress-bar"></span>
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                sky123&#39;s site
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/categories/"
                                        >
                                    <i class="fa-solid fa-folder fa-fw"></i>
                                    分类
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/tags/"
                                        >
                                    <i class="fa-solid fa-tags fa-fw"></i>
                                    标签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/bookmarks/"
                                        >
                                    <i class="fa-solid fa-bookmark fa-fw"></i>
                                    书签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/categories/"
                        >
                            <span>
                                分类
                            </span>
                            
                                <i class="fa-solid fa-folder fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/tags/"
                        >
                            <span>
                                标签
                            </span>
                            
                                <i class="fa-solid fa-tags fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/bookmarks/"
                        >
                            <span>
                                书签
                            </span>
                            
                                <i class="fa-solid fa-bookmark fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">14</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">17</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">57</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">linux user pwn 基础知识</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/icon.jpg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">sky123</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2024-11-07 18:56:56</span>
        <span class="mobile">2024-11-07 18:56:56</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2026-02-03 00:02:59</span>
            <span class="mobile">2026-02-03 00:02:59</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/pwn/">pwn</a>&nbsp;
                        </li>
                    
                    
                
                    
                        
                            <li>></li>
                        
                        <li>
                            <a href="/categories/pwn/linux-user/">linux user</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/linux-user-pwn/">linux user pwn</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>66.1k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>282 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="虚拟机安装"><a href="#虚拟机安装" class="headerlink" title="虚拟机安装"></a>虚拟机安装</h2><ul>
<li><a class="link"   target="_blank" rel="noopener" href="http://old-releases.ubuntu.com/releases/" >镜像下载网站<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li>为了避免环境问题建议 22.04 ，20.04，18.04，16.04 等常见版本 ubuntu 虚拟机环境各准备一份。注意定期更新快照以防意外。</li>
<li>虚拟机建议硬盘 256 G 以上，内存也尽量大一些。硬盘大小只是上界，256 G 不是真就占了 256 G，而后期如果硬盘空间不足会很麻烦。</li>
<li>更换 <a class="link"   target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/" >ubuntu 镜像源<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> ，建议先在 <code>系统设置 → Software &amp; Updates → Download from → 选择国内服务器例如阿里云</code>（貌似不这样后续换源会出错），然后再 <code>sudo gedit /etc/apt/sources.list</code> 将镜像源中<strong>不高于</strong>当前系统版本的镜像复制进去（高于当前系统版本容易把 <code>apt</code> 搞坏）。</li>
<li>Ubuntu 换源 error：The following signatures couldn’t be verified because the public key is not available 解决方法：<code>sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 5523BAEEB01FA116</code> 其中的<code>5523BAEEB01FA116</code> 是根据错误提示写的。</li>
</ul>
<h2 id="基础工具"><a href="#基础工具" class="headerlink" title="基础工具"></a>基础工具</h2><h3 id="net-tools"><a href="#net-tools" class="headerlink" title="net-tools"></a>net-tools</h3><p><code>ifconfig</code> 查看网络配置需要安装 <code>net-tools</code> 。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install net-tools</span><br></pre></td></tr></table></figure></div>

<h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install vim</span><br></pre></td></tr></table></figure></div>

<h3 id="gedit"><a href="#gedit" class="headerlink" title="gedit"></a>gedit</h3><p>不习惯 vim 的可以使用 gedit 文本编辑器。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install gedit</span><br></pre></td></tr></table></figure></div>

<h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install git</span><br></pre></td></tr></table></figure></div>

<h3 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install gcc</span><br><span class="line"><span class="built_in">sudo</span> apt install gcc-multilib</span><br></pre></td></tr></table></figure></div>

<h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><p>ipython 提供了很好的 python 交互命令行，建议安装。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install python2</span><br><span class="line"><span class="built_in">sudo</span> apt install python3</span><br><span class="line"><span class="built_in">sudo</span> apt install ipython</span><br><span class="line"><span class="built_in">sudo</span> apt install ipython3</span><br></pre></td></tr></table></figure></div>

<p>另外有的版本 ubuntu 的不好安装 pip2 可以使用 <code>get-pip.py</code> 脚本安装。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install python3-pip</span><br><span class="line"><span class="built_in">sudo</span> apt  install curl</span><br><span class="line">curl https://bootstrap.pypa.io/pip/2.7/get-pip.py --output get-pip.py</span><br><span class="line"><span class="built_in">sudo</span> python2 get-pip.py</span><br></pre></td></tr></table></figure></div>

<p>ubuntu 22.04 的 ipython（python2）必须使用 pip2 安装：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pip2 install ipython</span><br></pre></td></tr></table></figure></div>

<h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install docker.io</span><br><span class="line"><span class="built_in">sudo</span> apt install docker-compose</span><br></pre></td></tr></table></figure></div>

<p>默认情况下，Docker 命令需要使用 sudo 权限才能运行，这是因为 Docker 守护进程以 root 用户身份运行。然而，你可以通过以下步骤将当前用户添加到 Docker 用户组，从而允许在不使用 sudo 的情况下运行 Docker 命令：</p>
<ul>
<li><p>确保当前用户属于 <code>docker</code> 组：运行以下命令检查当前用户是否已添加到 docker 组：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">groups</span></span><br></pre></td></tr></table></figure></div>

<p>在输出的组列表中查找 <code>docker</code>。如果没有找到 <code>docker</code> 组，请继续下一步。</p>
</li>
<li><p>将当前用户添加到 <code>docker</code> 组：运行以下命令将当前用户添加到 <code>docker</code> 组中（将 <code>&lt;username&gt;</code> 替换为你的用户名）：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> usermod -aG docker &lt;username&gt;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>更新用户组更改：运行以下命令使用户组更改生效：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newgrp docker</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>重新登录或重启系统：要使用户组更改永久生效，你需要注销当前会话并重新登录，或者重启系统。</p>
</li>
</ul>
<h3 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a>oh-my-zsh</h3><p>安装 zsh</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install zsh</span><br></pre></td></tr></table></figure></div>

<p>安装 <a class="link"   target="_blank" rel="noopener" href="https://ohmyz.sh/#install" >oh-my-zsh<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>设置 zsh 为默认 shell（重启虚拟机后生效）</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure></div>

<p>安装 oh-my-zsh 插件 <a class="link"   target="_blank" rel="noopener" href="https://github.com/zsh-users/zsh-autosuggestions/blob/master/INSTALL.md" >zsh-autosuggestions <i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，<a class="link"   target="_blank" rel="noopener" href="https://github.com/zsh-users/zsh-syntax-highlighting" >zsh-syntax-highlighting<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure></div>

<p>编辑 <code>~/.zshrc</code> 添加插件：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plugins=( </span><br><span class="line">    <span class="comment"># other plugins...</span></span><br><span class="line">    zsh-autosuggestions</span><br><span class="line">    zsh-syntax-highlighting</span><br><span class="line">    extract</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<p>更新：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">omz update</span><br></pre></td></tr></table></figure></div>

<h3 id="wsl"><a href="#wsl" class="headerlink" title="wsl"></a>wsl</h3><p><strong>WSL (Windows Subsystem for Linux)</strong> 是微软为 Windows 用户提供的一种兼容层，允许用户在 Windows 操作系统上运行 Linux 环境（包括大部分命令行工具、应用程序和服务），而不需要安装虚拟机或双系统。简单来说，WSL 让你在 Windows 上运行 Linux 程序，就像它们是原生程序一样。</p>
<p>WSL 目前有 WSL1 和 WSL2 两个版本：</p>
<ul>
<li><p><strong>WSL1</strong> ：最初的版本，提供 Linux 环境，运行 Linux 程序，速度较快但功能较有限。</p>
</li>
<li><p><strong>WSL2</strong> ：通过在 Windows 上虚拟化完整的 Linux 内核，提供更强大的功能和更高的兼容性，特别适合需要容器、Docker 或更复杂的 Linux 功能的开发工作。</p>
</li>
</ul>
<p>由于 WSL2 和虚拟机的部分设置冲突，因此这里建议安装 WSL1。具体安装过程如下：</p>
<ol>
<li><p><strong>安装 WSL 1 或 WSL 2</strong> ： 你可以通过 PowerShell 运行以下命令来安装 WSL：</p>
<div class="code-container" data-rel="Powershell"><figure class="iseeu highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--install</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>选择 Linux 发行版</strong> ： 安装后，你可以从 <strong>Microsoft Store</strong> 下载你喜欢的 Linux 发行版（如 Ubuntu、Debian 等）。我这里安装的是 Ubuntu 22.04。</p>
</li>
<li><p><strong>启用 Windows 功能</strong> ：下载好 Linux 发行版后在应用商店选择打开该 Linux，此时会弹出系统安装的命令窗口。但正常情况下这一步会出现一些报错，你需要启用部分 Windows 功能来避免这些报错。</p>
</li>
</ol>
<ul>
<li><p><strong>0x80370114 错误</strong> ：这个报错说明未启用<strong>“虚拟机平台 (Virtual Machine Platform)”</strong>或<strong>“Windows 子系统 for Linux”</strong>功能。你需要打开 PowerShell（<strong>以管理员身份</strong>运行），依次执行以下命令并重启电脑：</p>
<div class="code-container" data-rel="Powershell"><figure class="iseeu highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dism.exe /online /<span class="built_in">enable-feature</span> /featurename:Microsoft<span class="literal">-Windows-Subsystem-Linux</span> /all /norestart</span><br><span class="line">dism.exe /online /<span class="built_in">enable-feature</span> /featurename:VirtualMachinePlatform /all /norestart</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>0x80370102 错误</strong> ：这个报错表示<strong>虚拟化功能未启用</strong>，或者 Windows 中的 <strong>虚拟机平台 (Virtual Machine Platform)</strong> 功能未启用。</p>
<ul>
<li><p>如果是安装 WSL2 则需要打开 PowerShell（<strong>以管理员身份</strong>运行），然后执行以下命令开启 Hyper-V 功能并重启电脑。</p>
  <div class="code-container" data-rel="Powershell"><figure class="iseeu highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dism.exe /online /<span class="built_in">enable-feature</span> /featurename:Microsoft<span class="literal">-Hyper-V-All</span> /all /norestart</span><br></pre></td></tr></table></figure></div>
<p>  之后还要打开 <strong>任务管理器</strong>，切换到“<strong>性能</strong>”选项卡，选择“<strong>CPU</strong>”，查看右下角“<strong>虚拟化</strong>”是否显示为 <strong>已启用</strong>。如果未启用还要在重启的时候进 BIOS 开启 CPU 的虚拟化选项。</p>
</li>
<li><p>如果是安装 WSL1 则只需要将 WSL 的版本设置为 1 即可。</p>
  <div class="code-container" data-rel="Powershell"><figure class="iseeu highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--set-default-version</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ul>
<p>解决 WSL 中 DNS 炸的问题：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> bash -c <span class="string">&#x27;cat &gt; /etc/resolv.conf &lt;&lt;EOF</span></span><br><span class="line"><span class="string">nameserver 223.5.5.5</span></span><br><span class="line"><span class="string">nameserver 119.29.29.29</span></span><br><span class="line"><span class="string">nameserver 8.8.8.8</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure></div>

<h2 id="pwn-相关工具"><a href="#pwn-相关工具" class="headerlink" title="pwn 相关工具"></a>pwn 相关工具</h2><h3 id="clion"><a href="#clion" class="headerlink" title="clion"></a>clion</h3><p><a class="link"   target="_blank" rel="noopener" href="https://www.jetbrains.com/clion/download/#section=linux" >clion<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 是一款 C\C++ 的 IDE ，可以用来阅读 glibc 源码的工具，这款工具对<strong>宏展开</strong>，<strong>符号跳转</strong>，<strong>结构体大小以及成员偏移计算</strong>都有很好的支持。这款软件需要付费使用，不过可以某宝搞一个教育邮箱。</p>
<p>首先用打开 <a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/debug_glibc" >debug_glibc<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 解压后的 glibc  源码，这里有以下几点需要注意：</p>
<ul>
<li>源码在对应版本的 <code>source</code> 目录下。</li>
<li>最好不要使用解压到默认 <code>\glibc</code> 路径下的源码，因为源码调试与行号绑定，阅读源码可能会修改到源码。</li>
<li>这里用 <code>debug_glibc</code> 中的源码是因为这里的源码是编译过的，clion 分析代码需要编译的配置文件。</li>
</ul>
<p>然后这里我们看到 Makefile 没有正确导入：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux%20user%20pwn%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/images/image-20241107232611195.png"
                      alt="image-20241107232611195"
                ><br>在较新版本的 clion 中位于 <code>source</code> 根目录下的 <code>autoreconf</code> 的配置文件 <code>configure.ac</code> 配置有问题，需要改成以下内容（这个主要看版本，有时默认的就好使)：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">GLIBC_PROVIDES dnl See aclocal.m4 <span class="keyword">in</span> the top level <span class="built_in">source</span> directory.</span><br><span class="line"><span class="comment"># Local configure fragment for sysdeps/i386.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We no longer support i386 since it lacks the atomic instructions</span></span><br><span class="line"><span class="comment"># required to implement NPTL threading.</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> <span class="string">&quot;<span class="variable">$config_machine</span>&quot;</span> = i386; <span class="keyword">then</span></span><br><span class="line">  AC_MSG_ERROR([</span><br><span class="line">*** ERROR: Support <span class="keyword">for</span> i386 is deprecated.</span><br><span class="line">*** Please use host i786, i686, i585 or i486.</span><br><span class="line">*** For example: /src/glibc/configure --host=i686-pc-linux-gnu ...<span class="string">&quot;])</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># The GNU C Library can&#x27;t be built for i386.  There are several reasons for</span></span><br><span class="line"><span class="string"># this restriction.  The primary reason is that i386 lacks the atomic</span></span><br><span class="line"><span class="string"># operations required to support the current NPTL implementation.  While it is</span></span><br><span class="line"><span class="string"># possible that such atomic operations could be emulated in the kernel to date</span></span><br><span class="line"><span class="string"># no such work has been done to enable this.  Even with NPTL disabled you still</span></span><br><span class="line"><span class="string"># have no atomic.h implementation.  Given the declining use of i386 we disable</span></span><br><span class="line"><span class="string"># support for building with `-march=i386&#x27; or `-mcpu=i386.&#x27; We don&#x27;t explicitly</span></span><br><span class="line"><span class="string"># check for i386, instead we make sure the compiler has support for inlining</span></span><br><span class="line"><span class="string"># the builtin __sync_val_compare_and_swap. If it does then we should have no</span></span><br><span class="line"><span class="string"># problem building for i386.</span></span><br><span class="line"><span class="string">LIBC_COMPILER_BUILTIN_INLINED(</span></span><br><span class="line"><span class="string">  [__sync_val_compare_and_swap],</span></span><br><span class="line"><span class="string">  [int a, b, c; __sync_val_compare_and_swap (&amp;a, b, c);],</span></span><br><span class="line"><span class="string">  [-O0],</span></span><br><span class="line"><span class="string">  [libc_cv_unsupported_i386=no],</span></span><br><span class="line"><span class="string">  [AC_MSG_ERROR([</span></span><br><span class="line"><span class="string">*** Building with -march=i386/-mcpu=i386 is not supported.</span></span><br><span class="line"><span class="string">*** Please use host i786, i686, i586, or i486.</span></span><br><span class="line"><span class="string">*** For example: /source/glibc/configure CFLAGS=&#x27;-O2 -march=i686&#x27; ...])])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">dnl Check whether asm supports Intel MPX</span></span><br><span class="line"><span class="string">AC_CACHE_CHECK(for Intel MPX support, libc_cv_asm_mpx, [dnl</span></span><br><span class="line"><span class="string">cat &gt; conftest.s &lt;&lt;\EOF</span></span><br><span class="line"><span class="string">        bndmov %bnd0,(%esp)</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="string">if AC_TRY_COMMAND(<span class="variable">$&#123;CC-cc&#125;</span> -c <span class="variable">$ASFLAGS</span> conftest.s 1&gt;&amp;AS_MESSAGE_LOG_FD); then</span></span><br><span class="line"><span class="string">  libc_cv_asm_mpx=yes</span></span><br><span class="line"><span class="string">else</span></span><br><span class="line"><span class="string">  libc_cv_asm_mpx=no</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string">rm -f conftest*])</span></span><br><span class="line"><span class="string">if test <span class="variable">$libc_cv_asm_mpx</span> == yes; then</span></span><br><span class="line"><span class="string">  AC_DEFINE(HAVE_MPX_SUPPORT)</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">AC_DEFINE(USE_REGPARMS)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">dnl It is always possible to access static and hidden symbols in an</span></span><br><span class="line"><span class="string">dnl position independent way.</span></span><br><span class="line"><span class="string">AC_DEFINE(PI_STATIC_AND_HIDDEN)</span></span><br></pre></td></tr></table></figure></div>

<p>另外还需要右键 Makefile 设置在命令后面添加 <code>--disable-sanity-checks</code> 。另外构建目标要填 <code>all</code> ，否则 clion 分析的源码的不全。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux%20user%20pwn%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/images/image-20241107232825793.png"
                      alt="image-20241107232825793"
                ><br>完整预配置命令如下：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># GNU Autotools template, feel free to customize.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="built_in">which</span> autoreconf &gt;/dev/null &amp;&amp; autoreconf --install --force --verbose <span class="string">&quot;<span class="variable">$&#123;PROJECT_DIR:-..&#125;</span>&quot;</span> 2&gt;&amp;1; /bin/sh <span class="string">&quot;<span class="variable">$&#123;PROJECT_DIR:-..&#125;</span>/configure&quot;</span> --disable-sanity-checks</span><br></pre></td></tr></table></figure></div>

<p>之后右键重新加载 Makefile 项目。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux%20user%20pwn%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/images/image-20241107232847285.png"
                      alt="image-20241107232847285"
                ><br>不勾选清理项目。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux%20user%20pwn%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/images/image-20241107232907035.png"
                      alt="image-20241107232907035"
                ><br>如果最后这样说明导入成功，之后耐心等待项目导入完毕即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux%20user%20pwn%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/images/image-20241107232925754.png"
                      alt="image-20241107232925754"
                ></p>
<h3 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install gdb gdb-multiarch</span><br></pre></td></tr></table></figure></div>

<p>主要有 pwndbg，peda，gef ，这里我常用的是 pwndbg 。对于一些版本过于古老导致环境装不上的可以尝试一下 peda 。</p>
<p>先将三个项目的代码都拉取下来。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/longld/peda.git</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/pwndbg/pwndbg.git</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/hugsy/gef.git</span><br></pre></td></tr></table></figure></div>

<p>pwndbg 需要运行初始化脚本。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> pwndbg</span><br><span class="line">./setup.sh</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><code>setup.sh</code> 慢&#x2F;超时主要是两段：</p>
<ol>
<li><code>pip install uv</code> 默认去 <code>pypi.org</code> 拉 20+MB 的 wheel，在国内经常很慢；清华 TUNA 这类镜像可以用 <code>.../simple</code> 来加速（<code>simple</code> 不能少，而且要用 https）。</li>
<li>后面的 <code>uv sync</code> 也默认走 PyPI；而且 <strong>uv 不会自动沿用 pip 的镜像配置</strong>，需要单独给 uv 配 index（例如 <code>UV_DEFAULT_INDEX</code> &#x2F; <code>UV_INDEX_URL</code>），并且可以通过 <code>UV_HTTP_TIMEOUT</code> &#x2F; <code>UV_HTTP_RETRIES</code> 调大超时与重试来缓解慢网超时。</li>
</ol>
<p>下面是把 <code>setup.sh</code> 改成<strong>支持一键使用国内 PyPI 镜像</strong>的完整版本（同时把一开始那个 “Error: ‘uv’ binary not found.” 的噪音也抑制掉了；它本来只是 <code>common.sh</code> 早于 venv 创建而已，不是致命错误）。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------------------</span></span><br><span class="line"><span class="comment"># Pwndbg dev setup helper (patched for CN mirrors)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># New flags:</span></span><br><span class="line"><span class="comment">#   --cn                Use a China-friendly PyPI mirror for BOTH pip (uv install) and uv (uv sync)</span></span><br><span class="line"><span class="comment">#   --pypi-mirror URL   Override the PyPI/simple index URL (works with --cn too)</span></span><br><span class="line"><span class="comment">#   --cn-apt            (Ubuntu only) Switch archive.ubuntu.com -&gt; a CN Ubuntu mirror (backup first)</span></span><br><span class="line"><span class="comment">#   --cn-apt-security   (Ubuntu only) Also switch security.ubuntu.com -&gt; the CN mirror (NOT recommended on prod)</span></span><br><span class="line"><span class="comment">#   --apt-mirror URL    Override the Ubuntu mirror base (Ubuntu only; used with --cn-apt*)</span></span><br><span class="line"><span class="comment">#   --update            Same as upstream: do not touch ~/.gdbinit</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># You can also configure mirrors via environment variables:</span></span><br><span class="line"><span class="comment">#   PWNDBG_PYPI_MIRROR=&quot;https://pypi.tuna.tsinghua.edu.cn/simple&quot;</span></span><br><span class="line"><span class="comment">#   PWNDBG_APT_MIRROR=&quot;https://mirrors.tuna.tsinghua.edu.cn/ubuntu&quot;</span></span><br><span class="line"><span class="comment">#   UV_HTTP_TIMEOUT=600   UV_HTTP_RETRIES=10  (optional)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># -----------------------------</span></span><br><span class="line"></span><br><span class="line">SCRIPT_DIR=<span class="string">&quot;<span class="subst">$(cd <span class="string">&quot;<span class="subst">$(dirname <span class="string">&quot;<span class="variable">$0</span>&quot;</span>)</span>&quot;</span> &amp;&amp; pwd)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The upstream scripts/common.sh prints &quot;Error: &#x27;uv&#x27; binary not found.&quot; before we create the venv.</span></span><br><span class="line"><span class="comment"># That&#x27;s harmless but confusing. We temporarily set PWNDBG_NO_UV=1 while sourcing, to silence it.</span></span><br><span class="line">__OLD_PWNDBG_NO_UV=<span class="string">&quot;<span class="variable">$&#123;PWNDBG_NO_UV-&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">export</span> PWNDBG_NO_UV=1</span><br><span class="line"><span class="comment"># shellcheck source=/dev/null</span></span><br><span class="line"><span class="built_in">source</span> <span class="string">&quot;<span class="variable">$&#123;SCRIPT_DIR&#125;</span>/scripts/common.sh&quot;</span></span><br><span class="line"><span class="keyword">if</span> [[ -n <span class="string">&quot;<span class="variable">$&#123;__OLD_PWNDBG_NO_UV&#125;</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">export</span> PWNDBG_NO_UV=<span class="string">&quot;<span class="variable">$&#123;__OLD_PWNDBG_NO_UV&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">unset</span> PWNDBG_NO_UV</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">unset</span> __OLD_PWNDBG_NO_UV</span><br><span class="line"></span><br><span class="line"><span class="comment"># If we are root in a container and `sudo` doesn&#x27;t exist, overwrite sudo with a passthrough.</span></span><br><span class="line"><span class="keyword">if</span> ! <span class="built_in">hash</span> <span class="built_in">sudo</span> 2&gt; /dev/null &amp;&amp; <span class="built_in">whoami</span> | grep -q root; <span class="keyword">then</span></span><br><span class="line">    <span class="function"><span class="title">sudo</span></span>() &#123; <span class="variable">$&#123;*&#125;</span>; &#125;</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Helper functions</span></span><br><span class="line"><span class="function"><span class="title">linux</span></span>() &#123; <span class="built_in">uname</span> | grep -iqs Linux; &#125;</span><br><span class="line"><span class="function"><span class="title">osx</span></span>()   &#123; <span class="built_in">uname</span> | grep -iqs Darwin; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------------------</span></span><br><span class="line"><span class="comment"># Mirror helpers (CN-friendly)</span></span><br><span class="line"><span class="comment"># -----------------------------</span></span><br><span class="line"></span><br><span class="line">DEFAULT_CN_PYPI_MIRROR=<span class="string">&quot;https://pypi.tuna.tsinghua.edu.cn/simple&quot;</span></span><br><span class="line">DEFAULT_CN_UBUNTU_MIRROR=<span class="string">&quot;https://mirrors.tuna.tsinghua.edu.cn/ubuntu&quot;</span></span><br><span class="line"></span><br><span class="line">USE_CN_MIRROR=0</span><br><span class="line">USE_CN_APT=0</span><br><span class="line">USE_CN_APT_SECURITY=0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Allow overriding via environment variables</span></span><br><span class="line">PWNDBG_PYPI_MIRROR=<span class="string">&quot;<span class="variable">$&#123;PWNDBG_PYPI_MIRROR-&#125;</span>&quot;</span></span><br><span class="line">PWNDBG_APT_MIRROR=<span class="string">&quot;<span class="variable">$&#123;PWNDBG_APT_MIRROR-&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Derived pip options (only used for installing uv with pip)</span></span><br><span class="line">PIP_TIMEOUT=<span class="string">&quot;<span class="variable">$&#123;PIP_TIMEOUT-120&#125;</span>&quot;</span></span><br><span class="line">PIP_RETRIES=<span class="string">&quot;<span class="variable">$&#123;PIP_RETRIES-10&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Derived uv options (only used when --cn is enabled unless user sets them externally)</span></span><br><span class="line">UV_HTTP_TIMEOUT_DEFAULT=<span class="string">&quot;<span class="variable">$&#123;UV_HTTP_TIMEOUT-600&#125;</span>&quot;</span></span><br><span class="line">UV_HTTP_RETRIES_DEFAULT=<span class="string">&quot;<span class="variable">$&#123;UV_HTTP_RETRIES-10&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">get_host_from_url</span></span>() &#123;</span><br><span class="line">    <span class="comment"># Extract host from a URL like https://example.com/path -&gt; example.com</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> | sed -E <span class="string">&#x27;s@^[a-zA-Z]+://([^/]+)/?.*$@\1@&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">enable_python_mirror_env</span></span>() &#123;</span><br><span class="line">    <span class="comment"># Configure uv to use a custom index (mirror) + safer timeout/retry defaults.</span></span><br><span class="line">    <span class="comment"># uv supports UV_DEFAULT_INDEX / UV_INDEX_URL and UV_HTTP_TIMEOUT / UV_HTTP_RETRIES.  (Docs: Astral uv)</span></span><br><span class="line">    <span class="built_in">local</span> mirror_url=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">export</span> UV_DEFAULT_INDEX=<span class="string">&quot;<span class="variable">$&#123;mirror_url&#125;</span>&quot;</span></span><br><span class="line">    <span class="comment"># Backwards compatibility for older uv (deprecated but still recognized):</span></span><br><span class="line">    <span class="built_in">export</span> UV_INDEX_URL=<span class="string">&quot;<span class="variable">$&#123;mirror_url&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Avoid random timeouts on slow links</span></span><br><span class="line">    <span class="built_in">export</span> UV_HTTP_TIMEOUT=<span class="string">&quot;<span class="variable">$&#123;UV_HTTP_TIMEOUT_DEFAULT&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">export</span> UV_HTTP_RETRIES=<span class="string">&quot;<span class="variable">$&#123;UV_HTTP_RETRIES_DEFAULT&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># For pip (used only to fetch the &#x27;uv&#x27; wheel into the venv)</span></span><br><span class="line">    <span class="built_in">export</span> PIP_DEFAULT_TIMEOUT=<span class="string">&quot;<span class="variable">$&#123;PIP_TIMEOUT&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">export</span> PIP_DISABLE_PIP_VERSION_CHECK=1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">apply_ubuntu_apt_mirror</span></span>() &#123;</span><br><span class="line">    <span class="comment"># Only for Ubuntu, and only when user explicitly asked via --cn-apt / --cn-apt-security.</span></span><br><span class="line">    <span class="built_in">local</span> mirror_base=<span class="string">&quot;<span class="variable">$1</span>&quot;</span>      <span class="comment"># e.g. https://mirrors.tuna.tsinghua.edu.cn/ubuntu</span></span><br><span class="line">    <span class="built_in">local</span> also_security=<span class="string">&quot;<span class="variable">$2</span>&quot;</span>    <span class="comment"># 0/1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">local</span> files=()</span><br><span class="line">    [[ -f /etc/apt/sources.list ]] &amp;&amp; files+=(<span class="string">&quot;/etc/apt/sources.list&quot;</span>)</span><br><span class="line">    [[ -f /etc/apt/sources.list.d/ubuntu.sources ]] &amp;&amp; files+=(<span class="string">&quot;/etc/apt/sources.list.d/ubuntu.sources&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="variable">$&#123;#files[@]&#125;</span> -eq 0 ]]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;[!] No Ubuntu APT source file found to patch. Skipping APT mirror change.&quot;</span></span><br><span class="line">        <span class="built_in">return</span> 0</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;[*] Applying Ubuntu APT mirror: <span class="variable">$&#123;mirror_base&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$&#123;also_security&#125;</span>&quot;</span> == <span class="string">&quot;1&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;[!] NOTE: You enabled switching *security* updates to the mirror.&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;    Mirrors may lag behind official security updates; consider leaving security.ubuntu.com unchanged on production machines.&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;files[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">        <span class="comment"># Backup once</span></span><br><span class="line">        <span class="keyword">if</span> [[ ! -f <span class="string">&quot;<span class="variable">$&#123;f&#125;</span>.pwndbg.bak&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">sudo</span> <span class="built_in">cp</span> -a <span class="string">&quot;<span class="variable">$&#123;f&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;f&#125;</span>.pwndbg.bak&quot;</span> || <span class="literal">true</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;[*] Backup created: <span class="variable">$&#123;f&#125;</span>.pwndbg.bak&quot;</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Replace archive.ubuntu.com (and regional variants like xx.archive.ubuntu.com)</span></span><br><span class="line">        <span class="built_in">sudo</span> sed -i \</span><br><span class="line">            -e <span class="string">&quot;s@http://archive.ubuntu.com/ubuntu@<span class="variable">$&#123;mirror_base&#125;</span>@g&quot;</span> \</span><br><span class="line">            -e <span class="string">&quot;s@https://archive.ubuntu.com/ubuntu@<span class="variable">$&#123;mirror_base&#125;</span>@g&quot;</span> \</span><br><span class="line">            -e <span class="string">&quot;s@http://[a-z][a-z]\\.archive.ubuntu.com/ubuntu@<span class="variable">$&#123;mirror_base&#125;</span>@g&quot;</span> \</span><br><span class="line">            -e <span class="string">&quot;s@https://[a-z][a-z]\\.archive.ubuntu.com/ubuntu@<span class="variable">$&#123;mirror_base&#125;</span>@g&quot;</span> \</span><br><span class="line">            <span class="string">&quot;<span class="variable">$&#123;f&#125;</span>&quot;</span> || <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$&#123;also_security&#125;</span>&quot;</span> == <span class="string">&quot;1&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">sudo</span> sed -i \</span><br><span class="line">                -e <span class="string">&quot;s@http://security.ubuntu.com/ubuntu@<span class="variable">$&#123;mirror_base&#125;</span>@g&quot;</span> \</span><br><span class="line">                -e <span class="string">&quot;s@https://security.ubuntu.com/ubuntu@<span class="variable">$&#123;mirror_base&#125;</span>@g&quot;</span> \</span><br><span class="line">                <span class="string">&quot;<span class="variable">$&#123;f&#125;</span>&quot;</span> || <span class="literal">true</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------------------</span></span><br><span class="line"><span class="comment"># Package manager installers</span></span><br><span class="line"><span class="comment"># -----------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">install_apt</span></span>() &#123;</span><br><span class="line">    <span class="built_in">sudo</span> apt-get update || <span class="literal">true</span></span><br><span class="line">    <span class="built_in">sudo</span> apt-get install -y git gdb gdbserver python3-dev python3-venv python3-setuptools</span><br><span class="line">    <span class="built_in">sudo</span> apt-get install -y libc6-dbg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">install_dnf</span></span>() &#123;</span><br><span class="line">    <span class="built_in">sudo</span> dnf update || <span class="literal">true</span></span><br><span class="line">    <span class="built_in">sudo</span> dnf -y install git gdb gdb-gdbserver python3-devel</span><br><span class="line">    <span class="built_in">sudo</span> dnf -y debuginfo-install glibc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">install_xbps</span></span>() &#123;</span><br><span class="line">    <span class="built_in">sudo</span> xbps-install -Su</span><br><span class="line">    <span class="built_in">sudo</span> xbps-install -Sy gdb gcc python-devel python3-devel glibc-devel make curl</span><br><span class="line">    <span class="built_in">sudo</span> xbps-install -Sy glibc-dbg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">install_swupd</span></span>() &#123;</span><br><span class="line">    <span class="built_in">sudo</span> swupd update || <span class="literal">true</span></span><br><span class="line">    <span class="built_in">sudo</span> swupd bundle-add gdb python3-basic make c-basic curl</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">install_zypper</span></span>() &#123;</span><br><span class="line">    <span class="built_in">sudo</span> zypper mr -e repo-oss-debug || <span class="built_in">sudo</span> zypper mr -e repo-debug</span><br><span class="line">    <span class="built_in">sudo</span> zypper refresh || <span class="literal">true</span></span><br><span class="line">    <span class="built_in">sudo</span> zypper install -y gdb gdbserver python-devel python3-devel glib2-devel make glibc-debuginfo curl</span><br><span class="line">    <span class="built_in">sudo</span> zypper install -y python2-pip || <span class="literal">true</span> <span class="comment"># skip py2 installation if it doesn&#x27;t exist</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">uname</span> -m | grep -q x86_64; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">sudo</span> zypper install -y glibc-32bit-debuginfo || <span class="literal">true</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">install_emerge</span></span>() &#123;</span><br><span class="line">    <span class="built_in">sudo</span> emerge --oneshot --deep --newuse --changed-use --changed-deps dev-lang/python dev-debug/gdb</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">install_oma</span></span>() &#123;</span><br><span class="line">    <span class="built_in">sudo</span> oma refresh || <span class="literal">true</span></span><br><span class="line">    <span class="built_in">sudo</span> oma install -y gdb python-3 glib make glibc-dbg curl</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">uname</span> -m | grep -q x86_64; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">sudo</span> oma install -y glibc+32-dbg || <span class="literal">true</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">install_pacman</span></span>() &#123;</span><br><span class="line">    <span class="built_in">read</span> -p <span class="string">&quot;Do you want to do a full system update? (y/n) [n] &quot;</span> answer</span><br><span class="line">    <span class="comment"># user want to perform a full system upgrade</span></span><br><span class="line">    answer=<span class="variable">$&#123;answer:-n&#125;</span> <span class="comment"># n is default</span></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$answer</span>&quot;</span> == <span class="string">&quot;y&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">sudo</span> pacman -Syu || <span class="literal">true</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">sudo</span> pacman -S --noconfirm --needed git gdb python <span class="built_in">which</span> debuginfod curl</span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$UPDATE_MODE</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> ! grep -qs <span class="string">&quot;^set debuginfod enabled on&quot;</span> ~/.gdbinit; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;set debuginfod enabled on&quot;</span> &gt;&gt; ~/.gdbinit</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;[*] Added &#x27;set debuginfod enabled on&#x27; to ~/.gdbinit&quot;</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">install_freebsd</span></span>() &#123;</span><br><span class="line">    <span class="built_in">sudo</span> pkg install git gdb python py39-pip cmake gmake curl</span><br><span class="line">    <span class="built_in">which</span> rustc || <span class="built_in">sudo</span> pkg install rust</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">usage</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Usage: <span class="variable">$0</span> [--update] [--cn] [--pypi-mirror URL] [--cn-apt] [--cn-apt-security] [--apt-mirror URL]&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;  --cn                Use a CN PyPI mirror for pip+uv (default: <span class="variable">$&#123;DEFAULT_CN_PYPI_MIRROR&#125;</span>)&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;  --pypi-mirror URL    Override the PyPI/simple index URL used for --cn&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;  --cn-apt             (Ubuntu) Switch archive.ubuntu.com -&gt; CN Ubuntu mirror (backup first)&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;  --cn-apt-security    (Ubuntu) Also switch security.ubuntu.com -&gt; mirror (NOT recommended on prod)&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;  --apt-mirror URL     Override Ubuntu mirror base (default: <span class="variable">$&#123;DEFAULT_CN_UBUNTU_MIRROR&#125;</span>)&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;  --update             Install/update deps without checking ~/.gdbinit&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Env vars (optional):&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;  PWNDBG_PYPI_MIRROR, PWNDBG_APT_MIRROR, UV_HTTP_TIMEOUT, UV_HTTP_RETRIES, PIP_TIMEOUT, PIP_RETRIES&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UPDATE_MODE=</span><br><span class="line"><span class="keyword">while</span> [[ <span class="variable">$#</span> -gt 0 ]]; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">        --update)</span><br><span class="line">            UPDATE_MODE=1</span><br><span class="line">            <span class="built_in">shift</span></span><br><span class="line">            ;;</span><br><span class="line">        --cn)</span><br><span class="line">            USE_CN_MIRROR=1</span><br><span class="line">            <span class="built_in">shift</span></span><br><span class="line">            ;;</span><br><span class="line">        --pypi-mirror)</span><br><span class="line">            <span class="keyword">if</span> [[ <span class="variable">$#</span> -lt 2 ]]; <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;Missing value for --pypi-mirror&quot;</span></span><br><span class="line">                <span class="built_in">exit</span> 1</span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">            PWNDBG_PYPI_MIRROR=<span class="string">&quot;<span class="variable">$2</span>&quot;</span></span><br><span class="line">            <span class="built_in">shift</span> 2</span><br><span class="line">            ;;</span><br><span class="line">        --cn-apt)</span><br><span class="line">            USE_CN_APT=1</span><br><span class="line">            <span class="built_in">shift</span></span><br><span class="line">            ;;</span><br><span class="line">        --cn-apt-security)</span><br><span class="line">            USE_CN_APT=1</span><br><span class="line">            USE_CN_APT_SECURITY=1</span><br><span class="line">            <span class="built_in">shift</span></span><br><span class="line">            ;;</span><br><span class="line">        --apt-mirror)</span><br><span class="line">            <span class="keyword">if</span> [[ <span class="variable">$#</span> -lt 2 ]]; <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;Missing value for --apt-mirror&quot;</span></span><br><span class="line">                <span class="built_in">exit</span> 1</span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">            PWNDBG_APT_MIRROR=<span class="string">&quot;<span class="variable">$2</span>&quot;</span></span><br><span class="line">            <span class="built_in">shift</span> 2</span><br><span class="line">            ;;</span><br><span class="line">        -h | --<span class="built_in">help</span>)</span><br><span class="line">            usage</span><br><span class="line">            <span class="built_in">exit</span> 0</span><br><span class="line">            ;;</span><br><span class="line">        *)</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;Unknown argument: <span class="variable">$1</span>&quot;</span></span><br><span class="line">            usage</span><br><span class="line">            <span class="built_in">exit</span> 1</span><br><span class="line">            ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">PYTHON=<span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> osx; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Not supported on macOS. Please use one of the alternative methods listed at:&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;https://pwndbg.re/dev/contributing/setup-pwndbg-dev/&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Decide mirror URLs</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$&#123;USE_CN_MIRROR&#125;</span>&quot;</span> == <span class="string">&quot;1&quot;</span> &amp;&amp; -z <span class="string">&quot;<span class="variable">$&#123;PWNDBG_PYPI_MIRROR&#125;</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    PWNDBG_PYPI_MIRROR=<span class="string">&quot;<span class="variable">$&#123;DEFAULT_CN_PYPI_MIRROR&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$&#123;USE_CN_APT&#125;</span>&quot;</span> == <span class="string">&quot;1&quot;</span> &amp;&amp; -z <span class="string">&quot;<span class="variable">$&#123;PWNDBG_APT_MIRROR&#125;</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    PWNDBG_APT_MIRROR=<span class="string">&quot;<span class="variable">$&#123;DEFAULT_CN_UBUNTU_MIRROR&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Apply mirror env early (affects pip + uv later)</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$&#123;USE_CN_MIRROR&#125;</span>&quot;</span> == <span class="string">&quot;1&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;[*] Using CN PyPI mirror for pip+uv: <span class="variable">$&#123;PWNDBG_PYPI_MIRROR&#125;</span>&quot;</span></span><br><span class="line">    enable_python_mirror_env <span class="string">&quot;<span class="variable">$&#123;PWNDBG_PYPI_MIRROR&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> linux; <span class="keyword">then</span></span><br><span class="line">    distro=$(grep <span class="string">&quot;^ID=&quot;</span> /etc/os-release | <span class="built_in">cut</span> -d<span class="string">&#x27;=&#x27;</span> -f2 | sed -e <span class="string">&#x27;s/\&quot;//g&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$distro</span> <span class="keyword">in</span></span><br><span class="line">        <span class="string">&quot;ubuntu&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$&#123;USE_CN_APT&#125;</span>&quot;</span> == <span class="string">&quot;1&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">                apply_ubuntu_apt_mirror <span class="string">&quot;<span class="variable">$&#123;PWNDBG_APT_MIRROR&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;USE_CN_APT_SECURITY&#125;</span>&quot;</span></span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">            install_apt</span><br><span class="line">            ;;</span><br><span class="line">        <span class="string">&quot;fedora&quot;</span>)</span><br><span class="line">            install_dnf</span><br><span class="line">            ;;</span><br><span class="line">        <span class="string">&quot;clear-linux-os&quot;</span>)</span><br><span class="line">            install_swupd</span><br><span class="line">            ;;</span><br><span class="line">        <span class="string">&quot;opensuse-leap&quot;</span> | <span class="string">&quot;opensuse-tumbleweed&quot;</span>)</span><br><span class="line">            install_zypper</span><br><span class="line">            ;;</span><br><span class="line">        <span class="string">&quot;arch&quot;</span> | <span class="string">&quot;archarm&quot;</span> | <span class="string">&quot;endeavouros&quot;</span> | <span class="string">&quot;manjaro&quot;</span> | <span class="string">&quot;garuda&quot;</span> | <span class="string">&quot;cachyos&quot;</span> | <span class="string">&quot;archcraft&quot;</span> | <span class="string">&quot;artix&quot;</span>)</span><br><span class="line">            install_pacman</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;Logging off and in or conducting a power cycle is required to get debuginfod to work.&quot;</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;Alternatively you can manually set the environment variable: DEBUGINFOD_URLS=https://debuginfod.archlinux.org&quot;</span></span><br><span class="line">            ;;</span><br><span class="line">        <span class="string">&quot;void&quot;</span>)</span><br><span class="line">            install_xbps</span><br><span class="line">            ;;</span><br><span class="line">        <span class="string">&quot;gentoo&quot;</span>)</span><br><span class="line">            install_emerge</span><br><span class="line">            ;;</span><br><span class="line">        <span class="string">&quot;freebsd&quot;</span>)</span><br><span class="line">            install_freebsd</span><br><span class="line">            ;;</span><br><span class="line">        <span class="string">&quot;aosc&quot;</span>)</span><br><span class="line">            install_oma</span><br><span class="line">            ;;</span><br><span class="line">        *) <span class="comment"># we can add more install command for each distros.</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;\&quot;<span class="variable">$distro</span>\&quot; is not supported distro. Will search for &#x27;apt&#x27;, &#x27;dnf&#x27; or &#x27;pacman&#x27; package managers.&quot;</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">hash</span> apt; <span class="keyword">then</span></span><br><span class="line">                install_apt</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">hash</span> dnf; <span class="keyword">then</span></span><br><span class="line">                install_dnf</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">hash</span> pacman; <span class="keyword">then</span></span><br><span class="line">                install_pacman</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;\&quot;<span class="variable">$distro</span>\&quot; is not supported and your distro don&#x27;t have a package manager that we support currently.&quot;</span></span><br><span class="line">                <span class="built_in">exit</span> 2</span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">            ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ! <span class="built_in">hash</span> gdb; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Could not find gdb in <span class="variable">$PATH</span>&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 3</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Find the Python used in compilation by GDB.</span></span><br><span class="line">PYVER=$(gdb -batch -q --nx -ex <span class="string">&#x27;pi import sysconfig; print(sysconfig.get_config_var(&quot;VERSION&quot;))&#x27;</span>)</span><br><span class="line">PYTHON=$(gdb -batch -q --nx -ex <span class="string">&#x27;pi import sysconfig; print(sysconfig.get_config_vars().get(&quot;EXENAME&quot;, sysconfig.get_config_var(&quot;BINDIR&quot;)+&quot;/python&quot;+sysconfig.get_config_var(&quot;VERSION&quot;)+sysconfig.get_config_var(&quot;EXE&quot;)))&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! -x <span class="string">&quot;<span class="variable">$PYTHON</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Error: &#x27;<span class="variable">$PYTHON</span>&#x27; does not exist or is not executable.&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;It looks like GDB is using a different Python version than the one installed via the package manager.&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Possible solutions:&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;  1. Try installing &#x27;python<span class="variable">$PYVER</span>&#x27; manually using your package manager.&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;     Example (for Debian/Ubuntu/Kali): &#x27;sudo apt install python<span class="variable">$PYVER</span>&#x27;&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;     Example (for Fedora/RHEL): &#x27;sudo dnf install python<span class="variable">$PYVER</span>&#x27;&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;  2. Verify your GDB configuration and ensure it supports the correct Python version.&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;After making the necessary changes, rerun ./setup.sh&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Check python version supported: &lt;3.10, 3.99&gt;</span></span><br><span class="line">is_supported=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$PYVER</span>&quot;</span> | grep -E <span class="string">&#x27;3\.(10|11|12|13|14|15|16|17|18|19|[2-9][0-9])&#x27;</span> || <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">if</span> [[ -z <span class="string">&quot;<span class="variable">$is_supported</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Your system has unsupported python version. Please use older pwndbg release:&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&#x27;git checkout 2024.08.29&#x27; - python3.8, python3.9&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&#x27;git checkout 2023.07.17&#x27; - python3.6, python3.7&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 4</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the python virtual environment</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Creating virtualenv in path: <span class="variable">$&#123;PWNDBG_VENV_PATH&#125;</span>&quot;</span></span><br><span class="line"><span class="variable">$&#123;PYTHON&#125;</span> -m venv -- <span class="variable">$&#123;PWNDBG_VENV_PATH&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Activate venv</span></span><br><span class="line"><span class="comment"># shellcheck source=/dev/null</span></span><br><span class="line"><span class="built_in">source</span> <span class="string">&quot;<span class="variable">$&#123;PWNDBG_VENV_PATH&#125;</span>/bin/activate&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Install uv inside the venv (use mirror if enabled)</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Installing uv into venv...&quot;</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$&#123;USE_CN_MIRROR&#125;</span>&quot;</span> == <span class="string">&quot;1&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    python -m pip install --upgrade uv \</span><br><span class="line">        --index-url <span class="string">&quot;<span class="variable">$&#123;PWNDBG_PYPI_MIRROR&#125;</span>&quot;</span> \</span><br><span class="line">        --<span class="built_in">timeout</span> <span class="string">&quot;<span class="variable">$&#123;PIP_TIMEOUT&#125;</span>&quot;</span> \</span><br><span class="line">        --retries <span class="string">&quot;<span class="variable">$&#123;PIP_RETRIES&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    python -m pip install --upgrade uv</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">UV_BIN=<span class="string">&quot;<span class="variable">$&#123;PWNDBG_VENV_PATH&#125;</span>/bin/uv&quot;</span></span><br><span class="line"><span class="keyword">if</span> [[ ! -x <span class="string">&quot;<span class="variable">$&#123;UV_BIN&#125;</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># fallback, but normally venv/bin/uv should exist</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">command</span> -v uv &gt; /dev/null 2&gt;&amp;1; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Warning: Falling back to &#x27;uv&#x27; found in PATH.&quot;</span> &gt;&amp;2</span><br><span class="line">        UV_BIN=<span class="string">&quot;<span class="subst">$(command -v uv)</span>&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Error: &#x27;uv&#x27; not found after installation. Check your pip/venv setup.&quot;</span> &gt;&amp;2</span><br><span class="line">        <span class="built_in">exit</span> 5</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Install dependencies</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Installing dependencies..&quot;</span></span><br><span class="line"><span class="comment"># uv will use UV_DEFAULT_INDEX / UV_HTTP_TIMEOUT / UV_HTTP_RETRIES if exported above.</span></span><br><span class="line"><span class="string">&quot;<span class="variable">$&#123;UV_BIN&#125;</span>&quot;</span> <span class="built_in">sync</span> --extra gdb --extra lldb --quiet</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$UPDATE_MODE</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> grep -qs <span class="string">&#x27;^[^#]*source.*pwndbg/gdbinit.py&#x27;</span> ~/.gdbinit; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&#x27;Pwndbg is already sourced in ~/.gdbinit .&#x27;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment"># Load Pwndbg into GDB on every launch.</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;source <span class="variable">$PWD</span>/gdbinit.py&quot;</span> &gt;&gt; ~/.gdbinit</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;[*] Added &#x27;source <span class="variable">$PWD</span>/gdbinit.py&#x27; to ~/.gdbinit so that Pwndbg will be loaded on every launch of GDB.&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Please set the PWNDBG_NO_AUTOUPDATE environment variable to any value&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;to disable the automatic updating of dependencies when Pwndbg is loaded.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></div>

<p>用法示例：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1) 只把 pip/uv 的 PyPI 下载切到国内镜像（推荐先用这个）</span></span><br><span class="line">./setup.sh --cn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2) 自己指定 PyPI 镜像（例如阿里云）</span></span><br><span class="line">./setup.sh --cn --pypi-mirror https://mirrors.aliyun.com/pypi/simple/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3) （可选）Ubuntu APT 也换源：只换 archive，不动 security（更稳妥）</span></span><br><span class="line">./setup.sh --cn --cn-apt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4) （不建议生产机）连 security 源也换到镜像</span></span><br><span class="line">./setup.sh --cn --cn-apt-security</span><br></pre></td></tr></table></figure></div>
</blockquote>
<p>gdb 在启动的时候会读取当前用户的主目录的 <code>.gdbinit</code> 文件进行 gdb 插件的初始化，通常来说使用默认的配置即可：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /home/sky123/tools/pwndbg/gdbinit.py </span><br><span class="line"><span class="comment">#source /home/sky123/tools/peda/peda.py</span></span><br><span class="line"><span class="comment">#source /home/sky123/tools/gef/gef.py</span></span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p>以普通用权限和管理员权限启动 gdb 时读取的 <code>.gdbinit</code> 文件的路径是不同的，普通权限读取的是 <code>/home/&lt;username&gt;/.gdbinit</code> 而管理员权限读取的是 <code>/root/.gdbinit</code> 。</p>

    </div>
  </div>

<blockquote>
<p>pwndbg 安装 ghidra 插件可以支持代码反编译（<del>虽然没啥用</del> ）</p>
<ul>
<li><p>安装 <code>r2pipe</code> 库</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install r2pipe</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>下载安装 radere2 项目</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/radareorg/radare2.git</span><br><span class="line"><span class="built_in">cd</span> radare2</span><br><span class="line"><span class="built_in">sudo</span> sys/install.sh</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>下载编译安装 r2ghidra 项目</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/radareorg/r2ghidra.git</span><br><span class="line"><span class="built_in">cd</span> r2ghidra</span><br><span class="line"><span class="built_in">sudo</span> ./preconfigure</span><br><span class="line"><span class="built_in">sudo</span> ./configure</span><br><span class="line"><span class="built_in">sudo</span> make -j16</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br></pre></td></tr></table></figure></div></li>
</ul>
</blockquote>
<p>没有调试插件的时候可以使用下面这套命令应急。最好放到 <code>~/.gdbinit</code> 文件，如果在命令行中使用则只能逐行粘贴。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> pagination off</span><br><span class="line"><span class="built_in">set</span> confirm off</span><br><span class="line"><span class="built_in">set</span> disassembly-flavor intel</span><br><span class="line"><span class="built_in">set</span> <span class="built_in">print</span> pretty on</span><br><span class="line"></span><br><span class="line">define context</span><br><span class="line">    <span class="built_in">echo</span> \n----[ REGISTERS ]----\n</span><br><span class="line">    info registers</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">echo</span> \n----[ CODE / RIP ]----\n</span><br><span class="line">    x/10i <span class="variable">$pc</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> \n----[ STACK TOP ]----\n</span><br><span class="line">    x/10gx <span class="variable">$rsp</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">define hook-stop</span><br><span class="line">    context</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> [gdb] simple pwndbg-like context enabled.\n</span><br></pre></td></tr></table></figure></div>

<h3 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h3><p>注意我这里的 pwntools 是 python2 版本的，需要指定为 4.9.0 ，因为高版本的 pwntools 已经不支持 python2 了（具体来说是高版本的 pwntools 必须依赖 unicorn 2.x.x ，而 unicorn 2.x.x 只支持 python3）。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pwntools==4.10.0 -i https://pypi.tuna.tsinghua.edu.cn/simple </span><br></pre></td></tr></table></figure></div>

<p>如果已经装了 pwntools 需要先卸载干净再重新安装，否则更改版本无效（最好不带 <code>sudo</code> 也来一遍确保卸载干净）。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pip2 uninstall pwntools</span><br><span class="line"><span class="built_in">sudo</span> pip2 uninstall unicorn</span><br></pre></td></tr></table></figure></div>

<p>这样安装的 pwntools 的 plt 功可能无法正常使用，需要手动安装 Unicorn 库。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install unicorn==1.0.3 -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure></div>

<p>当然这样做的代价是一些特殊架构老版本的 pwntools 不支持，这时候最好换 python3 的 pwntools 。</p>
<h3 id="gadget-搜索工具"><a href="#gadget-搜索工具" class="headerlink" title="gadget 搜索工具"></a>gadget 搜索工具</h3><h4 id="ROPgdbget"><a href="#ROPgdbget" class="headerlink" title="ROPgdbget"></a>ROPgdbget</h4><p>安装：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/JonathanSalwan/ROPgadget.git</span><br><span class="line"><span class="built_in">cd</span> ROPgadget</span><br><span class="line"><span class="built_in">sudo</span> python3 setup.py install</span><br></pre></td></tr></table></figure></div>

<p>使用：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary ntdll.dll &gt; rop</span><br></pre></td></tr></table></figure></div>

<p>有时候 <code>ROPgadget</code> 会出现如下报错：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary init_60D_fwf &gt; rop</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/usr/local/bin/ROPgadget&quot;</span>, line 12, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    ropgadget.main()</span><br><span class="line">  File <span class="string">&quot;/home/sky123/.local/lib/python3.10/site-packages/ropgadget/__init__.py&quot;</span>, line 30, <span class="keyword">in</span> main</span><br><span class="line">    sys.exit(0 <span class="keyword">if</span> Core(args.getArgs()).analyze() <span class="keyword">else</span> 1)</span><br><span class="line">  File <span class="string">&quot;/home/sky123/.local/lib/python3.10/site-packages/ropgadget/core.py&quot;</span>, line 257, <span class="keyword">in</span> analyze</span><br><span class="line">    self.__getGadgets()</span><br><span class="line">  File <span class="string">&quot;/home/sky123/.local/lib/python3.10/site-packages/ropgadget/core.py&quot;</span>, line 70, <span class="keyword">in</span> __getGadgets</span><br><span class="line">    G = Gadgets(self.__binary, self.__options, self.__offset)</span><br><span class="line">  File <span class="string">&quot;/home/sky123/.local/lib/python3.10/site-packages/ropgadget/gadgets.py&quot;</span>, line 24, <span class="keyword">in</span> __init__</span><br><span class="line">    <span class="keyword">elif</span> self.__arch == CS_ARCH_ARM64:</span><br><span class="line">NameError: name <span class="string">&#x27;CS_ARCH_ARM64&#x27;</span> is not defined. Did you mean: <span class="string">&#x27;CS_ARCH_ARM&#x27;</span>?</span><br></pre></td></tr></table></figure></div>

<p>此时需要重新安装 <code>capstone</code>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pip uninstall capstone</span><br><span class="line"><span class="built_in">sudo</span> pip install capstone</span><br></pre></td></tr></table></figure></div>

<p>如果出现这个报错：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ROPgadget</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/usr/local/bin/ROPgadget&quot;</span>, line 4, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    __import__(<span class="string">&#x27;pkg_resources&#x27;</span>).run_script(<span class="string">&#x27;ROPGadget==7.5&#x27;</span>, <span class="string">&#x27;ROPgadget&#x27;</span>)</span><br><span class="line">  File <span class="string">&quot;/usr/lib/python3/dist-packages/pkg_resources/__init__.py&quot;</span>, line 656, <span class="keyword">in</span> run_script</span><br><span class="line">    self.require(requires)[0].run_script(script_name, ns)</span><br><span class="line">  File <span class="string">&quot;/usr/lib/python3/dist-packages/pkg_resources/__init__.py&quot;</span>, line 1441, <span class="keyword">in</span> run_script</span><br><span class="line">    raise ResolutionError(</span><br><span class="line">pkg_resources.ResolutionError: Script <span class="string">&#x27;scripts/ROPgadget&#x27;</span> not found <span class="keyword">in</span> metadata at <span class="string">&#x27;/home/ubuntu/.local/lib/python3.10/site-packages/ROPGadget-7.5.dist-info&#x27;</span></span><br></pre></td></tr></table></figure></div>

<p>这里需要将 <code>ROPGadget</code> 安装目录下的 <code>script</code> 目录拷贝到 <code>/home/ubuntu/.local/lib/python3.10/site-packages/ROPGadget-7.5.dist-info</code> 中。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ROPGadget</span><br><span class="line">sudo cp -r scripts /home/ubuntu/.local/lib/python3.10/site-packages/ROPGadget-7.5.dist-info</span><br></pre></td></tr></table></figure></div>



<h4 id="ropper"><a href="#ropper" class="headerlink" title="ropper"></a>ropper</h4><p>ropper 可以和 ROPgadget 配合使用，因为有的 gadget 使用 ROPgadget 搜不到，例如 arm32 架构的 Thumb 模式 gadget。</p>
<ul>
<li><p>安装：</p>
<ul>
<li><p>在 pypi 的 <a class="link"   target="_blank" rel="noopener" href="https://pypi.org/project/ropper/#files" >ropper 官网<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>上下载 ropper</p>
</li>
<li><p>运行安装脚本完成 ropper 安装</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> python3 setup.py install</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><p>使用：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ropper --file ./pwn --nocolor &gt; rop</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="one-gadget"><a href="#one-gadget" class="headerlink" title="one_gadget"></a>one_gadget</h4><p>用于搜索 libc 中能够实现 <code>execve(&quot;/bin/sh&quot;, (char *[2]) &#123;&quot;/bin/sh&quot;, NULL&#125;, NULL);</code> 的效果的跳转地址，由于是采用特征匹配的方法，因此只能是在 libc 中查找。</p>
<ul>
<li><p>安装：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install -y ruby ruby-dev</span><br><span class="line"><span class="built_in">sudo</span> gem install one_gadget</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>使用：可以查找到 gadget 地址以及条件限制。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ one_gadget /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">0x50a37 posix_spawn(rsp+0x1c, <span class="string">&quot;/bin/sh&quot;</span>, 0, rbp, rsp+0x60, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rsp &amp; 0xf == 0</span><br><span class="line">  rcx == NULL</span><br><span class="line">  rbp == NULL || (u16)[rbp] == NULL</span><br><span class="line"></span><br><span class="line">0xebcf1 execve(<span class="string">&quot;/bin/sh&quot;</span>, r10, [rbp-0x70])</span><br><span class="line">constraints:</span><br><span class="line">  address rbp-0x78 is writable</span><br><span class="line">  [r10] == NULL || r10 == NULL</span><br><span class="line">  [[rbp-0x70]] == NULL || [rbp-0x70] == NULL</span><br><span class="line"></span><br><span class="line">0xebcf5 execve(<span class="string">&quot;/bin/sh&quot;</span>, r10, rdx)</span><br><span class="line">constraints:</span><br><span class="line">  address rbp-0x78 is writable</span><br><span class="line">  [r10] == NULL || r10 == NULL</span><br><span class="line">  [rdx] == NULL || rdx == NULL</span><br><span class="line"></span><br><span class="line">0xebcf8 execve(<span class="string">&quot;/bin/sh&quot;</span>, rsi, rdx)</span><br><span class="line">constraints:</span><br><span class="line">  address rbp-0x78 is writable</span><br><span class="line">  [rsi] == NULL || rsi == NULL</span><br><span class="line">  [rdx] == NULL || rdx == NULL</span><br></pre></td></tr></table></figure></div>

<p>如果 <code>one_gadget</code> 在一个版本的 Ubuntu 中搜索某一版本的 glibc 的 gadget 出现如下报错可以尝试换另一个版本的 Ubuntu 。貌似是权限问题，可以以 root 权限重新装一下。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux%20user%20pwn%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/images/image-20241107233247289.png"
                      alt="image-20241107233247289"
                ></p>
</li>
</ul>
<h3 id="seccomp-tools"><a href="#seccomp-tools" class="headerlink" title="seccomp-tools"></a>seccomp-tools</h3><p>用于查看和生成程序沙箱规则。</p>
<ul>
<li><p>安装：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> gem install seccomp-tools</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>使用：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seccomp-tools dump ./pwn</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="LibcSearcher"><a href="#LibcSearcher" class="headerlink" title="LibcSearcher"></a>LibcSearcher</h3><p>通过泄露的 libc 中函数的地址来确定 libc 版本。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/lieanu/LibcSearcher.git</span><br><span class="line"><span class="built_in">cd</span> LibcSearcher</span><br><span class="line"><span class="built_in">sudo</span> python3 setup.py install</span><br></pre></td></tr></table></figure></div>

<h3 id="glibc-all-in-one"><a href="#glibc-all-in-one" class="headerlink" title="glibc-all-in-one"></a>glibc-all-in-one</h3><p>临时找 glibc 和 ld 或者编译 glibc 。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/matrix1001/glibc-all-in-one.git</span><br></pre></td></tr></table></figure></div>

<p>更新下载列表：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">➜  glibc-all-in-one ./update_list</span><br><span class="line">[+] Common list has been save to <span class="string">&quot;list&quot;</span></span><br><span class="line">[+] Old-release list has been save to <span class="string">&quot;old_list&quot;</span></span><br><span class="line"></span><br><span class="line">➜  glibc-all-in-one <span class="built_in">cat</span> list</span><br><span class="line">2.23-0ubuntu10_amd64</span><br><span class="line">2.23-0ubuntu10_i386</span><br><span class="line">2.23-0ubuntu11_amd64</span><br><span class="line">2.23-0ubuntu11_i386</span><br><span class="line">2.23-0ubuntu3_amd64</span><br><span class="line">2.23-0ubuntu3_i386</span><br><span class="line">2.27-3ubuntu1_amd64</span><br><span class="line">2.27-3ubuntu1_i386</span><br><span class="line">2.28-0ubuntu1_amd64</span><br><span class="line">2.28-0ubuntu1_i386</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">➜  glibc-all-in-one <span class="built_in">cat</span> old_list</span><br><span class="line">2.21-0ubuntu4.3_amd64</span><br><span class="line">2.21-0ubuntu4.3_amd64</span><br><span class="line">2.21-0ubuntu4_amd64</span><br><span class="line">2.21-0ubuntu4_amd64</span><br><span class="line">2.24-3ubuntu1_amd64</span><br><span class="line">2.24-3ubuntu1_amd64</span><br><span class="line">2.24-3ubuntu2.2_amd64</span><br><span class="line">2.24-3ubuntu2.2_amd64</span><br><span class="line">2.24-9ubuntu2.2_amd64</span><br><span class="line">2.24-9ubuntu2.2_amd64</span><br><span class="line">......</span><br></pre></td></tr></table></figure></div>

<p>下载 libc ，注意要安装解压工具 <code>zstd</code> ，因为下载脚本中用到了。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install zstd</span><br><span class="line"><span class="built_in">cat</span> list |xargs -i ./download &#123;&#125;</span><br><span class="line"><span class="built_in">cat</span> old_list |xargs -i ./download_old &#123;&#125;</span><br></pre></td></tr></table></figure></div>

<p>编译 libc</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ./build [版本例如2.29] [架构例如 i686 amd64]</span><br></pre></td></tr></table></figure></div>

<h3 id="patchelf"><a href="#patchelf" class="headerlink" title="patchelf"></a>patchelf</h3><p>安装：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install patchelf</span><br></pre></td></tr></table></figure></div>

<h3 id="qemu"><a href="#qemu" class="headerlink" title="qemu"></a>qemu</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install qemu-user qemu-system </span><br></pre></td></tr></table></figure></div>

<h1 id="ELF-文件格式"><a href="#ELF-文件格式" class="headerlink" title="ELF 文件格式"></a>ELF 文件格式</h1><p>ELF（Executable and Linkable Format）是一种通用的<strong>目标文件 &#x2F; 可执行文件格式</strong>，是 System V ABI 的一部分，目前在多数类 Unix 系统（Linux、*BSD、Solaris 等）上作为标准的二进制格式，用于：</p>
<ul>
<li>可执行文件（executable）</li>
<li>可重定位目标文件（object file）</li>
<li>共享对象（shared object &#x2F; shared library）</li>
<li>核心转储文件（core dump）</li>
</ul>
<blockquote>
<p>在 ELF&#x2F;ABI 里的 System V ABI 即 <strong>System V Application Binary Interface</strong>，这是一个规范文档，最早是在 UNIX System V &#x2F; SVR4 体系下制定的；</p>
<blockquote>
<p>这里的 UNIX System V 是历史上的 <strong>UNIX System V 操作系统</strong>；</p>
<p>其中 <strong>System V Release 4（SVR4）</strong> 是一个重要版本：</p>
<ul>
<li>把很多特性（包括 ELF 格式、共享库、System V IPC 等）标准化；</li>
<li>影响了后来的很多类 Unix 系统，包括 Solaris、现代 Linux 的很多接口习惯。</li>
</ul>
<p>今天你经常看到的几个词：</p>
<ul>
<li><strong>SysV IPC</strong>：System V 风格的进程间通信（<code>shmget</code> &#x2F; <code>semget</code> &#x2F; <code>msgget</code> 等）；</li>
<li><strong>SysV init</strong>：老式的 <code>/etc/init.d</code> <code>rc*.d</code> 那一套 init 系统；</li>
<li><strong>System V shared libraries</strong>：早期 SysV 提出的共享库机制（后发展为 ELF 动态链接）。</li>
</ul>
<p>这些“SysV”大多就是从那个时代的 UNIX System V 演化来的。</p>
</blockquote>
<p>它定义了很多东西“在二进制层面究竟长啥样”：</p>
<ul>
<li>ELF 文件格式（头、节、程序头、重定位、动态链接等）；</li>
</ul>
<ul>
<li>调用约定（函数参数怎么压栈、寄存器怎么用）；</li>
<li>动态链接行为、重定位类型、符号解析规则；</li>
<li>等等。</li>
</ul>
<p>Linux、glibc、GCC、binutils 这些主流工具链，基本都是：</p>
<ul>
<li>在 <strong>System V ABI</strong> 这套规范的基础上；</li>
<li>再加上一些各自的扩展（比如 <code>.gnu.hash</code>、<code>.eh_frame</code>、TLS、CET 等）。</li>
</ul>
<p>所以当我们说：</p>
<ul>
<li>“System V 风格 ELF”</li>
<li>“遵循 System V ABI 的 x86‑64 Linux”</li>
<li>“System V i386 ABI 规定了 R_386_32 &#x2F; R_386_PC32 等重定位类型”</li>
</ul>
<p>指的就是：</p>
<blockquote>
<p><strong>这是按 System V ABI 那套规则来玩 ELF 和动态链接的</strong>，<br>而不是别的什么私有格式（比如 Windows 的 PE&#x2F;COFF，macOS 的 Mach‑O 等）。</p>
</blockquote>
</blockquote>
<p>ELF 头中的 <code>e_type</code> 字段描述该 ELF 文件的“对象类型”：</p>
<ul>
<li><p><strong><code>ET_REL</code>（1）——可重定位文件（Relocatable file）</strong></p>
<ul>
<li>编译器生成的中间目标文件，一般扩展名为 **<code>.o</code>**。</li>
<li>不能直接执行，必须经过链接器处理，生成 <code>ET_EXEC</code> 或 <code>ET_DYN</code>。</li>
<li><strong>静态库 <code>.a</code> 并不是一种单独的 ELF 类型</strong>，而是一个 <strong>ar 归档文件</strong>，里面打包了多个 <code>ET_REL</code> 的 ELF 目标文件。</li>
</ul>
</li>
<li><p><strong><code>ET_EXEC</code>（2）——可执行文件（Executable file）</strong></p>
<ul>
<li>传统意义上的“普通可执行程序”，装载基址一般是固定的（非 PIE）。</li>
<li>在现代 Linux 上，如果启用 PIE，主程序通常会使用 <code>ET_DYN</code> 而不是 <code>ET_EXEC</code>。</li>
</ul>
</li>
<li><p><strong><code>ET_DYN</code>（3）——共享对象文件（Shared object file）</strong> </p>
<ul>
<li>最典型的是共享库，扩展名通常是 **<code>.so</code>**（例如 <code>libc.so.6</code>）。</li>
<li>同时，现代的 <strong>PIE（Position-Independent Executable）主程序</strong> 也经常是 <code>ET_DYN</code>：本质上就是“可以当主程序启动的共享对象”。</li>
</ul>
</li>
<li><p><strong><code>ET_CORE</code>（4）——核心转储文件（Core file）</strong></p>
<ul>
<li>程序崩溃时，内核生成的内存快照，用于调试。</li>
<li>包含进程地址空间、寄存器等运行时状态。</li>
</ul>
</li>
</ul>
<p>除此之外，还有：</p>
<ul>
<li><code>ET_NONE</code>：无类型 &#x2F; 未定义；</li>
<li><code>ET_LOOS</code> ~ <code>ET_HIOS</code>、<code>ET_LOPROC</code> ~ <code>ET_HIPROC</code>：保留给特定 OS &#x2F; CPU 扩展使用。</li>
</ul>
<p>ELF 规范同时定义了 32 位（<code>ELFCLASS32</code>）和 64 位（<code>ELFCLASS64</code>）两套结构。两者在<strong>整体布局上是兼容的</strong>：</p>
<ul>
<li><p>同样都有：</p>
<ul>
<li>ELF 文件头 <code>Elf32_Ehdr</code> &#x2F; <code>Elf64_Ehdr</code></li>
<li>程序头表 <code>Elf32_Phdr</code> &#x2F; <code>Elf64_Phdr</code></li>
<li>节表 <code>Elf32_Shdr</code> &#x2F; <code>Elf64_Shdr</code></li>
</ul>
</li>
<li><p>大部分结构只是：</p>
<ul>
<li>字段宽度不同（32 位地址 &#x2F; 偏移 VS 64 位地址 &#x2F; 偏移）；</li>
<li>个别字段为保证对齐，顺序略有调整（例如 <code>Elf64_Phdr</code> 中先是 <code>p_type</code>、<code>p_flags</code>，再是 offset &#x2F; addr 等）。</li>
</ul>
</li>
</ul>
<p>在 Linux 系统上，这些结构和相关常量通常由 <code>&lt;elf.h&gt;</code> 提供，头文件路径一般在 <code>/usr/include/elf.h</code> 或 C 库的专用 include 目录中。</p>
<p><code>elf.h</code> 通过 <code>typedef</code> 定义了一组与具体平台无关的基础类型，用来描述 ELF 各种结构体中的字段。不同实现写法略有差别，但主流实现（glibc、Linux 内核、LLVM 等）的定义基本一致：</p>
<table>
<thead>
<tr>
<th>自定义类型</th>
<th>含义（语义）</th>
<th>常见底层类型</th>
<th>长度（字节）</th>
</tr>
</thead>
<tbody><tr>
<td><code>Elf32_Addr</code></td>
<td>32 位地址（虚拟地址）</td>
<td><code>uint32_t</code></td>
<td>4</td>
</tr>
<tr>
<td><code>Elf32_Half</code></td>
<td>16 位无符号整数</td>
<td><code>uint16_t</code></td>
<td>2</td>
</tr>
<tr>
<td><code>Elf32_Off</code></td>
<td>32 位文件偏移</td>
<td><code>uint32_t</code></td>
<td>4</td>
</tr>
<tr>
<td><code>Elf32_Word</code></td>
<td>32 位无符号整数</td>
<td><code>uint32_t</code></td>
<td>4</td>
</tr>
<tr>
<td><code>Elf32_Sword</code></td>
<td>32 位有符号整数</td>
<td><code>int32_t</code></td>
<td>4</td>
</tr>
<tr>
<td><code>Elf64_Addr</code></td>
<td>64 位地址（虚拟地址）</td>
<td><code>uint64_t</code></td>
<td>8</td>
</tr>
<tr>
<td><code>Elf64_Half</code></td>
<td>16 位无符号整数</td>
<td><code>uint16_t</code></td>
<td>2</td>
</tr>
<tr>
<td><code>Elf64_Off</code></td>
<td>64 位文件偏移</td>
<td><code>uint64_t</code></td>
<td>8</td>
</tr>
<tr>
<td><code>Elf64_Word</code></td>
<td>32 位无符号整数（仍为 32bit）</td>
<td><code>uint32_t</code></td>
<td>4</td>
</tr>
<tr>
<td><code>Elf64_Sword</code></td>
<td>32 位有符号整数（仍为 32bit）</td>
<td><code>int32_t</code></td>
<td>4</td>
</tr>
</tbody></table>
<blockquote>
<p>说明：</p>
<ul>
<li><p><strong><code>Word</code> &#x2F; <code>Sword</code> 并不是“跟随地址宽度扩成 64 位”</strong>，而是统一定义为 32 位整型；</p>
</li>
<li><p>真正的 64 位整型在 ELF 里通常用 <code>Xword</code> &#x2F; <code>Sxword</code>：</p>
<ul>
<li><code>Elf32_Xword</code> &#x2F; <code>Elf32_Sxword</code>：在 32 位变体里偶尔用到；</li>
<li><code>Elf64_Xword</code> &#x2F; <code>Elf64_Sxword</code>：64 位 ELF 中大量使用（如某些 size 字段）。</li>
</ul>
</li>
</ul>
</blockquote>
<p>从整体结构上看，一个 ELF 文件大致由以下几部分组成：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/image-20241108001735862.png"
                      alt="image-20241108001735862" style="zoom:33%;" 
                >

<ol>
<li><p><strong>ELF 文件头（ELF Header，<code>Elf*_Ehdr</code>）</strong></p>
<ul>
<li><p>出现在文件开头，包含：</p>
<ul>
<li>魔数 <code>\x7fELF</code> 和一些“识别信息”（位宽、大小端、ABI 等）；</li>
<li>文件类型 <code>e_type</code>、目标架构 <code>e_machine</code>、版本 <code>e_version</code>；</li>
<li>程序入口 <code>e_entry</code>；</li>
<li>程序头表偏移 <code>e_phoff</code>、节表偏移 <code>e_shoff</code>；</li>
<li>各表项大小 &#x2F; 数量（<code>e_phentsize</code>、<code>e_phnum</code>、<code>e_shentsize</code>、<code>e_shnum</code>）等。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>程序头表（Program Header Table，<code>Elf*_Phdr</code>，描述“段 Segment”）</strong></p>
<ul>
<li><p>只有需要被装载执行的文件才真正用到（典型是 <code>ET_EXEC</code>、<code>ET_DYN</code>、<code>ET_CORE</code>）；</p>
</li>
<li><p>目标文件 <code>ET_REL</code> <strong>一般没有程序头表</strong>（规范允许有，但常见工具不会生成）；</p>
</li>
<li><p>每个 <code>Elf*_Phdr</code> 描述一个 <strong>段（Segment）</strong>：</p>
<ul>
<li>段类型 <code>p_type</code>（如 <code>PT_LOAD</code>、<code>PT_DYNAMIC</code>、<code>PT_INTERP</code> 等）；</li>
<li>文件偏移 <code>p_offset</code>、内存虚拟地址 <code>p_vaddr</code>；</li>
<li>文件中大小 <code>p_filesz</code>、内存中大小 <code>p_memsz</code>；</li>
<li>读 &#x2F; 写 &#x2F; 执行等权限标志 <code>p_flags</code>；</li>
<li>对齐要求 <code>p_align</code> 等。</li>
</ul>
</li>
<li><p><strong>段是面向“运行时装载”的视图</strong>：内核 &#x2F; 动态链接器根据 Program Header 来决定如何把文件映射到进程的虚拟地址空间。</p>
</li>
</ul>
</li>
<li><p><strong>节表（Section Header Table，<code>Elf*_Shdr</code>，描述“节 Section”）</strong></p>
<ul>
<li><p>所有 ELF 文件（包含 <code>ET_REL</code>）都可以有节表，用于链接 &#x2F; 调试等工具。</p>
</li>
<li><p>每个 <code>Elf*_Shdr</code> 描述一个 <strong>节（Section）</strong>：</p>
<ul>
<li>节名索引 <code>sh_name</code>（指向 <code>.shstrtab</code>）；</li>
<li>节类型 <code>sh_type</code>（如 <code>SHT_PROGBITS</code>、<code>SHT_SYMTAB</code>、<code>SHT_STRTAB</code>、<code>SHT_NOBITS</code> 等）；</li>
<li>标志 <code>sh_flags</code>（可写 &#x2F; 可执行 &#x2F; 是否占用内存等）；</li>
<li>文件偏移 <code>sh_offset</code>、大小 <code>sh_size</code>；</li>
<li>对齐 <code>sh_addralign</code>、表项大小 <code>sh_entsize</code>（如符号表、重定位表）等。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>段与节的关系：</strong></p>
<ul>
<li><p><strong>节（Section）</strong>：</p>
<ul>
<li>主要服务于 <strong>链接器 &#x2F; 调试器 &#x2F; 静态分析工具</strong>；</li>
<li>例如 <code>.text</code>、<code>.data</code>、<code>.bss</code>、<code>.rodata</code>、<code>.symtab</code>、<code>.strtab</code>、<code>.rel.text</code> 等；</li>
<li>一个文件可以有很多细粒度的节，每个节有清晰的类型、用途。</li>
</ul>
</li>
<li><p><strong>段（Segment）</strong>：</p>
<ul>
<li>主要服务于 <strong>运行时装载</strong>（内核、动态链接器）；</li>
<li>典型的 <code>PT_LOAD</code> 段会把若干具有相同权限属性（如 <code>R-X</code>、<code>RW-</code>）的节“打包”进同一块连续的虚拟地址区间，以减少映射次数、简化权限设置。</li>
<li>段和节之间是 <strong>多对多的映射关系</strong>，并不是简单“若干属性相同的节合成一个段”，而是由链接脚本和链接器策略决定。</li>
</ul>
</li>
</ul>
<p>可以通俗地这么理解：</p>
<blockquote>
<p><strong>节 &#x3D; 文件视图</strong>，偏重“这块数据是什么”；<br><strong>段 &#x3D; 运行时视图</strong>，偏重“这块数据如何被映射到内存、有什么权限”。</p>
</blockquote>
<h2 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h2><p>每个 ELF 文件开头都有一个 <strong>文件头（ELF Header）</strong>，用于描述整个文件的基本属性和布局信息。无论是：</p>
<ul>
<li>可重定位文件（<code>.o</code>，<code>ET_REL</code>），</li>
<li>可执行文件（<code>ET_EXEC</code>），</li>
<li>共享对象（<code>.so</code>，<code>ET_DYN</code>），</li>
<li>核心转储文件（<code>ET_CORE</code>），</li>
</ul>
<p>都必须以同一个 ELF 头结构开头。</p>
<p>以 32 位的 <code>Elf32_Ehdr</code> 为例（64 位的 <code>Elf64_Ehdr</code> 字段完全对应，只是类型宽度不同）：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EI_NIDENT (16)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The ELF file header.  This appears at the start of every ELF file.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> e_ident[EI_NIDENT]; <span class="comment">/* Magic number and other info */</span></span><br><span class="line">  Elf32_Half    e_type;             <span class="comment">/* Object file type */</span></span><br><span class="line">  Elf32_Half    e_machine;          <span class="comment">/* Architecture */</span></span><br><span class="line">  Elf32_Word    e_version;          <span class="comment">/* Object file version */</span></span><br><span class="line">  Elf32_Addr    e_entry;            <span class="comment">/* Entry point virtual address */</span></span><br><span class="line">  Elf32_Off     e_phoff;            <span class="comment">/* Program header table file offset */</span></span><br><span class="line">  Elf32_Off     e_shoff;            <span class="comment">/* Section header table file offset */</span></span><br><span class="line">  Elf32_Word    e_flags;            <span class="comment">/* Processor-specific flags */</span></span><br><span class="line">  Elf32_Half    e_ehsize;           <span class="comment">/* ELF header size in bytes */</span></span><br><span class="line">  Elf32_Half    e_phentsize;        <span class="comment">/* Program header table entry size */</span></span><br><span class="line">  Elf32_Half    e_phnum;            <span class="comment">/* Program header table entry count */</span></span><br><span class="line">  Elf32_Half    e_shentsize;        <span class="comment">/* Section header table entry size */</span></span><br><span class="line">  Elf32_Half    e_shnum;            <span class="comment">/* Section header table entry count */</span></span><br><span class="line">  Elf32_Half    e_shstrndx;         <span class="comment">/* Section header string table index */</span></span><br><span class="line">&#125; Elf32_Ehdr;</span><br></pre></td></tr></table></figure></div>

<hr>
<ul>
<li><p><strong><code>e_ident</code>：魔数和基础属性</strong></p>
<p><code>e_ident</code> 是一个长度为 16 字节的数组，用来描述 ELF 文件的“标识信息”。各字节含义如下（用常见的宏名标号）：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">e_ident[EI_MAG0] = <span class="number">0x7f</span>;</span><br><span class="line">e_ident[EI_MAG1] = <span class="string">&#x27;E&#x27;</span>;</span><br><span class="line">e_ident[EI_MAG2] = <span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">e_ident[EI_MAG3] = <span class="string">&#x27;F&#x27;</span>;</span><br><span class="line">e_ident[EI_CLASS];      <span class="comment">// 32/64 位</span></span><br><span class="line">e_ident[EI_DATA];       <span class="comment">// 字节序</span></span><br><span class="line">e_ident[EI_VERSION];    <span class="comment">// ELF 版本</span></span><br><span class="line">e_ident[EI_OSABI];      <span class="comment">// OS/ABI</span></span><br><span class="line">e_ident[EI_ABIVERSION]; <span class="comment">// ABI 版本</span></span><br><span class="line">e_ident[EI_PAD.<span class="number">.15</span>];    <span class="comment">// 填充/保留</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong>前 4 字节（<code>EI_MAG0</code>~&#96;EI_MAG3&#96;）</strong> 固定为 <code>\x7f &#39;E&#39; &#39;L&#39; &#39;F&#39;</code>，用来标识“这是一个 ELF 文件”。</p>
</li>
<li><p><strong>第 5 字节：<code>EI_CLASS</code></strong> 表示 ELF 的 <strong>位宽类别</strong>（注意不是“文件类型”）：</p>
<ul>
<li><code>ELFCLASS32 (1)</code>：32 位 ELF；</li>
<li><code>ELFCLASS64 (2)</code>：64 位 ELF。</li>
</ul>
</li>
<li><p><strong>第 6 字节：<code>EI_DATA</code></strong> 表示 <strong>字节序</strong>：</p>
<ul>
<li><code>ELFDATA2LSB (1)</code>：小端；</li>
<li><code>ELFDATA2MSB (2)</code>：大端；</li>
<li>0 为无效。</li>
</ul>
</li>
<li><p><strong>第 7 字节：<code>EI_VERSION</code></strong> 表示 ELF 标准版本，目前固定为：</p>
<ul>
<li><code>EV_CURRENT (1)</code>：当前 ELF 规范版本，仅仅是一个版本号，并不是“1.2 版本”之类的概念。</li>
</ul>
</li>
<li><p><strong>第 8 字节：<code>EI_OSABI</code></strong> 指示目标 OS&#x2F;ABI，比如：</p>
<ul>
<li><code>ELFOSABI_SYSV</code>（System V，最常见），</li>
<li>Linux、FreeBSD 等的专有值。</li>
</ul>
</li>
<li><p>**第 9 字节：<code>EI_ABIVERSION</code>**：OS&#x2F;ABI 的版本号，大部分系统中为 0。</p>
</li>
<li><p><strong>第 10~15 字节：<code>EI_PAD</code> 及保留</strong>：用于填充和保留，一般填 0，部分平台可能用这几字节做扩展。</p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p><strong><code>e_type</code>：文件类型</strong></p>
<p>表示 ELF 文件的整体类型，常见取值（宏名以 <code>ET_</code> 开头）：</p>
<ul>
<li><code>ET_REL</code>：可重定位文件（<code>.o</code>）；</li>
<li><code>ET_EXEC</code>：可执行文件；</li>
<li><code>ET_DYN</code>：共享对象（<code>.so</code>），也包括 PIE 可执行文件；</li>
<li><code>ET_CORE</code>：core dump。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p><strong><code>e_machine</code>：目标体系结构</strong></p>
<p>表示目标架构 &#x2F; 指令集，例如：</p>
<ul>
<li><code>EM_386</code>、<code>EM_X86_64</code>、<code>EM_ARM</code>、<code>EM_AARCH64</code> 等。</li>
</ul>
<p>不同架构在重定位类型、指令编码、对齐等方面都不相同，动态链接器、调试器等会根据这个字段选择对应的处理逻辑。</p>
</li>
</ul>
<hr>
<ul>
<li><p><strong><code>e_version</code>：ELF 文件版本</strong></p>
<p>一般为：<code>EV_CURRENT (1)</code>。</p>
<p>它与 <code>e_ident[EI_VERSION]</code> 一致，都是当前 ELF 版本号，一般不会是其它值。</p>
</li>
</ul>
<hr>
<ul>
<li><p><strong><code>e_entry</code>：程序入口虚拟地址</strong></p>
<p>表示程序开始执行时的 <strong>入口虚拟地址</strong>：</p>
<ul>
<li><p>对 <strong>可执行文件 &#x2F; PIE &#x2F; 共享对象</strong>：</p>
<ul>
<li>指向程序或共享库的入口地址；</li>
<li>对可执行文件来说，内核或动态链接器最终会跳到这里，执行运行时初始化后再进入 <code>main</code>。</li>
</ul>
</li>
<li><p>对 <strong>可重定位文件（<code>ET_REL</code>）</strong>：</p>
<ul>
<li>通常没有入口意义，一般为 0。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p><strong><code>e_phoff</code>：程序头表文件偏移</strong></p>
<p>表示 <strong>程序头表（Program Header Table）在文件中的偏移（字节）</strong>：</p>
<ul>
<li>对 <code>ET_EXEC</code> &#x2F; <code>ET_DYN</code> &#x2F; <code>ET_CORE</code>：通常非 0，内核 &#x2F; 动态链接器加载时必须用到；</li>
<li>对 <code>ET_REL</code>：一般为 0（不需要程序头表，但规范允许存在）。</li>
</ul>
<p>若 <code>e_phoff == 0</code>，通常表示“本文件没有程序头表”。</p>
</li>
</ul>
<hr>
<ul>
<li><p><strong><code>e_shoff</code>：节头表文件偏移</strong></p>
<p>表示 <strong>节头表（Section Header Table）在文件中的偏移（字节）</strong>：</p>
<ul>
<li>链接器、调试器通过它来定位 <code>.text</code>、<code>.data</code> 等各节的元信息；</li>
<li>对某些被完全 strip 的可执行文件 &#x2F; 共享库，<code>e_shoff</code> 可能为 0（没有节表），程序依然可以正常执行，只是调试 &#x2F; 链接信息丢失。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p><strong><code>e_flags</code>：处理器特定标志</strong></p>
<p>这是一个与架构相关的标志字段：</p>
<ul>
<li>对 x86 &#x2F; x86‑64 等架构通常为 0；</li>
<li>对 ARM、MIPS 等架构，可能编码 ABI、指令集模式等信息。</li>
</ul>
<p>其具体意义需要参考对应架构的 ABI 文档。</p>
</li>
</ul>
<hr>
<ul>
<li><p><strong><code>e_ehsize</code>：ELF 头大小</strong></p>
<p>表示 ELF 文件头自身的大小（字节数）：</p>
<ul>
<li>对 32 位 ELF，一般为 <code>sizeof(Elf32_Ehdr)</code>，典型值 52；</li>
<li>对 64 位 ELF，一般为 <code>sizeof(Elf64_Ehdr)</code>，典型值 64。</li>
</ul>
<p>解析 ELF 时可以用该字段来校验读到的头部是否完整。</p>
</li>
</ul>
<hr>
<ul>
<li><p><strong><code>e_phentsize</code> &#x2F; <code>e_phnum</code>：程序头表项大小与数量</strong></p>
<ul>
<li><code>e_phentsize</code>：程序头表中 <strong>每个表项（<code>Elf*_Phdr</code>）的大小</strong>；</li>
<li><code>e_phnum</code>：程序头表中 <strong>表项数量</strong>。</li>
</ul>
<p>当 <code>e_phnum == 0</code> 时，表示本文件中没有程序头表（例如纯 <code>ET_REL</code> 文件或某些特殊构造）。</p>
</li>
</ul>
<hr>
<ul>
<li><p><strong><code>e_shentsize</code> &#x2F; <code>e_shnum</code>：节头表项大小与数量</strong></p>
<ul>
<li><code>e_shentsize</code>：节头表中 <strong>每个表项（<code>Elf*_Shdr</code>）的大小</strong>；</li>
<li><code>e_shnum</code>：节头表中 <strong>表项数量</strong>。</li>
</ul>
<p>当 <code>e_shnum == 0</code> 时，通常意味着文件中没有节表（例如被完全 strip 且不再需要调试 &#x2F; 链接用途的二进制）。</p>
</li>
</ul>
<hr>
<ul>
<li><p><strong><code>e_shstrndx</code>：节名字符串表索引</strong></p>
<p><code>e_shstrndx</code> 指明：</p>
<blockquote>
<p>在节头表中，哪一个节（按 <code>Elf*_Shdr</code> 索引）是 <strong>节头字符串表（Section Header String Table，一般名为 <code>.shstrtab</code>）</strong>。</p>
</blockquote>
<ul>
<li><code>.shstrtab</code> 中保存了所有“节名”的字符串；</li>
<li>每个 <code>Elf*_Shdr::sh_name</code> 字段是相对于 <code>.shstrtab</code> 的偏移；</li>
<li>若 <code>e_shstrndx == SHN_UNDEF (0)</code>，通常表示没有节名字符串表（少见，多见于特殊或混淆过的 ELF）。</li>
</ul>
</li>
</ul>
<h2 id="程序头表"><a href="#程序头表" class="headerlink" title="程序头表"></a>程序头表</h2><p>在 ELF 中，有两套“描述结构”：</p>
<ul>
<li><strong>节表（Section Header Table）</strong>：描述的是 <strong>节（Section）</strong>，主要给<strong>链接器、调试器</strong>用。</li>
<li><strong>程序头表（Program Header Table）</strong>：描述的是 <strong>段（Segment）</strong>，主要给<strong>操作系统装载器 &#x2F; 动态链接器</strong>用。</li>
</ul>
<p>一般来说：</p>
<ul>
<li><strong>可执行文件（<code>ET_EXEC</code>）</strong>：有程序头表；</li>
<li><strong>共享对象（<code>ET_DYN</code>，共享库 &#x2F; PIE）</strong>：有程序头表；</li>
<li><strong>可重定位目标文件（<code>ET_REL</code>）</strong>：通常<strong>没有</strong>程序头表，只需要节表即可（也可以有，但实际工具链基本不会这么干）。</li>
</ul>
<p>程序头表描述的是<strong>装载相关的“段”</strong>，而目标文件不直接被操作系统装载执行，所以通常不需要程序头表。</p>
<p>程序头表是一个由 <code>Elf*_Phdr</code> 结构体构成的数组，每个 <code>Phdr</code> 描述一个 <strong>段（Segment）</strong>，而不是“每个节”。</p>
<ul>
<li><p><strong>段是面向“内存装载”的视图</strong>：<br>OS 根据程序头表决定：</p>
<ul>
<li>从文件的哪个偏移 (<code>p_offset</code>) 读多少字节 (<code>p_filesz</code>)</li>
<li>把它们映射到内存中的哪个虚拟地址 (<code>p_vaddr</code>)，映射多大 (<code>p_memsz</code>)</li>
<li>映射的权限（读 &#x2F; 写 &#x2F; 执行：<code>p_flags</code>）</li>
</ul>
</li>
<li><p>一个段可以覆盖多个节；多个属性相同的节会被合并进同一个 <code>PT_LOAD</code> 段里。</p>
</li>
</ul>
<p>以 32 位为例（64 位只是字段宽度不同）<code>Elf32_Phdr</code> 结构如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Program segment header.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word p_type;   <span class="comment">/* Segment type */</span></span><br><span class="line">  Elf32_Off  p_offset; <span class="comment">/* Segment file offset */</span></span><br><span class="line">  Elf32_Addr p_vaddr;  <span class="comment">/* Segment virtual address */</span></span><br><span class="line">  Elf32_Addr p_paddr;  <span class="comment">/* Segment physical address */</span></span><br><span class="line">  Elf32_Word p_filesz; <span class="comment">/* Segment size in file */</span></span><br><span class="line">  Elf32_Word p_memsz;  <span class="comment">/* Segment size in memory */</span></span><br><span class="line">  Elf32_Word p_flags;  <span class="comment">/* Segment flags */</span></span><br><span class="line">  Elf32_Word p_align;  <span class="comment">/* Segment alignment */</span></span><br><span class="line">&#125; Elf32_Phdr;</span><br></pre></td></tr></table></figure></div>

<p>各字段含义：</p>
<ul>
<li><p><strong><code>p_type</code>：段类型</strong></p>
<p>指定该条目表示什么类型的段，常见值（省略很多）：</p>
<ul>
<li><code>PT_NULL</code>：无效条目，忽略；</li>
<li><code>PT_LOAD</code>：<strong>可装载段</strong>，真正会映射到进程虚拟地址空间（代码 &#x2F; 数据等都在这里）；</li>
<li><code>PT_DYNAMIC</code>：动态链接信息所在的段，对应 <code>.dynamic</code>；</li>
<li><code>PT_INTERP</code>：解释器（通常是动态链接器）路径所在段，对应 <code>.interp</code>；</li>
<li><code>PT_NOTE</code>：<code>NOTE</code> 信息；</li>
<li><code>PT_GNU_STACK</code> 等：GNU 扩展，用于指定栈是否可执行。</li>
</ul>
<p>“可执行段、数据段”这类说法<strong>其实是由 <code>PT_LOAD</code> + <code>p_flags</code>（读写执行）组合出来的</strong>，而不是 <code>p_type</code> 本身区分“代码段 &#x2F; 数据段”。</p>
</li>
<li><p><strong><code>p_offset</code>：文件偏移</strong></p>
<p>段在 <strong>文件中的起始偏移</strong>（字节）。装载器从这个位置开始读数据。</p>
</li>
<li><p><strong><code>p_vaddr</code>：虚拟地址</strong></p>
<p>段在 <strong>进程虚拟地址空间中的起始地址</strong>。<br>对于 <code>PT_LOAD</code> 段，必须是页对齐的，且会参与实际的内存映射。<br>对于某些非装载段（如 <code>PT_NOTE</code>），这个字段的解释依 ABI 而定，可能为 0 或未使用。</p>
</li>
<li><p><strong><code>p_paddr</code>：物理地址</strong></p>
<p>段在物理内存中的地址。</p>
<ul>
<li>在大多数通用操作系统（Linux 等）中，进程只关心虚拟地址，这个字段通常<strong>被忽略或与 <code>p_vaddr</code> 保持一致</strong>，更多是给某些裸机 &#x2F; 特殊系统预留的。</li>
<li>所以简单记：在普通用户空间程序里，可以当作保留字段看待。</li>
</ul>
</li>
<li><p><strong><code>p_filesz</code>：文件中大小</strong></p>
<p>段在文件中占据的字节数。</p>
</li>
<li><p><strong><code>p_memsz</code>：内存中大小</strong></p>
<p>段映射到内存时占据的字节数。</p>
<p>常见关系：<code>p_memsz &gt;= p_filesz</code></p>
<ul>
<li>对于 <code>.bss</code> 这种“未初始化数据”，相应部分不会写入文件，只在内存中以 0 填充；</li>
<li>这时 <code>p_filesz</code> 小于 <code>p_memsz</code>，多出来的部分由内核（或运行时）做清零。</li>
</ul>
</li>
<li><p><strong><code>p_flags</code>：段标志</strong></p>
<p>常用为位组合：</p>
<ul>
<li><code>PF_X</code>：可执行</li>
<li><code>PF_W</code>：可写</li>
<li><code>PF_R</code>：可读</li>
</ul>
<p>OS 会据此设置内存页的权限。</p>
</li>
<li><p><strong><code>p_align</code>：对齐要求</strong></p>
<p>段在文件和内存中的对齐约束：</p>
<ul>
<li><p>若 <code>p_align &gt; 1</code>，则通常需要满足：</p>
<ul>
<li><code>p_vaddr % p_align == p_offset % p_align</code></li>
</ul>
</li>
<li><p>对于 <code>PT_LOAD</code> 段，<code>p_align</code> 一般是 <strong>页大小</strong>（如 0x1000），确保段起始地址为页对齐。</p>
</li>
<li><p>若 <code>p_align</code> 为 0 或 1，表示<strong>没有特殊对齐要求</strong>。</p>
</li>
</ul>
</li>
</ul>
<h2 id="节表"><a href="#节表" class="headerlink" title="节表"></a>节表</h2><p>ELF 文件中使用一组 <code>Elf*_Shdr</code> 结构体来描述<strong>每一个节</strong>，这些结构体顺序排在一起，构成 <strong>节表（Section Header Table）</strong>：</p>
<ul>
<li>每个表项大小固定（<code>e_shentsize</code>），类型为 <code>Elf32_Shdr</code> 或 <code>Elf64_Shdr</code>；</li>
<li>表项个数由 ELF 头里的 <code>e_shnum</code> 指定；</li>
<li>整个节表在文件中的位置由 <code>e_shoff</code> 给出。</li>
</ul>
<blockquote>
<p><strong>段（Segment） vs 节（Section）</strong></p>
<ul>
<li><p><strong>节（Section）</strong></p>
<ul>
<li><p>是<strong>文件级</strong>的逻辑组织单位，用来按“用途”划分内容：</p>
<ul>
<li>代码：<code>.text</code></li>
<li>已初始化数据：<code>.data</code></li>
<li>未初始化数据：<code>.bss</code>（<code>SHT_NOBITS</code>）</li>
<li>只读数据：<code>.rodata</code></li>
<li>符号表：<code>.symtab</code></li>
<li>字符串表：<code>.strtab</code> &#x2F; <code>.dynstr</code></li>
<li>……</li>
</ul>
</li>
<li><p>每个节在节表里对应一个 <code>Elf*_Shdr</code> 表项，给出它在<strong>文件中的偏移、大小、属性等</strong>。</p>
</li>
<li><p><strong>链接器 &#x2F; 调试器主要看“节”</strong>。</p>
</li>
</ul>
</li>
<li><p><strong>段（Segment）</strong></p>
<ul>
<li>是<strong>内存装载视图</strong>，由 Program Header（<code>Elf*_Phdr</code>，类型 <code>PT_LOAD</code> &#x2F; <code>PT_DYNAMIC</code> &#x2F; <code>PT_INTERP</code> 等）描述；</li>
<li>一个段通常对应进程虚拟地址空间中的一个连续区间（比如“这块内存可读+可执行，用来放代码”和“这块内存可读+可写，用来放数据”）；</li>
<li>一个 <strong>PT_LOAD</strong> 段内部可以包含多个 section（例如 <code>.text</code> + <code>.rodata</code> 合在一个只读+可执行段里）。</li>
<li><strong>操作系统装载器只看“段”（Program Header），可以完全不理会节表。</strong></li>
</ul>
</li>
</ul>
<p>链接器会把属性相同的节（比如都只读+可执行的 <code>.text</code> &#x2F; <code>.rodata</code>）打包到同一个 <code>PT_LOAD</code> 段中；装载时，内核只根据“段”来把文件映射进内存，而不关心“节”的细节。</p>
</blockquote>
<p>ELF 使用一个由 <code>Elf*_Shdr</code> 组成的数组来描述所有 <strong>节（section）</strong>，每个表项大小固定，但数组长度（节个数）不固定，由 ELF 头决定。</p>
<ul>
<li><p>以 32 位为例（64 位只是字段宽度不同）<code>Elf32_Shdr</code> 结构如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Section header.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word sh_name;      <span class="comment">/* Section name (string tbl index)   */</span></span><br><span class="line">  Elf32_Word sh_type;      <span class="comment">/* Section type                      */</span></span><br><span class="line">  Elf32_Word sh_flags;     <span class="comment">/* Section flags                     */</span></span><br><span class="line">  Elf32_Addr sh_addr;      <span class="comment">/* Section virtual addr at execution */</span></span><br><span class="line">  Elf32_Off  sh_offset;    <span class="comment">/* Section file offset               */</span></span><br><span class="line">  Elf32_Word sh_size;      <span class="comment">/* Section size in bytes             */</span></span><br><span class="line">  Elf32_Word sh_link;      <span class="comment">/* Link to another section           */</span></span><br><span class="line">  Elf32_Word sh_info;      <span class="comment">/* Additional section information    */</span></span><br><span class="line">  Elf32_Word sh_addralign; <span class="comment">/* Section alignment                 */</span></span><br><span class="line">  Elf32_Word sh_entsize;   <span class="comment">/* Entry size if section holds table */</span></span><br><span class="line">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure></div>

<p>各字段含义：</p>
<ul>
<li><p><strong><code>sh_name</code>：节名索引</strong></p>
<ul>
<li>表示节名在“节名字符串表”（<code>.shstrtab</code>）中的索引。</li>
<li><code>.shstrtab</code> 是一个专门用来存放“节名字符串”的节，它本身在节头表中的索引由 ELF 头的 <code>e_shstrndx</code> 给出。</li>
<li>因此 <code>sh_name</code> 指向的是 <code>.shstrtab</code>，<strong>不是</strong> <code>.strtab</code> &#x2F; <code>.dynstr</code> 这些普通字符串表。</li>
</ul>
</li>
<li><p><strong><code>sh_type</code>：节类型</strong></p>
<ul>
<li><p>描述该节的类型，从而决定这节的用途和解释方式。</p>
</li>
<li><p>常见取值（只列常用的）：</p>
<ul>
<li><code>SHT_NULL (0)</code>：无效节（占位用）。</li>
<li><code>SHT_PROGBITS (1)</code>：程序自定义内容（代码、常量等），例如 <code>.text</code>、<code>.rodata</code>、<code>.data</code> 通常都是这个类型。</li>
<li><code>SHT_SYMTAB (2)</code>：静态符号表，例如 <code>.symtab</code>。</li>
<li><code>SHT_STRTAB (3)</code>：字符串表，例如 <code>.strtab</code>、<code>.dynstr</code>、<code>.shstrtab</code>。</li>
<li><code>SHT_RELA (4)</code> &#x2F; <code>SHT_REL (9)</code>：重定位表（分别为带 &#x2F; 不带显式 addend 的形式）。</li>
<li><code>SHT_NOBITS (8)</code>：不在文件中占空间的节，例如 <code>.bss</code>。</li>
<li>……</li>
</ul>
</li>
<li><p>注意：**“代码段 &#x2F; 数据段”是节的用途，不是不同的 <code>sh_type</code>**，代码和数据一般都属于 <code>SHT_PROGBITS</code>。</p>
</li>
</ul>
</li>
<li><p><strong><code>sh_flags</code>：节标志</strong></p>
<ul>
<li><p>描述该节在内存中的属性，常见标志：</p>
<ul>
<li><code>SHF_WRITE</code>：节在内存中可写。</li>
<li><code>SHF_ALLOC</code>：装载时会被映射到进程地址空间。</li>
<li><code>SHF_EXECINSTR</code>：节中包含可执行指令。</li>
<li>……</li>
</ul>
</li>
<li><p>链接器 &#x2F; 装载器会据此决定该节应放入什么样的 <code>PT_LOAD</code> 段，以及映射时的页权限（r&#x2F;w&#x2F;x）。</p>
</li>
</ul>
</li>
<li><p><strong><code>sh_addr</code>：虚拟地址</strong></p>
<ul>
<li>表示该节在内存中的虚拟地址。</li>
<li>对 <strong>可重定位文件（<code>ET_REL</code>）</strong>：一般为 0（尚未分配最终虚拟地址）。</li>
<li>对 <strong>可执行文件（<code>ET_EXEC</code>）和共享对象（<code>ET_DYN</code>）</strong> 中带 <code>SHF_ALLOC</code> 的节：该字段表示此节在进程地址空间中的位置（通常是相对装载基址的偏移）。</li>
<li>总结：<strong>只对带 <code>SHF_ALLOC</code> 的节、且在已定址的 ELF（ET_EXEC&#x2F;ET_DYN）中有实际意义</strong>。</li>
</ul>
</li>
<li><p><strong><code>sh_offset</code>：文件偏移</strong></p>
<ul>
<li><p>表示该节在 ELF 文件中的起始偏移（字节）。</p>
</li>
<li><p>对绝大多数节，这就是节内容在文件里的位置。</p>
</li>
<li><p>对 <code>SHT_NOBITS</code>（例如 <code>.bss</code>）：</p>
<ul>
<li>按规范 <code>sh_offset</code> 仍然有定义——表示“如果这节在文件中有数据，应该放在这里”；</li>
<li>但这种节在文件中<strong>不占空间</strong>，loader 只会根据 <code>sh_type == SHT_NOBITS</code> 和 <code>sh_size</code> 在内存中划出一块区域并清零，而不会从文件这个位置读取。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>sh_size</code>：节大小</strong></p>
<ul>
<li>表示该节的大小（字节数）。</li>
<li>对 <code>SHT_NOBITS</code>：表示这块在内存中需要保留的大小（虽然文件中没有对应数据）。</li>
</ul>
</li>
<li><p><strong><code>sh_link</code>：链接信息</strong></p>
<ul>
<li><p>含义依 <code>sh_type</code> 不同而不同，一般用来“指向另一个相关的节”：</p>
<ul>
<li>对 <code>SHT_SYMTAB</code> &#x2F; <code>SHT_DYNSYM</code>：<code>sh_link</code> 通常是该符号表所使用的字符串表（<code>.strtab</code> &#x2F; <code>.dynstr</code>）在节头表中的索引。</li>
<li>对重定位节（<code>SHT_REL</code> &#x2F; <code>SHT_RELA</code>）：<code>sh_link</code> 通常是所引用的符号表节的索引。</li>
<li>其它类型也有各自约定。</li>
</ul>
</li>
<li><p>简单理解：<strong>“关联到哪个节”</strong>，具体要看节类型的说明。</p>
</li>
</ul>
</li>
<li><p><strong><code>sh_info</code>：附加信息</strong></p>
<ul>
<li><p>同样是与 <code>sh_type</code> 相关的附加字段：</p>
<ul>
<li>对 <code>SHT_SYMTAB</code> &#x2F; <code>SHT_DYNSYM</code>：通常表示本地符号个数（<code>STB_LOCAL</code> 的符号数量）。</li>
<li>对重定位节：通常表示“本节要重定位的目标节”的索引。</li>
<li>其它类型用法依 ABI 约定。</li>
</ul>
</li>
<li><p>可以简单记为：<strong>“额外信息字段，其含义随节类型而变”。</strong></p>
</li>
</ul>
</li>
<li><p><strong><code>sh_addralign</code>：地址对齐约束</strong></p>
<ul>
<li><p>描述该节在内存中的对齐要求：</p>
<ul>
<li><p>若 <code>sh_addralign == 0</code> 或 <code>sh_addralign == 1</code>：表示没有特别的对齐要求，可认为是字节对齐。</p>
</li>
<li><p>否则 <code>sh_addralign</code> 一般是 2 的幂，并要求：</p>
<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh_addr % sh_addralign == 0</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>sh_entsize</code>：表项大小</strong></p>
<ul>
<li><p>若该节存放的是由<strong>定长表项组成的表</strong>（例如符号表、重定位表），则 <code>sh_entsize</code> 表示每个表项的大小（字节数）：</p>
<ul>
<li>对 <code>.symtab</code> &#x2F; <code>.dynsym</code>：通常是 <code>sizeof(Elf32_Sym)</code> &#x2F; <code>sizeof(Elf64_Sym)</code>。</li>
<li>对 <code>.rel.*</code> &#x2F; <code>.rela.*</code>：通常是 <code>sizeof(Elf32_Rel)</code> &#x2F; <code>Elf32_Rela</code> 等。</li>
</ul>
</li>
<li><p>若 <code>sh_entsize == 0</code>：表示该节不是“定长表项数组”，例如 <code>.text</code>、<code>.rodata</code> 这类普通数据区域。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>ELF 中常见的节如下：</p>
<ul>
<li><p><strong><code>.text</code></strong><br>代码节，存放程序的机器指令，通常 <code>SHT_PROGBITS</code> + <code>SHF_ALLOC | SHF_EXECINSTR</code>。</p>
</li>
<li><p><strong><code>.rodata</code></strong><br>只读数据节，存放字符串常量、常量表等，通常 <code>SHT_PROGBITS</code> + <code>SHF_ALLOC</code>（不带 <code>SHF_WRITE</code>）。</p>
</li>
<li><p><strong><code>.data</code></strong><br>已初始化的可写全局 &#x2F; 静态变量，通常 <code>SHT_PROGBITS</code> + <code>SHF_ALLOC | SHF_WRITE</code>。</p>
</li>
<li><p><strong><code>.bss</code></strong><br>未初始化的全局 &#x2F; 静态变量，<code>SHT_NOBITS</code>，带 <code>SHF_ALLOC | SHF_WRITE</code>：</p>
<ul>
<li>在文件中<strong>不占实际数据空间</strong>（只有节头），</li>
<li>装载时在内存中分配 <code>sh_size</code> 字节并清零。</li>
</ul>
</li>
<li><p><strong><code>.symtab</code></strong><br>静态符号表，<code>SHT_SYMTAB</code>，供链接器 &#x2F; 调试器使用，可能在 strip 后被移除。</p>
</li>
<li><p><strong><code>.strtab</code></strong><br>字符串表，<code>SHT_STRTAB</code>，配合 <code>.symtab</code> 存符号名等字符串。</p>
</li>
<li><p><strong><code>.rel.text</code> &#x2F; <code>.rela.text</code></strong><br>代码重定位信息，分别是 <code>SHT_REL</code> &#x2F; <code>SHT_RELA</code> 类型，链接时用来修正 <code>.text</code> 内的地址引用。</p>
</li>
<li><p><strong><code>.rel.data</code> &#x2F; <code>.rela.data</code></strong><br>数据重定位信息，用于修正 <code>.data</code> 等数据节中的地址引用。</p>
</li>
<li><p><strong><code>.dynamic</code></strong><br>动态节，<code>SHT_DYNAMIC</code>，内部是 <code>Elf*_Dyn</code> 数组，描述动态链接所需的信息：</p>
<ul>
<li>动态符号表、字符串表、重定位表的位置和大小；</li>
<li>依赖的共享库名（<code>DT_NEEDED</code>）所在的字符串表索引；</li>
<li>初始化&#x2F;终止函数地址等。<br>本身<strong>不是</strong>重定位表或符号表，而是这些表的“目录”。</li>
</ul>
</li>
<li><p><strong><code>.note.*</code></strong><br>注释 &#x2F; 说明 &#x2F; 元数据节，<code>SHT_NOTE</code>：</p>
<ul>
<li>常见如 <code>.note.ABI-tag</code>、<code>.note.gnu.build-id</code>，存放 ABI 信息、build-id 等；</li>
<li>不等同于 DWARF 调试节（那些通常是 <code>.debug_*</code>）。</li>
</ul>
</li>
</ul>
<h2 id="字符串表"><a href="#字符串表" class="headerlink" title="字符串表"></a>字符串表</h2><p>在 ELF 文件里会出现大量字符串，例如：</p>
<ul>
<li>段名（section name）</li>
<li>符号名（函数名、变量名）</li>
<li>动态链接相关的各种名字</li>
</ul>
<p>由于字符串长度不定，如果在每个需要名字的结构里都直接放一个“定长字符串字段”，会非常浪费空间，也不灵活。</p>
<p>ELF 的做法是：<strong>把所有字符串集中放到一个“字符串表”（String Table）里，然后在各个结构中用“偏移量”来引用字符串</strong>。</p>
<ul>
<li><p>字符串表本质上就是一段连续的字节数组。</p>
</li>
<li><p>某个字段（比如 <code>sh_name</code>、<code>st_name</code>）存的不是字符串本身，而是：</p>
<blockquote>
<p>从该字符串表起始处到目标字符串开头的 <strong>字节偏移（index &#x2F; offset）</strong>。</p>
</blockquote>
</li>
</ul>
<p>这样，ELF 内部引用字符串时只要给出一个整数偏移即可，不需要关心字符串实际长度。</p>
<p>在 ELF 中，字符串表以 <strong>节（section）</strong> 的形式出现，节类型为 <code>SHT_STRTAB</code>。常见的名字有：</p>
<ul>
<li><p><code>.shstrtab</code> —— <strong>Section Header String Table</strong></p>
<ul>
<li>“段表字符串表”：专门存放 <strong>段表（section header table）用到的字符串</strong>。</li>
<li>最典型的就是段名，供 <code>ElfXX_Shdr::sh_name</code> 字段引用。</li>
</ul>
</li>
<li><p><code>.strtab</code> —— <strong>String Table</strong></p>
<ul>
<li>一般用作 <strong>普通符号表 <code>.symtab</code> 的名字字符串表</strong>，保存各种符号名（函数名、全局变量名等）。</li>
</ul>
</li>
<li><p><code>.dynstr</code> —— <strong>Dynamic String Table</strong></p>
<ul>
<li>供 <code>.dynsym</code>（动态符号表）、<code>.dynamic</code> 等动态链接相关结构使用，保存运行时需要的那些字符串。</li>
</ul>
</li>
</ul>
<blockquote>
<p>说明：在简单的介绍里，常会只提 <code>.strtab</code> 和 <code>.shstrtab</code> 两个表来讲概念，这没有问题。但真实 ELF 里还经常能看到 <code>.dynstr</code> 这样的动态字符串表。</p>
</blockquote>
<p>常见的“通过偏移引用字符串”的例子有：</p>
<ul>
<li><p><strong>段表条目中的 <code>sh_name</code> 字段</strong></p>
<ul>
<li><p>类型：<code>uint32_t</code></p>
</li>
<li><p>含义：这是相对于 <code>.shstrtab</code> 开头的字节偏移。</p>
</li>
<li><p>动态装载器&#x2F;分析工具会：</p>
<ul>
<li>找到段表字符串表 <code>.shstrtab</code></li>
<li>从偏移 <code>sh_name</code> 开始，读取一个以 <code>&#39;\0&#39;</code> 结尾的字符串，这就是该 section 的名字。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>符号表条目中的 <code>st_name</code> 字段（<code>.symtab</code> &#x2F; <code>.dynsym</code>）</strong></p>
<ul>
<li>类型：<code>uint32_t</code></li>
<li>含义：这是相对于对应字符串表 (<code>.strtab</code> 或 <code>.dynstr</code>) 开头的字节偏移。</li>
<li>通过这个偏移就能拿到符号名。</li>
</ul>
</li>
</ul>
<p>你可以把字符串表理解成一个字符串池，而 <code>sh_name</code> &#x2F; <code>st_name</code> 这些字段就是“指向池里面某个字符串的偏移指针”。</p>
<p><strong>ELF 字符串表中的字符串是以 <code>\x00</code> 结尾的 C 风格字符串，字符串之间紧挨着存放。</strong></p>
<p>关键点：</p>
<ol>
<li><p>每个字符串是：</p>
<ul>
<li>若干个非零字节</li>
<li>后面跟一个 <code>&#39;\0&#39;</code>（即 <code>\x00</code>）作为结尾</li>
</ul>
</li>
<li><p><strong>整个字符串表的第 0 个字节</strong> 被规定为 <code>&#39;\0&#39;</code>：</p>
<ul>
<li>这就构成了一个“空字符串”，偏移为 0。</li>
<li>当某些字段（比如 <code>sh_name</code> 或 <code>st_name</code>）为 0 时，就表示“没有名字”或“名字为空”。</li>
</ul>
</li>
<li><p>相邻字符串之间 <strong>只需要结尾处的那个 <code>\x00</code> 来做分隔</strong>，不会在“每个字符串的开头再填一个 <code>\x00</code>”。</p>
</li>
</ol>
<h1 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h1><h2 id="栈结构"><a href="#栈结构" class="headerlink" title="栈结构"></a>栈结构</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux%20user%20pwn%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/images/image-20241108005938556.png"
                      alt="image-20241108005938556"
                ></p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p>canary 不一定与 ebp 相邻，因为有些函数会先将一些寄存器保存到栈中。canary 实际位置以调试为准。</p>

    </div>
  </div>

<h2 id="函数调用过程"><a href="#函数调用过程" class="headerlink" title="函数调用过程"></a>函数调用过程</h2><p>32位为例：</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>push args</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>call func</mtext><mrow><mo fence="true">{</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>push next_eip</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>jmp func</mtext></mstyle></mtd></mtr></mtable></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>push ebp</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>mov ebp,esp</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>leave</mtext><mrow><mo fence="true">{</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>mov esp,ebp</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>pop ebp</mtext></mstyle></mtd></mtr></mtable></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>ret (pop eip)</mtext></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{align*}
&amp; \text{push args}\\
&amp; \text{call func}\left\{\begin{matrix}
\text{push next\_eip}\\ 
\text{jmp func}
\end{matrix}\right.\\
&amp; \text{push ebp}\\
&amp; \text{mov ebp,esp}\\
&amp; \vdots \\
&amp; \text{leave}\left\{\begin{matrix}
\text{mov esp,ebp}\\ 
\text{pop ebp}
\end{matrix}\right.\\
&amp;\text{ret}\ \text{(pop eip)}
\end{align*}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:13.5601em;vertical-align:-6.53em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:7.03em;"><span style="top:-9.69em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"></span></span><span style="top:-7.58em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"></span></span><span style="top:-5.49em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"></span></span><span style="top:-3.99em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"></span></span><span style="top:-1.83em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"></span></span><span style="top:0.28em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"></span></span><span style="top:2.37em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:6.53em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:7.03em;"><span style="top:-9.8775em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"></span><span class="mord text"><span class="mord">push args</span></span></span></span><span style="top:-7.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"></span><span class="mord text"><span class="mord">call func</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">{</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">push next_eip</span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">jmp func</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-5.6775em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"></span><span class="mord text"><span class="mord">push ebp</span></span></span></span><span style="top:-4.1775em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"></span><span class="mord text"><span class="mord">mov ebp,esp</span></span></span></span><span style="top:-2.0175em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"></span><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:0.0925em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"></span><span class="mord text"><span class="mord">leave</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">{</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">mov esp,ebp</span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">pop ebp</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:2.1825em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"></span><span class="mord text"><span class="mord">ret</span></span><span class="mspace"> </span><span class="mord text"><span class="mord">(pop eip)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:6.53em;"><span></span></span></span></span></span></span></span></span></span></span></span>


<h2 id="函数参数传递"><a href="#函数参数传递" class="headerlink" title="函数参数传递"></a>函数参数传递</h2>
  <div class="note p-4 mb-4 rounded-small markdown-body red icon-padding">
    <i class="note-icon fa-solid fa-bolt"></i><p>注意：通常 linux 下的程序的函数调用都是外平栈的。</p>

  </div>

<h3 id="32-位程序"><a href="#32-位程序" class="headerlink" title="32 位程序"></a>32 位程序</h3><h4 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h4><p>Linux 使用 <strong><code>cdecl</code> 调用约定</strong>，所有参数 <strong>从右到左</strong> 压入栈中。由 <strong>调用者（caller）</strong> 负责清理栈上的参数。使用 <code>EAX</code> 返回函数值。</p>
<h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>在 <strong>32 位 Linux</strong>（x86 架构）中，用户态通过 <code>int 0x80</code> 进入内核执行系统调用。为了提高兼容性，Linux 系统主要采用 <code>int 0x80</code>，而不是 <code>sysenter</code>，因为后者需要硬件支持和额外的返回跳板机制。</p>
<p>系统调用时，<strong>调用号和参数都通过寄存器传递</strong>，具体分配如下：</p>
<ul>
<li><code>EAX</code> 寄存器用于存放系统调用号（syscall number）。</li>
<li><code>EBX</code>、<code>ECX</code>、<code>EDX</code>、<code>ESI</code>、<code>EDI</code>、<code>EBP</code> 依次用于传递系统调用的第 1 到第 6 个参数。</li>
</ul>
<p>系统调用返回时，结果会存放在 <code>EAX</code> 中。如果调用成功，<code>EAX</code> 中为返回值；如果失败，则 <code>EAX</code> 为负值（对应负的 <code>errno</code> 编号）。</p>
<h3 id="64位程序"><a href="#64位程序" class="headerlink" title="64位程序"></a>64位程序</h3><h4 id="普通函数-1"><a href="#普通函数-1" class="headerlink" title="普通函数"></a>普通函数</h4><p>在 <strong>64 位 Linux</strong>（x86_64 架构）中，普通函数调用遵循 <strong>System V AMD64 ABI 调用约定</strong>，这是当前 Linux 平台上 C&#x2F;C++ 等语言的标准调用方式。</p>
<p>函数参数通过寄存器优先传递，具体为：</p>
<ul>
<li><code>RDI</code>、<code>RSI</code>、<code>RDX</code>、<code>RCX</code>、<code>R8</code>、<code>R9</code> 依次用于传递前 6 个参数。</li>
<li>超过 6 个参数的部分，从右到左压入栈中。</li>
</ul>
<p>函数返回值通过 <code>RAX</code> 返回，若返回值过大或为结构体，可能使用多个寄存器（必要时用 <code>RDX:RAX</code> 返回 128bit）或通过内存返回。</p>
<p>在寄存器使用上，调用者负责保存 <code>RAX</code>、<code>RCX</code>、<code>RDX</code>、<code>RDI</code>、<code>RSI</code>、<code>R8</code>～<code>R11</code> 等 caller-saved 寄存器；而 <code>RBX</code>、<code>RBP</code>、<code>R12</code>～<code>R15</code> 等 callee-saved 寄存器由被调用函数保存。</p>
<p>函数调用前，要求栈地址必须对齐到 <strong>16 字节</strong>，否则在使用某些 SSE 指令时会触发崩溃。</p>
<h4 id="系统调用-1"><a href="#系统调用-1" class="headerlink" title="系统调用"></a>系统调用</h4><p>在 <strong>64 位 Linux</strong>（x86_64 架构）中，用户态通过 <code>syscall</code> 指令进入内核执行系统调用。相比 32 位的 <code>int 0x80</code>，<code>syscall</code> 是专为 64 位架构设计的系统调用指令，执行效率更高，也是当前主流的调用方式。</p>
<p>系统调用时，<strong>调用号和参数都通过寄存器传递</strong>，具体分配如下：</p>
<ul>
<li><code>RAX</code> 寄存器用于存放系统调用号（syscall number）。</li>
<li><code>RDI</code>、<code>RSI</code>、<code>RDX</code>、<code>R10</code>、<code>R8</code>、<code>R9</code> 依次用于传递系统调用的第 1 到第 6 个参数。</li>
</ul>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p>第 4 个参数使用 <code>R10</code> 而不是 <code>RCX</code>，因为 <code>RCX</code> 在执行 <code>syscall</code> 时会被硬件破坏（用作返回地址保存）。</p>

    </div>
  </div>

<p>系统调用返回时，结果会存放在 <code>RAX</code> 中。如果调用成功，<code>RAX</code> 中为返回值；如果失败，则 <code>RAX</code> 为负值（对应负的 <code>errno</code> 编号）。</p>
<h2 id="系统调用号"><a href="#系统调用号" class="headerlink" title="系统调用号"></a>系统调用号</h2><h3 id="32-位"><a href="#32-位" class="headerlink" title="32 位"></a>32 位</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ASM_X86_UNISTD_32_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ASM_X86_UNISTD_32_H 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_restart_syscall 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_exit 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fork 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_read 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_write 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_open 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_close 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_waitpid 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_creat 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_link 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_unlink 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_execve 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_chdir 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_time 13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mknod 14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_chmod 15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lchown 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_break 17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_oldstat 18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lseek 19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpid 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mount 21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_umount 22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setuid 23</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getuid 24</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_stime 25</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ptrace 26</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_alarm 27</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_oldfstat 28</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pause 29</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_utime 30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_stty 31</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_gtty 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_access 33</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_nice 34</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ftime 35</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sync 36</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_kill 37</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rename 38</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mkdir 39</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rmdir 40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_dup 41</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pipe 42</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_times 43</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_prof 44</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_brk 45</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setgid 46</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getgid 47</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_signal 48</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_geteuid 49</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getegid 50</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_acct 51</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_umount2 52</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lock 53</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ioctl 54</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fcntl 55</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mpx 56</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setpgid 57</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ulimit 58</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_oldolduname 59</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_umask 60</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_chroot 61</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ustat 62</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_dup2 63</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getppid 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpgrp 65</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setsid 66</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sigaction 67</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sgetmask 68</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ssetmask 69</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setreuid 70</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setregid 71</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sigsuspend 72</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sigpending 73</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sethostname 74</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setrlimit 75</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getrlimit 76</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getrusage 77</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_gettimeofday 78</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_settimeofday 79</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getgroups 80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setgroups 81</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_select 82</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_symlink 83</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_oldlstat 84</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_readlink 85</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_uselib 86</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_swapon 87</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_reboot 88</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_readdir 89</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mmap 90</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_munmap 91</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_truncate 92</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ftruncate 93</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchmod 94</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchown 95</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpriority 96</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setpriority 97</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_profil 98</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_statfs 99</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fstatfs 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ioperm 101</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_socketcall 102</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_syslog 103</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setitimer 104</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getitimer 105</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_stat 106</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lstat 107</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fstat 108</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_olduname 109</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_iopl 110</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vhangup 111</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_idle 112</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vm86old 113</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_wait4 114</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_swapoff 115</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sysinfo 116</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ipc 117</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fsync 118</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sigreturn 119</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clone 120</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setdomainname 121</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_uname 122</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_modify_ldt 123</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_adjtimex 124</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mprotect 125</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sigprocmask 126</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_create_module 127</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_init_module 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_delete_module 129</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_get_kernel_syms 130</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_quotactl 131</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpgid 132</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchdir 133</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_bdflush 134</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sysfs 135</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_personality 136</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_afs_syscall 137</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setfsuid 138</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setfsgid 139</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR__llseek 140</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getdents 141</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR__newselect 142</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_flock 143</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_msync 144</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_readv 145</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_writev 146</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getsid 147</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fdatasync 148</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR__sysctl 149</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mlock 150</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_munlock 151</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mlockall 152</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_munlockall 153</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_setparam 154</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_getparam 155</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_setscheduler 156</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_getscheduler 157</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_yield 158</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_get_priority_max 159</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_get_priority_min 160</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_rr_get_interval 161</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_nanosleep 162</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mremap 163</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setresuid 164</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getresuid 165</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vm86 166</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_query_module 167</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_poll 168</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_nfsservctl 169</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setresgid 170</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getresgid 171</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_prctl 172</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigreturn 173</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigaction 174</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigprocmask 175</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigpending 176</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigtimedwait 177</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigqueueinfo 178</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigsuspend 179</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pread64 180</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pwrite64 181</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_chown 182</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getcwd 183</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_capget 184</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_capset 185</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sigaltstack 186</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sendfile 187</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpmsg 188</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_putpmsg 189</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vfork 190</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ugetrlimit 191</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mmap2 192</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_truncate64 193</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ftruncate64 194</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_stat64 195</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lstat64 196</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fstat64 197</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lchown32 198</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getuid32 199</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getgid32 200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_geteuid32 201</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getegid32 202</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setreuid32 203</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setregid32 204</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getgroups32 205</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setgroups32 206</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchown32 207</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setresuid32 208</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getresuid32 209</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setresgid32 210</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getresgid32 211</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_chown32 212</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setuid32 213</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setgid32 214</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setfsuid32 215</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setfsgid32 216</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pivot_root 217</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mincore 218</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_madvise 219</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getdents64 220</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fcntl64 221</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_gettid 224</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_readahead 225</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setxattr 226</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lsetxattr 227</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fsetxattr 228</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getxattr 229</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lgetxattr 230</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fgetxattr 231</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_listxattr 232</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_llistxattr 233</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_flistxattr 234</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_removexattr 235</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lremovexattr 236</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fremovexattr 237</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_tkill 238</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sendfile64 239</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_futex 240</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_setaffinity 241</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_getaffinity 242</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_set_thread_area 243</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_get_thread_area 244</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_setup 245</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_destroy 246</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_getevents 247</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_submit 248</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_cancel 249</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fadvise64 250</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_exit_group 252</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lookup_dcookie 253</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_create 254</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_ctl 255</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_wait 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_remap_file_pages 257</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_set_tid_address 258</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_create 259</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_settime 260</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_gettime 261</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_getoverrun 262</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_delete 263</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clock_settime 264</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clock_gettime 265</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clock_getres 266</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clock_nanosleep 267</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_statfs64 268</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fstatfs64 269</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_tgkill 270</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_utimes 271</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fadvise64_64 272</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vserver 273</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mbind 274</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_get_mempolicy 275</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_set_mempolicy 276</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_open 277</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_unlink 278</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_timedsend 279</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_timedreceive 280</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_notify 281</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_getsetattr 282</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_kexec_load 283</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_waitid 284</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_add_key 286</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_request_key 287</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_keyctl 288</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ioprio_set 289</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ioprio_get 290</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_inotify_init 291</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_inotify_add_watch 292</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_inotify_rm_watch 293</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_migrate_pages 294</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_openat 295</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mkdirat 296</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mknodat 297</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchownat 298</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_futimesat 299</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fstatat64 300</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_unlinkat 301</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_renameat 302</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_linkat 303</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_symlinkat 304</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_readlinkat 305</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchmodat 306</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_faccessat 307</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pselect6 308</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ppoll 309</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_unshare 310</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_set_robust_list 311</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_get_robust_list 312</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_splice 313</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sync_file_range 314</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_tee 315</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vmsplice 316</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_move_pages 317</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getcpu 318</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_pwait 319</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_utimensat 320</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_signalfd 321</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timerfd_create 322</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_eventfd 323</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fallocate 324</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timerfd_settime 325</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timerfd_gettime 326</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_signalfd4 327</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_eventfd2 328</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_create1 329</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_dup3 330</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pipe2 331</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_inotify_init1 332</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_preadv 333</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pwritev 334</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_tgsigqueueinfo 335</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_perf_event_open 336</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_recvmmsg 337</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fanotify_init 338</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fanotify_mark 339</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_prlimit64 340</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_name_to_handle_at 341</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_open_by_handle_at 342</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clock_adjtime 343</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_syncfs 344</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sendmmsg 345</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setns 346</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_process_vm_readv 347</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_process_vm_writev 348</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_kcmp 349</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_finit_module 350</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_setattr 351</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_getattr 352</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_renameat2 353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_seccomp 354</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getrandom 355</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_memfd_create 356</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_bpf 357</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_execveat 358</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_socket 359</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_socketpair 360</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_bind 361</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_connect 362</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_listen 363</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_accept4 364</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getsockopt 365</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setsockopt 366</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getsockname 367</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpeername 368</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sendto 369</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sendmsg 370</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_recvfrom 371</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_recvmsg 372</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_shutdown 373</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_userfaultfd 374</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_membarrier 375</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mlock2 376</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_copy_file_range 377</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_preadv2 378</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pwritev2 379</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* _ASM_X86_UNISTD_32_H */</span></span></span><br></pre></td></tr></table></figure></div>

<h3 id="64-位"><a href="#64-位" class="headerlink" title="64 位"></a>64 位</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ASM_X86_UNISTD_64_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ASM_X86_UNISTD_64_H 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_read 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_write 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_open 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_close 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_stat 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fstat 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lstat 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_poll 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lseek 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mmap 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mprotect 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_munmap 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_brk 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigaction 13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigprocmask 14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigreturn 15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ioctl 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pread64 17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pwrite64 18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_readv 19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_writev 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_access 21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pipe 22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_select 23</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_yield 24</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mremap 25</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_msync 26</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mincore 27</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_madvise 28</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_shmget 29</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_shmat 30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_shmctl 31</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_dup 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_dup2 33</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pause 34</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_nanosleep 35</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getitimer 36</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_alarm 37</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setitimer 38</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpid 39</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sendfile 40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_socket 41</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_connect 42</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_accept 43</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sendto 44</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_recvfrom 45</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sendmsg 46</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_recvmsg 47</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_shutdown 48</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_bind 49</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_listen 50</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getsockname 51</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpeername 52</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_socketpair 53</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setsockopt 54</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getsockopt 55</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clone 56</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fork 57</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vfork 58</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_execve 59</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_exit 60</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_wait4 61</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_kill 62</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_uname 63</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_semget 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_semop 65</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_semctl 66</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_shmdt 67</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_msgget 68</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_msgsnd 69</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_msgrcv 70</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_msgctl 71</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fcntl 72</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_flock 73</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fsync 74</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fdatasync 75</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_truncate 76</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ftruncate 77</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getdents 78</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getcwd 79</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_chdir 80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchdir 81</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rename 82</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mkdir 83</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rmdir 84</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_creat 85</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_link 86</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_unlink 87</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_symlink 88</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_readlink 89</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_chmod 90</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchmod 91</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_chown 92</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchown 93</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lchown 94</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_umask 95</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_gettimeofday 96</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getrlimit 97</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getrusage 98</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sysinfo 99</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_times 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ptrace 101</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getuid 102</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_syslog 103</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getgid 104</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setuid 105</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setgid 106</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_geteuid 107</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getegid 108</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setpgid 109</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getppid 110</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpgrp 111</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setsid 112</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setreuid 113</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setregid 114</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getgroups 115</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setgroups 116</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setresuid 117</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getresuid 118</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setresgid 119</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getresgid 120</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpgid 121</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setfsuid 122</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setfsgid 123</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getsid 124</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_capget 125</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_capset 126</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigpending 127</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigtimedwait 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigqueueinfo 129</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigsuspend 130</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sigaltstack 131</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_utime 132</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mknod 133</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_uselib 134</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_personality 135</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ustat 136</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_statfs 137</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fstatfs 138</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sysfs 139</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpriority 140</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setpriority 141</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_setparam 142</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_getparam 143</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_setscheduler 144</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_getscheduler 145</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_get_priority_max 146</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_get_priority_min 147</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_rr_get_interval 148</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mlock 149</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_munlock 150</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mlockall 151</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_munlockall 152</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vhangup 153</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_modify_ldt 154</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pivot_root 155</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR__sysctl 156</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_prctl 157</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_arch_prctl 158</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_adjtimex 159</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setrlimit 160</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_chroot 161</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sync 162</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_acct 163</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_settimeofday 164</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mount 165</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_umount2 166</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_swapon 167</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_swapoff 168</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_reboot 169</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sethostname 170</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setdomainname 171</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_iopl 172</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ioperm 173</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_create_module 174</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_init_module 175</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_delete_module 176</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_get_kernel_syms 177</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_query_module 178</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_quotactl 179</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_nfsservctl 180</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpmsg 181</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_putpmsg 182</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_afs_syscall 183</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_tuxcall 184</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_security 185</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_gettid 186</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_readahead 187</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setxattr 188</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lsetxattr 189</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fsetxattr 190</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getxattr 191</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lgetxattr 192</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fgetxattr 193</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_listxattr 194</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_llistxattr 195</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_flistxattr 196</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_removexattr 197</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lremovexattr 198</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fremovexattr 199</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_tkill 200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_time 201</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_futex 202</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_setaffinity 203</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_getaffinity 204</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_set_thread_area 205</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_setup 206</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_destroy 207</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_getevents 208</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_submit 209</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_cancel 210</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_get_thread_area 211</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lookup_dcookie 212</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_create 213</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_ctl_old 214</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_wait_old 215</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_remap_file_pages 216</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getdents64 217</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_set_tid_address 218</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_restart_syscall 219</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_semtimedop 220</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fadvise64 221</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_create 222</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_settime 223</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_gettime 224</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_getoverrun 225</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_delete 226</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clock_settime 227</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clock_gettime 228</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clock_getres 229</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clock_nanosleep 230</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_exit_group 231</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_wait 232</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_ctl 233</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_tgkill 234</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_utimes 235</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vserver 236</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mbind 237</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_set_mempolicy 238</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_get_mempolicy 239</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_open 240</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_unlink 241</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_timedsend 242</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_timedreceive 243</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_notify 244</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_getsetattr 245</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_kexec_load 246</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_waitid 247</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_add_key 248</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_request_key 249</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_keyctl 250</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ioprio_set 251</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ioprio_get 252</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_inotify_init 253</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_inotify_add_watch 254</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_inotify_rm_watch 255</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_migrate_pages 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_openat 257</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mkdirat 258</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mknodat 259</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchownat 260</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_futimesat 261</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_newfstatat 262</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_unlinkat 263</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_renameat 264</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_linkat 265</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_symlinkat 266</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_readlinkat 267</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchmodat 268</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_faccessat 269</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pselect6 270</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ppoll 271</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_unshare 272</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_set_robust_list 273</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_get_robust_list 274</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_splice 275</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_tee 276</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sync_file_range 277</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vmsplice 278</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_move_pages 279</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_utimensat 280</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_pwait 281</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_signalfd 282</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timerfd_create 283</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_eventfd 284</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fallocate 285</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timerfd_settime 286</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timerfd_gettime 287</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_accept4 288</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_signalfd4 289</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_eventfd2 290</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_create1 291</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_dup3 292</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pipe2 293</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_inotify_init1 294</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_preadv 295</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pwritev 296</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_tgsigqueueinfo 297</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_perf_event_open 298</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_recvmmsg 299</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fanotify_init 300</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fanotify_mark 301</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_prlimit64 302</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_name_to_handle_at 303</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_open_by_handle_at 304</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clock_adjtime 305</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_syncfs 306</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sendmmsg 307</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setns 308</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getcpu 309</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_process_vm_readv 310</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_process_vm_writev 311</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_kcmp 312</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_finit_module 313</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_setattr 314</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_getattr 315</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_renameat2 316</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_seccomp 317</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getrandom 318</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_memfd_create 319</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_kexec_file_load 320</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_bpf 321</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_execveat 322</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_userfaultfd 323</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_membarrier 324</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mlock2 325</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_copy_file_range 326</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_preadv2 327</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pwritev2 328</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* _ASM_X86_UNISTD_64_H */</span></span></span><br></pre></td></tr></table></figure></div>

<h1 id="程序编译过程"><a href="#程序编译过程" class="headerlink" title="程序编译过程"></a>程序编译过程</h1><p>从源码到最终 ELF 可执行文件（或共享库），通常会经历几个主要阶段：</p>
<blockquote>
<p>源代码（<code>.c</code> &#x2F; <code>.cpp</code>）<br>➜ <strong>预处理</strong>（生成 <code>.i</code> &#x2F; <code>.ii</code>）<br>➜ <strong>编译</strong>（生成汇编 <code>.s</code>）<br>➜ <strong>汇编</strong>（生成目标文件 <code>.o</code>）<br>➜ <strong>链接</strong>（生成 ELF 可执行文件 &#x2F; 共享库）</p>
</blockquote>
<p>从源文件编译链接形成 ELF 文件的过程如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux%20user%20pwn%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/images/image-20241108004250085.png"
                      alt="image-20241108004250085"
                ></p>
<h2 id="预处理（Preprocessing）"><a href="#预处理（Preprocessing）" class="headerlink" title="预处理（Preprocessing）"></a>预处理（Preprocessing）</h2><p>预处理阶段由预处理器（通常是 GCC 内部的 cpp 前端）完成，把源文件和头文件“拼装 + 展开”成一个纯文本的中间文件：</p>
<ul>
<li><p>C 源文件：</p>
<ul>
<li>源文件扩展名：<code>.c</code></li>
<li>预处理后扩展名：<code>.i</code></li>
</ul>
</li>
<li><p>C++ 源文件：</p>
<ul>
<li>源文件扩展名：<code>.cpp</code> &#x2F; <code>.cxx</code> 等</li>
<li>预处理后扩展名：<code>.ii</code></li>
</ul>
</li>
</ul>
<p>典型命令（<code>-E</code> 表示“只做预处理，不继续编译”）：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure></div>

<p>或者直接调用预处理器：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpp hello.c &gt; hello.i</span><br></pre></td></tr></table></figure></div>

<p>预处理阶段主要处理所有以 <code>#</code> 开头的预处理指令，常见规则包括：</p>
<ul>
<li><p>展开和移除宏定义</p>
<ul>
<li>展开所有通过 <code>#define</code> 定义的宏；</li>
<li>源文件里的 <code>#define</code> 本身不会出现在 <code>.i</code> 中（系统头里的一些实现细节可能因选项不同略有差异）。</li>
</ul>
</li>
<li><p>处理条件编译指令</p>
<ul>
<li>如 <code>#if</code> &#x2F; <code>#ifdef</code> &#x2F; <code>#elif</code> &#x2F; <code>#else</code> &#x2F; <code>#endif</code>；</li>
<li>根据条件选择性地保留或丢弃代码块。</li>
</ul>
</li>
<li><p>展开 <code>#include</code></p>
<ul>
<li>将被包含的头文件内容“内联”到当前文件中；</li>
<li>这个过程是递归的：包含的文件里还可以继续 <code>#include</code> 其他文件。</li>
</ul>
</li>
<li><p>删除注释</p>
<ul>
<li>删除所有 <code>//</code> 和 <code>/* ... */</code> 注释（变成纯代码文本）。</li>
</ul>
</li>
<li><p>插入行号和文件名标记</p>
<ul>
<li><p>生成类似下面这样的行标记：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">2</span> <span class="string">&quot;hello.c&quot;</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>这些用于：</p>
<ul>
<li>编译器在报错&#x2F;告警时能正确显示“原始源文件 + 行号”；</li>
<li>生成调试信息时记录源码位置。</li>
</ul>
</li>
</ul>
</li>
<li><p>保留必要的 <code>#pragma</code></p>
<ul>
<li><code>#pragma</code> 指令通常会被保留下来，由后续编译阶段处理。</li>
</ul>
</li>
</ul>
<p>预处理之后得到的 <code>.i</code> &#x2F; <code>.ii</code> 文件本质上还是 <strong>C&#x2F;C++ 源代码</strong>，只是：</p>
<ul>
<li>所有宏都已经展开；</li>
<li>所有 <code>#include</code> 的头文件都已经展开进来；</li>
<li>不再包含一般的预处理指令（除了行标记和部分 <code>#pragma</code>）。</li>
</ul>
<h2 id="编译（Compilation）"><a href="#编译（Compilation）" class="headerlink" title="编译（Compilation）"></a>编译（Compilation）</h2><p>编译阶段的任务是：<strong>把预处理后的源代码翻译成目标机器的汇编代码</strong>。</p>
<p>编译器在这一阶段会进行：</p>
<ul>
<li>词法分析（Lexical Analysis）：把字符流切分成 token；</li>
<li>语法分析（Parsing）：检查语法是否合法，构建语法树；</li>
<li>语义分析（Semantic Analysis）：类型检查、作用域解析、常量折叠等；</li>
<li>中间表示（IR）生成与优化：如常量传播、死代码删除、循环优化等；</li>
<li>目标相关优化：指令选择、寄存器分配等；</li>
<li>输出汇编代码（<code>.s</code> 文件）。</li>
</ul>
<p>常见命令示例（从预处理后的 <code>.i</code> 出发）：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.i -o hello.s</span><br></pre></td></tr></table></figure></div>

<p>一般更常用的是直接从 <code>.c</code> 开始，让 GCC 自动完成“预处理 + 编译”两步：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.c -o hello.s</span><br></pre></td></tr></table></figure></div>

<p>此时生成的 <code>hello.s</code> 是与平台&#x2F;架构相关的 <strong>汇编代码</strong>。</p>
<h2 id="汇编（Assembly）"><a href="#汇编（Assembly）" class="headerlink" title="汇编（Assembly）"></a>汇编（Assembly）</h2><p>汇编阶段由汇编器（如 GNU <code>as</code>，但通常通过 <code>gcc</code> 间接调用）完成，把 <code>.s</code> 汇编代码翻译成机器码，生成 <strong>目标文件（Object File，<code>.o</code>）</strong>。</p>
<ul>
<li><p>每条汇编指令大多对应一条机器指令（也会有伪指令、宏指令等间接映射的情况）；</p>
</li>
<li><p>相比编译器，汇编器的工作相对简单：</p>
<ul>
<li>不再做高级语言的语法&#x2F;语义分析；</li>
<li>主要负责解析汇编伪指令、符号、重定位信息、节布局等；</li>
<li>将其组织成符合目标平台 ABI 的 ELF 目标文件。</li>
</ul>
</li>
</ul>
<p>可以直接调用汇编器：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">as hello.s -o hello.o</span><br></pre></td></tr></table></figure></div>

<p>更常见的是用 <code>gcc</code> 一步从 C 源码生成 <code>.o</code>，让它在内部自动完成“预处理 + 编译 + 汇编”：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.c -o hello.o</span><br></pre></td></tr></table></figure></div>

<p><code>-c</code> 的含义是：<strong>只生成目标文件，不进行链接</strong>。</p>
<p>得到的 <code>hello.o</code> 一般是 ELF 格式的 <code>ET_REL</code> 文件，包含：</p>
<ul>
<li>机器指令和数据；</li>
<li>符号表、重定位表等链接所需的信息。</li>
</ul>
<h2 id="链接（Linking）"><a href="#链接（Linking）" class="headerlink" title="链接（Linking）"></a>链接（Linking）</h2><p>“编译过程中的链接阶段” &#x3D; 由 <code>ld</code> 完成的，把一堆 <code>.o</code> 和库文件合成一个 ELF 的那一步，它是所有程序（无论静态还是动态链接）都会经历的统一阶段。</p>
<p>这一阶段对应如下命令：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc main.o foo.o -o prog      <span class="comment"># gcc 在背后帮你调用 ld</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">ld main.o foo.o ... -o prog   <span class="comment"># 直接调用链接器</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>输入：</strong></p>
<ul>
<li><p>一个或多个 <strong>目标文件</strong>：<code>main.o</code>、<code>foo.o</code> …</p>
<ul>
<li><p>内部是 ELF <code>ET_REL</code>，包含：</p>
<ul>
<li>各种节：<code>.text</code>、<code>.data</code>、<code>.bss</code> 等</li>
<li>符号表 <code>.symtab</code> &#x2F; 字符串表 <code>.strtab</code></li>
<li>重定位表 <code>.rel.text</code>、<code>.rel.data</code> &#x2F; <code>.rela.*</code></li>
</ul>
</li>
</ul>
</li>
<li><p>若干 <strong>库文件</strong>：</p>
<ul>
<li><p>静态库：<code>libxxx.a</code></p>
<ul>
<li>其实是很多 <code>.o</code> 的打包（ar 格式），链接器会按需从里面挑成员出来用</li>
</ul>
</li>
<li><p>共享库：<code>libxxx.so</code></p>
<ul>
<li>ELF <code>ET_DYN</code> 文件</li>
</ul>
</li>
</ul>
</li>
<li><p>启动文件 &#x2F; 运行时：</p>
<ul>
<li><code>crt1.o</code>、<code>crti.o</code>、<code>crtn.o</code> 等 C 运行库的启动代码</li>
<li><code>libgcc.a</code> 等编译器运行时支持库</li>
</ul>
</li>
</ul>
<p><strong>输出：</strong></p>
<ul>
<li><strong>可执行文件</strong>：<code>prog</code><ul>
<li>传统非 PIE：<code>ET_EXEC</code></li>
<li>PIE：<code>ET_DYN</code>，但带入口、可直接运行</li>
</ul>
</li>
<li>或者 <strong>共享库</strong>：<code>libxxx.so</code>（ELF <code>ET_DYN</code>）</li>
</ul>
</blockquote>
<p>静态 &#x2F; 动态程序的区别，只在于链接器把多少工作留到运行时去做。</p>
<blockquote>
<p>站在“编译期链接器”的角度：</p>
<ul>
<li><p><strong>静态链接程序（<code>-static</code>）</strong></p>
<ul>
<li>把用到的静态库 <code>.a</code> 中的函数 &#x2F; 变量实现代码都拷贝进最终可执行文件；</li>
<li>尽量在链接阶段把所有符号地址定死；</li>
<li>最终 ELF 通常没有 <code>PT_INTERP</code>，运行时不需要动态链接器参与；</li>
<li>GOT&#x2F;PLT 也可以存在，但只在程序内部跳，不依赖外部 <code>.so</code>。</li>
</ul>
</li>
<li><p><strong>动态链接程序（默认）</strong></p>
<ul>
<li><p>自己的 <code>.o</code> + 启动文件依然正常合并、重定位；</p>
</li>
<li><p>对共享库 <code>.so</code>：</p>
<ul>
<li>不复制代码，只登记依赖（<code>DT_NEEDED</code>）；</li>
<li>建好 <code>.dynsym</code> &#x2F; <code>.dynstr</code> &#x2F; <code>.rela.*</code> &#x2F; <code>.plt</code> &#x2F; <code>.got</code> 等结构；</li>
<li>留下一部分重定位条目由动态链接器在运行时处理。</li>
</ul>
</li>
<li><p>最终 ELF 一定有 <code>PT_INTERP</code>（指定动态链接器）。</p>
</li>
</ul>
</li>
</ul>
<p>所以，编译阶段的“链接”<strong>总是存在</strong>，无论你生成的是静态程序还是动态程序，只是：</p>
<ul>
<li>静态程序：绝大部分链接工作在这一阶段一次性完成；</li>
<li>动态程序：这一阶段先完成一部分，剩下交给运行时的动态链接器继续做。</li>
</ul>
</blockquote>
<h3 id="ELF-相关结构"><a href="#ELF-相关结构" class="headerlink" title="ELF 相关结构"></a>ELF 相关结构</h3><p>在 <strong>可重定位目标文件（<code>ET_REL</code>，即 <code>.o</code>）</strong> 中，链接器主要依赖以下信息完成“静态链接”：</p>
<ul>
<li><p>符号表：<code>.symtab</code>（<code>SHT_SYMTAB</code>，元素类型 <code>Elf*_Sym</code>）</p>
</li>
<li><p>字符串表：<code>.strtab</code>（存放符号名等）</p>
</li>
<li><p>重定位表：</p>
<ul>
<li>代码相关：<code>.rel.text</code> &#x2F; <code>.rela.text</code></li>
<li>数据相关：<code>.rel.data</code> &#x2F; <code>.rela.data</code></li>
</ul>
</li>
<li><p>以及各种属性节（<code>.text</code> &#x2F; <code>.data</code> &#x2F; <code>.bss</code> 等）</p>
</li>
</ul>
<p><strong>静态链接时使用的重定位节（<code>.rel.text</code> &#x2F; <code>.rela.text</code>、<code>.rel.data</code> &#x2F; <code>.rela.data</code> 等）只存在于 <code>ET_REL</code> 这样的中间目标文件中</strong>。</p>
<p>当链接器把多个 <code>.o</code> 合成最终的 <strong>可执行文件（<code>ET_EXEC</code>）</strong> 或 <strong>共享对象 &#x2F; PIE（<code>ET_DYN</code>）</strong> 时，会：</p>
<ul>
<li><p>读取这些重定位条目；</p>
</li>
<li><p>把对应位置的指令 &#x2F; 数据修正好；</p>
</li>
<li><p><strong>通常会把这些“静态重定位节”删掉</strong>，所以在最终 ELF 里一般看不到 <code>.rel.text</code> &#x2F; <code>.rel.data</code> 之类。</p>
<blockquote>
<p>当链接器把一堆 <code>.o</code> 链起来之后，<strong>静态链接这轮其实已经结束了</strong>，从链接器的角度：</p>
<ul>
<li>符号都已经解析好了；</li>
<li>该重定位的都打好补丁了；</li>
<li>那么理论上，“给静态链接用的那些 <code>.symtab</code> &#x2F; <code>.strtab</code> &#x2F; <code>.rel.*</code> 也可以不用保留了”。</li>
</ul>
<p>所以从 <strong>纯“执行程序”角度</strong> 看：</p>
<ul>
<li>**运行时不需要 <code>.symtab</code> &#x2F; <code>.strtab</code>**（动态链接用的是 <code>.dynsym</code> &#x2F; <code>.dynstr</code>，那是另一套）；</li>
<li>也不需要 <code>.rel.text</code> &#x2F; <code>.rel.data</code>（静态链接用完就扔了）；</li>
<li>留它们只是方便<strong>人类和工具</strong>（调试、反汇编、分析等）。</li>
</ul>
<p>关键点：<strong>链接器的默认行为是“生成未 strip 的二进制”</strong>——方便你：</p>
<ul>
<li>用 <code>gdb</code> 调试；</li>
<li>用 <code>nm</code> &#x2F; <code>objdump</code> 看符号名；</li>
<li>在崩溃 backtrace 中能打印出函数名，而不仅是地址。</li>
</ul>
<p>而且注意：</p>
<ul>
<li><code>.symtab</code> 就算没有 <code>-g</code>，通常也会存在（只是符号信息没那么丰富）；</li>
<li><code>-g</code> 控制的是生成 <code>.debug_*</code> 等 <strong>DWARF 调试信息节</strong>（<code>.debug_info</code>、<code>.debug_line</code>、<code>.debug_abbrev</code> 等），而不直接控制 <code>.symtab</code> 是否出现。</li>
</ul>
<p>换句话说：</p>
<ul>
<li><code>.symtab</code> &#x2F; <code>.strtab</code> &#x3D; <strong>符号表 + 名字表</strong>，链接器必用，在最终 ELF 里保留与否是“方便人”的选择；</li>
<li><code>-g</code> &#x3D; “生成详细调试信息（DWARF）”，主要体现在 <code>.debug_*</code> 这些节上。</li>
</ul>
<p>真正控制 <code>.symtab</code> &#x2F; <code>.strtab</code> 要不要留的，是 <strong><code>strip</code> 或链接器选项</strong>，比如：</p>
<ul>
<li><p><code>strip prog</code> &#x2F; <code>strip --strip-all prog</code></p>
<ul>
<li>会干掉大部分符号信息（包括 <code>.symtab</code>、<code>.strtab</code>、<code>.debug_*</code> 等）；</li>
</ul>
</li>
<li><p><code>strip --strip-debug prog</code></p>
<ul>
<li>只删调试节 <code>.debug_*</code>，通常会保留必要的符号（比如 <code>.dynsym</code>），具体行为看实现；</li>
</ul>
</li>
<li><p>链接时用 <code>-Wl,--strip-all</code> &#x2F; <code>-s</code>：</p>
<ul>
<li>直接让 ld 在生成时就去掉符号。</li>
</ul>
</li>
</ul>
<p>这就是为什么：</p>
<ul>
<li>你看到有些 pwn 题附件有函数名、有 <code>.symtab</code>（没 strip 或只 strip 了调试信息）；</li>
<li>有些则啥名都没了，只剩下 <code>.dynsym</code> 或极少量符号（被 strip 过）。</li>
</ul>
</blockquote>
</li>
</ul>
<p>与之对应，<strong>最终的可执行文件 &#x2F; 共享对象里还会保留一套“动态重定位信息”</strong>（例如 <code>.rela.dyn</code>、<code>.rela.plt</code>），是给 <strong>动态链接器在运行时</strong> 用的，主要用于：</p>
<ul>
<li>根据实际装载地址（ASLR &#x2F; PIE）修正 GOT、静态指针等（<code>R_*_RELATIVE</code>）；</li>
<li>修正导入函数 &#x2F; 变量（<code>R_*_JUMP_SLOT</code>、<code>R_*_GLOB_DAT</code> 等）。</li>
</ul>
<h4 id="符号表（-symtab）"><a href="#符号表（-symtab）" class="headerlink" title="符号表（.symtab）"></a>符号表（<code>.symtab</code>）</h4><p>在 ELF 文件中，<strong>静态符号表</strong>通常是一个名为 <code>.symtab</code> 的节：</p>
<ul>
<li>节类型：<code>SHT_SYMTAB</code></li>
<li>元素类型：<code>Elf32_Sym</code> &#x2F; <code>Elf64_Sym</code> 数组</li>
</ul>
<p>以 32 位为例：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Symbol table entry.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word    st_name;   <span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  Elf32_Addr    st_value;  <span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf32_Word    st_size;   <span class="comment">/* Symbol size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_info;   <span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_other;  <span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf32_Section st_shndx;  <span class="comment">/* Section index */</span></span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure></div>

<p>各字段含义：</p>
<ul>
<li><p><strong><code>st_name</code>：符号名索引</strong></p>
<ul>
<li>指向某个 <strong>字符串表节</strong>（通常是 <code>.strtab</code>）中的偏移；</li>
<li>字符串表的<strong>节索引（section index）</strong>由符号表节头的 <code>sh_link</code> 指定。</li>
</ul>
</li>
<li><p><strong><code>st_value</code>：符号值</strong></p>
<ul>
<li><p>在 <strong>可重定位文件（<code>ET_REL</code>）</strong> 中：</p>
<ul>
<li><p>如果符号是定义在某个节里的（且 <code>st_shndx</code> 不是特殊值，例如既不是 <code>SHN_UNDEF</code> 也不是 <code>SHN_COMMON</code>），<br>则 <code>st_value</code> 表示 <strong>相对于该节起始地址的偏移</strong>；</p>
</li>
<li><p>如果 <code>st_shndx == SHN_COMMON</code>（所谓“COMMON 块”&#x2F;暂定定义），<br>则：</p>
<ul>
<li><code>st_value</code> 表示该符号所需的 <strong>对齐</strong>；</li>
<li><code>st_size</code> 表示所需空间大小。</li>
</ul>
<p>链接器最终会把这些符号分配到 <code>.bss</code> 等处。</p>
</li>
</ul>
</li>
<li><p>在 <strong>可执行文件 &#x2F; 共享对象（<code>ET_EXEC</code> &#x2F; <code>ET_DYN</code>）</strong> 中：</p>
<ul>
<li>对带 <code>STB_GLOBAL</code> &#x2F; <code>STB_WEAK</code> 等可见性符号，<code>st_value</code> 一般表示符号的 <strong>虚拟地址</strong>（或相对装载基址的偏移）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>st_size</code>：符号大小</strong></p>
<ul>
<li>对函数符号：通常是函数机器码的长度；</li>
<li>对对象符号：是该对象占用的字节数；</li>
<li>若为 0：表示大小为 0 或未知（链接器 &#x2F; 调试器会根据实际上下文处理）。</li>
</ul>
</li>
<li><p><strong><code>st_info</code>：类型 + 绑定</strong></p>
<ul>
<li><p>这是一个打包字段：</p>
<ul>
<li>高 4 位：<strong>绑定（binding）</strong>，<code>STB_LOCAL</code> &#x2F; <code>STB_GLOBAL</code> &#x2F; <code>STB_WEAK</code> 等；</li>
<li>低 4 位：<strong>类型（type）</strong>，<code>STT_NOTYPE</code> &#x2F; <code>STT_OBJECT</code> &#x2F; <code>STT_FUNC</code> &#x2F; <code>STT_SECTION</code> 等。</li>
</ul>
</li>
<li><p>取值一般通过宏：</p>
<ul>
<li><p><code>ELF32_ST_BIND(st_info)</code> 得到绑定；</p>
</li>
<li><p><code>ELF32_ST_TYPE(st_info)</code> 得到类型；</p>
</li>
<li><p><code>ELF32_ST_INFO(bind, type)</code> 组装。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>st_other</code>：可见性等信息</strong></p>
<ul>
<li>低 2 位通常表示 <strong>符号可见性</strong>：<code>STV_DEFAULT</code> &#x2F; <code>STV_HIDDEN</code> &#x2F; <code>STV_PROTECTED</code> 等；</li>
<li>其它位保留，一般为 0。</li>
</ul>
</li>
<li><p><strong><code>st_shndx</code>：所在节索引 &#x2F; 特殊标记</strong></p>
<ul>
<li><p>一般情况：</p>
<ul>
<li><code>st_shndx</code> 为某个有效节号，表示符号定义于该节；</li>
</ul>
</li>
<li><p>特殊情况（部分）：</p>
<ul>
<li><code>SHN_UNDEF</code>：未定义符号（当前文件中只引用、未定义），需要在链接时从其他目标文件 &#x2F; 库中解析。</li>
<li><code>SHN_ABS</code>：绝对符号，其值不随重定位变化（如某些常量）。</li>
<li><code>SHN_COMMON</code>：COMMON 符号（见上：<code>st_value</code> 表示对齐，<code>st_size</code> 为空间大小）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="重定位表（-rel-rela-）"><a href="#重定位表（-rel-rela-）" class="headerlink" title="重定位表（.rel.* &#x2F; .rela.*）"></a>重定位表（<code>.rel.*</code> &#x2F; <code>.rela.*</code>）</h4><p>在 <strong>静态链接阶段</strong>，链接器通过重定位表知道“哪些位置需要根据符号的最终地址进行修正”。</p>
<p>常见的“静态重定位节”有：</p>
<ul>
<li><code>.rel.text</code> &#x2F; <code>.rela.text</code>：对 <code>.text</code> 代码节中的重定位；</li>
<li><code>.rel.data</code> &#x2F; <code>.rela.data</code>：对 <code>.data</code> 等数据节中的重定位。</li>
</ul>
<blockquote>
<p><code>.rel.*</code> 和 <code>.rela.*</code> 都是“重定位节”，区别在于：**<code>.rel.*</code> 用的是 <code>Elf*_Rel</code>，没有显式 addend；**</p>
<ul>
<li><p><code>.rel.*</code>：节类型是 **<code>SHT_REL</code>**，元素结构是 <code>Elf32_Rel</code> &#x2F; <code>Elf64_Rel</code>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Addr r_offset; <span class="comment">/* Address */</span></span><br><span class="line">    Elf32_Word r_info;   <span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure></div>

<p>没有 <code>r_addend</code> 字段。</p>
</li>
<li><p><code>.rela.*</code>：节类型是 **<code>SHT_RELA</code>**，元素结构是 <code>Elf32_Rela</code> &#x2F; <code>Elf64_Rela</code>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Addr  r_offset; <span class="comment">/* Address */</span></span><br><span class="line">    Elf32_Word  r_info;   <span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">    Elf32_Sword r_addend; <span class="comment">/* Addend */</span></span><br><span class="line">&#125; Elf32_Rela;</span><br></pre></td></tr></table></figure></div>

<p>多了一个 <strong><code>r_addend</code></strong> 字段。</p>
</li>
</ul>
<p>节名的约定通常是：</p>
<ul>
<li>用 <code>SHT_REL</code> 的节叫 <code>.rel.xxx</code></li>
<li>用 <code>SHT_RELA</code> 的节叫 <code>.rela.xxx</code></li>
</ul>
<p>名字本身没有魔法，只是惯例；真正的区别在 <code>sh_type</code> 和表项结构体。</p>
<p>所有 ELF 重定位的计算本质都是类似：</p>
<blockquote>
<p>新值 &#x3D; 符号值 <code>S</code> + addend <code>A</code>（再根据重定位类型决定是不是还要加 <code>P</code> 等）</p>
</blockquote>
<p>区别只在于 <strong>addend <code>A</code> 从哪儿来</strong>：</p>
<ul>
<li><p><code>Elf*_Rel</code> 里没有 <code>r_addend</code> 字段；<strong>addend 存在被重定位的位置本身</strong>：</p>
<ul>
<li><p>对 <code>ET_REL</code>：编译器&#x2F;汇编器在生成 <code>.o</code> 时，把一个“初始值”写到 <code>r_offset</code> 对应的位置；</p>
</li>
<li><p>链接器 &#x2F; 动态链接器在做重定位时：</p>
<ol>
<li>先读出当前位置原来的内容，作为 addend <code>A</code>；</li>
<li>用 <code>S</code>、<code>A</code>、重定位类型算出新值；</li>
<li>再把新值写回这个位置。</li>
</ol>
</li>
</ul>
<p>可以理解为：<strong>“addend 嵌在代码&#x2F;数据里”</strong>。</p>
</li>
<li><p><code>Elf*_Rela</code> 里有显式的 <code>r_addend</code>；**addend 不再从内存中读，而是直接用表项里的 <code>r_addend</code>**：</p>
<ul>
<li>计算时直接用 <code>A = r_addend</code>，然后根据类型算出新值写到 <code>r_offset</code> 位置；</li>
<li>重定位前，<code>r_offset</code> 对应地址里的内容对计算不重要（往往是 0）。</li>
</ul>
<p>可以理解为：<strong>“addend 单独存在重定位表里”</strong>。</p>
</li>
</ul>
</blockquote>
<p>以 32 位 <code>REL</code> 为例（不带 addend）：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Relocation table entry without addend (in section of type SHT_REL).  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Addr r_offset; <span class="comment">/* Address */</span></span><br><span class="line">  Elf32_Word r_info;   <span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure></div>

<p>各字段含义：</p>
<ul>
<li><p><strong><code>r_offset</code>：待修正位置</strong></p>
<ul>
<li><p>对于 <strong>可重定位文件（<code>ET_REL</code>）</strong>：</p>
<ul>
<li><code>r_offset</code> 表示“需要重定位的位置相对于所属节起始的偏移”；</li>
<li>哪个节要被重定位，是通过重定位节头的 <code>sh_info</code> 字段指向的。</li>
</ul>
</li>
<li><p>对于最终的 <strong>可执行文件 &#x2F; 共享对象中的动态重定位表（如 <code>.rela.dyn</code> &#x2F; <code>.rela.plt</code>）</strong>：</p>
<ul>
<li><p><code>r_offset</code> 一般是“待修正位置的虚拟地址”或者装载基址上的偏移；</p>
</li>
<li><p>这时是动态链接器在运行时根据它进行修正。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>r_info</code>：符号索引 + 重定位类型</strong></p>
<ul>
<li><p>这是一个打包字段，包含：</p>
<ul>
<li>符号索引（指向某个符号表条目，一般是 <code>.symtab</code> &#x2F; <code>.dynsym</code>）；</li>
<li>重定位类型（<code>R_*</code>）；</li>
</ul>
</li>
<li><p>在 32 位 System V ABI 下，通常约定：</p>
<ul>
<li><p>低若干位为重定位类型；</p>
</li>
<li><p>高若干位为符号索引；</p>
</li>
<li><p>glibc 提供宏：</p>
<ul>
<li><code>ELF32_R_SYM(r_info)</code>：取符号索引；</li>
<li><code>ELF32_R_TYPE(r_info)</code>：取重定位类型；</li>
<li><code>ELF32_R_INFO(sym, type)</code>：组合。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>对 <code>RELA</code> 形式（<code>Elf32_Rela</code> &#x2F; <code>Elf64_Rela</code>）还会多一个 <code>r_addend</code> 字段，表示显式的加数，用法与具体重定位类型相关。</p>
</li>
</ul>
<h3 id="链接过程"><a href="#链接过程" class="headerlink" title="链接过程"></a>链接过程</h3><h4 id="收集-合并节"><a href="#收集-合并节" class="headerlink" title="收集 &amp; 合并节"></a>收集 &amp; 合并节</h4><ul>
<li><p>每个 <code>.o</code> 里都有自己的 <code>.text</code> &#x2F; <code>.data</code> &#x2F; <code>.rodata</code> &#x2F; <code>.bss</code> 等节；</p>
</li>
<li><p>链接器根据<strong>链接脚本</strong>（默认或自定义）的规则，把多个目标文件里的同类节合并在一起，例如：</p>
<ul>
<li>所有 <code>.text</code> → 合成一个大的 <code>.text</code>；</li>
<li>所有 <code>.data</code> → 合成一个大的 <code>.data</code>；</li>
<li>所有 <code>.bss</code> → 合成一个大的 <code>.bss</code>；</li>
</ul>
</li>
<li><p>同时决定它们在最终 ELF 中的<strong>文件布局顺序</strong>、<strong>对齐方式</strong>等。</p>
</li>
</ul>
<h4 id="符号解析（Symbol-Resolution）"><a href="#符号解析（Symbol-Resolution）" class="headerlink" title="符号解析（Symbol Resolution）"></a>符号解析（Symbol Resolution）</h4><p>核心问题就是一句话：</p>
<blockquote>
<p>“这个符号到底是哪个 <code>.o</code> &#x2F; 库里定义的？它对应哪一段代码或哪个变量？”</p>
</blockquote>
<p>链接器会：</p>
<ul>
<li><p><strong>扫描所有 <code>.o</code> 和库文件</strong>，读取它们的 <code>.symtab</code> &#x2F; <code>.strtab</code>：</p>
<ul>
<li>找到每个“<strong>符号名 → 定义位置</strong>”的对应关系；</li>
<li>本地符号（<code>STB_LOCAL</code>）只在各自目标文件内部使用，不参与全局解析；</li>
<li>全局 &#x2F; 弱符号（<code>STB_GLOBAL</code> &#x2F; <code>STB_WEAK</code>）参与跨文件可见的解析。</li>
</ul>
</li>
<li><p>处理<strong>未定义符号</strong>（<code>st_shndx == SHN_UNDEF</code>）：</p>
<ul>
<li>在当前 <code>.o</code> 里只被引用，没有定义；</li>
<li>链接器会在其它 <code>.o</code> 或库中寻找相应的定义；</li>
<li>找不到就报“未定义引用”。</li>
</ul>
</li>
<li><p>对 <strong>静态库 <code>.a</code></strong> 的特殊处理：</p>
<ul>
<li><code>.a</code> 是很多 <code>.o</code> 的集合，链接器不会一次性把所有成员都拉进来；</li>
<li>只有当某个未定义符号需要时，才<strong>按需从 <code>.a</code> 中挑出某个 <code>.o</code> 加入链接</strong>；</li>
<li>没有被用到的成员 <code>.o</code> 不会被加入最终文件。</li>
</ul>
</li>
<li><p>冲突检查：</p>
<ul>
<li>同名全局符号在多个文件中均为强符号定义：报多重定义错误；</li>
<li>弱符号（<code>STB_WEAK</code>）与强符号之间有一套优先级规则：通常是“强覆盖弱”。</li>
</ul>
</li>
</ul>
<p><strong>这一步的结果是：</strong></p>
<blockquote>
<p>对于每一个“需要被引用的符号”，链接器都知道它：</p>
<ul>
<li>在最终合并后的哪个节里；</li>
<li>偏移多少；</li>
<li>大小是多少。</li>
</ul>
</blockquote>
<h4 id="地址分配-静态重定位（Relocation）"><a href="#地址分配-静态重定位（Relocation）" class="headerlink" title="地址分配 &amp; 静态重定位（Relocation）"></a>地址分配 &amp; 静态重定位（Relocation）</h4><p>在有了“全局布局 + 符号解析结果”之后，链接器开始做“<strong>修地址</strong>”的工作。</p>
<ul>
<li><p><strong>地址分配（Assign Addresses）</strong> ：为合并后的 <code>.text</code> &#x2F; <code>.data</code> &#x2F; <code>.bss</code> 等分配<strong>文件偏移</strong>和<strong>虚拟地址区间</strong>；</p>
<ul>
<li><p>对 <code>ET_EXEC</code> 类型的可执行文件：一般以某个固定基址为起点（例如 0x400000 + offset）</p>
<blockquote>
<p>PIE 与否是由 ELF 类型（<code>ET_EXEC</code> vs <code>ET_DYN</code>）和代码生成方式决定的，理论上和“静态&#x2F;动态链接”是正交的概念；</p>
<p>但在目前主流 Linux 工具链中，**静态链接的可执行文件通常仍然生成为非 PIE 的 <code>ET_EXEC</code>**，即使指定了 <code>-fPIE -pie</code>，实际也未必会得到真正的静态 PIE。</p>
<p>因此，在分析实际二进制时，应以 <code>readelf -h</code> &#x2F; <code>checksec</code> 检查 ELF 类型和装载基址为准，而不是只看编译命令行参数。</p>
</blockquote>
</li>
<li><p>对 <code>ET_DYN</code>（包括共享库和 PIE）：通常以 0 作为逻辑基址，真实装载时由内核 &#x2F; 动态链接器整体平移，利于地址无关代码。</p>
</li>
</ul>
</li>
<li><p><strong>静态重定位（消耗 <code>.rel.*</code> &#x2F; <code>.rela.*</code>）</strong> ：在 <strong><code>ET_REL</code> 的目标文件</strong> 中，每个要被重定位的节（比如 <code>.text</code> &#x2F; <code>.data</code>）通常有对应的重定位节：</p>
<ul>
<li><p><code>.rel.text</code> &#x2F; <code>.rela.text</code>：代码重定位；</p>
</li>
<li><p><code>.rel.data</code> &#x2F; <code>.rela.data</code>：数据重定位。</p>
</li>
</ul>
<p>其元素是 <code>Elf*_Rel</code> 或 <code>Elf*_Rela</code>，每一项包含：</p>
<ul>
<li><p><code>r_offset</code>：当前目标文件中需要修正的位置；</p>
</li>
<li><p><code>r_info</code>：打包的“符号索引 + 重定位类型”；</p>
</li>
<li><p>（RELA 情况下）<code>r_addend</code>：显式 addend。</p>
</li>
</ul>
</li>
</ul>
<p><strong>链接器做的事：</strong></p>
<ul>
<li><p>根据重定位节头的 <code>sh_info</code> 找到“要被修正的是哪个节”（比如 <code>.text</code>）；</p>
</li>
<li><p>通过 <code>r_offset</code> + 该节在最终 ELF 中的起始地址，算出真正要 patch 的位置；</p>
</li>
<li><p>用 <code>r_info</code> 取出：</p>
<ul>
<li>需要引用的符号（从 <code>.symtab</code> 找到对应 <code>Elf*_Sym</code>）；</li>
<li>重定位类型（如 <code>R_386_32</code> &#x2F; <code>R_386_PC32</code> 等）；</li>
</ul>
</li>
<li><p>从符号表条目的 <code>st_value</code>（结合最终地址分配）得到符号在最终 ELF 中的地址或偏移；</p>
</li>
<li><p>按照重定位类型的规则计算<strong>最终写回值</strong>，patch 到对应位置。</p>
</li>
</ul>
<p>示例（32 位 x86 常见类型）：</p>
<ul>
<li><p><code>R_386_32</code>：绝对地址形式，一般是 <code>S + A</code>；</p>
</li>
<li><p><code>R_386_PC32</code>：PC 相对，一般是 <code>S + A - P</code>；</p>
<ul>
<li>其中 <code>S</code> 是符号地址，<code>A</code> 是 addend，<code>P</code> 是重定位入口地址。</li>
</ul>
</li>
</ul>
<p>完成这一轮后：</p>
<ul>
<li>目标文件里 <code>.rel.text</code> &#x2F; <code>.rel.data</code> 这类“静态重定位节”对最终可执行文件来说已经没用了，</li>
<li>链接器一般会<strong>直接把它们丢掉</strong>，因此在 <code>ET_EXEC</code> &#x2F; <code>ET_DYN</code> 里通常看不到这些节（除非用特殊选项要求保留）。</li>
</ul>
<blockquote>
<p>对于<strong>静态链接程序</strong>（<code>-static</code>）：<br>绝大部分符号引用（包括 libc 等静态库里的函数）在这一步就被“彻底解决”，最终可执行文件里不再依赖外部符号。</p>
</blockquote>
<blockquote>
<p>对于<strong>动态链接程序</strong>（默认模式）：<br>链接器只解决“自己能定死的”部分；<br>对需要在运行时由共享库提供的符号，会保留一部分“动态重定位任务”给动态链接器去做，相关信息会写入 <code>.dynsym</code> &#x2F; <code>.dynstr</code> &#x2F; <code>.rela.dyn</code> &#x2F; <code>.rela.plt</code> 等节中。</p>
</blockquote>
<h4 id="生成运行时元数据"><a href="#生成运行时元数据" class="headerlink" title="生成运行时元数据"></a>生成运行时元数据</h4><p>为了让内核 &#x2F; 动态链接器 &#x2F; 调试器能够正确装载、运行和分析这个 ELF，链接器还需要生成一堆“辅助结构”：</p>
<ul>
<li><p><strong>程序头表（Program Header Table）</strong></p>
<ul>
<li>若干 <code>Elf*_Phdr</code> 条目，如 <code>PT_LOAD</code>、<code>PT_DYNAMIC</code>、<code>PT_INTERP</code> 等；</li>
<li>告诉内核：文件中哪些区间要映射到内存哪里、权限是什么（R&#x2F;W&#x2F;X）。</li>
</ul>
</li>
<li><p><strong><code>.interp</code> &#x2F; <code>PT_INTERP</code>（仅动态链接程序）</strong></p>
<ul>
<li>里面是动态链接器路径，例如 <code>/lib64/ld-linux-x86-64.so.2</code>；</li>
<li>让内核知道“启动这个程序前要先加载哪个解释器（动态链接器）”。</li>
</ul>
</li>
<li><p><strong>动态节 <code>.dynamic</code> &#x2F; <code>PT_DYNAMIC</code>（动态链接相关）</strong></p>
<ul>
<li><p>以 <code>Elf*_Dyn</code> 数组的形式记录：</p>
<ul>
<li>依赖的共享库（<code>DT_NEEDED</code>）；</li>
<li>动态符号表、字符串表的位置（<code>DT_SYMTAB</code> &#x2F; <code>DT_STRTAB</code>）；</li>
<li>动态重定位表的位置和大小（<code>DT_RELA*</code> &#x2F; <code>DT_REL*</code>）；</li>
<li>初始化 &#x2F; 终止函数（<code>DT_INIT</code> &#x2F; <code>DT_FINI</code> &#x2F; <code>DT_INIT_ARRAY*</code> &#x2F; <code>DT_FINI_ARRAY*</code>）等；</li>
</ul>
</li>
<li><p>这些信息是动态链接器在运行时的“导航图”。</p>
</li>
</ul>
</li>
<li><p><strong>PLT &#x2F; GOT（对动态链接程序）</strong></p>
<ul>
<li><p>为外部函数调用合成 PLT 代码段 <code>.plt</code> &#x2F; <code>.plt.sec</code> 和对应的 GOT 槽位 <code>.got.plt</code>；</p>
</li>
<li><p>在 <code>.rela.plt</code> &#x2F; <code>.rel.plt</code> 中为每个跳转槽位生成一个重定位条目，告诉动态链接器：</p>
<ul>
<li>第一次调用某个函数时应该如何解析符号、写入 GOT、并跳转过去；</li>
<li>或在 FULL RELRO + <code>-z now</code> 时一上来就把这些槽位填满。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="程序执行过程"><a href="#程序执行过程" class="headerlink" title="程序执行过程"></a>程序执行过程</h1><h2 id="装载"><a href="#装载" class="headerlink" title="装载"></a>装载</h2><p>在 Linux 中，<strong>装载（load&#x2F;load in memory）</strong>指的是操作系统内核将一个 ELF 可执行文件从磁盘读取出来，并将其内容映射到进程的虚拟地址空间中，准备好让 CPU 可以从它的入口点开始执行的整个过程。</p>
<p>装载的本质是：<strong>内核清空当前进程的用户空间 → 加载新程序 → 设置入口 → 开始执行。</strong></p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">用户命令 → shell 调用 fork → 子进程调用 execve</span><br><span class="line">           ↓</span><br><span class="line">         内核接管 → ELF 加载 &amp; 动态链接器启动</span><br><span class="line">           ↓</span><br><span class="line">         加载依赖库 → 重定位 → 执行构造函数</span><br><span class="line">           ↓</span><br><span class="line">         main()</span><br></pre></td></tr></table></figure></div>

<h3 id="从-shell-到-execve"><a href="#从-shell-到-execve" class="headerlink" title="从 shell 到 execve"></a>从 shell 到 execve</h3><p>当我们在 shell 中执行一条命令时，实际上发生了以下流程：</p>
<ol>
<li><code>bash</code> 进程调用 <code>fork()</code> 创建一个子进程；</li>
<li>子进程调用 <code>execve()</code> 执行新的 ELF 可执行程序；</li>
<li>父进程继续执行，等待子进程结束。</li>
</ol>
<p>其中 <code>execve()</code> 是 Linux 中非常核心的一个系统调用，简单来说，**<code>execve()</code> 就是“让当前进程去运行另一个程序”。**该函数原型如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>pathname</code>：要执行的程序路径（可以是 ELF 文件、脚本等）</li>
<li><code>argv[]</code>：参数列表（传给 <code>main(int argc, char *argv[])</code>）</li>
<li><code>envp[]</code>：环境变量列表</li>
</ul>
<p>另外 glibc 提供了多个 <code>exec</code> 族 API（如 <code>execl</code>, <code>execvp</code>, <code>execvpe</code> 等）对其封装，最终都调用 <code>execve()</code>。</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>参数形式</th>
<th>是否查 PATH</th>
<th>是否自带 envp</th>
<th>调用示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>execl</code></td>
<td>列表</td>
<td>❌ 否</td>
<td>❌ 否</td>
<td><code>execl(&quot;/bin/ls&quot;, &quot;ls&quot;, NULL);</code></td>
</tr>
<tr>
<td><code>execlp</code></td>
<td>列表</td>
<td>✅ 是</td>
<td>❌ 否</td>
<td><code>execlp(&quot;ls&quot;, &quot;ls&quot;, NULL);</code></td>
</tr>
<tr>
<td><code>execle</code></td>
<td>列表 + envp</td>
<td>❌ 否</td>
<td>✅ 是</td>
<td><code>execle(&quot;/bin/ls&quot;, &quot;ls&quot;, NULL, envp);</code></td>
</tr>
<tr>
<td><code>execv</code></td>
<td>数组 <code>argv[]</code></td>
<td>❌ 否</td>
<td>❌ 否</td>
<td><code>execv(&quot;/bin/ls&quot;, argv);</code></td>
</tr>
<tr>
<td><code>execvp</code></td>
<td>数组 <code>argv[]</code></td>
<td>✅ 是</td>
<td>❌ 否</td>
<td><code>execvp(&quot;ls&quot;, argv);</code></td>
</tr>
<tr>
<td><code>execvpe</code></td>
<td>数组 + envp</td>
<td>✅ 是</td>
<td>✅ 是</td>
<td><code>execvpe(&quot;ls&quot;, argv, envp);</code></td>
</tr>
</tbody></table>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <ul>
<li><p><strong>参数形式</strong>指的是怎么把<strong>参数（<code>argv</code>）</strong>传给要执行的程序。</p>
<ul>
<li><p><strong>列表形式</strong>指的是<strong>一个一个地写参数</strong>（就是函数的变长参数）。例如 <code>execl</code>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execl(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="string">&quot;/tmp&quot;</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></div>

<p>这种形式里，函数的参数是分开的，最终内部会构造出一个 <code>argv[]</code> 数组：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *argv[] = &#123;<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="string">&quot;/tmp&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>数组形式</strong>指的是需要自己先准备好一个 <code>argv[]</code> 数组，把它直接传进去：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *argv[] = &#123;<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="string">&quot;/tmp&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">execv(<span class="string">&quot;/bin/ls&quot;</span>, argv);</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><p><strong>是否查 <code>PATH</code></strong> 指的是系统<strong>要不要自动去 <code>$PATH</code> 环境变量指定的目录中查找可执行文件的位置</strong>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">execlp(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="literal">NULL</span>);  <span class="comment">// ✅ 查 PATH，会找到 /bin/ls 或 /usr/bin/ls</span></span><br><span class="line"></span><br><span class="line">execl(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="literal">NULL</span>);  <span class="comment">// ❌ 不查 PATH，需要你手动给出完整路径</span></span><br></pre></td></tr></table></figure></div>

<p>在 Linux 中，环境变量 <code>PATH</code> 是一串目录组成的列表，比如：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line"><span class="comment"># /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span></span><br></pre></td></tr></table></figure></div>

<p>当你调用 <code>execvp(&quot;ls&quot;, argv)</code> 时，它会依次在这些目录中查找有没有可执行文件叫 <code>&quot;ls&quot;</code>，直到找到为止。</p>
<ul>
<li>如果找到了，比如 <code>/bin/ls</code>，就用它去执行；</li>
<li>如果没找到，就报错 <code>ENOENT</code>。</li>
</ul>
</li>
<li><p><strong>是否自带 <code>envp</code></strong> 这个函数是否支持你<strong>传入自定义 <code>envp</code><strong>（不然只能用默认的）。<code>envp</code> 是</strong>环境变量数组</strong>，是一个 <code>char *envp[]</code> 类型，例如：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *envp[] = &#123;<span class="string">&quot;PATH=/bin:/usr/bin&quot;</span>, <span class="string">&quot;USER=sky123&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>如果函数 <strong>没有 <code>envp</code> 参数</strong>，那就只能<strong>自动使用当前进程的环境变量</strong>（通过全局变量 <code>environ</code> 获取）；</li>
<li>如果函数 <strong>有 <code>envp</code> 参数</strong>（比如 <code>execle</code>, <code>execvpe</code>），你可以<strong>自己传一组新的环境变量数组</strong>，用于改变目标程序执行时的环境。</li>
</ul>
</li>
</ul>

    </div>
  </div>

<p>下面是一个简易的 bash 程序实现：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_COMMAND 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> command[MAX_COMMAND];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;minibash$ &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!fgets(command, <span class="keyword">sizeof</span>(command), <span class="built_in">stdin</span>)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去掉换行符</span></span><br><span class="line">        command[<span class="built_in">strcspn</span>(command, <span class="string">&quot;\n&quot;</span>)] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输入为空或为 &quot;exit&quot; 时跳过或退出</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(command, <span class="string">&quot;exit&quot;</span>) == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(command) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 子进程：使用 PATH 查找并执行命令</span></span><br><span class="line">            execlp(command, command, <span class="literal">NULL</span>);</span><br><span class="line">            perror(<span class="string">&quot;exec failed&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 父进程等待子进程结束</span></span><br><span class="line">            <span class="type">int</span> status;</span><br><span class="line">            waitpid(pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="execve-的内核的实现"><a href="#execve-的内核的实现" class="headerlink" title="execve 的内核的实现"></a>execve 的内核的实现</h3><p><code>execve()</code> 是 Linux 中最核心的“程序执行”系统调用。它会将当前进程的用户态空间<strong>完全清空</strong>，然后<strong>加载新的 ELF 程序及其依赖库</strong>，并最终<strong>跳转到新程序入口点执行</strong>。</p>
<p><code>execve</code> 整体的系统调用流程如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">glibc                     <span class="comment">// 用户态 C 库；调用 exec 系列 API</span></span><br><span class="line">  → 触发 syscall          <span class="comment">// 通过 SYS_execve 软中断/系统调用指令</span></span><br><span class="line">      → sys_execve()      <span class="comment">// arch-specific 汇编桩 → C 包装；进入内核</span></span><br><span class="line">          → do_execveat_common()</span><br><span class="line">                            <span class="comment">// 通用入口；解析 flags / fd / filename</span></span><br><span class="line">              → __do_execve_file()</span><br><span class="line">                  ├─ prepare_binprm()   <span class="comment">// 读取前 128 B 判魔数，填充 linux_binprm</span></span><br><span class="line">                  └─ exec_binprm()      <span class="comment">// 真正执行加载流程</span></span><br><span class="line">                       └─ search_binary_handler()   <span class="comment">// 依次尝试已注册 binfmt</span></span><br><span class="line">                            ├─ binfmt_script        <span class="comment">// 处理 `#!` 脚本</span></span><br><span class="line">                            ├─ binfmt_misc          <span class="comment">// 用户自定义格式（/proc/sys/fs/binfmt_misc）</span></span><br><span class="line">                            └─ binfmt_elf           <span class="comment">// 命中 ELF 时调用 ↓</span></span><br><span class="line">                                  ↳ load_elf_binary() <span class="comment">// 映射段、构造栈、设入口</span></span><br></pre></td></tr></table></figure></div>

<p>简单来说 <code>execve</code> 的执行逻辑就是就是<strong>判断可执行文件的魔数然后调用对应的回调函数加载执行可执行文件。</strong></p>
<blockquote>
<p><strong>魔数（Magic Number）</strong> 指文件头部的一段固定字节序列，用来快速标识文件类型或版本。它是“文件格式的身份证”，让操作系统或应用程序无需解析整个文件即可知道该用哪种解析&#x2F;加载器处理。</p>
<p>例如在类 UNIX 操作系统中，文件头以 <code>#!</code>（称为 Shebang）开头，是专门用于标识“这是一个脚本文件”及其对应解释器路径的魔数格式。</p>
<p>而对于 ELF 格式的可执行文件，其魔数是：<code>\x7FELF</code>。</p>
</blockquote>
<p>对于可执行文件，在 <code>fs/binfmt_elf.c</code> 中定义了加载执行该类型文件的回调函数 <code>load_elf_binary</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> <span class="title">elf_format</span> =</span> &#123;</span><br><span class="line">    .module     = THIS_MODULE,</span><br><span class="line">    .load_binary   = load_elf_binary,</span><br><span class="line">    .load_shlib    = load_elf_library,</span><br><span class="line">    .core_dump     = elf_core_dump,</span><br><span class="line">    .min_coredump  = ELF_EXEC_PAGESIZE,</span><br><span class="line">    .hasvdso       = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">init_elf_binfmt</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    register_binfmt(&amp;elf_format);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>load_elf_binary()</code> 是 <strong>Linux 内核真正把 ELF 映像搬进新进程地址空间并把 CPU 跳到入口地址的函数</strong>，该函数的主要逻辑为：</p>
<ol>
<li><p><strong>验证 ELF 头</strong></p>
<ul>
<li>检查魔数 <code>\x7FELF</code>、位宽、字节序、<code>e_type</code> (<code>ET_EXEC/ET_DYN</code>)。</li>
<li>读取并验证 <em>Program‑Header Table</em> 数量与大小。</li>
</ul>
</li>
<li><p><strong>查找 <code>.interp</code> 段（如有）</strong></p>
<ul>
<li>若存在 <code>PT_INTERP</code>，读出动态链接器路径 <code>/lib*/ld-linux*.so.*</code>。</li>
<li>打开链接器文件，为后续映射做准备。</li>
</ul>
<p>有 <code>PT_INTERP</code> 的 ELF，其真正的“解释器”就是这个 <code>ld-linux*.so.*</code>；跟 <code>#!/usr/bin/python3</code> 的脚本会交给 python 解释器，有点类似。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./a.out arg1 arg2</span><br></pre></td></tr></table></figure></div>
<p>内核等价于偷偷做了：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/lib64/ld-linux-x86-64.so.2 ./a.out arg1 arg2</span><br></pre></td></tr></table></figure></div>
<p>你也可以自己手动这么干，比如：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 看看当前程序的解释器是谁</span></span><br><span class="line">readelf -l ./a.out | grep <span class="string">&#x27;interpreter&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动调用动态链接器来跑它</span></span><br><span class="line">/lib64/ld-linux-x86-64.so.2 ./a.out arg1 arg2</span><br></pre></td></tr></table></figure></div>
<p>前提是：</p>
<ul>
<li>这个 ELF 是<strong>动态链接的</strong>（有 <code>PT_INTERP</code>）；</li>
<li>你用的路径要跟 <code>.interp</code> 里的一致或兼容。</li>
</ul>
<p>对于<strong>静态链接程序</strong>（没 <code>PT_INTERP</code>），就不会走动态链接器了，内核直接把它当普通 <code>ET_EXEC</code> 装载执行，用 <code>ld-linux.so</code> 去跑就没意义。</p>
</li>
<li><p><strong>加载 Program‑Header <code>PT_LOAD</code> 段</strong></p>
<ul>
<li>逐段 <code>mmap</code> <code>.text</code> &#x2F; <code>.rodata</code> &#x2F; <code>.data</code> &#x2F; <code>.bss</code> 等到进程地址空间；</li>
<li>计算 <code>load_bias</code>（PIE 随机基址）并更新 <code>start_code/end_code</code> 等 mm 统计字段；</li>
<li>为 <code>.bss</code>&#x2F;heap 调用 <code>set_brk()</code> 分配零页。</li>
</ul>
</li>
<li><p><strong>设置栈与辅助向量</strong> (<code>setup_arg_pages()</code> → <code>create_elf_tables()</code>)</p>
<ul>
<li>把 <code>argv[]</code>、<code>envp[]</code>、<code>auxv[]</code> 拷到新栈；</li>
<li>在 auxv 填入 <code>AT_PHDR</code>, <code>AT_ENTRY</code>, <code>AT_BASE</code>, <code>AT_RANDOM</code> 等，供链接器&#x2F;程序读取。</li>
</ul>
</li>
<li><p><strong>加载并映射动态链接器</strong>（若存在）</p>
<ul>
<li><code>load_elf_interp()</code> 把 <code>ld.so</code> 自身映射进地址空间；</li>
<li>记录其加载基址，用作 <code>AT_BASE</code> 及后续重定位。</li>
</ul>
</li>
<li><p><strong>切换到新进程映像</strong></p>
<ul>
<li><code>flush_old_exec()</code> → 清掉旧 <em>mm</em>；</li>
<li><code>install_exec_creds()</code> → 安装新 UID&#x2F;GID&#x2F;LSM 凭据；</li>
<li>随机化栈 &#x2F; brk（若启用 ASLR）。</li>
</ul>
</li>
<li><p><strong>确定入口地址并启动线程</strong></p>
<ul>
<li><strong>静态 ELF</strong>：入口 &#x3D; <code>e_entry + load_bias</code>；</li>
<li>**动态 ELF (PIE)**：入口 &#x3D; 链接器入口；链接器完成重定位后再跳到主程序 <code>_start</code>；</li>
<li><code>start_thread(regs, elf_entry, stack_top)</code> 把 <code>rip/eip</code> 指向入口并返回用户态。</li>
</ul>
</li>
</ol>
<p>一旦 <code>start_thread()</code> 返回到用户空间，CPU 已在 <strong>新程序入口</strong> 指令处运行；自此，旧进程代码与所有旧 <code>.so</code> 全部被替换。</p>
<h3 id="进程虚拟地址空间"><a href="#进程虚拟地址空间" class="headerlink" title="进程虚拟地址空间"></a>进程虚拟地址空间</h3><p>在现代操作系统中，每个进程都运行在自己的<strong>虚拟地址空间（Virtual Address Space）</strong>中。所谓<strong>虚拟地址空间</strong>，是操作系统提供给进程的一种抽象地址空间：</p>
<ul>
<li><strong>每个进程拥有独立的地址空间</strong>，互相隔离。</li>
<li>虚拟地址空间由<strong>连续的虚拟地址</strong>构成，而不是物理地址。</li>
<li>操作系统通过<strong>内存管理单元（MMU）</strong>将虚拟地址翻译为实际的物理地址。</li>
</ul>
<p>虚拟地址空间让进程以为自己独占内存空间，简化了程序设计，并提高了系统的安全性和稳定性。</p>
<p>通常来说，一个进程（关闭 PIE 且动态链接）的进程空间布局如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">0x0000_0000_0000 ── NULL page               (不可访问，解引用触发 SIGSEGV)</span><br><span class="line">                  ↓</span><br><span class="line">0x0000_0040_0000 ── ELF 主映像加载基址（PIE 随机或固定 0x400000）</span><br><span class="line">   │  .text         R‑X  │ 机器指令</span><br><span class="line">   │  .rodata        R-- │ 只读常量</span><br><span class="line">   │  .data          RW- │ 已初始化全局/静态变量</span><br><span class="line">   │  .bss           RW- │ 未初始化全局/静态变量，加载时清零</span><br><span class="line">   │  .got           RW- │ Global Offset Table（重定位指针）</span><br><span class="line">   │  .plt           R‑X │ Procedure Linkage Table（延迟绑定跳板）</span><br><span class="line">   │  .init_array    RW- │ 构造函数指针表</span><br><span class="line">   │  .fini_array    RW- │ 析构函数指针表</span><br><span class="line">                  ↓</span><br><span class="line">            (可选) 另一些映像段或 RO/RW PT_NOTE 等</span><br><span class="line">                  ↓</span><br><span class="line">---------- ELF 映像结束 ----------</span><br><span class="line">                  ↓</span><br><span class="line">     Heap / brk 区域               RW-  `brk()` 起点紧接 .bss；向 **高地址** 扩张</span><br><span class="line">        └─ 超额分配由 `mmap` 匿名页补充</span><br><span class="line">                  ↓</span><br><span class="line">---------- 匿名 / 文件 mmap 区域 ----------</span><br><span class="line">                  ↓</span><br><span class="line">     共享库（.so）                 R‑X / R-- / RW-</span><br><span class="line">        └─ 动态链接器 `ld‑linux.so` 亦映射于此</span><br><span class="line">     JIT 代码段                    R‑X（随后可能转 RW‑X）</span><br><span class="line">     映射文件页 / 内存映射缓存       按 `mmap()` 权限</span><br><span class="line">     匿名大页 / 线程栈             依需要分配</span><br><span class="line">                  ↓</span><br><span class="line">     vDSO / vvar                  R--  内核提供的用户态系统调用&amp;时钟数据页</span><br><span class="line">                  ↓</span><br><span class="line">---------- guard page（不可访问） ----------</span><br><span class="line">0x7fff_xxxx0000 ── **stack 顶**            RW-</span><br><span class="line">                  ↑ 向 **低地址** 增长</span><br><span class="line">0x7fff_ffff_ffff ── 用户空间最高地址（TASK_SIZE - 1）</span><br></pre></td></tr></table></figure></div>

<p>其中常见的段含义如下：</p>
<table>
<thead>
<tr>
<th>区域 &#x2F; 段</th>
<th>典型权限</th>
<th>详细说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>.text</code></strong></td>
<td><code>R‑X</code></td>
<td>- 代码段（text segment），包含可执行的 <strong>机器指令</strong>。- 在可执行文件中，此段往往是只读 + 可执行，避免被恶意篡改。- 如果启用了 NX（No-eXecute）保护，除了此段外，其他内存区域将被禁止执行（W^X 策略）。</td>
</tr>
<tr>
<td><strong><code>.rodata</code></strong></td>
<td><code>R--</code></td>
<td>- Read-Only Data 段。- 存放 <strong>字符串常量</strong>、<strong>const 修饰的全局变量</strong>、C++ 的 <strong>虚表（vtable）</strong> 等。- 映射为只读，防止运行期间被意外或恶意修改。</td>
</tr>
<tr>
<td><strong><code>.data</code></strong></td>
<td><code>RW-</code></td>
<td>- 已初始化的全局变量、静态变量（<code>.data</code>段）。- 例如：<code>int x = 42;</code> 会被存入此区域。</td>
</tr>
<tr>
<td><strong><code>.bss</code></strong></td>
<td><code>RW-</code></td>
<td>- Block Started by Symbol（BSS 段），用于<strong>未初始化的全局 &#x2F; 静态变量</strong>。- 比如：<code>int y;</code> 会占据此段空间。- 在加载时由内核自动用 <code>0</code> 填充，不会占用磁盘文件空间（仅占内存页）。</td>
</tr>
<tr>
<td><strong><code>.got / .plt</code></strong></td>
<td><code>.got</code>: <code>RW-``.plt</code>: <code>R‑X</code></td>
<td>- <strong>GOT（Global Offset Table）</strong> 保存运行时解析出的函数 &#x2F; 全局变量地址。- <strong>PLT（Procedure Linkage Table）</strong> 是延迟绑定跳板，调用函数时会跳到 <code>.plt</code> 中间接跳转到实际地址。- 两者配合实现 <code>dlopen()</code> 和延迟绑定机制。</td>
</tr>
<tr>
<td><strong><code>.dynamic</code></strong></td>
<td><code>R--</code></td>
<td>- 存放动态链接信息，如：符号表、重定位表偏移、需要的共享库名等。- 程序启动时由动态链接器（如 <code>ld-linux.so</code>）读取并处理。</td>
</tr>
<tr>
<td><strong><code>.init_array / .fini_array</code></strong></td>
<td><code>RW-</code></td>
<td>- 分别用于 C&#x2F;C++ 程序的<strong>构造函数</strong>（初始化）和<strong>析构函数</strong>（结束）列表。- 编译器将 <code>__attribute__((constructor))</code> 或全局对象构造函数地址放入 <code>.init_array</code>，在启动时自动调用。</td>
</tr>
<tr>
<td><strong>Heap（堆）</strong></td>
<td><code>RW-</code></td>
<td>- 程序通过 <code>malloc()</code> &#x2F; <code>new</code> 等动态分配的内存区域。- 初始堆由 <code>brk()</code> 创建，超出部分通过 <code>mmap()</code> 生成匿名页。- 向高地址扩展。</td>
</tr>
<tr>
<td><strong>Stack（栈）</strong></td>
<td><code>RW-</code></td>
<td>- 包含函数调用栈帧、局部变量、返回地址等信息。- 默认 8MB 左右空间，可通过 <code>ulimit -s</code> 设置。- <code>argv[]</code>, <code>envp[]</code>, <code>auxv[]</code> 也在进程启动时由内核构造在此处。- 向低地址扩展；底部设置 guard page（不可访问）防溢出。</td>
</tr>
<tr>
<td><strong>vDSO &#x2F; vvar</strong></td>
<td><code>R--</code></td>
<td>- vDSO（Virtual Dynamic Shared Object）是<strong>内核映射到用户空间的共享库</strong>，提供 <code>gettimeofday()</code> 等系统调用的用户态实现，加快访问速度（免陷入内核）。- vvar 是 vDSO 访问的变量页，如时钟源信息。- <code>cat /proc/self/maps</code> 可见它们在栈附近。</td>
</tr>
<tr>
<td><strong>mmap() 区域</strong></td>
<td><code>R--/RW-/RWX</code> 等</td>
<td>- 使用 <code>mmap()</code> 映射的所有区域：包括<strong>动态链接库（.so 文件）</strong>、<strong>匿名页</strong>、<strong>文件映射</strong>、<strong>JIT 编译代码区</strong>等。- 运行时由内核动态分配，段数量不定；常见于 JavaScript 引擎、Python、动态模块等。</td>
</tr>
</tbody></table>
<h3 id="进程栈的初始化"><a href="#进程栈的初始化" class="headerlink" title="进程栈的初始化"></a>进程栈的初始化</h3><p>当我们执行：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /home</span><br></pre></td></tr></table></figure></div>

<p><code>bash</code> 最终会调用：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execve(<span class="string">&quot;ls&quot;</span>, argv, envp);</span><br></pre></td></tr></table></figure></div>

<p>从这一刻开始，<strong>内核</strong>接管控制权，大致流程（对 ELF 程序）是：</p>
<ol>
<li><p><code>do_execveat_common()</code> 解析参数，识别这是 ELF。</p>
</li>
<li><p>调用 <code>load_elf_binary()</code>（<code>fs/binfmt_elf.c</code>）：</p>
<ul>
<li>释放旧地址空间，创建新的 <code>mm_struct</code>；</li>
<li>映射 ELF 的 <code>PT_LOAD</code> 段（代码段、数据段等）；</li>
<li>调用 <code>setup_arg_pages()</code> 创建用户栈 VMA（这里会处理 <strong>ASLR + 栈&#x2F;映射区间隔</strong>）；</li>
<li>调用 <code>create_elf_tables()</code> 把 <code>argc/argv/envp/auxv</code> 布置到栈上；</li>
<li>设置寄存器：指令指针（IP）&#x3D; 入口地址、栈指针（SP）&#x3D; 刚搭好的栈顶。</li>
</ul>
</li>
<li><p>从内核返回用户态，从入口地址开始执行（静态程序直接是你的 <code>_start</code>，动态程序是 <code>ld-linux.so</code> 的 <code>_start</code>）。</p>
</li>
</ol>
<p>在 <code>load_elf_binary()</code> 中，内核先选一个靠近 <code>STACK_TOP</code> 的位置作栈顶：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> stack_top = STACK_TOP;</span><br><span class="line">stack_top = randomize_stack_top(stack_top);</span><br><span class="line">setup_arg_pages(bprm, stack_top, executable_stack);</span><br></pre></td></tr></table></figure></div>

<p><code>randomize_stack_top()</code> 会在 <code>STACK_TOP</code> 附近向下随机偏移一段（典型范围是 ~8MB）：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> STACK_RND_MASK</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_RND_MASK (0x7ff &gt;&gt; (PAGE_SHIFT - 12)) <span class="comment">/* 8MB of VA */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">randomize_stack_top</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> stack_top)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> random_variable = get_random_int() &amp; STACK_RND_MASK;</span><br><span class="line">    random_variable &lt;&lt;= PAGE_SHIFT;</span><br><span class="line">    <span class="keyword">return</span> PAGE_ALIGN(stack_top) - random_variable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>生成一个随机数 <code>random_variable = get_random_int() &amp; STACK_RND_MASK</code>；</p>
</li>
<li><p><code>random_variable &lt;&lt;= PAGE_SHIFT</code>（按页对齐）；</p>
</li>
<li><p>对向下生长的栈，返回：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack_top = PAGE_ALIGN(STACK_TOP) - random_variable;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>这一步在 <strong>8MB 左右的范围内</strong>随机（<code>STACK_RND_MASK</code> 决定上限）。</p>
</li>
</ul>
<p>接着，在 <code>create_elf_tables()</code> 里还会调用 <code>arch_align_stack()</code> 做一次细粒度随机 + 16 字节对齐：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">arch_align_stack</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> sp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(current-&gt;personality &amp; ADDR_NO_RANDOMIZE) &amp;&amp; randomize_va_space)</span><br><span class="line">        sp -= get_random_int() % <span class="number">8192</span>;  <span class="comment">// 随机减去 0..8191</span></span><br><span class="line">    <span class="keyword">return</span> sp &amp; ~<span class="number">0xf</span>;                   <span class="comment">// 再向下 16 字节对齐</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp = arch_align_stack(sp);</span><br><span class="line"><span class="comment">/* x86 上大致是：减去 (0..8191) 字节的随机偏移，再对齐到 16 字节 */</span></span><br></pre></td></tr></table></figure></div>

<p>这两步叠加效果：</p>
<ul>
<li>每次 <code>execve()</code>，<strong>初始栈地址都不一样（ASLR）</strong>；</li>
<li>最终 <code>%rsp</code> 会被对齐到 16 字节，满足 System V ABI 要求，所以你总能看到栈地址低 4 bit 为 0，但高几位总在变。</li>
</ul>
<p>只做 ASLR 还不够。历史上 Linux 只有“一页 guard page”，结果出现了著名的 <strong>Stack Clash</strong>：用户栈可以一次性递归&#x2F;alloc 大量空间，一口气“跳过”那一页，直接撞上 mmap 区，引起堆栈重叠，从而打穿沙箱。</p>
<p>为此，内核引入了一个全局参数 **<code>stack_guard_gap</code>**，表示栈和其它映射之间要预留多少页不映射（guard 区）：</p>
<p>官方文档（<code>Documentation/admin-guide/kernel-parameters.txt</code>）说明：</p>
<blockquote>
<p><code>stack_guard_gap=</code>：距离主栈前（栈向下增长时）或后（栈向上增长时）预留多少页不用于映射，默认是 <strong>256 页</strong>。</p>
</blockquote>
<p>在通用 mm 代码里，有两个辅助函数专门考虑这个 gap：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">vm_start_gap</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_start = vma-&gt;vm_start;</span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_flags &amp; VM_GROWSDOWN) &#123;</span><br><span class="line">        vm_start -= stack_guard_gap;</span><br><span class="line">        <span class="keyword">if</span> (vm_start &gt; vma-&gt;vm_start)</span><br><span class="line">            vm_start = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vm_start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">vm_end_gap</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_end = vma-&gt;vm_end;</span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_flags &amp; VM_GROWSUP) &#123;</span><br><span class="line">        vm_end += stack_guard_gap;</span><br><span class="line">        <span class="keyword">if</span> (vm_end &lt; vma-&gt;vm_end)</span><br><span class="line">            vm_end = -PAGE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vm_end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这些函数被 mmap 布局代码用来保证：<strong>在栈 VMA 周围预留一段 <code>stack_guard_gap</code> 大小的空洞，别的 VMA 不会贴得太近。</strong></p>
<p>再看 top‑down mmap 布局（很多 64 位平台使用），<code>mmap_base()</code> 里会参考当前 <code>RLIMIT_STACK</code> 和 <code>stack_guard_gap</code> 计算 <strong>stack 与 mmap 之间的“安全间隔 gap”</strong>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">mmap_base</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> rnd, <span class="keyword">struct</span> rlimit *rlim_stack)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> gap = rlim_stack-&gt;rlim_cur;  <span class="comment">// 用户栈允许的最大大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> pad = stack_guard_gap;       <span class="comment">// 保护 gap</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若启用 ASLR，还把栈随机化范围也算到 gap 里 */</span></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;flags &amp; PF_RANDOMIZE)</span><br><span class="line">        pad += (STACK_RND_MASK &lt;&lt; PAGE_SHIFT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (gap + pad &gt; gap)</span><br><span class="line">        gap += pad;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (gap &lt; MIN_GAP)</span><br><span class="line">        gap = MIN_GAP;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (gap &gt; MAX_GAP)</span><br><span class="line">        gap = MAX_GAP;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TASK_SIZE - gap - rnd;  <span class="comment">// mmap_base 在 gap 下方</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>关键点：</p>
<ul>
<li><p><strong>gap 至少包含：</strong></p>
<ul>
<li>栈允许的最大大小（<code>RLIMIT_STACK</code>）；</li>
<li><code>stack_guard_gap</code>（例如缺省 256 页 ≈ 1MB 左右）；</li>
<li>外加考虑栈随机化的那一段。</li>
</ul>
</li>
<li><p>gap 被夹在 <code>[MIN_GAP, MAX_GAP]</code> 之间，防止搞得太大或太小。</p>
</li>
<li><p>mmap 顶端（<code>mmap_base</code>）会在 <code>TASK_SIZE - gap</code> 之下，留出这个 gap 给栈增长和 guard 使用。</p>
</li>
</ul>
<p>直观理解：</p>
<blockquote>
<p><strong>内核在用户栈和 mmap 区之间留出了一块至少 <code>stack_guard_gap</code> + 随机偏移 + RLIMIT_STACK 的 “空洞”，</strong></p>
<p><strong>栈要想撞上 mmap，必须先填满自己允许的栈大小，还得跨过 guard 空洞，Stack Clash 难度就被拉高很多。</strong></p>
</blockquote>
<p>栈空间搞定之后，<code>create_elf_tables()</code> 会在栈顶附近按 ELF 规范布置进程参数和“辅助信息”。</p>
<p>在程序初始状态的栈如下图所示：</p>
<pre><font color="#26A269"><b>pwndbg&gt; </b></font>stack 40
00:0000│ <b>rsp    </b> <font color="#A2734C">0x7fffffffdf28</font> —▸ <font color="#C01C28">0x7ffff7c29d90 (__libc_start_call_main+128)</font> ◂— <font color="#AFD700">mov</font><font color="#000000"> </font><font color="#5FD7FF">edi</font><font color="#000000">, </font><font color="#5FD7FF">eax</font>
01:0008│ <b>       </b> <font color="#A2734C">0x7fffffffdf30</font> —▸ <font color="#A2734C">0x7fffffffe038</font> —▸ <font color="#A2734C">0x7fffffffe3ba</font> ◂— &apos;/usr/bin/ls&apos;
02:0010│ <b>       </b> <font color="#A2734C">0x7fffffffdf38</font> —▸ <font color="#C01C28">0x555555558d10</font> ◂— <font color="#AFD700">endbr64</font><font color="#000000"> </font>
03:0018│ <b>       </b> <font color="#A2734C">0x7fffffffdf40</font> ◂— 0x2f7fa5910
04:0020│ <b>       </b> <font color="#A2734C">0x7fffffffdf48</font> —▸ <font color="#A2734C">0x7fffffffe038</font> —▸ <font color="#A2734C">0x7fffffffe3ba</font> ◂— &apos;/usr/bin/ls&apos;
05:0028│ <b>       </b> <font color="#A2734C">0x7fffffffdf50</font> ◂— 0
06:0030│ <b>       </b> <font color="#A2734C">0x7fffffffdf58</font> ◂— 0xea1debf161b77c7f
07:0038│ <b>       </b> <font color="#A2734C">0x7fffffffdf60</font> —▸ <font color="#A2734C">0x7fffffffe038</font> —▸ <font color="#A2734C">0x7fffffffe3ba</font> ◂— &apos;/usr/bin/ls&apos;
08:0040│ <b>       </b> <font color="#A2734C">0x7fffffffdf68</font> —▸ <font color="#C01C28">0x555555558d10</font> ◂— <font color="#AFD700">endbr64</font><font color="#000000"> </font>
09:0048│ <b>       </b> <font color="#A2734C">0x7fffffffdf70</font> —▸ 0x555555574fd8 —▸ <font color="#C01C28">0x55555555ab40</font> ◂— <font color="#AFD700">endbr64</font><font color="#000000"> </font>
0a:0050│ <b>       </b> <font color="#A2734C">0x7fffffffdf78</font> —▸ <font color="#A347BA">0x7ffff7ffd040 (_rtld_global)</font> —▸ <font color="#A347BA">0x7ffff7ffe2e0</font> —▸ 0x555555554000 ◂— 0x10102464c457f
0b:0058│ <b>       </b> <font color="#A2734C">0x7fffffffdf80</font> ◂— 0x15e2140edfd37c7f
0c:0060│ <b>       </b> <font color="#A2734C">0x7fffffffdf88</font> ◂— 0x15e204745b3b7c7f
0d:0068│ <b>       </b> <font color="#A2734C">0x7fffffffdf90</font> ◂— 0x7fff00000000
0e:0070│ <b>       </b> <font color="#A2734C">0x7fffffffdf98</font> ◂— 0
... ↓            3 skipped
12:0090│ <b>       </b> <font color="#A2734C">0x7fffffffdfb8</font> ◂— 0xea3da6237c5e9c00
13:0098│ <b>       </b> <font color="#A2734C">0x7fffffffdfc0</font> ◂— 0
14:00a0│ <b>       </b> <font color="#A2734C">0x7fffffffdfc8</font> —▸ <font color="#C01C28">0x7ffff7c29e40 (__libc_start_main+128)</font> ◂— <font color="#AFD700">mov</font><font color="#000000"> </font><font color="#5FD7FF">r15</font><font color="#000000">, </font><font color="#5FD7FF">qword</font><font color="#000000"> </font><font color="#5FD7FF">ptr</font><font color="#000000"> [</font><font color="#5FD7FF">rip</font><font color="#000000"> + </font><font color="#AF87FF">0x1f0159</font><font color="#000000">]</font>
15:00a8│ <b>       </b> <font color="#A2734C">0x7fffffffdfd0</font> —▸ <font color="#A2734C">0x7fffffffe050</font> —▸ <font color="#A2734C">0x7fffffffe3cc</font> ◂— &apos;SYSTEMD_EXEC_PID=1484&apos;
16:00b0│ <b>       </b> <font color="#A2734C">0x7fffffffdfd8</font> —▸ 0x555555574fd8 —▸ <font color="#C01C28">0x55555555ab40</font> ◂— <font color="#AFD700">endbr64</font><font color="#000000"> </font>
17:00b8│ <b>       </b> <font color="#A2734C">0x7fffffffdfe0</font> —▸ <font color="#A347BA">0x7ffff7ffe2e0</font> —▸ 0x555555554000 ◂— 0x10102464c457f
18:00c0│ <b>       </b> <font color="#A2734C">0x7fffffffdfe8</font> ◂— 0
19:00c8│ <b>       </b> <font color="#A2734C">0x7fffffffdff0</font> ◂— 0
1a:00d0│ <b>       </b> <font color="#A2734C">0x7fffffffdff8</font> —▸ <font color="#C01C28">0x55555555aaa0</font> ◂— <font color="#AFD700">endbr64</font><font color="#000000"> </font>
1b:00d8│ <b>       </b> <font color="#A2734C">0x7fffffffe000</font> —▸ <font color="#A2734C">0x7fffffffe030</font> ◂— 2
1c:00e0│ <b>       </b> <font color="#A2734C">0x7fffffffe008</font> ◂— 0
1d:00e8│ <b>       </b> <font color="#A2734C">0x7fffffffe010</font> ◂— 0
1e:00f0│ <b>       </b> <font color="#A2734C">0x7fffffffe018</font> —▸ <font color="#C01C28">0x55555555aac5</font> ◂— <font color="#AFD700">hlt</font><font color="#000000"> </font>
1f:00f8│ <b>       </b> <font color="#A2734C">0x7fffffffe020</font> —▸ <font color="#A2734C">0x7fffffffe028</font> ◂— 0x1c
20:0100│ <b>       </b> <font color="#A2734C">0x7fffffffe028</font> ◂— 0x1c
21:0108│ <b>       </b> <font color="#A2734C">0x7fffffffe030</font> ◂— 2
22:0110│ <b>rsi r12</b> <font color="#A2734C">0x7fffffffe038</font> —▸ <font color="#A2734C">0x7fffffffe3ba</font> ◂— &apos;/usr/bin/ls&apos;
23:0118│ <b>       </b> <font color="#A2734C">0x7fffffffe040</font> —▸ <font color="#A2734C">0x7fffffffe3c6</font> ◂— 0x595300656d6f682f /* &apos;/home&apos; */
24:0120│ <b>       </b> <font color="#A2734C">0x7fffffffe048</font> ◂— 0
25:0128│ <b>rdx    </b> <font color="#A2734C">0x7fffffffe050</font> —▸ <font color="#A2734C">0x7fffffffe3cc</font> ◂— &apos;SYSTEMD_EXEC_PID=1484&apos;
26:0130│ <b>       </b> <font color="#A2734C">0x7fffffffe058</font> —▸ <font color="#A2734C">0x7fffffffe3e2</font> ◂— &apos;SSH_AUTH_SOCK=/run/user/1000/keyring/ssh&apos;
27:0138│ <b>       </b> <font color="#A2734C">0x7fffffffe060</font> —▸ <font color="#A2734C">0x7fffffffe40b</font> ◂— &apos;SESSION_MANAGER=local/ubuntu:@/tmp/.ICE-unix/1452,unix/ubuntu:/tmp/.ICE-unix/1452&apos;
<font color="#26A269"><b>pwndbg&gt; </b></font>telescope &amp;environ 1
00:0000│  <font color="#A347BA">0x7ffff7ffe2d0 (environ)</font> —▸ <font color="#A2734C">0x7fffffffe050</font> —▸ <font color="#A2734C">0x7fffffffe3cc</font> ◂— &apos;SYSTEMD_EXEC_PID=1484&apos;
<font color="#26A269"><b>pwndbg&gt; </b></font>vmmap 0x7fffffffe050
LEGEND: <font color="#A2734C">STACK</font> | <font color="#12488B">HEAP</font> | <font color="#C01C28">CODE</font> | <font color="#A347BA">DATA</font> | <font color="#C01C28"><u style="text-decoration-style:single">WX</u></font> | RODATA
             Start                End Perm     Size Offset File (set vmmap-prefer-relpaths on)
<font color="#A347BA">    0x7ffff7ffd000     0x7ffff7fff000 rw-p     2000  39000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2</font>
<font color="#A2734C">►   0x7ffffffde000     0x7ffffffff000 rw-p    21000      0 [stack] +0x20050</font>
</pre>

<p>从<strong>低地址到高地址</strong>的大致布局（低地址 &#x3D; 初始 <code>%rsp</code> 指向的位置）：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/0b14b8f7b214bfb36efc1979d4c50b10.png"
                      alt="在这里插入图片描述" style="zoom: 33%;" 
                >

<p>以 <code>ls /home</code> 为例：</p>
<ul>
<li><p><code>argc = 2</code>（一般为 <code>argv[0] = &quot;/usr/bin/ls&quot;</code>，<code>argv[1] = &quot;/home&quot;</code>）；</p>
</li>
<li><p><code>argv</code> 是一个以 NULL 结尾的指针数组，数组元素指向后面“字符串区”的具体 C 字符串；</p>
</li>
<li><p><code>envp</code> 同理，是以 NULL 结尾的 <code>char *</code> 数组，例如：</p>
<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">envp[0] -&gt; &quot;SYSTEMD_EXEC_PID=1484&quot;</span><br><span class="line">envp[1] -&gt; &quot;SSH_AUTH_SOCK=/run/user/1000/...&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>C 运行时里全局变量 <code>char **environ</code> 一般就直接指向 <code>envp[0]</code>。</p>
<blockquote>
<p><strong>辅助信息数组（Auxiliary Vector）</strong>是内核给用户态“塞的一小包元数据”。内核在进程启动时，会在用户栈上布置一段 <code>(a_type, a_val)</code> 形式的辅助向量 auxv，用来向用户态传递 ELF 布局、硬件特性、随机种子、UID&#x2F;GID 等信息。</p>
<ul>
<li>对 <strong>动态链接程序</strong>，动态链接器（<code>ld-linux.so</code>）会优先读取其中的 <code>AT_PHDR</code>、<code>AT_PHNUM</code>、<code>AT_BASE</code>、<code>AT_ENTRY</code> 等条目，用来完成重定位和把控制权交给真正的程序入口。</li>
<li>对 <strong>静态链接程序</strong>，没有动态链接器参与，但 libc 和应用本身仍然可以通过 <code>getauxval()</code> 或 <code>/proc/self/auxv</code> 读取 auxv（如页大小、硬件能力、随机种子等）。</li>
</ul>
<p>以 32 位为例（64 位只是字段宽度不同），<code>Elf32_auxv_t</code> 的定义如下（节选自 <code>elf.h</code>）：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> a_type;  <span class="comment">/* Entry type */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="type">uint32_t</span> a_val;  <span class="comment">/* Integer value */</span></span><br><span class="line">      <span class="comment">/* We use to have pointer elements added here.  We cannot do that,</span></span><br><span class="line"><span class="comment">   though, since it does not work when using 32-bit definitions</span></span><br><span class="line"><span class="comment">   on 64-bit platforms and vice versa.  */</span></span><br><span class="line">    &#125; a_un;</span><br><span class="line">&#125; Elf32_auxv_t;</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>a_un</code> 是一个联合体，目前实际上只用到其中的 <code>a_val</code> 成员：</p>
<ul>
<li><p>在 32 位结构体里是 <code>uint32_t</code>，在 64 位结构体里是 64 位无符号整型；</p>
</li>
<li><p>从“语义”上看，它可能代表两类东西：</p>
<ul>
<li><strong>普通整数</strong>：比如 <code>AT_PAGESZ</code>、<code>AT_FLAGS</code> 等；</li>
<li><strong>地址值</strong>：比如 <code>AT_PHDR</code>、<code>AT_BASE</code>、<code>AT_ENTRY</code>、<code>AT_RANDOM</code>、<code>AT_EXECFN</code> 等，本质是一个指针，被强行塞进整型里。</li>
</ul>
</li>
</ul>
<p><code>a_type</code> 指示这一条 auxv 的<strong>类型</strong>，决定了 <code>a_val</code> 的含义。常见类型包括：</p>
<ul>
<li><p><code>AT_NULL (0)</code><br>辅助向量列表结束标志。最后一条一定是 <code>(AT_NULL, 0)</code>。</p>
</li>
<li><p><code>AT_IGNORE (1)</code><br>忽略此条目，历史兼容保留，一般不用。</p>
</li>
<li><p><code>AT_EXECFD (2)</code><br>可执行文件的文件描述符（配合 <code>fexecve()</code> 等使用）。多数普通 <code>execve(path, ...)</code> 的程序不会设置。</p>
</li>
<li><p><code>AT_PHDR (3)</code><br><strong>程序头表（Program Header Table）在内存中的地址</strong>。动态链接器用它来遍历 <code>Elf*_Phdr</code>，找到 <code>PT_PHDR</code>、<code>PT_DYNAMIC</code> 等段。</p>
</li>
<li><p><code>AT_PHENT (4)</code><br>程序头表中每个条目的大小（字节数），通常是 <code>sizeof(Elf*_Phdr)</code>。</p>
</li>
<li><p><code>AT_PHNUM (5)</code><br>程序头表中条目的数量，对应 ELF 头里的 <code>e_phnum</code>。</p>
</li>
<li><p><code>AT_PAGESZ (6)</code><br>系统页大小（如 4096）。libc&#x2F;malloc&#x2F;动态链接器会用它做页对齐和内存映射。</p>
</li>
<li><p><code>AT_BASE (7)</code><br><strong>动态链接器自身的装载基址</strong>（比如 <code>/lib64/ld-linux-x86-64.so.2</code> 在进程地址空间中的基地址）。<br>对纯静态程序通常为 0。</p>
</li>
<li><p><code>AT_FLAGS (8)</code><br>各种标志位，含义依具体实现和 ABI，一般调试器&#x2F;动态链接器内部使用。</p>
</li>
<li><p><code>AT_ENTRY (9)</code><br>程序入口点虚拟地址（最终要跳到的地址），和 ELF 头的 <code>e_entry</code> 一致（考虑装载基址后）。</p>
</li>
<li><p><code>AT_NOTELF (10)</code><br>标记“原始执行文件不是标准 ELF”，某些兼容场景用，一般 ELF 程序不会碰到。</p>
</li>
<li><p><code>AT_UID</code> &#x2F; <code>AT_EUID</code> &#x2F; <code>AT_GID</code> &#x2F; <code>AT_EGID</code><br>程序的真实&#x2F;有效 UID、GID，libc、PAM、沙箱等可能会用。</p>
</li>
<li><p><code>AT_SECURE</code><br>非 0 表示当前进程处于“安全执行模式”，例如 setuid 程序。libc 会据此忽略部分不安全的环境变量。</p>
</li>
<li><p><code>AT_RANDOM</code><br>指向栈上一块 16 字节的随机数据。glibc 用它初始化栈 canary、<code>rand()</code> 种子等安全相关内容。</p>
</li>
<li><p><code>AT_EXECFN</code><br>指向启动该程序时使用的路径字符串（通常是 <code>argv[0]</code> 对应的那一块）。</p>
</li>
</ul>
<p><strong>注意：并不是每个进程都会拥有所有这些条目</strong>，内核会根据实际情况填充一部分，剩下的根本不会出现。</p>
<p>这些值的“解释”由 libc &#x2F; 动态链接器负责，你在 glibc 里可以通过 <code>getauxval(AT_XXX)</code> 读到。</p>
</blockquote>
<p>内核把 IP&#x2F;SP 设好后，开始执行用户态入口：</p>
<ul>
<li><strong>静态链接程序</strong>：IP 直接指向你的 <code>_start</code>；</li>
<li><strong>动态链接程序</strong>：IP 指向 <code>ld-linux.so</code> 的 <code>_start</code>，它先处理自己的重定位、扫描 auxv、构建链表 <code>link_map</code> 等，然后再跳到目标 ELF 的 <code>_start</code>。</li>
</ul>
<p>以 glibc + x86‑64 为例，你的程序里的 <code>_start</code>（crt1.S）做的事情大致是：</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ENTRY (_start)</span><br><span class="line">    ...</span><br><span class="line">    popq   %rsi        # 弹出 argc</span><br><span class="line">    /* argv starts just <span class="meta">at</span> the current stack top.  */</span><br><span class="line">    <span class="keyword">mov</span>    %RSP_LP, %RDX_LP     # <span class="built_in">rdx</span> = argv</span><br><span class="line"></span><br><span class="line">    /* <span class="meta">Align</span> the stack to a <span class="number">16</span> <span class="built_in">byte</span> boundary to follow the ABI.  */</span><br><span class="line">    <span class="keyword">and</span>    $~<span class="number">15</span>, %RSP_LP        # 这里：强制 %rsp 按 <span class="number">16</span> 字节对齐</span><br><span class="line"></span><br><span class="line">    /* <span class="keyword">Push</span> garbage because we <span class="keyword">push</span> <span class="number">8</span> more bytes.  */</span><br><span class="line">    pushq  %rax                 # 占个坑（返回地址对齐用）</span><br><span class="line"></span><br><span class="line">    /* Provide the highest stack address to the user code</span><br><span class="line">       (for stacks which grow downwards).  */</span><br><span class="line">    pushq  %rsp                 # 把对齐后的 stack_end 压栈，作为最后一个参数传给 __libc_start_main</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">mov</span>    $main, %RDI_LP       # <span class="built_in">rdi</span> = main</span><br><span class="line">    <span class="keyword">call</span>   *__libc_start_main@GOTPCREL(%rip)</span><br></pre></td></tr></table></figure></div>

<ol>
<li><p><code>_start</code> 先从栈里弹出 <code>argc</code>，算出 <code>argv</code> 指针：</p>
<ul>
<li><code>popq %rsi</code>  → <code>rsi = argc</code></li>
<li><code>mov %rsp, %rdx</code> → <code>rdx = argv</code></li>
</ul>
</li>
<li><p><code>and $~15, %rsp</code>，直接把 <code>%rsp</code> 底 4 bit 清零，强制对齐到 16 字节边界。</p>
<blockquote>
<p>内核把 <code>argc/argv/envp/auxv</code> 布好栈，把控制权交给 <code>_start</code>，此时栈<strong>不一定</strong>是满足 SysV ABI 要求的 16 字节对齐（内核只保证基本合理性和自己的对齐策略）。</p>
<p>这一步<strong>保证 <code>__libc_start_main</code> 这类 C 函数被调用时，栈已经按 x86‑64 SysV ABI 要求对齐好了。</strong></p>
</blockquote>
</li>
<li><p>紧接着 <code>pushq %rax</code>、<code>pushq %rsp</code> 等，最后再 <code>call __libc_start_main</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__libc_start_main(main, argc, argv, init, fini, ..., stack_end);</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p><code>__libc_start_main()</code> 里会</p>
<ul>
<li><p>设置全局变量 <code>environ = envp</code>；</p>
</li>
<li><p>从 auxv 提取 <code>AT_*</code> 信息，完成 TLS &#x2F; canary &#x2F; locale 等初始化；</p>
</li>
<li><p>调用构造函数（<code>.init_array</code>）；</p>
</li>
<li><p>最后才调用用户的：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> main(argc, argv, envp);</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p><strong>动态链接（Dynamic Linking）</strong>是指把“某些符号的解析和重定位工作”<strong>推迟到程序装载时甚至运行时</strong>再做：</p>
<ul>
<li><p>可执行文件里只记录“我需要哪些共享库、哪些导入符号”；</p>
</li>
<li><p>程序启动时由 <strong>动态链接器（<code>ld-linux.so</code>）</strong> 根据 <code>.dynamic</code> &#x2F; <code>.dynsym</code> &#x2F; <code>.rela.*</code> 等信息：</p>
<ul>
<li>把各个共享对象（<code>.so</code>）映射进内存；</li>
<li>解析导入符号；</li>
<li>对 GOT&#x2F;数据等做动态重定位；</li>
<li>然后把控制权交给程序入口。</li>
</ul>
</li>
</ul>
<p>在 ELF 的动态链接里，有两个核心限制：</p>
<ul>
<li>代码要支持 <strong>位置无关</strong>（共享库、PIE），指令里不能写死绝对地址；</li>
<li>可执行文件在链接阶段<strong>还不知道</strong>外部函数&#x2F;变量最终会来自哪个 <code>.so</code>，地址要到运行时由动态链接器决定。</li>
</ul>
<p>于是就出现了两张表：</p>
<ul>
<li><strong>GOT（Global Offset Table）</strong>：纯数据表，存“将来要用到的各种地址”（变量地址、函数地址等）；</li>
<li><strong>PLT（Procedure Linkage Table）</strong>：纯代码表，存“调用外部函数用的跳板 stub”。</li>
</ul>
<p>基本模式：</p>
<blockquote>
<p>代码 → 跳到 <strong>某个 PLT 入口</strong> → 通过 <strong>GOT 槽位</strong> 找到目标地址 → 真正的函数 &#x2F; 变量。</p>
</blockquote>
<p>这样：</p>
<ul>
<li><p>编译&#x2F;链接时，代码里只需要写相对地址（PC-relative）到 PLT&#x2F;GOT；</p>
</li>
<li><p>运行时动态链接器填补 GOT，PLT 就能通过 GOT 间接跳转到真正的实现；</p>
</li>
<li><p>可以支持：</p>
<ul>
<li>共享库复用；</li>
<li>PIE；</li>
<li>lazy binding 等。</li>
</ul>
</li>
</ul>
<h3 id="ELF-相关结构-1"><a href="#ELF-相关结构-1" class="headerlink" title="ELF 相关结构"></a>ELF 相关结构</h3><h4 id="interp-段"><a href="#interp-段" class="headerlink" title=".interp 段"></a>.interp 段</h4><p>在<strong>需要“程序解释器”的 ELF 可执行文件</strong>中（典型就是动态链接的可执行文件，包括 PIE），通常会有一个名为 <strong><code>.interp</code></strong> 的 <strong>节（section）</strong>。</p>
<ul>
<li>节名：<code>.interp</code></li>
<li>一般类型：<code>SHT_PROGBITS</code>，带 <code>SHF_ALLOC</code> 标志</li>
<li>通常会被映射到一个 <strong>程序头（Program Header）</strong>，类型为 <strong><code>PT_INTERP</code></strong> 的段（segment）</li>
</ul>
<blockquote>
<p>注意：ELF 规范里 <strong>关键的是 <code>PT_INTERP</code> 这个 Program Header</strong>，<code>.interp</code> 只是实现上常见的节名而已。</p>
</blockquote>
<p><code>.interp</code> 的内容非常简单：</p>
<ul>
<li>内容是一段 <strong>以 <code>\0</code> 结尾的 ASCII 字符串</strong></li>
<li>这段字符串给出的是 <strong>“程序解释器（Program Interpreter）”的路径</strong></li>
<li>在 Linux 上，绝大多数情况下，这个解释器就是 <strong>动态链接器</strong>（dynamic linker &#x2F; loader）</li>
</ul>
<p>常见（但<strong>不是唯一正确</strong>）的例子：</p>
<ul>
<li>x86_64 + glibc：<code>/lib64/ld-linux-x86-64.so.2</code></li>
<li>i386 + glibc：<code>/lib/ld-linux.so.2</code></li>
<li>musl libc：如 <code>/lib/ld-musl-x86_64.so.1</code> 等</li>
</ul>
<p>所以，**不能说 <code>.interp</code> 里“就是” <code>/lib64/ld-linux-x86-64.so.2</code>**，<br>应该说：</p>
<blockquote>
<p><code>.interp</code> 中保存着一个以 <code>\0</code> 结尾的路径字符串，指定该 ELF 需要的“程序解释器”（在 Linux 上通常是动态链接器），路径具体取决于架构和发行版。</p>
</blockquote>
<p>从内核视角看，关键是 <strong>程序头表中的 <code>PT_INTERP</code></strong> 条目：</p>
<ol>
<li><p>当你 <code>execve()</code> 一个 ELF 文件时，内核解析其 <strong>Program Header Table</strong>：</p>
<ul>
<li><p>如果发现有一个 <code>PT_INTERP</code> 条目：</p>
<ul>
<li>读取其中的路径字符串（文件偏移一般指向 <code>.interp</code> 的内容）</li>
<li>把该路径对应的 ELF 文件（通常是动态链接器，如 <code>ld-linux-*.so.*</code>）加载到内存</li>
<li>让这个“解释器”接管原始可执行文件的装载和运行</li>
</ul>
</li>
<li><p>如果 **没有 <code>PT_INTERP</code>**：</p>
<ul>
<li>内核直接把当前 ELF 当作<strong>不需要外部解释器</strong>的程序加载执行（在常见场景下就是“静态链接程序”）</li>
</ul>
</li>
</ul>
</li>
<li><p>从工具和实践角度看：</p>
<ul>
<li>带 <code>PT_INTERP</code> 的 ELF 一般就是“<strong>动态链接的可执行文件（包括 PIE）</strong>”</li>
<li>没有 <code>PT_INTERP</code> 的，则一般是<strong>静态链接</strong>的可执行文件</li>
</ul>
</li>
</ol>
<blockquote>
<p>更严谨地说：</p>
<ul>
<li>“是不是动态链接程序”的判断，核心依据是 <strong>是否存在 <code>PT_INTERP</code>（以及通常也有 <code>PT_DYNAMIC</code>）</strong>；</li>
<li><code>.interp</code> 只是保存路径字符串的那块数据区域，内核真正关心的是指向它的 <strong><code>PT_INTERP</code> program header</strong>，而不是“有没有一个名叫 <code>.interp</code> 的节”。</li>
</ul>
</blockquote>
<h4 id="dynamic-段"><a href="#dynamic-段" class="headerlink" title=".dynamic 段"></a>.dynamic 段</h4><p>在<strong>使用动态链接</strong>的 ELF 可执行文件或共享对象（共享库）中，有一个非常关键的结构：<br>**Dynamic Section（动态节） <code>.dynamic</code>**。</p>
<ul>
<li>从 <strong>节（Section）</strong> 的角度看：名字就叫 <code>.dynamic</code>。</li>
<li>从 <strong>段（Segment）</strong> 的角度看：程序头表中有一个类型为 <strong><code>PT_DYNAMIC</code></strong> 的段，它指向这块区域。<br>动态链接器（<code>ld.so</code>）真正依赖的是这个 <strong><code>PT_DYNAMIC</code> 段</strong> 来找到 <code>.dynamic</code> 中的内容。</li>
</ul>
<p><code>.dynamic</code> 里存放的是一系列“键值对式”的条目，告诉动态链接器：</p>
<ul>
<li>依赖了哪些共享库；</li>
<li>动态符号表和字符串表在哪里；</li>
<li>重定位表在哪里、多大；</li>
<li>初始化 &#x2F; 终止函数在哪里；</li>
<li>以及其他动态链接需要的各种参数。</li>
</ul>
<p><code>.dynamic</code> 区域是一个以 <code>Elf*_Dyn</code> 为元素的<strong>数组</strong>，以 <code>DT_NULL</code> 结尾。</p>
<p>以 32 位为例（你原来的结构体是对的，只是 64 位略有不同）：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Dynamic section entry.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Sword d_tag;   <span class="comment">/* Dynamic entry type */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        Elf32_Word d_val; <span class="comment">/* Integer value */</span></span><br><span class="line">        Elf32_Addr d_ptr; <span class="comment">/* Address value */</span></span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br></pre></td></tr></table></figure></div>

<p>64 位版本（简化）大致是：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf64_Sxword d_tag;  <span class="comment">/* Dynamic entry type */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        Elf64_Xword d_val; <span class="comment">/* Integer value */</span></span><br><span class="line">        Elf64_Addr  d_ptr; <span class="comment">/* Address value */</span></span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf64_Dyn;</span><br></pre></td></tr></table></figure></div>

<p>含义：</p>
<ul>
<li><p><code>d_tag</code>：表明这一项是什么类型（<code>DT_XXX</code>）。</p>
</li>
<li><p><code>d_un.d_val</code> &#x2F; <code>d_un.d_ptr</code>：</p>
<ul>
<li><p>对于“一般整数值”的条目，用 <code>d_val</code>；</p>
</li>
<li><p>对于“地址（虚拟地址）”类型的条目，用 <code>d_ptr</code>。</p>
<blockquote>
<p><strong><code>d_ptr</code> 一般是虚拟地址，不是文件偏移</strong>；</p>
</blockquote>
</li>
</ul>
</li>
<li><p>最后一项是 <code>d_tag == DT_NULL</code>，表示 <code>.dynamic</code> 结束。</p>
</li>
</ul>
<p><code>d_tag</code> 常见的有下面几种类型：</p>
<blockquote>
<p><strong>符号表和字符串表相关</strong></p>
<ul>
<li><p><strong><code>DT_SYMTAB</code></strong></p>
<ul>
<li>含义：动态符号表的虚拟地址。</li>
<li>使用字段：<code>d_un.d_ptr</code>。</li>
<li>通常指向 <code>.dynsym</code> 节的起始地址。</li>
<li>动态链接器通过这里找到所有“参与动态链接”的符号（函数 &#x2F; 变量名等）。</li>
</ul>
</li>
<li><p><strong><code>DT_STRTAB</code></strong></p>
<ul>
<li>含义：<strong>动态字符串表</strong>的虚拟地址。</li>
<li>使用字段：<code>d_un.d_ptr</code>。</li>
<li>通常指向 <code>.dynstr</code>（不是 <code>.synstr</code>，你原文这里写错了）。</li>
<li>符号名字、<code>DT_NEEDED</code>&#x2F;<code>DT_SONAME</code> 等引用的字符串，都存放在这个表中。</li>
</ul>
</li>
<li><p><strong><code>DT_STRSZ</code></strong></p>
<ul>
<li>含义：动态字符串表的大小（字节数）。</li>
<li>使用字段：<code>d_un.d_val</code>。</li>
</ul>
</li>
</ul>
<p>符号查找加速相关</p>
<ul>
<li><p><strong><code>DT_HASH</code></strong></p>
<ul>
<li>含义：传统 SysV 风格符号哈希表的虚拟地址。</li>
<li>使用字段：<code>d_un.d_ptr</code>。</li>
<li>通常对应 <code>.hash</code> 节，用于加速符号查找。</li>
<li>现代系统上常见 **<code>DT_GNU_HASH</code>**，对应 <code>.gnu.hash</code>，是另一套更高效的哈希机制。</li>
</ul>
</li>
</ul>
<p><strong>名字 &#x2F; 路径相关</strong></p>
<p>这些条目通常<strong>不直接存放指针</strong>，而是：</p>
<blockquote>
<p><code>d_un.d_val</code> &#x3D; 在 <strong>动态字符串表（<code>DT_STRTAB</code> 指向的表）</strong> 中的偏移。</p>
</blockquote>
<ul>
<li><p><strong><code>DT_SONAME</code></strong></p>
<ul>
<li>共享对象自己的“逻辑名称”（如 <code>libc.so.6</code>），</li>
<li>动态链接器和 <code>ldd</code> 等工具会使用它显示库名。</li>
<li>常存在于共享库（ET_DYN），在可执行文件中一般不用。</li>
</ul>
</li>
<li><p><strong><code>DT_NEEDED</code></strong></p>
<ul>
<li>表示“本对象依赖的一个共享库名字”。</li>
<li>一个库 &#x2F; 可执行文件可以有多个 <code>DT_NEEDED</code>，每个条目代表一个依赖库。</li>
<li>动态链接器通过这些名字去搜索并加载对应的 <code>.so</code> 文件。</li>
</ul>
</li>
<li><p>**<code>DT_RPATH</code>**（已废弃）</p>
<ul>
<li>指向一个以 <code>:</code> 分隔的库搜索路径字符串（字符串表偏移）。</li>
<li>旧机制，已被 <strong><code>DT_RUNPATH</code></strong> 替代，一般不推荐继续使用。</li>
<li>同样使用 <code>d_un.d_val</code> 作为字符串表偏移。</li>
</ul>
</li>
</ul>
<p><strong>初始化 &#x2F; 终止相关</strong></p>
<ul>
<li><p><strong><code>DT_INIT</code></strong></p>
<ul>
<li>含义：单个初始化函数的虚拟地址。</li>
<li>使用字段：<code>d_un.d_ptr</code>。</li>
<li>动态链接器在装载该对象、在 <code>main</code> 之前会调用这个函数一次。</li>
<li>现代编译器更多使用 <code>DT_INIT_ARRAY</code> &#x2F; <code>DT_INIT_ARRAYSZ</code> 来支持一组构造函数。</li>
</ul>
</li>
<li><p><strong><code>DT_FINI</code></strong></p>
<ul>
<li>含义：单个终止函数的虚拟地址。</li>
<li>使用字段：<code>d_un.d_ptr</code>。</li>
<li>程序退出或卸载共享对象时由动态链接器调用。</li>
<li>对应的新形式是 <code>DT_FINI_ARRAY</code> &#x2F; <code>DT_FINI_ARRAYSZ</code>。</li>
</ul>
</li>
</ul>
<p><strong>重定位相关</strong></p>
<ul>
<li><p><strong><code>DT_REL</code> &#x2F; <code>DT_RELA</code></strong></p>
<ul>
<li><p>含义：重定位表的起始虚拟地址。</p>
</li>
<li><p><code>DT_REL</code> 对应不带附加 addend 的重定位表（<code>Elf*_Rel</code>）；</p>
</li>
<li><p><code>DT_RELA</code> 对应带 addend 的重定位表（<code>Elf*_Rela</code>）。</p>
</li>
<li><p>使用字段：<code>d_un.d_ptr</code>。</p>
</li>
<li><p>实际上还会配合以下条目一起使用：</p>
<ul>
<li><code>DT_RELSZ</code> &#x2F; <code>DT_RELASZ</code>：重定位表总大小；</li>
<li><code>DT_RELENT</code> &#x2F; <code>DT_RELAENT</code>：每个重定位项的大小；</li>
<li>还有专门给 PLT 的 <code>DT_JMPREL</code> &#x2F; <code>DT_PLTRELSZ</code> &#x2F; <code>DT_PLTREL</code> 等。</li>
</ul>
</li>
</ul>
<p>动态链接器根据这些信息，遍历重定位项，为 GOT&#x2F;PLT、全局变量等打上正确的地址。</p>
</li>
</ul>
</blockquote>
<h4 id="动态符号表（-dynsym）"><a href="#动态符号表（-dynsym）" class="headerlink" title="动态符号表（.dynsym）"></a>动态符号表（<code>.dynsym</code>）</h4><p>动态链接时，动态链接器需要知道：</p>
<ul>
<li>本模块<strong>导出</strong>给别人的符号（供别的 <code>.so</code> &#x2F; 主程序引用）；</li>
<li>本模块<strong>导入</strong>自别人的符号（需要从其它 <code>.so</code> 里解析）。</li>
</ul>
<p>这些信息就集中保存在 <strong>动态符号表 <code>.dynsym</code></strong> 中：</p>
<ul>
<li><p><code>.dynsym</code> 的元素类型仍然是 <code>Elf*_Sym</code> 数组。</p>
</li>
<li><p>它只包含“<strong>和动态链接相关</strong>”的那部分符号：</p>
<ul>
<li>参与导入 &#x2F; 导出 &#x2F; 重定位的全局符号、弱符号；</li>
<li>不包含纯本地、只在编译期用的内部符号（那种在 <code>.symtab</code> 里才完整出现）。</li>
</ul>
</li>
<li><p>一个 ELF 通常可能同时有：</p>
<ul>
<li>**<code>.symtab</code>**：静态符号表，给链接器、调试器用，内容“尽量全”（编译期视图）；</li>
<li>**<code>.dynsym</code>**：动态符号表，给动态链接器用，只保留动态链接需要的那一部分符号（运行期视图）。</li>
</ul>
</li>
</ul>
<p>和 <code>.symtab</code> 一样，<code>.dynsym</code> 也需要配套的辅助表：</p>
<ul>
<li><p>**<code>.dynstr</code>**：动态字符串表</p>
<ul>
<li><code>st_name</code> 字段的字符串偏移就是相对于 <code>.dynstr</code> 的；</li>
<li>哪个节是 <code>.dynstr</code>，由 <code>.dynsym</code> 节头里的 <code>sh_link</code> 指明。</li>
</ul>
</li>
<li><p><strong>符号哈希表</strong>：</p>
<ul>
<li>老式：<code>.hash</code></li>
<li>新式：<code>.gnu.hash</code></li>
<li>主要用于加速动态链接器查符号，不查整个 <code>.dynsym</code> 线性表。</li>
</ul>
</li>
</ul>
<blockquote>
<p>总结一句：<br><code>.symtab</code> 是“给链接器 &#x2F; 调试器看的完整符号视图”，<br><code>.dynsym</code> 是“给动态链接器看的精简符号视图”。</p>
</blockquote>
<h4 id="动态重定位表（-rel-dyn-rela-dyn、-rel-plt-rela-plt）"><a href="#动态重定位表（-rel-dyn-rela-dyn、-rel-plt-rela-plt）" class="headerlink" title="动态重定位表（.rel.dyn &#x2F; .rela.dyn、.rel.plt &#x2F; .rela.plt）"></a>动态重定位表（<code>.rel.dyn</code> &#x2F; <code>.rela.dyn</code>、<code>.rel.plt</code> &#x2F; <code>.rela.plt</code>）</h4><p>在 <strong>静态链接</strong> 中，未知地址在链接阶段就能确定；链接器用 <code>.rel.text</code> &#x2F; <code>.rel.data</code> 等把地址 patch 好后，这些重定位信息就可以丢掉。</p>
<p>但在 <strong>动态链接</strong> 中，导入符号（来自其它 <code>.so</code>）的地址要到 <strong>运行时</strong> 才能确定：</p>
<ul>
<li>比如程序哪个时刻才加载哪个 <code>.so</code>；</li>
<li>PIE &#x2F; 共享库的装载基址每次运行都可能不同（ASLR）。</li>
</ul>
<p>所以必须把一部分“待修正的引用”延后到动态链接器运行时再做，这就需要“动态重定位表”。</p>
<p><strong>一般数据和非 PLT 的重定位</strong>需要 <code>.rel.dyn</code> 或 <code>.rela.dyn</code>（具体用 REL 还是 RELA 看 ABI），节类型为 <code>SHT_REL</code> &#x2F; <code>SHT_RELA</code>，元素为 <code>Elf*_Rel</code> &#x2F; <code>Elf*_Rela</code>。</p>
<p>这类节的主要作用是<strong>修正各种“非 PLT 的”地址引用</strong>，包括但不限于：</p>
<ul>
<li><code>.got</code> 中存放的指针（例如全局变量、函数指针等）；</li>
<li><code>.data</code> &#x2F; <code>.bss</code> 等数据段中保存的绝对地址；</li>
<li>某些位置无关代码中需要运行时计算的地址等。</li>
</ul>
<p>可以类比为“<strong>动态版本的 .rel.data &#x2F; .rela.data</strong>”，只不过它修的是：</p>
<blockquote>
<p>“装载后在内存中的位置”，由<strong>动态链接器</strong>来处理（通常在程序启动阶段或按需处理）。</p>
</blockquote>
<p><strong>PLT&#x2F;GOT 上的函数调用重定位</strong>需要 <code>.rel.plt</code> 或 <code>.rela.plt</code>；这种重定位的目标位置主要在 <strong><code>.got.plt</code></strong> 里，即和 PLT 表关联的 GOT 槽位；</p>
<p>因此这类节的主要作用是<strong>修正外部函数调用的入口</strong>，典型流程：</p>
<ul>
<li><p>对某个外部函数 <code>foo</code>：</p>
<ul>
<li>代码调用 <code>foo@plt</code>；</li>
<li><code>foo@plt</code> 的 stub 会通过 <code>.got.plt</code> 中的槽位间接跳转；</li>
<li><code>.rel.plt</code> &#x2F; <code>.rela.plt</code> 中为这个槽位生成一个重定位条目。</li>
</ul>
</li>
<li><p>动态链接器根据这些条目：</p>
<ul>
<li>首次调用时解析符号地址，写入对应 GOT 槽位；</li>
<li>之后直接从 GOT 跳到真正的 <code>foo</code> 实现（延迟绑定），<br>或在 FULL RELRO + <code>-z now</code> 场景下启动时就一次性填满。</li>
</ul>
</li>
</ul>
<p>可以粗略把 <code>.rel.plt</code> &#x2F; <code>.rela.plt</code> 想象成：</p>
<blockquote>
<p>“<strong>动态版本的 .rel.text 里那部分跟函数调用相关的重定位信息，但专门抽出来服务于 PLT</strong>”。</p>
</blockquote>
<h4 id="GOT-表（-got-got-plt）"><a href="#GOT-表（-got-got-plt）" class="headerlink" title="GOT 表（.got&#x2F;.got.plt）"></a>GOT 表（.got&#x2F;.got.plt）</h4><p>在常见的 System V 风格 ELF（比如 x86‑64 glibc）里，GOT 通常“逻辑上”分两块：</p>
<ul>
<li><p><strong><code>.got</code></strong></p>
<ul>
<li><p>用来存放<strong>数据引用</strong>相关的地址（或偏移），比如：</p>
<ul>
<li>全局变量；</li>
<li>常量表；</li>
<li>函数指针等。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>.got.plt</code></strong></p>
<ul>
<li>用来存放<strong>通过 PLT 调用的外部函数</strong>的地址槽位。</li>
</ul>
</li>
</ul>
<p>有些实现可能只生成一个 <code>.got</code>，把函数&#x2F;数据混在一起，这是实现细节，不是 ELF 规范强制的。</p>
<p>在 glibc + i386 &#x2F; x86‑64 下，<code>.got.plt</code> 前几项通常留给动态链接器自用（懒绑定相关），常见约定类似：</p>
<pre><font color="#26A269"><b>pwndbg&gt; </b></font>got
Filtering out read-only entries (display them with -r or --show-readonly)
State of the GOT of <font color="#A347BA">/home/ubuntu/Desktop/pwn</font>:
GOT protection: <font color="#A2734C">Partial RELRO</font> | Found <font color="#A2734C">1</font> GOT entries passing the filter
[<font color="#A347BA">0x555555558018</font>] <font color="#A2734C">system@GLIBC_2.2.5</font> -&gt; <font color="#C01C28">0x555555555030</font> ◂— <font color="#AFD700">endbr64</font><font color="#FFFFFF"> </font>
<font color="#26A269"><b>pwndbg&gt; </b></font>telescope 0x555555558018-8*3
00:0000│  <font color="#A347BA">0x555555558000 (_GLOBAL_OFFSET_TABLE_)</font> ◂— 0x3df8
01:0008│  <font color="#A347BA">0x555555558008 (_GLOBAL_OFFSET_TABLE_+8)</font> —▸ <font color="#A347BA">0x7ffff7ffe2e0</font> —▸ 0x555555554000 ◂— 0x10102464c457f
02:0010│  <font color="#A347BA">0x555555558010 (_GLOBAL_OFFSET_TABLE_+16)</font> —▸ <font color="#C01C28">0x7ffff7fd8d30 (_dl_runtime_resolve_xsavec)</font> ◂— <font color="#AFD700">endbr64</font><font color="#FFFFFF"> </font>
03:0018│  <font color="#A347BA">0x555555558018 (system@got[plt])</font> —▸ <font color="#C01C28">0x555555555030</font> ◂— <font color="#AFD700">endbr64</font><font color="#FFFFFF"> </font>
04:0020│  <font color="#A347BA">0x555555558020 (data_start)</font> ◂— 0
05:0028│  <font color="#A347BA">0x555555558028 (__dso_handle)</font> ◂— <font color="#A347BA">0x555555558028 (__dso_handle)</font>
06:0030│  <font color="#A347BA">0x555555558030 (tcp_port)</font> ◂— 0x16
07:0038│  <font color="#A347BA">0x555555558038</font> ◂— 0
<font color="#26A269"><b>pwndbg&gt; </b></font>telescope &dollar;rebase(0x3df8)
00:0000│  0x555555557df8 (_DYNAMIC) ◂— 1
01:0008│  0x555555557e00 (_DYNAMIC+8) ◂— 0x29 /* &apos;)&apos; */
02:0010│  0x555555557e08 (_DYNAMIC+16) ◂— 0xc /* &apos;\x0c&apos; */
03:0018│  0x555555557e10 (_DYNAMIC+24) ◂— 0x1000
04:0020│  0x555555557e18 (_DYNAMIC+32) ◂— 0xd /* &apos;\r&apos; */
05:0028│  0x555555557e20 (_DYNAMIC+40) ◂— 0x11f0
06:0030│  0x555555557e28 (_DYNAMIC+48) ◂— 0x19
07:0038│  0x555555557e30 (_DYNAMIC+56) ◂— 0x3de8
</pre>

<ul>
<li><p><code>got.plt[0]</code>：指向与动态链接有关的数据（比如 <code>_DYNAMIC</code> 或内部标记），方便动态链接器定位动态段；</p>
</li>
<li><p><code>got.plt[1]</code>：指向 <code>link_map</code> 结构体，里面存着当前进程已加载模块的信息，是 <code>_dl_runtime_resolve</code> 的一个参数；</p>
<blockquote>
<p><strong><code>struct link_map</code> &#x3D; 动态链接器内部用来描述“一个已加载 ELF 模块”的大结构体。</strong><br>每加载一个可执行文件或 <code>.so</code>，动态链接器就为它建一个 <code>link_map</code> 节点，把这些节点串成双向链表。</p>
<ul>
<li><p>每个 <code>link_map</code> 对应一个 <strong>已加载的 ELF 对象</strong>：</p>
<ul>
<li>主程序；</li>
<li>每一个共享库 <code>.so</code>；</li>
<li>甚至 <code>ld-linux.so</code> 自己。</li>
</ul>
</li>
<li><p>所有 <code>link_map</code> 用 <code>l_next</code> &#x2F; <code>l_prev</code> 串成链表，表头通过 <code>r_debug.r_map</code> 这个结构给调试器用。</p>
</li>
<li><p>动态链接器做任何“找符号 &#x2F; 找重定位 &#x2F; 找依赖库”的事，基本都是从某个 <code>link_map *</code> 开始，顺着里面的各种字段找 <code>.dynamic</code>、符号表、重定位表等等。</p>
</li>
</ul>
<p>glibc 内部的 <code>link_map</code> 结构大致如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> &#123;</span></span><br><span class="line">    ElfW(Addr)  l_addr;  <span class="comment">// 该对象在内存中的基址偏移（load bias）</span></span><br><span class="line">    <span class="type">char</span>       *l_name;  <span class="comment">// 这个对象对应的文件路径</span></span><br><span class="line">    ElfW(Dyn)  *l_ld;    <span class="comment">// 指向该对象的 .dynamic 段</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span> <span class="comment">// 链表指针</span></span><br><span class="line">    <span class="comment">/* 后面一大堆是 glibc 内部字段 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong><code>l_addr</code></strong></p>
<ul>
<li>作用：<strong>这个模块的 load bias &#x2F; 基址</strong>。</li>
<li>含义：内存装载地址和 ELF 文件里 p_vaddr &#x2F; e_entry 之间的差值。</li>
<li>对 PIE&#x2F;共享库来说：地址 &#x3D; <code>l_addr + 文件里写的虚拟地址</code>。</li>
<li>动态链接器&#x2F;调试器都用它来把“ELF 里的地址”映射成“进程里的真实地址”。</li>
</ul>
</li>
<li><p><strong><code>l_name</code></strong></p>
<ul>
<li>模块的文件名（绝对路径），比如 <code>/lib/x86_64-linux-gnu/libc.so.6</code>。</li>
<li><code>dlopen</code> &#x2F; <code>gdb info sharedlibrary</code> 之类都能看到它。</li>
</ul>
</li>
<li><p><strong><code>l_ld</code></strong></p>
<ul>
<li><p>指向这个模块的 <code>.dynamic</code> 段在内存中的位置（<code>ElfW(Dyn) *</code>）。</p>
</li>
<li><p><code>.dynamic</code> 里面就是各种 <code>DT_*</code>：</p>
<ul>
<li><code>DT_SYMTAB</code> &#x2F; <code>DT_STRTAB</code> &#x2F; <code>DT_HASH</code> &#x2F; <code>DT_GNU_HASH</code></li>
<li><code>DT_RELA</code> &#x2F; <code>DT_JMPREL</code>（.rela.dyn &#x2F; .rela.plt 的信息）</li>
<li><code>DT_NEEDED</code> &#x2F; <code>DT_RPATH</code> &#x2F; <code>DT_RUNPATH</code> 等等。</li>
</ul>
</li>
<li><p>动态链接器初始化 <code>link_map</code> 的时候，会扫 <code>l_ld</code> 指向的 <code>.dynamic</code>，把有用的信息抄到下面的 <code>l_info[]</code> 里。</p>
</li>
</ul>
</li>
<li><p><strong><code>l_next</code> &#x2F; <code>l_prev</code></strong></p>
<ul>
<li>把所有 <code>link_map</code> 串成一个双向链表。</li>
<li>链表表头在 <code>struct r_debug.r_map</code> 里，<code>DT_DEBUG</code> 会指向 <code>_r_debug</code>，所以调试器可以从这里遍历所有已加载模块。</li>
</ul>
</li>
</ul>
<p>其中最重要的字段是 <code>l_info</code>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ElfW(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM + DT_EXTRANUM];</span><br></pre></td></tr></table></figure></div>

<p>意思是：</p>
<blockquote>
<p>把 <code>.dynamic</code> 里各种 DT_* 项按照不同 tag 分类，<br><strong>预先按索引塞进 <code>l_info[]</code>，方便 O(1) 拿到各种关键指针。</strong></p>
</blockquote>
<p>例如（伪代码）：</p>
<ul>
<li><code>l_info[DT_SYMTAB]</code> → 指向 <code>.dynsym</code>；</li>
<li><code>l_info[DT_STRTAB]</code> → 指向 <code>.dynstr</code>；</li>
<li><code>l_info[DT_JMPREL]</code> → 指向 <code>.rela.plt</code>；</li>
<li><code>l_info[DT_PLTRELSZ]</code> → <code>.rela.plt</code> 的大小；</li>
<li><code>l_info[DT_RELA]</code> &#x2F; <code>DT_RELASZ</code> → <code>.rela.dyn</code>；</li>
<li>…</li>
</ul>
<p>这样 <code>_dl_fixup</code> &#x2F; <code>_dl_relocate_object</code> 在处理一个模块时，只要有 <code>link_map *l</code>，就能很快拿到它的动态符号表、字符串表、重定位表等信息，而不用每次手动遍历 <code>.dynamic</code> 段。</p>
<p>往下还有很多字段（<code>l_searchlist</code>、<code>l_runpath_dirs</code>、<code>l_dev</code>&#x2F;<code>l_ino</code>、<code>l_versions</code>、<code>l_scope</code>、<code>l_mach</code> 等），大致用途：</p>
<ul>
<li>依赖关系和符号查找 scope；</li>
<li>RPATH &#x2F; RUNPATH 搜索路径；</li>
<li>版本信息（<code>VERSYM</code> &#x2F; <code>VERDEF</code>）；</li>
<li>这个模块是主程序 &#x2F; 依赖库 &#x2F; <code>dlopen</code> 动态加载；</li>
<li>是否已经做过重定位、是否调用过 <code>DT_INIT</code> 等；</li>
<li>机器相关数据（<code>l_mach</code>）；</li>
<li>最近一次符号查找缓存（<code>l_lookup_cache</code>）。</li>
</ul>
<p>这些对写漏洞利用 &#x2F; ELF 分析来说一般不必全记死，知道“动态链接器有一张很大的状态表，<code>link_map</code> 是核心入口”就够了。</p>
<p>典的懒绑定流程里（你前面那种 <code>.plt</code> + <code>_dl_runtime_resolve</code>）大致是：</p>
<ol>
<li><p>程序调用 <code>foo@plt</code>；</p>
</li>
<li><p><code>foo@plt</code> 先 <code>jmp [foo@GOT]</code>，第一次会跳到 <code>push index; jmp PLT0</code>；</p>
</li>
<li><p>PLT0 调 <code>_dl_runtime_resolve</code>（或某个架构专用的 trampoline）；</p>
</li>
<li><p><code>_dl_runtime_resolve</code> &#x2F; <code>_dl_fixup</code> 需要知道：</p>
<ul>
<li>是“<strong>哪个模块</strong>”发起的这次 PLT 调用（主程序？某个 <code>.so</code>？）；</li>
<li>以及这个模块的 <code>.dynsym</code>、<code>.dynstr</code>、<code>.rela.plt</code> 等的地址。</li>
</ul>
</li>
</ol>
<p>这里就用到了 GOT：</p>
<ul>
<li><p>按 System V &#x2F; glibc 的传统约定：</p>
<ul>
<li>**<code>GOT[1]</code><strong>（或 <code>.got.plt[1]</code>）里放的是</strong>当前模块的 <code>struct link_map *</code>**；</li>
<li><strong><code>GOT[2]</code></strong> 里放的是 <code>_dl_runtime_resolve</code> 的地址。</li>
</ul>
</li>
</ul>
<p>这样 <code>_dl_runtime_resolve</code> 就能：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码（实际是汇编转 C 的逻辑）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span> =</span> (<span class="keyword">struct</span> link_map *) got[<span class="number">1</span>];</span><br><span class="line">ElfW(Sym) *symtab   = (ElfW(Sym) *) l-&gt;l_info[DT_SYMTAB]-&gt;d_un.d_ptr;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *strtab  = (<span class="type">char</span> *)       l-&gt;l_info[DT_STRTAB]-&gt;d_un.d_ptr;</span><br><span class="line">ElfW(Rela) *jmprel  = (ElfW(Rela) *) l-&gt;l_info[DT_JMPREL]-&gt;d_un.d_ptr;</span><br><span class="line"><span class="comment">// 用 index 去 jmprel / symtab / strtab 里找符号、修 GOT 槽位……</span></span><br></pre></td></tr></table></figure></div>

<p>也就是说：</p>
<blockquote>
<p><strong>GOT[1] &#x3D; 这个 PLT 所属模块的“身份证”；<br>从 <code>link_map *</code> 出发，动态链接器才能知道：<br>“我要在谁的 <code>.dynsym/.dynstr/.rela.plt</code> 里给谁修重定位。”</strong></p>
</blockquote>
</blockquote>
</li>
<li><p><code>got.plt[2]</code>：保存 <code>_dl_runtime_resolve</code> 或对应入口桩的地址，PLT0 会通过这里跳进动态链接器。</p>
</li>
</ul>
<p>精确含义依 ABI &#x2F; glibc 版本略有差异，但结论统一：</p>
<blockquote>
<p><strong><code>.got.plt</code> 的前几项留给动态链接器实现 lazy binding，后面的槽位才是每个外部函数自己的 GOT entry。</strong></p>
</blockquote>
<h4 id="PLT-表（-plt-plt-got-plt-sec）"><a href="#PLT-表（-plt-plt-got-plt-sec）" class="headerlink" title="PLT 表（.plt&#x2F;.plt.got&#x2F;.plt.sec）"></a>PLT 表（.plt&#x2F;.plt.got&#x2F;.plt.sec）</h4><p>PLT 是一堆小函数，每个外部符号（尤其是导入函数）在 PLT 里对应一个入口：</p>
<ul>
<li><code>printf@plt</code></li>
<li><code>getenv@plt</code></li>
<li><code>bar@plt</code></li>
<li>…</li>
</ul>
<p>编译器&#x2F;链接器不会生成：</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> printf          <span class="comment">; 绝对或直接相对</span></span><br></pre></td></tr></table></figure></div>

<p>而是生成：</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> printf@plt      <span class="comment">; 调用当前模块里的 PLT stub</span></span><br></pre></td></tr></table></figure></div>

<p>PLT stub 内部再去看 GOT 条目：</p>
<ul>
<li>运行时动态链接器填 GOT；</li>
<li>PLT 通过 GOT 间接跳到真正的函数实现。</li>
</ul>
<p>以 x86‑64 延迟绑定 PLT 为例，在未开启 FULL RELRO + lazy binding 时，PLT 表可以抽象成：</p>
<ul>
<li><p><strong>PLT0</strong>（通用入口）：</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">PLT0:</span></span><br><span class="line">    <span class="keyword">push</span> *(GOT+<span class="number">8</span>)         <span class="comment">; 压 link_map 等信息</span></span><br><span class="line">    <span class="keyword">jmp</span>  *(GOT+<span class="number">16</span>)        <span class="comment">; 跳到 _dl_runtime_resolve</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>对某个函数 <code>bar</code> 的 <code>bar@plt</code>：</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">bar@plt:</span></span><br><span class="line">    <span class="keyword">jmp</span> *(bar@GOT)  <span class="comment">; 通过 .got.plt[bar_index] 间接跳转</span></span><br><span class="line">    <span class="keyword">push</span> n          <span class="comment">; n = 对应重定位条目的索引</span></span><br><span class="line">    <span class="keyword">jmp</span>  PLT0       <span class="comment">; 交给 PLT0 / 动态链接器处理</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<p><strong>第一次调用 <code>bar</code> 时：</strong></p>
<ul>
<li><p><code>bar@GOT</code> 槽位里放的是“跳回 PLT stub 后半段”的地址；</p>
</li>
<li><p><code>jmp *(bar@GOT)</code> 实际跳到 <code>push n; jmp PLT0</code>；</p>
</li>
<li><p>PLT0 调 <code>_dl_runtime_resolve</code>，动态链接器：</p>
<ul>
<li>在 <code>.dynsym</code>、<code>.dynstr</code>、<code>.gnu.hash</code> 等里查 “bar”；</li>
<li>在 <code>.rela.plt</code> 里找对应重定位；</li>
<li>解析出真正的 <code>bar</code> 地址，写进 <code>bar@GOT</code> 槽位；</li>
<li>然后跳到真正的 <code>bar</code>。</li>
</ul>
</li>
</ul>
<p><strong>后续调用 <code>bar</code>：</strong></p>
<ul>
<li><code>bar@GOT</code> 已经是正确地址；</li>
<li><code>jmp *(bar@GOT)</code> 直接跳到真正的 <code>bar</code>，不再走动态链接器；</li>
<li>实现了 <strong>lazy binding</strong>：按需解析，第一次慢、之后快。</li>
</ul>
<blockquote>
<p>延迟绑定能成立的前提：<code>.got.plt</code> 对动态链接器是 <strong>可写</strong> 的。</p>
</blockquote>
<p>除了 <code>.plt</code> 外，现代二进制（PIE + Full RELRO + CET）里，会同时存在：</p>
<ul>
<li><code>.plt</code></li>
<li><code>.plt.got</code></li>
<li><code>.plt.sec</code></li>
</ul>
<p>这不是三种“完全不同的机制”，而是 <strong>同一套机制在安全强化 &amp; 兼容性约束下演化出来的不同分工</strong>。</p>
<ul>
<li><p><code>.plt</code>：是为 <strong>老式懒绑定协议</strong> 准备的入口；在 Full RELRO + BIND_NOW 下，一般不会实用，只是保留兼容。</p>
</li>
<li><p><code>.plt.got</code>：少量特殊函数的 PLT，是专门给个别函数（如 <code>__cxa_finalize</code>）做一个 PLT 入口；这些函数在初始化&#x2F;终结阶段有特殊要求，动态链接器可能在不同时间点处理；形式通常是：</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">__cxa_finalize@plt:</span></span><br><span class="line">    endbr64</span><br><span class="line">    <span class="keyword">bnd</span> <span class="keyword">jmp</span> *__cxa_finalize@GOTPCREL(%rip)</span><br><span class="line">    <span class="keyword">nop</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>为什么单独放 <code>.plt.got</code>？</strong><br>主要是布局和实现约定的问题：让动态链接器容易找到并提前处理，属于 ABI&#x2F;x86_64 glibc 的细节。</p>
</blockquote>
</li>
<li><p><code>.plt.sec</code>：现代“主力 PLT”，一般的 stub 模式（Full RELRO + CET）类似：</p>
</li>
</ul>
  <div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">foo@plt:</span></span><br><span class="line">    endbr64</span><br><span class="line">    <span class="keyword">bnd</span> <span class="keyword">jmp</span> *foo@GOTPCREL(%rip)</span><br><span class="line">    <span class="keyword">nop</span></span><br></pre></td></tr></table></figure></div>

<p>  与老 PLT 相比：</p>
<ul>
<li><p><strong>没有</strong> <code>push index; jmp PLT0</code> 这半截；</p>
</li>
<li><p>调用路径就是单一步“间接跳转到 GOT 里记录的地址”；</p>
</li>
<li><p>结合 Full RELRO + <code>-z now</code>：</p>
<ul>
<li>启动时动态链接器就把 <code>.rela.plt</code> 的所有重定位做完；</li>
<li>把 <code>.got.plt</code> 槽位全部写成最终函数地址；</li>
<li>然后把 GOT 页标记为只读；</li>
<li>之后 <code>foo@plt</code> 就是一个固定的 <code>endbr64; jmp [GOT]</code>，<strong>不再发生 lazy binding</strong>。</li>
</ul>
</li>
</ul>
<h3 id="动态链接过程"><a href="#动态链接过程" class="headerlink" title="动态链接过程"></a>动态链接过程</h3><h4 id="动态链接器自举"><a href="#动态链接器自举" class="headerlink" title="动态链接器自举"></a>动态链接器自举</h4><p>在 ELF 格式的程序中，如果启用了动态链接（即不是 <code>-static</code> 编译），那么程序的启动流程会先进入动态链接器（如 64 位系统上的 <code>/lib64/ld-linux-x86-64.so.2</code>）。但由于动态链接器本身也是一个 ELF 可执行体，它也有重定位需求，必须先完成<strong>自我重定位</strong>才能开始为主程序服务，这一过程称为<strong>自举（Bootstrap）</strong>。</p>
<p>动态链接器的入口地址就是自举代码的起点，当内核将控制权交给动态链接器时，它会执行如下步骤：</p>
<ol>
<li><strong>读取自己的 GOT 表</strong>，通常通过 <code>.got.plt</code> 区段定位。</li>
<li><strong>GOT 的第一个表项</strong>通常保存 <code>.dynamic</code> 段的偏移，由此定位到 <code>.dynamic</code>。</li>
<li>从 <code>.dynamic</code> 段中解析出链接器自身的重定位表、符号表、字符串表等信息。</li>
<li>使用这些表项，对链接器自身的重定位表进行修复（如 <code>R_*_RELATIVE</code> 条目），完成自身地址修正。</li>
</ol>
<p>只有完成这些步骤后，链接器本身的<strong>全局变量、函数指针、跳转表等才能正常使用</strong>。这也意味着：<strong>动态链接器前半段的代码几乎不依赖任何已初始化的全局数据区，只能使用硬编码和偏移量操作。</strong></p>
<h4 id="装载共享对象"><a href="#装载共享对象" class="headerlink" title="装载共享对象"></a>装载共享对象</h4><p>完成自举后，链接器会开始处理主程序（即用户编写的可执行文件）的依赖项。</p>
<ol>
<li><strong>合并全局符号表</strong><br> 链接器将主程序与链接器自身的符号表合并为一个全局符号表，供后续查找使用。</li>
<li><strong>解析 DT_NEEDED</strong><br> 主程序的 <code>.dynamic</code> 段中包含多个 <code>DT_NEEDED</code> 项，每个表示一个需要加载的共享对象（动态库）。</li>
<li><strong>构建装载集合</strong><br> 链接器将所有 <code>DT_NEEDED</code> 项依次加入待装载队列，并按一定顺序加载这些库。这个过程可以类比为对 ELF 依赖图的遍历，glibc 中使用的是<strong>广度优先遍历（BFS）</strong>，可以避免较深的递归加载导致顺序不一致。</li>
<li><strong>递归解析依赖</strong><br> 如果某个库又依赖其他共享对象（即它自身也有 <code>DT_NEEDED</code>），链接器将其依赖也加入集合中，直到整个依赖树完全加载。</li>
<li><strong>映射 ELF 文件</strong><br> 每个共享对象被打开后，链接器读取其 ELF 头部、程序头表（Program Header Table），将其 <code>.text</code>、<code>.data</code>、<code>.rodata</code> 等段通过 <code>mmap</code> 映射到进程地址空间中。</li>
</ol>
<h4 id="重定位和初始化"><a href="#重定位和初始化" class="headerlink" title="重定位和初始化"></a>重定位和初始化</h4><p>共享对象装载完成后，链接器执行重定位操作，将指针类符号修正为实际加载地址。</p>
<blockquote>
<p>由于需要将多个模块装载到内存中，因此动态链接难免会有地址冲突问题，这就需要我们在加载的时候将模块中的相关地址修改为正确的值，这就是装载时重定位。</p>
<p>Linux和GCC支持这种装载时重定位的方法，在产生共享对象时，使用了两个GCC参数 <code>-shared</code> 和 <code>-fPIC</code> ，如果只使用 <code>-shared</code> ，那么输出的共享对象就是使用装载时重定位的方法。</p>
</blockquote>
<p>这包括 <code>.got</code>、<code>.got.plt</code>、全局变量等。常见重定位类型（以 x86 为例）有：</p>
<ul>
<li><code>R_386_RELATIVE</code>：重定位静态地址引用，如 <code>static int *p = &amp;a;</code></li>
<li><code>R_386_GLOB_DAT</code>：全局变量地址写入 <code>.got</code> 表</li>
<li><code>R_386_JUMP_SLOT</code>：函数符号重定位，写入 <code>.got.plt</code>，用于延迟绑定</li>
</ul>
<p>为了提高程序启动速度，<strong>PLT（Procedure Linkage Table）+ GOT 机制支持懒绑定</strong>：首次调用外部函数时，PLT 入口跳转至 <code>_dl_runtime_resolve</code>，动态链接器在该函数中完成真正地址解析并修复 <code>.got.plt</code> 表项。</p>
<blockquote>
<p>把同一个模块装到不同虚拟地址，如果在代码里写死了绝对地址，就需要<strong>修改代码段</strong>里的指令（所谓“对 .text 做重定位”），这会让代码页变成私有页，<strong>无法在多个进程间共享</strong>，也拉低启动性能。</p>
<p>用 <strong>地址无关代码</strong>（PIC）把“和绝对地址相关的东西”挪到<strong>数据表</strong>里就可以解决上述问题：</p>
<ul>
<li>代码中的控制流（<code>call/jmp</code>）尽量用<strong>相对位移</strong>；</li>
<li>代码若要取“某个符号的绝对地址”，就先去 <strong>GOT（全局偏移表）</strong> 拿该符号当前进程里的真实地址，再访问；</li>
<li>调<strong>外部函数</strong>用 <strong>PLT（过程链接表）</strong>：<code>call foo@plt</code> → PLT 查&#x2F;填 GOT → 真正跳到函数。首次调用解析，之后命中 GOT（延迟绑定）。</li>
</ul>
<p>此时<strong>模块内与模块间</strong></p>
<ul>
<li><p><strong>模块内控制流</strong>：天然 PC‑relative，对<strong>同一模块内</strong>的符号，用“相对当前指令的偏移”寻址（不依赖装载基址），无需表项。</p>
<blockquote>
<p>注：x86‑64 上 RIP 是<strong>顺序下一条指令</strong>的地址（fall‑through），PC‑relative 以它为基准计算偏移。</p>
</blockquote>
</li>
<li><p><strong>模块内数据</strong>：</p>
<ul>
<li><code>static</code>&#x2F;<code>hidden</code>：直接 RIP‑relative；</li>
<li>默认可见全局：为支持 ELF <strong>符号截获</strong>语义，经 GOT 间接。</li>
</ul>
</li>
<li><p><strong>模块间</strong>：</p>
<ul>
<li><strong>函数</strong>：PLT+GOT（支持延迟绑定）；</li>
<li><strong>数据</strong>：通过 GOT 间接；若主程序是<strong>非 PIE</strong>而直接引用共享库变量，可能触发 <strong>Copy relocation</strong>（启动时把值拷贝一份到主程序的 <code>.bss</code>）。</li>
</ul>
</li>
</ul>
</blockquote>
<p>可通过环境变量 <code>LD_BIND_NOW=1</code> 禁用懒绑定，强制所有 <code>JUMP_SLOT</code> 重定位在程序启动时立即完成。</p>
<h4 id="执行构造函数"><a href="#执行构造函数" class="headerlink" title="执行构造函数"></a>执行构造函数</h4><p>重定位完成后，链接器将调用每个<strong>共享对象</strong>中注册的初始化函数：</p>
<ul>
<li><code>.init_array</code>：现代构造函数表，<strong>按数组顺序依次调用</strong>，优先使用。</li>
<li><code>.init</code>：旧式单入口构造函数（被 <code>_init</code> 调用）。</li>
<li><code>.ctors</code>：废弃机制，仅供兼容。</li>
</ul>
<p>这些构造函数用于初始化 C++ 的全局对象、线程局部变量、资源连接等。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p>**动态链接器不会主动执行主程序的 <code>.init</code> 和 <code>.init_array</code>**，这部分由程序自己的入口代码（通常是 <code>__libc_csu_init</code>）负责调用。</p>

    </div>
  </div>

<p>当所有依赖库装载完毕、重定位完成、构造函数执行完毕之后，动态链接器的工作完成，它将控制权移交给主程序入口，即 ELF 文件头 <code>e_entry</code> 指定的位置。在 glibc 中，这个流程是：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_start</span><br><span class="line">  → __libc_start_main</span><br><span class="line">      → __libc_csu_init   <span class="comment">// 调用 .init_array / _init 等</span></span><br><span class="line">      → main              <span class="comment">// 用户主函数</span></span><br></pre></td></tr></table></figure></div>

<p>至此，用户代码才真正开始执行。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>当程序执行结束时，还会依次执行 <code>.fini_array</code>、<code>.fini</code> 中注册的析构函数，以销毁全局对象、关闭连接、释放资源等。</p>
<p>动态链接器也会负责调用所有共享对象的 <code>.fini_array</code>，而主程序自身的 <code>.fini_array</code> 同样由 <code>__libc_csu_fini</code> 负责。</p>

    </div>
  </div>

<h4 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h4><p>在使用动态链接的程序里，模块之间常常存在<strong>大量的函数调用</strong>（而为了降低耦合，跨模块的可写全局变量一般较少）。如果在<strong>程序启动</strong>时就把所有外部函数的地址都解析并重定位完，会带来不必要的启动开销——毕竟很多函数在一次运行中<strong>从未被调用</strong>。因此，ELF&#x2F;ld.so 采用<strong>延迟绑定</strong>：<strong>仅在函数第一次被调用时</strong>，才进行符号查找与对应 GOT 表的修补；未被用到的函数<strong>不会</strong>提前绑定，从而缩短启动时间，特别适合依赖众多库、外部调用巨量的程序。</p>
<blockquote>
<p><strong>只对“函数调用”可延迟。</strong> 变量（数据）引用的动态重定位<strong>一般在装载时一次性完成</strong>，不会延迟绑定。通过 <code>dlopen()</code> 也能强制“立即（NOW）”或“延迟（LAZY）”解析，但“延迟”只适用于函数。</p>
</blockquote>
<p>大多数系统&#x2F;构建默认<strong>启用</strong>懒绑定（除非显式要求“立即绑定”）。可以用<strong>环境变量</strong> <code>LD_BIND_NOW=1</code> 或链接选项 <strong><code>-Wl,-z,now</code></strong> 禁用懒绑定，改为<strong>装载时就解析全部外部函数</strong>。</p>
<p><strong>与 RELRO 的关系</strong>：</p>
<ul>
<li><p><strong>Partial RELRO</strong>：仅将一部分动态链接数据区标记为只读，<strong>保留 <code>.got.plt</code> 可写</strong>以支持懒绑定。</p>
</li>
<li><p><strong>Full RELRO</strong>：要求在进入 <code>main</code> 前<strong>全部解析函数符号</strong>并把 <strong>GOT（含 <code>.got.plt</code>）设为只读</strong>，这就<strong>事实上禁用了延迟绑定</strong>（等价于 <code>-z now</code>）。代价是启动时多做一点工作，换来运行期更强的防篡改性。</p>
<blockquote>
<p>当然特殊情况也有在开启 FULL RELRO 的时候进行重定位，比如 ret2dlresolve 。</p>
</blockquote>
</li>
</ul>
<p>我们以调用 <code>puts</code> 函数为例讲解一下延迟绑定的过程。</p>
<p>首先第一次调用 <code>puts</code> 时由于 <code>puts@got</code> 没有进行重定位，因此会调用 <code>_dl_runtime_resolve</code> 函数进行重定位，<code>_dl_runtime_resolve</code> 函数将查找到的 <code>puts</code> 函数地址填写到 <code>puts@got</code> 后会调用 <code>puts</code> 函数。</p>
<p>**第一次调用 <code>puts</code>**（尚未解析）：</p>
<ol>
<li><p>调用点发出 <code>call puts@PLT</code>，跳到该函数的 <strong>PLT 入口</strong>（每个外部函数有自己的 <code>pltN</code>）。</p>
</li>
<li><p>进入 <code>puts@plt</code> 后（典型两段式）：</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; --- 通用 PLT0 桩 ---</span></span><br><span class="line"><span class="symbol">plt0:</span></span><br><span class="line">    <span class="keyword">push</span>    <span class="built_in">qword</span> <span class="built_in">ptr</span> [<span class="built_in">rip</span> + .got<span class="number">.</span>plt + <span class="number">8</span>]  <span class="comment">; = .got.plt[1] =&gt; link_map</span></span><br><span class="line">    <span class="keyword">jmp</span>     <span class="built_in">qword</span> <span class="built_in">ptr</span> [<span class="built_in">rip</span> + .got<span class="number">.</span>plt + <span class="number">16</span>] <span class="comment">; = .got.plt[2] =&gt; 解析器入口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; --- 单个函数的专属 PLT 桩（俗称 pltN）---</span></span><br><span class="line"><span class="comment">; label: puts@plt</span></span><br><span class="line"><span class="symbol">puts@plt:</span></span><br><span class="line">    <span class="keyword">jmp</span>     <span class="built_in">qword</span> <span class="built_in">ptr</span> [<span class="built_in">rip</span> + puts@GOTPLT]   <span class="comment">; 已解析：直接跳真实 puts</span></span><br><span class="line">    <span class="keyword">push</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> idx_puts              <span class="comment">; 首调：压入 .rela.plt 的表项序号</span></span><br><span class="line">    <span class="keyword">jmp</span>     plt0                            <span class="comment">; 进入通用桩</span></span><br></pre></td></tr></table></figure></div>

<p>由于 <code>puts@GOTPLT</code> 被初始化成<strong>指回本桩的第二条指令</strong>（也可理解为“一个 PLT 局部小跳板”）。因此第 ① 步<strong>并不会</strong>离开本桩，而是<strong>落到</strong>后面的 <code>push $idx</code>。这个 <strong><code>idx</code></strong> 就是该函数在 <strong><code>.rela.plt</code></strong> 里的<strong>表项序号</strong>。</p>
</li>
<li><p><strong>PLT0</strong> 从 GOT 中取到当前模块的 <code>link_map</code>，再跳转到运行时解析器（<code>dl_runtime_resolve</code> 族）入口。</p>
<blockquote>
<p><strong>.got.plt</strong>（函数用 GOT）前 <strong>3 个条目</strong>是保留位，后续每个条目对应一个可延迟解析的<strong>函数</strong>。</p>
<ul>
<li><p><strong><code>.got.plt[0]</code> → <code>_DYNAMIC</code> 的链接时地址</strong><br>给动态链接器（ld.so）做“自举&#x2F;定位”的锚点：它能让 ld.so 通过 <code>_DYNAMIC</code> 找到该对象的 <strong><code>.dynamic</code> 段</strong>，进而读到 <code>DT_PLTGOT</code>、<code>DT_JMPREL</code>、<code>DT_SYMTAB</code>、<code>DT_STRTAB</code> 等指针，用来完成 PLT&#x2F;GOT 的修补、符号解析等工作。这个槽<strong>不直接参与</strong>一次函数调用的跳转，但对装载期和解析期的元数据定位很重要。</p>
</li>
<li><p><strong><code>.got.plt[1]</code> → 当前对象的“描述符”（<code>link_map</code> 指针）</strong><br>这是传给解析桩的<strong>第一个参数</strong>。首调时，PLT 桩会把 <code>.got.plt[1]</code> 压栈&#x2F;放寄存器，ld.so 由此拿到当前 ELF 对象的 **<code>link_map</code>**，再根据 <code>link_map-&gt;l_info[DT_*]</code> 找到 <code>.rela.plt/.rel.plt</code>、<code>.dynsym</code>、<code>.dynstr</code> 等表去解析符号、写回真实地址。</p>
</li>
<li><p><strong><code>.got.plt[2]</code> → 解析器入口（resolver trampoline）</strong><br>这是 PLT0 要 <strong><code>jmp</code></strong> 去的目标（也就是 <code>_dl_runtime_resolve</code> 的汇编桩入口；在 glibc 上常见别名如 <code>_dl_runtime_resolve_xsave[_c]</code>）。PLT0 把上一步准备好的参数（<code>link_map</code> + 重定位索引）“交给”这个解析桩，解析桩再调用 C 例程 <code>_dl_fixup</code> 完成 <strong><code>R_X86_64_JUMP_SLOT</code></strong> 的解析与<strong>回填 <code>.got.plt[n]</code><strong>，并</strong>尾调用</strong>到真实函数。</p>
</li>
</ul>
</blockquote>
</li>
<li><p>解析器依据 <code>link_map</code> 查 <code>.dynsym/.dynstr</code> 和 **<code>.rela.plt</code>**（注意：x86‑64 使用 <strong><code>Elf64_Rela</code><strong>，即 <strong>RELA</strong> 形式），通过重定位条目的 <code>r_info</code> 找到目标符号，按动态链接的搜索顺序解析出</strong>真实地址</strong>。</p>
</li>
<li><p>解析器把真实地址<strong>写回</strong>该函数的 <strong>GOT 槽（<code>.got.plt</code> 的对应项）</strong>，随后<strong>跳转</strong>到 <code>puts</code> 真身继续执行。</p>
</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux%20user%20pwn%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/images/image-20241108004319385.png"
                      alt="image-20241108004319385"
                ></p>
<p><strong>再次调用 <code>puts</code><strong>，<code>puts@PLT</code> 直接从 <strong><code>puts@GOTPLT</code></strong> 读取</strong>已解析好的函数地址</strong>并跳转，<strong>不再进入解析器</strong>，因此热路径只有一次间接跳转开销。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux%20user%20pwn%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/images/image-20241108004343509.png"
                      alt="image-20241108004343509"
                ><br>其中在第一次调用 <code>puts</code> 函数时调用的 <code>_dl_runtime_resolve</code> 函数的具体实现为：</p>
<ul>
<li>用第一个参数 <code>link_map</code> 访问 <code>.dynamic</code> ，取出 <code>.dynstr</code> ， <code>.dynsym</code> ， <code>.rel.plt</code> 的指针。</li>
<li><code>.rel.plt + 第二个参数</code> 求出当前函数的重定位表项 <code>Elf32_Rel</code> 的指针，记作 <code>rel</code> 。</li>
<li><code>rel-&gt;r_info &gt;&gt; 8</code> 作为 <code>.dynsym</code> 的下标，求出当前函数的符号表项 <code>Elf32_Sym</code> 的指针，记作 <code>sym</code> 。</li>
<li><code>.dynstr + sym-&gt;st_name</code> 得出符号名字符串指针。</li>
<li>在动态链接库查找这个函数的地址，并且把地址赋值给 <code>*rel-&gt;r_offset</code> ，即 GOT 表。</li>
<li>调用这个函数。</li>
</ul>
<blockquote>
<p>把 <code>puts@GOTPLT</code> 改成指向 <strong><code>printf@plt</code> 的第二条指令</strong>（也就是它的 <code>push idx_printf</code>）：</p>
<ol>
<li>调用 <code>puts@PLT</code> → 第一条 <code>jmp [rip+puts@GOTPLT]</code> 会<strong>跳到 <code>printf@plt</code> 的 fallback</strong>。</li>
<li><code>printf@plt</code> 的 fallback 会 <code>push idx_printf; jmp plt0</code>，于是解析器拿到的 <strong><code>idx</code> 是 <code>printf</code> 的</strong>。</li>
<li><code>_dl_fixup</code> 解析 <strong><code>printf</code><strong>，并把</strong>真实 <code>printf</code> 地址写回</strong> <code>.rela.plt[idx_printf].r_offset</code> 指向的槽（即 **<code>printf@GOTPLT</code><strong>）——</strong>不是 <code>puts@GOTPLT</code>**。</li>
<li>你的 <code>puts@GOTPLT</code> 仍然指向 <code>printf@plt</code> 的 fallback；以后每次 <code>puts@PLT</code> 都会“借道 printf 的 fallback”，解析器会很快认出已解析过，再尾调用真实 <code>printf</code>。</li>
</ol>
<p><strong>结论</strong>：这种劫持让 <code>puts()</code> 实际上调用了 <code>printf()</code>，且解析器<strong>修改的是 <code>printf</code> 的 GOT 槽</strong>，与“你最初跳出来的那个 GOT 槽”无关。</p>
</blockquote>
<h2 id="main-函数之外的启动-退出流程"><a href="#main-函数之外的启动-退出流程" class="headerlink" title="main 函数之外的启动 &#x2F; 退出流程"></a>main 函数之外的启动 &#x2F; 退出流程</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux%20user%20pwn%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/images/image-20241108004754680.png"
                      alt="image-20241108004754680"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux%20user%20pwn%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/images/image-20241108004734754.png"
                      alt="image-20241108004734754"
                ></p>
<h3 id="入口-start"><a href="#入口-start" class="headerlink" title="入口 _start"></a>入口 <code>_start</code></h3><p><em>对静态可执行文件</em>，入口就是你编译出来的 <code>_start</code>。<br><em>对动态可执行文件</em>，入口其实是 **动态链接器的 <code>_start</code>**（<code>ld-linux*.so</code> 里的 <code>_dl_start</code> &#x2F; <code>_dl_start_user</code>），它先完成自身装载、重定位，再跳进程序的 <code>_start</code>。</p>
<p><code>_start</code> 通常来自 glibc 提供的 <code>crt1.o</code>，是 ELF 的真正入口。它主要做三件事：</p>
<ol>
<li><p>从当前栈布局里取出 **<code>argc</code>、<code>argv</code>、<code>envp</code>**；</p>
</li>
<li><p>按 System V ABI 要求<strong>对齐栈</strong>（x86‑64 要求 16 字节对齐）；</p>
</li>
<li><p>把 <code>main</code>、<code>argc/argv</code>、构造&#x2F;析构函数入口等打包好，调用：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__libc_start_main(main, argc, argv, init, fini, rtld_fini, stack_end);</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p>x86‑64 的 <code>_start</code> 伪代码大致是：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_start:</span><br><span class="line">    ; 内核保证 %rsp 指向 argc</span><br><span class="line">    xor    %rbp, %rbp           ; 最外层调用栈 frame pointer = 0</span><br><span class="line">    pop    %rdi                 ; rdi = argc</span><br><span class="line">    mov    %rsp, %rsi           ; rsi = argv</span><br><span class="line">    and    $-16, %rsp           ; 栈 16 字节对齐</span><br><span class="line">    push   %rax                 ; 作为 stack_end（高地址）</span><br><span class="line">    push   %rsp                 ; 再次保存对齐后的栈顶（旧实现略有差异）</span><br><span class="line">    mov    $__libc_csu_fini, %rdx</span><br><span class="line">    mov    $__libc_csu_init, %rcx</span><br><span class="line">    mov    $main, %r8           ; 以及其它参数</span><br><span class="line">    call   __libc_start_main</span><br><span class="line">    hlt                          ; 若返回则 hlt/陷入</span><br></pre></td></tr></table></figure></div>

<h3 id="libc-start-main-初始化-调-main"><a href="#libc-start-main-初始化-调-main" class="headerlink" title="__libc_start_main 初始化 + 调 main"></a><code>__libc_start_main</code> 初始化 + 调 main</h3><p>在 glibc 的 <code>csu/libc-start.c</code> 里，<code>__libc_start_main</code>（或内部别名 <code>generic_start_main</code>）大致长这样：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LIBC_START_MAIN</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> (*main) (<span class="type">int</span>, <span class="type">char</span> **, <span class="type">char</span> **),</span></span><br><span class="line"><span class="params">    <span class="type">int</span> argc, <span class="type">char</span> **ubp_av,</span></span><br><span class="line"><span class="params">    <span class="type">void</span> (*init) (<span class="type">int</span>, <span class="type">char</span> **, <span class="type">char</span> **),</span></span><br><span class="line"><span class="params">    <span class="type">void</span> (*fini) (<span class="type">void</span>),</span></span><br><span class="line"><span class="params">    <span class="type">void</span> (*rtld_fini) (<span class="type">void</span>),</span></span><br><span class="line"><span class="params">    <span class="type">void</span> *stack_end   <span class="comment">/* 来自 _start 记录的栈顶 */</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>ubp_av</code> 实际上就是 <code>argv</code>，后面紧跟 <code>envp</code> 和 <code>auxv</code> 等；</li>
<li><code>init</code>、<code>fini</code> 通常是 <code>__libc_csu_init</code> &#x2F; <code>__libc_csu_fini</code>；</li>
<li><code>rtld_fini</code> 对动态程序是 <code>_dl_fini</code>，对静态程序为 <code>NULL</code>。</li>
</ul>
<p>LSB 规范对 <code>__libc_start_main()</code> 的概述是：</p>
<blockquote>
<p>“完成必要的运行环境初始化，调用 <code>main</code>，并在 <code>main</code> 返回后调用 <code>exit</code>。”</p>
</blockquote>
<p><code>__libc_start_main</code> 在不同版本 glibc 实现细节略有出入，但核心套路非常稳定：</p>
<ol>
<li><p><strong>保存 argc&#x2F;argv&#x2F;envp：</strong></p>
<ul>
<li>解析 <code>ubp_av</code>，得到 <code>argc</code>、<code>argv</code>、<code>envp</code>；</li>
<li>设置全局 <code>__environ = envp</code>。</li>
</ul>
</li>
<li><p><strong>处理 AUXV（辅助向量）：</strong></p>
<ul>
<li>从栈上的 auxv 读取 <code>AT_PHDR</code> &#x2F; <code>AT_PHENT</code> &#x2F; <code>AT_PHNUM</code>、<code>AT_ENTRY</code>、<code>AT_BASE</code>、<code>AT_PAGESZ</code> 等；</li>
<li>对应字段保存在内部全局，例如 <code>dl_phdr</code>、<code>dl_phnum</code>，作为后续 TLS &#x2F; 安全机制 &#x2F; 堆栈检查等的输入。</li>
</ul>
</li>
<li><p><strong>安全&#x2F;环境相关初始化：</strong></p>
<ul>
<li>基于 <code>geteuid/getuid</code>、<code>getegid/getgid</code> 设置 <code>_libc_enable_secure</code>（判断是否 setuid&#x2F;setgid）；</li>
<li>初始化 <code>__stack_chk_guard</code>、<code>pointer_guard</code> 等保护值，用于栈溢出检测和函数指针混淆（PTR_MANGLE&#x2F;DEMANGLE）。</li>
</ul>
</li>
<li><p><strong>CPU &#x2F; TLS &#x2F; 线程等底层初始化：</strong></p>
<ul>
<li><code>ARCH_INIT_CPU_FEATURES</code>：探测 CPU 指令集能力（SSE&#x2F;AVX 等）并缓存到 <code>*_cpu_features</code>；</li>
<li><code>__libc_setup_tls()</code>：搭 TLS 模板，初始化 TLS 相关数据；</li>
<li><code>__pthread_initialize_minimal()</code>：初始化极简线程环境，为后面的 pthread 函数调用铺路。</li>
</ul>
</li>
<li><p><strong>注册退出回调：</strong></p>
<ul>
<li>如果 <code>rtld_fini != NULL</code>（动态链接程序），调用 <code>__cxa_atexit(rtld_fini, ...)</code> 注册成退出时的回调（典型就是 <code>_dl_fini</code>）；</li>
<li>后面还会把 <code>fini</code>（<code>__libc_csu_fini</code>）通过 <code>__cxa_atexit</code> 注册为退出回调——这些最终都会在 <code>exit()</code> 路径里被 <code>__run_exit_handlers</code> 调用。</li>
</ul>
</li>
<li><p><strong>调用 <code>init</code>（通常是 <code>__libc_csu_init</code>）：</strong></p>
<ul>
<li>负责调用 <code>.preinit_array</code> &#x2F; <code>_init</code> &#x2F; <code>.init_array</code> 里的构造函数。</li>
</ul>
</li>
<li><p><strong>调用 <code>main</code> 并处理返回：</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> result = main(argc, argv, envp);</span><br><span class="line"><span class="built_in">exit</span>(result);</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>exit</code> 最终会进入 <code>__run_exit_handlers()</code>。</li>
</ul>
</li>
</ol>
<h3 id="libc-csu-init-构造函数调用"><a href="#libc-csu-init-构造函数调用" class="headerlink" title="__libc_csu_init 构造函数调用"></a><code>__libc_csu_init</code> 构造函数调用</h3><p><code>__libc_csu_init</code> 实现位于 glibc <code>csu/elf-init.c</code>，大致逻辑是：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __libc_csu_init (<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LIBC_NONSHARED</span></span><br><span class="line">  <span class="comment">/* 对静态链接程序，.preinit_array 由 libc 自己负责调用；</span></span><br><span class="line"><span class="comment">     动态链接程序时，通常由动态链接器处理一部分。 */</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">size_t</span> size = __preinit_array_end - __preinit_array_start;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">      __preinit_array_start[i](argc, argv, envp);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NO_INITFINI</span></span><br><span class="line">  _init();  <span class="comment">/* .init 段里的函数，一般是编译器生成的 _init */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> size = __init_array_end - __init_array_start;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">    __init_array_start[i](argc, argv, envp);  <span class="comment">/* 调构造函数数组 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因此构造函数调用顺序为：</p>
<ol>
<li><code>.preinit_array</code>（静态程序为主）；</li>
<li><code>.init</code>（通常是 <code>_init</code>）；</li>
<li><code>.init_array</code>（C++ 静态对象构造函数等）。</li>
</ol>
<h3 id="退出路径：exit"><a href="#退出路径：exit" class="headerlink" title="退出路径：exit"></a>退出路径：<code>exit</code></h3><p><code>exit</code> 定义在 glibc 的 <code>stdlib/exit.c</code> 里，大致长这样（删掉了一堆属性宏和弱符号）：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span> <span class="params">(<span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">  __run_exit_handlers (status, &amp;__exit_funcs, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>也就是说：</p>
<blockquote>
<p><strong><code>exit()</code> 自己什么都不做，直接把活交给 <code>__run_exit_handlers</code>，最后由后者调用 <code>_exit</code> 真正终止进程。</strong></p>
</blockquote>
<p><code>__run_exit_handlers()</code> 核心函数在 <code>stdlib/exit.c</code> 中：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__run_exit_handlers (<span class="type">int</span> status,</span><br><span class="line">                     <span class="keyword">struct</span> exit_function_list **listp,</span><br><span class="line">                     <span class="type">bool</span> run_list_atexit,</span><br><span class="line">                     <span class="type">bool</span> run_dtors)</span><br></pre></td></tr></table></figure></div>

<p>主要做：</p>
<ol>
<li><p>调 TLS 析构函数（线程本地析构链）；</p>
</li>
<li><p>走一遍 <code>__exit_funcs</code> 链表，按注册顺序反向调用：</p>
<ul>
<li><code>on_exit()</code> 注册的回调；</li>
<li><code>atexit()</code> 注册的回调；</li>
<li><code>__cxa_atexit()</code> 注册的 C++ 析构函数（包括 <code>_dl_fini</code>、<code>__libc_csu_fini</code> 等）；</li>
</ul>
</li>
<li><p>在新版本中，通过弱符号调用 <code>_IO_cleanup</code>（即 FSOP 中常见的那个点）；</p>
</li>
<li><p>最后调用 <code>_exit(status)</code>，直接陷入内核终止进程（<code>_exit</code> 是系统调用封装，并不是你原文里的“<code>status &amp;= 0xff; abort()</code> 那种伪代码）。</p>
</li>
</ol>
<blockquote>
<ul>
<li><p><strong><code>exit(int status)</code><strong>：</strong>C 标准库函数</strong>（声明在 <code>&lt;stdlib.h&gt;</code>）<br>➜ 做“正常退出”：调用各种析构函数 &#x2F; <code>atexit</code> 回调、刷新 stdio 缓冲区、做库级清理，最后再调用 <code>_exit</code>。</p>
</li>
<li><p><strong><code>_exit(int status)</code><strong>：</strong>POSIX 系统调用封装</strong>（声明在 <code>&lt;unistd.h&gt;</code>）<br>➜ 直接让内核结束进程，不跑 C 库的清理逻辑，不调用 <code>atexit</code>、不刷新 stdio 缓冲、也不跑 C++ 析构这类用户态收尾。</p>
</li>
</ul>
<p>GNU libc 手册直接说得很白：</p>
<blockquote>
<p><code>_exit</code> 是 <code>exit</code> 用来终止进程的原始原语；它不会调用 <code>atexit</code> &#x2F; <code>on_exit</code> 的回调。</p>
</blockquote>
<p>所以 <code>exit()</code> &#x3D; “**先跑所有用户态清理，再调用 <code>_exit</code>**”。</p>
</blockquote>
<h4 id="TLS-析构链：-call-tls-dtors-tls-dtor-list"><a href="#TLS-析构链：-call-tls-dtors-tls-dtor-list" class="headerlink" title="TLS 析构链：__call_tls_dtors + tls_dtor_list"></a>TLS 析构链：<code>__call_tls_dtors</code> + <code>tls_dtor_list</code></h4><p>在 <code>__run_exit_handlers()</code> 一开始（且 <code>run_dtors == true</code>），会调用 TLS 析构链：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (run_dtors)</span><br><span class="line">  call_function_static_weak (__call_tls_dtors);</span><br></pre></td></tr></table></figure></div>

<p><code>__call_tls_dtors</code> 实现位于 <code>libc/cxa_thread_atexit_impl.c</code>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*dtor_func)</span><span class="params">(<span class="type">void</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> &#123;</span></span><br><span class="line">  dtor_func func;        <span class="comment">// 析构函数指针</span></span><br><span class="line">  <span class="type">void</span> *obj;             <span class="comment">// 传给析构函数的参数</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">map</span>;</span>  <span class="comment">// 所属模块，对应共享库</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread <span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> *<span class="title">tls_dtor_list</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line">__call_tls_dtors (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (tls_dtor_list != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> *<span class="title">cur</span> =</span> tls_dtor_list;</span><br><span class="line">    dtor_func func = cur-&gt;func;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">    PTR_DEMANGLE (func);  <span class="comment">// 用 pointer_guard 对函数指针做解混淆</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    tls_dtor_list = cur-&gt;next;</span><br><span class="line"></span><br><span class="line">    func (cur-&gt;obj);      <span class="comment">// 调用析构函数</span></span><br><span class="line">    atomic_fetch_add_release (&amp;cur-&gt;<span class="built_in">map</span>-&gt;l_tls_dtor_count, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span> (cur);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>要点：</p>
<ul>
<li><code>tls_dtor_list</code> 是 <strong>线程局部变量（<code>__thread</code>）</strong>，每个线程有一条析构链；</li>
<li><code>func</code> 经过 <code>PTR_DEMANGLE</code> 解密，混淆密钥来自 <code>pointer_guard</code>（通常在 TLS&#x2F;TCB 中）；</li>
<li>每个节点销毁后 <code>free</code> 掉，且减少对应 <code>link_map-&gt;l_tls_dtor_count</code>。</li>
</ul>
<p>想用 TLS dtor 劫持控制流，需要：</p>
<ol>
<li>能伪造一条 <code>tls_dtor_list</code>（可控 <code>func</code> &#x2F; <code>obj</code> &#x2F; <code>next</code>）；</li>
<li>且能泄露 <code>pointer_guard</code>，绕过 <code>PTR_DEMANGLE</code>。</li>
</ol>
<p>这是一些 TLS‑dtor 利用中常用的路径。</p>
<h4 id="exit-funcs：atexit-on-exit-cxa-atexit"><a href="#exit-funcs：atexit-on-exit-cxa-atexit" class="headerlink" title="__exit_funcs：atexit&#x2F;on_exit&#x2F;__cxa_atexit"></a><code>__exit_funcs</code>：atexit&#x2F;on_exit&#x2F;__cxa_atexit</h4><p><code>__run_exit_handlers</code> 的主体循环维护一个 <code>exit_function_list</code> 链表，结构在 <code>stdlib/exit.c</code> 附近定义：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> &#123;</span></span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> flavor;   <span class="comment">// 函数种类：ef_at / ef_on / ef_cxa ...</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> (*at)(<span class="type">void</span>);           <span class="comment">// atexit</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      <span class="type">void</span> (*fn)(<span class="type">int</span>, <span class="type">void</span> *);</span><br><span class="line">      <span class="type">void</span> *arg;</span><br><span class="line">    &#125; on;                       <span class="comment">// on_exit</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      <span class="type">void</span> (*fn)(<span class="type">void</span> *, <span class="type">int</span>);</span><br><span class="line">      <span class="type">void</span> *arg;</span><br><span class="line">      <span class="type">void</span> *dso_handle;</span><br><span class="line">    &#125; cxa;                      <span class="comment">// __cxa_atexit</span></span><br><span class="line">  &#125; func;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="type">size_t</span> idx;                  <span class="comment">// 当前已使用的 fns 数量</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> <span class="title">fns</span>[32];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><code>__run_exit_handlers</code> 会：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (*listp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">cur</span> =</span> *listp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (cur-&gt;idx &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *<span class="title">f</span> =</span> &amp;cur-&gt;fns[--cur-&gt;idx];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (f-&gt;flavor) &#123;</span><br><span class="line">      <span class="keyword">case</span> ef_free:</span><br><span class="line">      <span class="keyword">case</span> ef_us:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> ef_on: &#123;</span><br><span class="line">        <span class="type">void</span> (*onfct)(<span class="type">int</span>, <span class="type">void</span> *) = f-&gt;func.on.fn;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">        PTR_DEMANGLE(onfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        onfct(status, f-&gt;func.on.arg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> ef_at: &#123;</span><br><span class="line">        <span class="type">void</span> (*atfct)(<span class="type">void</span>) = f-&gt;func.at;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">        PTR_DEMANGLE(atfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        atfct();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> ef_cxa: &#123;</span><br><span class="line">        <span class="type">void</span> (*cxafct)(<span class="type">void</span> *, <span class="type">int</span>) = f-&gt;func.cxa.fn;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">        PTR_DEMANGLE(cxafct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        cxafct(f-&gt;func.cxa.arg, status);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *listp = cur-&gt;next;</span><br><span class="line">  <span class="keyword">if</span> (*listp != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">free</span>(cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li><p>从最后一个 <code>exit_function_list</code> 开始，倒序遍历 <code>fns[--idx]</code>；</p>
</li>
<li><p>根据 <code>flavor</code> 决定调用：</p>
<ul>
<li><code>ef_on</code>：<code>func.on.fn(status, arg)</code>（对应 <code>on_exit</code>）；</li>
<li><code>ef_at</code>：<code>func.at()</code>（对应 <code>atexit</code>）；</li>
<li><code>ef_cxa</code>：<code>func.cxa.fn(arg, status)</code>（对应 <code>__cxa_atexit</code>，也会被标记成 <code>ef_free</code> 防止重复调用）；</li>
</ul>
</li>
<li><p>调用前会用 <code>PTR_DEMANGLE</code> 对函数指针做一次解混淆；</p>
</li>
<li><p>遍历完一个节点后，移动到 <code>listp = cur-&gt;next</code>，并释放旧节点（最后一个静态节点不会 free）。</p>
</li>
</ol>
<p>要点：</p>
<ul>
<li>所有用户通过 <code>atexit</code>、<code>on_exit</code>、<code>__cxa_atexit</code> 注册的函数，最终都挂在这个链表上；</li>
<li>每个 <code>exit_function_list</code> 里有 32 个槽，填满后再链入一个新节点；</li>
<li>调用顺序：<strong>后注册的先调用（栈式 LIFO）</strong>；</li>
<li>调用前，同样用 <code>PTR_DEMANGLE</code> 对函数指针解混淆。</li>
</ul>
<p>如果你能：</p>
<ul>
<li>泄露 <code>pointer_guard</code>（绕过 <code>PTR_DEMANGLE</code>），并且</li>
<li>写入 <code>exit_function_list.fns[]</code> 中的函数指针 &#x2F; 参数，</li>
</ul>
<p>就可以在正常 <code>exit()</code> 路径上拿到一个可控的 call 机会。很多人把 <code>_dl_fini</code>、<code>__libc_csu_fini</code> 这类系统级 handler 也统称为 “exit hook”（广义）。</p>
<h4 id="动态程序的-dl-fini"><a href="#动态程序的-dl-fini" class="headerlink" title="动态程序的 _dl_fini"></a>动态程序的 <code>_dl_fini</code></h4><p>对于 <strong>动态链接程序（动态 libc + ld-linux.so）</strong> 来说，<code>__run_exit_handlers</code> 还会在合适的时机调用 <strong>动态链接器</strong> 的 <code>_dl_fini()</code>：它同样是通过 <code>__cxa_atexit</code> 在 ld.so 启动阶段注册进去的。</p>
<blockquote>
<p><strong>动态链接程序的 <code>_dl_fini</code> 是怎么挂进来的？</strong></p>
<p>在进程启动时，<code>__libc_start_main</code> 会把一些“需要在 exit 时调用的函数”通过 <code>__cxa_atexit</code> 注册到 <code>__exit_funcs</code> 里，其中对动态程序来说，**<code>rtld_fini</code> 就是动态链接器的 <code>_dl_fini</code>**：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* csu/libc-start.c，伪代码简化 */</span></span><br><span class="line"><span class="keyword">if</span> (rtld_fini != <span class="literal">NULL</span>)</span><br><span class="line">  __cxa_atexit ((<span class="type">void</span> (*)(<span class="type">void</span> *)) rtld_fini, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对动态链接程序：rtld_fini == &amp;_dl_fini */</span></span><br><span class="line"><span class="comment">/* 对纯静态程序：rtld_fini == NULL */</span></span><br></pre></td></tr></table></figure></div>

<p>于是当你 <code>exit()</code> 时，<code>__run_exit_handlers</code> 会在一堆 exit handler 里 **调用 <code>_dl_fini()</code>**，进入动态链接器的清理逻辑。这就是为什么 <code>_dl_fini</code> 处在“正常退出路径”上。</p>
</blockquote>
<p><code>_dl_fini</code> 定义在 <code>elf/dl-fini.c</code>，简化后大致逻辑：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略了有关 SHARED 的处理逻辑</span></span><br><span class="line"><span class="type">void</span> internal_function</span><br><span class="line">_dl_fini (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (Lmid_t ns = GL (dl_nns) - <span class="number">1</span>; ns &gt;= <span class="number">0</span>; --ns) &#123;</span><br><span class="line">        <span class="comment">/* 加锁：dl_load_lock 是动态链接器的全局加载锁 */</span></span><br><span class="line">        __rtld_lock_lock_recursive (GL (dl_load_lock));</span><br><span class="line"></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> nloaded = GL (dl_ns)[ns]._ns_nloaded;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nloaded == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* 该命名空间没有已加载的模块，解锁后处理下一个命名空间 */</span></span><br><span class="line">            __rtld_lock_unlock_recursive (GL (dl_load_lock));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 临时数组，用来保存需要执行 fini 的 link_map 指针 */</span></span><br><span class="line">            <span class="keyword">struct</span> link_map *maps[nloaded];</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 如果 _ns_nloaded 为 0，那么 _ns_loaded 必须为 NULL */</span></span><br><span class="line">            assert (nloaded != <span class="number">0</span> || GL (dl_ns)[ns]._ns_loaded == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 遍历 _ns_loaded 链表，把“真实模块”放入 maps[] 数组中 */</span></span><br><span class="line">            <span class="keyword">for</span> (l = GL (dl_ns)[ns]._ns_loaded, i = <span class="number">0</span>;</span><br><span class="line">                 l != <span class="literal">NULL</span>;</span><br><span class="line">                 l = l-&gt;l_next) &#123;</span><br><span class="line">                <span class="comment">// 只处理 l == l-&gt;l_real 的节点（跳过 alias / fake 节点）</span></span><br><span class="line">                <span class="keyword">if</span> (l == l-&gt;l_real) &#123;</span><br><span class="line">                    assert (i &lt; nloaded);</span><br><span class="line">                    maps[i] = l;            <span class="comment">// 保存到临时数组</span></span><br><span class="line">                    l-&gt;l_idx = i;          <span class="comment">// 记录在数组中的索引</span></span><br><span class="line">                    ++i;</span><br><span class="line">                    ++l-&gt;l_direct_opencount; <span class="comment">// 增加直接引用计数，避免并发 dlclose 造成竞态</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 基本命名空间（LM_ID_BASE）要求 i == nloaded */</span></span><br><span class="line">            assert (ns != LM_ID_BASE || i == nloaded);</span><br><span class="line">            <span class="comment">/* 其他命名空间允许少 1 个（vDSO 之类的特殊情况） */</span></span><br><span class="line">            assert (ns == LM_ID_BASE || i == nloaded || i == nloaded - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 此时 ns 命名空间中至少有若干个 link_map 节点</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> nmaps = i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 按依赖关系排序，保证析构顺序正确（依赖方先析构） */</span></span><br><span class="line">            _dl_sort_fini (maps, nmaps, <span class="literal">NULL</span>, ns);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 排序结束后释放加载锁，实际调用 fini 时不再持有锁 */</span></span><br><span class="line">            __rtld_lock_unlock_recursive (GL (dl_load_lock));</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 按排序后的顺序遍历每个 link_map，执行它们的析构函数 */</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nmaps; ++i) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span> =</span> maps[i];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 只对曾调用过 init 的模块执行 fini</span></span><br><span class="line">                <span class="keyword">if</span> (l-&gt;l_init_called) &#123;</span><br><span class="line">                    l-&gt;l_init_called = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span></span><br><span class="line">                        || l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* 若开启 DL_DEBUG_IMPCALLS，打印正在调用的 fini 模块名 */</span></span><br><span class="line">                        <span class="keyword">if</span> (__builtin_expect (GLRO (dl_debug_mask)</span><br><span class="line">                                              &amp; DL_DEBUG_IMPCALLS, <span class="number">0</span>))</span><br><span class="line">                            _dl_debug_printf (<span class="string">&quot;\ncalling fini: %s [%lu]\n\n&quot;</span>,</span><br><span class="line">                                              DSO_FILENAME (l-&gt;l_name), ns);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* 先处理 DT_FINI_ARRAY（.fini_array）：逆序调用数组中的函数 */</span></span><br><span class="line">                        <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                            ElfW (Addr) *<span class="built_in">array</span> =</span><br><span class="line">                                (ElfW (Addr) *) (l-&gt;l_addr</span><br><span class="line">                                                 + l-&gt;l_info[DT_FINI_ARRAY]</span><br><span class="line">                                                       -&gt;d_un.d_ptr);</span><br><span class="line">                            <span class="type">unsigned</span> <span class="type">int</span> j =</span><br><span class="line">                                (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span><br><span class="line">                                 / <span class="keyword">sizeof</span> (ElfW (Addr)));</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">while</span> (j-- &gt; <span class="number">0</span>)</span><br><span class="line">                                ((<span class="type">fini_t</span>) <span class="built_in">array</span>[j]) ();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* 再调用旧式的 DT_FINI（.fini 段） */</span></span><br><span class="line">                        <span class="keyword">if</span> (l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>)</span><br><span class="line">                            DL_CALL_DT_FINI (l,</span><br><span class="line">                                             l-&gt;l_addr</span><br><span class="line">                                             + l-&gt;l_info[DT_FINI]</span><br><span class="line">                                                   -&gt;d_un.d_ptr);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 完成一个模块的 fini，减少其直接引用计数 */</span></span><br><span class="line">                --l-&gt;l_direct_opencount;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><strong>只要 <code>_dl_fini</code> 被调，<code>__rtld_lock_lock_recursive</code> &#x2F; <code>__rtld_lock_unlock_recursive</code> 就一定会被执行</strong>，而且是成对调用。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* elf/dl-fini.c 片段，注释简化 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> internal_function</span><br><span class="line">_dl_fini (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (Lmid_t ns = GL(dl_nns) - <span class="number">1</span>; ns &gt;= <span class="number">0</span>; --ns)</span><br><span class="line">    &#123;</span><br><span class="line">      __rtld_lock_lock_recursive (GL (dl_load_lock));   <span class="comment">// ← 这里</span></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> nloaded = GL (dl_ns)[ns]._ns_nloaded;</span><br><span class="line">      <span class="keyword">if</span> (nloaded == <span class="number">0</span>)</span><br><span class="line">        __rtld_lock_unlock_recursive (GL (dl_load_lock)); <span class="comment">// ← 这里</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* 构造 link_map 数组、排序、依次调用各 DSO 的 FINI */</span></span><br><span class="line">          ...</span><br><span class="line">          __rtld_lock_unlock_recursive (GL (dl_load_lock));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>宏展开后分别为：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_rtld_local._dl_rtld_lock_recursive(&amp;(_rtld_local._dl_load_lock).mutex)</span><br><span class="line">_rtld_local._dl_rtld_unlock_recursive(&amp;(_rtld_local._dl_load_lock).mutex)</span><br></pre></td></tr></table></figure></div>

<p><code>_rtld_global._dl_rtld_lock_recursive</code> &#x2F; <code>_rtld_global._dl_rtld_unlock_recursive</code> 是动态链接器用来给自己“封装锁操作”的两根函数指针，位于 <code>ld.so</code> 上。如果能改这些函数指针，那么就是<strong>狭义的 exit hook</strong>。</p>
<p><code>GL(dl_ns)[ns]._ns_loaded</code> 是一个 <code>link_map</code> 链表，描述当前命名空间中加载的所有 ELF 模块（主程序、本地 .so、依赖 .so 等）；每个 <code>link_map</code> 里有：</p>
<ul>
<li><code>l_addr</code>：模块加载基址；</li>
<li><code>l_info[]</code>：所有 <code>DT_*</code> 动态段条目的指针（包括 <code>DT_FINI_ARRAY</code>、<code>DT_FINI</code> 等）；</li>
<li><code>l_next</code>：下一个模块。</li>
</ul>
<p><code>_dl_fini</code> 会按依赖排序后，对每个模块调用：</p>
<ul>
<li><code>.fini_array</code> 里的析构函数数组；</li>
<li><code>.fini</code>（老式方式）。</li>
</ul>
<p>具体过程为：按 <code>maps[0..nmaps-1]</code> 顺序调用 <code>_dl_call_fini(map)</code>，真正执行析构，<code>_dl_call_fini</code> 会根据 <code>l_info[DT_FINI_ARRAY]</code> &#x2F; <code>l_info[DT_FINI]</code> 找到 <code>.fini_array</code> 和 <code>.fini</code>，依次调用这些函数指针。</p>
<p>如果能伪造一个“假 link_map”，让 <code>_dl_fini</code> 在退出时遍历到它，就可以控制它调用哪一组 <code>fini</code>；这就是很多文章里提到的 <strong>House of Banana &#x2F; _dl_fini 利用</strong> 的大致思路。</p>
<h4 id="静态程序的-libc-csu-fini"><a href="#静态程序的-libc-csu-fini" class="headerlink" title="静态程序的 __libc_csu_fini"></a>静态程序的 <code>__libc_csu_fini</code></h4><p>完全静态链接的 ELF（<code>-static</code>），不再依赖 ld-linux.so，因此没有 <code>_dl_fini</code> 这条路径。此时：</p>
<ul>
<li>链接时传给 <code>__libc_start_main</code> 的 <code>fini</code>，是 <code>__libc_csu_fini</code>（在 <code>csu/elf-init.c</code> 一带）；</li>
<li>它会通过 <code>__cxa_atexit(fini, ...)</code> 被注册进 <code>__exit_funcs</code> 链表；</li>
<li>在 <code>exit()</code> 路径里，被当作一个普通的 <code>ef_cxa</code> slot 调用。</li>
</ul>
<p><code>__libc_csu_fini</code> 的逻辑（略化）大概是：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__libc_csu_fini (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> i = __fini_array_end - __fini_array_start;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)</span><br><span class="line">    __fini_array_start[i] ();   <span class="comment">// 逆序调用 .fini_array</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NO_INITFINI</span></span><br><span class="line">  _fini ();                     <span class="comment">// 如果存在 .fini 段，也调用</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因此对静态程序，想在正常退出路径上劫持流，常见手段是<strong>覆盖 <code>.fini_array</code> 里的函数指针</strong>（或构造 fake <code>.fini_array</code> 对应的内存）。</p>
<h4 id="libc-atexit-区段与-IO-cleanup（FSOP）"><a href="#libc-atexit-区段与-IO-cleanup（FSOP）" class="headerlink" title="__libc_atexit 区段与 _IO_cleanup（FSOP）"></a><code>__libc_atexit</code> 区段与 <code>_IO_cleanup</code>（FSOP）</h4><p>在 <code>__run_exit_handlers()</code> 的最后，如果 <code>run_list_atexit == true</code>，会执行一个额外的 hook：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* stdlib/exit.c 中的关键逻辑 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">exit</span> <span class="params">(<span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">    __run_exit_handlers (status, &amp;__exit_funcs, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">/* 不再返回 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line">__run_exit_handlers (<span class="type">int</span> status,</span><br><span class="line">                     <span class="keyword">struct</span> exit_function_list **listp,</span><br><span class="line">                     <span class="type">bool</span> run_list_atexit,</span><br><span class="line">                     <span class="type">bool</span> run_dtors)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* ... 调 TLS 析构、__exit_funcs 等 ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (run_list_atexit)</span><br><span class="line">        RUN_HOOK (__libc_atexit, ());   <span class="comment">/* 这一句非常关键 */</span></span><br><span class="line"></span><br><span class="line">    _exit (status);                     <span class="comment">/* 真正进入内核终止进程 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>RUN_HOOK</code> 宏的展开类似于：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码，实际宏用 start/stop 符号</span></span><br><span class="line"><span class="keyword">for</span> (p = &amp;__start___libc_atexit; p &lt; &amp;__stop___libc_atexit; ++p)</span><br><span class="line">  ((hook_fn)*p)();</span><br></pre></td></tr></table></figure></div>

<p>也就是：</p>
<blockquote>
<p><strong>遍历 <code>__libc_atexit</code> 段中的所有函数指针，逐个调用，直到遇到段尾。</strong></p>
</blockquote>
<p>其中一个经典条目就是 <code>_IO_cleanup</code>（定义在 <code>libio/genops.c</code>）：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* libio/genops.c 关键逻辑（简化） */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 声明一个函数，做 IO 层的统一清理 */</span></span><br><span class="line"><span class="type">void</span> _IO_cleanup (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 刷新所有流（会走 _IO_flush_all_lockp） */</span></span><br><span class="line">    _IO_flush_all_lockp (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 解除缓冲等额外清理 */</span></span><br><span class="line">    _IO_unbuffer_all ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 把 _IO_cleanup 放进 __libc_atexit 段，作为退出时的 hook */</span></span><br><span class="line">text_set_element (__libc_atexit, _IO_cleanup);</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong>动态链接程序</strong>：</p>
<pre><font color="#26A269"><b>pwndbg&gt; </b></font>u 0x7ffff7c4552c
 ► <font color="#26A269"><b>0x7ffff7c4552c</b></font> <font color="#26A269"><b>&lt;__run_exit_handlers+412&gt; </b></font>   <font color="#AFD700">lea</font><font color="#000000">    </font><font color="#5FD7FF">rbx</font><font color="#000000">, [</font><font color="#5FD7FF">rip</font><font color="#000000"> + </font><font color="#AF87FF">0x1d14c5</font><font color="#000000">]</font>     <font color="#C01C28"><b>RBX</b></font> =&gt; 0x7ffff7e169f8 (__elf_set___libc_atexit_element__IO_cleanup__) —▸ <font color="#C01C28">0x7ffff7c8eb50 (_IO_cleanup)</font> ◂— <font color="#AFD700">endbr64</font><font color="#000000"> </font>
   0x7ffff7c45533 &lt;__run_exit_handlers+419&gt;    <font color="#AFD700">lea</font><font color="#000000">    </font><font color="#5FD7FF">r12</font><font color="#000000">, [</font><font color="#5FD7FF">rip</font><font color="#000000"> + </font><font color="#AF87FF">0x1d14c6</font><font color="#000000">]</font>     <font color="#C01C28"><b>R12</b></font> =&gt; 0x7ffff7e16a00 (_IO_helper_jumps) ◂— 0
   0x7ffff7c4553a &lt;__run_exit_handlers+426&gt;    <font color="#AFD700">cmp</font><font color="#000000">    </font><font color="#5FD7FF">rbx</font><font color="#000000">, </font><font color="#5FD7FF">r12</font>
   0x7ffff7c4553d &lt;__run_exit_handlers+429&gt;    <font color="#AFD700"><b>jae</b></font><font color="#000000">    </font><font color="#C01C28">__run_exit_handlers+443</font>     &lt;<font color="#C01C28">__run_exit_handlers+443</font>&gt;

   0x7ffff7c4553f &lt;__run_exit_handlers+431&gt;    <font color="#AFD700">nop</font><font color="#000000">    </font>
   0x7ffff7c45540 &lt;__run_exit_handlers+432&gt;    <font color="#AFD700"><b>call</b></font><font color="#000000">   </font><font color="#5FD7FF">qword</font><font color="#000000"> </font><font color="#5FD7FF">ptr</font><font color="#000000"> [</font><font color="#5FD7FF">rbx</font><font color="#000000">]</font>

   0x7ffff7c45542 &lt;__run_exit_handlers+434&gt;    <font color="#AFD700">add</font><font color="#000000">    </font><font color="#5FD7FF">rbx</font><font color="#000000">, </font><font color="#AF87FF">8</font>
   0x7ffff7c45546 &lt;__run_exit_handlers+438&gt;    <font color="#AFD700">cmp</font><font color="#000000">    </font><font color="#5FD7FF">rbx</font><font color="#000000">, </font><font color="#5FD7FF">r12</font>
   0x7ffff7c45549 &lt;__run_exit_handlers+441&gt;    <font color="#AFD700"><b>jb</b></font><font color="#000000">     </font><font color="#C01C28">__run_exit_handlers+432</font>     &lt;<font color="#C01C28">__run_exit_handlers+432</font>&gt;

   0x7ffff7c4554b &lt;__run_exit_handlers+443&gt;    <font color="#AFD700">mov</font><font color="#000000">    </font><font color="#5FD7FF">edi</font><font color="#000000">, </font><font color="#5FD7FF">ebp</font>
   0x7ffff7c4554d &lt;__run_exit_handlers+445&gt;    <font color="#AFD700"><b>call</b></font><font color="#000000">   </font><font color="#C01C28">_exit</font>                       &lt;<font color="#C01C28">_exit</font>&gt;
<font color="#26A269"><b>pwndbg&gt; </b></font>telescope 0x7ffff7e169f8
00:0000│  0x7ffff7e169f8 (__elf_set___libc_atexit_element__IO_cleanup__) —▸ <font color="#C01C28">0x7ffff7c8eb50 (_IO_cleanup)</font> ◂— <font color="#AFD700">endbr64</font><font color="#000000"> </font>
01:0008│  0x7ffff7e16a00 (_IO_helper_jumps) ◂— 0
02:0010│  0x7ffff7e16a08 (_IO_helper_jumps+8) ◂— 0
03:0018│  0x7ffff7e16a10 (_IO_helper_jumps+16) —▸ <font color="#C01C28">0x7ffff7c8e730 (_IO_default_finish)</font> ◂— <font color="#AFD700">endbr64</font><font color="#000000"> </font>
04:0020│  0x7ffff7e16a18 (_IO_helper_jumps+24) —▸ <font color="#C01C28">0x7ffff7c72260 (_IO_helper_overflow)</font> ◂— <font color="#AFD700">endbr64</font><font color="#000000"> </font>
05:0028│  0x7ffff7e16a20 (_IO_helper_jumps+32) —▸ <font color="#C01C28">0x7ffff7c8dd50 (_IO_default_underflow)</font> ◂— <font color="#AFD700">endbr64</font><font color="#000000"> </font>
06:0030│  0x7ffff7e16a28 (_IO_helper_jumps+40) —▸ <font color="#C01C28">0x7ffff7c8dd60 (_IO_default_uflow)</font> ◂— <font color="#AFD700">endbr64</font><font color="#000000"> </font>
07:0038│  0x7ffff7e16a30 (_IO_helper_jumps+48) —▸ <font color="#C01C28">0x7ffff7c8f280 (_IO_default_pbackfail)</font> ◂— <font color="#AFD700">endbr64</font><font color="#000000"> </font></pre>

<ul>
<li><code>__libc_atexit</code> 段位于 <code>libc.so</code> 映像中；</li>
<li>GDB 里常见 <code>__elf_set___libc_atexit_element__IO_cleanup__</code> 这一符号指向 <code>_IO_cleanup</code>。</li>
</ul>
</li>
<li><p><strong>静态链接程序</strong>：</p>
<pre><font color="#26A269"><b>pwndbg&gt; </b></font>u 0x40aa7e 
 ► <font color="#26A269"><b>0x40aa7e</b></font> <font color="#26A269"><b>&lt;__run_exit_handlers+446&gt; </b></font>   <font color="#AFD700">mov</font><font color="#000000">    </font><font color="#5FD7FF">rbx</font><font color="#000000">, </font><font color="#A347BA">__elf_set___libc_atexit_element__IO_cleanup__</font>     <font color="#C01C28"><b>RBX</b></font> =&gt; <font color="#A347BA">0x4ca288 (__elf_set___libc_atexit_element__IO_cleanup__)</font>
   0x40aa85 &lt;__run_exit_handlers+453&gt;    <font color="#AFD700">mov</font><font color="#000000">    </font><font color="#5FD7FF">r12</font><font color="#000000">, </font><font color="#AF87FF">0x4ca290</font>                                          <font color="#C01C28"><b>R12</b></font> =&gt; <font color="#A347BA">0x4ca290</font>
   0x40aa8c &lt;__run_exit_handlers+460&gt;    <font color="#AFD700">cmp</font><font color="#000000">    </font><font color="#5FD7FF">rbx</font><font color="#000000">, </font><font color="#5FD7FF">r12</font>
   0x40aa8f &lt;__run_exit_handlers+463&gt;    <font color="#AFD700"><b>jae</b></font><font color="#000000">    </font><font color="#C01C28">__run_exit_handlers+483</font>     &lt;<font color="#C01C28">__run_exit_handlers+483</font>&gt;

   0x40aa91 &lt;__run_exit_handlers+465&gt;    <font color="#AFD700">nop</font><font color="#000000">    </font><font color="#5FD7FF">dword</font><font color="#000000"> </font><font color="#5FD7FF">ptr</font><font color="#000000"> [</font><font color="#5FD7FF">rax</font><font color="#000000">]</font>
   0x40aa98 &lt;__run_exit_handlers+472&gt;    <font color="#AFD700"><b>call</b></font><font color="#000000">   </font><font color="#5FD7FF">qword</font><font color="#000000"> </font><font color="#5FD7FF">ptr</font><font color="#000000"> [</font><font color="#5FD7FF">rbx</font><font color="#000000">]</font>

   0x40aa9a &lt;__run_exit_handlers+474&gt;    <font color="#AFD700">add</font><font color="#000000">    </font><font color="#5FD7FF">rbx</font><font color="#000000">, </font><font color="#AF87FF">8</font>
   0x40aa9e &lt;__run_exit_handlers+478&gt;    <font color="#AFD700">cmp</font><font color="#000000">    </font><font color="#5FD7FF">rbx</font><font color="#000000">, </font><font color="#5FD7FF">r12</font>
   0x40aaa1 &lt;__run_exit_handlers+481&gt;    <font color="#AFD700"><b>jb</b></font><font color="#000000">     </font><font color="#C01C28">__run_exit_handlers+472</font>     &lt;<font color="#C01C28">__run_exit_handlers+472</font>&gt;

   0x40aaa3 &lt;__run_exit_handlers+483&gt;    <font color="#AFD700">mov</font><font color="#000000">    </font><font color="#5FD7FF">edi</font><font color="#000000">, </font><font color="#5FD7FF">ebp</font>
   0x40aaa5 &lt;__run_exit_handlers+485&gt;    <font color="#AFD700"><b>call</b></font><font color="#000000">   </font><font color="#C01C28">_exit</font>                       &lt;<font color="#C01C28">_exit</font>&gt;
<font color="#26A269"><b>pwndbg&gt; </b></font>telescope 0x4ca288
00:0000│  <font color="#A347BA">0x4ca288 (__elf_set___libc_atexit_element__IO_cleanup__)</font> —▸ <font color="#C01C28">0x413450 (_IO_cleanup)</font> ◂— <font color="#AFD700">endbr64</font><font color="#000000"> </font>
01:0008│  <font color="#A347BA">0x4ca290</font> ◂— 0
... ↓     5 skipped
07:0038│  <font color="#A347BA">0x4ca2c0 (object)</font> ◂— 0xffffffffffffffff
</pre>

<ul>
<li>整个 libc 被链接进主程序，<code>__libc_atexit</code> 段是可执行文件里的一个节；</li>
<li>一样会在 <code>exit()</code> 路径上调用 <code>_IO_cleanup</code>。</li>
</ul>
</li>
</ul>
<p><code>_IO_cleanup</code> 调 <code>_IO_flush_all_lockp</code>，后者会遍历 <code>_IO_list_all</code> 链表上的所有 <code>FILE</code> 对象，并对每一个调用 vtable 中的某些函数（如 <code>__overflow</code>、<code>_IO_FILE_jumps</code> 中的函数）。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* libio/genops.c 里，关键逻辑大致如下 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="type">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">    _IO_FILE *fp;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 从 _IO_list_all 开始遍历所有 FILE */</span></span><br><span class="line">    <span class="keyword">for</span> (fp = (_IO_FILE *) _IO_list_all; fp != <span class="literal">NULL</span>; fp = fp-&gt;_chain) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 需要的话先加流级别的锁（多线程安全） */</span></span><br><span class="line">        <span class="keyword">if</span> (do_lock)</span><br><span class="line">            _IO_flockfile (fp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 以下条件判断是否需要 flush 写缓存 */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="comment">/* 流的模式不是特殊宽字符模式等 */</span></span><br><span class="line">            (fp-&gt;_mode &lt;= <span class="number">0</span> ||</span><br><span class="line">             _IO_vtable_offset (fp) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">/* 不是禁止写的流 */</span></span><br><span class="line">            &amp;&amp; (fp-&gt;_flags &amp; _IO_NO_WRITES) == <span class="number">0</span></span><br><span class="line">            <span class="comment">/* 之前没出错 */</span></span><br><span class="line">            &amp;&amp; (fp-&gt;_flags &amp; _IO_ERR_SEEN) == <span class="number">0</span></span><br><span class="line">            <span class="comment">/* 当前正在写模式 */</span></span><br><span class="line">            &amp;&amp; (fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) != <span class="number">0</span></span><br><span class="line">            <span class="comment">/* 写缓存中有数据 */</span></span><br><span class="line">            &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 关键调用：通过 vtable 调 _IO_OVERFLOW (fp, EOF) 刷新 */</span></span><br><span class="line">            <span class="keyword">if</span> (_IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">                result = EOF;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 解锁流 */</span></span><br><span class="line">        <span class="keyword">if</span> (do_lock)</span><br><span class="line">            _IO_funlockfile (fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里有几个重要点：</p>
<ol>
<li><p><strong>遍历入口</strong>：<br>从 <code>_IO_list_all</code> 开始，逐个走 <code>_chain</code> 字段：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (fp = (_IO_FILE *)_IO_list_all; fp; fp = fp-&gt;_chain) &#123; ... &#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>触发路径</strong>：<br>想要走到 <code>_IO_OVERFLOW(fp, EOF)</code>，需要满足一系列 flag &#x2F; 指针条件：</p>
<ul>
<li><code>_flags</code> 没有 <code>_IO_NO_WRITES</code> &#x2F; <code>_IO_ERR_SEEN</code>；</li>
<li><code>_flags</code> 包含 <code>_IO_CURRENTLY_PUTTING</code>（说明是输出模式）；</li>
<li><code>_IO_write_ptr &gt; _IO_write_base</code>（说明缓冲区里“看起来有待写的数据”）。</li>
</ul>
<p>这些值在 FSOP 里一般<strong>由你伪造 FILE 时手动布置</strong>。</p>
</li>
<li><p>**关键调用 <code>_IO_OVERFLOW</code>**：</p>
<p><code>_IO_OVERFLOW(fp, EOF)</code> 本质是通过 vtable 的间接调用：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* libio/libioP.h 中类似宏定义 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_JUMPS(THIS)        ((struct _IO_jump_t *) (THIS)-&gt;vtable)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMP0(THIS, FUN)       (_IO_JUMPS (THIS)-&gt;FUN) (THIS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_OVERFLOW(THIS, CH) JUMP1 (THIS, __overflow, CH)</span></span><br></pre></td></tr></table></figure></div>

<p>vtable 里长这样：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> &#123;</span></span><br><span class="line">    JUMP_FIELD (<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD (<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD (<span class="type">int</span>,   __overflow);  <span class="comment">/* 就是这里被 _IO_OVERFLOW 用 */</span></span><br><span class="line">    <span class="comment">/* 后面还有一堆函数指针：__underflow、__xsputn 等等 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>所以 <code>_IO_OVERFLOW(fp, EOF)</code> 其实就是：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fp-&gt;vtable-&gt;__overflow(fp, EOF);</span><br></pre></td></tr></table></figure></div>

<p>这就是 FSOP 最关键的“可控函数指针调用”。</p>
</li>
</ol>
<p><code>_IO_list_all</code> 是一个全局指针，指向所有活动 <code>FILE</code> 结构组成的链表（实际上是 <code>_IO_FILE_plus</code>）：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* libio/libioP.h 里类似这样的定义 */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span>;</span>        <span class="comment">/* 标准 FILE 结构的前半部分 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span>;</span>      <span class="comment">/* vtable 结构 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span>    <span class="title">file</span>;</span>   <span class="comment">/* 真正的 FILE 结构 */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span> <span class="comment">/* 虚表指针：一堆函数指针 */</span></span><br><span class="line">&#125; _IO_FILE_plus;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全局链表头：所有打开的流都挂在这个链表上 */</span></span><br><span class="line">_IO_FILE_plus *_IO_list_all;   <span class="comment">/* 默认指向 stderr 对象之类 */</span></span><br></pre></td></tr></table></figure></div>

<p>链表通过 <code>file._chain</code> 字段串起来：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>              _flags;       <span class="comment">/* 标志位：读/写/错误等 */</span></span><br><span class="line">    <span class="type">char</span>            *_IO_read_ptr;</span><br><span class="line">    <span class="type">char</span>            *_IO_read_end;</span><br><span class="line">    <span class="type">char</span>            *_IO_read_base;</span><br><span class="line">    <span class="type">char</span>            *_IO_write_base;</span><br><span class="line">    <span class="type">char</span>            *_IO_write_ptr;</span><br><span class="line">    <span class="type">char</span>            *_IO_write_end;</span><br><span class="line">    <span class="comment">/* ... 省略若干字段 ... */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span>       <span class="comment">/* 指向下一个 FILE（单向链表） */</span></span><br><span class="line">    <span class="comment">/* ... 末尾还有 _lock 等字段 ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>如果你能：</p>
<ul>
<li>控制 <code>_IO_list_all</code>，让它指向你伪造的 <code>FILE</code> 结构；</li>
<li>控制 <code>vtable</code> 或利用 <code>_IO_str_jumps</code> 等特性；</li>
</ul>
<p>就可以在 <code>exit()</code> 阶段，通过 <code>_IO_cleanup</code> → <code>_IO_flush_all_lockp</code> → vtable 调用，拿到可控 PC。这就是 FSOP 攻击的经典路径。</p>
<h1 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h1><h2 id="共享库版本"><a href="#共享库版本" class="headerlink" title="共享库版本"></a>共享库版本</h2><h3 id="共享库版本命名"><a href="#共享库版本命名" class="headerlink" title="共享库版本命名"></a>共享库版本命名</h3><p>在 ELF 系统（Linux 等）中，共享库通常采用如下“约定俗成”的命名方式：</p>
<blockquote>
<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libname.so.MAJOR.MINOR.RELEASE</span><br></pre></td></tr></table></figure></div>

</blockquote>
<ul>
<li><p>前缀：<code>lib</code></p>
</li>
<li><p>中间：库名 + <code>.so</code></p>
</li>
<li><p>后缀：一串用点分隔的数字版本号，一般为 3 段：主版本号（MAJOR）、次版本号（MINOR）、发布号（RELEASE）</p>
<blockquote>
<p>实际上并不是强制必须是 3 段数字，有些库只有两段，或者采用略有差异的规则，但含义类似。</p>
</blockquote>
<ul>
<li><p><strong>主版本号（Major）</strong></p>
<ul>
<li><p>表示 <strong>ABI 发生不兼容变更</strong> 的重大升级（接口删除、参数类型改变、语义改变等）。</p>
</li>
<li><p>不同主版本号之间通常视为 <strong>不兼容</strong>。</p>
</li>
<li><p>升级主版本号时：</p>
<ul>
<li>依赖旧主版本的程序需要修改、重新编译；或者</li>
<li>系统同时保留多个主版本的共享库（例如 <code>libfoo.so.1</code> 和 <code>libfoo.so.2</code> 并存），老程序继续用旧版本。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>次版本号（Minor）</strong></p>
<ul>
<li>表示 <strong>增量升级</strong>：在保持已有接口不变的前提下，新增加一些接口符号。</li>
<li>主版本号相同的前提下，<strong>高次版本号向后兼容低次版本号</strong>。</li>
<li>程序只要不使用“新加的符号”，通常可以在较旧次版本的库上运行。</li>
</ul>
</li>
<li><p><strong>发布号（Release &#x2F; Patch）</strong></p>
<ul>
<li>表示 <strong>bug 修复、性能优化等</strong>，不新增接口，也不修改接口。</li>
<li>相同主版本号和次版本号下，不同发布号之间一般视为 <strong>完全兼容</strong>。</li>
<li>依赖某个 <code>MAJOR.MINOR</code> 的程序，可以在任意 <code>MAJOR.MINOR.x</code> 上正常运行。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>glibc（C 标准库）和动态链接器本身的命名规则稍有历史遗留问题，不完全符合上面“libname.so.MAJOR.MINOR.RELEASE”的形式。</p>
<p>以 64 位 glibc 为例：</p>
<ul>
<li><p>真实文件：<code>libc-2.31.so</code></p>
</li>
<li><p>SO-NAME：<code>libc.so.6</code></p>
</li>
<li><p>库路径示例：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">lrwxrwxrwx 1 root root 12 Apr  7  2022 /lib/x86_64-linux-gnu/libc.so.6 -&gt; libc-2.31.so</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>可以看到：</p>
<ul>
<li>真实文件名不是 <code>libc.so.6.0.0</code> 这种形式，而是 <code>libc-2.31.so</code>；</li>
<li>但 <strong>SO-NAME 仍然遵循“libname.so.MAJOR” 的形式</strong>（<code>libc.so.6</code>），ABI 规则依然是“主版本号变更才视为不兼容”。</li>
</ul>
<p>不同发行版上，<code>libc.so.6</code> 有时是符号链接，有时也可能是直接的 ELF 文件实现，这属于实现细节，理解为“SO-NAME 对应的那个对象”即可。</p>
<p>动态链接器（ld-linux）命名也比较特殊，同样是历史和兼容性原因导致的特殊命名方式。例如：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -al /lib64/ld-linux-x86-64.so.2</span><br><span class="line">lrwxrwxrwx 1 root root 32 Apr  7  2022 /lib64/ld-linux-x86-64.so.2 -&gt; /lib/x86_64-linux-gnu/ld-2.31.so</span><br></pre></td></tr></table></figure></div>

<ul>
<li>真实文件是 <code>ld-2.31.so</code>；</li>
<li>对外暴露的名字为 <code>ld-linux-x86-64.so.2</code>；</li>
</ul>
</blockquote>
<h3 id="SO-NAME"><a href="#SO-NAME" class="headerlink" title="SO-NAME"></a>SO-NAME</h3><p>通常一个共享库会同时存在三个“层次”的名字（很多资料只提其中两种，容易混淆）：</p>
<ul>
<li><p><strong>真实文件名（Real name）</strong><br>比如：</p>
<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/lib/libfoo.so.2.6.1</span><br></pre></td></tr></table></figure></div>

<p>这是实际存放在磁盘上的文件，带有完整的版本号。</p>
</li>
<li><p><strong>SO-NAME（soname）</strong><br>这是 ABI 级别的名字，用来标识“接口版本”，一般只包含主版本号：</p>
<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libfoo.so.2</span><br></pre></td></tr></table></figure></div>

<ul>
<li>由链接器在生成共享库时写入 ELF 文件的 <code>.dynamic</code> 段中的 <code>DT_SONAME</code> 条目。</li>
<li>编译、链接可执行文件时，链接器会把库的 <strong>SO-NAME</strong> 写入可执行文件的 <code>.dynamic</code> 段中的 <code>DT_NEEDED</code> 条目（注意是 <code>DT_NEEDED</code>，不是 <code>DT_NEED</code>）。</li>
</ul>
</li>
<li><p><strong>链接名（linker name）</strong><br>仅用于编译&#x2F;链接阶段，一般是不带版本号的：</p>
<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libfoo.so</span><br></pre></td></tr></table></figure></div>

<ul>
<li>当你在命令行写 <code>-lfoo</code> 时，链接器会去找 <code>libfoo.so</code>（以及静态库 <code>libfoo.a</code>），决定与哪个库链接。</li>
<li>这个名字通常由开发包（<code>-dev</code>&#x2F;<code>-devel</code> 包）提供为指向 SO-NAME 的符号链接。</li>
</ul>
</li>
</ul>
<p>典型目录结构示例（省略了路径前缀）：</p>
<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libfoo.so      -&gt; libfoo.so.2      # 链接名（编译时用）</span><br><span class="line">libfoo.so.2    -&gt; libfoo.so.2.6.1  # SO-NAME 对应的软链接</span><br><span class="line">libfoo.so.2.6.1                    # 真正的共享库文件</span><br></pre></td></tr></table></figure></div>

<p>系统会在库所在目录为共享库创建一个以 <strong>SO-NAME</strong> 为名的软链接，指向真实文件，例如：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">lrwxrwxrwx 1 root root 12 Apr  7  2022 /lib/x86_64-linux-gnu/libc.so.6 -&gt; libc-2.31.so</span><br><span class="line">$ <span class="built_in">ls</span> -l /lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">-rwxr-xr-x 1 root root 2029592 Apr  7  2022 /lib/x86_64-linux-gnu/libc-2.31.so</span><br></pre></td></tr></table></figure></div>

<ul>
<li>可执行文件中记录的是 <code>DT_NEEDED = &quot;libfoo.so.2&quot;</code> 这样的 SO-NAME，而不是 <code>libfoo.so.2.6.1</code>。</li>
<li>动态链接器（<code>ld-linux-*</code>）在加载程序时，会按照搜索路径在各个共享库目录（<code>/lib</code>、<code>/usr/lib</code> 等）中查找 <strong>名字为 SO-NAME 的文件</strong>，最后会被软链接引导到真正的文件。</li>
</ul>
<p>这样做的好处：</p>
<ul>
<li><p>程序只绑定到 SO-NAME，不依赖完整版本号；</p>
</li>
<li><p>升级库时，只需要：</p>
<ol>
<li>替换真实文件（例如安装 <code>libfoo.so.2.7.0</code>），</li>
<li>把 <code>libfoo.so.2</code> 软链接指向新文件，</li>
<li>不改变 SO-NAME（仍然是 <code>libfoo.so.2</code>），就可以在同一 ABI 下实现平滑升级。</li>
</ol>
</li>
</ul>
<p>Linux 提供 <code>ldconfig</code> 工具来维护这些软链接和缓存，安装或更新共享库后通常会运行 <code>ldconfig</code>：</p>
<ul>
<li><p>扫描默认共享库目录（如 <code>/lib</code>、<code>/usr/lib</code> 以及配置中的其他目录）；</p>
<p><code>ldconfig</code> 会读取 <code>/etc/ld.so.conf</code> 和 <code>/etc/ld.so.conf.d/</code> 目录下的一些 <code>.conf</code> 文件，得到一堆“库目录列表”；在这些目录里扫描所有的 <code>lib*.so*</code> 文件；</p>
<p>一般 Linux 发行版在装 glibc &#x2F; 基础系统包的时候，会顺手：</p>
<ul>
<li>创建 <code>/etc/ld.so.conf</code>；</li>
<li>在 <code>/etc/ld.so.conf.d/</code> 目录下放一些 <code>.conf</code> 文件。</li>
</ul>
<p>比如典型的 <code>/etc/ld.so.conf</code>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include /etc/ld.so.conf.d/*.conf</span><br></pre></td></tr></table></figure></div>

<p>意思是：</p>
<p>“真正的配置都丢在 <code>/etc/ld.so.conf.d/</code> 目录里，我把它们全 include 进来。”</p>
<p>而 <code>/etc/ld.so.conf.d/</code> 里头的那些 <code>.conf</code> 文件，通常是<strong>各个软件包自己扔的</strong>，例如：</p>
<ul>
<li><p>glibc 自己放一个，写多架构相关目录：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/lib/x86_64-linux-gnu</span><br><span class="line">/usr/lib/x86_64-linux-gnu</span><br><span class="line">/lib32</span><br><span class="line">/usr/lib32</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>某些第三方包（数据库、GPU 驱动、音视频 SDK 等）安装时放一个：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/opt/myvendor/lib</span><br><span class="line">/opt/myvendor/lib64</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><p>自动为库创建或更新 SO-NAME 软链接；</p>
</li>
<li><p>更新 <code>/etc/ld.so.cache</code> 中的动态链接库缓存，加速查找。</p>
</li>
</ul>
<p>当你执行：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ldconfig</span><br></pre></td></tr></table></figure></div>

<p><code>ldconfig</code> 会做的事之一：<strong>在每个库目录里，帮你维护“SO-NAME → 真文件”的软链接</strong>。</p>
<p>例如目录里有一个真实库文件：</p>
<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/lib/x86_64-linux-gnu/libfoo.so.2.6.1</span><br></pre></td></tr></table></figure></div>

<p>这个 ELF 的 <code>.dynamic</code> 段里 <code>DT_SONAME</code> 写着：<code>libfoo.so.2</code>。</p>
<p>那 <code>ldconfig</code> 会确保存在一个软链接：</p>
<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/lib/x86_64-linux-gnu/libfoo.so.2 -&gt; libfoo.so.2.6.1</span><br></pre></td></tr></table></figure></div>

<p>这样，当程序的 <code>DT_NEEDED</code> 里写的是 <code>libfoo.so.2</code> 时，动态链接器只需要按这个名字查文件，就能通过软链接跳到对应的真实版本。</p>
<p><code>ldconfig</code> 还会生成 <code>/etc/ld.so.cache</code>，这一步是为了提速。没有缓存的话，每次程序启动，动态链接器都得：</p>
<ol>
<li>遍历它认为的所有库目录（可能十几个）；</li>
<li>一路找 “有没有名叫 <code>libfoo.so.2</code> 的文件”。</li>
</ol>
<p>这会比较慢，所以引入了一个<strong>全局缓存文件</strong> <code>/etc/ld.so.cache</code>：</p>
<ul>
<li><p>它是个二进制文件，里边就是一堆类似：</p>
<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libfoo.so.2  -&gt; /usr/lib/x86_64-linux-gnu/libfoo.so.2</span><br><span class="line">libc.so.6    -&gt; /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>格式专门设计成“方便二进制查找”的结构。</p>
</li>
</ul>
<p><code>ldconfig</code> 就是负责：</p>
<ol>
<li>根据 <code>ld.so.conf</code> + 默认目录扫描所有库；</li>
<li>把“库名 → 路径”的映射写入 <code>/etc/ld.so.cache</code>。</li>
</ol>
<p>之后每次启动程序时，<code>ld.so</code> 都会先在 <code>/etc/ld.so.cache</code> 里查库名：</p>
<ul>
<li>找到了：直接去对应路径 <code>open</code>；</li>
<li>找不到：再去默认目录 <code>/lib</code>、<code>/usr/lib</code> 里挨个遍历。</li>
</ul>
<h3 id="符号版本"><a href="#符号版本" class="headerlink" title="符号版本"></a>符号版本</h3><p>仅用 SO-NAME 管理依赖仍然存在一个经典问题：</p>
<blockquote>
<p>程序在某个系统上编译链接时，使用的是 <strong>较新的次版本号的共享库</strong>，而运行时所在系统的库虽然 <strong>SO-NAME 一样</strong>，但次版本号较低，缺少某些新加的符号，导致运行失败。</p>
</blockquote>
<p>例如：</p>
<ul>
<li>编译时链接的是 <code>libfoo.so.2.6.1</code>（其中新增了 <code>foo_new_api</code> 符号）；</li>
<li>可执行文件中记录的是 <code>DT_NEEDED = &quot;libfoo.so.2&quot;</code>；</li>
<li>在目标系统上只装有比较老的 <code>libfoo.so.2.3.0</code>，没有 <code>foo_new_api</code>；</li>
<li>运行时动态链接器在解析 <code>foo_new_api</code> 时找不到对应符号，会报错。</li>
</ul>
<p>这个问题就是所谓的 <strong>次版本号交会问题（Minor‑revision Rendezvous Problem）</strong>。SO-NAME 只区分主版本号，无法精细到“符号级别”的兼容关系。</p>
<p>为了解决上述问题，并允许库在 <strong>不改 SO-NAME</strong> 的前提下进行复杂演进，现代 ELF 系统引入了 <strong>符号版本机制</strong>：</p>
<ul>
<li><p>每个导出符号（函数、全局变量）除了名字外，还关联一个 <strong>版本标签</strong>，类似于：</p>
<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">printf@@GLIBC_2.2.5</span><br><span class="line">memcpy@@GLIBC_2.2.5</span><br><span class="line">memcpy@GLIBC_2.14</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>对同名符号，可以同时存在多个版本（老版本保留，新版本新增），通过版本标签区分。</p>
</li>
<li><p>可执行文件在链接时，会把“自己实际使用的那个符号版本”记录下来：</p>
<ul>
<li><p>老程序继续引用老版本的符号；</p>
</li>
<li><p>新程序可以链接到新版本的符号；</p>
</li>
<li><p>运行时动态链接器根据符号名 + 版本号精确匹配，从而保证：</p>
<ul>
<li>老程序不会突然跑到新符号语义上去；</li>
<li>新程序不会错误地绑定到旧符号上。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>在 ELF 文件中，符号版本信息主要通过几类条目配合实现：</p>
<ul>
<li><p><code>.dynamic</code> 段中有：</p>
<ul>
<li><code>DT_VERSYM</code>：指向 <code>.gnu.version</code> 表；</li>
<li><code>DT_VERDEF</code> &#x2F; <code>DT_VERNEED</code>：分别描述本库 <strong>定义</strong> 的符号版本以及 <strong>依赖</strong> 的其他库的符号版本信息。</li>
</ul>
</li>
<li><p><code>.gnu.version</code>（由 <code>DT_VERSYM</code> 指向）：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux%20user%20pwn%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/images/image-20241108005224309.png"
                      alt="image-20241108005224309"
                ></p>
<ul>
<li>与动态符号表 <code>.dynsym</code> 一一对应；</li>
<li>为每个符号提供一个“版本索引”。</li>
</ul>
</li>
</ul>
<p>动态链接器大致流程：</p>
<ol>
<li>读取可执行文件或共享库的 <code>.dynsym</code>、<code>.gnu.version</code>、<code>.gnu.version_r</code> 等信息，知道每个导入符号需要哪个版本；</li>
<li>在目标共享库中查找具有匹配“名字 + 版本”的导出符号；</li>
<li>找不到合适版本就报“undefined symbol: xxx@VERSION”之类的错误。</li>
</ol>
<p>符号版本机制允许库在保持相同 SO-NAME 的前提下，<strong>同时保留旧符号版本</strong>，实现非常精细的 ABI 兼容策略，较好地缓解了“次版本号交会问题”：</p>
<ul>
<li>程序依赖的是某个具体版本的符号；</li>
<li>系统只要提供该版本（或兼容版本），程序就能正常运行。</li>
</ul>
<h2 id="共享库系统路径"><a href="#共享库系统路径" class="headerlink" title="共享库系统路径"></a>共享库系统路径</h2><p>FHS（Filesystem Hierarchy Standard）是 Linux&#x2F;Unix 系统的文件层次结构标准，大致规定了：</p>
<ul>
<li>哪些目录由发行版管理（<code>/bin</code>、<code>/lib</code>、<code>/usr</code> 等）；</li>
<li>哪些目录留给本地管理员（<code>/usr/local</code>）；</li>
<li>第三方软件大致放在哪（<code>/opt</code>）。</li>
</ul>
<p>共享库路径也遵守这个思想：<strong>越基础、越“引导级别”的库，越靠近根目录；越高层应用，越往 <code>/usr</code> &#x2F; <code>/usr/local</code> 走。</strong></p>
<blockquote>
<p>glibc 的动态链接器把某些路径视为 <strong>受信任目录</strong>，典型就是 <code>/lib</code>、<code>/usr/lib</code> 以及其多架构子目录（<code>/lib/x86_64-linux-gnu</code> 等）。</p>
<p>在 <strong>secure‑execution 模式</strong>（例如执行 setuid&#x2F;setgid 程序）下，动态链接器会：</p>
<ul>
<li>忽略一些环境变量（如 <code>LD_LIBRARY_PATH</code>、<code>LD_PRELOAD</code> 等）；</li>
<li>只从受信任目录中加载库，避免被非特权用户通过环境污染劫持。</li>
</ul>
</blockquote>
<h3 id="lib-系列：系统引导和最基础运行环境"><a href="#lib-系列：系统引导和最基础运行环境" class="headerlink" title="/lib 系列：系统引导和最基础运行环境"></a><code>/lib</code> 系列：系统引导和最基础运行环境</h3><p><code>/lib</code> 放置系统 <strong>引导和最小用户态环境</strong> 所必需的共享库，例如 <code>libc.so.*</code>、<code>ld-linux*.so.*</code>、某些基础加密 &#x2F; 压缩库等。</p>
<p>系统要求在根文件系统刚挂载好时，就必须能访问这些库；即使 <code>/usr</code> 单独挂载，也要确保系统能先起来。</p>
<p>现代多架构系统上，<code>/lib</code> 往往只是入口，还会细分为：</p>
<ul>
<li><code>/lib/x86_64-linux-gnu</code></li>
<li><code>/lib/i386-linux-gnu</code></li>
<li><code>/lib/x32-linux-gnu</code></li>
<li><code>/lib64</code>（在部分发行版上是主 64 位库目录）</li>
</ul>
<p>这是所谓 <strong>Multiarch</strong>（多架构）布局：同一系统里可以并存多种 ABI 的同名库（如 32&#x2F;64 位两个 <code>libc.so.6</code>）。</p>
<h3 id="usr-lib-系列：发行版自带的“普通软件库”"><a href="#usr-lib-系列：发行版自带的“普通软件库”" class="headerlink" title="/usr/lib 系列：发行版自带的“普通软件库”"></a><code>/usr/lib</code> 系列：发行版自带的“普通软件库”</h3><p><code>/usr/lib</code> 存放包管理器安装的绝大多数共享库，例如 GUI 框架、网络库、数据库驱动、多媒体库等。</p>
<p>常见路径有：</p>
<ul>
<li><code>/usr/lib/x86_64-linux-gnu</code></li>
<li><code>/usr/lib/i386-linux-gnu</code></li>
<li>部分发行版上的 <code>/usr/lib32</code>、<code>/usr/lib64</code> 等。</li>
</ul>
<p>与 <code>/lib</code> 作区分，可以简单理解为：</p>
<blockquote>
<p><strong>“系统刚活过来时就必须要的库在 <code>/lib</code>；能晚点再用的库在 <code>/usr/lib</code>。”</strong></p>
</blockquote>
<h3 id="usr-local-lib-系列：本地安装的软件库"><a href="#usr-local-lib-系列：本地安装的软件库" class="headerlink" title="/usr/local/lib 系列：本地安装的软件库"></a><code>/usr/local/lib</code> 系列：本地安装的软件库</h3><p>从源码 <code>./configure &amp;&amp; make &amp;&amp; make install</code> 默认前缀通常是 <code>/usr/local</code>，对应库就会装到：</p>
<ul>
<li><code>/usr/local/lib</code></li>
<li><code>/usr/local/lib/x86_64-linux-gnu</code> 等。</li>
</ul>
<p>这样不覆盖 <code>/usr/lib</code> 里的系统库，可以同时存在“系统版 + 自己编译版”；</p>
<blockquote>
<p>FHS 规定：<strong>发行版不要乱动 <code>/usr/local</code>，留给系统管理员自己折腾。</strong></p>
</blockquote>
<p>用户配合 <code>/etc/ld.so.conf</code> 或 <code>LD_LIBRARY_PATH</code> 可以方便地让程序优先使用 <code>/usr/local/lib</code> 下的库。</p>
<h3 id="其他常见库路径：-lib32、-lib64、-opt-lib-等"><a href="#其他常见库路径：-lib32、-lib64、-opt-lib-等" class="headerlink" title="其他常见库路径：/lib32、/lib64、/opt/*/lib 等"></a>其他常见库路径：<code>/lib32</code>、<code>/lib64</code>、<code>/opt/*/lib</code> 等</h3><p>不同发行版&#x2F;架构上你还能看到：</p>
<ul>
<li><strong><code>/lib32</code> &#x2F; <code>/usr/lib32</code></strong> ：64 位系统上存放 32 位兼容库（给 32 位程序用的 <code>libc.so.6</code> 等）。</li>
<li><strong><code>/lib64</code> &#x2F; <code>/usr/lib64</code></strong> ：某些发行版中“所有 64 位库都放这里”，<code>/lib</code> &#x2F; <code>/usr/lib</code> 留给 32 位。</li>
<li><strong><code>/opt/&lt;vendor&gt;/lib</code></strong> ：第三方软件通常安装在 <code>/opt/vendor</code>，库在 <code>/opt/vendor/lib</code> 或 <code>lib64</code>。一般靠启动脚本设置 <code>LD_LIBRARY_PATH</code> 或 RPATH&#x2F;RUNPATH 让程序找到这些库。</li>
</ul>
<h2 id="共享库查找过程"><a href="#共享库查找过程" class="headerlink" title="共享库查找过程"></a>共享库查找过程</h2><h3 id="预加载阶段"><a href="#预加载阶段" class="headerlink" title="预加载阶段"></a>预加载阶段</h3><p><strong>预加载（preload）</strong> 指的是：在正常按依赖查找之前，强制先装载一批共享库，这些库里的符号可以覆盖后面加载的库，实现 hook 或注入。</p>
<p>glibc 文档明确写了预加载来源的优先顺序：</p>
<blockquote>
<p>有多种方式可以指定预加载库，其处理顺序是：</p>
<ol>
<li>环境变量 <code>LD_PRELOAD</code></li>
<li>直接调用动态链接器时使用 <code>--preload</code> 参数</li>
<li>配置文件 <code>/etc/ld.so.preload</code></li>
</ol>
</blockquote>
<h4 id="LD-PRELOAD（进程级预加载）"><a href="#LD-PRELOAD（进程级预加载）" class="headerlink" title="LD_PRELOAD（进程级预加载）"></a><code>LD_PRELOAD</code>（进程级预加载）</h4><p>通过 <code>LD_PRELOAD</code> 环境变量指定预先加载的库。</p>
<p>该机制对设置了该环境变量的进程本身以及它 <code>fork/exec</code> 出来的子进程（环境变量默认是继承的）生效，且只对 <strong>使用 glibc 动态链接器的 ELF 动态链接程序</strong> 有效，并且 <strong>在 secure-execution 模式下会被严格限制</strong>。</p>
<p>对<strong>静态链接的可执行文件</strong>、不使用 <code>ld.so</code> 的程序、或者使用其他 C 库（如 musl 的 ld-musl）的程序无效。</p>
<p><code>LD_PRELOAD</code> 列表中的每一项可以是：</p>
<ul>
<li>带路径的名字（包含 <code>/</code>）：如 <code>/home/me/mylib.so</code>；</li>
<li>不带路径的名字（纯库名）：如 <code>libmylib.so</code>。</li>
</ul>
<p>内容是一个共享库“列表”，<strong>用空格或冒号分隔</strong>，没有转义机制。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单个库</span></span><br><span class="line">LD_PRELOAD=/home/me/libmtrace.so <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多个库（空格 / 冒号都行）</span></span><br><span class="line">LD_PRELOAD=<span class="string">&quot;/home/me/a.so:/home/me/b.so&quot;</span> ./prog</span><br><span class="line">LD_PRELOAD=<span class="string">&quot;/home/me/a.so /home/me/b.so&quot;</span> ./prog</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>没有转义语法是 ld.so 自己的规则：</p>
<p>The items of the list can be separated by spaces or colons,<br>and <strong>there is no support for escaping either separator</strong>.</p>
<p>也就是说，在 <strong>动态链接器解析这根字符串时</strong>，它看到空格&#x2F;冒号就认为那是分隔符，不存在像 <code>\:</code>、<code>\&quot;</code> 之类的“再转义”机制。</p>
</blockquote>
<p>动态链接器对每一项做法是：</p>
<ol>
<li><p>shell 层<strong>先展开动态字符串 token</strong>：</p>
<ul>
<li><code>$ORIGIN</code>：程序或共享对象所在目录；</li>
<li><code>$LIB</code>：当前架构对应的 <code>lib</code> 或 <code>lib64</code>；</li>
<li><code>$PLATFORM</code>：处理器平台字符串，如 <code>&quot;x86_64&quot;</code>。</li>
</ul>
<p>例如：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LD_PRELOAD=<span class="string">&#x27;$ORIGIN/mylib.so&#x27;</span> ./prog</span><br><span class="line">LD_PRELOAD=<span class="string">&#x27;/path/$LIB/libfoo.so&#x27;</span></span><br></pre></td></tr></table></figure></div>

<p>注意用单引号防止 shell 把 <code>$ORIGIN</code> 当环境变量展开。</p>
</li>
<li><p>**如果名字中含有 <code>/</code>**：</p>
<p>按给出的相对或绝对路径直接尝试加载，找不到就报错 <code>cannot be preloaded: ... ignored.</code>。</p>
</li>
<li><p><strong>如果名字中不含 <code>/</code>（纯库名）</strong>：</p>
<p>按普通库查找顺序：<code>RPATH</code> → <code>LD_LIBRARY_PATH</code> → <code>RUNPATH</code> → <code>/etc/ld.so.cache</code> → <code>/lib</code> <code>/usr/lib</code> 等默认目录。</p>
</li>
</ol>
<p>预加载库中如果定义了与 libc 等库同名的函数（如 <code>open</code>、<code>malloc</code>），在默认的符号查找规则下，这些定义会 <strong>优先</strong> 被绑定；</p>
<blockquote>
<p>man page 对 <code>LD_PRELOAD</code> 在 secure-execution 模式下的说明：</p>
<ul>
<li><p><strong>secure-exec 触发条件</strong>：<br>例如执行 setuid&#x2F;setgid 程序、运行赋予 capability 的二进制等，内核会通过 <code>AT_SECURE</code> 标记通知 ld.so 进入“安全模式”。</p>
</li>
<li><p>在 secure-exec 模式下：</p>
<ol>
<li><p><strong><code>LD_PRELOAD</code> 属于被“剥离”的环境变量之一</strong>：</p>
<ul>
<li>对程序来说，它根本看不到 <code>LD_PRELOAD</code>；</li>
<li>ld.so 也不会按普通方式信任用户传入的库。</li>
</ul>
</li>
<li><p>对预加载名单的额外限制：</p>
<ul>
<li>列表里 <strong>包含 <code>/</code> 的路径一律忽略</strong>（即不能指定任意路径）；</li>
<li>仅会从“标准搜索目录”（如 <code>/lib</code>、<code>/usr/lib</code> 等）中预加载库，</li>
<li>且被预加载的库必须自身带 <strong>set-user-ID 位</strong>——现实中几乎不会这么配置。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>效果可以简单理解为：</p>
<blockquote>
<p>对普通用户来说，想通过 <code>LD_PRELOAD=自己写的.so</code> 去劫持 setuid 程序，基本是不可行的。</p>
</blockquote>
</blockquote>
<h4 id="ld-so-preload（命令行预加载）"><a href="#ld-so-preload（命令行预加载）" class="headerlink" title="ld.so --preload（命令行预加载）"></a><code>ld.so --preload</code>（命令行预加载）</h4><p>glibc 从 2.30 开始为动态链接器本身提供了 <code>--preload</code> 选项：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 手动调用动态链接器 + 指定预加载库 + 要运行的程序</span></span><br><span class="line">/lib64/ld-linux-x86-64.so.2 --preload ./mylib.so ./a.out</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>选项形式：<code>--preload list</code></p>
</li>
<li><p>其中 <code>list</code> 的语法与 <code>LD_PRELOAD</code> 完全一致：</p>
<ul>
<li>使用空格或冒号分隔多个库；</li>
<li>支持 <code>$ORIGIN</code> &#x2F; <code>$LIB</code> &#x2F; <code>$PLATFORM</code> 动态 token；</li>
<li>同样没有“转义分隔符”的机制（分隔逻辑一样）。</li>
</ul>
</li>
</ul>
<p><strong>和 <code>LD_PRELOAD</code> 的差异：</strong></p>
<blockquote>
<p><code>LD_PRELOAD</code> 是环境变量，默认会被子进程继承；<br><code>--preload</code> 是这一次调用 ld.so 的命令行选项，只对这次执行生效，<br>不会自动影响子进程后续 exec 的新程序。</p>
</blockquote>
<h4 id="etc-ld-so-preload（系统级预加载）"><a href="#etc-ld-so-preload（系统级预加载）" class="headerlink" title="/etc/ld.so.preload（系统级预加载）"></a><code>/etc/ld.so.preload</code>（系统级预加载）</h4><p><code>/etc/ld.so.preload</code> 是由 root 管理的 <strong>系统级预加载列表文件</strong>。</p>
<ul>
<li>内容：一个由 <strong>空白字符（空格 &#x2F; 换行 &#x2F; tab）分隔</strong>的共享库路径列表；</li>
<li>这些库会在每次加载任意程序时，由 ld.so 按顺序强制预加载；</li>
<li>它的处理顺序在 <code>LD_PRELOAD</code> 和 <code>--preload</code> 之后。</li>
</ul>
<p>同样地：</p>
<ul>
<li>每一条目可以包含 <code>$ORIGIN</code>、<code>$LIB</code>、<code>$PLATFORM</code> 等 token；</li>
<li>每次新程序启动时，ld.so 都会重新读取这个文件；</li>
<li>修改文件只影响之后启动的进程，<strong>不会 retroactively 影响已在运行的进程</strong>。</li>
</ul>
<blockquote>
<p><strong>多架构支持与 ELFCLASS 错误</strong></p>
<p>在 64 位系统上，如果你在 <code>/etc/ld.so.preload</code> 写了一个仅有 64 位版本的库：</p>
<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/lib/libhook64.so</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>对 64 位程序没问题；</p>
</li>
<li><p>但当 32 位程序启动时，同样会尝试预加载这库，结果就是：</p>
<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR: ld.so: object &#x27;libhook64.so&#x27; from /etc/ld.so.preload cannot be preloaded (wrong ELF class: ELFCLASS64): ignored.</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>典型的多架构写法是使用 <code>$LIB</code> token：</p>
<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/path/$LIB/libhook.so</span><br></pre></td></tr></table></figure></div>

<p>然后：</p>
<ul>
<li>为 32 位架构在 <code>/path/lib</code> 放 <code>libhook.so</code>；</li>
<li>为 64 位架构在 <code>/path/lib64</code> 放 <code>libhook.so</code>。</li>
</ul>
<p>这样：</p>
<ul>
<li>32 位进程 <code>$LIB → lib</code>，加载 <code>/path/lib/libhook.so</code>；</li>
<li>64 位进程 <code>$LIB → lib64</code>，加载 <code>/path/lib64/libhook.so</code>。</li>
</ul>
<p><strong>与 secure‑execution &#x2F; 容器 的关系</strong></p>
<p>和 <code>LD_PRELOAD</code> 不同：</p>
<ul>
<li><code>/etc/ld.so.preload</code> 是 <strong>由 root 写入的系统配置文件</strong>；</li>
<li>即使在 secure-execution 模式下，ld.so 也仍然会读取该文件（因为它假定 root 已经过滤过风险）；</li>
<li>这也是为什么很多 rootkit &#x2F; 攻击技术会使用 <code>/etc/ld.so.preload</code> 做持久化代码注入。</li>
</ul>
<p>在容器 &#x2F; sandbox 中还会遇到一个常见现象：</p>
<ul>
<li>容器内的 <code>/etc/ld.so.preload</code> 可能绑定宿主机的文件；</li>
<li>但宿主机中提到的库路径并未挂到容器内；</li>
<li>结果就是容器里每次执行程序都会看到 <code>cannot be preloaded: ignored</code> 的错误提示。</li>
</ul>
</blockquote>
<h3 id="正常查找阶段"><a href="#正常查找阶段" class="headerlink" title="正常查找阶段"></a>正常查找阶段</h3><p>预加载阶段结束后，动态链接器才开始对每个 <code>DT_NEEDED</code> 的库名按规则查找。</p>
<p>以 glibc 的 <code>ld.so</code> 为例，它的搜索顺序（普通非 secure 模式下）大致是：</p>
<ol>
<li><p><strong>RPATH（<code>DT_RPATH</code>）</strong></p>
<ul>
<li>如果存在 <code>DT_RPATH</code> 且没有 <code>DT_RUNPATH</code>，先按 <code>DT_RPATH</code> 中的目录搜索；</li>
<li><code>DT_RPATH</code> 是旧机制，在很多新程序中已被 <code>DT_RUNPATH</code> 取代。</li>
</ul>
</li>
<li><p><strong><code>LD_LIBRARY_PATH</code> 环境变量</strong></p>
<ul>
<li>由用户设置的、冒号分隔的目录列表；</li>
<li>在 setuid&#x2F;setgid 等 secure‑execution 模式下会被<strong>忽略并从环境中剥离</strong>。</li>
</ul>
</li>
<li><p><strong>RUNPATH（<code>DT_RUNPATH</code>）</strong></p>
<ul>
<li>新机制，只影响“当前 ELF 直接依赖”的库；</li>
<li>适合作为“内嵌搜索路径”，优先级低于 <code>LD_LIBRARY_PATH</code>。</li>
</ul>
</li>
<li><p><strong><code>/etc/ld.so.cache</code>（由 <code>ldconfig</code> 生成的缓存）</strong></p>
<ul>
<li>一个二进制文件，内部是“库名 → 路径”的索引；</li>
<li>动态链接器会优先查这个缓存，加快查找速度。</li>
</ul>
</li>
<li><p><strong>受信任默认路径：<code>/lib</code>、<code>/usr/lib</code> …</strong></p>
<ul>
<li>如果缓存里没找到，就会在这些目录及其多架构子目录中遍历查找；</li>
<li>在使用 <code>-z nodefaultlib</code> 链接的情况下，这一步可能被跳过（非常少见）。</li>
</ul>
</li>
</ol>
<p><strong>特殊情况：<code>DT_NEEDED</code> 是绝对路径</strong></p>
<ul>
<li>如果 <code>DT_NEEDED</code> 条目就是 <code>/opt/mylib/libfoo.so.2</code> 这种绝对路径，动态链接器会直接尝试加载这个路径；</li>
<li>失败则报错，不会再去其它目录找；</li>
<li>可移植性很差，一般只在特化场景下使用。</li>
</ul>
<blockquote>
<p>对 setuid&#x2F;setgid 程序，动态链接器会进入 secure‑execution 模式：</p>
<ul>
<li>一大堆影响自身行为的环境变量被剥离（包括 <code>LD_LIBRARY_PATH</code>、<code>LD_PRELOAD</code>、<code>LD_DEBUG</code> 等）；</li>
<li>只从受信任路径加载库，避免用户通过环境变量或非受信任目录劫持 setuid 程序。</li>
</ul>
</blockquote>
<h2 id="更改共享库"><a href="#更改共享库" class="headerlink" title="更改共享库"></a>更改共享库</h2><p>Linux 系统提供了很多方法来改变动态链接器装载共享库路径的方法，通过使用这些方法，我们可以满足一些特殊的需求，比如共享库的调试和测试、应用程序级别的虚拟等。</p>
<h3 id="LD-LIBRARY-PATH"><a href="#LD-LIBRARY-PATH" class="headerlink" title="LD_LIBRARY_PATH"></a>LD_LIBRARY_PATH</h3><p>在 Linux 系统中，<code>LD_LIBRARY_PATH</code> 是一个由若干个路径组成的环境变量，每个路径之间由冒号隔开。默认情况下， <code>LD_LIBRARY_PATH</code> 为空。如果我们为某个进程设置了 <code>LD_LIBRARY_PATH</code> ，那么进程在启动时，动态链接器在查找共享库时，会首先查找由 <code>LD_LIBRARY_PATH</code> 指定的目录。这个环境变量可以很方便地让我们测试新的共享库或使用非标准的共享库。</p>
<p>比如更换 <code>libdl.so.2</code> 和 <code>libc.so.6</code> 的 pwntools 脚本如下：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh = process(<span class="string">&quot;./lib/ld.so --preload libdl.so.2 ./pwnhub&quot;</span>.split(), env=&#123;<span class="string">&quot;LD_LIBRARY_PATH&quot;</span>: <span class="string">&quot;./lib/&quot;</span>&#125;)</span><br></pre></td></tr></table></figure></div>

<h3 id="LD-PRELOAD"><a href="#LD-PRELOAD" class="headerlink" title="LD_PRELOAD"></a>LD_PRELOAD</h3><p>系统中另外还有一个环境变量叫做 <code>LD_PRELOAD</code> ，这个文件中我们可以指定预先装载的一些共享库甚或是目标文件。在 <code>LD_PRELOAD</code> 里面指定的文件会在动态链接器按照固定规则搜索共享库之前装载，它比 <code>LD_LIBRARY_PATH</code> 里面所指定的目录中的共享库还要优先。无论程序是否依赖于它们，<code>LD_PRELOAD</code> 里面指定的共享库或目标文件都会被装载。</p>
<p>比如更换 <code>libdl.so.2</code> 和 <code>libc.so.6</code> 的 pwntools 脚本如下：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process(<span class="string">&quot;./lib/ld.so ./pwnhub&quot;</span>.split(), env=&#123;<span class="string">&quot;LD_PRELOAD&quot;</span>: <span class="string">&quot;./lib/libc.so.6 ./lib/libdl.so.2&quot;</span>&#125;)</span><br></pre></td></tr></table></figure></div>

<h3 id="LD-DEBUG"><a href="#LD-DEBUG" class="headerlink" title="LD_DEBUG"></a>LD_DEBUG</h3><p>另外还有一个非常有用的环境变量 <code>LD_DEBUG</code> ，这个变量可以打开动态链接器的调试功能，当我们设置这个变量时，动态链接器会在运行时打印出各种有用的信息，对于我们开发和调试共享库有很大的帮助。</p>
<p>例如运行 <code>LD_DEBUG=files /bin/ls</code> 命令时动态链接器打印出了整个装载过程，显示程序依赖于哪个共享库并且按照什么步骤装载和初始化，共享库装载时的地址等。</p>
<ul>
<li><code>bindings</code>：显示动态链接的符号绑定过程。</li>
<li><code>libs</code>：显示共享库的查找过程。</li>
<li><code>versions</code>：显示符号的版本依赖关系。</li>
<li><code>reloc</code>：显示重定位过程。</li>
<li><code>symbols</code>：显示符号表查找过程。</li>
<li><code>statistics</code>：显示动态链接过程中的各种统计信息。</li>
</ul>
<h3 id="patchelf-1"><a href="#patchelf-1" class="headerlink" title="patchelf"></a>patchelf</h3><p>用于对于依赖不是很复杂的程序更换 libc ，有一下几点需要注意：</p>
<ul>
<li>如果在漏洞利用时用到了动态链接相关结构最好不要 patchelf，因为 patchelf 会改变动态链接相关结构的位置。</li>
<li>一个程序在一个版本的虚拟机里面 patchelf 后换到另一个版本虚拟机中可能会运行失败。</li>
<li>在 patch 完 libc 后最好把 ld 也 patch 成大版本相同的 ld ，否则会运行失败。</li>
</ul>
<p>修改 libc：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf --replace-needed libc.so.6 ./libc.so.6 ./pwn</span><br></pre></td></tr></table></figure></div>

<p>修改 ld：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf --set-interpreter ./ld-2.31.so ./pwn</span><br></pre></td></tr></table></figure></div>

<p>有的时候像 <code>libm.so.6</code> 换不过来的情况可能因为程序依赖的某个动态库本身也依赖该动态库：</p>
<pre><font color="#26A269"><b>➜  </b></font><font color="#2AA1B3"><b>cursedst</b></font> <font color="#26A269">patchelf</font> --replace-needed <u style="text-decoration-style:single">libm.so.6</u> <u style="text-decoration-style:single">./libm.so.6</u> <u style="text-decoration-style:single">./st</u>
<font color="#26A269"><b>➜  </b></font><font color="#2AA1B3"><b>cursedst</b></font> <font color="#26A269">ldd</font> <u style="text-decoration-style:single">./st</u>
    linux-vdso.so.1 (0x00007fffdfad9000)
    ./libstdc++.so.6 (0x000076ee89e00000)
    ./libgcc_s.so.1 (0x000076ee8a195000)
    ./libc.so.6 (0x000076ee89a00000)
    libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x000076ee8a09c000)
    ./ld-linux-x86-64.so.2 =&gt; /lib64/ld-linux-x86-64.so.2 (0x000076ee8a1c5000)
<font color="#26A269"><b>➜  </b></font><font color="#2AA1B3"><b>cursedst</b></font> <font color="#26A269">patchelf</font> --replace-needed <u style="text-decoration-style:single">libm.so.6</u> <u style="text-decoration-style:single">./libm.so.6</u> <u style="text-decoration-style:single">./st</u>
<font color="#26A269">patchelf</font> --replace-needed <u style="text-decoration-style:single">libm.so.6</u> <u style="text-decoration-style:single">./libm.so.6</u> <u style="text-decoration-style:single">./libstdc++.so.6</u>
<font color="#26A269"><b>➜  </b></font><font color="#2AA1B3"><b>cursedst</b></font> <font color="#26A269">./st</font>
What&apos;s your name?
^C
<font color="#C01C28"><b>➜  </b></font><font color="#2AA1B3"><b>cursedst</b></font> <font color="#26A269">ldd</font> <u style="text-decoration-style:single">./st</u> 
    linux-vdso.so.1 (0x00007ffc52bea000)
    ./libstdc++.so.6 (0x0000747ef3600000)
    ./libgcc_s.so.1 (0x0000747ef396a000)
    ./libc.so.6 (0x0000747ef3200000)
    ./libm.so.6 (0x0000747ef3512000)
    ./ld-linux-x86-64.so.2 =&gt; /lib64/ld-linux-x86-64.so.2 (0x0000747ef399a000)
</pre>

<h1 id="进程线程"><a href="#进程线程" class="headerlink" title="进程线程"></a>进程线程</h1><h2 id="多线程与-TLS"><a href="#多线程与-TLS" class="headerlink" title="多线程与 TLS"></a>多线程与 TLS</h2><h3 id="TLS-基本概念"><a href="#TLS-基本概念" class="headerlink" title="TLS 基本概念"></a>TLS 基本概念</h3><p>线程的访问非常自由，它可以访问进程内存里的所有数据，甚至包括其他线程的堆栈（如果它知道其他线程的堆栈地址，那么这就是很少见的情况），但实际运用中线程也拥有自己的私有存储空间，包括以下几方面：</p>
<ul>
<li>栈（尽管并非完全无法被其他线程访问，但一般情况下仍然可以认为是私有的数据）。</li>
<li>线程局部存储（Thread Local Storage, TLS）。线程局部存储是某些操作系统为线程单独提供的私有空间，但通常只具有很有限的容量。</li>
<li>寄存器（包括PC寄存器），寄存器是执行流的基本数据，因此为线程私有。</li>
</ul>
<p>实际上，线程私有的数据有：</p>
<ul>
<li>局部变量</li>
<li>函数的参数</li>
<li><strong>TLS 数据</strong></li>
</ul>
<p>线程共享的数据有：</p>
<ul>
<li>全局变量</li>
<li>堆上的数据</li>
<li>函数里的静态变量</li>
<li>程序代码，任何线程都有有权利读取并执行任何代码。</li>
<li>打开的文件，A 线程打开的文件可以由 B 线程读写。</li>
</ul>
<h4 id="TLS-数据"><a href="#TLS-数据" class="headerlink" title="TLS 数据"></a>TLS 数据</h4><p>一个<strong>全局变量</strong>如果使用 <code>__thread</code> 关键字修饰，那么这个变量就变成线程私有的 <strong>TLS 数据</strong>，也就是说每个线程都在自己所属 TLS 中单独保存一份这个变量的副本。例如下面的代码中，<code>a</code> 和 <code>b</code> 都是 TLS 数据，而 <code>c</code> 是全局变量。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc test.c -o test -g -pthread</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint-gcc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__thread <span class="type">uint32_t</span> a = <span class="number">0x114514</span>;</span><br><span class="line">__thread <span class="type">uint32_t</span> b;</span><br><span class="line"><span class="type">uint32_t</span> c = <span class="number">0x1919810</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread: a(%p) = %x, b(%p) = %x, c(%p) = %x\n&quot;</span>, &amp;a, a, &amp;b, b, &amp;c, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    a = <span class="number">0x12345678</span>;</span><br><span class="line">    b = <span class="number">0x87654321</span>;</span><br><span class="line">    c = <span class="number">0xdeadbeef</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread: a(%p) = %x, b(%p) = %x, c(%p) = %x\n&quot;</span>, &amp;a, a, &amp;b, b, &amp;c, c);</span><br><span class="line">    <span class="type">pthread_t</span> pid;</span><br><span class="line">    pthread_create(&amp;pid, <span class="literal">NULL</span>, thread, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(pid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">thread: a(0x7f1ec78f0738) = 12345678, b(0x7f1ec78f073c) = 87654321, c(0x562d7468a010) = deadbeef</span></span><br><span class="line"><span class="comment">thread: a(0x7f1ec70ed6f8) = 114514, b(0x7f1ec70ed6fc) = 0, c(0x562d7468a010) = deadbeef</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>

<p>分析生成的 ELF 文件的节表，发现多出了 <code>.tdata</code> 和 <code>.tbss</code> ，这两个节分别记录已初始化和未初始化的 TLS 数据。</p>
<p>其中 <code>.tbss</code> 在 ELF 文件中不占用空间， <code>.tdata</code> 在 ELF 中存储了初始化的数据，比如上面的代码中的 <code>__thread uint32_t a = 0x114514</code> 。</p>
<p>ELF 加载到内存中后， <code>.tdata</code> 和 <code>.tbss</code> 这两个节合并为一个段，在程序头表中这个段的 <code>p_type</code> 为 <code>PT_TLS(7)</code> 。</p>
<h4 id="TLS-结构"><a href="#TLS-结构" class="headerlink" title="TLS 结构"></a>TLS 结构</h4><p>在 ELF TLS ABI 的抽象模型中，每个线程大致有这么几层：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux%20user%20pwn%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/images/image-20241108005249673.png"
                      alt="image-20241108005249673"
                ></p>
<ol>
<li><p><strong>TCB（Thread Control Block）</strong></p>
<p>TCB 是“线程指针（Thread Pointer, TP）”指向的那块结构。对 x86_64 来说，TP &#x3D; <code>fs.base</code>，即 FS 段基址。线程控制块头部包含指向 DTV 的指针、<code>stack_guard</code>、<code>pointer_guard</code> 等。</p>
</li>
<li><p><strong>DTV（Dynamic Thread Vector）</strong></p>
<p>一个数组 <code>dtv_t[]</code>，用于“索引到各个模块的 TLS block”。</p>
</li>
<li><p><strong>TLS blocks</strong></p>
<p>每个“有 TLS 的模块”对应一个 block，内部就是该模块 <code>.tdata + .tbss</code> 的一个 per-thread 副本。对每个线程来说，这一套布局对应一块内存区域，<strong>专属于这个线程</strong>；</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ .tdata 初值拷贝 ][ .tbss 区域（零填） ][ 可能还有对齐 padding ]</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p>DTV 在 glibc 中定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dtv_pointer</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *val;      <span class="comment">// 指向 TLS block 起始</span></span><br><span class="line">    <span class="type">void</span> *to_free;  <span class="comment">// 非对齐指针，释放用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">dtv</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> counter;          <span class="comment">// 某些槽里用作计数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dtv_pointer</span> <span class="title">pointer</span>;</span></span><br><span class="line">&#125; <span class="type">dtv_t</span>;</span><br></pre></td></tr></table></figure></div>

<p>在 glibc 的布局里（注意指针是 <code>dtv+1</code>）：</p>
<ul>
<li><p><code>dtv[-1].counter</code>：当前这块 dtv 的“容量”（最多可以容纳多少 modid）；比如值是 64，就说明最多用 <code>dtv[1]..dtv[64]</code> 存放 TLS block 信息；</p>
</li>
<li><p><code>dtv[0].counter</code>：<strong>当前线程 DTV 的 TLS 版本号（generation）</strong>；每当有 <code>dlopen</code> &#x2F; <code>dlclose</code> 引入&#x2F;移除带 TLS 的模块，全局的 generation 会变化；运行时可以通过它判断“当前这个线程的 DTV 是否需要更新&#x2F;扩容”；</p>
</li>
<li><p><code>dtv[i].pointer</code>（<code>i &gt;= 1</code>）：表示 <strong>模块 ID 为 i 的模块</strong> 的 TLS block 信息：</p>
<ul>
<li><code>val</code>：指向该线程中，这个模块 TLS block 起始；</li>
<li><code>to_free</code>：如果这个 block 是单独 <code>malloc</code> 出来的，<code>to_free</code> 记录原始指针以便 <code>free</code>；<br>如果这个 block 是静态 TLS 区的一部分（比如主程序 TLS），<code>to_free</code> 就是 <code>NULL</code>。</li>
</ul>
<blockquote>
<p>模块 ID（<code>modid</code>）来自每个模块的 <code>link_map-&gt;l_tls_modid</code>，是由动态链接器分配的，典型从 <code>1</code> 开始，主程序是 1，第一个共享库是 2，依次往后。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>初始创建线程时，<code>allocate_dtv</code> 会按当前“最大 modid 值 + 冗余”分配一块 DTV；如果后面 <code>dlopen</code> 了新的带 TLS 的模块，<code>dl_tls_max_dtv_idx</code> 变大，某些线程就需要扩容：</p>
<ul>
<li>检查 <code>dtv[-1].counter</code> 是否够用；</li>
<li>不够的话重新 <code>malloc</code> 一块更大的、拷贝旧的内容、更新 TCB 里的 <code>dtv</code> 指针；</li>
<li>同时更新 <code>dtv[0].counter</code> 为新的 generation 值。</li>
</ul>
<p>这也是为什么你会看到 <code>_dl_allocate_tls_init</code> 里有一堆 “slotinfo_list &#x2F; generation &#x2F; max modid” 之类的逻辑：本质上就是管理这张 DTV 表的生命周期。</p>
</blockquote>
<p>以 x86_64 glibc 为例，TCB 实际上就是 <code>tcbhead_t</code>，该类型定义在 <code>sysdeps/x86_64/nptl/tls.h</code>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">void</span> *tcb;         <span class="comment">// 指向 TCB 本身（struct pthread）</span></span><br><span class="line">  <span class="type">dtv_t</span> *dtv;        <span class="comment">// DTV 指针（实际指向 dtv[1]）</span></span><br><span class="line">  <span class="type">void</span> *self;        <span class="comment">// 指向线程描述符（struct pthread）</span></span><br><span class="line">  <span class="type">int</span> multiple_threads;</span><br><span class="line">  <span class="type">int</span> gscope_flag;</span><br><span class="line">  <span class="type">uintptr_t</span> sysinfo;</span><br><span class="line">  <span class="type">uintptr_t</span> stack_guard;     <span class="comment">// 栈 canary 基值</span></span><br><span class="line">  <span class="type">uintptr_t</span> pointer_guard;   <span class="comment">// 指针加密基值</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> unused_vgetcpu_cache[<span class="number">2</span>];</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> feature_1;</span><br><span class="line">  <span class="type">int</span> __glibc_unused1;</span><br><span class="line">  <span class="type">void</span> *__private_tm[<span class="number">4</span>];</span><br><span class="line">  <span class="type">void</span> *__private_ss;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> ssp_base;</span><br><span class="line">  __128bits __glibc_unused2[<span class="number">8</span>][<span class="number">4</span>] __attribute__ ((aligned (<span class="number">32</span>)));</span><br><span class="line">  <span class="type">void</span> *__padding[<span class="number">8</span>];</span><br><span class="line">&#125; <span class="type">tcbhead_t</span>;</span><br></pre></td></tr></table></figure></div>

<p>在 pwndbg 中可以通过 <code>tls</code> 命令查看当前线程的 TCB：</p>
<pre><font color="#26A269"><b>pwndbg&gt; </b></font>tls
<font color="#26A269">Thread Local Storage (TLS) base: 0x7ffff7ee3800</font>
<font color="#26A269">TLS is located at:</font>
<font color="#A347BA">    0x7ffff7ee3000     0x7ffff7ee6000 rw-p     3000      0 [anon_7ffff7ee3]</font>
<font color="#26A269">Dumping the address:</font>
<font color="#A347BA">tcbhead_t @ 0x7ffff7ee3800</font>
<font color="#A347BA">    0x00007ffff7ee3800 +0x0000 tcb                  : 0x7ffff7ee3800</font>
<font color="#A347BA">    0x00007ffff7ee3808 +0x0008 dtv                  : 0x7ffff7ee4220</font>
<font color="#A347BA">    0x00007ffff7ee3810 +0x0010 self                 : 0x7ffff7ee3800</font>
<font color="#A347BA">    0x00007ffff7ee3818 +0x0018 multiple_threads     : 0x0</font>
<font color="#A347BA">    0x00007ffff7ee381c +0x001c gscope_flag          : 0x0</font>
<font color="#A347BA">    0x00007ffff7ee3820 +0x0020 sysinfo              : 0x0</font>
<font color="#A347BA">    0x00007ffff7ee3828 +0x0028 stack_guard          : 0xea3da6237c5e9c00</font>
<font color="#A347BA">    0x00007ffff7ee3830 +0x0030 pointer_guard        : 0xbe3ff50ef5f8b0d9</font>
<font color="#A347BA">    0x00007ffff7ee3838 +0x0038 unused_vgetcpu_cache : {0, 0}</font>
<font color="#A347BA">    0x00007ffff7ee3848 +0x0048 feature_1            : 0x0</font>
<font color="#A347BA">    0x00007ffff7ee384c +0x004c __glibc_unused1      : 0x0</font>
<font color="#A347BA">    0x00007ffff7ee3850 +0x0050 __private_tm         : {0x0, 0x0, 0x0, 0x0}</font>
<font color="#A347BA">    0x00007ffff7ee3870 +0x0070 __private_ss         : 0x0</font>
<font color="#A347BA">    0x00007ffff7ee3878 +0x0078 ssp_base             : 0x0</font>
<font color="#A347BA">    0x00007ffff7ee3880 +0x0080 __glibc_unused2      : &#123;&#123;&#123;</font>
<font color="#A347BA">                                         i = &#123;0, 0, 0, 0&#125;</font>
    <font color="#A347BA">[...]</font>
<font color="#A2734C">Output truncated. Rerun with option -a to display the full output.</font></pre>



<p>在线程里，<strong>FS base</strong> 指向的是一个 <code>struct pthread</code>，其首字段就是 <code>tcbhead_t header</code>；所以：</p>
<ul>
<li><code>fs:0x00</code> → <code>header.tcb</code></li>
<li><code>fs:0x08</code> → <code>header.dtv</code></li>
<li><code>fs:0x28</code> → <code>stack_guard</code></li>
<li><code>fs:0x30</code> → <code>pointer_guard</code></li>
</ul>
<p>也就是说：<strong>每个线程的 TLS &#x2F; canary &#x2F; pointer_guard 都是挂在它自己的 FS base 下面的一整个结构里。</strong></p>
<p>例如 <code>__stack_chk_guard</code> 这种 TLS 栈 canary 变量，最终就是通过 FS 相对偏移拿到 <code>stack_guard</code>；</p>
<h3 id="TLS-初始化过程"><a href="#TLS-初始化过程" class="headerlink" title="TLS 初始化过程"></a>TLS 初始化过程</h3><h4 id="主线程-TLS-初始化"><a href="#主线程-TLS-初始化" class="headerlink" title="主线程 TLS 初始化"></a>主线程 TLS 初始化</h4><p>前面提到过在 <code>main</code> 开始前会调用 <code>__libc_setup_tls</code> 初始化 TLS 。</p>
<p>在 <code>__libc_setup_tls</code> 函数中，首先会遍历 ELF 的程序头表，找到 <code>p_type</code> 为 <code>PT_TLS(7)</code> 的段，这个段中就存储着 TLS 的初始化数据。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_dl_phdr != <span class="literal">NULL</span>)</span><br><span class="line">  <span class="keyword">for</span> (phdr = _dl_phdr; phdr &lt; &amp;_dl_phdr[_dl_phnum]; ++phdr)</span><br><span class="line">    <span class="keyword">if</span> (phdr-&gt;p_type == PT_TLS) &#123;</span><br><span class="line">      memsz    = phdr-&gt;p_memsz;   <span class="comment">// TLS block 总大小 (.tdata + .tbss)</span></span><br><span class="line">      filesz   = phdr-&gt;p_filesz;  <span class="comment">// .tdata 在文件中的大小</span></span><br><span class="line">      initimage = (<span class="type">void</span> *) phdr-&gt;p_vaddr + main_map-&gt;l_addr; <span class="comment">// 初始化镜像</span></span><br><span class="line">      align    = phdr-&gt;p_align;</span><br><span class="line">      <span class="keyword">if</span> (align &gt; max_align) max_align = align;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>然后通过 <code>sbrk</code> 调用为 TLS 中的数据以及一个 <code>pthread</code> 结构体分配内存。其中 <code>pthread</code> 结构体的第一项为 <code>tcbhead_t header;</code> ，即前面提到的 <strong>TCB</strong> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为 TLS block + TCB 预留空间</span></span><br><span class="line">tcb_offset = roundup (memsz + GLRO(dl_tls_static_surplus), max_align);</span><br><span class="line">tlsblock = __sbrk (tcb_offset + TLS_INIT_TCB_SIZE + max_align);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对齐到 max_align</span></span><br><span class="line">tlsblock = (<span class="type">void</span> *) (((<span class="type">uintptr_t</span>) tlsblock + max_align - <span class="number">1</span>)</span><br><span class="line">                     &amp; ~(max_align - <span class="number">1</span>));</span><br></pre></td></tr></table></figure></div>

<p>布局大致如下，其中 <code>TLS_INIT_TCB_SIZE == sizeof(struct pthread)</code>。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ TLS Block (静态 TLS) ][padding][ struct pthread (TCB) ]</span><br></pre></td></tr></table></figure></div>

<p>之后初始化 <code>_dl_static_dtv</code> ，也就是主线程的“静态 DTV 数组”，具体过程为：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">dtv_t</span> _dl_static_dtv[<span class="number">2</span> + TLS_SLOTINFO_SURPLUS];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0 号槽：dtv 的“容量”（长度），注意后续会把 dtv 指针设为 &amp;dtv[1]</span></span><br><span class="line">_dl_static_dtv[<span class="number">0</span>].counter = (<span class="keyword">sizeof</span>(_dl_static_dtv)/<span class="keyword">sizeof</span>(_dl_static_dtv[<span class="number">0</span>])) - <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 1 号槽：generation counter，初始化为 0（已经在 BSS 中清零）</span></span><br><span class="line"><span class="comment">/* _dl_static_dtv[1].counter = 0; */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 号槽：主程序 TLS block 的入口</span></span><br><span class="line">_dl_static_dtv[<span class="number">2</span>].pointer.val =</span><br><span class="line">    (<span class="type">char</span> *)tlsblock + tcb_offset - roundup(memsz, align ?: <span class="number">1</span>);</span><br><span class="line">_dl_static_dtv[<span class="number">2</span>].pointer.to_free = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(_dl_static_dtv[<span class="number">2</span>].pointer.val, initimage, filesz);</span><br></pre></td></tr></table></figure></div>

<p>随后，通过 <code>INSTALL_DTV</code> 宏把 TCB 里的 <code>dtv</code> 指针指向 <code>&amp;_dl_static_dtv[1]</code>：</p>
<ul>
<li><code>dtv[-1] == _dl_static_dtv[0]</code> → 容量</li>
<li><code>dtv[0]  == _dl_static_dtv[1]</code> → generation</li>
<li><code>dtv[1]  == _dl_static_dtv[2]</code> → 主程序 TLS block 信息</li>
</ul>
<p>然后将 TLS 的初始数据也就是 <code>PT_TLS</code> 段中的数据复制到 TLS 中。</p>
<p>此时 TLS 相关结构之间的关系如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux%20user%20pwn%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/images/image-20241108005415665.png"
                      alt="image-20241108005415665"
                ><br>另外还会初始化 <code>link_map</code> 中的 TLS 相关的数据，由此我们可以知道 <code>link_map</code> 中这些字段的含义：</p>
<ul>
<li><code>l_tls_offset </code>：TCB 在 TLS 中的偏移。</li>
<li><code>l_tls_align</code>：TLS 初始数据的对齐，在 TLS 中 TLS 初始数据关于 <code>l_tls_align</code> 向上取整。</li>
<li><code>l_tls_blocksize</code>：TLS 初始数据的大小，也就是前面提到的 TLS Block 的大小。</li>
<li><code>l_tls_initimage</code>：TLS 初始数据的地址。也就是 <code>PT_TLS</code> 段的地址。</li>
<li><code>l_tls_initimage_size</code>：<code>PT_TLS</code> 段在文件中的大小，也就是 <code>.tdata</code> 的大小。</li>
<li><code>l_tls_modid</code>：模块编号。</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">main_map</span> =</span> GL(dl_ns)[LM_ID_BASE]._ns_loaded;</span><br><span class="line">main_map-&gt;l_tls_offset = roundup (memsz, align ?: <span class="number">1</span>);</span><br><span class="line"><span class="comment">/* Update the executable&#x27;s link map with enough information to make</span></span><br><span class="line"><span class="comment">   the TLS routines happy.  */</span></span><br><span class="line">main_map-&gt;l_tls_align = align;</span><br><span class="line">main_map-&gt;l_tls_blocksize = memsz;</span><br><span class="line">main_map-&gt;l_tls_initimage = initimage;</span><br><span class="line">main_map-&gt;l_tls_initimage_size = filesz;</span><br><span class="line">main_map-&gt;l_tls_modid = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="创建线程时-TLS-初始化"><a href="#创建线程时-TLS-初始化" class="headerlink" title="创建线程时 TLS 初始化"></a>创建线程时 TLS 初始化</h4><p>创建线程的函数 <code>pthread_create</code> 实际调用的是 <code>__pthread_create_2_1</code> 函数，在该函数中调用了 <code>allocate_stack</code> 函数，展开为 <code>allocate_stack</code>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> ALLOCATE_STACK(attr, pd) allocate_stack (attr, pd, &amp;stackaddr)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pthread</span> *<span class="title">pd</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> err = ALLOCATE_STACK (iattr, &amp;pd);</span><br></pre></td></tr></table></figure></div>

<p><code>allocate_stack</code> 大致做几件事：</p>
<ol>
<li>用 <code>mmap</code> 分配一块“栈 + guard page”的内存；</li>
<li>在栈顶附近摆一个 <code>struct pthread</code>（即 TCB+线程描述符），返回指针 <code>pd</code>；</li>
<li>调用 <code>_dl_allocate_tls(TLS_TPADJ(pd))</code> 为这个新线程分配并初始化 TLS&#x2F;DTV。</li>
</ol>
<p>在 <code>allocate_stack</code> 函数中会调用 <code>mmap</code> 为线程分配栈空间，然后初始化栈底为一个 <code>pthread</code> 结构体并将指针 <code>pd</code> 指向该结构体。最后调用 <code>_dl_allocate_tls</code> 函数为 TCB 创建 <code>dtv</code> 数组。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pthread</span> *<span class="title">pd</span>;</span></span><br><span class="line"><span class="comment">// [...]</span></span><br><span class="line">mem = __mmap (<span class="literal">NULL</span>, size, (guardsize == <span class="number">0</span>) ? prot : PROT_NONE,</span><br><span class="line">  MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// [...]</span></span><br><span class="line">pd = (<span class="keyword">struct</span> pthread *) ((((<span class="type">uintptr_t</span>) mem + size) - TLS_TCB_SIZE) &amp; ~__static_tls_align_m1);</span><br><span class="line"><span class="comment">// [...]</span></span><br><span class="line">_dl_allocate_tls (TLS_TPADJ (pd))</span><br></pre></td></tr></table></figure></div>

<p><code>_dl_allocate_tls</code> 函数依次调用 <code>allocate_dtv</code> 和 <code>_dl_allocate_tls_init</code> 分配和初始化 <code>dtv</code> 数组。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">_dl_allocate_tls (<span class="type">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> _dl_allocate_tls_init (mem == <span class="literal">NULL</span></span><br><span class="line">        ? _dl_allocate_tls_storage ()</span><br><span class="line">        : allocate_dtv (mem));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>allocate_dtv</code> 函数调用了 ptmalloc 堆管理器的 <code>calloc</code> 函数为 <code>dtv</code> 数组分配内存，初始化 <code>dtv[0].counter</code> 为数组中元素数量，并且让 <code>pd-&gt;dtv</code> 指向 <code>dtv[1]</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 安装 dtv 指针。</span></span><br><span class="line"><span class="comment"> * 传入的 dtvp 指向下标为 -1 的元素（即 dtv[-1]），</span></span><br><span class="line"><span class="comment"> * 这个元素里存的是 dtv 的长度信息（counter）。</span></span><br><span class="line"><span class="comment"> * TCB 内部的 dtv 字段则指向 dtv[1] 这个位置。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INSTALL_DTV(descr, dtvp) \</span></span><br><span class="line"><span class="meta">    ((tcbhead_t *)(descr))-&gt;dtv = (dtvp) + 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">allocate_dtv</span><span class="params">(<span class="type">void</span> *result)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">dtv_t</span>  *dtv;</span><br><span class="line">    <span class="type">size_t</span>  dtv_length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为 dtv 分配的槽位会比当前需要的模块数多一点（DTV_SURPLUS），</span></span><br><span class="line"><span class="comment">     * 这样可以减少后续因 dlopen 新模块而频繁扩容 dtv 的情况。 */</span></span><br><span class="line">    dtv_length = GL(dl_tls_max_dtv_idx) + DTV_SURPLUS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 多申请 2 个元素：</span></span><br><span class="line"><span class="comment">     *   - dtv[0]   ：保存 dtv 的长度（counter），即最大可用槽数</span></span><br><span class="line"><span class="comment">     *   - dtv[1..]：真正给各个 TLS 模块使用（modid 对应的槽）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 注意：calloc 会把整个 dtv 数组清零，</span></span><br><span class="line"><span class="comment">     *       所以除了 dtv[0].counter 之外，其余元素包括 generation</span></span><br><span class="line"><span class="comment">     *       和各个 pointer 都默认是 0（表示未使用或未分配）。 */</span></span><br><span class="line">    dtv = <span class="built_in">calloc</span>(dtv_length + <span class="number">2</span>, <span class="keyword">sizeof</span>(<span class="type">dtv_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (dtv != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 初始化 dtv 的“长度”信息。</span></span><br><span class="line"><span class="comment">         * 这里记录的是可用的最大槽数（不含前面预留的 2 个）。 */</span></span><br><span class="line">        dtv[<span class="number">0</span>].counter = dtv_length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 其余元素（包括 generation counter 和各个 pointer）已经被</span></span><br><span class="line"><span class="comment">         * calloc 清零，用 0 表示“尚未分配 / 尚未使用”。 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 把 dtv 挂到当前线程的 TCB 结构中。</span></span><br><span class="line"><span class="comment">         * INSTALL_DTV 会让 TCB 里的 dtv 字段指向 &amp;dtv[1]：即</span></span><br><span class="line"><span class="comment">         *   dtv[-1].counter = 长度</span></span><br><span class="line"><span class="comment">         *   dtv[0]          = generation</span></span><br><span class="line"><span class="comment">         *   dtv[modid]      = 对应模块的 TLS block 信息 */</span></span><br><span class="line">        INSTALL_DTV(result, dtv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 分配失败，返回 NULL，调用方需要据此判断错误。 */</span></span><br><span class="line">        result = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>_dl_allocate_tls_init</code> 函数会遍历 <code>dl_tls_dtv_slotinfo_list</code> 中的 <code>link_map</code> ，初始化 <code>dtv</code> 数组并将初始数据复制到 TLS 变量中。<strong>从这里可以看出，如果一个模块有 TLS 变量，则该模块对应的 <code>dtv-&gt;pointer.val</code> 指向 TLS 变量的起始地址。</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 先将当前模块对应的 dtv 槽位标记为“未分配”。</span></span><br><span class="line"><span class="comment"> * 这里使用 TLS_DTV_UNALLOCATED 作为特殊标记值，</span></span><br><span class="line"><span class="comment"> * to_free 置为 NULL，表示目前没有单独分配的 TLS block</span></span><br><span class="line"><span class="comment"> * 需要在销毁线程时 free。 */</span></span><br><span class="line">dtv[<span class="built_in">map</span>-&gt;l_tls_modid].pointer.val     = TLS_DTV_UNALLOCATED;</span><br><span class="line">dtv[<span class="built_in">map</span>-&gt;l_tls_modid].pointer.to_free = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果这个模块没有静态 TLS offset（NO_TLS_OFFSET），</span></span><br><span class="line"><span class="comment"> * 或者被强制为“动态 TLS”（FORCED_DYNAMIC_TLS_OFFSET），</span></span><br><span class="line"><span class="comment"> * 那就跳过本次处理。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 换句话说：这里只处理“已经有静态 TLS 偏移”的模块，</span></span><br><span class="line"><span class="comment"> * 也就是在 static TLS 区里已经为它预留好空间的情况。 */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">map</span>-&gt;l_tls_offset == NO_TLS_OFFSET</span><br><span class="line">    || <span class="built_in">map</span>-&gt;l_tls_offset == FORCED_DYNAMIC_TLS_OFFSET)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置当前模块在 dtv 中的入口。</span></span><br><span class="line"><span class="comment"> * 对于静态 TLS，dest 是已经算好的该模块 TLS block 起始地址，</span></span><br><span class="line"><span class="comment"> * 直接把它写进 dtv[modid].pointer.val。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注释里说的 “The simplified __tls_get_addr … requires it”</span></span><br><span class="line"><span class="comment"> * 指的是某些平台上静态程序使用精简版 __tls_get_addr 时，</span></span><br><span class="line"><span class="comment"> * 依赖 dtv[modid].pointer.val 里已经填好有效地址。 */</span></span><br><span class="line">dtv[<span class="built_in">map</span>-&gt;l_tls_modid].pointer.val = dest;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 拷贝该模块的 TLS 初始化镜像（.tdata 部分），</span></span><br><span class="line"><span class="comment"> * 然后把剩余部分（.tbss，即未初始化 TLS 区域）清零。 */</span></span><br><span class="line"><span class="built_in">memset</span>(__mempcpy(dest,</span><br><span class="line">                 <span class="built_in">map</span>-&gt;l_tls_initimage,</span><br><span class="line">                 <span class="built_in">map</span>-&gt;l_tls_initimage_size),</span><br><span class="line">       <span class="string">&#x27;\0&#x27;</span>,</span><br><span class="line">       <span class="built_in">map</span>-&gt;l_tls_blocksize - <span class="built_in">map</span>-&gt;l_tls_initimage_size);</span><br></pre></td></tr></table></figure></div>

<p>回到 <code>__pthread_create_2_1</code> 函数，在完成了 <code>pthread</code> 的一系列初始化后调用了 <code>THREAD_COPY_STACK_GUARD</code> 和 <code>THREAD_COPY_POINTER_GUARD</code> 两个宏，这两个宏的展开如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 拷贝当前线程的 stack_guard（栈 canary 种子）到新线程 pd-&gt;header.stack_guard */</span></span><br><span class="line">(pd)-&gt;header.stack_guard = (&#123;</span><br><span class="line">    <span class="comment">/* 通过 typeof 推导出 header.stack_guard 的类型，保证 __value 与之匹配。 */</span></span><br><span class="line">    __typeof((&#123;</span><br><span class="line">        <span class="keyword">struct</span> pthread *__self;</span><br><span class="line">        <span class="comment">/* 从当前线程的 TLS/TCB 中取出 self 指针：</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *   mov %fs:offset(self), __self</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 这里 offset 是 &amp;(((struct pthread *)0)-&gt;header.self) 的偏移量，</span></span><br><span class="line"><span class="comment">         * 即“从 FS.base 到 header.self 字段”的偏移。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">asm</span>(<span class="string">&quot;mov %%fs:%c1,%0&quot;</span></span><br><span class="line">            : <span class="string">&quot;=r&quot;</span>(__self)</span><br><span class="line">            : <span class="string">&quot;i&quot;</span>(((<span class="type">size_t</span>) (&amp;(((<span class="keyword">struct</span> pthread *)<span class="number">0</span>)-&gt;header.self)))));</span><br><span class="line">        __self;</span><br><span class="line">    &#125;)-&gt;header.stack_guard) __value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 编译期断言：per-thread 数据只支持 1 / 4 / 8 字节三种大小。 */</span></span><br><span class="line">    <span class="keyword">_Static_assert</span>(<span class="keyword">sizeof</span>(__value) == <span class="number">1</span></span><br><span class="line">                   || <span class="keyword">sizeof</span>(__value) == <span class="number">4</span></span><br><span class="line">                   || <span class="keyword">sizeof</span>(__value) == <span class="number">8</span>,</span><br><span class="line">                   <span class="string">&quot;size of per-thread data&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 根据字段大小选择合适的 mov 指令从 FS 段加载 stack_guard：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   - sizeof == 1 → movb</span></span><br><span class="line"><span class="comment">     *   - sizeof == 4 → movl</span></span><br><span class="line"><span class="comment">     *   - sizeof == 8 → movq</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * offset = &amp;(((struct pthread *)0)-&gt;header.stack_guard)</span></span><br><span class="line"><span class="comment">     * 同样是 “从 FS.base 到 header.stack_guard” 的偏移。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">sizeof</span>(__value) == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">asm</span> <span class="keyword">volatile</span>(</span><br><span class="line">            <span class="string">&quot;movb %%fs:%P2,%b0&quot;</span></span><br><span class="line">            : <span class="string">&quot;=q&quot;</span>(__value)</span><br><span class="line">            : <span class="string">&quot;0&quot;</span>(<span class="number">0</span>),</span><br><span class="line">              <span class="string">&quot;i&quot;</span>(((<span class="type">size_t</span>) (&amp;(((<span class="keyword">struct</span> pthread *)<span class="number">0</span>)-&gt;header.stack_guard)))));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">sizeof</span>(__value) == <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">asm</span> <span class="keyword">volatile</span>(</span><br><span class="line">            <span class="string">&quot;movl %%fs:%P1,%0&quot;</span></span><br><span class="line">            : <span class="string">&quot;=r&quot;</span>(__value)</span><br><span class="line">            : <span class="string">&quot;i&quot;</span>(((<span class="type">size_t</span>) (&amp;(((<span class="keyword">struct</span> pthread *)<span class="number">0</span>)-&gt;header.stack_guard)))));</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">asm</span> <span class="keyword">volatile</span>(</span><br><span class="line">            <span class="string">&quot;movq %%fs:%P1,%q0&quot;</span></span><br><span class="line">            : <span class="string">&quot;=r&quot;</span>(__value)</span><br><span class="line">            : <span class="string">&quot;i&quot;</span>(((<span class="type">size_t</span>) (&amp;(((<span class="keyword">struct</span> pthread *)<span class="number">0</span>)-&gt;header.stack_guard)))));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 整个语句表达式的值就是 __value */</span></span><br><span class="line">    __value;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 拷贝当前线程的 pointer_guard（指针加密种子）到新线程 pd-&gt;header.pointer_guard */</span></span><br><span class="line">(pd)-&gt;header.pointer_guard = (&#123;</span><br><span class="line">    __typeof((&#123;</span><br><span class="line">        <span class="keyword">struct</span> pthread *__self;</span><br><span class="line">        <span class="comment">/* 同上，从 FS 段中取出当前线程的 self 指针。 */</span></span><br><span class="line">        <span class="keyword">asm</span>(<span class="string">&quot;mov %%fs:%c1,%0&quot;</span></span><br><span class="line">            : <span class="string">&quot;=r&quot;</span>(__self)</span><br><span class="line">            : <span class="string">&quot;i&quot;</span>(((<span class="type">size_t</span>) (&amp;(((<span class="keyword">struct</span> pthread *)<span class="number">0</span>)-&gt;header.self)))));</span><br><span class="line">        __self;</span><br><span class="line">    &#125;)-&gt;header.pointer_guard) __value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">_Static_assert</span>(<span class="keyword">sizeof</span>(__value) == <span class="number">1</span></span><br><span class="line">                   || <span class="keyword">sizeof</span>(__value) == <span class="number">4</span></span><br><span class="line">                   || <span class="keyword">sizeof</span>(__value) == <span class="number">8</span>,</span><br><span class="line">                   <span class="string">&quot;size of per-thread data&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">sizeof</span>(__value) == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">asm</span> <span class="keyword">volatile</span>(</span><br><span class="line">            <span class="string">&quot;movb %%fs:%P2,%b0&quot;</span></span><br><span class="line">            : <span class="string">&quot;=q&quot;</span>(__value)</span><br><span class="line">            : <span class="string">&quot;0&quot;</span>(<span class="number">0</span>),</span><br><span class="line">              <span class="string">&quot;i&quot;</span>(((<span class="type">size_t</span>) (&amp;(((<span class="keyword">struct</span> pthread *)<span class="number">0</span>)-&gt;header.pointer_guard)))));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">sizeof</span>(__value) == <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">asm</span> <span class="keyword">volatile</span>(</span><br><span class="line">            <span class="string">&quot;movl %%fs:%P1,%0&quot;</span></span><br><span class="line">            : <span class="string">&quot;=r&quot;</span>(__value)</span><br><span class="line">            : <span class="string">&quot;i&quot;</span>(((<span class="type">size_t</span>) (&amp;(((<span class="keyword">struct</span> pthread *)<span class="number">0</span>)-&gt;header.pointer_guard)))));</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">asm</span> <span class="keyword">volatile</span>(</span><br><span class="line">            <span class="string">&quot;movq %%fs:%P1,%q0&quot;</span></span><br><span class="line">            : <span class="string">&quot;=r&quot;</span>(__value)</span><br><span class="line">            : <span class="string">&quot;i&quot;</span>(((<span class="type">size_t</span>) (&amp;(((<span class="keyword">struct</span> pthread *)<span class="number">0</span>)-&gt;header.pointer_guard)))));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p>不难看出这两个宏把当前线程（当前 fs 寄存器还没有指向新线程的 TCB）的 TLS 中的 <code>stack_guard</code> 和 <code>pointer_guard</code> 都复制到子线程的 TLS 的对应位置上。<strong>因此可以确定线程的 <code>stack_guard</code> 和 <code>pointer_guard</code> 与主线程相同。</strong></p>
<p>最后需要确定是 fs 寄存器何时被修改，因为 fs 寄存器不能再用户态修改，因此一定是一个系统调用完成了对 fs 寄存器的修改。</p>
<p>通过调试发现，<code>pthread_create-&gt;create_thread-&gt;clone</code> 中的 <code>clone</code> 系统调用完成了对 fs 寄存器的修改。</p>
<h2 id="gdb-调试技巧"><a href="#gdb-调试技巧" class="headerlink" title="gdb 调试技巧"></a>gdb 调试技巧</h2><h3 id="多线程调试"><a href="#多线程调试" class="headerlink" title="多线程调试"></a>多线程调试</h3><h4 id="线程信息"><a href="#线程信息" class="headerlink" title="线程信息"></a>线程信息</h4><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info threads      <span class="comment"># 或 i th</span></span><br></pre></td></tr></table></figure></div>

<p>典型输出（示意）：</p>
<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  Id   Target Id         Frame</span><br><span class="line">* 1    Thread 0x7ffff7fc (LWP 1234)  main () at main.c:42</span><br><span class="line">  2    Thread 0x7fffef00 (LWP 1235)  worker () at worker.c:100</span><br><span class="line">  3    Thread 0x7fffdf00 (LWP 1236)  worker () at worker.c:100</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>*</code> 前缀那一行是 <strong>当前线程</strong>。</li>
<li>左边的 <code>1,2,3</code> 是 <strong>GDB 自己的线程号</strong>（gdb thread id），跟 LWP&#x2F;TID 不是一个东西。</li>
<li>GDB 有个方便变量 <code>$_thread</code>，值就是当前线程的这个 gdb 线程号，可以在条件里用。</li>
</ul>
<p>切换线程：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) thread 3          <span class="comment"># 切到 gdb 线程号 3</span></span><br><span class="line">(gdb) bt</span><br><span class="line">(gdb) info locals</span><br></pre></td></tr></table></figure></div>

<p>一次性把所有线程的栈打出来：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">set</span> pagination off        <span class="comment"># 建议放到 ~/.gdbinit</span></span><br><span class="line">(gdb) thread apply all bt</span><br><span class="line">(gdb) thread apply all bt full  <span class="comment"># 带局部变量</span></span><br></pre></td></tr></table></figure></div>

<h4 id="断点技巧"><a href="#断点技巧" class="headerlink" title="断点技巧"></a>断点技巧</h4><p><strong>按线程号下断点：</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">break</span> worker.c:42 thread 3</span><br><span class="line"><span class="comment"># 只有 gdb 线程 3 跑到 worker.c:42 才会停</span></span><br></pre></td></tr></table></figure></div>

<p><strong>条件断点：</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">break</span> worker.c:42 <span class="keyword">if</span> i &gt; 1000</span><br><span class="line">(gdb) <span class="built_in">break</span> handle_request <span class="keyword">if</span> tid == 5</span><br><span class="line">(gdb) <span class="built_in">break</span> foo.c:100 <span class="keyword">if</span> <span class="variable">$_thread</span> == 5   <span class="comment"># 只对 gdb 线程 5 生效</span></span><br></pre></td></tr></table></figure></div>

<p><code>$_thread</code> 是当前线程的 gdb 线程号，专门拿来做这种条件判断的。</p>
<p>你很多需求是：</p>
<blockquote>
<p>跑的时候在某一行打印点东西，<strong>不要真正停下来</strong>。</p>
</blockquote>
<p>这用 <code>dprintf</code> 最合适：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 foo.c:100 打印 i 和当前线程号，打印后自动继续</span></span><br><span class="line">(gdb) dprintf foo.c:100, <span class="string">&quot;hit foo: i=%d, thread=%d\n&quot;</span>, i, <span class="variable">$_thread</span></span><br></pre></td></tr></table></figure></div>

<p>只对某个线程打印，用条件：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) dprintf foo.c:100, <span class="string">&quot;hit foo: i=%d, thread=%d\n&quot;</span>, i, <span class="variable">$_thread</span></span><br><span class="line">(gdb) condition <span class="variable">$bpnum</span> <span class="variable">$_thread</span> == 5</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>dprintf</code> &#x3D; 断点 + 打印 + 自动 continue。</li>
<li><code>$bpnum</code> 是刚刚创建的这个断点的编号。</li>
</ul>
<p>这个命令非常适合当作“动态 printf 调试”，不用改代码、不用 <code>commands + continue</code> 那一套。</p>
<p>在裸 gdb 里这么写没问题，但在 pwndbg 环境里，这个 <code>continue</code> 有可能把调试器锁死：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">break foo.c:100</span><br><span class="line">commands</span><br><span class="line">    silent</span><br><span class="line">    if $_thread != 5</span><br><span class="line">        continue</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    printf &quot;&gt;&gt;&gt; interesting thread %d here!\n&quot;, $_thread</span><br><span class="line">    bt</span><br><span class="line">end</span><br></pre></td></tr></table></figure></div>

<p><strong>pwndbg 规避写法：把 <code>continue</code> 换成 Python 的 <code>gdb.execute(&quot;continue&quot;)</code></strong></p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">break foo.c:100</span><br><span class="line">commands</span><br><span class="line">    silent</span><br><span class="line">    if $_thread != 5</span><br><span class="line">        # 用 Python 调 GDB 命令，绕过 pwndbg 的 stop-event 坑</span><br><span class="line">        pi import gdb; gdb.execute(&quot;continue&quot;)</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    printf &quot;&gt;&gt;&gt; interesting thread %d here!\n&quot;, $_thread</span><br><span class="line">    bt</span><br><span class="line">end</span><br></pre></td></tr></table></figure></div>

<p>这里的 <code>pi</code> 是 <code>python-interactive</code> 的缩写，相当于一行 Python：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line">import gdb</span><br><span class="line">gdb.execute(&quot;continue&quot;)</span><br><span class="line">end</span><br></pre></td></tr></table></figure></div>

<p>这个写法就是你记得的那句：<strong>“在 pwndbg 的脚本里不能直接写 continue，要用个 python 语句”</strong>。</p>
<h4 id="相关设置"><a href="#相关设置" class="headerlink" title="相关设置"></a>相关设置</h4><blockquote>
<p><strong>all-stop vs non-stop —— “谁会被停下来”</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">set</span> non-stop off            <span class="comment"># 默认</span></span><br><span class="line">(gdb) <span class="built_in">set</span> non-stop on</span><br></pre></td></tr></table></figure></div>

<p><strong>all-stop（默认）</strong>：</p>
<blockquote>
<p>任意一个线程因为断点 &#x2F; 单步 &#x2F; 信号停了，<br>👉 这个进程里的<strong>所有线程都一起停</strong>。</p>
</blockquote>
<p><strong>non-stop</strong>：</p>
<blockquote>
<p>每个线程独立：<br>某个线程 hit 断点，它停；<br>其他线程可以继续跑，不会自动一起停。</p>
</blockquote>
<p>这是“<strong>停的语义</strong>”：</p>
<ul>
<li>all-stop：一停全停；</li>
<li>non-stop：谁撞断点，谁停，其它照跑。</li>
</ul>
<p><strong>scheduler-locking —— “从停恢复时，谁能继续跑”</strong></p>
<p><code>scheduler-locking</code> 是另一个开关，只在你从断点继续&#x2F;单步时起作用：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">set</span> scheduler-locking off   <span class="comment"># 默认：继续时所有线程都可以跑</span></span><br><span class="line">(gdb) <span class="built_in">set</span> scheduler-locking on    <span class="comment"># 继续/单步时只让当前线程跑</span></span><br><span class="line">(gdb) <span class="built_in">set</span> scheduler-locking step  <span class="comment"># 单步时只当前线程跑，continue 时所有线程跑</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>它<strong>不改变“谁会被停住”</strong>，只改变：</p>
<p>👉 “你敲 <code>continue/next/step</code> 之后，哪些线程会动”。</p>
</blockquote>
</blockquote>
<p>多线程单步时常见场景：</p>
<blockquote>
<p>在 2 号线程里 <code>next</code>，结果 3 号线程先跑了一堆，屏幕上全是别的线程的日志。</p>
</blockquote>
<p>这时候用：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">set</span> scheduler-locking off   <span class="comment"># 默认：谁都能跑</span></span><br><span class="line">(gdb) <span class="built_in">set</span> scheduler-locking on    <span class="comment"># 只有当前线程能跑</span></span><br><span class="line">(gdb) <span class="built_in">set</span> scheduler-locking step  <span class="comment"># 单步时只让当前线程跑，continue 时恢复</span></span><br></pre></td></tr></table></figure></div>

<p>一般推荐：</p>
<ul>
<li>平时用默认 <code>off</code>；</li>
<li>调某一个线程逻辑时·用 <code>set scheduler-locking step</code>，单步时不被其他线程抢。</li>
</ul>
<p>注意：</p>
<p>如果当前线程卡在 <code>pthread_mutex_lock</code>，又设成 <code>on</code>，那真正持锁的线程永远不跑，整个程序就被你锁死了。</p>
<p>默认是 all-stop：一个线程停，全停。</p>
<p>non-stop 则允许某些线程停，其他线程继续：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set target-async on</span><br><span class="line">(gdb) set non-stop on</span><br><span class="line">(gdb) run</span><br></pre></td></tr></table></figure></div>

<p>然后你可以：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) thread 3</span><br><span class="line">(gdb) continue        # 只让 3 号线程跑</span><br></pre></td></tr></table></figure></div>

<h3 id="多进程调试"><a href="#多进程调试" class="headerlink" title="多进程调试"></a>多进程调试</h3><p>真多进程调试时基本靠四个东西：</p>
<ul>
<li><code>set follow-fork-mode parent|child</code></li>
<li><code>set detach-on-fork on|off</code></li>
<li><code>set follow-exec-mode same|new</code></li>
<li><code>catch fork / catch exec</code></li>
</ul>
<h4 id="只跟父-or-只跟子：follow-fork-mode"><a href="#只跟父-or-只跟子：follow-fork-mode" class="headerlink" title="只跟父 or 只跟子：follow-fork-mode"></a>只跟父 or 只跟子：<code>follow-fork-mode</code></h4><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">set</span> follow-fork-mode parent   <span class="comment"># 默认，跟父</span></span><br><span class="line">(gdb) <span class="built_in">set</span> follow-fork-mode child    <span class="comment"># 改成跟子</span></span><br></pre></td></tr></table></figure></div>

<p>例如：启动器 <code>fork</code> 出干活的 worker，你只想调 worker：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">set</span> follow-fork-mode child</span><br><span class="line">(gdb) run</span><br></pre></td></tr></table></figure></div>

<p>fork 后，gdb 会自动切到子进程继续调。</p>
<h4 id="同时调父子：detach-on-fork-off-多-inferiors"><a href="#同时调父子：detach-on-fork-off-多-inferiors" class="headerlink" title="同时调父子：detach-on-fork off + 多 inferiors"></a>同时调父子：<code>detach-on-fork off</code> + 多 inferiors</h4><p>想父子进程都在 gdb 手里：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">set</span> follow-fork-mode parent</span><br><span class="line">(gdb) <span class="built_in">set</span> detach-on-fork off</span><br><span class="line">(gdb) run</span><br></pre></td></tr></table></figure></div>

<p>fork 之后：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info inferiors</span><br><span class="line">  Id   Description   Executable</span><br><span class="line">* 1    &lt;null&gt;        ./prog</span><br><span class="line">  2    &lt;null&gt;        ./prog    <span class="comment"># fork 出来的子</span></span><br><span class="line"></span><br><span class="line">(gdb) inferior 2</span><br><span class="line">(gdb) info threads</span><br><span class="line">(gdb) bt</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>inferior N</code>：切换当前进程；</li>
<li>在每个 inferiors 里你还能 <code>thread apply all bt</code>。</li>
</ul>
<p>不要某个进程了：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) detach inferiors 2   <span class="comment"># 放飞 2 号进程</span></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">(gdb) <span class="built_in">kill</span> inferiors 2     <span class="comment"># 杀掉 2 号进程</span></span><br></pre></td></tr></table></figure></div>

<h4 id="处理-exec：follow-exec-mode"><a href="#处理-exec：follow-exec-mode" class="headerlink" title="处理 exec：follow-exec-mode"></a>处理 exec：<code>follow-exec-mode</code></h4><p>很多程序是：</p>
<blockquote>
<p>父进程 fork 子进程 → 子进程 <code>exec</code> 真正的程序。</p>
</blockquote>
<p><code>follow-exec-mode</code> 决定 exec 时 gdb 怎么处理当前 inferior：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">set</span> follow-exec-mode same   <span class="comment"># 默认</span></span><br><span class="line">(gdb) <span class="built_in">set</span> follow-exec-mode new</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>same</code>：当前 inferior 直接变成新程序，之后 <code>run</code> 也跑新程序；</li>
<li><code>new</code>：exec 时新建一个 inferior，旧的还保留着旧程序的信息。</li>
</ul>
<p>如果你就是冲着“fork 之后的那坨新程序”来的，一般组合是：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> follow-fork-mode child</span><br><span class="line"><span class="built_in">set</span> detach-on-fork off</span><br><span class="line"><span class="built_in">set</span> follow-exec-mode same    <span class="comment"># 或 new，看个人习惯</span></span><br></pre></td></tr></table></figure></div>

<h4 id="精确卡在-fork-exec：catch"><a href="#精确卡在-fork-exec：catch" class="headerlink" title="精确卡在 fork &#x2F; exec：catch"></a>精确卡在 fork &#x2F; exec：<code>catch</code></h4><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) catch fork</span><br><span class="line">(gdb) catch <span class="built_in">exec</span></span><br><span class="line">(gdb) run</span><br></pre></td></tr></table></figure></div>

<p>每次 fork &#x2F; exec 时都会停一下，你可以立刻 <code>bt</code> 看是谁调用的。</p>
<p>一个经典例子：<strong>在 exec 之后的 <code>main</code> 上断</strong>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">set</span> follow-fork-mode child</span><br><span class="line">(gdb) catch <span class="built_in">exec</span></span><br><span class="line">(gdb) run</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一次停在 exec 调用点</span></span><br><span class="line">(gdb) <span class="built_in">continue</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># exec 完成，加载了新程序，再停一次</span></span><br><span class="line">(gdb) <span class="built_in">break</span> main</span><br><span class="line">(gdb) <span class="built_in">continue</span></span><br></pre></td></tr></table></figure></div>

<p>这样即使一开始没新程序的符号，也能在 exec 后补断点。</p>
<h1 id="常见保护"><a href="#常见保护" class="headerlink" title="常见保护"></a>常见保护</h1><p><code>checksec</code> 可以查看程序开启了哪些保护。</p>
<p>该命令通常对应两种：</p>
<ul>
<li><p>通过 <code>apt</code> 安装的 <code>checksec</code>。 </p>
</li>
<li><p><code>pwntools</code> 安装时注册的一个 <strong>console_scripts entry point</strong>，不过需要 <code>root</code> 权限安装才能直接在命令行使用。</p>
</li>
</ul>
<pre><font color="#26A269"><b>➜  </b></font><font color="#2AA1B3"><b>~</b></font> <font color="#26A269">/usr/bin/checksec</font> --file=/bin/ls
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH	Symbols		FORTIFY	Fortified	Fortifiable	FILE
<font color="#26A269">Full RELRO   </font>   <font color="#26A269">Canary found   </font>   <font color="#26A269">NX enabled </font>   <font color="#26A269">PIE enabled  </font>   <font color="#26A269">No RPATH </font>  <font color="#26A269">No RUNPATH </font>  <font color="#26A269">No Symbols</font>	  <font color="#26A269">Yes</font>	6		18		/bin/ls
<font color="#26A269"><b>➜  </b></font><font color="#2AA1B3"><b>~</b></font> <font color="#26A269">/usr/local/bin/checksec</font> <u style="text-decoration-style:single">/bin/ls</u>
[<font color="#12488B"><b>*</b></font>] &apos;/bin/ls&apos;
    Arch:       amd64-64-little
    RELRO:      <font color="#26A269">Full RELRO</font>
    Stack:      <font color="#26A269">Canary found</font>
    NX:         <font color="#26A269">NX enabled</font>
    PIE:        <font color="#26A269">PIE enabled</font>
    FORTIFY:    <font color="#26A269">Enabled</font>
    SHSTK:      <font color="#26A269">Enabled</font>
    IBT:        <font color="#26A269">Enabled</font>
</pre>

<h2 id="RELRO（Relocation-Read-Only）"><a href="#RELRO（Relocation-Read-Only）" class="headerlink" title="RELRO（Relocation Read-Only）"></a>RELRO（Relocation Read-Only）</h2><p>传统 ELF 里有一块非常关键又非常危险的数据区：<strong>GOT（Global Offset Table，全局偏移表）</strong>。</p>
<ul>
<li>程序调用外部函数（如 <code>printf</code>）时，会通过 PLT&#x2F;GOT 间接跳转；</li>
<li>如果攻击者能改写 GOT 表里的“函数地址”，就能把 <code>printf</code> 改成 <code>system</code> 或直接跳到任意 gadget——典型的 GOT 覆写劫持控制流。</li>
</ul>
<p><strong>RELRO 的目的</strong>：</p>
<blockquote>
<p>把运行时不需要再修改的重定位相关段（尤其是 GOT）在程序启动时就重定位完，然后改成只读，防止被写。</p>
</blockquote>
<h3 id="原理解释"><a href="#原理解释" class="headerlink" title="原理解释"></a>原理解释</h3><p>链接时加 <code>-Wl,-z,relro</code>，ld 会在 ELF 里创建一个 <strong><code>PT_GNU_RELRO</code> 程序头</strong>，对应一段内存区域，里面通常放：</p>
<ul>
<li><code>.init_array</code> &#x2F; <code>.fini_array</code> &#x2F; <code>.jcr</code></li>
<li><code>.dynamic</code></li>
<li><code>.got</code> 和 <code>.got.plt</code> 的前几个 entry（具体和实现有关）</li>
</ul>
<p>动态链接器加载完之后，会在<strong>完成对这些区域的重定位之后</strong>，对 <code>PT_GNU_RELRO</code> 覆盖的内存调用 <code>mprotect(PROT_READ, …)</code>，也就是“<strong>把这块只读化</strong>”。这就是“Relocation Read-Only”的由来。</p>
<blockquote>
<p>关键点：<strong>是 loader 在运行时 <code>mprotect</code>，而不是编译期就只读</strong>。否则启动时没法往 GOT &#x2F; <code>.init_array</code> 里写重定位结果。</p>
</blockquote>
<h3 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h3><p>checksec 一般会显示三档：</p>
<ul>
<li><p><strong>No RELRO</strong></p>
<ul>
<li>编译&#x2F;链接时使用 <code>-Wl,-z,norelro</code>，或者干脆没启用 relro（老工具链默认）。</li>
<li><code>.got</code> 和 <code>.got.plt</code> 以及 <code>.init_array</code> &#x2F; <code>.fini_array</code> 所在的页都是普通 <code>RW</code> 数据段。</li>
</ul>
</li>
<li><p><strong>Partial RELRO</strong>（部分 RELRO）</p>
<ul>
<li>使用了 <code>-Wl,-z,relro</code>，但没配 <code>-Wl,-z,now</code>；</li>
<li>loader 会把 <strong>非 PLT 部分的 <code>.got</code></strong> 放在 <code>PT_GNU_RELRO</code>，完成重定位后将其设为只读；但 <code>.got.plt</code> 仍然可写，以便 lazy binding 时动态写入函数真实地址。</li>
<li>结果就是 <code>.init_array</code> &#x2F; <code>.fini_array</code> 等“析构&#x2F;构造”数组被放到了只读区域；<code>.got</code>（非 PLT 部分）只读；但 <strong><code>got.plt</code> 仍然可写</strong>；也就是说 <strong>Partial RELRO 仍然可以 GOT 覆写，只是“锁了一部分 GOT 和 init&#x2F;fini 数组”。</strong></li>
</ul>
</li>
<li><p><strong>Full RELRO</strong>（完全 RELRO）</p>
<ul>
<li>同时使用 <code>-Wl,-z,relro -Wl,-z,now</code>；或者开启了 <code>-Wl,-z,now</code>，在现代发行版中通常就会默认加上 <code>-z relro</code>。</li>
<li>Full RELRO 在 Partial 的基础上多做了两件事：<ul>
<li><strong>禁用 lazy binding</strong>：<code>-z now</code> &#x2F; <code>BIND_NOW</code> 要求 loader 在程序启动时就解析<strong>所有导入符号</strong>，包括 PLT 的函数引用。</li>
<li>因为不再需要在运行时修改 <code>.got.plt</code>，所以 loader 可以在完成绑定后，<strong>把 <code>.got.plt</code> 也一起设成只读</strong>。</li>
</ul>
</li>
<li><code>.got</code> + <code>.got.plt</code> 全部在 <code>PT_GNU_RELRO</code> 段下，被 <code>mprotect</code> 成只读；<code>.init_array</code> &#x2F; <code>.fini_array</code> 等也同样只读；代价是：所有符号启动时就解析完，<strong>启动时间略有增加</strong>，所以很多库&#x2F;程序为了启动性能只开 Partial。</li>
</ul>
</li>
</ul>
<h2 id="Stack-Canary"><a href="#Stack-Canary" class="headerlink" title="Stack Canary"></a>Stack Canary</h2><p><strong>Canary（Stack Smashing Protector，SSP）</strong> 是编译器插的一种防御机制，用来检测栈上的缓冲区溢出。</p>
<h3 id="原理解释-1"><a href="#原理解释-1" class="headerlink" title="原理解释"></a>原理解释</h3><p>Canary 保护的基本思路是在局部变量（特别是数组）和控制数据（<code>saved RBP</code> &#x2F; 返回地址）之间插一个<strong>随机值</strong>，函数返回前检查这个值有没有被改，如果被改了就直接崩溃而不是正常 <code>ret</code>。</p>
<p>如果某个栈上的数组发生溢出，要想覆盖到返回地址，<strong>几乎必然要先踩到 canary</strong>。在函数返回时，如果 canary 被改动，就调用 <code>__stack_chk_fail</code> 直接终止程序。</p>
<p>GCC + glibc 的 SSP 逻辑（x86‑64）如下：</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span>    <span class="built_in">rbp</span></span><br><span class="line"><span class="keyword">mov</span>     <span class="built_in">rbp</span>, <span class="built_in">rsp</span></span><br><span class="line"><span class="keyword">sub</span>     <span class="built_in">rsp</span>, <span class="number">0x30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; --- 取 TLS 中的“主 canary”，保存到当前栈帧 ---</span></span><br><span class="line"><span class="keyword">mov</span>     <span class="built_in">rax</span>, <span class="built_in">qword</span> <span class="built_in">ptr</span> <span class="built_in">fs</span>:<span class="number">0x28</span>  <span class="comment">; rax = TLS 里的 stack_guard（主 canary）</span></span><br><span class="line"><span class="keyword">mov</span>     [<span class="built_in">rbp</span>-<span class="number">0x8</span>], <span class="built_in">rax</span>          <span class="comment">; 把 canary 备份到当前栈帧（[rbp-8]）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; ... 这里是函数主体，可能有对栈上缓冲区的操作 ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; --- 函数返回前：检查栈上的 canary 是否被破坏 ---</span></span><br><span class="line"><span class="keyword">mov</span>     <span class="built_in">rdx</span>, [<span class="built_in">rbp</span>-<span class="number">0x8</span>]          <span class="comment">; 取出栈上的 canary 副本</span></span><br><span class="line"><span class="keyword">xor</span>     <span class="built_in">rdx</span>, <span class="built_in">qword</span> <span class="built_in">ptr</span> <span class="built_in">fs</span>:<span class="number">0x28</span>  <span class="comment">; 和 TLS 中的 canary 做异或比较</span></span><br><span class="line"><span class="keyword">jz</span>      .Lret_ok                <span class="comment">; 结果为 0 → 没被改，安全</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; canary 被改：认为发生栈溢出，直接调用异常处理函数</span></span><br><span class="line"><span class="keyword">call</span>    __stack_chk_fail        <span class="comment">; 一般里面会打印错误并 abort()</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">.Lret_ok:</span></span><br><span class="line"><span class="keyword">leave</span></span><br><span class="line"><span class="keyword">ret</span> </span><br></pre></td></tr></table></figure></div>

<p><code>pwndbg</code> 中的 <code>canary</code> 命令可以查看 <code>canary</code> 的值以及在栈上存储的位置。</p>
<pre><font color="#26A269"><b>pwndbg&gt; </b></font>canary --help
usage: canary [-h] [-a]

Print out the current stack canary.

options:
  -h, --help  show this help message and exit
  -a, --all   Print out stack canaries for all threads instead of the current thread only.
<font color="#26A269"><b>pwndbg&gt; </b></font>canary
<font color="#A347BA">AT_RANDOM  = 0x7fffffffe3a9 # points to global canary seed value</font>
<font color="#A347BA">TLS Canary = 0x7ffff7ee3828 # address where canary is stored</font>
<font color="#A347BA">Canary     = 0xc4049b4e3a9f4700 (may be incorrect on != glibc)</font>
<font color="#26A269">Thread 1: Found valid canaries.</font>
00:0000│  <font color="#A2734C">0x7fffffffb528</font> ◂— 0xc4049b4e3a9f4700
<font color="#A2734C">Additional results hidden. Use --all to see them.</font>
<font color="#26A269"><b>pwndbg&gt; </b></font>canary --all
<font color="#A347BA">AT_RANDOM  = 0x7fffffffe3a9 # points to global canary seed value</font>
<font color="#A347BA">TLS Canary = 0x7ffff7ee3828 # address where canary is stored</font>
<font color="#A347BA">Canary     = 0xc4049b4e3a9f4700 (may be incorrect on != glibc)</font>
<font color="#26A269">Thread 1: Found valid canaries.</font>
00:0000│  <font color="#A2734C">0x7fffffffb528</font> ◂— 0xc4049b4e3a9f4700
00:0000│  <font color="#A2734C">0x7fffffffb768</font> ◂— 0xc4049b4e3a9f4700
00:0000│  <font color="#A2734C">0x7fffffffb848</font> ◂— 0xc4049b4e3a9f4700
00:0000│  <font color="#A2734C">0x7fffffffb998</font> ◂— 0xc4049b4e3a9f4700
00:0000│  <font color="#A2734C">0x7fffffffbae8</font> ◂— 0xc4049b4e3a9f4700
00:0000│  <font color="#A2734C">0x7fffffffdad8</font> ◂— 0xc4049b4e3a9f4700
00:0000│  <font color="#A2734C">0x7fffffffdae8</font> ◂— 0xc4049b4e3a9f4700
00:0000│  <font color="#A2734C">0x7fffffffdf08</font> ◂— 0xc4049b4e3a9f4700
00:0000│  <font color="#A2734C">0x7fffffffdfd8</font> ◂— 0xc4049b4e3a9f4700
</pre>

<p>glibc 通常把 <strong>最低一个字节设为 0</strong>。这样一来 canary 的 0 字节会截断字符串，导致难以泄露整个 canary。</p>
<h3 id="编译选项-1"><a href="#编译选项-1" class="headerlink" title="编译选项"></a>编译选项</h3><p>GCC &#x2F; Clang 的 SSP 相关选项：</p>
<ul>
<li><p><code>-fstack-protector</code></p>
<ul>
<li><p>对“看起来危险”的函数插 canary：</p>
<ul>
<li>有较大局部数组（&gt; 8 字节）</li>
<li>调用了 <code>alloca</code></li>
<li>等等（有个 heuristic）。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>-fstack-protector-strong</code>（很多发行版默认）</p>
<ul>
<li><p>比 <code>-fstack-protector</code> 严格，会覆盖更多函数，包括：</p>
<ul>
<li>有局部数组；</li>
<li>取了局部变量地址；</li>
<li>某些其它模式。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>-fstack-protector-all</code></p>
<ul>
<li><strong>所有函数</strong>都插 canary，最狠也最慢。</li>
</ul>
</li>
<li><p><code>-fno-stack-protector</code></p>
<ul>
<li><p>显式关掉当前编译单元里的 SSP：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fno-stack-protector a.c -o a</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>但注意几点：</p>
<ul>
<li>这个只对 <strong>你正在编的 .c 文件</strong> 生效；</li>
<li>系统库（libc 等）本身是单独编译的，即使你关了，你调用的库函数内部依然可能有自己的 canary；</li>
<li>某些函数可以带 <code>__attribute__((stack_protect))</code> &#x2F; <code>__attribute__((stack_protect_strong))</code> 之类属性，<strong>会覆盖编译选项</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="NX（No-eXecute）"><a href="#NX（No-eXecute）" class="headerlink" title="NX（No-eXecute）"></a>NX（No-eXecute）</h2><p><strong>NX &#x3D; No-eXecute bit</strong>，是 <strong>CPU 页表里的一个硬件位</strong>：</p>
<ul>
<li>在 x86 上，它是页表项里的“不可执行标志”（AMD 叫 NX、Intel 叫 XD）。</li>
<li>OS（Linux、Windows 等）如果支持 NX，就可以在某一页的 PTE 上把 NX 位置 1，表示“<strong>这页只能当数据用，不能取指执行</strong>”。</li>
<li>CPU 取指到标了 NX 的页，会直接触发异常（Linux 下就是 segfault），而不是执行里面的内容。</li>
</ul>
<p>所以从硬件和内核角度看，NX 做的是：</p>
<blockquote>
<p><strong>把虚拟地址空间里的“可执行代码”和“纯数据”区域区分开。</strong></p>
</blockquote>
<p>常见的安全效果：栈、堆、全局变量这些“用户可控数据”页默认都是 <strong>RW &#x2F; 不可执行</strong>；</p>
<h3 id="编译选项-2"><a href="#编译选项-2" class="headerlink" title="编译选项"></a>编译选项</h3><p>现代 Linux + gcc 一般 <strong>默认就是 NX 打开的</strong>，也就是说：</p>
<ul>
<li>CPU 支持 NX；</li>
<li>kernel 会把栈、堆、bss 都设置成非执行；</li>
<li>GCC&#x2F;ld 产生的 ELF 默认会加 <code>PT_GNU_STACK: R W</code>（非 X）。</li>
</ul>
<p><strong>关闭 NX 保护的方法有：</strong></p>
<p><strong>方法 1：编译时加 <code>-z execstack</code></strong></p>
<p><code>-z</code> 是链接器（<code>ld</code>）的选项，gcc 会帮你转发过去：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc a.c -z execstack -o a</span><br><span class="line"><span class="comment"># 等价于 gcc a.c -Wl,-z,execstack -o a</span></span><br></pre></td></tr></table></figure></div>

<p>这样：</p>
<ul>
<li>链接出来的 ELF 会把 <code>PT_GNU_STACK</code> 标成 <code>RWE</code>（栈可执行）；([novafacing][8])</li>
<li>loader 加载时就会给你分配一个可执行栈；</li>
<li><code>checksec</code> 会显示 <code>NX disabled</code>（从 CTF 视角就是“可以往栈上打 shellcode 跳过去了”）。</li>
</ul>
<p><strong>方法 2：对现成的 binary 用 <code>execstack</code> 工具修改</strong></p>
<p>有 <code>execstack</code> 这个小工具可以改已经编好的 ELF：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">execstack -q ./a       <span class="comment"># 看栈是否可执行</span></span><br><span class="line">execstack -s ./a       <span class="comment"># 设置为 execstack（可执行栈）</span></span><br><span class="line">execstack -c ./a       <span class="comment"># 设置为 noexecstack（不可执行栈）</span></span><br></pre></td></tr></table></figure></div>

<p>这个实质就是在改 ELF 里的 <code>PT_GNU_STACK</code> 权限标志。</p>
<h3 id="原理解释-2"><a href="#原理解释-2" class="headerlink" title="原理解释"></a>原理解释</h3><p>大部分版本的 <code>checksec</code> &#x2F; <code>pwn checksec</code> 的 NX 一栏，做的事情都是类似：</p>
<ol>
<li><p>读取 ELF 的 program header；</p>
</li>
<li><p>找到 <code>PT_GNU_STACK</code> 这个条目；</p>
</li>
<li><p>看它的 <code>p_flags</code> 里有没有 <code>PF_X</code>（可执行）位：</p>
<ul>
<li>如果 <code>GNU_STACK</code> 是 <code>RW</code> → <code>NX enabled</code>（栈不可执行）；</li>
<li>如果 <code>GNU_STACK</code> 是 <code>RWE</code> → <code>NX disabled</code>（栈可执行）。</li>
</ul>
</li>
</ol>
<p>所以：</p>
<blockquote>
<p><strong>checksec 的 “NX disabled” 其实只说明“栈是可执行的”，完全不保证“堆也可执行”。</strong></p>
</blockquote>
<p>早期很多内核（2.6&#x2F;3.x 到较老的 4.x）上，有这么一段逻辑（<code>fs/binfmt_elf.c</code> 中 <code>load_elf_binary</code>）：</p>
<ol>
<li><p>解析 <code>PT_GNU_STACK</code>，算出 <code>executable_stack</code> 是 <code>ENABLE_X / DISABLE_X / DEFAULT</code>；</p>
</li>
<li><p>调用 <code>elf_read_implies_exec(ex, executable_stack)</code>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> elf_read_implies_exec(ex, executable_stack) \</span></span><br><span class="line"><span class="meta">    (executable_stack != EXSTACK_DISABLE_X)</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>如果返回 true，就给当前进程 personality 加上标志 <code>READ_IMPLIES_EXEC</code>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (elf_read_implies_exec(loc-&gt;elf_ex, executable_stack))</span><br><span class="line">    current-&gt;personality |= READ_IMPLIES_EXEC;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p>这个 <code>READ_IMPLIES_EXEC</code> 在 <code>do_mmap_pgoff()</code> 里有特殊处理：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Does the application expect PROT_READ to imply PROT_EXEC? */</span></span><br><span class="line"><span class="keyword">if</span> ((prot &amp; PROT_READ) &amp;&amp; (current-&gt;personality &amp; READ_IMPLIES_EXEC))</span><br><span class="line">    prot |= PROT_EXEC;</span><br></pre></td></tr></table></figure></div>

<p>也就是说：</p>
<blockquote>
<p>只要进程开了 <code>READ_IMPLIES_EXEC</code>，**所有用 <code>PROT_READ</code> 映射的页都会自动加上 <code>PROT_EXEC</code>**——堆、数据段全部变成 RX 或 RWX。</p>
</blockquote>
<p>而老版本内核里，**只要你把 <code>PT_GNU_STACK</code> 设为可执行（<code>-z execstack</code> 或 execstack）就会触发 <code>READ_IMPLIES_EXEC</code>**。</p>
<p>结果就是你在老 Ubuntu 上看到的效果：</p>
<ul>
<li>用 <code>-z execstack</code> 编译；</li>
<li>checksec 显示 “NX disabled”（栈可执行）；</li>
<li>实际上 heap &#x2F; .data 也都变可执行：因为所有 R 页被自动加了 X。</li>
</ul>
<p>后来大家都觉得这种行为太危险，于是内核做了改动：</p>
<ul>
<li>在 x86‑64 上，**不再因为 <code>PT_GNU_STACK</code> 就自动开启 <code>READ_IMPLIES_EXEC</code>**；</li>
<li>默认策略改成“除非显式要 PROT_EXEC，否则所有匿名映射都是 NX”。</li>
</ul>
<p>在 Linux 5.8-rc1 之后，<code>READ_IMPLIES_EXEC</code> 在 x86‑64 上被禁用，即使 <code>PT_GNU_STACK</code> 设置了 <code>PF_X</code> 也不会再让所有页都可执行。所以在 <strong>新一点的 Ubuntu（内核 5.8+，比如 20.04 更新后、22.04 这些）</strong> 上：</p>
<ul>
<li><code>-z execstack</code> &#x2F; execstack：<ul>
<li>只会把 <strong>栈段</strong> 映射成 RWE；</li>
<li>不再触发 <code>READ_IMPLIES_EXEC</code>；</li>
</ul>
</li>
<li>堆还是按正常方式通过 <code>mmap(PROT_READ|PROT_WRITE)</code> 创建 → <strong>RW，但没有 X</strong>；</li>
</ul>
<h2 id="PIE（Position-Independent-Executable）"><a href="#PIE（Position-Independent-Executable）" class="headerlink" title="PIE（Position Independent Executable）"></a>PIE（Position Independent Executable）</h2><p>没有 PIE 时，可执行文件的 <code>.text</code> 段通常加载在一个<strong>固定基址</strong>（如 <code>0x400000</code>）。</p>
<pre><font color="#26A269"><b>pwndbg&gt; </b></font>vmmap
LEGEND: <font color="#A2734C">STACK</font> | <font color="#12488B">HEAP</font> | <font color="#C01C28">CODE</font> | <font color="#A347BA">DATA</font> | <font color="#C01C28"><u style="text-decoration-style:single">WX</u></font> | RODATA
             Start                End Perm     Size Offset File (set vmmap-prefer-relpaths on)
          0x400000           0x401000 r--p     1000      0 pwn
<font color="#C01C28">          0x401000           0x402000 r-xp     1000   1000 pwn</font>
          0x402000           0x403000 r--p     1000   2000 pwn
          0x403000           0x404000 r--p     1000   2000 pwn
<font color="#A347BA">          0x404000           0x405000 rw-p     1000   3000 pwn</font>
    0x7ffff7c00000     0x7ffff7c28000 r--p    28000      0 /usr/lib/x86_64-linux-gnu/libc.so.6
<font color="#C01C28">    0x7ffff7c28000     0x7ffff7dbd000 r-xp   195000  28000 /usr/lib/x86_64-linux-gnu/libc.so.6</font>
    0x7ffff7dbd000     0x7ffff7e15000 r--p    58000 1bd000 /usr/lib/x86_64-linux-gnu/libc.so.6
<font color="#2AA1B3">    0x7ffff7e15000     0x7ffff7e16000 ---p     1000 215000 /usr/lib/x86_64-linux-gnu/libc.so.6</font>
    0x7ffff7e16000     0x7ffff7e1a000 r--p     4000 215000 /usr/lib/x86_64-linux-gnu/libc.so.6
<font color="#A347BA">    0x7ffff7e1a000     0x7ffff7e1c000 rw-p     2000 219000 /usr/lib/x86_64-linux-gnu/libc.so.6</font>
<font color="#A347BA">    0x7ffff7e1c000     0x7ffff7e29000 rw-p     d000      0 [anon_7ffff7e1c]</font>
<font color="#A347BA">    0x7ffff7fa6000     0x7ffff7fa9000 rw-p     3000      0 [anon_7ffff7fa6]</font>
<font color="#A347BA">    0x7ffff7fbb000     0x7ffff7fbd000 rw-p     2000      0 [anon_7ffff7fbb]</font>
    0x7ffff7fbd000     0x7ffff7fc1000 r--p     4000      0 [vvar]
<font color="#C01C28">    0x7ffff7fc1000     0x7ffff7fc3000 r-xp     2000      0 [vdso]</font>
    0x7ffff7fc3000     0x7ffff7fc5000 r--p     2000      0 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
<font color="#C01C28">    0x7ffff7fc5000     0x7ffff7fef000 r-xp    2a000   2000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2</font>
    0x7ffff7fef000     0x7ffff7ffa000 r--p     b000  2c000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    0x7ffff7ffb000     0x7ffff7ffd000 r--p     2000  37000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
<font color="#A347BA">    0x7ffff7ffd000     0x7ffff7fff000 rw-p     2000  39000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2</font>
<font color="#A2734C">    0x7ffffffde000     0x7ffffffff000 rw-p    21000      0 [stack]</font>
<font color="#C01C28">0xffffffffff600000 0xffffffffff601000 --xp     1000      0 [vsyscall]</font>
</pre>

<p><strong>PIE</strong> 的思路是把可执行文件本身也编译成<strong>位置无关代码（PIC）</strong>，让它像共享库一样，可以被加载到任意地址，并结合内核的 ASLR 随机化基址。</p>
<pre><font color="#26A269"><b>pwndbg&gt; </b></font>vmmap
LEGEND: <font color="#A2734C">STACK</font> | <font color="#12488B">HEAP</font> | <font color="#C01C28">CODE</font> | <font color="#A347BA">DATA</font> | <font color="#C01C28"><u style="text-decoration-style:single">WX</u></font> | RODATA
             Start                End Perm     Size Offset File (set vmmap-prefer-relpaths on)
    0x555555554000     0x555555555000 r--p     1000      0 pwn
<font color="#C01C28">    0x555555555000     0x555555556000 r-xp     1000   1000 pwn</font>
    0x555555556000     0x555555557000 r--p     1000   2000 pwn
    0x555555557000     0x555555558000 r--p     1000   2000 pwn
<font color="#A347BA">    0x555555558000     0x555555559000 rw-p     1000   3000 pwn</font>
    0x7ffff7c00000     0x7ffff7c28000 r--p    28000      0 /usr/lib/x86_64-linux-gnu/libc.so.6
<font color="#C01C28">    0x7ffff7c28000     0x7ffff7dbd000 r-xp   195000  28000 /usr/lib/x86_64-linux-gnu/libc.so.6</font>
    0x7ffff7dbd000     0x7ffff7e15000 r--p    58000 1bd000 /usr/lib/x86_64-linux-gnu/libc.so.6
<font color="#2AA1B3">    0x7ffff7e15000     0x7ffff7e16000 ---p     1000 215000 /usr/lib/x86_64-linux-gnu/libc.so.6</font>
    0x7ffff7e16000     0x7ffff7e1a000 r--p     4000 215000 /usr/lib/x86_64-linux-gnu/libc.so.6
<font color="#A347BA">    0x7ffff7e1a000     0x7ffff7e1c000 rw-p     2000 219000 /usr/lib/x86_64-linux-gnu/libc.so.6</font>
<font color="#A347BA">    0x7ffff7e1c000     0x7ffff7e29000 rw-p     d000      0 [anon_7ffff7e1c]</font>
<font color="#A347BA">    0x7ffff7fa6000     0x7ffff7fa9000 rw-p     3000      0 [anon_7ffff7fa6]</font>
<font color="#A347BA">    0x7ffff7fbb000     0x7ffff7fbd000 rw-p     2000      0 [anon_7ffff7fbb]</font>
    0x7ffff7fbd000     0x7ffff7fc1000 r--p     4000      0 [vvar]
<font color="#C01C28">    0x7ffff7fc1000     0x7ffff7fc3000 r-xp     2000      0 [vdso]</font>
    0x7ffff7fc3000     0x7ffff7fc5000 r--p     2000      0 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
<font color="#C01C28">    0x7ffff7fc5000     0x7ffff7fef000 r-xp    2a000   2000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2</font>
    0x7ffff7fef000     0x7ffff7ffa000 r--p     b000  2c000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    0x7ffff7ffb000     0x7ffff7ffd000 r--p     2000  37000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
<font color="#A347BA">    0x7ffff7ffd000     0x7ffff7fff000 rw-p     2000  39000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2</font>
<font color="#A2734C">    0x7ffffffde000     0x7ffffffff000 rw-p    21000      0 [stack]</font>
<font color="#C01C28">0xffffffffff600000 0xffffffffff601000 --xp     1000      0 [vsyscall]</font>
</pre>

<h3 id="原理解释-3"><a href="#原理解释-3" class="headerlink" title="原理解释"></a>原理解释</h3><p>先分清两个词：</p>
<ul>
<li><p><strong>PIC（Position-Independent Code）位置无关代码</strong><br>一段 <em>代码</em> 写得比较讲究，里面不直接写绝对地址，而是通过相对寻址 &#x2F; GOT &#x2F; PLT 等方式访问数据和函数，所以这段代码被装到内存里的哪个地址都能正常跑。共享库 <code>.so</code> 通常就是 PIC。</p>
</li>
<li><p><strong>PIE（Position-Independent Executable）位置无关可执行文件</strong><br>指整个 <em>可执行文件</em> 都是由 PIC 编出来的，链接成一种特殊的 ELF：<code>Type: DYN</code>（看起来像一个带入口点的共享库）。这样它就可以像 <code>.so</code> 一样被加载到任意基址，然后做重定位、执行。</p>
</li>
</ul>
<p>通俗一点说：</p>
<blockquote>
<p>PIC：<strong>一段代码</strong>随便放哪都能跑。<br>PIE：<strong>整个主程序</strong>都是 PIC，所以主程序整体随便放哪都能跑。</p>
</blockquote>
<p>在安全方向上，PIE 的意义就是：<strong>给 ASLR 一个“能搬的主程序”</strong>。</p>
<h3 id="编译选项-3"><a href="#编译选项-3" class="headerlink" title="编译选项"></a>编译选项</h3><p>GCC 的典型组合是：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显式开启</span></span><br><span class="line">gcc -fPIE -pie a.c -o a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 很多发行版（Debian/Ubuntu、Fedora 等）已经对 x86_64 默认打开 PIE：</span></span><br><span class="line"><span class="comment">#   直接 gcc a.c -o a 就是 PIE</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>-fPIE</code>：编译阶段，生成适合做 PIE 的对象代码（类似 <code>-fPIC</code>，但稍微弱一些，只保证作为可执行文件足够）。</li>
<li><code>-pie</code>：链接阶段，生成 ET_DYN + PIE 的可执行文件。</li>
</ul>
<p>在“默认开启 PIE” 的系统（比如现代 Ubuntu）里，如果你想要“传统非 PIE”：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新版 gcc：</span></span><br><span class="line">gcc -no-pie a.c -o a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者视版本，还可以加：</span></span><br><span class="line">gcc -fno-PIE -no-pie a.c -o a</span><br></pre></td></tr></table></figure></div>

<p>关掉之后，<code>readelf -h</code> 的 Type 就会回到 <code>EXEC</code>，程序 .text 基址固定为 0x400000 左右。</p>
<blockquote>
<p>⚠ 整个 PIE &#x2F; 非 PIE 属性是“编译 + 链接期”决定的，没法简单靠 <code>patchelf</code> 这种后期改改 header 就切换，因为里面的代码生成方式（是否 RIP‑relative &#x2F; GOT 引用）已经完全不一样。</p>
</blockquote>
<p>传统 <code>-static</code> 静态链接出来的是非 PIE 的 <code>ET_EXEC</code>，主程序基址固定，ASLR 对代码段无能为力。真正的 static‑PIE（<code>-static-pie</code>）需要 glibc&#x2F;toolchain 专门支持，不是随便加个 <code>-static -pie</code> 就有。</p>
<blockquote>
<p>Ubuntu 22.04 的 glibc 版本是 2.35，但默认构建**没有启用 <code>--enable-static-pie</code>**（至少 x86_64 上是这样），也就是说：</p>
<ul>
<li><code>/usr/lib/x86_64-linux-gnu/libc.a</code> 仍然是为非 PIE 静态程序准备的；</li>
<li>用的是传统的 <code>crt1.o</code> &#x2F; <code>crtbeginT.o</code>，这些 .o 内部包含了<strong>非 PIC 的绝对重定位</strong>（比如对 <code>__TMC_END__</code> 的 <code>R_X86_64_32</code>）。</li>
</ul>
<p>当 GCC&#x2F;ld 试图干两件事：</p>
<ol>
<li>把输出当成一个 <strong>PIE&#x2F;共享对象</strong> 来处理（因为有 <code>-static-pie</code>，等价于告诉 ld “我要做 ET_DYN 风格的程序”）；</li>
<li>又因为有 <code>-static</code> + 当前 glibc 没 static‑PIE 支持，它只能拉进来老式的 <code>crtbeginT.o</code> 等非 PIC 对象。</li>
</ol>
<p>结果 ld 一看：</p>
<blockquote>
<p>“你这个输入对象 <code>crtbeginT.o</code> 含有 <code>R_X86_64_32</code> 这种绝对 32 位重定位，<br>但目标明明是 PIE（相当于共享库），不允许这种重定位，<br>请用 -fPIC 重编译。”</p>
</blockquote>
<p>因此会报错：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/crtbeginT.o: relocation</span><br><span class="line">R_X86_64_32 against hidden symbol `__TMC_END__&#x27; can not be used when</span><br><span class="line">making a PIE object</span><br><span class="line">/usr/bin/ld: failed to set dynamic section sizes: bad value</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure></div>
</blockquote>
<h2 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h2><p><strong>ASLR（Address Space Layout Randomization）</strong> 是操作系统提供的一种内存保护机制：<br>每次程序启动时，把以下这些东西的位置随机化：</p>
<ul>
<li>栈（stack）</li>
<li>堆（heap）</li>
<li>通过 <code>mmap</code> 映射的区域（包括共享库）</li>
<li>vDSO（用户态的小 syscall 页）</li>
<li>主程序代码段 &#x2F; 数据段（前提：是 PIE）</li>
</ul>
<p>在 Linux 上：</p>
<ul>
<li><strong>内核</strong> 负责给各种映射挑一个随机基址；</li>
<li><strong>ELF loader（动态链接器 <code>ld-linux.so</code>）</strong> 负责把 PIE &#x2F; 共享库搬到这些随机基址上。</li>
</ul>
<p>所以 ASLR 不是编译器一个选项就能搞定的，是<strong>内核 + 动态链接器 + 程序编译方式</strong>一起配合的结果。</p>
<h3 id="随机化级别"><a href="#随机化级别" class="headerlink" title="随机化级别"></a>随机化级别</h3><p>Ubuntu 官方安全文档把 ASLR 具体随机的地址拆成几类（其实主流 Linux 都类似）：</p>
<ul>
<li><strong>Stack ASLR</strong> ：每次程序启动，<strong>栈顶</strong>（<code>rsp</code> 初始值）附近的映射基址都不一样；环境变量、argv 这些其实都塞在栈映射里，也跟着换位置；</li>
<li><strong>vDSO ASLR</strong> ：vDSO（<code>linux-vdso.so.1</code>）是内核映射进用户态的一小块“共享库”，里面有 <code>gettimeofday</code>、<code>clock_gettime</code> 之类的<strong>无陷入 syscall 封装</strong>；内核也会把 vDSO 映射到随机位置，避免“跳转到 vDSO 某个固定偏移执行 gadget 这类攻击。</li>
<li><strong>Libs &#x2F; mmap ASLR</strong> ：所有通过 <code>mmap</code> 得到的匿名映射、共享库（<code>libc.so.6</code>、<code>libm.so.6</code> 等）都会随机映射到地址空间的某个地方；</li>
<li><strong>Exec ASLR</strong> ：如果程序是用 <code>-fPIE -pie</code> 编译&#x2F;链接的，内核和动态链接器会像对待共享库那样，给它一个随机的基址，然后再把 <code>.text</code> &#x2F; <code>.data</code> 映射上去；<strong>前提：主程序是 PIE（ET_DYN）</strong>；</li>
<li><strong>brk &#x2F; heap ASLR</strong> ：Linux 上小 malloc 通常走 <code>brk</code> 这块“向上长”的堆区域（大块用 <code>mmap</code>），在 <strong>ASLR 完全开启</strong>（<code>randomize_va_space = 2</code>）时，内核会让 brk 起点相对于 exec 区的偏移也是随机的。</li>
</ul>
<p>ASLR 的内核总开关是 <code>/proc/sys/kernel/randomize_va_space</code>，值有 3 种：</p>
<ul>
<li><p><strong><code>0</code> – 关闭 ASLR</strong></p>
<blockquote>
<p>Turn the process address space randomization off. </p>
</blockquote>
<p>所有进程：栈、堆、共享库、vDSO 等 <strong>地址都固定</strong>；</p>
</li>
<li><p><strong><code>1</code> – 部分随机（不含 heap&#x2F;brk）</strong></p>
<blockquote>
<p>Make the addresses of mmap base, stack and VDSO page randomized.<br>This implies that shared libraries will be loaded to random addresses.<br>Also for PIE-linked binaries, the location of code start is randomized. </p>
</blockquote>
<ul>
<li><p>随机项：</p>
<ul>
<li>栈</li>
<li>vDSO</li>
<li><code>mmap</code> 基址 → 共享库、匿名映射等</li>
<li>对 <strong>PIE</strong> 程序，代码段基址也会随机</li>
</ul>
</li>
<li><p>不随机：</p>
<ul>
<li><code>brk</code> 堆起点（兼容某些古早 libc5 程序）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>2</code> – 完全随机（包括 heap&#x2F;brk）</strong></p>
<blockquote>
<p>Additionally enable heap randomization.</p>
</blockquote>
<p>在模式 1 的基础上，<strong>brk 堆起点也随机</strong>，这是现代发行版默认模式（CONFIG_COMPAT_BRK 关闭时）。</p>
</li>
</ul>
<p>修改 ASLR 的命令如下：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局关闭 ASLR（root）</span></span><br><span class="line"><span class="built_in">echo</span> 0 | <span class="built_in">sudo</span> <span class="built_in">tee</span> /proc/sys/kernel/randomize_va_space</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="built_in">sudo</span> sysctl -w kernel.randomize_va_space=0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复完全随机</span></span><br><span class="line"><span class="built_in">sudo</span> sysctl -w kernel.randomize_va_space=2</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>ASLR 和 PIE 的关系：</strong></p>
<p>一句话总结：</p>
<blockquote>
<p><strong>ASLR 是“我要随机化地址”的策略，<br>PIE 是“主程序本身允许被搬来搬去”的技术。</strong></p>
</blockquote>
<ul>
<li><p><strong>非 PIE（ET_EXEC）程序</strong></p>
<p>链接时假定程序从一个固定基址（比如 <code>0x400000</code>）运行，内部使用<strong>绝对地址</strong>。这是因为内核没法随便给你挪基址，否则所有绝对引用都错了；所以即使 <code>randomize_va_space=2</code>，<strong>主程序 <code>.text</code> 仍然固定</strong>，ASLR 只能随机库&#x2F;栈&#x2F;堆。</p>
</li>
<li><p><strong>PIE（ET_DYN）程序</strong></p>
<p>链接时使用 <strong>位置无关代码（PIC）</strong>：内部都是基址 + offset，没硬编码绝对虚拟地址；动态链接器把它当成一个“主程序用的 shared object”，选一个随机基址，把所有段映射进去；于是：</p>
<ul>
<li>ASLR 打开时：<strong>主程序、libc、堆、栈全随机</strong>；</li>
<li>ASLR 关闭时：会选一个<strong>固定的基址</strong>（比如很多 64 位 Ubuntu 上是 <code>0x55xxxxxxx000</code>），但每次都一样。</li>
</ul>
</li>
</ul>
</blockquote>
<p>Linux 还提供了两个更具体的 <code>sysctl</code>：</p>
<ul>
<li><code>vm.mmap_rnd_bits</code>：控制 <strong>64 位进程（本机架构）</strong> 做 mmap 时使用多少位随机偏移。</li>
<li><code>vm.mmap_rnd_compat_bits</code>：控制 <strong>兼容模式进程</strong>（比如 64 位内核上的 32 位程序） mmap 的随机位数。</li>
</ul>
<p>这两个值决定了“mmap 区域基址要随机多少 bits”，受架构支持的最大值限制。主线 Linux 默认大概是：<strong>64 位 28 bit、32 位 8 bit</strong>，可以调高到：64 位 32 bit，32 位 16 bit。</p>
<blockquote>
<p>来看 x86 的源码，内核是怎么用 <code>mmap_rnd_bits</code> 的（删掉无关部分）：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* arch/x86/mm/mmap.c 里的典型逻辑，伪代码简化版 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">arch_mmap_rnd</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rnd = get_random_long();</span><br><span class="line">    <span class="comment">/* 取低 mmap_rnd_bits 比特作为“随机页号”，再左移 PAGE_SHIFT */</span></span><br><span class="line">    rnd &amp;= (<span class="number">1UL</span> &lt;&lt; mmap_rnd_bits) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> rnd &lt;&lt; PAGE_SHIFT;  <span class="comment">// PAGE_SHIFT = 12，页大小 4 KiB</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后 top‑down 布局的大致逻辑是：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addr = mmap_base - arch_mmap_rnd();   <span class="comment">// 从某个基准往下挪 “随机偏移”</span></span><br><span class="line">addr = align_down(addr, PAGE_SIZE);   <span class="comment">// 至少 4K 对齐</span></span><br></pre></td></tr></table></figure></div>

<p>所以：<code>mmap_rnd_bits = 28</code> 的意思是——<strong>在 4K 页粒度上最多有 2²⁸ 种不同的位置可以选</strong>。<br>但最后你能看到多少不同的地址，还要看：</p>
<ul>
<li>地址空间窗口多大（<code>DEFAULT_MAP_WINDOW</code> &#x2F; <code>TASK_SIZE</code> 限制）；</li>
<li>后面有没有再做更粗的对齐（比如 THP 2MiB 对齐）。</li>
</ul>
</blockquote>
<h3 id="用户空间布局"><a href="#用户空间布局" class="headerlink" title="用户空间布局"></a>用户空间布局</h3><p>x86_64 的用户空间理论上是：<code>0x0000000000000000 - 0x00007fffffffffff</code></p>
<p>内核用一个 <code>DEFAULT_MAP_WINDOW</code> 代表 mmap 可用的窗口：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/x86/include/asm/page_64_types.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MAP_WINDOW ((1UL &lt;&lt; 47) - PAGE_SIZE)   <span class="comment">// ≈ 0x7ffffffff000</span></span></span><br></pre></td></tr></table></figure></div>

<p>PIE（ET_DYN + INTERP 的可执行文件）加载时用 <code>ELF_ET_DYN_BASE</code> 作为基点：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/x86/include/asm/elf.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELF_ET_DYN_BASE \</span></span><br><span class="line"><span class="meta">    (mmap_is_ia32() ? 0x000400000UL : (DEFAULT_MAP_WINDOW / 3 * 2))</span></span><br></pre></td></tr></table></figure></div>

<p>对于 64 位进程来说，<code>ELF_ET_DYN_BASE ≈ 2/3 * 0x7ffffffff000 ≈ 0x555555554000</code>，所以：</p>
<blockquote>
<p><strong>大部分 64 位 PIE 主程序的基址（没开 ASLR 时）就是 0x555555554000 一带</strong>，<br>开了 ASLR 后会在这一段附近加随机偏移。</p>
</blockquote>
<p>堆一般是紧跟着 data&#x2F;bss 往高地址扩展，也在差不多的区域，所以你在旧系统看到：</p>
<ul>
<li>PIE &#x2F; 堆地址 ≈ <code>0x55xxxx...</code></li>
<li>共享库（libc 等）贴近用户空间顶部 ≈ <code>0x7fxxxx...</code></li>
</ul>
<p>在 <strong>内核 5.18 之前</strong>，典型情况是：</p>
<ul>
<li>mmap 区、库、PIE 基址都以 4K 对齐；</li>
<li><code>vm.mmap_rnd_bits ≈ 28</code>，随机偏移范围大概是 <code>2^28 * 0x1000 ≈ 1 TiB</code>；</li>
</ul>
<p>但因为：</p>
<ul>
<li>共享库被限制在用户空间最顶端附近（0x7f… 那一截）；</li>
<li>PIE 被限制在 <code>ELF_ET_DYN_BASE ≈ 0x5555...</code> 附近；</li>
</ul>
<p>所以<strong>随机实际上只在“中间几十 bit”抖动</strong>，高 8 位几乎不怎么变——肉眼看，就像是：</p>
<ul>
<li>libc 总是 <code>0x7fxxxxxx...</code></li>
<li>PIE&#x2F;堆 总是 <code>0x55xxxxxx...</code> &#x2F; <code>0x56xxxxxx...</code></li>
</ul>
<p>Linux 5.18 开始，为了更好利用 <strong>Transparent Huge Pages（THP）</strong>，对一些映射做了改动：大于等于 2 MiB 的映射会通过 <code>thp_get_unmapped_area()</code> 选地址，并被强制<strong>按 2 MiB 对齐</strong>。</p>
<pre>    0x77f111000000     0x77f111028000 r--p    28000      0 /usr/lib/x86_64-linux-gnu/libc.so.6
<font color="#C01C28">    0x77f111028000     0x77f1111bd000 r-xp   195000  28000 /usr/lib/x86_64-linux-gnu/libc.so.6</font>
    0x77f1111bd000     0x77f111215000 r--p    58000 1bd000 /usr/lib/x86_64-linux-gnu/libc.so.6
<font color="#2AA1B3">    0x77f111215000     0x77f111216000 ---p     1000 215000 /usr/lib/x86_64-linux-gnu/libc.so.6</font>
    0x77f111216000     0x77f11121a000 r--p     4000 215000 /usr/lib/x86_64-linux-gnu/libc.so.6
<font color="#A347BA">    0x77f11121a000     0x77f11121c000 rw-p     2000 219000 /usr/lib/x86_64-linux-gnu/libc.so.6</font></pre>

<blockquote>
<p>当你用 <code>mmap</code> 映射一个文件（比如 libc.so.6），如果映射的长度 ≥ 2 MiB，并且文件系统是 ext4&#x2F;btrfs&#x2F;xfs 等“主流盘”，<strong>内核会尝试把这个映射放在一个 2 MiB 对齐的虚拟地址上</strong>，为了以后可以用 2 MiB huge page（透明大页）来映射它。</p>
<ul>
<li><p>内核在决定 mmap 要放哪的时候，会调用 <code>get_unmapped_area()</code> 这一类函数。</p>
</li>
<li><p>从 Linux <strong>5.18</strong> 开始，对 ext4&#x2F;btrfs&#x2F;xfs 等文件系统，**文件映射会先走 <code>thp_get_unmapped_area()</code>**，而不是直接用原来的 <code>get_unmapped_area</code>。</p>
</li>
<li><p><code>thp_get_unmapped_area()</code> 里实际会调用 <code>__thp_get_unmapped_area(..., PMD_SIZE)</code>，其中 <code>PMD_SIZE</code> 在 x86‑64 上就是 <strong>2 MiB</strong>，最后把地址 <strong><code>ALIGN</code> 到 2 MiB 边界</strong>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mm/huge_memory.c</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">thp_get_unmapped_area</span><span class="params">(<span class="keyword">struct</span> file *filp,</span></span><br><span class="line"><span class="params">                                    <span class="type">unsigned</span> <span class="type">long</span> addr,</span></span><br><span class="line"><span class="params">                                    <span class="type">unsigned</span> <span class="type">long</span> len,</span></span><br><span class="line"><span class="params">                                    <span class="type">unsigned</span> <span class="type">long</span> pgoff,</span></span><br><span class="line"><span class="params">                                    <span class="type">unsigned</span> <span class="type">long</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    ret = __thp_get_unmapped_area(filp, addr, len, off, flags, PMD_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="keyword">return</span> current-&gt;mm-&gt;get_unmapped_area(filp, addr, len, pgoff, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>2 MiB huge page的本质：像 4 KiB 页要 4 KiB（2¹²）对齐一样，<strong>2 MiB huge page 要 2 MiB（2²¹）对齐</strong>，所以<strong>低 21 位全是 0</strong>。</p>
</blockquote>
<p>对 <strong>64 位库（≥2 MiB）</strong>，原本库基址有 ~28 bit 随机。被 2 MiB 对齐后，损失了 9 bit（因为多出了 2^9 ≈ 512 个页对齐），有效熵只剩 ~19 bit。</p>
<blockquote>
<p>只有「大于等于 2MiB 的 file‑backed 映射」会被 THP 对齐，小块 mmap 正常按 4K 对齐随机。</p>
</blockquote>
<p>再结合 <code>vm.mmap_rnd_bits</code> 提高（很多发行版把它从 28 调到 30&#x2F;32）：</p>
<ul>
<li>原来随机基本只在某个小区间抖动，高位几乎不动；</li>
<li>现在随机偏移范围更大，<strong>高 8bit 本身也在一个区间里变化</strong>，程序地址变成了 <code>0x55/0x56/0x57</code>，甚至 <code>0x5c/0x6x</code> 之类的开头，libc 地址也同理。</li>
</ul>
<p>总结来说就是：</p>
<p><strong>64 位</strong>：老内核上 mmap&#x2F;库&#x2F;PIE 基本都有 ≈28 bit 熵；5.18+ 之后，大库因 THP 变成 ≈19 bit，某些发行版把 <code>vm.mmap_rnd_bits</code> 调高到 32，又把库拉回 ≈23 bit，其它非 THP 区域可到 32 bit。</p>
<p><strong>32 位</strong>：老内核上库&#x2F;PIE 也就 8 bit，heap 13 bit，栈 19 bit；5.18+ 后 2MiB 的大库甚至掉到 0 bit，靠拉高 <code>vm.mmap_rnd_compat_bits</code> 最多救到 7 bit，整体仍然非常脆弱。</p>
<table>
<thead>
<tr>
<th>区域 &#x2F; 对象</th>
<th>老内核（无 THP 2MiB 对齐，<code>rnd_bits≈28</code>）</th>
<th>新内核默认（THP 对齐 + <code>rnd_bits≈28</code>）</th>
<th>新内核 + 高熵（THP 对齐 + <code>rnd_bits=32</code>）</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>PIE 主程序 text（ET_DYN）</strong></td>
<td>~<strong>28 bit</strong>；约 bit12–bit39</td>
<td>仍 ~<strong>28 bit</strong>；bit12–bit39</td>
<td>若 <code>rnd_bits=32</code>：~<strong>32 bit</strong>；约 bit12–bit43</td>
<td>PIE 映射本身通常不是 2MiB 对齐的“巨大映射”，所以不受 THP 影响，熵主要由 <code>mmap_rnd_bits</code> 决定。</td>
</tr>
<tr>
<td><strong>共享库 &#x2F; libc（大于 2MiB）</strong></td>
<td>~<strong>28 bit</strong>；bit12–bit39</td>
<td><strong>19 bit</strong>；约 bit21–bit39</td>
<td><code>32−9=23 bit</code>；约 bit21–bit43</td>
<td>5.18+ 起，大库按 2MiB 对齐 ⇒ 吞掉 9 个随机位。提高 <code>rnd_bits</code> 只能部分弥补。</td>
</tr>
<tr>
<td><strong>小型共享库 &#x2F; 小 mmap</strong></td>
<td>~<strong>28 bit</strong>；bit12–bit39</td>
<td>仍 ~<strong>28 bit</strong>；bit12–bit39</td>
<td>若 <code>rnd_bits=32</code>：~<strong>32 bit</strong>；bit12–bit43</td>
<td>只有「大于等于 2MiB 的 file‑backed 映射」会被 THP 对齐，小块 mmap 正常按 4K 对齐随机。</td>
</tr>
<tr>
<td><strong>heap（brk），非 PIE</strong></td>
<td>~<strong>13 bit</strong>；约 bit12–bit24</td>
<td>还是 ~<strong>13 bit</strong></td>
<td>同</td>
<td>不走 mmap 区，THP 对齐不直接影响。</td>
</tr>
<tr>
<td><strong>heap（brk），PIE 程序</strong></td>
<td>~<strong>28 bit</strong>；bit12–bit39</td>
<td>仍 ~<strong>28 bit</strong></td>
<td>若 <code>rnd_bits=32</code> 可略增（视实现而定）</td>
<td>Heap (PIE) ≈ 28 bit。是否受 <code>rnd_bits</code> 影响略复杂，但和大库 THP 无关。</td>
</tr>
<tr>
<td><strong>用户栈（stack）基址</strong></td>
<td>~<strong>30 bit</strong>；约 bit12–bit41</td>
<td>仍 ~<strong>30 bit</strong></td>
<td>变化不大</td>
<td>栈随机有自己一套逻辑，与 <code>mmap_rnd_bits</code>&#x2F;THP 的关系较弱</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>区域 &#x2F; 对象</th>
<th>老内核 32 位（无 THP，对应 <code>compat_bits≈8</code>）</th>
<th>新内核默认（THP + <code>compat_bits≈8</code>）</th>
<th>新内核 + 高熵（THP + <code>compat_bits=16</code>）</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>PIE 主程序 text（ET_DYN）</strong></td>
<td>~<strong>8 bit</strong>；约 bit12–bit19</td>
<td>仍 ~<strong>8 bit</strong></td>
<td>若 <code>compat_bits=16</code>：~<strong>16 bit</strong></td>
<td></td>
</tr>
<tr>
<td><strong>共享库 &#x2F; libc（≥2MiB）</strong></td>
<td>~<strong>8 bit</strong>；bit12–bit19</td>
<td><strong>≈0 bit</strong>（几乎固定）</td>
<td>理论上 ≈<strong>7 bit</strong>（16−9）</td>
<td>32 位上大库 + 2MiB 对齐 ⇒ 没啥地方可随机，很多发行版几乎 0 bit 熵。把 <code>compat_bits</code> 拉到 16，最多也就 7 bit 左右。</td>
</tr>
<tr>
<td><strong>小型共享库 &#x2F; 普通 mmap</strong></td>
<td>~<strong>8 bit</strong>；bit12–bit19</td>
<td>仍 ~<strong>8 bit</strong>；bit12–bit19</td>
<td>若 <code>compat_bits=16</code>：~<strong>16 bit</strong></td>
<td>小映射不受 THP 影响，熵完全由 <code>vm.mmap_rnd_compat_bits</code> 决定。</td>
</tr>
<tr>
<td><strong>heap（brk）</strong></td>
<td>~<strong>13 bit</strong>；bit12–bit24</td>
<td>仍 ~<strong>13 bit</strong></td>
<td>同</td>
<td></td>
</tr>
<tr>
<td><strong>栈（stack）基址</strong></td>
<td>~<strong>19 bit</strong>；bit12–bit30</td>
<td>仍 ~<strong>19 bit</strong></td>
<td>差别不大</td>
<td></td>
</tr>
<tr>
<td><strong>VDSO &#x2F; 小映射</strong></td>
<td>~<strong>8 bit</strong>；bit12–bit19</td>
<td>仍 ~<strong>8 bit</strong></td>
<td>若高熵：~<strong>16 bit</strong></td>
<td>也走 mmap 区，服从 <code>vm.mmap_rnd_compat_bits</code>。</td>
</tr>
</tbody></table>
<h2 id="FORTIFY"><a href="#FORTIFY" class="headerlink" title="FORTIFY"></a>FORTIFY</h2><p><strong>FORTIFY 不是像 NX &#x2F; RELRO 那样的“内核级保护”，而是 glibc + GCC 合作实现的一套“带边界检查的 libc 包装函数”。</strong></p>
<p>它靠 <code>_FORTIFY_SOURCE</code> 宏 + 优化编译，在编译期 &#x2F; 运行时对 <code>strcpy</code> &#x2F; <code>memcpy</code> &#x2F; <code>sprintf</code> 这类函数做额外检查，出问题就直接 <code>abort()</code>。</p>
<h3 id="原理解释-4"><a href="#原理解释-4" class="headerlink" title="原理解释"></a>原理解释</h3><p>这个机制的大致思路是：</p>
<ol>
<li><p>在 <strong>glibc 头文件</strong> 里（如 <code>&lt;string.h&gt;</code>,<code>&lt;stdio.h&gt;</code>），一旦检测到：</p>
<ul>
<li>使用 GCC；</li>
<li>开了优化（<code>-O1</code> 及以上）；</li>
<li>并且定义了 <code>_FORTIFY_SOURCE&gt;0</code>；</li>
</ul>
</li>
<li><p>就把一些“危险”函数，比如：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>, stpcpy, <span class="built_in">strcat</span>, <span class="built_in">sprintf</span>, <span class="built_in">vsprintf</span>,</span><br><span class="line"><span class="built_in">memcpy</span>, memmove, <span class="built_in">memset</span>,</span><br><span class="line">read, pread, getcwd, gets（老版本）...</span><br></pre></td></tr></table></figure></div>

<p><strong>宏替换</strong>成带 <code>_chk</code> 后缀的版本，例如：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _FORTIFY_SOURCE</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> strcpy(dest, src) \</span></span><br><span class="line"><span class="meta">        __builtin___strcpy_chk((dest), (src), __builtin_object_size(dest, 1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<p>编译后链接到 glibc 里的实现：<code>__strcpy_chk</code>, <code>__memcpy_chk</code>, <code>__sprintf_chk</code> 等。</p>
</li>
<li><p>这些 <code>_chk</code> 版本在内部会检查“你要拷贝的字节数”是否超过“目标缓冲区大小”：</p>
<ul>
<li><strong>编译期能确定一定越界 → 编译器直接给 warning&#x2F;甚至 error</strong>；</li>
<li>确定不了或只知道“可能” → 在运行时 <code>_chk</code> 里判断，大于就调用 <code>__fortify_fail()</code>，程序直接 <code>abort()</code>。</li>
</ul>
</li>
</ol>
<p>当 <code>_FORTIFY_SOURCE</code> 生效时，glibc 的头文件会用宏 &#x2F; inline 函数把一些“危险函数”<strong>替换成带额外参数的版本</strong>，比如 <code>strcpy</code>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> strcpy(dest, src) \</span></span><br><span class="line"><span class="meta">    __builtin___strcpy_chk((dest), (src), __builtin_object_size(dest, 1))</span></span><br></pre></td></tr></table></figure></div>

<p>编译后链接到 glibc 里真正实现的 <code>_chk</code> 版本，例如 <code>__strcpy_chk</code>。<code>memcpy</code> &#x2F; <code>sprintf</code> 等同理：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__builtin___memcpy_chk(dst, src, len, __builtin_object_size(dst, <span class="number">0</span>));</span><br><span class="line">__builtin___sprintf_chk(buf, flag, buf_size, fmt, ...);</span><br></pre></td></tr></table></figure></div>

<p>glibc 手册的说法是：</p>
<blockquote>
<p>Fortified 变体一般是在原函数名两边加前缀 <code>__</code> 和后缀 <code>_chk</code>：如 <code>__memcpy_chk</code>、<code>__strcpy_chk</code>；<br>对 <code>printf</code> 家族和 <code>open</code> 家族有一些命名上的例外（<code>_2</code> 后缀、<code>_chkieee128</code> 等）。</p>
</blockquote>
<p>这些 <code>_chk</code> 函数内部做的事，大致就是：检查目标对象大小，如果要写的长度超过了，就调用 <code>__fortify_fail()</code>。例如（伪代码，逻辑与 glibc 源码一致）：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *__memcpy_chk(<span class="type">void</span> *dst, <span class="type">const</span> <span class="type">void</span> *src,</span><br><span class="line">                   <span class="type">size_t</span> len, <span class="type">size_t</span> dst_objsize)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (dst_objsize != (<span class="type">size_t</span>)<span class="number">-1</span> &amp;&amp; len &gt; dst_objsize)</span><br><span class="line">        __fortify_fail(<span class="string">&quot;memcpy: buffer overflow&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">memcpy</span>(dst, src, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>而 <code>__fortify_fail()</code> 最终会走 glibc 的内部错误处理路径，打印诊断信息并触发 <code>SIGABRT</code>（类似 <code>__stack_chk_fail</code> 的行为）。</p>
<p>FORTIFY 的核心依赖是两个内建：</p>
<ul>
<li><code>__builtin_object_size(ptr, type)</code></li>
<li><code>__builtin_dynamic_object_size(ptr, type)</code>（较新，GCC 12+）</li>
</ul>
<p>编译器会尝试在 <strong>编译期</strong> 推导指针 <code>ptr</code> 所指向对象的“最大可能大小”（如果完全推不出，就返回 <code>(size_t)-1</code> 表示未知）：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">16</span>];</span><br><span class="line"><span class="type">char</span> *p = buf;</span><br><span class="line"><span class="type">char</span> *q;</span><br><span class="line"></span><br><span class="line">__builtin_object_size(buf, <span class="number">1</span>)  → <span class="number">16</span></span><br><span class="line">__builtin_object_size(p,   <span class="number">1</span>)  → 通常也能算出 <span class="number">16</span></span><br><span class="line">__builtin_object_size(q,   <span class="number">1</span>)  → (<span class="type">size_t</span>)<span class="number">-1</span>  <span class="comment">// 完全不知道</span></span><br></pre></td></tr></table></figure></div>

<p>glibc fortify 包装里会把这个结果塞给 <code>_chk</code> 版本：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__builtin___strcpy_chk(dest, src, __builtin_object_size(dest, <span class="number">1</span>));</span><br></pre></td></tr></table></figure></div>

<p>然后就有三种情况：</p>
<ol>
<li><p><strong>肯定安全（编译期就能证明确实 fit）</strong></p>
<ul>
<li>GCC 看到“长度常量 &lt; 缓冲区大小”，可能会直接退化成普通 <code>strcpy</code> 或简单的内联；</li>
<li><code>_chk</code> 调用甚至都不会出现在最终二进制里。</li>
</ul>
</li>
<li><p><strong>肯定越界</strong></p>
<ul>
<li>GCC 会发出类似 <code>-Wstringop-overflow</code>、<code>-Wformat-overflow</code> 等告警；</li>
<li>在某些配置下（配合 <code>-Werror</code>）直接变成编译失败；</li>
<li>如果仍然生成代码，运行时一旦触发调用就会走 <code>_chk</code> → <code>__fortify_fail()</code>，程序崩溃。([GNU][2])</li>
</ul>
</li>
<li><p><strong>不确定（只知道上界 &#x2F; 完全不知道）</strong></p>
<ul>
<li>编译器保留 <code>_chk</code> 调用；</li>
<li>运行时由 <code>_chk</code> 自己比较 <code>len</code> 与 <code>dst_objsize</code>，越界则 <code>__fortify_fail()</code>。</li>
</ul>
</li>
</ol>
<p>较新的 glibc + GCC 还会在 level 3 使用 <code>__builtin_dynamic_object_size</code>，在涉及 <code>malloc</code> 后又传给 <code>memcpy</code> 的这类场景里推导出更精确的大小。</p>
<h3 id="保护级别"><a href="#保护级别" class="headerlink" title="保护级别"></a>保护级别</h3><p>glibc + GCC 主要约定了 3 个等级：</p>
<ul>
<li><p><strong><code>_FORTIFY_SOURCE=1</code></strong></p>
<p>使用 <code>__builtin_object_size</code> 做边界检查；如果返回 <code>(size_t)-1</code> 就不替换函数调用；此外对 <code>open/openat</code> 的 flags 做一些基本校验。</p>
</li>
<li><p><strong><code>_FORTIFY_SOURCE=2</code></strong></p>
<p>在 1 的基础上增加更 aggressive 的检查，比如 <code>printf</code> 家族对 <code>%n</code> 的限制（只允许出现在只读格式串里）等，<strong>有可能会拦截一些标准允许但危险的用法</strong>。</p>
</li>
<li><p><code>_FORTIFY_SOURCE=3</code></p>
<p>使用 <code>__builtin_dynamic_object_size</code> 做更精确的大小推导。<br>这一层可能显著增加运行时开销（特别是 size 表达式复杂、调用频繁时），所以默认一般不会开到 3。</p>
</li>
</ul>
<p>glibc 手册列了一长串被 fortify 的函数 &#x2F; 宏，大致包括：</p>
<ul>
<li>字符串 &#x2F; 内存：<code>strcpy/strncpy/strcat/strncat/stpcpy/stpncpy/memcpy/memmove/memset/...</code></li>
<li><code>printf</code> 家族：<code>printf/sprintf/snprintf/vprintf/vsnprintf/...</code></li>
<li>文件 I&#x2F;O：<code>fgets/fread/getcwd/gethostname/...</code></li>
<li>原始 I&#x2F;O：<code>read/pread/recv/recvfrom/...</code></li>
<li><code>open</code> 家族：<code>open/open64/openat/openat64/mq_open/...</code>（用 <code>_2</code> 后缀变体）</li>
<li><code>FD_SET/FD_CLR/FD_ISSET</code>（使用 <code>__fdelt_chk</code>）</li>
<li>宽字符版本：<code>wcscpy/wcsncpy/wcslcpy/wcslcat/wmemcpy/...</code></li>
<li>以及 <code>gets/getwd/syslog/realpath</code> 等一堆历史遗留危险函数（很多已经不推荐再用）。</li>
</ul>
<p>这也解释了为什么 <code>checksec</code> 的 FORTIFY 一栏一般会同时给出两列：</p>
<ul>
<li>**<code>FORTIFY: Enabled</code> &#x2F; <code>Disabled</code>**：是否在编译时启用了 <code>_FORTIFY_SOURCE</code>；</li>
<li><strong><code>Fortified / Fortifiable</code> 计数</strong>：当前 ELF 里 <strong>用了多少个被 fortify 的函数</strong>，以及理论上还可以 fortify 多少个没被用到 <code>_chk</code> 版本。</li>
</ul>
<h3 id="编译选项-4"><a href="#编译选项-4" class="headerlink" title="编译选项"></a>编译选项</h3><p><strong>启用 FORTIFY 的最常见写法：</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -O2 -D_FORTIFY_SOURCE=2 main.c -o main</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>FORTIFY 是否启用由 glibc 的头文件里一个内部宏 <code>__USE_FORTIFY_LEVEL</code> 决定，大致逻辑是：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> _FORTIFY_SOURCE &gt; 0 &amp;&amp; __OPTIMIZE__ &gt; 0 &amp;&amp; __GLIBC_USE(FORTIFY)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">if</span>   _FORTIFY_SOURCE &gt;= 3</span></span><br><span class="line"><span class="meta">#    <span class="keyword">define</span> __USE_FORTIFY_LEVEL 3</span></span><br><span class="line"><span class="meta">#  <span class="keyword">elif</span> _FORTIFY_SOURCE == 2</span></span><br><span class="line"><span class="meta">#    <span class="keyword">define</span> __USE_FORTIFY_LEVEL 2</span></span><br><span class="line"><span class="meta">#  <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#    <span class="keyword">define</span> __USE_FORTIFY_LEVEL 1</span></span><br><span class="line"><span class="meta">#  <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> __USE_FORTIFY_LEVEL 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<p>也就是说，要想 FORTIFY 真正生效，<strong>必须同时满足</strong>：</p>
<ol>
<li>使用 glibc 头文件（<code>&lt;string.h&gt;</code>, <code>&lt;stdio.h&gt;</code>, <code>&lt;unistd.h&gt;</code> 等）；</li>
<li>编译优化开启：<code>__OPTIMIZE__ &gt; 0</code>，即 <code>-O1</code> 及以上；</li>
<li>定义 <code>_FORTIFY_SOURCE</code> 且大于 0；</li>
<li>glibc 自己启用了 FORTIFY 支持（<code>__GLIBC_USE(FORTIFY)</code>，现代发行版基本都开着）。</li>
</ol>
<p>否则即使你写 <code>-D_FORTIFY_SOURCE=2</code>，宏也会被静默降级成“无效”。</p>
<blockquote>
<p>实战里最常见的组合就是发行版默认 CFLAGS：<br><code>-O2 -D_FORTIFY_SOURCE=2</code>（Ubuntu、Debian、Fedora 等都是类似设置）。</p>
</blockquote>
</blockquote>
<p><strong>关闭 FORTIFY 的最常见写法：</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -U_FORTIFY_SOURCE -O2 main.c -o main</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">gcc -D_FORTIFY_SOURCE=0 -O2 main.c -o main</span><br></pre></td></tr></table></figure></div>

<p>另外如果不满足启用 FORTIFY 保护的条件则同样可以关闭 FORTIFY 保护。</p>
<h2 id="CET"><a href="#CET" class="headerlink" title="CET"></a>CET</h2><p><strong>CET &#x3D; Control‑flow Enforcement Technology</strong>，是 Intel 在 x86 上加的一套硬件特性，用来防御 <strong>控制流劫持</strong>，主要针对：</p>
<ul>
<li>ROP：改返回地址，<code>ret</code> 跳到 gadget 链上；</li>
<li>JOP &#x2F; COOP：改函数指针 &#x2F; vtable &#x2F; GOT，间接跳转到奇怪的位置；</li>
</ul>
<p>CET 在指令集里主要分两块：</p>
<ol>
<li><strong>Shadow Stack（SHSTK）</strong>：影子栈，保护 <strong>返回地址</strong>（后向边）。</li>
<li><strong>Indirect Branch Tracking（IBT）</strong>：间接分支跟踪，限制 <strong>间接 CALL&#x2F;JMP</strong> 的落点（前向边）。</li>
</ol>
<blockquote>
<p>你可以粗暴理解为：CET &#x3D; 硬件级 CFI（控制流完整性）+ 硬件版“栈保护”。</p>
</blockquote>
<h3 id="Shadow-Stack（SHSTK）"><a href="#Shadow-Stack（SHSTK）" class="headerlink" title="Shadow Stack（SHSTK）"></a>Shadow Stack（SHSTK）</h3><p>Intel 的官方描述是这样的：</p>
<blockquote>
<p>影子栈是一个 <strong>单独分配的栈</strong>，用户态代码不能直接修改。<br>当执行 <code>CALL</code> 时，CPU 同时把返回地址压到 <strong>普通栈</strong> 和 <strong>影子栈</strong>。<br>执行 <code>RET</code> 时，从两边各弹一个地址，如果不一样，就触发“控制保护异常”（#CP）。</p>
</blockquote>
<p>对应硬件上多了几个东西：</p>
<ul>
<li><p>一个 <strong>SSP（Shadow Stack Pointer）寄存器</strong>，指向当前影子栈；</p>
</li>
<li><p>影子栈所在的页面有特殊标记：</p>
<ul>
<li>普通写指令（<code>mov [mem], reg</code> 这种）写不上去；</li>
<li>只能由 <strong>CALL&#x2F;RET</strong> 和几条专门的 CET 指令（<code>WRSS*</code>、<code>RSTORSSP</code>、<code>SAVEPREVSSP</code>、<code>INCSSP</code> 等）改。</li>
</ul>
</li>
</ul>
<p>开启用户态 SHSTK 之后（内核会给该线程设置 CET MSR 位）：</p>
<ul>
<li><p><strong>near CALL</strong>：</p>
<ol>
<li>像往常一样，把返回地址压到普通栈（<code>RSP</code>）；</li>
<li>额外再把返回地址压到影子栈（<code>SSP</code>）；</li>
<li><code>SSP</code> 向低地址移动（x86 栈向下生长）。</li>
</ol>
</li>
<li><p><strong>near RET</strong>：</p>
<ol>
<li>从普通栈弹出返回地址 A，<code>RSP += 8</code>（64 位）；</li>
<li>从影子栈弹出返回地址 B，<code>SSP += 8</code>；</li>
<li><strong>比较 A 和 B</strong>：如果不相等 ⇒ 触发 <strong>#CP（Control‑Protection Fault）</strong> ⇒ 进程直接挂掉。</li>
</ol>
</li>
</ul>
<p>所以典型的栈溢出攻击：你只覆盖了普通栈上的 saved RIP，<strong>影子栈那一份没法改</strong>，一执行 <code>ret</code> 就立即触发 <code>#CP</code> 异常。</p>
<p>Linux 文档里写得很清楚，要用用户态 shadow stack，需要：</p>
<ol>
<li><strong>CPU 硬件支持 CET&#x2F;Shadow Stack</strong>（<code>cpuid</code> 里有相关 flag）；</li>
<li><strong>内核配置启用用户态 shadow stack</strong>（<code>CONFIG_X86_USER_SHADOW_STACK</code> 之类选项）；</li>
<li><strong>用户态库 &#x2F; 程序按 CET ABI 构建</strong>（带 SHSTK 属性的 ELF）。</li>
</ol>
<p>Linux 启用流程大致是：</p>
<ul>
<li><p>引导时检测 CPU 是否支持 CET；</p>
</li>
<li><p>如果配置打开了 user shadow stack，内核支持为用户进程分配影子栈、设置 <code>MSR_IA32_U_CET</code> 之类 MSR；</p>
</li>
<li><p>动态链接器（ld-linux）在加载 ELF 时，看到程序或某个 so 的 <code>.note.gnu.property</code> 里带 **<code>GNU_PROPERTY_X86_FEATURE_1_SHSTK</code>**，就给这个进程打开 SHSTK：</p>
<ul>
<li>分配一块只读+shadow‑stack 类型的内存；</li>
<li>初始化 SSP；</li>
<li>打开该线程的 CET bit。</li>
</ul>
</li>
</ul>
<p>文档里还特地提到，当前 64 位 Linux 上：<strong>只支持“用户态影子栈 + 内核 IBT”组合</strong>，内核自己暂时不用影子栈。</p>
<h3 id="IBT：Indirect-Branch-Tracking"><a href="#IBT：Indirect-Branch-Tracking" class="headerlink" title="IBT：Indirect Branch Tracking"></a>IBT：Indirect Branch Tracking</h3><p>SHSTK 解决的是“<strong>ret 往哪里回</strong>”的问题（后向边）；但攻击者也可以不碰 <code>ret</code>，而是：</p>
<ul>
<li>改函数指针 &#x2F; vtable；</li>
<li>改 GOT 表；</li>
<li>用 <code>jmp [rax]</code> &#x2F; <code>call [rax]</code> 这种 <strong>间接跳转</strong> 跳到恶意 gadget。</li>
</ul>
<p><strong>IBT 就针对这种“间接 CALL&#x2F;JMP 的落点”做限制。</strong></p>
<p>CET 引入了一个新的“landing pad”指令：<strong>ENDBRANCH</strong>，有两种编码：<code>ENDBR64</code>、<code>ENDBR32</code>。核心点：</p>
<ul>
<li><p>编译器会在<strong>所有合法的“间接跳转目标”</strong>前插入 <code>endbr64</code>；</p>
</li>
<li><p>开启 IBT 后：</p>
<ul>
<li><strong>间接 CALL&#x2F;JMP 必须跳到 <code>endbr</code> 开头的地址</strong>；</li>
<li>如果跳到一个不是 <code>endbr</code> 的地址（比如半个 gadget） ⇒ CPU 触发 <code>#CP</code>，程序崩溃；</li>
</ul>
</li>
<li><p><strong>直接 CALL&#x2F;JMP 不受影响</strong>。</p>
</li>
</ul>
<p>和 SHSTK 一样，IBT 也透过 ELF note 宣告“我支持 IBT”：</p>
<ul>
<li>ELF <code>.note.gnu.property</code> 里有一个 <code>GNU_PROPERTY_X86_FEATURE_1_IBT</code> 位；</li>
<li>链接器通过 <code>-z ibt</code> 把这个 property 写进去；</li>
<li>编译器通过 <code>-fcf-protection=branch</code> 或 <code>-fcf-protection=full</code> 在间接跳转目标插 <code>endbr64</code>。</li>
</ul>
<p>加载器看到 IBT property + 内核&#x2F;CET 硬件支持，就会给该进程打开 IBT 模式；之后所有非 <code>endbr</code> 开头的间接跳转目标都视为非法。</p>
<h3 id="编译选项-5"><a href="#编译选项-5" class="headerlink" title="编译选项"></a>编译选项</h3><p>GCC&#x2F;Clang 这边关键有两个：</p>
<ol>
<li><p><strong>IBT</strong>：<code>-fcf-protection=</code></p>
<ul>
<li><code>=none</code>：关 CET 前向边（默认有些发行版已经改成 <code>=full</code>）；</li>
<li><code>=branch</code>：只对间接分支插 <code>endbr</code>，对应 IBT；</li>
<li><code>=full</code>：在 <code>=branch</code> 基础上再加 <code>ret</code> 前的 <code>endbr</code> 等别的东西，这个对 CET 以外的 CFI 也有帮助。</li>
</ul>
</li>
<li><p><strong>Shadow Stack</strong>：<code>-mshstk</code></p>
<ul>
<li>允许用一组内建函数操作 shadow stack（<code>__builtin_*ssp</code>）；</li>
<li>一般应用程序不需要手撸这些，<strong>只要链接器&#x2F;loader 打开 SHSTK，CALL&#x2F;RET 就会自动维护影子栈</strong>；</li>
<li>这些选项更多是给 runtime&#x2F;库实现用的（比如 glibc 的 setjmp&#x2F;longjmp、信号处理要专门配合 shadow stack）。</li>
</ul>
</li>
</ol>
<p>Linker 负责在最终 ELF 里写 <code>.note.gnu.property</code>：</p>
<ul>
<li><code>-z shstk</code> → 写入 <code>GNU_PROPERTY_X86_FEATURE_1_SHSTK</code></li>
<li><code>-z ibt</code>   → 写入 <code>GNU_PROPERTY_X86_FEATURE_1_IBT</code></li>
<li>两个都加 → 一起写，表示这个 ELF <strong>支持&#x2F;需要 CET 双开</strong>。</li>
</ul>
<p>这样：</p>
<ol>
<li>CPU &amp; 内核支持 CET；</li>
<li>ELF 声明自己是 CET‑compatible；</li>
<li>loader 自动为该进程打开 IBT + SHSTK，分配影子栈。</li>
</ol>
<h3 id="判断环境的-CET-支持"><a href="#判断环境的-CET-支持" class="headerlink" title="判断环境的 CET 支持"></a>判断环境的 CET 支持</h3><blockquote>
<p>已经满足“内核 ≥ 6.6 + glibc ≥ 2.39”的条件，<strong>系统级 CET（IBT+SHSTK）才真正开始落地</strong>；</p>
</blockquote>
<ol>
<li><p><strong>看 CPU 支不支持 CET</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E <span class="string">&#x27;shstk|ibt|cet&#x27;</span> /proc/cpuinfo</span><br></pre></td></tr></table></figure></div>

<p>新一点的 Intel&#x2F;AMD CPU 会在 <code>flags</code> 里出现 CET 相关标志（不同代的名字略有差异）。</p>
</li>
<li><p><strong>看内核有没有开用户态 SHSTK &#x2F; IBT</strong></p>
<p>看内核配置（假设有 <code>/proc/config.gz</code>）：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zgrep -E <span class="string">&#x27;CET|SHADOW_STACK|IBT&#x27;</span> /proc/config.gz</span><br></pre></td></tr></table></figure></div>

<p>在带有 CET 支持的内核树里，文档明确说现在 <strong>x86‑64 只支持“userspace shadow stack + kernel IBT”</strong>，也就是你主要关心的是：</p>
<blockquote>
<p><code>CONFIG_X86_USER_SHADOW_STACK=y</code>、用户态 IBT 支持是否打开。</p>
</blockquote>
</li>
</ol>
<p>另外，Linux 文档里提到可以在 <code>/proc/self/status</code> 里看 per‑thread 特性，比如：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep x86_Thread /proc/self/status</span><br></pre></td></tr></table></figure></div>

<h1 id="远程交互技巧"><a href="#远程交互技巧" class="headerlink" title="远程交互技巧"></a>远程交互技巧</h1><h2 id="Pwn-题常见交互类型"><a href="#Pwn-题常见交互类型" class="headerlink" title="Pwn 题常见交互类型"></a>Pwn 题常见交互类型</h2><p>大多数 CTF pwn 题可以粗糙归成三类。</p>
<h3 id="xinetd-socat-等-0-1-2-重定向"><a href="#xinetd-socat-等-0-1-2-重定向" class="headerlink" title="xinetd &#x2F; socat 等 + 0&#x2F;1&#x2F;2 重定向"></a>xinetd &#x2F; socat 等 + 0&#x2F;1&#x2F;2 重定向</h3><p>CTF 题目基本都是这种形式——<strong>建立接 TCP 链接，然后把这个 TCP socket 接到子进程的 0&#x2F;1&#x2F;2 上，最后 exec 题目程序</strong>。</p>
<p>例如使用 <code>socat</code>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat TCP-LISTEN:9999,reuseaddr,fork EXEC:<span class="string">&quot;./chall&quot;</span>,pty,stderr</span><br></pre></td></tr></table></figure></div>

<p>过程大概是：</p>
<ol>
<li><p>开一个 TCP 监听端口 9999</p>
</li>
<li><p>有人连上来 → fork 一个子进程专门处理</p>
</li>
<li><p>子进程：</p>
<ul>
<li>把这个 TCP socket 和一个 pty 连起来</li>
<li>把 <code>./chall</code> 的 stdin&#x2F;stdout&#x2F;stderr 接到这个 pty 上</li>
</ul>
</li>
<li><p><code>./chall</code> 还是以为自己在跟一个“终端”交互（因为看到的是 pty），但实际上所有数据都是通过 TCP 传进来的。</p>
</li>
</ol>
<p>inetd &#x2F; systemd 也是类似，只是配置更复杂。</p>
<h3 id="题目自己写-socket-服务器"><a href="#题目自己写-socket-服务器" class="headerlink" title="题目自己写 socket 服务器"></a>题目自己写 socket 服务器</h3><p>有一些题目在 C 代码里自己实现了 socket 通信，形式如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    bind(listenfd, ...);</span><br><span class="line">    listen(listenfd, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> connfd = accept(listenfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">// 每个客户端一个 connfd</span></span><br><span class="line">        <span class="comment">// 有的题这里 fork / pthread_create 给每个连接一个子进程/线程</span></span><br><span class="line"></span><br><span class="line">        handle_client(connfd);</span><br><span class="line">        close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>对于这类题目我们只能与题目主动建立的 sock 通信，而题目本身的 0&#x2F;1&#x2F;2 通常不暴露出来。</p>
<p>而 <code>system()</code> 的行为等价于在子进程里执行：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execl(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, command, (<span class="type">char</span> *)<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></div>

<p>即：fork + 在子进程 exec <code>/bin/sh -c command</code></p>
<p>此时子进程会<strong>继承父进程所有打开的 fd</strong>，包括 0&#x2F;1&#x2F;2 和 connfd，但 <strong>&#x2F;bin&#x2F;sh 只把 0&#x2F;1&#x2F;2 当作自己的 stdin&#x2F;stdout&#x2F;stderr</strong></p>
<p>此时实际效果是：</p>
<ul>
<li>程序在服务器上确实 fork 出了一个 <code>/bin/sh</code>；</li>
<li>但这个 shell 正在从 <strong>某个本地终端 &#x2F; &#x2F;dev&#x2F;null &#x2F; 日志管道</strong>（fd0）读命令，把输出写到那里（fd1&#x2F;2）；</li>
<li>**完全没有走你连过来的那个 TCP socket (connfd)**。</li>
</ul>
<p>所以远程视角就是：</p>
<blockquote>
<p>你连上服务 → 发 payload → 程序里 <code>system(&quot;/bin/sh&quot;)</code> → 你这边既看不到提示也发不了命令，连接要么卡死，要么被服务端断开。</p>
</blockquote>
<p>在“自己写 socket 服务器、只用 connfd 读写”的题里，<strong>裸 <code>system(&quot;/bin/sh&quot;)</code> 通常是拿不到“远程交互 shell”的</strong> —— shell 是开了，但你根本够不到它。</p>
<p>为了能够拿到交互式 shell，我们的思路是<strong>要么让 shell 用 connfd 当 0&#x2F;1&#x2F;2，要么自己在 shell 命令里做重定向。</strong></p>
<h3 id="QEMU-环境里的用户态-pwn"><a href="#QEMU-环境里的用户态-pwn" class="headerlink" title="QEMU 环境里的用户态 pwn"></a>QEMU 环境里的用户态 pwn</h3><p>典型就是各种内核 pwn 环境 &#x2F; 类内核 pwn 题。一般给你一个 <code>run.sh</code>，里面是类似：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 128M \</span><br><span class="line">    -kernel vmlinuz \</span><br><span class="line">    -initrd initramfs.cpio.gz \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 kaslr ... panic=1&quot;</span> \</span><br><span class="line">    -nographic \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -no-reboot</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>-nographic</code> + <code>console=ttyS0</code> 把 guest 的内核和用户空间的输出都走串口 <code>ttyS0</code>，<br>这个串口再被重定向到 QEMU 的 stdout &#x2F; stdin 上。</p>
<p>有的脚本还会用 <code>-serial mon:stdio</code>，同样是把串口控制台绑定到宿主机 stdio。</p>
<p>于是链路就变成：</p>
<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">你本地的终端 / pwntools</span><br><span class="line">    ↕ (SSH / socat / nc)</span><br><span class="line">远程机器上的 shell</span><br><span class="line">    ↕ (QEMU 进程的 stdin/stdout, 可能还有一层 socat pty)</span><br><span class="line">QEMU 串口 / console=ttyS0</span><br><span class="line">    ↕</span><br><span class="line">guest 里的 /bin/sh / 你的用户态 chall</span><br></pre></td></tr></table></figure></div>

<p><strong>这和前面第一种的差别在于：</strong></p>
<ul>
<li>你并不是直接连到 <code>/chall</code> 的 stdin&#x2F;stdout 上；</li>
<li>你是连到了“外面一层的 shell &#x2F; QEMU console”，中间隔了一层 TTY &#x2F; pty；</li>
</ul>
<p>QEMU console 本质上是一个终端设备（串口 → host TTY 或 pty），有：</p>
<ul>
<li>行编辑、回显；</li>
<li><code>Ctrl+C</code> &#x2F; <code>Ctrl+Z</code> &#x2F; <code>Ctrl+D</code> 等信号；</li>
<li><code>DELETE</code>、<code>Ctrl+V(LNEXT)</code> 等控制字符。</li>
</ul>
<p>如果你在<strong>自己本地的终端里</strong>再跑一个 <code>nc</code>，然后再连到远程 QEMU，则某些字符会被远程 TTY 处理掉。</p>
<p>例如发送 <code>\x7f</code> 会被当成 DELETE 键，真的删掉前一个字符。而 64bit glibc 的地址里几乎总有 <code>\x7f</code> 开头的字节，所以如果你直接把 ROP 链扔过去，这个字节会被 TTY 行规吃掉。</p>
<p><strong>解决方法就是用 socat 的 pty escape 字节 <code>\x16</code> 把这些控制字符转义。</strong></p>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>在类 Unix 系统里，每个进程都有一张“文件描述符表”：</p>
<ul>
<li><code>0</code> → 标准输入 <code>stdin</code></li>
<li><code>1</code> → 标准输出 <code>stdout</code></li>
<li><code>2</code> → 标准错误 <code>stderr</code></li>
</ul>
<p>每个 fd 都指向一个“打开文件对象”（open file description），可以是：</p>
<ul>
<li>终端 <code>/dev/tty</code></li>
<li>普通文件</li>
<li>管道 &#x2F; socket（pwn 里最常见）</li>
</ul>
<p><strong>关键点：</strong></p>
<blockquote>
<p>多个 fd（比如 0 和 1）可以指向同一个底层对象，这就是 <code>dup / dup2</code> 干的事。</p>
</blockquote>
<h3 id="dup-重定向"><a href="#dup-重定向" class="headerlink" title="dup 重定向"></a>dup 重定向</h3><p><code>dup</code>&#x2F;<code>dup2</code> 的语义（man dup2）是：</p>
<blockquote>
<p><strong>dup(oldfd)</strong><br>分配一个新的文件描述符，这个新 fd 指向和 <code>oldfd</code> <strong>相同的 open file description</strong>，<br>并且保证“新 fd 是当前进程中<strong>最小的那个空闲 fd</strong>”。</p>
</blockquote>
<blockquote>
<p><strong>dup2(oldfd, newfd)</strong><br>做的事跟 <code>dup</code> 一样，但不是“找一个最小空闲 fd”，<br>而是<strong>强制让 <code>newfd</code> 变成 <code>oldfd</code> 的副本</strong>。<br>如果 <code>newfd</code> 之前已经打开，则先静默 <code>close(newfd)</code>。<br>如果 <code>newfd == oldfd</code>，<code>dup2</code> 直接什么都不做，返回这个 fd。</p>
</blockquote>
<p>也就是说：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> newfd = dup(oldfd);</span><br><span class="line"><span class="comment">// 等价于：找一个最小的可用fd号 X，然后让 X 指向 oldfd 的那个 open file description</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> newfd = dup2(oldfd, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 等价于：close(3); 然后让 3 指向 oldfd 的那个 open file description</span></span><br></pre></td></tr></table></figure></div>

<p>因此如果是直接 socket 通信而不是重定向 0&#x2F;1&#x2F;2 的 pwn 题目，在 shellcode 里经典套路是：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dup2(sock, <span class="number">0</span>);</span><br><span class="line">dup2(sock, <span class="number">1</span>);</span><br><span class="line">dup2(sock, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 然后 execve(&quot;/bin/sh&quot;, ...)</span></span><br></pre></td></tr></table></figure></div>

<p>效果就是：</p>
<blockquote>
<p>“把 <strong>标准输入、标准输出、标准错误</strong> 这 3 个 fd 全都指到这个网络 socket 上。”</p>
</blockquote>
<p>因为通常在 CTF 环境中 <code>sock</code> 这个文件描述符的值是稳定可预测的，因此完全可以通过这种方法让 shell 的标准输入输出都走你的 socket，你也就得到一个交互 shell。</p>
<h3 id="shell-重定向"><a href="#shell-重定向" class="headerlink" title="shell 重定向"></a>shell 重定向</h3><p>有些题目会 <code>close(1)</code> 关闭输出，对于这种场景我们可以通过 shell 重定向让 sdterr 充当 stdout。</p>
<p>在 sh &#x2F; bash 里，重定向语法有一种是：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[n]&gt;&amp;word</span><br></pre></td></tr></table></figure></div>

<p>如果 <code>word</code> 展开为数字 <code>m</code>，语义是：</p>
<blockquote>
<p>“把文件描述符 <strong>m</strong> 所指向的那个对象，复制一份给 <strong>n</strong>。”<br>即：让 fd n 变成 fd m 的一个副本。([Stack Overflow][3])</p>
</blockquote>
<p>所以：</p>
<ul>
<li><code>2&gt;&amp;1</code>：让 stderr（2）变成 stdout（1）的副本（命令的错误输出会跟着标准输出走）。([Super User][4])</li>
<li><strong><code>1&gt;&amp;0</code>：让 stdout（1）变成 stdin（0）的副本。</strong></li>
</ul>
<p>这不是“把 0 的内容复制一份到 1”，而是<strong>把两个 fd 接到同一个东西上</strong>，之后：</p>
<ul>
<li>写入 fd 1 → 写入那个底层对象；</li>
<li>读 &#x2F; 写 fd 0 → 也是同一个底层对象。</li>
</ul>
<p>底层对应的系统调用就是：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dup2(src_fd, dst_fd);   <span class="comment">// dst_fd 变成 src_fd 的别名</span></span><br></pre></td></tr></table></figure></div>

<p>比如 <code>1&gt;&amp;0</code> 本质就是 <code>dup2(0, 1)</code>。</p>
<p><code>exec</code> 在 shell 里有两种用法：</p>
<ol>
<li><code>exec /bin/ls</code>：用 ls <strong>替换当前 shell 进程</strong>；</li>
<li><code>exec 1&gt;file</code> &#x2F; <code>exec 1&gt;&amp;0</code>：<strong>不带命令，只带重定向</strong> → 修改“当前 shell 自己”的文件描述符。</li>
</ol>
<p>POSIX &#x2F; bash 手册里说得很明白：</p>
<blockquote>
<p>使用 <code>exec</code> 并只带重定向时，这些重定向会修改当前 shell 的文件描述符，而不是新进程。</p>
</blockquote>
<p>还有一条：</p>
<blockquote>
<p>如果不带参数，<code>exec</code> 只是重定义当前 shell 的文件描述符，执行完后 shell 继续跑，只是之后的 stdin&#x2F;stdout&#x2F;stderr 都变了。</p>
</blockquote>
<p>所以：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> 1&gt;&amp;0</span><br></pre></td></tr></table></figure></div>

<p>&#x3D; “在<strong>当前 shell 进程里</strong>执行一次 <code>dup2(0, 1)</code>，之后这个 shell（以及它之后 fork&#x2F;exec 出来的子进程）都会继承这个新的 fd 布局”。</p>
<p>如果你写成：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">some_cmd 1&gt;&amp;0</span><br></pre></td></tr></table></figure></div>

<p>那只是：<code>some_cmd</code> 这个进程的 stdout 被改成 stdin，对当前 shell 的 fd 没影响，命令结束就归零了。</p>
<p><strong>pwn 里我们想要的是“把 &#x2F;bin&#x2F;sh 本身的 stdout 改回来，并且持续生效”，所以要用 <code>exec 1&gt;&amp;0</code>。</strong></p>
<p>另外像 socket 服务器这种类型的题目，由于 <code>system</code> 启的进程可以继承父进程的文件描述符。也就是说我们建立的 socket 也可以被 <code>/bin/sh</code> 继承过去，我们可以采用下面这种方式（假设 <code>socketfd = 4</code>）通过 shell 重定向来获得一个交互式 shell。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system(<span class="string">&quot;/bin/sh &lt;&amp;4 &gt;&amp;4 2&gt;&amp;4&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>不过这种方法成功的前提是 <strong>fd 4 没有被 FD_CLOEXEC 掉</strong>。</p>
<blockquote>
<p><code>FD_CLOEXEC</code> 是一个<strong>“文件描述符标志”</strong>，名字叫 <strong>close‑on‑exec</strong>。这个标志跟某个 fd 绑定（比如 fd&#x3D;4），用 <code>fcntl(fd, F_GETFD / F_SETFD)</code> 操作。含义是：</p>
<p>如果某个 fd 的 <code>FD_CLOEXEC</code> 置位（&#x3D;1），那<strong>当这个进程调用任何 <code>exec*</code> 系列函数成功时</strong>，这个 fd 会被内核<strong>自动关闭</strong>。</p>
<p>反之，如果 <code>FD_CLOEXEC</code> 没开（&#x3D;0），那这个 fd 会在 <code>execve()</code> 之后<strong>继续保持打开</strong>，被新程序继承。</p>
<p>因此只有 fd 4 没有被 FD_CLOEXEC 掉，这样 <code>system()</code> 里的 <code>/bin/sh</code> 才能继承这个 fd。</p>
</blockquote>
<h2 id="IO-通信"><a href="#IO-通信" class="headerlink" title="IO 通信"></a>IO 通信</h2><h3 id="题目读入函数"><a href="#题目读入函数" class="headerlink" title="题目读入函数"></a>题目读入函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>是否读空格</th>
<th>截断条件（停止条件）</th>
<th>自动加 <code>&#39;\0&#39;</code></th>
<th>长度控制</th>
<th>备注 &#x2F; 安全提示</th>
</tr>
</thead>
<tbody><tr>
<td><code>gets(buf)</code></td>
<td>✅ 能</td>
<td>遇到首个 <code>\n</code>（<strong>丢弃</strong>该换行）或 EOF</td>
<td>✅ 是（成功时）</td>
<td>❌ 无</td>
<td><strong>已被 C11 移除，严禁使用</strong>；无法限制长度，极不安全。</td>
</tr>
<tr>
<td><code>fgets(buf, n, stdin)</code></td>
<td>✅ 能</td>
<td>读到 <code>\n</code>（<strong>保留</strong>在缓冲区）、或读满 <code>n-1</code>、或 EOF&#x2F;错误</td>
<td>✅ 是＊（若至少读到 1 字节；否则返回 <code>NULL</code>）</td>
<td>✅ 由 <code>n</code> 限制</td>
<td>常见坑：换行会保留；若一开始就 EOF&#x2F;错误，缓冲区<strong>不改动</strong>、返回 <code>NULL</code>。</td>
</tr>
<tr>
<td><code>scanf(&quot;%s&quot;, buf)</code></td>
<td>❌ 不能（以任一空白为分隔）</td>
<td>遇到空白字符（空格&#x2F;<code>\t</code>&#x2F;<code>\n</code> 等；会<strong>跳过前导空白</strong>）</td>
<td>✅ 是＊（成功匹配时）</td>
<td>❌ 默认无；应写宽度如 <code>%Ns</code></td>
<td>对 <code>%s</code> 和 <code>%[</code> <strong>必须</strong>写入字段宽度，否则同样不安全；<code>s</code> 会写终止符。</td>
</tr>
<tr>
<td><code>scanf(&quot;%[^\n]&quot;, buf)</code></td>
<td>✅ 能</td>
<td>遇到 <code>\n</code>（<strong>不消费</strong>该换行，仍留在输入流中）或达字段宽度</td>
<td>✅ 是＊（成功匹配时）</td>
<td>❌ 默认无；应写 <code>%N[^\n]</code></td>
<td>扫描集会把空格读入结果；由于不消费换行，后续读取前最好先丢弃该换行。</td>
</tr>
<tr>
<td><code>read(fd, buf, size)</code></td>
<td>✅ 能</td>
<td>读满 <code>size</code> 或 EOF（返回已读字节数）</td>
<td>❌ 否</td>
<td>✅ 由 <code>size</code> 精确控制</td>
<td>原始字节读取（系统调用），<strong>不会</strong>追加终止符；若要当 C 字符串用，需手动补 <code>&#39;\0&#39;</code>。</td>
</tr>
<tr>
<td><code>getline(&amp;buf, &amp;len, stdin)</code></td>
<td>✅ 能</td>
<td>读到 <code>\n</code>（<strong>保留</strong>在缓冲区）或 EOF&#x2F;错误</td>
<td>✅ 是（成功时）</td>
<td>✅ <strong>自动扩容</strong>（必要时 <code>realloc</code>）</td>
<td>POSIX 接口（ISO C 未定义）；返回字节数（<strong>包含</strong>换行，不包含终止 <code>&#39;\0&#39;</code>）。</td>
</tr>
</tbody></table>
<blockquote>
<p>在 <strong>C 语言 <code>C</code> locale</strong> 下，<code>isspace()</code> 判定为空白的<strong>仅</strong>以下 6 个字符（也是 <code>scanf</code>&#x2F;<code>printf</code> 相关规则里的空白集合）：</p>
<ul>
<li>空格：<code>&#39; &#39;</code></li>
<li>水平制表：<code>&#39;\t&#39;</code> (HT)</li>
<li>换行：<code>&#39;\n&#39;</code> (LF)</li>
<li>垂直制表：<code>&#39;\v&#39;</code> (VT)</li>
<li>换页：<code>&#39;\f&#39;</code> (FF)</li>
<li>回车：<code>&#39;\r&#39;</code> (CR)</li>
</ul>
</blockquote>
<h3 id="shutdown-技巧"><a href="#shutdown-技巧" class="headerlink" title="shutdown 技巧"></a>shutdown 技巧</h3><p><code>close(fd)</code> 会把当前进程里的这个 fd 直接关掉，之后对这个 fd 的读写都会失败；如果这是最后一个指向该 socket 的引用，底层连接也会被内核关闭。</p>
<p>对于 socket，更细粒度地控制可以用 <code>shutdown(sockfd, how)</code>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> how)</span>;</span><br><span class="line"><span class="comment">/* how = SHUT_RD(0) / SHUT_WR(1) / SHUT_RDWR(2) */</span></span><br></pre></td></tr></table></figure></div>

<p>以 TCP 为例：</p>
<ul>
<li><p><code>SHUT_WR</code>：本端写方向关闭</p>
<ul>
<li>后续 <code>send</code> &#x2F; <code>write</code> 失败；</li>
<li>内核向对端发送 FIN，对端继续读，数据耗尽后再读会得到返回值 0（EOF）；</li>
<li>本端仍可继续 <code>recv</code> 对端发送的数据。</li>
</ul>
</li>
<li><p><code>SHUT_RD</code>：本端读方向关闭</p>
<ul>
<li>本端不再接收数据（后续 <code>recv</code> 直接失败或返回 0），不会给对端发 FIN；</li>
<li>对端仍可继续 <code>send</code>，但这些数据会在本端内核中被丢弃。</li>
</ul>
</li>
<li><p><code>SHUT_RDWR</code>：同时关闭读、写方向，但 fd 仍存在，需要额外 <code>close()</code> 释放。</p>
</li>
</ul>
<p>在 pwn 里常见的场景是：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((n = read(<span class="number">0</span>, buf, <span class="keyword">sizeof</span> buf)) &gt; <span class="number">0</span>)</span><br><span class="line">    handle(buf, n);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;bye&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>程序只有在读到 EOF 时才会打印 <code>&quot;bye&quot;</code>。</p>
<p>pwntools 脚本中，如果直接 <code>p.close()</code>，连接会整体结束，收不到 <code>&quot;bye&quot;</code>。</p>
<p>正确做法是半关闭写端：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p.send(payload)</span><br><span class="line">p.shutdown(<span class="string">&#x27;send&#x27;</span>)      <span class="comment"># 半关写端，相当于 shutdown(SHUT_WR)</span></span><br><span class="line"><span class="built_in">print</span>(p.recvall().decode())</span><br></pre></td></tr></table></figure></div>

<p><code>tube.shutdown(direction)</code> 的语义，就是帮你在后端 socket&#x2F;pipe 上做 <code>shutdown</code> 或关闭一端的 pipe。其中的的 <code>direction</code> 可以是：</p>
<ul>
<li><code>&quot;in&quot;</code>, <code>&quot;read&quot;</code>, <code>&quot;recv&quot;</code>：关闭“读”方向；</li>
<li><code>&quot;out&quot;</code>, <code>&quot;write&quot;</code>, <code>&quot;send&quot;</code>：关闭“写”方向。</li>
</ul>
<p>对远程 TCP 题目，<code>shutdown(&#39;send&#39;)</code> 最常见，用来触发对端读到 EOF 之后的逻辑（比如结束循环、输出 flag）。</p>
<h3 id="tty-转义绕过"><a href="#tty-转义绕过" class="headerlink" title="tty 转义绕过"></a>tty 转义绕过</h3><p>你在本地终端里跑：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span></span><br></pre></td></tr></table></figure></div>

<p>然后你敲键盘：</p>
<ul>
<li>敲 <code>a b c</code> → 终端窗口里看到 <code>abc</code>，<code>cat</code> 进程也收到字节 <code>0x61 0x62 0x63</code>；</li>
<li>敲 <code>Backspace</code> → 屏幕上删掉一个字符；<code>cat</code> 并没有收到“Backspace”这个按键，而是终端自己把刚刚那一位删掉了；</li>
<li>敲 <code>Ctrl+C</code> → 屏幕上出现 <code>^C</code>，<code>cat</code> 进程被 kill 掉（收到 SIGINT），它根本没读到字节 <code>0x03</code>；</li>
<li>敲 <code>Ctrl+D</code> → <code>cat</code> 结束（读到 EOF），并不是收到 <code>0x04</code> 字节。</li>
</ul>
<p><strong>重点：在你的程序和键盘之间，还有一层“终端驱动 &#x2F; 行规（line discipline）”在搞事情。</strong></p>
<p>这层就是 <code>/dev/tty</code> &#x2F; <code>/dev/pts/N</code> 对应的终端设备，负责：</p>
<ul>
<li>把按键转换成字节流；</li>
<li>对某些组合做特殊处理（Ctrl+C → SIGINT，Ctrl+Z → SIGTSTP，Ctrl+D → EOF 等）；</li>
<li>做行编辑、回显、删除、历史记录等等。</li>
</ul>
<p>POSIX 里定义了一个控制字符叫 <strong>VLNEXT &#x2F; lnext</strong>（literal next），在绝大多数系统上默认是 <strong>Ctrl‑V（0x16）</strong>。<br>你可以 <code>stty -a</code> 看配置，会有一行类似：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lnext = ^V;</span><br></pre></td></tr></table></figure></div>

<p>意思是：<strong>“下一个字符按字面含义处理，不要当控制字符。”</strong></p>
<p>所以在终端里：</p>
<ul>
<li><p>直接按 <code>Ctrl+C</code>：终端把这次按键当作“中断键”，发 SIGINT，程序死；</p>
</li>
<li><p>按 <code>Ctrl+V</code> 然后 <code>Ctrl+C</code>：</p>
<ul>
<li>终端先看到 <code>Ctrl+V</code>（lnext），切换成“literal next 一次”模式；</li>
<li>下一次按 <code>Ctrl+C</code> 时，不再当成中断，而是真的把字节 <code>0x03</code> 送给程序；</li>
<li>程序就能收到 <code>0x03</code> 这个字节，而不是被干掉。</li>
</ul>
</li>
</ul>
<blockquote>
<p>也正因为如此，在很多文本编辑器里你想插入一个真正的 “Ctrl+S” 字节，常常是 <code>Ctrl+V</code> 再按 <code>Ctrl+S</code>。</p>
</blockquote>
<p>在 CTF 场景中，如果程序的 stdin&#x2F;stdout 连着的是 <strong>&#x2F;dev&#x2F;pts&#x2F;N 这种 TTY 设备</strong>；中间那层“终端 driver &#x2F; line discipline”会截胡控制字符：</p>
<ul>
<li>你发 <code>0x03</code> → 变成 SIGINT；</li>
<li>发 <code>0x04</code> → 被当成 EOF；</li>
<li>发 <code>0x7f</code> → 被当成 DEL，删前一个字符（在 canonical 模式）；</li>
</ul>
<p>如果你要做“文件传输 &#x2F; 传 shellcode &#x2F; 任意字节流”，这些字节不能被 TTY 吃掉，于是你就希望<strong>先发一个 lnext，然后再发控制字符本身</strong>。</p>
<p>pwntools 的 <code>tty_escape</code> 就是专门为后面这种场景设计的。Release note 里明确写过：</p>
<blockquote>
<p>“Add TTY escape function for file transfer”</p>
</blockquote>
<p>该函数实现如下：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tty_escape</span>(<span class="params">s, lnext=<span class="string">b&#x27;\x16&#x27;</span>, dangerous=<span class="built_in">bytes</span>(<span class="params"><span class="built_in">bytearray</span>(<span class="params"><span class="built_in">range</span>(<span class="params"><span class="number">0x20</span></span>)</span>)</span>)</span>):</span><br><span class="line">    s = s.replace(lnext, lnext * <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> <span class="built_in">bytearray</span>(dangerous):</span><br><span class="line">        b = <span class="built_in">bytes</span>(<span class="built_in">bytearray</span>([b]))</span><br><span class="line">        <span class="keyword">if</span> b <span class="keyword">in</span> lnext: <span class="keyword">continue</span></span><br><span class="line">        s = s.replace(b, lnext + b)</span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure></div>

<p>pwntools 的文档这样说：</p>
<blockquote>
<ul>
<li><code>s (bytes)</code>: 要转义的数据</li>
<li><code>lnext (bytes)</code>: 用来“引用下一个字符”的字节，默认是 <code>^V</code>（0x16）</li>
<li><code>dangerous (bytes)</code>: 认为“危险，需要转义”的字节集合</li>
</ul>
</blockquote>
<p>默认参数：</p>
<ul>
<li><code>lnext = b&#39;\x16&#39;</code> → Ctrl‑V；</li>
<li><code>dangerous = bytes(range(0x20))</code> → 0x00–0x1f 所有 ASCII 控制字符；</li>
</ul>
<p>也就是说：<strong>默认认为所有 0x00–0x1f 都是“危险字符”，要用 lnext 前缀保护起来。</strong></p>
<h1 id="如何使用题目提供的-docker-环境"><a href="#如何使用题目提供的-docker-环境" class="headerlink" title="如何使用题目提供的 docker 环境"></a>如何使用题目提供的 docker 环境</h1><h2 id="netcat"><a href="#netcat" class="headerlink" title="netcat"></a>netcat</h2><p>在<a class="link"   target="_blank" rel="noopener" href="https://netcat.sourceforge.net/" >官网<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>下载项目源码，使用如下命令进行编译。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure LDFLAGS=-static <span class="comment"># 考虑到 docker 环境恶劣选择静态编译</span></span><br><span class="line">make -j24 <span class="comment"># 编译</span></span><br></pre></td></tr></table></figure></div>

<p>编译后生成的 <code>netcat</code> 位于项目 <code>src</code> 目录下。<code>netcat</code> 即我们常用的 <code>nc</code> 命令对应的可执行程序。</p>
<p>在 docker 中使用如下命令将题目 io 映射到 8888 端口。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./netcat -lvp 8888 -e ./pwn</span><br></pre></td></tr></table></figure></div>

<p>在本机可以使用如下命令连接并交互。（前提是 docker 的 8888 端口映射到本机的 8888 端口）</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc 127.0.0.1 8888</span><br></pre></td></tr></table></figure></div>

<h2 id="gdb-1"><a href="#gdb-1" class="headerlink" title="gdb"></a>gdb</h2><p>在<a class="link"   target="_blank" rel="noopener" href="https://www.sourceware.org/gdb/download/" >官网<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>下载项目源码，使用如下命令编译 gdbserver ：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install libgmp-dev libmpfr-dev</span><br><span class="line"><span class="built_in">cd</span> gdb-9.2/gdb/gdbserver</span><br><span class="line">./configure LDFLAGS=-static</span><br><span class="line">make -j $(<span class="built_in">nproc</span>)</span><br></pre></td></tr></table></figure></div>

<p>对于 gdb ，由于编译 gdb 时依赖的静态库需要提前编译，因此想要编译 gdb 最好直接编译整个项目：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> gdb-9.2</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">../configure   LDFLAGS=-static</span><br><span class="line">make -j $(<span class="built_in">nproc</span>)</span><br></pre></td></tr></table></figure></div>

<p>注意以下几点：</p>
<ul>
<li>编译的 <code>gdbserver</code> 版本一定要与本机的 <code>gdb</code> 匹配，不同版本的 <code>gdbserver</code> 通信协议不同。</li>
<li>有的时候在 <code>gdbserver</code> 中运行 <code>./configuer</code> 命令会出现找不到 <code>Makefile</code> 的情况，这时在根目录进行一次编译就好了。</li>
<li>连接失败之后再运行一次编译命令就可能编译成功。</li>
<li><code>gdb</code> 位于 <code>./gdb/gdb</code> 中。</li>
<li><code>gdbserver</code> 位于 <code>./gdbserver/gdbserver</code> 中。</li>
</ul>
<h2 id="docker-1"><a href="#docker-1" class="headerlink" title="docker"></a>docker</h2><ul>
<li><p>加载镜像</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i 题目附件.tar</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>查看现有镜像</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>启动容器</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --privileged -it -w /home/ctf -v ~/Desktop/本机目录:/home/ctf/镜像目录 -p 8888:8888 -p 9999:9999 镜像名 /bin/bash </span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>--privileged</code>：加这个参数才能 <code>gdbserver</code> 附加进程远程调试</li>
<li><code>-v</code>：目录映射，方便传文件。</li>
<li><code>-p</code>：端口映射，开两个端口分别给 <code>netcat</code> 和 <code>gdbserver</code> 用。改用 <code>--net=host</code> 可以映射全部端口。</li>
<li><code>-w</code>：进入 docker 后目录为 <code>/home/ctf</code> 。</li>
</ul>
</li>
<li><p>查看现有容器 </p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>进容器 shell ，即同一个容器再开一个 shell 。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker <span class="built_in">exec</span> -it -w /home/ctf 容器ID /bin/bash</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>停止所有容器：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop $(docker ps -a -q)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>删除所有容器：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> $(docker ps -a -q)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>删除所有镜像：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p><code>exp.py</code> 模板如下：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8888</span>) <span class="comment"># nc 连接远程程序</span></span><br><span class="line"></span><br><span class="line">gdb.attach(target=(<span class="string">&quot;localhost&quot;</span>, <span class="number">9999</span>), exe=<span class="string">&quot;./pwn&quot;</span>, gdbscript=<span class="string">&quot;&quot;</span>) <span class="comment"># gdb 连接 docker 中的 gdbserver 调试 ./pwn</span></span><br><span class="line"></span><br><span class="line">pause() <span class="comment"># 阻塞脚本直到 gdb 成功连接 gdbserver防止程序跑飞</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">r.sendlineafter(&quot;xxxx&quot;, &quot;xxx&quot;) # 脚本远程交互</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>运行脚本前首先在 docker 容器中用 <code>netcat</code> 将题目程序 IO 映射到 8888 端口：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./netcat -lvp 8888 -e ./pwn</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>运行脚本，阻塞在 <code>gdb.attach</code> 时脚本已经与远程的 <code>netcat</code> 连接，此时 docker 镜像中已经有 <code>pwn</code> 这个进程了。此时使用 <code>ps -aux | grep pwn</code> 查看进程 <code>pid</code> 然后运行如下命令让 <code>gdbserver</code> 附加进程并监听 9999 端口。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdbserver :9999 --attach 进程pid</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>此时脚本执行 <code>gdb.attach</code> 连接 docker 中的 <code>gdbserver</code> 并阻塞在 <code>pause()</code> 上直到 <code>gdb</code> 成功连接 <code>gdbserver</code> 。</p>
</li>
<li><p>在脚本运行窗口按回车解除阻塞进行调试。</p>
</li>
</ul>
<p>其中 docker 中的操作可以通过脚本自动化实现。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">IMAGE_NAME=minipy-debug</span><br><span class="line">CONTAINER_HOME=/home/ctf</span><br><span class="line">PROG_NAME=minipy</span><br><span class="line">NC_PORT=8888</span><br><span class="line">DBG_PORT=9999</span><br><span class="line"></span><br><span class="line"><span class="comment"># load image</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="subst">$(docker images | grep $&#123;IMAGE_NAME&#125; | wc -l)</span>&quot;</span> -lt <span class="string">&quot;1&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    docker load -i <span class="variable">$&#123;IMAGE_NAME&#125;</span>.tar</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># start continer</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="subst">$(docker ps | grep $&#123;IMAGE_NAME&#125; | wc -l)</span>&quot;</span> -lt <span class="string">&quot;1&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="comment">#   docker run --privileged -itd -p $&#123;DBG_PORT&#125;:$&#123;DBG_PORT&#125; -p $&#123;NC_PORT&#125;:$&#123;NC_PORT&#125; $&#123;IMAGE_NAME&#125;</span></span><br><span class="line">    docker run --privileged -itd --net=host <span class="variable">$&#123;IMAGE_NAME&#125;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># get continer id</span></span><br><span class="line">CONTAINER_ID=$(docker ps -q --filter <span class="string">&quot;ancestor=<span class="variable">$&#123;IMAGE_NAME&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># cp files</span></span><br><span class="line">docker <span class="built_in">cp</span> ./tools/gdbserver <span class="variable">$&#123;CONTAINER_ID&#125;</span>:<span class="variable">$&#123;CONTAINER_HOME&#125;</span></span><br><span class="line">docker <span class="built_in">cp</span> ./tools/netcat <span class="variable">$&#123;CONTAINER_ID&#125;</span>:<span class="variable">$&#123;CONTAINER_HOME&#125;</span></span><br><span class="line">docker <span class="built_in">cp</span> ./<span class="variable">$&#123;PROG_NAME&#125;</span> <span class="variable">$&#123;CONTAINER_ID&#125;</span>:<span class="variable">$&#123;CONTAINER_HOME&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># start run</span></span><br><span class="line">docker <span class="built_in">exec</span> -itd -w <span class="variable">$&#123;CONTAINER_HOME&#125;</span> <span class="variable">$&#123;CONTAINER_ID&#125;</span> /bin/bash -c <span class="string">&quot;./netcat -lvp <span class="variable">$&#123;NC_PORT&#125;</span> -e ./<span class="variable">$&#123;PROG_NAME&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">read</span></span><br><span class="line"></span><br><span class="line">docker <span class="built_in">exec</span> -it -w <span class="variable">$&#123;CONTAINER_HOME&#125;</span> <span class="variable">$&#123;CONTAINER_ID&#125;</span> /bin/bash -c <span class="string">&quot;ps -ef | grep <span class="variable">$&#123;PROG_NAME&#125;</span> | grep -v &#x27;grep&#x27; | grep -v &#x27;\-c&#x27; | awk &#x27;&#123;print \$2&#125;&#x27; | xargs ./gdbserver :<span class="variable">$&#123;DBG_PORT&#125;</span> --attach&quot;</span></span><br><span class="line"><span class="built_in">read</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#docker stop $&#123;CONTAINER_ID&#125;</span></span><br><span class="line"><span class="comment">#docker rm $&#123;CONTAINER_ID&#125;</span></span><br><span class="line"></span><br><span class="line">docker stop $(docker ps -a -q)</span><br><span class="line">docker <span class="built_in">rm</span> $(docker ps -a -q)</span><br></pre></td></tr></table></figure></div>

		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> linux user pwn 基础知识</li>
        <li><strong>Author:</strong> sky123</li>
        <li><strong>Created at
                :</strong> 2024-11-07 18:56:56</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2026-02-03 00:02:59
            </li>
        
        <li>
            <strong>Link:</strong> https://skyi23.github.io/2024/11/07/linux user pwn 基础知识/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/linux-user-pwn/">#linux user pwn</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2024/11/08/linux-IO_FILE-exploit/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">linux IO_FILE 利用</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2022/09/28/linux%20%E7%94%A8%E6%88%B7%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">linux 用户态逆向开发</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'skyI23/my-giscus-discussions',
                'data-repo-id': 'R_kgDONL9k_w',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDONL9k_84CkEdK',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">linux user pwn 基础知识</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="nav-text">环境搭建</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85"><span class="nav-text">虚拟机安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7"><span class="nav-text">基础工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#net-tools"><span class="nav-text">net-tools</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vim"><span class="nav-text">vim</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gedit"><span class="nav-text">gedit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git"><span class="nav-text">git</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gcc"><span class="nav-text">gcc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#python"><span class="nav-text">python</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#docker"><span class="nav-text">docker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#oh-my-zsh"><span class="nav-text">oh-my-zsh</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wsl"><span class="nav-text">wsl</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pwn-%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7"><span class="nav-text">pwn 相关工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#clion"><span class="nav-text">clion</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gdb"><span class="nav-text">gdb</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pwntools"><span class="nav-text">pwntools</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gadget-%E6%90%9C%E7%B4%A2%E5%B7%A5%E5%85%B7"><span class="nav-text">gadget 搜索工具</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ROPgdbget"><span class="nav-text">ROPgdbget</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ropper"><span class="nav-text">ropper</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#one-gadget"><span class="nav-text">one_gadget</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#seccomp-tools"><span class="nav-text">seccomp-tools</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LibcSearcher"><span class="nav-text">LibcSearcher</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#glibc-all-in-one"><span class="nav-text">glibc-all-in-one</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#patchelf"><span class="nav-text">patchelf</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#qemu"><span class="nav-text">qemu</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="nav-text">ELF 文件格式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%A4%B4"><span class="nav-text">文件头</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E5%A4%B4%E8%A1%A8"><span class="nav-text">程序头表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8A%82%E8%A1%A8"><span class="nav-text">节表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A8"><span class="nav-text">字符串表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A"><span class="nav-text">调用约定</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E7%BB%93%E6%9E%84"><span class="nav-text">栈结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B"><span class="nav-text">函数调用过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="nav-text">函数参数传递</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#32-%E4%BD%8D%E7%A8%8B%E5%BA%8F"><span class="nav-text">32 位程序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0"><span class="nav-text">普通函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-text">系统调用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#64%E4%BD%8D%E7%A8%8B%E5%BA%8F"><span class="nav-text">64位程序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0-1"><span class="nav-text">普通函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-1"><span class="nav-text">系统调用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B7"><span class="nav-text">系统调用号</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#32-%E4%BD%8D"><span class="nav-text">32 位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#64-%E4%BD%8D"><span class="nav-text">64 位</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="nav-text">程序编译过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%EF%BC%88Preprocessing%EF%BC%89"><span class="nav-text">预处理（Preprocessing）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%EF%BC%88Compilation%EF%BC%89"><span class="nav-text">编译（Compilation）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%87%E7%BC%96%EF%BC%88Assembly%EF%BC%89"><span class="nav-text">汇编（Assembly）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%EF%BC%88Linking%EF%BC%89"><span class="nav-text">链接（Linking）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ELF-%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84"><span class="nav-text">ELF 相关结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E8%A1%A8%EF%BC%88-symtab%EF%BC%89"><span class="nav-text">符号表（.symtab）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8%EF%BC%88-rel-rela-%EF%BC%89"><span class="nav-text">重定位表（.rel.* &#x2F; .rela.*）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B"><span class="nav-text">链接过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%B6%E9%9B%86-%E5%90%88%E5%B9%B6%E8%8A%82"><span class="nav-text">收集 &amp; 合并节</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E8%A7%A3%E6%9E%90%EF%BC%88Symbol-Resolution%EF%BC%89"><span class="nav-text">符号解析（Symbol Resolution）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D-%E9%9D%99%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D%EF%BC%88Relocation%EF%BC%89"><span class="nav-text">地址分配 &amp; 静态重定位（Relocation）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E8%BF%90%E8%A1%8C%E6%97%B6%E5%85%83%E6%95%B0%E6%8D%AE"><span class="nav-text">生成运行时元数据</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-text">程序执行过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A3%85%E8%BD%BD"><span class="nav-text">装载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E-shell-%E5%88%B0-execve"><span class="nav-text">从 shell 到 execve</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#execve-%E7%9A%84%E5%86%85%E6%A0%B8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">execve 的内核的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-text">进程虚拟地址空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%A0%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">进程栈的初始化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="nav-text">动态链接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ELF-%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84-1"><span class="nav-text">ELF 相关结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#interp-%E6%AE%B5"><span class="nav-text">.interp 段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dynamic-%E6%AE%B5"><span class="nav-text">.dynamic 段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E7%AC%A6%E5%8F%B7%E8%A1%A8%EF%BC%88-dynsym%EF%BC%89"><span class="nav-text">动态符号表（.dynsym）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8%EF%BC%88-rel-dyn-rela-dyn%E3%80%81-rel-plt-rela-plt%EF%BC%89"><span class="nav-text">动态重定位表（.rel.dyn &#x2F; .rela.dyn、.rel.plt &#x2F; .rela.plt）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GOT-%E8%A1%A8%EF%BC%88-got-got-plt%EF%BC%89"><span class="nav-text">GOT 表（.got&#x2F;.got.plt）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PLT-%E8%A1%A8%EF%BC%88-plt-plt-got-plt-sec%EF%BC%89"><span class="nav-text">PLT 表（.plt&#x2F;.plt.got&#x2F;.plt.sec）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B"><span class="nav-text">动态链接过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%99%A8%E8%87%AA%E4%B8%BE"><span class="nav-text">动态链接器自举</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A3%85%E8%BD%BD%E5%85%B1%E4%BA%AB%E5%AF%B9%E8%B1%A1"><span class="nav-text">装载共享对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">重定位和初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">执行构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A"><span class="nav-text">延迟绑定</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#main-%E5%87%BD%E6%95%B0%E4%B9%8B%E5%A4%96%E7%9A%84%E5%90%AF%E5%8A%A8-%E9%80%80%E5%87%BA%E6%B5%81%E7%A8%8B"><span class="nav-text">main 函数之外的启动 &#x2F; 退出流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A5%E5%8F%A3-start"><span class="nav-text">入口 _start</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#libc-start-main-%E5%88%9D%E5%A7%8B%E5%8C%96-%E8%B0%83-main"><span class="nav-text">__libc_start_main 初始化 + 调 main</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#libc-csu-init-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-text">__libc_csu_init 构造函数调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%80%E5%87%BA%E8%B7%AF%E5%BE%84%EF%BC%9Aexit"><span class="nav-text">退出路径：exit</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TLS-%E6%9E%90%E6%9E%84%E9%93%BE%EF%BC%9A-call-tls-dtors-tls-dtor-list"><span class="nav-text">TLS 析构链：__call_tls_dtors + tls_dtor_list</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#exit-funcs%EF%BC%9Aatexit-on-exit-cxa-atexit"><span class="nav-text">__exit_funcs：atexit&#x2F;on_exit&#x2F;__cxa_atexit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E7%A8%8B%E5%BA%8F%E7%9A%84-dl-fini"><span class="nav-text">动态程序的 _dl_fini</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E7%9A%84-libc-csu-fini"><span class="nav-text">静态程序的 __libc_csu_fini</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#libc-atexit-%E5%8C%BA%E6%AE%B5%E4%B8%8E-IO-cleanup%EF%BC%88FSOP%EF%BC%89"><span class="nav-text">__libc_atexit 区段与 _IO_cleanup（FSOP）</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%BA%93"><span class="nav-text">共享库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%BA%93%E7%89%88%E6%9C%AC"><span class="nav-text">共享库版本</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%BA%93%E7%89%88%E6%9C%AC%E5%91%BD%E5%90%8D"><span class="nav-text">共享库版本命名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SO-NAME"><span class="nav-text">SO-NAME</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E7%89%88%E6%9C%AC"><span class="nav-text">符号版本</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%BA%93%E7%B3%BB%E7%BB%9F%E8%B7%AF%E5%BE%84"><span class="nav-text">共享库系统路径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#lib-%E7%B3%BB%E5%88%97%EF%BC%9A%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC%E5%92%8C%E6%9C%80%E5%9F%BA%E7%A1%80%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="nav-text">&#x2F;lib 系列：系统引导和最基础运行环境</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#usr-lib-%E7%B3%BB%E5%88%97%EF%BC%9A%E5%8F%91%E8%A1%8C%E7%89%88%E8%87%AA%E5%B8%A6%E7%9A%84%E2%80%9C%E6%99%AE%E9%80%9A%E8%BD%AF%E4%BB%B6%E5%BA%93%E2%80%9D"><span class="nav-text">&#x2F;usr&#x2F;lib 系列：发行版自带的“普通软件库”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#usr-local-lib-%E7%B3%BB%E5%88%97%EF%BC%9A%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%BA%93"><span class="nav-text">&#x2F;usr&#x2F;local&#x2F;lib 系列：本地安装的软件库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E8%A7%81%E5%BA%93%E8%B7%AF%E5%BE%84%EF%BC%9A-lib32%E3%80%81-lib64%E3%80%81-opt-lib-%E7%AD%89"><span class="nav-text">其他常见库路径：&#x2F;lib32、&#x2F;lib64、&#x2F;opt&#x2F;*&#x2F;lib 等</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%BA%93%E6%9F%A5%E6%89%BE%E8%BF%87%E7%A8%8B"><span class="nav-text">共享库查找过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%84%E5%8A%A0%E8%BD%BD%E9%98%B6%E6%AE%B5"><span class="nav-text">预加载阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LD-PRELOAD%EF%BC%88%E8%BF%9B%E7%A8%8B%E7%BA%A7%E9%A2%84%E5%8A%A0%E8%BD%BD%EF%BC%89"><span class="nav-text">LD_PRELOAD（进程级预加载）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ld-so-preload%EF%BC%88%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%A2%84%E5%8A%A0%E8%BD%BD%EF%BC%89"><span class="nav-text">ld.so --preload（命令行预加载）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#etc-ld-so-preload%EF%BC%88%E7%B3%BB%E7%BB%9F%E7%BA%A7%E9%A2%84%E5%8A%A0%E8%BD%BD%EF%BC%89"><span class="nav-text">&#x2F;etc&#x2F;ld.so.preload（系统级预加载）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E5%B8%B8%E6%9F%A5%E6%89%BE%E9%98%B6%E6%AE%B5"><span class="nav-text">正常查找阶段</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E6%94%B9%E5%85%B1%E4%BA%AB%E5%BA%93"><span class="nav-text">更改共享库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LD-LIBRARY-PATH"><span class="nav-text">LD_LIBRARY_PATH</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LD-PRELOAD"><span class="nav-text">LD_PRELOAD</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LD-DEBUG"><span class="nav-text">LD_DEBUG</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#patchelf-1"><span class="nav-text">patchelf</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B"><span class="nav-text">进程线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E-TLS"><span class="nav-text">多线程与 TLS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TLS-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">TLS 基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TLS-%E6%95%B0%E6%8D%AE"><span class="nav-text">TLS 数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TLS-%E7%BB%93%E6%9E%84"><span class="nav-text">TLS 结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TLS-%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="nav-text">TLS 初始化过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E7%BA%BF%E7%A8%8B-TLS-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">主线程 TLS 初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%97%B6-TLS-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">创建线程时 TLS 初始化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gdb-%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7"><span class="nav-text">gdb 调试技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%B0%83%E8%AF%95"><span class="nav-text">多线程调试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%BF%A1%E6%81%AF"><span class="nav-text">线程信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%AD%E7%82%B9%E6%8A%80%E5%B7%A7"><span class="nav-text">断点技巧</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE"><span class="nav-text">相关设置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E8%B0%83%E8%AF%95"><span class="nav-text">多进程调试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AA%E8%B7%9F%E7%88%B6-or-%E5%8F%AA%E8%B7%9F%E5%AD%90%EF%BC%9Afollow-fork-mode"><span class="nav-text">只跟父 or 只跟子：follow-fork-mode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%97%B6%E8%B0%83%E7%88%B6%E5%AD%90%EF%BC%9Adetach-on-fork-off-%E5%A4%9A-inferiors"><span class="nav-text">同时调父子：detach-on-fork off + 多 inferiors</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86-exec%EF%BC%9Afollow-exec-mode"><span class="nav-text">处理 exec：follow-exec-mode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B2%BE%E7%A1%AE%E5%8D%A1%E5%9C%A8-fork-exec%EF%BC%9Acatch"><span class="nav-text">精确卡在 fork &#x2F; exec：catch</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4"><span class="nav-text">常见保护</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RELRO%EF%BC%88Relocation-Read-Only%EF%BC%89"><span class="nav-text">RELRO（Relocation Read-Only）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8A"><span class="nav-text">原理解释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9"><span class="nav-text">编译选项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stack-Canary"><span class="nav-text">Stack Canary</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8A-1"><span class="nav-text">原理解释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9-1"><span class="nav-text">编译选项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NX%EF%BC%88No-eXecute%EF%BC%89"><span class="nav-text">NX（No-eXecute）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9-2"><span class="nav-text">编译选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8A-2"><span class="nav-text">原理解释</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PIE%EF%BC%88Position-Independent-Executable%EF%BC%89"><span class="nav-text">PIE（Position Independent Executable）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8A-3"><span class="nav-text">原理解释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9-3"><span class="nav-text">编译选项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ASLR"><span class="nav-text">ASLR</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E5%8C%96%E7%BA%A7%E5%88%AB"><span class="nav-text">随机化级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80"><span class="nav-text">用户空间布局</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FORTIFY"><span class="nav-text">FORTIFY</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8A-4"><span class="nav-text">原理解释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E6%8A%A4%E7%BA%A7%E5%88%AB"><span class="nav-text">保护级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9-4"><span class="nav-text">编译选项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CET"><span class="nav-text">CET</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Shadow-Stack%EF%BC%88SHSTK%EF%BC%89"><span class="nav-text">Shadow Stack（SHSTK）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IBT%EF%BC%9AIndirect-Branch-Tracking"><span class="nav-text">IBT：Indirect Branch Tracking</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9-5"><span class="nav-text">编译选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E7%8E%AF%E5%A2%83%E7%9A%84-CET-%E6%94%AF%E6%8C%81"><span class="nav-text">判断环境的 CET 支持</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E4%BA%A4%E4%BA%92%E6%8A%80%E5%B7%A7"><span class="nav-text">远程交互技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Pwn-%E9%A2%98%E5%B8%B8%E8%A7%81%E4%BA%A4%E4%BA%92%E7%B1%BB%E5%9E%8B"><span class="nav-text">Pwn 题常见交互类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#xinetd-socat-%E7%AD%89-0-1-2-%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-text">xinetd &#x2F; socat 等 + 0&#x2F;1&#x2F;2 重定向</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E8%87%AA%E5%B7%B1%E5%86%99-socket-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-text">题目自己写 socket 服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#QEMU-%E7%8E%AF%E5%A2%83%E9%87%8C%E7%9A%84%E7%94%A8%E6%88%B7%E6%80%81-pwn"><span class="nav-text">QEMU 环境里的用户态 pwn</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-text">重定向</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dup-%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-text">dup 重定向</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shell-%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-text">shell 重定向</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO-%E9%80%9A%E4%BF%A1"><span class="nav-text">IO 通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E8%AF%BB%E5%85%A5%E5%87%BD%E6%95%B0"><span class="nav-text">题目读入函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shutdown-%E6%8A%80%E5%B7%A7"><span class="nav-text">shutdown 技巧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tty-%E8%BD%AC%E4%B9%89%E7%BB%95%E8%BF%87"><span class="nav-text">tty 转义绕过</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E9%A2%98%E7%9B%AE%E6%8F%90%E4%BE%9B%E7%9A%84-docker-%E7%8E%AF%E5%A2%83"><span class="nav-text">如何使用题目提供的 docker 环境</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#netcat"><span class="nav-text">netcat</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gdb-1"><span class="nav-text">gdb</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#docker-1"><span class="nav-text">docker</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">使用方法</span></a></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2024</span>
              -
            
            2026&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">sky123</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        57 posts in total
                    </span>
                    
                        <span>
                            1223.7k words in total
                        </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.5</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>



<script src="/js/build/libs/Swup.min.js"></script>

<script src="/js/build/libs/SwupSlideTheme.min.js"></script>

<script src="/js/build/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/build/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/build/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/build/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	
<script src="/js/build/tools/imageViewer.js" type="module"></script>

<script src="/js/build/utils.js" type="module"></script>

<script src="/js/build/main.js" type="module"></script>

<script src="/js/build/layouts/navbarShrink.js" type="module"></script>

<script src="/js/build/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/build/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/build/layouts/categoryList.js" type="module"></script>



    
<script src="/js/build/tools/localSearch.js" type="module"></script>




    
<script src="/js/build/tools/codeBlock.js" type="module"></script>




    
<script src="/js/build/layouts/lazyload.js" type="module"></script>




    
<script src="/js/build/tools/runtime.js"></script>

    
<script src="/js/build/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/build/libs/Typed.min.js"></script>

  
<script src="/js/build/plugins/typed.js" type="module"></script>




    
        
<script src="/js/build/libs/mermaid.min.js"></script>

    
    
<script src="/js/build/plugins/mermaid.js"></script>






    
<script src="/js/build/libs/anime.min.js"></script>





    
<script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script>





    
<script src="/js/build/layouts/bookmarkNav.js" type="module"></script>


	
</body>

</html>