<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="sky123">
    
    <!-- Completely eliminate flash of wrong theme -->
    <script>
        (function() {
            const THEME_KEY = "REDEFINE-THEME-STATUS";
            const DARK = "dark", LIGHT = "light";
            
            // Get preferred theme
            function getTheme() {
                try {
                    const saved = localStorage.getItem(THEME_KEY);
                    if (saved) {
                        const { isDark } = JSON.parse(saved);
                        return isDark ? DARK : LIGHT;
                    }
                } catch (e) {}
                
                return matchMedia("(prefers-color-scheme: dark)").matches ? DARK : LIGHT;
            }
            
            // Apply theme to document
            function applyTheme(theme) {
                const isDark = theme === DARK;
                const root = document.documentElement;
                
                // Set data attribute for CSS variables
                root.setAttribute("data-theme", theme);
                
                // Set classes for compatibility
                root.classList.add(theme);
                root.classList.remove(isDark ? LIGHT : DARK);
                root.style.colorScheme = theme;
            }
            
            // Initial application
            const theme = getTheme();
            applyTheme(theme);
            
            // Listen for system preference changes
            matchMedia("(prefers-color-scheme: dark)").addEventListener("change", ({ matches }) => {
                // Only update if using system preference (no localStorage entry)
                if (!localStorage.getItem(THEME_KEY)) {
                    applyTheme(matches ? DARK : LIGHT);
                }
            });
            
            // Set body classes once DOM is ready
            if (document.readyState !== "loading") {
                document.body.classList.add(theme + "-mode");
            } else {
                document.addEventListener("DOMContentLoaded", () => {
                    document.body.classList.add(theme + "-mode");
                    document.body.classList.remove((theme === DARK ? LIGHT : DARK) + "-mode");
                });
            }
        })();
    </script>
    
    <!-- Critical CSS to prevent flash -->
    <style>
        :root[data-theme="dark"] {
            --background-color: #202124;
            --background-color-transparent: rgba(32, 33, 36, 0.6);
            --second-background-color: #2d2e32;
            --third-background-color: #34353a;
            --third-background-color-transparent: rgba(32, 33, 36, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #ffffff;
            --second-text-color: #eeeeee;
            --third-text-color: #bebec6;
            --fourth-text-color: #999999;
            --default-text-color: #bebec6;
            --invert-text-color: #373D3F;
            --border-color: rgba(255, 255, 255, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(255, 255, 255, 0.08);
            --shadow-color-2: rgba(255, 255, 255, 0.05);
        }
        
        :root[data-theme="light"] {
            --background-color: #fff;
            --background-color-transparent: rgba(255, 255, 255, 0.6);
            --second-background-color: #f8f8f8;
            --third-background-color: #f2f2f2;
            --third-background-color-transparent: rgba(241, 241, 241, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #16171a;
            --second-text-color: #2f3037;
            --third-text-color: #5e5e5e;
            --fourth-text-color: #eeeeee;
            --default-text-color: #373D3F;
            --invert-text-color: #bebec6;
            --border-color: rgba(0, 0, 0, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(0, 0, 0, 0.08);
            --shadow-color-2: rgba(0, 0, 0, 0.05);
        }
        
        body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
        
        /* Apply body classes as soon as DOM is ready */
        :root[data-theme="dark"] body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
    </style>
    
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://skyi23.github.io/2022/09/28/windows 保护模式/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/null" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/null">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/null">
    <!--- Page Info-->
    
    <title>
        
            windows 保护模式 | sky123&#39;s site
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/css/build/tailwind.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" rel="stylesheet">
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"skyi23.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":true,"family":"JetBrains Mono","url":"https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap"}},"toc":{"enable":true,"max_depth":5,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"side_tools":{"gear_rotation":true,"auto_expand":false},"open_graph":{"enable":false,"image":"/images/redefine-og.webp","description":"Hexo Theme Redefine, Redefine Your Hexo Journey."},"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"sky123's blog","subtitle":{"text":["书有未曾经我读，事无不可对人言"],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":true,"version":"11.4.1"}},"version":"2.8.5","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"分类":{"icon":"fa-solid fa-folder","path":"/categories/"},"标签":{"icon":"fa-solid fa-tags","path":"/tags/"},"书签":{"icon":"fa-solid fa-bookmark","path":"/bookmarks/"}},"search":{"enable":true,"preload":true}},"page_templates":{"bookmarks_column":3,"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2024/11/7 00:00:00"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha256-TThEtR+XalhWKkfF383YLOrI50NGNeIqrzS+q08afrY=" crossorigin="anonymous"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>



<body>
	<div class="progress-bar-container">
	
	<span class="scroll-progress-bar"></span>
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                sky123&#39;s site
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/categories/"
                                        >
                                    <i class="fa-solid fa-folder fa-fw"></i>
                                    分类
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/tags/"
                                        >
                                    <i class="fa-solid fa-tags fa-fw"></i>
                                    标签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/bookmarks/"
                                        >
                                    <i class="fa-solid fa-bookmark fa-fw"></i>
                                    书签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/categories/"
                        >
                            <span>
                                分类
                            </span>
                            
                                <i class="fa-solid fa-folder fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/tags/"
                        >
                            <span>
                                标签
                            </span>
                            
                                <i class="fa-solid fa-tags fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/bookmarks/"
                        >
                            <span>
                                书签
                            </span>
                            
                                <i class="fa-solid fa-bookmark fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">11</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">14</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">41</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">windows 保护模式</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/icon.jpg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">sky123</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2022-09-28 11:45:14</span>
        <span class="mobile">2022-09-28 11:45:14</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-07-01 10:19:52</span>
            <span class="mobile">2025-07-01 10:19:52</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/reverse/">reverse</a>&nbsp;
                        </li>
                    
                    
                
                    
                        
                            <li>></li>
                        
                        <li>
                            <a href="/categories/reverse/windows-kernel/">windows kernel</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/windows-kernel-reverse/">windows kernel reverse</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>20.3k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>78 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<p>参考 <a href="attachments/325462-sdm-vol-1-2abcd-3abcd.pdf">英特尔开发手册</a></p>
<h1 id="CPU-的模式"><a href="#CPU-的模式" class="headerlink" title="CPU 的模式"></a>CPU 的模式</h1><p>x86 CPU 的三个主要模式分别是实模式（Real Mode）、保护模式（Protected Mode）和虚拟8086模式（Virtual 8086 Mode）。它们各自的功能和特点如下：</p>
<h2 id="实模式（Real-Mode）"><a href="#实模式（Real-Mode）" class="headerlink" title="实模式（Real Mode）"></a>实模式（Real Mode）</h2><ul>
<li><strong>简介</strong> ：实模式是x86架构最早的工作模式，与8086 CPU的工作方式相同。</li>
<li><strong>内存管理</strong> ：在实模式下，CPU可以访问1MB的内存。内存地址是通过段寄存器和偏移地址组合来形成的，总地址空间为20位。</li>
<li><strong>特点</strong> ：<ul>
<li>没有内存保护机制，即程序可以访问所有内存区域，包括操作系统内核和其他程序的数据。</li>
<li>没有多任务支持，所有程序运行在同一个地址空间中。</li>
<li>简单的地址计算：物理地址 &#x3D; 段寄存器 * 16 + 偏移地址。</li>
</ul>
</li>
<li><strong>用途</strong> ：实模式主要用于早期的DOS操作系统和初始系统引导过程。</li>
</ul>
<h2 id="保护模式（Protected-Mode）"><a href="#保护模式（Protected-Mode）" class="headerlink" title="保护模式（Protected Mode）"></a>保护模式（Protected Mode）</h2><ul>
<li><strong>简介</strong> ：保护模式是为了提供更高级的内存管理和多任务处理而设计的，是现代操作系统（如Windows、Linux）运行的基础模式。</li>
<li><strong>内存管理</strong> ：保护模式下，CPU可以访问4GB的内存地址空间，使用32位地址。引入了分页（Paging）和分段（Segmentation）机制。</li>
<li><strong>特点</strong> ：<ul>
<li>支持内存保护，防止一个程序访问另一个程序的内存区域。</li>
<li>支持硬件级别的多任务处理，通过任务状态段（TSS）进行任务切换。</li>
<li>支持虚拟内存，通过分页机制，可以使用物理内存之外的存储空间。</li>
<li>提供特权级别（Privilege Levels），通常有四个环（Ring 0到Ring 3），用于控制访问权限和隔离内核与用户程序。</li>
</ul>
</li>
<li><strong>用途</strong> ：保护模式用于运行复杂的多任务操作系统，如Windows、Linux等。</li>
</ul>
<h2 id="虚拟8086模式（Virtual-8086-Mode）"><a href="#虚拟8086模式（Virtual-8086-Mode）" class="headerlink" title="虚拟8086模式（Virtual 8086 Mode）"></a>虚拟8086模式（Virtual 8086 Mode）</h2><ul>
<li><strong>简介</strong> ：虚拟8086模式是保护模式的一部分，允许在保护模式下运行实模式应用程序。它引入了一种机制，使得保护模式操作系统可以运行多个8086虚拟机。</li>
<li><strong>内存管理</strong> ：每个虚拟8086模式下的任务都有自己独立的1MB地址空间，模拟实模式的内存管理。</li>
<li><strong>特点</strong> ：<ul>
<li>兼容性：允许在现代操作系统上运行旧的实模式程序。</li>
<li>隔离：每个虚拟8086任务被隔离在自己的内存空间内，受保护模式的内存保护机制保护。</li>
<li>性能：在保护模式下，通过硬件支持的虚拟化技术，可以高效地执行实模式代码。</li>
</ul>
</li>
<li><strong>用途</strong> ：虚拟8086模式用于在保护模式操作系统（如Windows NT系列）中运行DOS程序。</li>
</ul>
<h1 id="保护模式下的地址"><a href="#保护模式下的地址" class="headerlink" title="保护模式下的地址"></a>保护模式下的地址</h1><p>在保护模式下，x86 CPU通过<strong>段式内存管理</strong>和<strong>分页机制</strong>来转换和管理<strong>逻辑地址</strong>、<strong>虚拟地址</strong>和<strong>物理地址</strong>。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/df792f4a88f2cc9705abc70c9ffd90bd.png"
                      alt="在这里插入图片描述"
                ></p>
<p>三种地址的转换具体如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/image-20250602014852488.png"
                      alt="image-20250602014852488"
                ></p>
<h2 id="逻辑地址（Logical-Address）"><a href="#逻辑地址（Logical-Address）" class="headerlink" title="逻辑地址（Logical Address）"></a>逻辑地址（Logical Address）</h2><ul>
<li><strong>组成</strong> ：<strong>逻辑地址</strong>由<strong>段选择子</strong>（Segment Selector）和<strong>段内偏移</strong>（Offset）组成。</li>
<li><strong>格式</strong> ：<code>Logical Address = Segment Selector:Offset</code></li>
<li><strong>作用</strong> ：逻辑地址是程序员在代码中使用的地址形式。<ul>
<li><strong>段选择子</strong>决定了使用哪个段描述符</li>
<li><strong>偏移量</strong>则指示在该段内的具体位置。</li>
</ul>
</li>
</ul>
<h2 id="虚拟地址（Virtual-Address）"><a href="#虚拟地址（Virtual-Address）" class="headerlink" title="虚拟地址（Virtual Address）"></a>虚拟地址（Virtual Address）</h2><ul>
<li><strong>生成</strong> ：通过<strong>段选择子</strong>从<strong>段描述符表</strong>（GDT或LDT）中找到对应的<strong>段描述符</strong>，利用<strong>段描述符中的基址</strong>（Base Address）加上<strong>偏移量</strong>（即逻辑地址中的段内偏移）得到虚拟地址。</li>
<li><strong>格式</strong> ：<code>Virtual Address = Base Address (from Segment Descriptor) + Offset</code></li>
<li><strong>作用</strong> ：虚拟地址是CPU在段内的线性地址，它可以直接被分页单元使用以进一步转换为物理地址。</li>
</ul>
<h2 id="物理地址（Physical-Address）"><a href="#物理地址（Physical-Address）" class="headerlink" title="物理地址（Physical Address）"></a>物理地址（Physical Address）</h2><ul>
<li><strong>生成</strong> ：<strong>虚拟地址</strong>通过<strong>分页机制</strong>（如果启用）被转换成<strong>物理地址</strong>。分页机制使用页目录（Page Directory）和页表（Page Table）来完成这个转换。</li>
<li><strong>作用</strong> ：物理地址是内存芯片上的实际地址，是最终用于存储器访问的地址。</li>
</ul>
<h1 id="段式内存管理"><a href="#段式内存管理" class="headerlink" title="段式内存管理"></a>段式内存管理</h1><p>段式内存管理（Segmentation）是x86架构保护模式下的内存管理机制之一。它通过将内存划分为多个段，每个段都有独立的基址、大小和访问权限，以便对内存进行更加灵活和安全的管理。</p>
<p>不过在 32 位下由于访问范围为 4GB，因此通常设置基址为 0 。</p>
<h2 id="段寄存器（Segment-Registers）"><a href="#段寄存器（Segment-Registers）" class="headerlink" title="段寄存器（Segment Registers）"></a>段寄存器（Segment Registers）</h2><p>段寄存器用于保存段选择子，指示当前正在使用的段。x86 CPU中有多个段寄存器，每个寄存器对应不同类型的内存段。</p>
<h3 id="主要段寄存器"><a href="#主要段寄存器" class="headerlink" title="主要段寄存器"></a>主要段寄存器</h3><p>32 位 Windows（x86）段寄存器：</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>Ring 3 (用户态)</th>
<th>Ring 0 (内核态)</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CS</td>
<td>0x1B</td>
<td>0x08</td>
<td>代码段</td>
</tr>
<tr>
<td>DS</td>
<td>0x23</td>
<td>0x10</td>
<td>数据段</td>
</tr>
<tr>
<td>SS</td>
<td>0x23</td>
<td>0x10</td>
<td>栈段</td>
</tr>
<tr>
<td>ES</td>
<td>0x23</td>
<td>0x10</td>
<td>额外数据段(一般等于 DS)</td>
</tr>
<tr>
<td>FS</td>
<td>0x3B</td>
<td>0x30</td>
<td>用户态: <code>TEB</code>，内核态: <code>KPCR</code></td>
</tr>
<tr>
<td>GS</td>
<td>0x00</td>
<td>0x00</td>
<td>通常未使用</td>
</tr>
</tbody></table>
<p> 64 位 Windows（x64）段寄存器：</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>Ring 3 (用户态)</th>
<th>Ring 0 (内核态)</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CS</td>
<td>0x33</td>
<td>0x10</td>
<td>代码段</td>
</tr>
<tr>
<td>DS</td>
<td>0x00</td>
<td>0x00</td>
<td>被忽略，平坦段</td>
</tr>
<tr>
<td>SS</td>
<td>0x00</td>
<td>0x00</td>
<td>被忽略，平坦段</td>
</tr>
<tr>
<td>ES</td>
<td>0x00</td>
<td>0x00</td>
<td>被忽略，平坦段</td>
</tr>
<tr>
<td>FS</td>
<td>0x00 (或用于 WOW64)</td>
<td>0x00</td>
<td>兼容层用，64 位下一般不用</td>
</tr>
<tr>
<td>GS</td>
<td>0x53 (或配置值)</td>
<td>0x10</td>
<td>用户态: <code>TEB</code>，内核态: <code>KPCR</code></td>
</tr>
</tbody></table>
<h3 id="段寄存器结构"><a href="#段寄存器结构" class="headerlink" title="段寄存器结构"></a>段寄存器结构</h3><p>在x86保护模式下，每个段寄存器有一个16位的可见部分（段选择子）和一个80位的隐含部分（包含段基址、界限和属性）。所以，段寄存器的总长度是96位，其中只有16位是可见的。当然不可见的部分其实对我们来说是透明的，因为这一部分在段寄存器中的属性是从段描述符中加载出来，以提高内存访问速度。</p>
<p>为了更准确地描述段寄存器，可以使用如下的结构体：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentRegister</span> &#123;</span></span><br><span class="line">    WORD Selector;     <span class="comment">// 段选择子 16位 可见</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        WORD Attributes; <span class="comment">// 段属性 16位 不可见</span></span><br><span class="line">        DWORD Limit;   <span class="comment">// 段大小 20位（界限）+ 12位标志，不可见</span></span><br><span class="line">        DWORD Base;    <span class="comment">// 段基址 32位 不可见</span></span><br><span class="line">    &#125; Hidden;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/4f2684f1ab4ad202e7f03c900f782bdb.png"
                      alt="在这里插入图片描述"
                ></p>
<ul>
<li><p><strong>Selector（段选择子）</strong> ：段寄存器中唯一可见的部分，它包含段选择子的索引、TI（表指示位）和RPL（请求特权级别）。Selector用于在GDT或LDT中查找段描述符。</p>
<ul>
<li><strong>索引（Index）</strong> ：段描述符在描述符表（GDT 或 LDT）中的索引。</li>
<li><strong>TI（Table Indicator）</strong> ：指示使用全局描述符表（GDT）还是局部描述符表（LDT）。<ul>
<li>0：使用 GDT。</li>
<li>1：使用 LDT。</li>
</ul>
</li>
<li><strong>RPL（Requested Privilege Level）</strong> ：请求的特权级别，用于权限检查。</li>
</ul>
</li>
<li><p><strong>Base（段基址）</strong> ：段的起始地址，由段描述符中的 Base 字段组成。Base 字段在段描述符中分为三部分（低、中、高），合并后形成完整的 32 位基址。</p>
</li>
<li><p><strong>Limit（段大小）</strong> ：段的界限，由段描述符中的 Limit 字段组成。Limit 字段也分为低 16 位和高 4 位，高 4 位包含在段描述符的高字节中。Limit 通常表示段的大小。</p>
</li>
<li><p><strong>Attributes（段属性）</strong> ：段的属性和类型信息，包括段的类型（代码段、数据段）、DPL（描述符特权级别）、存在位（P）、扩展向下位（D&#x2F;B）、可访问位（A）等。</p>
</li>
</ul>
<h3 id="段寄存器读写"><a href="#段寄存器读写" class="headerlink" title="段寄存器读写"></a>段寄存器读写</h3><h4 id="数据段寄存器"><a href="#数据段寄存器" class="headerlink" title="数据段寄存器"></a>数据段寄存器</h4><p>数据段寄存器读写通常是通过寄存器完成的，例如 <code>mov ds, ax</code>，<code>mov ax, es</code> 等。</p>
<p>另外 <code>push</code> 和 <code>pop</code> 这种栈操作指令同样可以读写数据段寄存器，例如 <code>push fs</code>，<code>pop fs</code> 等，在开发中我们通常利用这个方法来保存段寄存器环境。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p><code>ss</code> 寄存器也能通过 <code>mov</code> 指令修改，但是 <code>ss</code> 的 RPL 要保持不变。因为 <code>ss</code> 的 RPL 和 <code>cs</code> 的 RPL 同为 CPL，段权限管理要求 <code>cs</code> 和 <code>ss</code> 的 RPL 要始终保持相同，而仅通过 <code>mov</code> 指令修改 <code>ss</code> 的 RPL 显然不符合这一规定。</p>

    </div>
  </div>

<h4 id="代码段寄存器"><a href="#代码段寄存器" class="headerlink" title="代码段寄存器"></a>代码段寄存器</h4><p><code>cs</code> 寄存器不能通过 <code>mov</code> 和 <code>pop</code> 指令修改（不过可以使用 <code>push cs</code> 和 <code>mov ax, cs</code> 这种指令来读取 <code>cs</code> 寄存器的值），因此我们必须通过<strong>跨段跳转</strong>指令来修改 <code>cs</code> 寄存器。 例如 <code>jmp fword</code> 和 <code>call fword</code> 指令：</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">jmp</span> <span class="built_in">far</span> <span class="meta">segment</span>:offset</span><br><span class="line"><span class="keyword">call</span> <span class="built_in">far</span> <span class="meta">segment</span>:offset</span><br></pre></td></tr></table></figure></div>

<p>然而在 MSVC（尤其是 32 位 x86 平台）中的内联汇编在语法上不支持这种直接立即数跳转：</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">jmp</span> <span class="built_in">far</span> <span class="number">0x1234</span>:<span class="number">0x5678</span></span><br><span class="line"><span class="keyword">call</span> <span class="built_in">far</span> <span class="number">0x1234</span>:<span class="number">0x5678</span></span><br></pre></td></tr></table></figure></div>

<p>因此我们需要使用 <code>call fword ptr [mem]</code> 指令来代替：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FarPointer</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset;    <span class="comment">// 32 位</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> selector; <span class="comment">// 16 位</span></span><br><span class="line">&#125; fp = &#123;<span class="number">0x5678</span>, <span class="number">0x1234</span>&#125;;</span><br><span class="line"></span><br><span class="line">__asm &#123;</span><br><span class="line">    jmp fword ptr ds:[fp]</span><br><span class="line">    call fword ptr ds:[fp]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>对于 <code>call fword ptr</code> 和 <code>call far</code> 指令，如果 <strong>CPL 不变</strong>则会在向栈中依次压入<strong>调用者的 cs</strong> 和<strong>返回地址</strong>（CPL 变化的情况比较复杂，具体见调用门部分）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/image-20250603005133672.png"
                      alt="image-20250603005133672"
                ></p>
<p>因此我们返回时需要通过 <code>retf</code> 指令返回。如果调用前在栈上压入了参数，那么我们可以通过 <code>retf [参数的字节总数]</code> 来平衡堆栈。</p>
<p>为了避免编译器在函数代码中生成堆栈帧（<code>push ebp</code>&#x2F;<code>mov ebp, esp</code>…），我们需要借助<strong>裸函数（naked function）</strong>精确控制函数的入口和返回指令。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__declspec(naked) <span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        <span class="comment">// 这里写汇编指令</span></span><br><span class="line">        retf</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>除此之外中断指令 <code>int</code> 以及对应的返回指令 <code>iret</code> 同样会修改 <code>cs</code> 寄存器，具体同样见后面的分析。</p>
<h2 id="段描述符表（Descriptor-Table）"><a href="#段描述符表（Descriptor-Table）" class="headerlink" title="段描述符表（Descriptor Table）"></a>段描述符表（Descriptor Table）</h2><h3 id="段描述符表种类"><a href="#段描述符表种类" class="headerlink" title="段描述符表种类"></a>段描述符表种类</h3><p>段描述符表是存储段描述符的结构，定义了各个段的属性。x86 架构中有两种主要的段描述符表：<strong>全局描述符表（GDT）</strong>和<strong>局部描述符表（LDT）</strong>。</p>
<h4 id="全局描述符表（GDT-Global-Descriptor-Table）"><a href="#全局描述符表（GDT-Global-Descriptor-Table）" class="headerlink" title="全局描述符表（GDT, Global Descriptor Table）"></a>全局描述符表（GDT, Global Descriptor Table）</h4><ul>
<li><strong>作用</strong> ：全局描述符表用于定义系统范围内的段，包括代码段、数据段和系统段（如任务状态段TSS）。</li>
<li><strong>存储位置</strong> ：GDT存储在内存中的一个固定位置，其基址和界限由 GDTR（GDT Register）寄存器保存。</li>
<li><strong>访问方式</strong> ：通过段选择子中的 TI 位（Table Indicator）为 0 来选择 GDT 。</li>
<li><strong>相关汇编指令</strong> ：<ul>
<li><code>lgdt [mem]</code> → 加载 GDT</li>
<li><code>sgdt [mem]</code> → 存储 GDT（SGDT 可以在 Ring 3 执行，常用于探测系统）</li>
</ul>
</li>
</ul>
<p>关于 GDT 有如下常用的调试命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>r gdtr</code>&#x2F;<code>r gdtl</code></td>
<td>查看 GDT 基地址和长度</td>
</tr>
<tr>
<td><code>!gdt</code></td>
<td>列出当前处理器的 GDT 表项</td>
</tr>
<tr>
<td><code>!gdt &lt;n&gt;</code></td>
<td>查看某个段选择子的详细描述符</td>
</tr>
<tr>
<td><code>dg &lt;selector&gt; [count]</code></td>
<td>解析段选择子 <code>selector</code> 开始的 <code>count</code> 个段描述符</td>
</tr>
<tr>
<td><code>~&lt;n&gt;</code></td>
<td>切换到第 n 个处理器上下文</td>
</tr>
</tbody></table>
<h4 id="局部描述符表（LDT-Local-Descriptor-Table）"><a href="#局部描述符表（LDT-Local-Descriptor-Table）" class="headerlink" title="局部描述符表（LDT, Local Descriptor Table）"></a>局部描述符表（LDT, Local Descriptor Table）</h4><ul>
<li><p><strong>作用</strong> ：局部描述符表用于定义特定任务或进程的段，通常用于多任务环境中。</p>
</li>
<li><p><strong>存储位置</strong> ：LDT 也存储在内存中的一个固定位置，其基址和界限由 LDTR（LDT Register）寄存器保存。</p>
</li>
<li><p><strong>访问方式</strong> ：通过段选择子中的 TI 位为 1 来选择 LDT 。</p>
</li>
<li><p><strong>相关汇编指令</strong> ：</p>
<ul>
<li><code>lldt reg/mem</code> → 加载 LDTR</li>
<li><code>sldt reg/mem</code> → 存储 LDTR（Ring 3 可执行）</li>
<li><code>str reg/mem</code> → 存储任务寄存器（可用于 TSS 调试）</li>
</ul>
</li>
</ul>
<p>关于 LDT 有如下常用的调试命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>r ldtr</code>&#x2F;<code>r ldtl</code></td>
<td>查看 LDT 基地址和长度</td>
</tr>
</tbody></table>
<h3 id="段描述符（Segment-Descriptor）"><a href="#段描述符（Segment-Descriptor）" class="headerlink" title="段描述符（Segment Descriptor）"></a>段描述符（Segment Descriptor）</h3><p>段描述符是描述段属性的结构体，存储在GDT或LDT中。每个段描述符占用8个字节，包含段的基址、界限和属性等信息。</p>
<p>一个段描述符的结构如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/SegmentDescriptor.svg"
                      alt="Figure 3-8. Segment Descriptor"
                ></p>
<ul>
<li><p><strong>基址（Base Address）</strong> ：段的起始地址，由 8 位高位基址（<code>Base 31:24</code>）、8 位中位基址（<code>Base 23:16</code>）和 16 位低位基址（<code>Base Address 15:00</code>）组成，共32位。</p>
</li>
<li><p><strong>界限（Limit）</strong> ：段的大小，由 16 位低位界限（<code>Limit 15:0</code>）和 4 位高位界限（<code>Limit 19:16</code>）组成，共 20 位。</p>
</li>
<li><p><strong>P（Present）</strong> ：段存在位，1 表示段存在。段描述符加载时，首先看 P 位是否为 1 。</p>
</li>
<li><p><strong>DPL（Descriptor Privilege Level）</strong> ：描述符的特权级别，共 2 位。</p>
</li>
<li><p><strong>S（Descriptor Type）</strong>，<strong>Type</strong> ：<code>S</code> 描述符类型，<code>Type</code> 根据 <code>S</code> 的不同含义不同。</p>
<ul>
<li><p><code>S</code> 为 0 表示系统段，此时 <code>Type</code> 描述系统段的类型（如调用门，中断门，陷阱门等），含义如下表所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/image-20250602003006973.png"
                      alt="image-20250602003006973"
                ></p>
</li>
<li><p><code>S</code> 为 1 表示代码段或数据段，此时 <code>Type</code> 描述段的具体类型（如代码段、数据段）和访问权限，含义如下表所示。</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/image-20250601231301425.png"
                      alt="image-20250601231301425"
                ></p>
<p>另外 <code>Type</code> 对应代码段和数据段时分别引入了一个新概念：</p>
<ul>
<li><strong>一致代码段（Conforming Code Segment）</strong><ul>
<li>当 <code>Type</code> 的 11 位为 1 时段描述符表示的是代码段，此时如果 <code>C</code> 位（10 位）为 1 则表示为一致代码段。</li>
<li>一致代码段是指当 CPU 执行跨特权级的代码段切换（比如调用更高权限的代码段）时，<strong>不需要特权级检查</strong>，允许直接进入。</li>
<li>CPU 不会在段切换时更改 CPL（因为一致代码段特权级不敏感）。</li>
</ul>
</li>
<li><strong>向下拓展数据段（Expand-Down Data Segment）</strong><ul>
<li>当 <code>Type</code> 的 11 位为 0 时段描述符表示的是数据段，此时如果 <code>E</code> 位（10 位）为 1 则表示为向下拓展。</li>
<li>正常情况下的我们见到的数据段都是向上拓展的，即有效偏移范围是从 <code>0</code> 到 <code>Limit</code> 。</li>
<li>对于向下拓展的数据段，有效偏移范围是从 <code>Limit + 1</code> 到最大偏移值（例如，<code>0xFFFF</code> 或 <code>0xFFFFFFFF</code>，取决于段的大小）。由于 <code>Base + Limit</code> 会溢出，因此实际的有效范围是 <code>[Base, Base + Limit)</code> 之外的范围。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>G位（Granularity）</strong> ：决定界限单位。</p>
<ul>
<li>0 表示段寄存器的 <code>Limit</code> 元素单位为字节，即最大范围为 0x000FFFFF（1MB）。</li>
<li>1 表示段寄存器的 <code>Limit</code> 元素单位为 4KB ，即最大范围为 0xFFFFFFFF（4GB）。</li>
</ul>
</li>
<li><p><strong>D&#x2F;B 位（Default Operand Size &#x2F; Big）</strong> ：决定了默认的操作数和地址的大小，以及堆栈指针的大小。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p>这里需要与 <code>Type</code> 位配合才能生效。<code>Type</code> 位决定了段描述符是<strong>代码段</strong>还是<strong>数据段</strong>，另外还决定了一些特性如<strong>向下拓展</strong>是否生效。</p>

    </div>
  </div>

<ul>
<li>对于代码段：<ul>
<li><strong>0</strong> ：默认操作数和地址大小为 16 位。例如 <code>push</code> 指令只能压 2 字节。</li>
<li><strong>1</strong> ：默认操作数和地址大小为 32 位。</li>
</ul>
</li>
<li>对于堆栈段：<ul>
<li><strong>0</strong> ：使用 16 位堆栈指针。</li>
<li><strong>1</strong> ：使用 32 位堆栈指针。</li>
</ul>
</li>
<li>对于数据段：<ul>
<li><strong>0</strong> ：向下拓展。</li>
<li><strong>1</strong> ：向上拓展。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>L 位（64-bit code segment）</strong> ：仅适用于 IA-32e 模式（64 位模式）的代码段。</p>
<ul>
<li><strong>0</strong> ：表示这是一个 16 位或 32 位代码段，具体取决于 <code>D/B</code> 位。</li>
<li><strong>1</strong> ：表示这是一个 64 位代码段，忽略 <code>D/B</code> 位。</li>
</ul>
</li>
<li><p><strong>AVL 位（Available for use by system software）</strong> ：供操作系统或其他系统软件使用，用于特定用途，例如标记段的状态，未被硬件使用。</p>
</li>
</ul>
<h2 id="段权限检测"><a href="#段权限检测" class="headerlink" title="段权限检测"></a>段权限检测</h2><h3 id="权限类型"><a href="#权限类型" class="headerlink" title="权限类型"></a>权限类型</h3><p>Ring Model 是一种 <strong>CPU 权限级别（Privilege Level）</strong> 的分层架构，主要用于操作系统中处理权限隔离和保护。它通过硬件机制，限制不同权限级别的代码对系统资源的访问，从而提高系统的安全性和稳定性。</p>
<p>Ring Model 的分层通常分为 4 个等级，编号从 0 到 3：<code>Ring 0</code>，<code> Ring 1</code>， <code>Ring 2</code>， <code>Ring 3</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/image-20250602015322945.png"
                      alt="image-20250602015322945"
                ></p>
<p>CPU 的权限等级主要有段机制来维护，具体来说段机制中有下面几个权限类型：</p>
<ul>
<li><strong>CPL（Current Privilege Level）</strong> ：表示当前程序的运行权限级别，由 CS 和 SS 的 RPL（低两位）决定，并且 CS 和 SS 的低两位一定相等（因为权限变化要求 CS 和 SS 同时修改，并且 CS 和 SS 必须变成相同是值）。</li>
<li><strong>RPL（Requested Privilege Level）</strong> ：请求访问段时指定的权限级别。通常由访存时使用的段寄存器的段选择子决定。</li>
<li><strong>DPL（Descriptor Privilege Level）</strong> ：段描述符中定义的段权限级别。</li>
</ul>
<h3 id="权限规则"><a href="#权限规则" class="headerlink" title="权限规则"></a>权限规则</h3><p>这里仅考虑常见的非一致代码段。</p>
<h4 id="权限检测规则"><a href="#权限检测规则" class="headerlink" title="权限检测规则"></a>权限检测规则</h4><ul>
<li>对于数据段：仅检测 DPL 与 CPL 之间的大小关系，当且仅当 DPL 在数值上大于等于 CPL（CPL ≤ DPL）时允许。例如当 CPL &#x3D;  DPL &#x3D; 3 时，即使 RPL &#x3D; 0 也允许访问。</li>
<li>对于堆栈段和代码段：当且仅当 CPL &#x3D; RPL &#x3D; DPL 时允许访问。因为堆栈段在数据段的基础上本身 RPL 就是 CPL，因此我们只需要知道这里比数据段严格，必须要求 CPL &#x3D; DPL。</li>
<li>对于系统段：CPL &#x3D; RPL ≤ 门描述符的 DPL</li>
</ul>
<h4 id="权限修改规则"><a href="#权限修改规则" class="headerlink" title="权限修改规则"></a>权限修改规则</h4><ul>
<li><p><code>cs</code> 的权限一旦改变，<code>ss</code> 的权限也要随着改变，<code>cs</code> 与 <code>ss</code> 的等级必须一样。</p>
</li>
<li><p><code>int</code>，<code>call far</code> 这一类的指令只能通过系统段提权或者不改变权限。</p>
</li>
<li><p><code>jmp far</code> 这一类指令不改变权限，除了 TSS（可以同时影响到 <code>cs</code> 和 <code>ss</code>）。</p>
</li>
<li><p><code>retf</code>，<code>iretd</code> 这一类指令只能同级跳转或者降权。</p>
</li>
</ul>
<h2 id="调用门"><a href="#调用门" class="headerlink" title="调用门"></a>调用门</h2><p>在 x86 保护模式下，调用门（Call Gate）是一种特殊的系统段描述符，存在于 <strong>GDT（全局描述符表）</strong>或 <strong>LDT（局部描述符表）</strong> 中。它的作用是：<strong>允许安全地从一个代码段转移到另一个代码段，通常伴随特权级切换</strong>。</p>
<h3 id="门描述符"><a href="#门描述符" class="headerlink" title="门描述符"></a>门描述符</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/Call-GateDescriptor.svg"
                      alt="Figure 5-8. Call-Gate Descriptor"
                ></p>
<ul>
<li><strong>偏移地址（Offset in Segment）</strong> ：目标代码段中被调用过程的入口的<strong>逻辑地址</strong>，分为 16 位的低位偏移（<code>Offset 15:00</code>）和 16 位的高位偏移（<code>Offset 31:16</code>），需要与段选择子指向的段描述符结合才能得到入口的<strong>线性地址</strong>。</li>
<li><strong>段选择子（Segment Selector）</strong> ：调用门要跳转到的目标代码段的选择子，用于在 GDT 或 LDT 中查找目标代码段的描述符。</li>
<li><strong>参数计数（Param Count）</strong> ：堆栈切换（权限改变）时需要从旧特权级堆栈复制到新特权级堆栈的参数个数，单位为字（16 位）或双字（32 位），具体取决于调用门的类型（位数）。</li>
<li><strong>类型（Type）</strong> ：4 位，表示调用门的类型。对于 32 位调用门，值为 <code>1100</code>（0xC）；对于 16 位调用门，值为 <code>0100</code>（0x4）。</li>
<li><strong>系统段标志（S）</strong> ：1 位，固定为 0，表示调用门是系统段，而不是普通的代码段或数据段。</li>
<li><strong>描述符特权级（DPL）</strong> ：2 位，表示访问调用门时所需的最低特权级，用于特权检查。</li>
<li><strong>段存在标志（P）</strong> ：1 位，表示调用门描述符是否存在。若为 0，访问该调用门会触发 #NP（Not Present）异常。</li>
</ul>
<h3 id="过程分析"><a href="#过程分析" class="headerlink" title="过程分析"></a>过程分析</h3><h4 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h4><p>当我们通过 <code>call/jmp far</code> 或者 <code>call/jmp fword ptr</code> 指令调用调用门：</p>
<ol>
<li><p><strong>根据指令中的段选择子找到调用门。</strong>（指令中的地址没有用到，最终跳转到的地址由调用门的门描述符中的 <code>Offset</code> 字段决定）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/image-20250602051346485.png"
                      alt="image-20250602051346485"
                ></p>
</li>
<li><p><strong>进行权限检查：</strong></p>
<ul>
<li>指令中的 RPL 不参与整个过程。</li>
<li>CPL 在数值上小于等于调用门 DPL。</li>
<li>调用门中代码段选择子的 RPL 在数值上小于等于对应的代码段的的 DPL（貌似不用满足，并且跳过去之后 CPL 还是设置为代码段的 DPL）。</li>
<li>如果是 <code>jmp</code> 则调用门的段描述符对应的代码段的 DPL 等于 CPL。（<code>jmp</code> 通过调用门提不了权）</li>
<li>如果是 <code>call</code> 则调用门的段描述符对应的代码段的 DPL 在数值上小于等于 CPL。</li>
</ul>
</li>
<li><p><strong>判断调用门是否提权：</strong></p>
<ul>
<li><p>如果没有权限变化则等价于普通的跨段跳转，只不过这里跳转的地址不是直接从操作数获取的。</p>
</li>
<li><p>如果权限发生变化则需要进行栈切换：</p>
<ul>
<li><p>从 TSS 中获取新的 <code>ss</code> 和 <code>esp</code> 更新对应的寄存器，期间会检测 <code>ss</code> 的权限以及 TSS 是否合法。</p>
</li>
<li><p>将原有的 <code>ss</code>，<code>esp</code>，参数（从原本的栈中拷贝，拷贝长度参考调用门描述符中的<strong>参数计数（Param Count）</strong>字段），<code>cs</code>，返回地址依次压入<strong>新</strong>的堆栈。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p>原有的堆栈中只有参数，没有压入返回地址之类的东西。</p>

    </div>
  </div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/image-20250602053230511.png"
                      alt="image-20250602053230511"
                ></p>
</li>
<li><p>根据门描述符中表示的代码段还有调用门入口点更新 <code>cs</code>，<code>eip</code>。</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>至此我们完成的 <code>cs</code> 和栈的切换，跳转指调用门指定的代码开始执行。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p>如果我们调试提权后的代码，则返回用户态之后会发生崩溃。</p>
<p>这是因为 <code>int 3</code> 对应的中断处理函数 <code>_KiTrap03</code> 会将 <code>fs</code> 寄存器修改为 0x30（这也是为什么我们下断点调试时发现 <code>fs</code> 的值发生变化），而由于我们通过调用门提权后处于 0 环权限，<code>_KiTrap03</code> 并不会恢复 <code>fs</code> 寄存器，因此我们在返回 3 环时需要手动还原 <code>fs</code> 寄存器。</p>

    </div>
  </div>

<h4 id="返回过程"><a href="#返回过程" class="headerlink" title="返回过程"></a>返回过程</h4><p>如果我们通过 <code>call</code> 长调用指令进行调用门跳转则需要通过 <code>retf</code> 指令返回。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p>如果调用门规定了参数格式，则我们必须使用 <code>retf [参数的字节总数]</code> 来返回。</p>
<p>注意，<code>retf</code> 后面跟的是参数的字节数，而调用门的<strong>参数计数（Param Count）</strong>字段描述的是参数的个数。</p>

    </div>
  </div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/image-20250603020931539.png"
                      alt="image-20250603020931539"
                ></p>
<p>具体过程为：</p>
<ol>
<li><p><strong>进行权限检查</strong> ：根据栈中存放的 <code>cs</code> 寄存器判断是否发生权限（CPL）变化：</p>
<ul>
<li><p>如果没有发生权限变化则为普通的跨段跳转，不会发生栈切换。</p>
</li>
<li><p>如果发生权限变化则：</p>
<ul>
<li>只能是降权，即在数值上栈中保存的 <code>cs</code> 的 RPL 要大于 CPL。</li>
<li>对栈中保存的 <code>ss</code> 进行权限检查，要求返回后 <code>ss</code> 和 <code>cs</code> 的 DPL 要相等。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>恢复寄存器</strong> ：</p>
<ul>
<li>根据中保存的 <code>eip</code>，<code>cs</code> 恢复 <code>eip</code> 和 <code>cs</code> 寄存器。</li>
<li>如果降权则要在普通的跨段跳转返回的基础上根据栈中保存的 <code>esp</code> 和 <code>ss</code> 恢复堆栈。栈中保存的 <code>esp</code> 和 <code>ss</code> 的位置需要根据 <code>retf</code> 后面跟的参数字节数定位。</li>
</ul>
</li>
<li><p><strong>平衡堆栈</strong> ：</p>
<ul>
<li><p>如果权限不变则根据 <code>retf</code> 后面跟的参数字节数平衡掉压入的参数，另外还要平衡掉跨段跳转时压入的返回地址和 <code>cs</code>。</p>
</li>
<li><p>如果是降权则需要在<strong>原本的堆栈</strong>中根据 <code>retf</code> 后面跟的参数字节数平衡掉压入的参数。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p>内核堆栈每次都是通过 TSS 的 <code>esp</code> 赋值，因此不需要平衡内核堆栈。</p>

    </div>
  </div></li>
</ul>
</li>
</ol>
<h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><h2 id="什么是中断"><a href="#什么是中断" class="headerlink" title="什么是中断"></a>什么是中断</h2><p>中断（<strong>Interrupt</strong>）是计算机系统中一种<strong>异步事件通知机制</strong>，用于在处理器正在执行任务时，<strong>打断当前执行流程</strong>，让处理器去响应<strong>更紧急或更重要的事件</strong>。</p>
<p>中断机制为计算机系统提供了一种对事件的实时响应方式，同时保证处理器资源的高效利用。</p>
<p>按照<strong>来源</strong>划分，中断可以分为<strong>硬件中断</strong>和<strong>软件中断</strong> ：</p>
<ul>
<li><p><strong>硬件中断</strong> ：来自外部设备（如键盘、鼠标、定时器、网卡）发出的中断信号。如：键盘按键、鼠标移动、时钟滴答。</p>
</li>
<li><p><strong>软件中断</strong> ：由程序通过指令（如 <code>int</code>）显式触发，通常用于系统调用。</p>
</li>
</ul>
<p>按<strong>目的</strong>划分，中断可以分为<strong>可屏蔽中断（IRQ）</strong>，<strong>不可屏蔽中断（NMI）</strong>和<strong>异常（Exception）</strong> ：</p>
<ul>
<li><p><strong>可屏蔽中断（IRQ）</strong> ：可以被禁止（如设置 <code>IF=0</code>，<code>EFLAGS</code> 寄存器第 10 位）。大多数硬件中断都属于这一类。</p>
</li>
<li><p><strong>不可屏蔽中断（NMI）</strong> ：非常紧急，不能被屏蔽，比如内存校验出错。</p>
</li>
<li><p><strong>异常（Exception）</strong> ：由 CPU 自身执行错误或特定条件触发，如除 0、段错误、页错误等。属于“内部中断”。</p>
</li>
</ul>
<h2 id="中断描述符表（IDT-Interrupt-Descriptor-Table）"><a href="#中断描述符表（IDT-Interrupt-Descriptor-Table）" class="headerlink" title="中断描述符表（IDT,Interrupt Descriptor Table）"></a>中断描述符表（IDT,Interrupt Descriptor Table）</h2><p>与调用门不同，中断门的门描述符位于存储在 <strong>IDT（中断描述符表）</strong> 中。这是因为中断描述符要以“中断号”为索引，用于快速响应<strong>异步事件</strong>或异常情况，强调处理器控制流程的跳转，因此需要单开一个表存储。</p>
<p> 中断向量表（IDT）最多有 <strong>256 项</strong>（编号 0–255），每一项都对应一个中断&#x2F;异常，中断号就是中断向量表的下标。其中中断号 0–31（共 32 个）被 CPU 保留，用于异常处理，<strong>操作系统不得更改其语义</strong>。</p>
<table>
<thead>
<tr>
<th>中断号</th>
<th>异常简称</th>
<th>异常名称</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>#DE</td>
<td>Divide Error（除 0 错误）</td>
<td>Fault</td>
</tr>
<tr>
<td>1</td>
<td>#DB</td>
<td>Debug（调试异常）</td>
<td>Fault&#x2F;Trap</td>
</tr>
<tr>
<td>2</td>
<td>—</td>
<td>Non-Maskable Interrupt（NMI）</td>
<td>Interrupt</td>
</tr>
<tr>
<td>3</td>
<td>#BP</td>
<td>Breakpoint（断点）</td>
<td>Trap</td>
</tr>
<tr>
<td>4</td>
<td>#OF</td>
<td>Overflow（溢出）</td>
<td>Trap</td>
</tr>
<tr>
<td>5</td>
<td>#BR</td>
<td>BOUND Range Exceeded（数组越界）</td>
<td>Fault</td>
</tr>
<tr>
<td>6</td>
<td>#UD</td>
<td>Invalid Opcode（非法&#x2F;未定义指令）</td>
<td>Fault</td>
</tr>
<tr>
<td>7</td>
<td>#NM</td>
<td>Device Not Available（协处理器不可用）</td>
<td>Fault</td>
</tr>
<tr>
<td>8</td>
<td>#DF</td>
<td>Double Fault（双重故障）</td>
<td>Abort</td>
</tr>
<tr>
<td>9</td>
<td>—</td>
<td>Coprocessor Segment Overrun（协处理器段溢出）</td>
<td>Fault（已废弃）</td>
</tr>
<tr>
<td>10</td>
<td>#TS</td>
<td>Invalid TSS（任务状态段无效）</td>
<td>Fault</td>
</tr>
<tr>
<td>11</td>
<td>#NP</td>
<td>Segment Not Present（段不存在）</td>
<td>Fault</td>
</tr>
<tr>
<td>12</td>
<td>#SS</td>
<td>Stack Segment Fault（栈段错误）</td>
<td>Fault</td>
</tr>
<tr>
<td>13</td>
<td>#GP</td>
<td>General Protection Fault（一般保护异常）</td>
<td>Fault</td>
</tr>
<tr>
<td>14</td>
<td>#PF</td>
<td>Page Fault（页错误）</td>
<td>Fault</td>
</tr>
<tr>
<td>15</td>
<td>—</td>
<td>Reserved（保留）</td>
<td>—</td>
</tr>
<tr>
<td>16</td>
<td>#MF</td>
<td>x87 Floating-Point Error（浮点错误）</td>
<td>Fault</td>
</tr>
<tr>
<td>17</td>
<td>#AC</td>
<td>Alignment Check（对齐检查）</td>
<td>Fault</td>
</tr>
<tr>
<td>18</td>
<td>#MC</td>
<td>Machine Check（机器检查）</td>
<td>Abort</td>
</tr>
<tr>
<td>19</td>
<td>#XM&#x2F;#XF</td>
<td>SIMD Floating-Point Exception</td>
<td>Fault</td>
</tr>
<tr>
<td>20–31</td>
<td>—</td>
<td>Reserved（保留）</td>
<td>—</td>
</tr>
</tbody></table>
<p>中断号 32–255：<strong>可由操作系统自由使用</strong>，每一项都是一个“中断描述符”，可为以下几种类型：</p>
<table>
<thead>
<tr>
<th>描述符类型</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>中断门（Interrupt Gate）</td>
<td>常用于处理硬件中断，自动清除 IF 位，防止嵌套</td>
</tr>
<tr>
<td>陷阱门（Trap Gate）</td>
<td>常用于异常和调试，不清除 IF</td>
</tr>
<tr>
<td>任务门（Task Gate）</td>
<td>切换到另一个任务（TSS），操作系统不使用该功能</td>
</tr>
</tbody></table>
<p>关于 IDT 有如下常用的调试命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>r idtr</code>&#x2F;<code>r idtl</code></td>
<td>查看 IDT 基地址和长度</td>
</tr>
<tr>
<td><code>!idt</code></td>
<td>查看当前处理器 IDT 内容</td>
</tr>
<tr>
<td><code>!idt &lt;n&gt;</code></td>
<td>查看中断号 <code>&lt;n&gt;</code> 的处理函数</td>
</tr>
<tr>
<td><code>~&lt;n&gt;</code></td>
<td>切换到第 n 个处理器上下文</td>
</tr>
</tbody></table>
<h2 id="中断门"><a href="#中断门" class="headerlink" title="中断门"></a>中断门</h2><p><strong>中断门（Interrupt Gate）是 x86 架构中用于处理中断（硬件&#x2F;软件中断）和异常的一种特殊机制。</strong>它是一种描述符，存储在 <strong>IDT（中断描述符表）</strong> 中，用于指向中断&#x2F;异常处理程序的入口地址和相关属性。</p>
<p>中断门的作用是：<strong>当发生中断或异常时，CPU 通过中断门自动跳转到对应的处理函数</strong>，并进行必要的权限切换、堆栈切换等。</p>
<h3 id="门描述符-1"><a href="#门描述符-1" class="headerlink" title="门描述符"></a>门描述符</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/InterruptGateDescriptior.svg"
                      alt="InterruptGateDescriptior"
                ></p>
<ul>
<li><strong>偏移地址（Offset）</strong> ：目标代码段中中断处理程序入口的<strong>逻辑地址</strong>，分为 16 位的低位偏移（<code>Offset 15:00</code>）和 16 位的高位偏移（<code>Offset 31:16</code>），需要与段选择子指向的段描述符结合才能得到入口的<strong>线性地址</strong>。</li>
<li><strong>段选择子（Segment Selector）</strong> ：中断门要跳转到的目标代码段的选择子，用于在 GDT 或 LDT 中查找中断处理程序所在的段描述符。</li>
<li><strong>类型（Type）</strong> ：4 位，表示门描述符的类型。对于 32 位中断门，值为 <code>1110</code>（0xE）；表示该门在触发时会自动清除 EFLAGS 中的 IF 位，从而禁止中断嵌套。</li>
<li><strong>系统段标志（S）</strong> ：1 位，固定为 0，表示中断门是系统段，而不是普通的代码段或数据段。</li>
<li><strong>描述符特权级（DPL）</strong> ：2 位，表示访问中断门所需的最低特权级。在中断由软件触发（如 INT 指令）时进行特权检查；若 CPL &gt; DPL，则会触发 #GP 异常。</li>
<li><strong>段存在标志（P）</strong> ：1 位，表示中断门描述符是否存在。若为 0，访问该中断门会触发 #NP（Not Present）异常。</li>
</ul>
<h3 id="过程分析-1"><a href="#过程分析-1" class="headerlink" title="过程分析"></a>过程分析</h3><h4 id="调用过程-1"><a href="#调用过程-1" class="headerlink" title="调用过程"></a>调用过程</h4><p>当我们通过 <code>int n</code> 或指令触发中断：</p>
<ol>
<li><p><strong>根据中断向量在 IDT 中查找中断门描述符。</strong>（指令中的操作数 <code>n</code> 作为索引，找到对应的门描述符；跳转地址由中断门中的 <code>Offset</code> 和 <code>Segment Selector</code> 字段决定）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/image-20250603235057313.png"
                      alt="image-20250603235057313"
                ></p>
</li>
<li><p><strong>进行权限检查：</strong></p>
<ul>
<li>对于<strong>硬件中断</strong> ：<strong>不进行权限检查</strong>，中断处理程序直接执行。</li>
<li>对于<strong>软件中断（如 INT n）</strong> ：<ul>
<li>CPL（当前特权级）必须<strong>小于等于</strong>中断门的 DPL。</li>
<li>如果 CPL &gt; DPL，则触发 #GP 异常。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>判断是否发生权限变化（提权）</strong> ：</p>
<ul>
<li><p>如果中断门的目标代码段的 DPL &lt; CPL，则发生提权，需要进行<strong>堆栈切换</strong>。</p>
<ul>
<li>从 TSS 中查找对应的 <code>SS</code> 和 <code>ESP</code>，加载为新堆栈。</li>
<li>将当前栈的 <code>SS</code>、<code>ESP</code>、<code>EFLAGS</code>、<code>CS</code> 和 <code>EIP</code> 依次压入新堆栈中，形成完整的返回上下文。</li>
<li>若中断号是 <code>INT n</code> 且带有错误码，则错误码也一并压入堆栈（CPU 固定的几项，我们自己注册的没有）。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/image-20250603235355733.png"
                      alt="image-20250603235355733"
                ></p>
</li>
<li><p>如果没有权限变化（例如从 Ring 0 调用 Ring 0 中断门）则不会切换堆栈，仅将 <code>EFLAGS</code>、<code>CS</code>、<code>EIP</code> 压入当前堆栈。</p>
</li>
</ul>
</li>
<li><p><strong>修改 <code>EFLAGS</code> 寄存器</strong> ：中断门会清空 <code>EFLAGS</code> 寄存器中的下面几个标志位：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/image-20250604005350818.png"
                      alt="image-20250604005350818"
                ></p>
</li>
</ol>
<table>
<thead>
<tr>
<th>位名</th>
<th>含义</th>
<th>EFLAGS 位位置</th>
<th>修改行为 &#x2F; 说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>IF</strong> (Interrupt Flag)</td>
<td>中断允许标志：控制是否允许 CPU 响应<strong>可屏蔽中断（IRQ）</strong></td>
<td>位 9</td>
<td>当通过<strong>中断门进入中断处理程序时</strong>，CPU 会自动将 <code>IF = 0</code>，即<strong>暂时屏蔽其他中断</strong>，防止当前中断被新的中断打断。等中断处理结束后通过 <code>IRET</code> 恢复原 <code>EFLAGS</code>，<code>IF</code> 才可能再次为 1。这个行为只发生在中断门，<strong>陷阱门不会清除 IF</strong>，允许中断嵌套。</td>
</tr>
<tr>
<td><strong>TF</strong> (Trap Flag)</td>
<td>单步调试标志：控制是否在每条指令后触发调试异常（#DB）</td>
<td>位 8</td>
<td>进入中断处理程序前，CPU 会自动将 <code>TF</code> 清 0，<strong>禁止单步调试在中断处理流程中生效</strong>，避免调试器每条指令都触发中断，造成混乱甚至不可预期行为。恢复时，<code>IRET</code> 会将 <code>TF</code> 恢复为中断前的状态。</td>
</tr>
<tr>
<td><strong>NT</strong> (Nested Task)</td>
<td>嵌套任务标志：用于任务切换机制（与 TSS 和任务门相关）</td>
<td>位 14</td>
<td><code>NT = 1</code> 表示当前是嵌套任务。中断门触发时，<strong>即便不是 Task Gate 形式，也会清除 <code>NT</code> 位为 0</strong>，防止任务嵌套链在中断中干扰任务切换控制流。(如果是嵌套任务则 <code>iretd</code> 指令会根据任务段返回)</td>
</tr>
<tr>
<td><strong>VM</strong> (Virtual 8086 Mode)</td>
<td>虚拟 8086 模式标志：控制是否在 V8086 模拟环境中运行 16 位实模式代码</td>
<td>位 17</td>
<td>如果 CPU 当前处于 <code>VM = 1</code>（虚拟 8086 模式），当通过中断门执行 <code>INT n</code> 指令时，CPU 会自动清除 <code>VM</code>，<strong>退出 V86 模式，进入保护模式（Ring 0）</strong>，以便执行保护模式下的中断处理程序。这个过程伴随着堆栈切换、权限检查和返回机制，支持从实模式模拟环境跳转到内核态中断处理逻辑。</td>
</tr>
</tbody></table>
<ol start="5">
<li><p><strong>跳转到中断处理程序：</strong></p>
<ul>
<li>设置新的 <code>CS:EIP</code> 为门描述符中指定的目标。</li>
<li>开始执行中断处理程序。</li>
</ul>
</li>
</ol>
<h4 id="返回过程-1"><a href="#返回过程-1" class="headerlink" title="返回过程"></a>返回过程</h4><p>在中断处理程序结束时通过 <code>iret</code>（ 32 位 <code>iretd</code>，64 位 <code>iretq</code>）指令返回，具体过程为：</p>
<ol>
<li><strong>进行权限检查：</strong><ul>
<li>从栈中弹出 <code>EIP</code>、<code>CS</code> 和 <code>EFLAGS</code>。</li>
<li>如果发生过权限变化（即从高权限跳转到低权限）：<ul>
<li>同时还需要从栈中恢复 <code>SS</code> 和 <code>ESP</code>。</li>
<li>返回后会将 CPL 设置为 <code>CS</code> 描述符中的 DPL。</li>
</ul>
</li>
</ul>
</li>
<li><strong>恢复上下文：</strong><ul>
<li>设置 <code>CS:EIP</code> 为返回地址。</li>
<li>恢复原 <code>EFLAGS</code>。</li>
<li>如果发生过堆栈切换，则也恢复 <code>SS</code> 和 <code>ESP</code>，切回用户堆栈。</li>
</ul>
</li>
<li><strong>完成权限恢复与返回：</strong><ul>
<li>中断处理完毕，程序继续从中断发生处继续执行。</li>
</ul>
</li>
</ol>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <ul>
<li>若中断期间修改了段寄存器（如 <code>fs</code>），在返回到用户态前应手动还原。</li>
<li><code>iretd</code> 不能被 <code>retf 4</code> 代替，因为发送权限变化的时候 <code>retf 4</code> 还会平衡掉用户态栈中压入的参数，而 <code>int</code> 指令只在内核态栈中压入 <code>EFLAGS</code>，因此会导致堆栈不平衡。</li>
</ul>

    </div>
  </div>

<h2 id="陷阱门"><a href="#陷阱门" class="headerlink" title="陷阱门"></a>陷阱门</h2><p>陷阱门是一种<strong>门描述符</strong>，用于定义某个中断或异常发生时，处理器该跳转到哪段代码继续执行。它和中断门类似，都存在于 <strong>IDT（Interrupt Descriptor Table）</strong> 中，但行为略有不同，<strong>主要用于不会频繁嵌套、需要精细控制响应时机的异常或调试场景</strong>。</p>
<h3 id="门描述符-2"><a href="#门描述符-2" class="headerlink" title="门描述符"></a>门描述符</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/TrapGateDescriptior.svg"
                      alt="TrapGateDescriptior"
                ></p>
<p>陷阱门描述符与中断门描述符格式基本一致，唯一区别就是 <code>Type</code> 字段不同，由 <code>1110</code>（0xE）变为了 <code>1111</code>（0xF）。</p>
<h3 id="过程分析-2"><a href="#过程分析-2" class="headerlink" title="过程分析"></a>过程分析</h3><p>与中断门完全一致，唯一的不同点在于陷阱门不会清空 <code>EFLAGS</code> 的 <code>IF</code> 标志位。</p>
<h2 id="任务门"><a href="#任务门" class="headerlink" title="任务门"></a>任务门</h2><p><strong>任务门（Task Gate）</strong>是一种特殊的<strong>系统段描述符</strong>，用于在 <strong>x86 保护模式</strong>下实现<strong>任务切换（Task Switch）</strong>，其本质作用是<strong>指向一个任务（TSS），以便通过它进行硬件级别的任务切换</strong>。</p>
<p>然而<strong>现代操作系统几乎完全不用任务门（Task Gate）和硬件任务切换机制</strong>，无论是 Windows、Linux、macOS 还是虚拟化内核，<strong>都采用软件实现的任务调度和上下文切换机制</strong>。这是因为：</p>
<ul>
<li><strong>控制粒度太粗、太死板。</strong><ul>
<li>一旦使用任务门 → 切换的是整个 TSS + CR3 + 所有段寄存器 + GPR + EFLAGS + EIP。OS 不能只保存&#x2F;恢复一部分，比如只切换线程状态，不切换地址空间。而软件调度可以精细控制切换内容（比如 lazy FPU context switching、延迟页表切换等）。</li>
<li><strong>性能开销大。</strong>使用任务门意味着 CPU 要自动执行一整套验证、保存、加载流程，而软件调度只需要保存需要的部分上下文，用 <code>mov</code>, <code>push</code>, <code>pop</code> 就行，效率更高。</li>
<li><strong>异常可恢复性差。</strong>硬件任务切换由 CPU 自动执行的一整套流程，如果在任务切换“中间过程”如果出错，则当前处于模糊状态，OS 没办法清楚知道到底处在哪个任务上下文。最终会导致：<strong>陷入不可恢复状态 → Triple Fault（第三次错误） → CPU 复位重启</strong>，分析调试困难。</li>
</ul>
</li>
<li><strong>不利高并发场景。</strong>TSS 原生只支持一个任务状态。TSS 的 busy 位、防嵌套规则等，使得任务链和多线程管理变得复杂且危险，经常可能因为并发问题触发异常导致系统崩溃。Linux、Windows 等直接为每个 CPU 定义自己的调度器和线程控制块（TCB），避免使用硬件机制。</li>
<li><strong>兼容性差。</strong>硬件任务切换机制使得 OS 必须与 x86 的 GDT、IDT、TSS、任务门、段保护等高度绑定，导致 OS 无法跨架构通用，也难以模块化维护。</li>
</ul>
<p>因此现代操作系统中任务门的主要作用为：</p>
<ul>
<li><p><strong>TSS 的 ESP0 用于内核栈切换</strong> ：现代操作系统都需要为每个 CPU 设置一个 TSS，仅为了提供 Ring 3 → Ring 0 的栈切换支持。在中断门或系统调用触发从用户态切换到内核态时，CPU 自动从当前 CPU 的 TSS 中加载 <code>SS0</code> &#x2F; <code>ESP0</code> 作为临时新栈顶。</p>
</li>
<li><p><strong>双重错误（#DF）异常处理</strong> ：Intel 推荐用 <strong>任务门</strong> 描述符来设置 IDT 中的第 8 号向量（#DF），这样就可以防止中断嵌套导致的<strong>堆栈损坏</strong>引发 Triple Fault。我们在调试这类异常的时候可以根据这一性质找到出现异常的堆栈。</p>
<blockquote>
<p><em>“Some exception handlers, such as the double-fault exception handler, are typically set up with a task gate in the IDT. This enables the processor to switch to a known-good TSS and clean stack.”</em><br>— SDM Vol. 3, Section 6.15 “Exception and Interrupt Handling”</p>
</blockquote>
</li>
</ul>
<h3 id="任务段描述符（TSS-Descriptor）"><a href="#任务段描述符（TSS-Descriptor）" class="headerlink" title="任务段描述符（TSS Descriptor）"></a>任务段描述符（TSS Descriptor）</h3><p>任务段（TSS）描述符的定义如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/TSSDescriptior.svg"
                      alt="TSSDescriptior"
                ></p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p>根据《Intel SDM（System Developer’s Manual）》中的明确规定：</p>
<blockquote>
<p><strong>“TSS descriptors may only be placed in the GDT; they cannot be placed in an LDT or the IDT.”</strong></p>
</blockquote>
<p><strong>任务段（TSS）描述符</strong>只能出现在 <strong>GDT（全局描述符表）</strong> 中，不能放在 LDT（局部描述符表）里。</p>

    </div>
  </div>

<ul>
<li><p><strong>段基址（Base Address）</strong> ：任务段（TSS）在内存中的线性地址，由三部分组成：<code>Base 15:00</code>、<code>Base 23:16</code> 和 <code>Base 31:24</code>，共同构成 32 位的段基址，用于定位 TSS 数据结构的起始地址。</p>
</li>
<li><p><strong>段限长（Segment Limit）</strong> ：指定任务段的长度，通常为 <code>0x67</code>（即 104 字节），分为低 16 位（<code>Limit 15:00</code>）和高 4 位（<code>Limit 19:16</code>）。如果 <code>G</code> 位为 0，则按字节为单位解释该限长。</p>
</li>
<li><p><strong>类型（Type）</strong> ：4 位，表示描述符的具体类型。对于 32 位可用任务段：</p>
<ul>
<li>类型值为 <code>1001</code>（0x9）说明该TSS段描述符未被加载到TR段寄存器中。</li>
<li>类型值为 <code>1011</code>（0xB）说明该TSS段描述符已被加载到TR段寄存器中。</li>
</ul>
</li>
<li><p><strong>系统段标志（S）</strong> ：1 位，必须固定为 0，表示该描述符是一个系统段，而非普通的代码段或数据段。TSS、LDT、门描述符等都属于系统段。</p>
</li>
<li><p><strong>描述符特权级（DPL）</strong> ：2 位，表示对该任务段的访问权限要求。在通过任务门或软件指令（如 <code>CALL</code>, <code>JMP</code>）触发任务切换时，当前特权级（CPL）必须 ≤ DPL，否则会触发 #GP（General Protection）异常。</p>
</li>
<li><p><strong>段存在标志（P）</strong> ：1 位，表示该任务段是否有效。若为 0，则尝试访问此任务段会触发 #NP（Not Present）异常；为 1 时表示段存在且可以使用。</p>
</li>
<li><p><strong>可用位（AVL）</strong> ：1 位，由操作系统自由使用，处理器不进行解释。常用于系统内部标记用途，例如多处理器状态跟踪或调试标志。</p>
</li>
<li><p><strong>默认操作数大小（D&#x2F;B）</strong> ：1 位，对于任务段必须设置为 0，否则行为未定义。该位在代码段中表示默认指令大小（16&#x2F;32 位），但在 TSS 描述符中无实际意义。</p>
</li>
<li><p><strong>粒度（G）</strong> ：1 位，控制段限长的单位。当为 0 时，段限长以字节为单位解释（TSS 推荐）；若为 1，则以 4KB 页为单位（不建议用于 TSS）。</p>
</li>
</ul>
<h3 id="任务寄存器（TR，Task-Register）"><a href="#任务寄存器（TR，Task-Register）" class="headerlink" title="任务寄存器（TR，Task Register）"></a>任务寄存器（TR，Task Register）</h3><p><strong>TR（Task Register，任务寄存器）</strong>是 x86 处理器中的一个系统段寄存器，用于引用当前正在使用的任务状态段（TSS）。</p>
<p>TR 寄存器会保存当前活动 TSS 的 <strong>段选择子</strong>（32 位下默认是 28），并缓存当前 TSS 的 <strong>基地址</strong> 和 <strong>限长</strong>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/image-20250604014705925.png"
                      alt="image-20250604014705925"
                ></p>
<p><code>TR</code> 寄存器可以通过 <code>LTR</code> 和 <code>STR</code> 指令进行读写，不过这两个指令都是 <strong>特权指令</strong>，<strong>只能在特权级 0（CPL &#x3D; 0）下执行</strong>。</p>
<ul>
<li><code>STR r16/m16</code>：从 <code>TR</code> 读取当前任务段选择子。</li>
<li><code>LTR r/m16</code>：向 <code>TR</code> 加载任务段选择子。</li>
</ul>
<h3 id="任务段（TSS，Task-State-Segment）"><a href="#任务段（TSS，Task-State-Segment）" class="headerlink" title="任务段（TSS，Task State Segment）"></a>任务段（TSS，Task State Segment）</h3><p><strong>任务段（TSS，Task State Segment）</strong>是 x86 架构中为支持<strong>多任务操作系统</strong>设计的一个特殊机制，它定义了一段特殊的内存结构，用于<strong>保存任务（线程&#x2F;进程）的运行上下文和特权级切换信息</strong>。</p>
<p>虽然现代操作系统（如 Windows 和 Linux）<strong>不再使用“硬件任务切换”</strong>（TSS 最初的主要目的），但 TSS 在 <strong>中断处理、安全控制、特权切换时仍然是必不可少的组件</strong>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/image-20250604014908047.png"
                      alt="image-20250604014908047"
                ></p>
<ul>
<li><p><strong>Previous Task Link</strong> ：上一个任务字段。如果使用任务切换（如使用<code>jmp TSS selector</code>），这里保存前一个任务的 TSS 选择子。由于 Windows 基本不使用硬件任务切换（而是用软件方式），因此此字段一般无实际用途。</p>
</li>
<li><p><strong>栈切换相关字段</strong> ：</p>
<ul>
<li><strong>ESP0 &#x2F; SS0</strong> ： Windows 在处理系统调用（如<code>sysenter</code>或<code>int 0x2e</code>）和异常（如页错误）时依赖这两个字段快速切换内核栈。当 CPU 从用户态（CPL&#x3D;3）切换到内核态（CPL&#x3D;0）时，会自动加载这两个字段的值作为内核栈的临时基地址（<code>SS:ESP</code>）。</li>
<li><strong>ESP1 &#x2F; SS1，ESP2 &#x2F; SS2</strong> ：较少用，仅在三层栈（Ring1、Ring2）情况下切换，<strong>Windows 不使用</strong>，这些字段保留。</li>
</ul>
</li>
<li><p><strong>CR3（PDBR）</strong> ：存储页目录基地址寄存器（CR3），用于指向进程的页表。如果用任务切换机制，CPU 会自动加载 CR3 切换页表。</p>
</li>
<li><p><strong>通用寄存器和段寄存器</strong> ：这些是当通过任务切换机制（<code>CALL/JMP TSS</code>）切换任务时自动保存的内容。</p>
<ul>
<li><strong>通用寄存器</strong> ：EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP</li>
<li><strong>段寄存器</strong> ：ES, CS, SS, DS, FS, GS</li>
<li><strong>其他</strong> ：EIP、EFLAGS</li>
</ul>
</li>
<li><p><strong>LDT Segment Selector</strong> ：指定当前任务使用的 LDT（Local Descriptor Table）。</p>
</li>
<li><p><strong>T（Trap）位</strong> ：如果置 1，则在任务切换到此 TSS 时触发调试异常（#DB）</p>
</li>
<li><p><strong>I&#x2F;O Map Base Address</strong> ：指定 TSS 后面的 I&#x2F;O 权限位图偏移，用于控制任务是否可以访问某些 I&#x2F;O 端口，某些驱动或 VM 技术中使用。</p>
</li>
<li><p><strong>SSP（Shadow Stack Pointer）</strong> ：当启用 Intel CET（Control-flow Enforcement Technology）时，记录 Shadow Stack 的指针。<strong>Windows 10+ 在启用 CET 保护（比如 MS Edge 浏览器）时会使用它。</strong></p>
<blockquote>
<p>Intel CET（Control-flow Enforcement Technology，<strong>控制流强制技术</strong>）是 Intel 推出的一个 <strong>硬件级安全特性</strong>。CET 有两个核心组件：</p>
<ul>
<li><strong>Shadow Stack（影子栈）</strong> ：CPU 维护一个只写入返回地址的“只读”影子栈。每次函数调用（<code>CALL</code>）时，返回地址会同时写入正常栈和影子栈。当执行 <code>RET</code> 时，CPU 会比对影子栈的返回地址，不一致则触发异常。</li>
<li><strong>Indirect Branch Tracking（IBT）</strong> ： 限制间接跳转（<code>JMP</code>、<code>CALL</code> 到寄存器&#x2F;内存）只能跳转到<strong>有效的目标地址</strong>。要跳转的目标必须以特殊指令（如 <code>ENDBR32</code> 或 <code>ENDBR64</code>）开头，否则触发异常。</li>
</ul>
</blockquote>
</li>
</ul>
<p><code>ntkrpamp!_KTSS</code> 是 Windows 内核中用于描述任务状态段（TSS，Task State Segment）的结构体，主要用于 x86 架构下的特权级堆栈切换、I&#x2F;O 端口访问控制等功能。</p>
<p>虽然现代 Windows 系统主要采用软件方式进行任务切换，但仍为每个处理器维护一个 TSS 结构，特别是在处理特定异常（如双重故障）时，硬件任务切换机制仍可能被触发。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x20ac bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">KTSS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    USHORT Backlink;                                                        <span class="comment">//0x0</span></span><br><span class="line">    USHORT Reserved0;                                                       <span class="comment">//0x2</span></span><br><span class="line">    ULONG Esp0;                                                             <span class="comment">//0x4</span></span><br><span class="line">    USHORT Ss0;                                                             <span class="comment">//0x8</span></span><br><span class="line">    USHORT Reserved1;                                                       <span class="comment">//0xa</span></span><br><span class="line">    ULONG NotUsed1[<span class="number">4</span>];                                                      <span class="comment">//0xc</span></span><br><span class="line">    ULONG CR3;                                                              <span class="comment">//0x1c</span></span><br><span class="line">    ULONG Eip;                                                              <span class="comment">//0x20</span></span><br><span class="line">    ULONG EFlags;                                                           <span class="comment">//0x24</span></span><br><span class="line">    ULONG Eax;                                                              <span class="comment">//0x28</span></span><br><span class="line">    ULONG Ecx;                                                              <span class="comment">//0x2c</span></span><br><span class="line">    ULONG Edx;                                                              <span class="comment">//0x30</span></span><br><span class="line">    ULONG Ebx;                                                              <span class="comment">//0x34</span></span><br><span class="line">    ULONG Esp;                                                              <span class="comment">//0x38</span></span><br><span class="line">    ULONG Ebp;                                                              <span class="comment">//0x3c</span></span><br><span class="line">    ULONG Esi;                                                              <span class="comment">//0x40</span></span><br><span class="line">    ULONG Edi;                                                              <span class="comment">//0x44</span></span><br><span class="line">    USHORT Es;                                                              <span class="comment">//0x48</span></span><br><span class="line">    USHORT Reserved2;                                                       <span class="comment">//0x4a</span></span><br><span class="line">    USHORT Cs;                                                              <span class="comment">//0x4c</span></span><br><span class="line">    USHORT Reserved3;                                                       <span class="comment">//0x4e</span></span><br><span class="line">    USHORT Ss;                                                              <span class="comment">//0x50</span></span><br><span class="line">    USHORT Reserved4;                                                       <span class="comment">//0x52</span></span><br><span class="line">    USHORT Ds;                                                              <span class="comment">//0x54</span></span><br><span class="line">    USHORT Reserved5;                                                       <span class="comment">//0x56</span></span><br><span class="line">    USHORT Fs;                                                              <span class="comment">//0x58</span></span><br><span class="line">    USHORT Reserved6;                                                       <span class="comment">//0x5a</span></span><br><span class="line">    USHORT Gs;                                                              <span class="comment">//0x5c</span></span><br><span class="line">    USHORT Reserved7;                                                       <span class="comment">//0x5e</span></span><br><span class="line">    USHORT LDT;                                                             <span class="comment">//0x60</span></span><br><span class="line">    USHORT Reserved8;                                                       <span class="comment">//0x62</span></span><br><span class="line">    USHORT Flags;                                                           <span class="comment">//0x64</span></span><br><span class="line">    USHORT IoMapBase;                                                       <span class="comment">//0x66</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KiIoAccessMap</span> <span class="title">IoMaps</span>[1];</span>                                        <span class="comment">//0x68</span></span><br><span class="line">    UCHAR IntDirectionMap[<span class="number">32</span>];                                              <span class="comment">//0x208c</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p>Windows 默认不使用 <code>ESP1</code> &#x2F; <code>SS1</code> 和 <code>ESP2</code> &#x2F; <code>SS2</code> 等<strong>特权级备用栈（Ring 1 和 Ring 2 的栈）</strong>，所以在它所定义的 <code>_KTSS</code> 结构体中，这些字段会被统一省略或标为保留（<code>Reserved1</code>，<code>NotUsed1</code>）。</p>

    </div>
  </div>

<h3 id="任务门描述符（Task-Gate-Descriptor）"><a href="#任务门描述符（Task-Gate-Descriptor）" class="headerlink" title="任务门描述符（Task Gate Descriptor）"></a>任务门描述符（Task Gate Descriptor）</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/TaskGateDescriptior.svg"
                      alt="TaskGateDescriptior"
                ></p>
<ul>
<li><p><strong>段选择子（TSS Segment Selector）</strong> ：表示该任务门对应的目标任务段（TSS）。该字段占据描述符的第 0–15 位，其值应为 GDT 中某个 <strong>TSS 段描述符的选择子</strong>。当任务门被触发时，处理器会使用该选择子来访问并加载目标 TSS，实现硬件任务切换。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/image-20250604014810467.png"
                      alt="image-20250604014810467"
                ></p>
</li>
<li><p><strong>类型（Type）</strong> ：4 位，位于描述符的第 40–43 位，用于标识该描述符的具体类型。对于任务门而言，该字段的值为 <code>0101</code>（即 0x5），表示“32 位任务门（Task Gate）”。该类型值要求处理器在使用该描述符时执行<strong>硬件任务切换流程</strong>。</p>
</li>
<li><p><strong>系统段标志（S）</strong> ：1 位，位于第 44 位，必须固定为 0，表示该描述符是一个 <strong>系统段</strong>，而非普通的数据段或代码段。所有任务门、中断门、陷阱门、TSS 和 LDT 描述符都属于系统段。</p>
</li>
<li><p><strong>描述符特权级（DPL）</strong> ：2 位，位于第 45–46 位，表示访问该任务门所需的最小权限级别。在尝试通过 <code>CALL</code>, <code>JMP</code>, 或 <code>INT</code> 指令使用该任务门时，如果当前特权级（CPL）高于该值，将会触发 <code>#GP</code>（General Protection）异常。该字段用于控制访问粒度，例如可限制用户态程序不可使用该门。</p>
</li>
<li><p><strong>段存在标志（P）</strong> ：1 位，位于第 47 位，用于表示该任务门描述符是否有效。当该位为 0 时，尝试访问该任务门会导致处理器抛出 <code>#NP</code>（Segment Not Present）异常。为 1 时表示描述符存在且可使用。</p>
</li>
</ul>
<h3 id="调用过程（任务切换机制）"><a href="#调用过程（任务切换机制）" class="headerlink" title="调用过程（任务切换机制）"></a>调用过程（任务切换机制）</h3><p>“任务门调用”是间接的任务切换方式，通过门找到 TSS；“任务段描述符调用”是直接调用 TSS 来切换任务。它们最终都会导致 TSS 被加载和任务切换，但路径和机制不同。</p>
<table>
<thead>
<tr>
<th>比较点</th>
<th>任务段描述符调用</th>
<th>任务门调用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>调用方式</strong></td>
<td><code>CALL TSS_selector</code> 或 <code>JMP TSS_selector</code>（选择子直接指向 TSS 描述符）</td>
<td><code>CALL</code>, <code>JMP</code>, 或 <code>INT</code> 到一个任务门（描述符中包含 TSS 选择子）</td>
</tr>
<tr>
<td><strong>位置</strong></td>
<td>TSS 必须在 <strong>GDT 中</strong></td>
<td>任务门可以在 <strong>GDT、LDT、IDT</strong></td>
</tr>
<tr>
<td><strong>是否间接</strong></td>
<td>❌ 否，直接引用 TSS</td>
<td>✅ 是，门中保存 TSS 的选择子</td>
</tr>
<tr>
<td><strong>可用于中断</strong></td>
<td>❌ 否，不能嵌入到 IDT</td>
<td>✅ 是，任务门可以作为中断门放入 IDT（任务型中断）</td>
</tr>
<tr>
<td><strong>权限检查点</strong></td>
<td>直接检查 TSS 描述符的 DPL</td>
<td>先检查门的 DPL，再检查 TSS 描述符的 DPL</td>
</tr>
<tr>
<td><strong>用途</strong></td>
<td>通常用于显式调度（早期OS设计）</td>
<td>可用于中断&#x2F;异常自动触发任务切换（支持隔离的 handler）</td>
</tr>
<tr>
<td><strong>效率与灵活性</strong></td>
<td>较低</td>
<td>稍好，但仍落后于软件上下文切换</td>
</tr>
<tr>
<td><strong>现代操作系统使用情况</strong></td>
<td>❌ 弃用</td>
<td>❌ 弃用（包括 Windows&#x2F;Linux）</td>
</tr>
</tbody></table>
<h4 id="任务段描述符调用过程"><a href="#任务段描述符调用过程" class="headerlink" title="任务段描述符调用过程"></a>任务段描述符调用过程</h4><p>使用 <code>CALL TSS_selector</code> 或 <code>JMP TSS_selector</code> 指令，其中选择子（Selector）指向 <strong>GDT 中的任务段描述符（TSS Descriptor）</strong>。</p>
<ol>
<li><p><strong>权限检查</strong> ：<code>max(CPL,RPL) ≤ DPL</code>，否则 <code>#GP(selector)</code></p>
</li>
<li><p><strong>存在检查</strong> ：P&#x3D;0 → <code>#NP(selector)</code></p>
</li>
<li><p><strong>类型检查</strong> ：Busy TSS 调用 → <code>#GP(selector)</code></p>
</li>
<li><p><strong>段限长检查</strong> ：limit &lt; 0x67 → <code>#GP(selector)</code></p>
</li>
<li><p><strong>加载新任务</strong></p>
<ul>
<li><p>将当前任务的上下文（寄存器、EIP、EFLAGS、段寄存器等）保存到当前 TSS；</p>
</li>
<li><p>设置 TR（Task Register）指向新的 TSS；</p>
</li>
<li><p><strong>目标 TSS 类型字段自动由 0x9 → 0xB</strong>，表示忙状态。</p>
</li>
<li><p><strong>载入新任务状态</strong> ：CR3、LDTR、EFLAGS、EIP、通用&#x2F;段寄存器</p>
</li>
<li><p>对 <code>CALL</code>：设置 <code>EFLAGS.NT=1</code> 并把当前 TSS 段选择子写到新 <code>TSS.Backlink</code>；<strong>对 <code>JMP</code> 不设置。</strong>因此如果想用 <code>JMP</code> 进行任务切换直接 <code>iretd</code> 返回会蓝屏。 </p>
<blockquote>
<p>When a <strong>CALL instruction</strong>, an interrupt, or an exception causes a task switch:<br>the processor copies the segment selector for the current TSS to the <strong>previous task link field (Backlink)</strong> of the TSS for the new task;<br>it then sets <strong>EFLAGS.NT &#x3D; 1</strong>.</p>
<p>当一个 <strong>CALL 指令、中断或异常</strong> 触发任务切换时：<br>处理器将当前 TSS 的段选择子写入新任务的 TSS 的 <strong>Backlink 字段</strong>，并设置 <strong>EFLAGS.NT &#x3D; 1</strong>。</p>
<p>When a <strong>JMP instruction</strong> causes a task switch, the new task is <strong>not nested</strong>.<br>The previous task link field is <strong>not used</strong> and <strong>EFLAGS.NT &#x3D; 0</strong>.</p>
<p>当一个 <strong>JMP 指令</strong> 引发任务切换时，新任务<strong>不被视为嵌套任务</strong>，不会使用 backlink，<strong>EFLAGS.NT &#x3D; 0</strong>。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h4 id="任务门调用过程"><a href="#任务门调用过程" class="headerlink" title="任务门调用过程"></a>任务门调用过程</h4><ol>
<li><p><strong>权限检查</strong> 对任务门（同样比较 CPL&#x2F;RPL 与 DPL）</p>
</li>
<li><p><strong>取出任务门中的 TSS Selector</strong></p>
</li>
<li><p>后续步骤与直接调用任务段相同。</p>
</li>
</ol>
<h4 id="返回过程-2"><a href="#返回过程-2" class="headerlink" title="返回过程"></a>返回过程</h4><ol>
<li><p>当执行 <code>iretd</code> 指令的时候，CPU 发现 <code>EFLAGS.NT=1</code>，识别为<strong>任务返回</strong>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/image-20250606011634326.png"
                      alt="image-20250606011634326"
                ></p>
<ul>
<li><p>任务状态段（TSS）中的“<strong>前一个任务链接字段</strong>”（Previous Task Link，有时也称为“backlink”）以及 <strong>EFLAGS 寄存器中的 NT 标志</strong>，用于将控制流<strong>返回到前一个任务</strong>。</p>
</li>
<li><p>当 <code>EFLAGS.NT = 1</code> 时，表示当前正在执行的任务是<strong>嵌套在另一个任务之内</strong>。</p>
</li>
</ul>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p>如果我们调试任务切换的代码，由于 <code>int 3</code> 中断会将 <code>EFLAGS.NT</code> 为置 0，导致返回的时候是通过堆栈返回，造成蓝屏。</p>

    </div>
  </div>
</li>
<li><p>读取当前 TSS 的 <strong>Backlink</strong> → 找到前一个 TSS 描述符。</p>
</li>
<li><p>对当前任务段执行与调用流程相同的有效性检查（<code>P=1</code>, <code>limit≥0x67</code>, <code>Type=Busy</code>）</p>
</li>
<li><p>保存当前任务状态到当前 TSS，因为 IRET 任务返回也属于任务切换。</p>
</li>
<li><p>清除当前 TSS Busy 位。</p>
</li>
<li><p>加载前一任务 TSS 内容 → 寄存器、EIP、EFLAGS。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p>如果 <strong>分页未启用</strong>（即 <code>CR0.PG = 0</code>），那么虽然 TSS 中的 CR3 字段仍会被读出来，<strong>但不会写入 CR3 寄存器</strong>。在 Intel 开发文档原文如下：</p>
<blockquote>
<p>If paging is not enabled, a PDBR value is read from the new task’s TSS, but it is not loaded into CR3.</p>
</blockquote>

    </div>
  </div>
</li>
<li><p>写 TR &#x3D; 前一 TSS selector，恢复其 Busy 状态。</p>
</li>
<li><p>清除 <code>EFLAGS.NT</code></p>
</li>
<li><p>跳回前一任务继续执行</p>
</li>
</ol>
<h1 id="页式内存管理"><a href="#页式内存管理" class="headerlink" title="页式内存管理"></a>页式内存管理</h1><p>Intel CPU 支持下面几种分页模式：</p>
<table>
<thead>
<tr>
<th>分页模式</th>
<th>地址宽度</th>
<th>页目录结构</th>
<th>页大小</th>
<th>是否支持 NX（DEP）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>非 PAE 分页</strong></td>
<td>32-bit</td>
<td>2 级（10+10+12）<br />CR3 → PDE → PTE</td>
<td>4 KB</td>
<td>❌ 否</td>
</tr>
<tr>
<td><strong>PAE 分页</strong></td>
<td>36-bit（最多64GB）</td>
<td>3 级（2+9+9+12）<br />CR3 → PDPT → PDE → PTE</td>
<td>4 KB, 2 MB</td>
<td>✅ 是</td>
</tr>
<tr>
<td><strong>x64 长模式分页</strong></td>
<td>48-bit（理论）</td>
<td>4 级（9+9+9+9+12）<br />CR3 → PML4 → PDPT → PDE → PTE</td>
<td>4 KB, 2 MB, 1 GB</td>
<td>✅ 是</td>
</tr>
</tbody></table>
<p>页式内存管理由 CPU 和操作系统共同维护：</p>
<ul>
<li><strong>CPU</strong> 主要负责<strong>地址转换过程</strong>。CPU 在执行指令时，如果涉及内存访问（如 <code>mov eax, [esp+0x10]</code>），就会自动触发地址翻译流程（虚拟 → 线性 → 物理）。</li>
<li><strong>操作系统</strong>主要负责<strong>页表结构维护</strong>。操作系统负责在内存中创建、更新和删除页表各层的表项，以决定每个虚拟地址该映射到哪个物理地址。</li>
</ul>
<p>有时候 CPU 还要与操作系统紧密配合，比如如果 CPU 发现访问的地址页表中标记为不存在（P&#x3D;0），则触发 #PF 缺页异常，此时需要由操作系统进行缺页处理或报错终止程序。</p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="Windows-XP-32-位"><a href="#Windows-XP-32-位" class="headerlink" title="Windows XP 32 位"></a>Windows XP 32 位</h3><p>Windows XP 32 位按照是否支持 PAE 和是否支持多处理器分为 4 个内核。</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>支持 PAE</th>
<th>支持 SMP（多处理器）</th>
<th>用途与说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ntoskrnl.exe</code></td>
<td>❌ 否</td>
<td>❌ 否</td>
<td>标准 <strong>单处理器</strong>，<strong>非 PAE</strong> 模式使用</td>
</tr>
<tr>
<td><code>ntkrnlpa.exe</code></td>
<td>✅ 是</td>
<td>❌ 否</td>
<td>单处理器，<strong>启用 PAE</strong> 的内核</td>
</tr>
<tr>
<td><code>ntkrnlmp.exe</code></td>
<td>❌ 否</td>
<td>✅ 是</td>
<td>多处理器 SMP，<strong>非 PAE</strong> 模式使用</td>
</tr>
<tr>
<td><code>ntkrpamp.exe</code></td>
<td>✅ 是</td>
<td>✅ 是</td>
<td>多处理器 SMP，<strong>启用 PAE</strong> 的完整内核（PAE + MP 全支持）</td>
</tr>
</tbody></table>
<p>我们通过 <code>boot.ini</code> 指定 <code>/PAE</code> 参数，并可通过 <code>/KERNEL=xxx.exe</code> 可以显式指定要加载的内核映像。</p>
<blockquote>
<p><code>boot.ini</code> 是 Windows NT 系列（如 Windows XP、2000、Server 2003）中用于控制启动引导参数的配置文件。它属于 NT Loader（ntldr）引导机制的一部分</p>
</blockquote>
<div class="code-container" data-rel="Ini"><figure class="iseeu highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[boot loader]</span></span><br><span class="line"><span class="attr">timeout</span>=<span class="number">5</span></span><br><span class="line"><span class="attr">default</span>=multi(<span class="number">0</span>)disk(<span class="number">0</span>)rdisk(<span class="number">0</span>)partition(<span class="number">1</span>)\WINDOWS</span><br><span class="line"><span class="section">[operating systems]</span></span><br><span class="line">multi(0)disk(0)rdisk(0)partition(1)\<span class="attr">WINDOWS</span>=<span class="string">&quot;Windows XP (PAE)&quot;</span> /fastdetect /PAE</span><br><span class="line">multi(0)disk(0)rdisk(0)partition(1)\<span class="attr">WINDOWS</span>=<span class="string">&quot;Windows XP (No PAE)&quot;</span> /fastdetect /NOPAE</span><br></pre></td></tr></table></figure></div>

<p> 启动时你将看到两个选项：</p>
<ul>
<li><code>Windows XP (PAE)</code> 会启用 PAE 分页，可能加载 <code>ntkrnlpa.exe</code> &#x2F; <code>ntkrpamp.exe</code></li>
<li><code>Windows XP (No PAE)</code> 会强制关闭 PAE，使用 <code>ntoskrnl.exe</code> &#x2F; <code>ntkrnlmp.exe</code></li>
</ul>
<h3 id="Windows-Vista-7-32-位"><a href="#Windows-Vista-7-32-位" class="headerlink" title="Windows Vista &#x2F; 7 32 位"></a>Windows Vista &#x2F; 7 32 位</h3><p>Windows Vista &#x2F; 7 32 位后不再区分 <code>mp</code> 和 <code>up</code>，统一支持 SMP。<strong>也不再使用 <code>ntkrnlmp.exe</code> 等文件</strong>。并且这个版本之后不再使用 <code>boot.ini</code> 而是使用 <code>bcdedit</code> 修改 PAE 状态。</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>支持 PAE</th>
<th>支持多核 (SMP)</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ntoskrnl.exe</code></td>
<td>❌ 否</td>
<td>✅ 是</td>
<td>默认内核映像，未启用 PAE 时使用</td>
</tr>
<tr>
<td><code>ntkrnlpa.exe</code></td>
<td>✅ 是</td>
<td>✅ 是</td>
<td>启用 PAE 时使用（通过 <code>bcdedit /set pae ForceEnable</code>）</td>
</tr>
</tbody></table>
<p><strong>从 Windows Vista 开始（包括 Windows 7&#x2F;8&#x2F;10&#x2F;11）就已经彻底废除了 <code>boot.ini</code></strong> ，转而使用新的引导配置机制 <strong>BCD（Boot Configuration Data）</strong>。该机制通过 <code>bcdedit</code> 命令进行配置，具体步骤为：</p>
<ol>
<li><p><strong>复制当前默认启动配置</strong></p>
<div class="code-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /<span class="built_in">copy</span> &#123;current&#125; /d &quot;Windows <span class="number">7</span> - No PAE&quot;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>这会复制当前启动项，生成一个新 GUID（比如 <code>&#123;3e9a0...&#125;</code>）。</li>
<li>新启动项会出现在启动菜单中，名字叫 <strong>“Windows 7 - No PAE”</strong>。</li>
</ul>
<p>正常情况下系统返回类似下面这段输出：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The entry was successfully copied to &#123;3e9a0123-xxxx-xxxx&#125;.</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>给这个新启动项设置关闭 PAE 参数</strong></p>
<div class="code-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /<span class="built_in">set</span> &#123;<span class="number">3</span>e9a0123-xxxx-xxxx&#125; pae ForceDisable</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p>再次开机时会看到：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Windows 7</span><br><span class="line">Windows 7 - No PAE</span><br></pre></td></tr></table></figure></div>

<ul>
<li>第一个启用 PAE，可能支持 DEP、安全保护机制；</li>
<li>第二个禁用 PAE，用于兼容旧驱动或调试。</li>
</ul>
<h3 id="Windows-64-位"><a href="#Windows-64-位" class="headerlink" title="Windows 64 位"></a>Windows 64 位</h3><p>Windows 7 &#x2F; 10 &#x2F; 11 等 64 位系统使用长模式分页，<code>ntoskrnl.exe</code> 已合并所有功能模块，不再有 PAE &#x2F; 非 PAE 区分，也不再需要多个版本。</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>支持 PAE</th>
<th>支持多核 (SMP)</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ntoskrnl.exe</code></td>
<td>✅ 是</td>
<td>✅ 是</td>
<td>唯一内核映像，默认启用 PAE + SMP + NX（DEP）等</td>
</tr>
</tbody></table>
<h2 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h2><p><code>CR0</code>～<code>CR4</code> 是 x86 架构中的 <strong>控制寄存器（Control Registers）</strong>，它们是 <strong>CPU 控制系统级特性和行为的关键寄存器</strong>。这些寄存器 <strong>只能在特权级 0（Ring 0）下访问</strong>，用于开启分页、保护模式、中断响应、缓存控制等功能。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/image-20250609044743350.png"
                      alt="image-20250609044743350"
                ></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>状态</th>
<th>主要功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>CR0</code></td>
<td>使用中</td>
<td>启用保护模式、分页机制、缓存控制、对齐检查、写保护等</td>
</tr>
<tr>
<td><code>CR1</code></td>
<td><strong>保留</strong></td>
<td><strong>未使用，Intel 架构中始终保留</strong></td>
</tr>
<tr>
<td><code>CR2</code></td>
<td>使用中</td>
<td>保存最近一次<strong>页错误异常（#PF）</strong>的线性地址</td>
</tr>
<tr>
<td><code>CR3</code></td>
<td>使用中</td>
<td><strong>页目录基地址</strong>（或 PAE 下页目录指针表地址），分页的起点</td>
</tr>
<tr>
<td><code>CR4</code></td>
<td>使用中</td>
<td>启用各种扩展功能，如 PAE、大页、PGE、SMEP、SMAP 等</td>
</tr>
<tr>
<td><code>CR8</code></td>
<td>64 位专用</td>
<td>控制 <strong>中断优先级（Task Priority Level）</strong>，用于高级中断屏蔽</td>
</tr>
</tbody></table>
<h3 id="CR0"><a href="#CR0" class="headerlink" title="CR0"></a>CR0</h3><p>CR0 控制的是处理器的基本操作模式，特别是保护模式、分页机制、缓存和协处理器等。其关键位如下：</p>
<table>
<thead>
<tr>
<th>位号</th>
<th>名称</th>
<th>含义 &amp; 功能</th>
</tr>
</thead>
<tbody><tr>
<td>31</td>
<td><strong>PG</strong></td>
<td>📌 <strong>Paging Enable</strong> ：启用分页机制。需要 <code>PE=1</code>（保护模式）才能生效。</td>
</tr>
<tr>
<td>30</td>
<td><strong>CD</strong></td>
<td>📌 <strong>Cache Disable</strong> ：禁止 CPU 缓存，设为 1 时强制所有访问绕过缓存（需配合 <code>NW=0</code>）。</td>
</tr>
<tr>
<td>29</td>
<td><strong>NW</strong></td>
<td>📌 <strong>Not Write-through</strong> ：当 <code>CD=0</code> 时决定写回&#x2F;直写策略（Write-back&#x2F;Write-through）。</td>
</tr>
<tr>
<td>18</td>
<td><strong>AM</strong></td>
<td><strong>Alignment Mask</strong> ：启用对对齐错误的检测。需 <code>EFLAGS.AC=1</code>、<code>CPL=3</code> 且当前处于保护模式或 V8086 模式。</td>
</tr>
<tr>
<td>16</td>
<td><strong>WP</strong></td>
<td>📌 <strong>Write Protect</strong> ：设置为 1 时，内核模式代码无法写入只读页（即使 <code>U/S=0</code>）。常用于 Copy-On-Write（COW）。</td>
</tr>
<tr>
<td>5</td>
<td><strong>NE</strong></td>
<td><strong>Numeric Error</strong> ：启用内部机制报告 x87 浮点错误；为 0 时使用 PC 式 FERR# 引脚。</td>
</tr>
<tr>
<td>4</td>
<td><strong>ET</strong></td>
<td><strong>Extension Type</strong>（已弃用）：在现代 CPU 中固定为 1。</td>
</tr>
<tr>
<td>3</td>
<td><strong>TS</strong></td>
<td><strong>Task Switched</strong> ：任务切换后由 CPU 设置，用于延迟保存 FPU&#x2F;MMX&#x2F;SSE 状态。与 <code>EM/MP</code> 配合控制 FPU 异常。</td>
</tr>
<tr>
<td>2</td>
<td><strong>EM</strong></td>
<td><strong>Emulation</strong> ：启用浮点指令模拟（禁用 FPU、MMX、SSE 指令，抛出 #NM &#x2F; #UD）。</td>
</tr>
<tr>
<td>1</td>
<td><strong>MP</strong></td>
<td><strong>Monitor Coprocessor</strong> ：配合 <code>TS</code> 控制 <code>WAIT/FWAIT</code> 指令是否触发 #NM。</td>
</tr>
<tr>
<td>0</td>
<td><strong>PE</strong></td>
<td>📌 <strong>Protection Enable</strong> ：启用保护模式。仅此位不足以开启分页，需同时 <code>PG=1</code> 才行。</td>
</tr>
</tbody></table>
<h3 id="CR2"><a href="#CR2" class="headerlink" title="CR2"></a>CR2</h3><table>
<thead>
<tr>
<th>内容</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Page Fault Linear Address</strong></td>
<td>仅当发生页错误（#PF）时，由处理器自动写入导致错误的线性地址。调试和异常处理中使用频繁。</td>
</tr>
</tbody></table>
<h3 id="CR3"><a href="#CR3" class="headerlink" title="CR3"></a>CR3</h3><p>仅在分页启用（<code>CR0.PG=1</code>）时生效，用于指示页目录（或 PDPTE）的物理地址：</p>
<table>
<thead>
<tr>
<th>位号</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>31:12</td>
<td><strong>Page Directory Base</strong></td>
<td>页目录&#x2F;页目录指针表的物理地址高位。必须 4KB 对齐，低 12 位为 0。</td>
</tr>
<tr>
<td>4</td>
<td><strong>PCD</strong></td>
<td>Page-level Cache Disable：控制页表访问的缓存行为。为 1 则关闭缓存。</td>
</tr>
<tr>
<td>3</td>
<td><strong>PWT</strong></td>
<td>Page-level Write-Through：控制页表访问的写策略。</td>
</tr>
<tr>
<td>2:0, 11:5, 63:32</td>
<td>-</td>
<td>保留&#x2F;忽略位，在 PAE 或 IA-32e 模式下含义不同。</td>
</tr>
</tbody></table>
<p>注意：在 PAE&#x2F;64 位模式下，<code>CR3</code> 不直接索引 PDE&#x2F;PTE，而是用于定位 <strong>PDPTE 表</strong>。</p>
<h3 id="CR4"><a href="#CR4" class="headerlink" title="CR4"></a>CR4</h3><p>提供了分页、虚拟化、异常处理、SIMD 等新机制的开关，位数最多，关键位如下：</p>
<table>
<thead>
<tr>
<th>位号</th>
<th>名称</th>
<th>功能简述</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td><strong>VME</strong></td>
<td>Virtual-8086 Mode Extensions（虚拟中断处理）</td>
</tr>
<tr>
<td>1</td>
<td><strong>PVI</strong></td>
<td>Protected-mode Virtual Interrupts，支持虚拟 8086 中断</td>
</tr>
<tr>
<td>2</td>
<td><strong>TSD</strong></td>
<td>限制 <code>RDTSC</code> 指令只能在 CPL&#x3D;0 执行</td>
</tr>
<tr>
<td>3</td>
<td><strong>DE</strong></td>
<td>禁用对 DR4&#x2F;DR5 寄存器的访问（生成 #UD），否则 CPU 会将对 <code>DR4</code> 和 <code>DR5</code> 的访问重定向到 <code>DR6</code> 和 <code>DR7</code>，这是为了兼容旧软件（早期 IA-32 处理器中曾使用 DR4&#x2F;DR5）</td>
</tr>
<tr>
<td>4</td>
<td><strong>PSE</strong></td>
<td>📌 启用 4MB 大页（非 PAE 下）</td>
</tr>
<tr>
<td>5</td>
<td><strong>PAE</strong></td>
<td>📌 启用物理地址扩展（使用 PDPTE 层、36 位物理地址）</td>
</tr>
<tr>
<td>6</td>
<td><strong>MCE</strong></td>
<td>启用机器检查异常（Machine Check Exception）</td>
</tr>
<tr>
<td>7</td>
<td><strong>PGE</strong></td>
<td>📌 启用全局页（带 <code>G</code> 标志的页不因 CR3 更新而清空 TLB）</td>
</tr>
<tr>
<td>8</td>
<td><strong>PCE</strong></td>
<td>用户态也能执行 <code>RDPMC</code> 指令</td>
</tr>
<tr>
<td>9</td>
<td><strong>OSFXSR</strong></td>
<td>OS 支持 <code>FXSAVE/FXRSTOR</code>，支持 SSE&#x2F;SSE2</td>
</tr>
<tr>
<td>10</td>
<td><strong>OSXMMEXCPT</strong></td>
<td>OS 支持 SSE 异常处理（#XM）</td>
</tr>
<tr>
<td>11</td>
<td><strong>UMIP</strong></td>
<td>用户模式禁止访问 <code>SGDT/SIDT/STR/SMSW/SLDT</code></td>
</tr>
<tr>
<td>12</td>
<td><strong>LA57</strong></td>
<td>启用 5 级分页，支持 57 位线性地址</td>
</tr>
<tr>
<td>13</td>
<td><strong>VMXE</strong></td>
<td>启用虚拟化扩展（VMX）</td>
</tr>
<tr>
<td>14</td>
<td><strong>SMXE</strong></td>
<td>启用安全模式扩展（SMX）</td>
</tr>
<tr>
<td>16</td>
<td><strong>FSGSBASE</strong></td>
<td>允许直接读写 <code>FS/GS</code> 基址</td>
</tr>
<tr>
<td>17</td>
<td><strong>PCIDE</strong></td>
<td>启用进程上下文标识（不刷新 TLB 切换上下文）</td>
</tr>
<tr>
<td>18</td>
<td><strong>OSXSAVE</strong></td>
<td>OS 支持 <code>XSAVE/XRSTOR/XGETBV/XSETBV</code></td>
</tr>
<tr>
<td>19</td>
<td><strong>KL</strong></td>
<td>启用 AES Key Locker</td>
</tr>
<tr>
<td>20</td>
<td><strong>SMEP</strong></td>
<td>Supervisor Mode Execution Protection（防止内核执行用户页）</td>
</tr>
<tr>
<td>21</td>
<td><strong>SMAP</strong></td>
<td>Supervisor Mode Access Protection（防止内核访问用户页）</td>
</tr>
<tr>
<td>22</td>
<td><strong>PKE</strong></td>
<td>启用用户页保护键（Protection Key）机制</td>
</tr>
<tr>
<td>23</td>
<td><strong>CET</strong></td>
<td>启用控制流强制（CET）技术</td>
</tr>
<tr>
<td>24</td>
<td><strong>PKS</strong></td>
<td>启用 supervisor 页面的保护键机制</td>
</tr>
</tbody></table>
<h3 id="CR8"><a href="#CR8" class="headerlink" title="CR8"></a>CR8</h3><table>
<thead>
<tr>
<th>位号</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>3:0</td>
<td><strong>TPL</strong></td>
<td>Task Priority Level：中断优先级阈值；<code>0</code> 表示允许所有中断，<code>15</code> 表示屏蔽所有中断。仅在 IA-32e 模式（64 位）使用。</td>
</tr>
</tbody></table>
<h2 id="非-PAE-分页"><a href="#非-PAE-分页" class="headerlink" title="非 PAE 分页"></a>非 PAE 分页</h2><p>在 32 位系统中，如果 <code>CR0.PG = 1</code>（启用分页）且 <code>CR4.PAE = 0</code>（未启用 PAE）则为非 PAE 分页模式，也就是我们常说的 10-10-12 分页模式。</p>
<h3 id="页表结构"><a href="#页表结构" class="headerlink" title="页表结构"></a>页表结构</h3><p><strong>在不考虑大页的情况下</strong>，非 PAE 分页模式的页表结构如下图所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/NO-PAE.svg"
                      alt="NO-PAE"
                ></p>
<p>该模式通过 <strong>2 级页表结构</strong>，将 32 位的线性地址映射到 <strong>最多 4GB 的物理地址空间</strong>。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>层级</th>
<th>数量与结构</th>
<th>每项大小 &#x2F; 总大小</th>
<th>作用说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>页目录表（Page Directory）</strong></td>
<td>一级结构</td>
<td>每进程 1 个，含 1024 个页目录项（PDE）</td>
<td>每项 4 字节，共 4KB</td>
<td>每项控制 <strong>4MB 线性空间</strong>，可指向页表或直接映射一个 4MB 大页（需 <code>CR4.PSE=1</code>）</td>
</tr>
<tr>
<td><strong>页表（Page Table）</strong></td>
<td>二级结构</td>
<td>最多 1024 个，每表含 1024 个页表项（PTE）</td>
<td>每项 4 字节，共 4KB</td>
<td>每项映射一个 <strong>4KB 物理页框</strong>，控制 4KB 线性空间。由 PDE 间接索引获得</td>
</tr>
</tbody></table>
<h4 id="地址转换过程"><a href="#地址转换过程" class="headerlink" title="地址转换过程"></a>地址转换过程</h4><p>非 PAE 分页模式的线性地址到物理地址的转换过程如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/image-20250607022406579.png"
                      alt="image-20250607022406579"
                ></p>
<p><strong>线性地址</strong>由高到低划分为 <strong>10 位 PDE 索引</strong>、<strong>10 位 PTE 索引</strong> 和 <strong>12 位页内偏移</strong>，其中 10，10，12 恰好对应：</p>
<ul>
<li>一个页目录表包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span></span></span></span> 个 PDE。</li>
<li>一个页表包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span></span></span></span> 个 PTE。</li>
<li>一个内存页大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span></span></span></span> 字节。</li>
</ul>
<p>例如假设线性地址为 <code>0x12345678</code>，则具体的转换过程如下：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>PDE Index</td>
<td>0x48</td>
<td>CR3 指向页目录 → 第 0x48 项 PDE</td>
</tr>
<tr>
<td>PTE Index</td>
<td>0xD1</td>
<td>PDE 指向的页表 → 第 0xD1 项 PTE</td>
</tr>
<tr>
<td>Offset</td>
<td>0x678</td>
<td>页内偏移，定位物理页中的位置</td>
</tr>
</tbody></table>
<h4 id="页目录自映射"><a href="#页目录自映射" class="headerlink" title="页目录自映射"></a>页目录自映射</h4><p>另外，为了方便操作系统在内核态访问并维护自身的页表结构，Windows 会设置页目录表中 <strong>第 <code>0x301</code> 项（769 项）</strong> 的 <strong>页目录项 PDE</strong> 指向<strong>页目录表自身的物理地址</strong>，实现所谓的 <strong>页目录自映射</strong>（Page Directory Self-Mapping）机制。这样，整个页目录表和所有页表都可以通过一组固定的线性地址访问。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/NO-PAE-flat.svg"
                      alt="NO-PAE-flat"
                ></p>
<ul>
<li><p><strong>页目录表</strong>的<strong>线性地址</strong>为：<code>0x300 &lt;&lt; (12 + 10) | 0x300 &lt;&lt; 12 = 0xC0300000</code></p>
<ul>
<li><p>第 <code>N</code> 个 PDE 的<strong>线性地址</strong>为：<code>0xC0300000 + (N - 1) * 4</code>（后面加的是第 <code>N</code> 个 PDE 在页目录表中的偏移）</p>
</li>
<li><p>第 0x301 个 PDE 存放着<strong>页目录表的物理地址</strong>，对应<strong>线性地址</strong>为：<code>0xC0300000 + 0x300 * 4 = 0xC0300c00</code></p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>因此我们可以从 <code>0xC0300c00</code> 地址读取到<strong>页目录表的物理地址</strong>。</p>

    </div>
  </div>
</li>
<li><p>线性地址 <code>p</code> 对应的 PDE 的线性地址为：<code>0xC0300000 | ((p &gt;&gt; (12 + 10)) * 4) = 0xC0300000 | p &gt;&gt; 20 &amp; 0xFFC</code></p>
</li>
</ul>
</li>
<li><p><strong>第一个 PDE</strong> 指向的<strong>页表</strong>（如果有）基址对应的<strong>线性地址</strong>为：<code>0x300 &lt;&lt; (12 + 10) = 0xC0000000</code></p>
<ul>
<li><p>第 <code>N</code> 个 PDE 指向的页表（如果有）基址对应的线性地址为：<code>0xC0000000 | (N - 1) &lt;&lt; 12 = 0xC0000000 + (N - 1) * 0x1000</code></p>
</li>
<li><p>第 <code>N</code> 个 PDE 指向的页表的第 <code>M</code> 个 PTE的线性地址为：<code>0xC0000000 | (N - 1) &lt;&lt; 12 | (M - 1) * 4 = 0xC0000000 + (N - 1) * 0x1000 + (M - 1) * 4</code></p>
</li>
<li><p>线性地址 <code>p</code> 对应的 PTE 的线性地址为：<code>0xC0000000 | ((p &gt;&gt; 12) * 4) = 0xC0000000 | p &gt;&gt; 10 &amp; 0x3FFFFC</code></p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>这个公式计算 PTE 的 PTE 时会找到指向 PTE 所在页表的 PDE 的线性地址；同理在计算 PDE 的 PTE 时会找到 <code>PDE[0x300]</code> 的线性地址。</p>

    </div>
  </div></li>
</ul>
</li>
</ul>
<h3 id="页表属性"><a href="#页表属性" class="headerlink" title="页表属性"></a>页表属性</h3><p>在非 PAE 分页模式下，页表相关属性如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/image-20250607042913949.png"
                      alt="image-20250607042913949"
                ></p>
<p><strong>其中 PDE（页目录项）主要有两种类型</strong>，取决于 <strong>PDE 的第 7 位（PS 位）</strong> 的取值，这两种 PDE 的结构稍有不同。</p>
<table>
<thead>
<tr>
<th>页大小</th>
<th>PS 位</th>
<th>解释方式</th>
<th>PDE 指向的对象</th>
<th>后续结构</th>
</tr>
</thead>
<tbody><tr>
<td><strong>4KB</strong> 页</td>
<td>0</td>
<td>二级页表结构</td>
<td>指向一个<strong>页表</strong>（PTE 数组）</td>
<td>需要查找 PTE</td>
</tr>
<tr>
<td><strong>4MB</strong> 页</td>
<td>1</td>
<td>一级页表结构（大页）</td>
<td>直接映射一个<strong>4MB 页框</strong></td>
<td>不查 PTE，直接定位物理页</td>
</tr>
</tbody></table>
<h4 id="CR3-1"><a href="#CR3-1" class="headerlink" title="CR3"></a>CR3</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/CR3.svg"
                      alt="CR3"
                ></p>
<ul>
<li><p><strong>页目录基地址（Address of page directory）</strong> ：<strong>CR3 的 Bits[31:12]</strong> 存储的是页目录的 <strong>物理地址的高 20 位</strong>（即第 12~31 位）。因为页目录必须 4KB 对齐，因此其低 12 位始终为 0，<strong>不会在 CR3 中存储</strong>。另外 <code>Bits[63:32]</code> 仅在 64 位模式下使用，在普通 32 位分页中忽略。</p>
</li>
<li><p><strong>页级写通标志（PWT, Page-level Write Through）</strong> ：位于 CR3 的 <strong>第 3 位</strong>，指定访问页目录时所用内存类型是否为<strong>直写缓存策略</strong>（Write-Through）。仅在启用页表缓存机制时生效，属于 <strong>间接影响</strong>。</p>
<blockquote>
<p><strong>直写缓存策略</strong>（Write-Through）指的是每次 <strong>CPU 写数据到缓存时</strong>，<strong>也会立即写入主内存</strong>，也就是说主内存始终是最新数据。</p>
</blockquote>
</li>
<li><p><strong>页级缓存禁止（PCD, Page-level Cache Disable）</strong> ：位于 CR3 的 <strong>第 4 位</strong>，指定是否对页目录表所在的内存区域禁用缓存。如果设为 1，则 CR3 所指向的整个页目录将不会被缓存，即<strong>CR3 所指向的</strong>页目录表所在内存区域，<strong>不会进入 CPU 的缓存系统</strong>（如 L1&#x2F;L2&#x2F;L3 cache），<strong>每次访问都直接访问内存（DRAM）</strong>。</p>
</li>
</ul>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>在调试的时候，我们可以通过 <code>!process 0 0</code> 来获取<strong>页目录基地址</strong>。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !process 0 0</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">Failed to get VadRoot</span><br><span class="line">PROCESS 8a01dda0  SessionId: 0  Cid: 0498    Peb: 7ffde000  ParentCid: 05f8</span><br><span class="line">    DirBase: a9024000  ObjectTable: e1bf5dc8  HandleCount:  52.</span><br><span class="line">    Image: notepad.exe</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>DirBase</code> 的值 <code>a9024000</code> 就是<strong>页目录基地址</strong>的<strong>物理地址</strong>。</p>

    </div>
  </div>

<h4 id="PDE"><a href="#PDE" class="headerlink" title="PDE"></a>PDE</h4><p>首先对于 4KB 页对应的 PDE，该页目录项的结构如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/PDE-4K.svg"
                      alt="PDE-4K"
                ></p>
<ul>
<li><p><strong>存在位（P, Present）</strong> ：表示该 PDE 是否有效，这里需要设置为 1 表示有效。</p>
<ul>
<li>1：该 PDE 有效，处理器可使用；</li>
<li>0：该 PDE 无效效，访问相关内存地址会触发 <strong>#PF（Page Fault）</strong>。</li>
</ul>
</li>
<li><p><strong>读&#x2F;写标志（R&#x2F;W, Read&#x2F;Write）</strong> ：控制该页是否可写。</p>
<ul>
<li>0：只读；</li>
<li>1：可读可写（实际受 <code>CR0.WP</code> 影响）。</li>
</ul>
</li>
<li><p><strong>用户&#x2F;特权标志（U&#x2F;S, User&#x2F;Supervisor）</strong> ：控制访问权限级别。</p>
<ul>
<li>0：仅 CPL 0~2（内核）可访问；</li>
<li>1：所有特权级（包括用户态）可访问。</li>
</ul>
</li>
<li><p><strong>页级直写缓存策略（PWT, Page-level Write Through）</strong> ：控制缓存策略。</p>
<ul>
<li>1：<strong>Write-Through</strong>（写同时写入主存和缓存）；</li>
<li>0：<strong>Write-Back</strong>（只写缓存，主存延迟刷新）。</li>
</ul>
</li>
<li><p><strong>页级缓存禁止（PCD, Page-level Cache Disable）</strong> ：控制是否禁用该页表所在区域的缓存。</p>
<ul>
<li>1：<strong>禁止缓存</strong>，每次访问都直接访问主内存；</li>
<li>0：允许缓存。</li>
</ul>
</li>
<li><p><strong>访问位（A, Accessed）</strong> ：由处理器在访问该 PDE（即页表）时自动置 1。OS 可用来统计页面活跃度、用于换页算法。</p>
</li>
<li><p><strong>页大小标志（PS, Page Size）</strong> ：指定 PDE 是映射页表还是映射 4MB 大页。</p>
<ul>
<li>0：PDE 指向一个 <strong>页表</strong>（常见）；</li>
<li>1：PDE 直接映射一个 <strong>4MB 大页</strong>（需 <code>CR4.PSE=1</code>）。</li>
</ul>
</li>
<li><p><strong>页表物理基地址（Page Table Base Address）</strong> ：用于指定页表的 <strong>物理地址的高 20 位</strong>，表示该 PDE 所对应页表的实际位置。因为页表是 4KB 对齐，低 12 位为 0，因此未在 PDE 中存储，实际页表地址为 <code>PDE[31:12] &lt;&lt; 12</code>。</p>
</li>
</ul>
<p>而对于 4MB PDE，由于是直接记录物理页的地址，因此比 4KB PTE 多了一些 PTE 相关的属性。另外就是由于从 <code>10-10-12</code> 变成了 <code>10-22</code>，也就是说指向的物理页大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>22</mn></msup></mrow><annotation encoding="application/x-tex">2^{22}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">22</span></span></span></span></span></span></span></span></span></span></span></span> 字节，基址关于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>22</mn></msup></mrow><annotation encoding="application/x-tex">2^{22}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">22</span></span></span></span></span></span></span></span></span></span></span></span> 对齐，因此只需要 <code>32 - 22 = 10</code> 比特来记录物理页的物理地址。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/image-20250607234821590.png"
                      alt="image-20250607234821590"
                ></p>
<p>4MB PDE 的各字段分布如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/PDE-4M.svg"
                      alt="PDE-4M"
                ></p>
<p>相对于 4KB PDE 有变化的属性如下：</p>
<ul>
<li><p><strong>脏位（D, Dirty）</strong> ：当该页<strong>被写入</strong>过时，自动由 CPU 置 <code>1</code>，用于操作系统判断是否需要回写磁盘。</p>
</li>
<li><p><strong>页面大小（PS, Page Size）</strong> ：固定为 <code>1</code>，表示这是一个 4MB 大页项，而非指向页表（4KB 页面）。</p>
</li>
<li><p><strong>全局页（G, Global）</strong> ：为 <code>1</code> 时表示该页为全局页（不因 CR3 切换被 TLB 清除），仅当 <code>CR4.PGE=1</code> 有效。</p>
</li>
<li><p><strong>PAT 位（Page Attribute Table）</strong> ：CPU 用来选择<strong>内存缓存类型</strong>的一个控制位，它和 CR0、CR3 中的 PCD&#x2F;PWT 配合，最终决定某一页（或一块内存）<strong>以什么样的缓存策略访问</strong>。</p>
</li>
<li><p><strong>页框基址（Page Frame Address）</strong> ：存储 4MB 页起始的<strong>物理地址高 10 位</strong>。低 22 位默认为 0（因为对齐到 4MB）。另外如果 <strong>支持 PSE-36 机制</strong> 并且 <strong>处理器支持的最大物理地址宽度为 36</strong>，则页框基址可以存储 14 位，可以映射 64 GB 的物理地址。</p>
</li>
</ul>
<h4 id="PTE"><a href="#PTE" class="headerlink" title="PTE"></a>PTE</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/PTE.svg"
                      alt="PTE"
                ></p>
<p>前面两种 PDT 基本包含了 PTE 的所有属性，PTE 主要变化就是在 4MB PDT 的基础上把 <code>PAT</code> 字段移动到了 <code>PS</code> 字段上（PTE 不需要 <code>PS</code> 字段）。</p>
<h2 id="PAE-分页"><a href="#PAE-分页" class="headerlink" title="PAE 分页"></a>PAE 分页</h2><p>在 32 位处理器中，若设置 <code>CR0.PG = 1</code>（启用分页）<strong>且</strong> <code>CR4.PAE = 1</code>（启用物理地址扩展），则启用 <strong>PAE 分页模式</strong>，也就是我们常说的 2-9-9-12 分页模式。此时每个进程的线性地址空间仍为 4GB，但可访问的<strong>物理地址上限扩展到 64GB（36 位地址）</strong>。</p>
<h3 id="页表结构-1"><a href="#页表结构-1" class="headerlink" title="页表结构"></a>页表结构</h3><p>PAE 模式采用 <strong>3 级页表结构</strong>。<strong>在不考虑大页的情况下</strong>，PAE 分页模式的页表结构如下图所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/PAE.svg"
                      alt="PAE"
                ></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>层级</th>
<th>数量与结构</th>
<th>每项大小 &#x2F; 总大小</th>
<th>作用说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>页目录指针表（PDPT）</strong></td>
<td>顶层结构</td>
<td>每进程 1 个，含 4 项</td>
<td>每项 8 字节，共 32B</td>
<td>每项指向一个页目录，控制 1GB 线性空间</td>
</tr>
<tr>
<td><strong>页目录表（Page Directory）</strong></td>
<td>一级结构</td>
<td>最多 4 个，每表含 512 项 PDE</td>
<td>每项 8 字节，共 4KB</td>
<td>每项指向一个页表，或直接映射 2MB 大页（需 PS&#x3D;1）</td>
</tr>
<tr>
<td><strong>页表（Page Table）</strong></td>
<td>二级结构</td>
<td>最多 512 个，每表含 512 项 PTE</td>
<td>每项 8 字节，共 4KB</td>
<td>每项映射 4KB 物理页，提供最小的线性地址映射单元</td>
</tr>
</tbody></table>
<h4 id="地址转换过程-1"><a href="#地址转换过程-1" class="headerlink" title="地址转换过程"></a>地址转换过程</h4><p>PAE 分页模式的线性地址到物理地址的转换过程如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/image-20250608014033134.png"
                      alt="image-20250608014033134"
                ></p>
<p>PAE 模式下将 32 位线性地址按如下方式拆分，即 <strong>2-9-9-12</strong> 分层结构。</p>
<ul>
<li><code>Bits[31:30]</code>（2 位）：选择 PDPT 中的页目录项（最多 4 项）</li>
<li><code>Bits[29:21]</code>（9 位）：选择页目录中的 PDE（最多 512 项）</li>
<li><code>Bits[20:12]</code>（9 位）：选择页表中的 PTE（最多 512 项）</li>
<li><code>Bits[11:0]</code>（12 位）：页内偏移（4KB）</li>
</ul>
<p>如果是大页模式，则线性地址低 21 比特作为 2MB 大小物理页的页内偏移。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/image-20250608014252251.png"
                      alt="image-20250608014252251"
                ></p>
<h4 id="页目录自映射-1"><a href="#页目录自映射-1" class="headerlink" title="页目录自映射"></a>页目录自映射</h4><p>PAE 分页模式下的<strong>页目录自映射</strong>（Page Directory Self-Mapping）机制也发生变化。由于 PDPTE 代替了 CR3 的功能，因此需要由第 4 个页目录表实现页目录自映射机制。该页目录表的前 4 项分别指向 4 个页目录表，因此在线性地址空间中，4 个页目录表以及对应映射的页表分布如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/PAE-flat.svg"
                      alt="PAE-flat"
                ></p>
<p>根据<strong>页目录自映射</strong>的特性可知，对应一个线性地址 <code>p</code> ：</p>
<ul>
<li>对应的 PTE 的线性地址为：<code>0xC0000000 | ((p &gt;&gt; 12) * 8) = 0xC0000000 | (p &gt;&gt; 9 &amp; 0x7FFFF8)</code>。<ul>
<li><code>(p &gt;&gt; 12) * 8</code> 中右移 12 是在计算页框编号，也就是第几个 PTE；乘 8 是在计算页框号对应的 PTE 的偏移。这种计算方法是从页表分布上推导出来的。</li>
<li><code>(p &gt;&gt; 12) * 8 = p &gt;&gt; 9 &amp; 0x7FFFF8</code>，而右移 9 使得 32 位地址中最高 2 位放在 <code>2-9-9-12</code> 中第一个 “9” 的范围内，从另一个角度印证了只需要第 3 个页目录表的前 4 个 PDE 就可以实现页目录<strong>自映射机制</strong>。</li>
</ul>
</li>
<li>对应的 PDE 的线性地址为：<code>0xC0600000 | ((p &gt;&gt; (12 + 9)) * 8) = 0xC0600000 | p &gt;&gt; 18 &amp; 0x3FF8</code>。</li>
</ul>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <ul>
<li>PAE 分页模式物理地址寻址增大不是因为分页层数增多，而是因为每一个页表项从 4 字节增加到 8 字节，导致物理地址字段长度增大。</li>
<li>新增<strong>页目录指针表（PDPT）</strong>的原因是每一个页表项从 4 字节增加到 8 字节，导致索引范围从 1024（10 bits）减小到 512（9 bits）,空出了 2 bits。</li>
<li><strong>页目录指针表（PDPT）</strong>的作用是代替非 PAE 模式的 CR3，从而避免利用<strong>页目录自映射</strong>（Page Directory Self-Mapping）机制从固定线性地址读取到 CR3 存储的值。</li>
</ul>

    </div>
  </div>

<h3 id="页表属性-1"><a href="#页表属性-1" class="headerlink" title="页表属性"></a>页表属性</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/image-20250608023903628.png"
                      alt="image-20250608023903628"
                ></p>
<h4 id="CR3-2"><a href="#CR3-2" class="headerlink" title="CR3"></a>CR3</h4><p>在开启 PAE 之后，CR3 寄存器的字段发生了一些变化。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/CR3-PAE.svg"
                      alt="CR3-PAE"
                ></p>
<ul>
<li><p><strong>CR3 在 PAE 模式下</strong>，其 Bits[31:5] 存放 PDPTE 表的<strong>物理地址高位</strong>（因 32 字节对齐，所以低 5 位为 0）。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>在调试时我们可以通过 <code>!process 0 0</code> 输出的 <code>DirBase</code> 是关于 0x20 还是 0x1000 对齐快速判断出当前是否是 PAE 分页模式。</p>

    </div>
  </div>
</li>
<li><p>将 CR3 中的 <code>PWT</code> 和 <code>PCD</code> 字段转移到了 PWPTE 中。</p>
</li>
</ul>
<h4 id="PDPTE"><a href="#PDPTE" class="headerlink" title="PDPTE"></a>PDPTE</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/PDPTE.svg"
                      alt="PDPTE"
                ></p>
<p>PDPTE 中主要承担了非 PAE 分页中的 CR3 的功能，唯一的区别就是 PDPTE 比 CR3 多了一个 <code>P</code> 标志位表示该 PDPTE 是否有效。</p>
<p>另外就是由于物理地址增大到 36 bits，因此页目录表地址字段增大到 36 - 12 &#x3D; 24 bits。</p>
<h4 id="PDE-1"><a href="#PDE-1" class="headerlink" title="PDE"></a>PDE</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/PDE-4K-PAE.svg"
                      alt="PDE-4K-PAE"
                ></p>
<p>对于 <code>PS</code> 位为 0 的 PDE，各字段分布基本和非 PAE 分页模式一致，只不过页表地址字段从原来的 20 bits 增加到 24 bits。</p>
<p>另外 PAE 模式的 PDE 新增了一个 <code>XD</code> 字段，即 <strong>Execute Disable</strong>（不可执行页）位。如果启用了 <code>IA32_EFER.NXE</code>（No eXecute Enable），则可以使用该位禁用页的代码执行，用于实现 <strong>DEP（数据执行保护）</strong> 等安全特性。如果 <code>NXE</code> 没启用，该位为 <strong>保留位</strong>（必须为 0）。</p>
<blockquote>
<p><code>IA32_EFER.NXE</code> 是 Intel x86 架构中一个控制位，用于 <strong>开启“不可执行页”功能（Execute Disable，XD）</strong>，位于 <strong><code>IA32_EFER</code>（扩展功能使能寄存器）</strong> 的 <strong>第 11 位</strong>。</p>
<p><strong><code>IA32_EFER</code> 是一个寄存器</strong>，更准确地说，它是一个 <strong>Model-Specific Register（MSR，模型特定寄存器）</strong>。因为这个寄存器是 Intel 专门定义的一类控制寄存器，不像通用寄存器那样在汇编中直接访问。要通过 <code>RDMSR</code> 和 <code>WRMSR</code> 指令来读写。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/PDR-2M-PAE.svg"
                      alt="PDR-2M-PAE"
                ></p>
<p>对于  <code>PS</code> 位为 1 的 PDE，各字段分布基本和非 PAE 分页模式同样基本一致。不同点是由于大页的大小有 4MB 减半到 2MB，因此地址字段的起始位从 22 减小到 21。</p>
<h4 id="PTE-1"><a href="#PTE-1" class="headerlink" title="PTE"></a>PTE</h4><p>PTE 除了内存页物理地址字段长度增加外基本无变化。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/images/PTE-PAE.svg"
                      alt="PTE-PAE"
                ></p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>分页不仅仅是地址映射，它与 CPU 的<strong>缓存体系</strong>（L1&#x2F;L2&#x2F;L3 Cache）与 <strong>TLB（Translation Lookaside Buffer）</strong> 紧密配合，高效完成地址转换与缓存一致性管理。</p>
<pre class="mermaid">flowchart TD
    %% ───── 1. 发起访问 ─────
    subgraph LA["线性地址"]
        A0["发起内存访问<br/>(CPU 指令)"]
    end
    A0 --> B1[TLB 查询]

    %% ───── 2. TLB 分支 ─────
    B1 -->|命中| C0[得到物理页基址<br/>+ 权限/属性<br/>Write/Exec 检查]
    B1 -->|未命中| PWalk["Page Walk<br/>(CR3→PDPTE→PDE→PTE)"]

    %% ---- Page Walk 子流程 ----
    subgraph Page_Table["页表遍历 (硬件完成)"]
        PWalk --> P1[PDPTE<br/>① 定位 1 GB 区域]
        P1 --> P2[PDE<br/>② 定位 2 MB 区域<br/>或继续页表]
        P2 --> P3[PTE<br/>③ 定位 4 KB 页框]
        P3 --> PT_Exit[得到物理页基址]
    end
    PT_Exit --> UpdateTLB["写入/更新 TLB<br/>(缓存映射)"]
    UpdateTLB --> C0

    %% ---- 3. 权限检查 ----
    C0 -->|权限允许| L1[L1 Cache 查询]
    C0 -->|权限不允许| PageFault[#PF → Page-Fault Handler]

    %% ---- 写时复制（COW） ----
    PageFault -->|写时复制触发| DoCOW[COW：分配新页+复制+更新页表]
    %% 触发 invlpg，刷本虚拟页的 TLB 项
    DoCOW -.invLPG(TLB flush).-> L1

    %% 非法访问
    PageFault -->|非法访问等| Kill[进程终止 / 抛异常]

    %% ---- 4. Cache → DRAM ----
    L1 -->|命中| Return[返回数据]
    L1 -->|未命中| L2[L2 Cache 查询]
    L2 -->|命中| Return
    L2 -->|未命中| L3["L3 (LLC) 查询"]
    L3 -->|命中| Return
    L3 -->|未命中| DRAM[主存 DRAM 访问]
    DRAM --> FillCache["加载到 L1<br/>(并按一致性写入 L2/L3)"]
    FillCache --> Return

    %% ---- 样式：仅热点节点上色（不含 DRAM） ----
    classDef hot fill:#d5f5d5,stroke:#2c6a21;
    class C0,L1,L2,L3,FillCache,Return hot;</pre>

<h3 id="CPU-缓存层级结构（L1-L2-L3）"><a href="#CPU-缓存层级结构（L1-L2-L3）" class="headerlink" title="CPU 缓存层级结构（L1 &#x2F; L2 &#x2F; L3）"></a>CPU 缓存层级结构（L1 &#x2F; L2 &#x2F; L3）</h3><p>CPU Cache 是 CPU 内部用于缓存主存（DRAM）数据的硬件单元，用于提升访问频繁数据的速度。主要分为多级：</p>
<table>
<thead>
<tr>
<th>缓存级别</th>
<th>延迟（大致）</th>
<th>每核独立？</th>
<th>存什么？</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>L1 Cache</td>
<td>1~3 cycle</td>
<td>✅ 是</td>
<td>指令 &#x2F; 数据</td>
<td>最快</td>
</tr>
<tr>
<td>L2 Cache</td>
<td>10~20 cycle</td>
<td>✅ 是</td>
<td>L1 的后备</td>
<td>大</td>
</tr>
<tr>
<td>L3 Cache</td>
<td>40~70 cycle</td>
<td>⛔ 否，共享</td>
<td>所有数据（共享页表）</td>
<td>更大更慢</td>
</tr>
</tbody></table>
<p>这些缓存用于存储「最近访问的内存数据」，而数据来自「物理地址」，也就是说 <strong>CPU Cache 缓存的是“物理地址 → 数据”的映射。</strong></p>
<h4 id="缓存类型"><a href="#缓存类型" class="headerlink" title="缓存类型"></a>缓存类型</h4><p>内存的 <strong>缓存类型（Cache Type）</strong> 决定了 CPU 如何对某块物理内存进行缓存操作，包括：是否缓存、以何种策略缓存、如何写入内存等。缓存类型不仅影响性能，还关系到设备访问的一致性和可靠性（例如访问显存、MMIO 寄存器时必须禁止缓存）。</p>
<table>
<thead>
<tr>
<th>PAT 编码</th>
<th>MTRR 编码</th>
<th>名称（缩写）</th>
<th>中文释义</th>
<th>特征说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>00h</code></td>
<td><code>06h</code></td>
<td><strong>Write-Back (WB)</strong></td>
<td>写回缓存</td>
<td><strong>默认策略</strong>。读写均使用缓存（L1&#x2F;L2&#x2F;L3）；<strong>写操作只更新缓存，延迟刷新主存</strong>（由缓存一致性机制控制）。<strong>性能最佳</strong>，支持预取、读写合并、乱序执行等，<strong>适用于普通主存数据访问</strong>。</td>
</tr>
<tr>
<td><code>01h</code></td>
<td><code>04h</code></td>
<td><strong>Write-Through (WT)</strong></td>
<td>直写缓存</td>
<td><strong>写操作同时写入缓存和主存</strong>，保证主存数据始终最新；<strong>读操作仍可命中缓存</strong>。适用于<strong>对主存一致性要求高</strong>的区域，如共享内存。<strong>写性能低于 WB</strong>。</td>
</tr>
<tr>
<td><code>02h</code></td>
<td><code>07h</code></td>
<td><strong>Uncached Minus (UC-)</strong></td>
<td>弱无缓存</td>
<td><strong>Intel 专有类型</strong>。行为类似 UC，但<strong>允许有限度的预取和请求合并</strong>。部分 CPU 可能仍使用缓存机制优化访问。适合<strong>性能敏感但对一致性要求略低</strong>的设备地址映射区域。</td>
</tr>
<tr>
<td><code>03h</code></td>
<td><code>00h</code></td>
<td><strong>Uncacheable (UC)</strong></td>
<td>不可缓存</td>
<td><strong>完全禁用缓存</strong> ：所有访问<strong>直接访问主存</strong>，不使用缓存、不支持预取、合并、乱序。适用于 <strong>MMIO、设备寄存器、显存帧缓冲</strong>等 <strong>对时序要求严格</strong>的场景。</td>
</tr>
<tr>
<td><code>04h</code></td>
<td><code>01h</code></td>
<td><strong>Write-Combining (WC)</strong></td>
<td>写合并</td>
<td><strong>不缓存读操作</strong>，但<strong>写操作可合并多个写入请求后批量写入主存</strong>。适用于<strong>图像缓冲区、视频帧缓冲、DMA 区域等大吞吐场景</strong>。<strong>写性能提升显著</strong>，但不保证一致性。</td>
</tr>
<tr>
<td><code>05h</code></td>
<td><code>05h</code></td>
<td><strong>Write-Protected (WP)</strong></td>
<td>只读缓存</td>
<td><strong>只读可缓存</strong>，但<strong>所有写操作必须访问主存</strong>（写不命中缓存）。适用于<strong>代码段或受保护数据页</strong>，<strong>防止意外修改或提升写安全性</strong>。</td>
</tr>
<tr>
<td><code>07h</code></td>
<td><code>00h</code></td>
<td><strong>UC（冗余编码）</strong></td>
<td>与 UC 等效</td>
<td>与 <code>03h</code> <strong>完全等价</strong>，行为与 UC 一致，出于<strong>兼容性考虑保留</strong>此编码。部分 BIOS&#x2F;固件使用该编码表示 UC。</td>
</tr>
</tbody></table>
<p>我们常见的几种内存的缓存机制如下：</p>
<table>
<thead>
<tr>
<th>区域</th>
<th>推荐类型</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>显卡显存（MMIO）</td>
<td><code>UC</code> &#x2F; <code>WC</code></td>
<td>避免缓存污染 &#x2F; 提高写效率</td>
</tr>
<tr>
<td>页表 &#x2F; CR3</td>
<td><code>WT</code> &#x2F; <code>UC</code></td>
<td>保证一致性</td>
</tr>
<tr>
<td>普通内核代码页</td>
<td><code>WB</code></td>
<td>高效指令读取</td>
</tr>
<tr>
<td>DMA 缓冲区</td>
<td><code>UC</code> &#x2F; <code>WC</code></td>
<td>避免设备与 CPU 缓存不一致</td>
</tr>
<tr>
<td>用户态栈 &#x2F; 堆</td>
<td><code>WB</code></td>
<td>高频读写，性能关键</td>
</tr>
</tbody></table>
<h4 id="缓存类型的配置机制"><a href="#缓存类型的配置机制" class="headerlink" title="缓存类型的配置机制"></a>缓存类型的配置机制</h4><p>缓存类型是 <strong>多个机制共同决定的结果</strong>，包括：</p>
<table>
<thead>
<tr>
<th>来源</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>页表项的 PCD &#x2F; PWT &#x2F; PAT 位</strong></td>
<td>控制页级别的缓存策略</td>
</tr>
<tr>
<td><strong>IA32_PAT 寄存器</strong></td>
<td>定义 PAT 编码与缓存类型的映射</td>
</tr>
<tr>
<td><strong>MTRR（Memory Type Range Register）</strong></td>
<td>控制物理地址范围的默认缓存类型</td>
</tr>
<tr>
<td><strong>固定类型内存（如设备寄存器）</strong></td>
<td>固定为 UC（不可缓存）或 WC（写合并）等类型</td>
</tr>
</tbody></table>
<p>每个页表项（PDE&#x2F;PTE）都有这三位控制缓存：</p>
<table>
<thead>
<tr>
<th>位名</th>
<th>含义</th>
<th>取值 1 的效果</th>
</tr>
</thead>
<tbody><tr>
<td><code>PWT</code></td>
<td>Page-level Write-Through</td>
<td>采用 Write-Through 策略</td>
</tr>
<tr>
<td><code>PCD</code></td>
<td>Page-level Cache Disable</td>
<td>禁用缓存（Uncached）</td>
</tr>
<tr>
<td><code>PAT</code></td>
<td>Page Attribute Table</td>
<td>用于选择 PAT 中的映射项（解释见下）</td>
</tr>
</tbody></table>
<p>这三位组成一个 <strong>3 位索引（b2b1b0 &#x3D; PAT,PWT,PCD）</strong>，共可表示 <strong>8 种编码（0~7）</strong>，再由 <strong><code>IA32_PAT</code></strong> 映射到缓存类型。</p>
<table>
<thead>
<tr>
<th>编号（索引）</th>
<th>对应组合（PAT:PWT:PCD）</th>
<th>默认缓存类型（如 IA32 手册）</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0:0:0</td>
<td>Write-Back (WB)</td>
</tr>
<tr>
<td>1</td>
<td>0:0:1</td>
<td>Write-Through (WT)</td>
</tr>
<tr>
<td>2</td>
<td>0:1:0</td>
<td>Uncached Minus (UC-)</td>
</tr>
<tr>
<td>3</td>
<td>0:1:1</td>
<td>Uncached (UC)</td>
</tr>
<tr>
<td>4</td>
<td>1:0:0</td>
<td>Write-Combining (WC)</td>
</tr>
<tr>
<td>5</td>
<td>1:0:1</td>
<td>Write-Protected (WP)</td>
</tr>
<tr>
<td>6</td>
<td>1:1:0</td>
<td>保留</td>
</tr>
<tr>
<td>7</td>
<td>1:1:1</td>
<td>UC（冗余）</td>
</tr>
</tbody></table>
<p>最终使用哪种类型由 CPU 按一定优先级解析这些机制的组合。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 固定类型区域（如 ROM/显存）？</span><br><span class="line">   是 → 使用平台指定类型（如 UC）</span><br><span class="line"></span><br><span class="line">2. 页表项中 PCD/PWT/PAT 存在？</span><br><span class="line">   是 → 用它们组成 PAT 索引 → 查询 IA32_PAT → 得到类型</span><br><span class="line"></span><br><span class="line">3. MTRR 中匹配该物理地址？</span><br><span class="line">   是 → 使用 MTRR 设置的缓存类型</span><br><span class="line"></span><br><span class="line">4. 否则 → 使用默认缓存策略（通常是 WB）</span><br></pre></td></tr></table></figure></div>

<h3 id="TLB（Translation-Lookaside-Buffer）"><a href="#TLB（Translation-Lookaside-Buffer）" class="headerlink" title="TLB（Translation Lookaside Buffer）"></a>TLB（Translation Lookaside Buffer）</h3><p><strong>TLB 是一种「地址映射的缓存」</strong>，专门缓存页表翻译（虚拟 → 物理）。</p>
<h4 id="TLB-属性"><a href="#TLB-属性" class="headerlink" title="TLB 属性"></a>TLB 属性</h4><p>通常 TLB 中的每一项包含如下属性：</p>
<ul>
<li><code>LA</code>：线性地址（Linear Address）</li>
<li><code>PA</code>：物理地址（Physical Address）</li>
<li><code>ATTR</code>：权限与属性字段（如 R&#x2F;W, U&#x2F;S, PWT, PCD, PAT 等）<ul>
<li>非 PAE（<code>10-10-12</code>）下：<code>ATTR = PDE 属性 &amp; PTE 属性</code></li>
<li>PAE（或 4级页表，如 <code>9-9-9-12</code>）下：<code>ATTR = PDPTE 属性 &amp; PDE 属性 &amp; PTE 属性</code></li>
</ul>
</li>
<li><code>LRU</code>：最近最少使用（Least Recently Used）统计信息，TLB替换策略之一</li>
</ul>
<p><strong>这些都是标准硬件 TLB 中会缓存的内容</strong>，尤其现代 CPU 会把 PTE&#x2F;PDE&#x2F;PDPTE 的<strong>属性字段</strong>也缓存进去，加快访问判断速度，避免再次查页表。</p>
<p>当 TLB 未命中时 → 需要查完整页表 → 增加延迟 → 加载结果再写入 TLB。</p>
<h4 id="TLB-类型"><a href="#TLB-类型" class="headerlink" title="TLB 类型"></a>TLB 类型</h4><p>在典型的 x86 CPU（从 Intel 486 起）中，为了提高虚拟地址到物理地址转换的效率，CPU 内部通常设置多组 TLB 缓存，按用途和页大小分为：</p>
<ul>
<li><strong>Instruction TLB for 4KB pages</strong> ：用于缓存指令取值所需的 4KB 页映射；</li>
<li><strong>Data TLB for 4KB pages</strong> ：用于缓存数据访问所需的 4KB 页映射；</li>
<li><strong>Instruction TLB for large pages (2MB&#x2F;4MB)</strong> ：用于缓存代码段中的大页映射；</li>
<li><strong>Data TLB for large pages (2MB&#x2F;4MB)</strong> ：用于缓存数据段中的大页映射；</li>
</ul>
<p>在现代 CPU 架构中，上述 TLB 有可能是多级的（L1&#x2F;L2），并支持更多页大小（如 1GB），具体组织方式视 CPU 实现而定。</p>
<h4 id="TLB-控制位"><a href="#TLB-控制位" class="headerlink" title="TLB 控制位"></a>TLB 控制位</h4><table>
<thead>
<tr>
<th>标志位</th>
<th>寄存器</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CR4.PGE</strong></td>
<td>CR4[7]</td>
<td>开启全局页（Global Page）支持；全局页不因 CR3 切换被刷新</td>
</tr>
<tr>
<td><strong>PDE&#x2F;PTE.G</strong></td>
<td>页表项 bit 8</td>
<td>与 CR4.PGE 配合，标记页项为全局页，避免频繁清除</td>
</tr>
<tr>
<td><strong>CR4.PCIDE</strong></td>
<td>CR4[17]</td>
<td>启用 PCID 支持，配合 CR3 实现不清 TLB 的上下文切换</td>
</tr>
</tbody></table>
<h4 id="TLB-刷新方式"><a href="#TLB-刷新方式" class="headerlink" title="TLB 刷新方式"></a>TLB 刷新方式</h4><p>TLB（Translation Lookaside Buffer）是一个 <strong>缓存虚拟地址到物理地址映射</strong> 的结构（即<strong>页表的副本</strong>）。当页表发生变更后，<strong>TLB 中的内容可能过时</strong>，这时候就必须刷新 TLB，防止地址转换错误。</p>
<p>常见的 TLB 刷新方式如下：</p>
<ul>
<li><p><strong>写入 <code>CR3</code>（页目录基地址）寄存器</strong> 是最常见的刷新方式，不论 CR3 的值是否真的改变，CR3 寄存器写入都会导致 TLB 被清空（传统 x86）。不过这种方式<strong>性能损耗较大</strong>，因为所有地址映射都要重新查页表。<strong>如果禁用 <code>CR4.PGE</code>，G 页也会被清除。</strong></p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="built_in">cr3</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cr3</span>, <span class="built_in">eax</span>     <span class="comment">; 触发完整 TLB flush</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>局部刷新（invlpg 指令）</strong>只刷新一个页（以页为单位），但是可以<strong>无视 <code>G</code> 标志位强制刷新</strong>。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">invlpg</span> [<span class="number">0x8048000</span>] <span class="comment">; 使虚拟地址 0x8048000 的 TLB 项失效</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>
		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> windows 保护模式</li>
        <li><strong>Author:</strong> sky123</li>
        <li><strong>Created at
                :</strong> 2022-09-28 11:45:14</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2025-07-01 10:19:52
            </li>
        
        <li>
            <strong>Link:</strong> https://skyi23.github.io/2022/09/28/windows 保护模式/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/windows-kernel-reverse/">#windows kernel reverse</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2022/09/28/windows%20%E7%94%A8%E6%88%B7%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">windows 用户态逆向开发</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2022/09/28/windows%20%E5%8F%A5%E6%9F%84%E8%A1%A8/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">windows 句柄表</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'skyI23/my-giscus-discussions',
                'data-repo-id': 'R_kgDONL9k_w',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDONL9k_84CkEdK',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">windows 保护模式</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#CPU-%E7%9A%84%E6%A8%A1%E5%BC%8F"><span class="nav-text">CPU 的模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E6%A8%A1%E5%BC%8F%EF%BC%88Real-Mode%EF%BC%89"><span class="nav-text">实模式（Real Mode）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%EF%BC%88Protected-Mode%EF%BC%89"><span class="nav-text">保护模式（Protected Mode）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F8086%E6%A8%A1%E5%BC%8F%EF%BC%88Virtual-8086-Mode%EF%BC%89"><span class="nav-text">虚拟8086模式（Virtual 8086 Mode）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%9C%B0%E5%9D%80"><span class="nav-text">保护模式下的地址</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%EF%BC%88Logical-Address%EF%BC%89"><span class="nav-text">逻辑地址（Logical Address）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%EF%BC%88Virtual-Address%EF%BC%89"><span class="nav-text">虚拟地址（Virtual Address）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%88Physical-Address%EF%BC%89"><span class="nav-text">物理地址（Physical Address）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AE%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">段式内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88Segment-Registers%EF%BC%89"><span class="nav-text">段寄存器（Segment Registers）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">主要段寄存器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84"><span class="nav-text">段寄存器结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%BB%E5%86%99"><span class="nav-text">段寄存器读写</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">数据段寄存器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">代码段寄存器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%EF%BC%88Descriptor-Table%EF%BC%89"><span class="nav-text">段描述符表（Descriptor Table）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%E7%A7%8D%E7%B1%BB"><span class="nav-text">段描述符表种类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%EF%BC%88GDT-Global-Descriptor-Table%EF%BC%89"><span class="nav-text">全局描述符表（GDT, Global Descriptor Table）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%EF%BC%88LDT-Local-Descriptor-Table%EF%BC%89"><span class="nav-text">局部描述符表（LDT, Local Descriptor Table）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%88Segment-Descriptor%EF%BC%89"><span class="nav-text">段描述符（Segment Descriptor）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AE%B5%E6%9D%83%E9%99%90%E6%A3%80%E6%B5%8B"><span class="nav-text">段权限检测</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E7%B1%BB%E5%9E%8B"><span class="nav-text">权限类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E8%A7%84%E5%88%99"><span class="nav-text">权限规则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E6%A3%80%E6%B5%8B%E8%A7%84%E5%88%99"><span class="nav-text">权限检测规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E4%BF%AE%E6%94%B9%E8%A7%84%E5%88%99"><span class="nav-text">权限修改规则</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E9%97%A8"><span class="nav-text">调用门</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-text">门描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="nav-text">过程分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B"><span class="nav-text">调用过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E8%BF%87%E7%A8%8B"><span class="nav-text">返回过程</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD"><span class="nav-text">中断</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E6%96%AD"><span class="nav-text">什么是中断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%EF%BC%88IDT-Interrupt-Descriptor-Table%EF%BC%89"><span class="nav-text">中断描述符表（IDT,Interrupt Descriptor Table）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E9%97%A8"><span class="nav-text">中断门</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6-1"><span class="nav-text">门描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90-1"><span class="nav-text">过程分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B-1"><span class="nav-text">调用过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E8%BF%87%E7%A8%8B-1"><span class="nav-text">返回过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%B7%E9%98%B1%E9%97%A8"><span class="nav-text">陷阱门</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6-2"><span class="nav-text">门描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90-2"><span class="nav-text">过程分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E9%97%A8"><span class="nav-text">任务门</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%88TSS-Descriptor%EF%BC%89"><span class="nav-text">任务段描述符（TSS Descriptor）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88TR%EF%BC%8CTask-Register%EF%BC%89"><span class="nav-text">任务寄存器（TR，Task Register）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E6%AE%B5%EF%BC%88TSS%EF%BC%8CTask-State-Segment%EF%BC%89"><span class="nav-text">任务段（TSS，Task State Segment）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E9%97%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%88Task-Gate-Descriptor%EF%BC%89"><span class="nav-text">任务门描述符（Task Gate Descriptor）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%EF%BC%88%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E6%9C%BA%E5%88%B6%EF%BC%89"><span class="nav-text">调用过程（任务切换机制）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B"><span class="nav-text">任务段描述符调用过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E9%97%A8%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B"><span class="nav-text">任务门调用过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E8%BF%87%E7%A8%8B-2"><span class="nav-text">返回过程</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A1%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">页式内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="nav-text">环境配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Windows-XP-32-%E4%BD%8D"><span class="nav-text">Windows XP 32 位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Windows-Vista-7-32-%E4%BD%8D"><span class="nav-text">Windows Vista &#x2F; 7 32 位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Windows-64-%E4%BD%8D"><span class="nav-text">Windows 64 位</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">控制寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CR0"><span class="nav-text">CR0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CR2"><span class="nav-text">CR2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CR3"><span class="nav-text">CR3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CR4"><span class="nav-text">CR4</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CR8"><span class="nav-text">CR8</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E-PAE-%E5%88%86%E9%A1%B5"><span class="nav-text">非 PAE 分页</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="nav-text">页表结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="nav-text">地址转换过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E7%9B%AE%E5%BD%95%E8%87%AA%E6%98%A0%E5%B0%84"><span class="nav-text">页目录自映射</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8%E5%B1%9E%E6%80%A7"><span class="nav-text">页表属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CR3-1"><span class="nav-text">CR3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PDE"><span class="nav-text">PDE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PTE"><span class="nav-text">PTE</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PAE-%E5%88%86%E9%A1%B5"><span class="nav-text">PAE 分页</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84-1"><span class="nav-text">页表结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B-1"><span class="nav-text">地址转换过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E7%9B%AE%E5%BD%95%E8%87%AA%E6%98%A0%E5%B0%84-1"><span class="nav-text">页目录自映射</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8%E5%B1%9E%E6%80%A7-1"><span class="nav-text">页表属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CR3-2"><span class="nav-text">CR3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PDPTE"><span class="nav-text">PDPTE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PDE-1"><span class="nav-text">PDE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PTE-1"><span class="nav-text">PTE</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98"><span class="nav-text">缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU-%E7%BC%93%E5%AD%98%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84%EF%BC%88L1-L2-L3%EF%BC%89"><span class="nav-text">CPU 缓存层级结构（L1 &#x2F; L2 &#x2F; L3）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%B1%BB%E5%9E%8B"><span class="nav-text">缓存类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%85%8D%E7%BD%AE%E6%9C%BA%E5%88%B6"><span class="nav-text">缓存类型的配置机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TLB%EF%BC%88Translation-Lookaside-Buffer%EF%BC%89"><span class="nav-text">TLB（Translation Lookaside Buffer）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TLB-%E5%B1%9E%E6%80%A7"><span class="nav-text">TLB 属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TLB-%E7%B1%BB%E5%9E%8B"><span class="nav-text">TLB 类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TLB-%E6%8E%A7%E5%88%B6%E4%BD%8D"><span class="nav-text">TLB 控制位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TLB-%E5%88%B7%E6%96%B0%E6%96%B9%E5%BC%8F"><span class="nav-text">TLB 刷新方式</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text"></span></a></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2024</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">sky123</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        41 posts in total
                    </span>
                    
                        <span>
                            691.8k words in total
                        </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.5</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>



<script src="/js/build/libs/Swup.min.js"></script>

<script src="/js/build/libs/SwupSlideTheme.min.js"></script>

<script src="/js/build/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/build/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/build/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/build/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	
<script src="/js/build/tools/imageViewer.js" type="module"></script>

<script src="/js/build/utils.js" type="module"></script>

<script src="/js/build/main.js" type="module"></script>

<script src="/js/build/layouts/navbarShrink.js" type="module"></script>

<script src="/js/build/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/build/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/build/layouts/categoryList.js" type="module"></script>



    
<script src="/js/build/tools/localSearch.js" type="module"></script>




    
<script src="/js/build/tools/codeBlock.js" type="module"></script>




    
<script src="/js/build/layouts/lazyload.js" type="module"></script>




    
<script src="/js/build/tools/runtime.js"></script>

    
<script src="/js/build/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/build/libs/Typed.min.js"></script>

  
<script src="/js/build/plugins/typed.js" type="module"></script>




    
        
<script src="/js/build/libs/mermaid.min.js"></script>

    
    
<script src="/js/build/plugins/mermaid.js"></script>






    
<script src="/js/build/libs/anime.min.js"></script>





    
<script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script>





    
<script src="/js/build/layouts/bookmarkNav.js" type="module"></script>


	
</body>

</html>