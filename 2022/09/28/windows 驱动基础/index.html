<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="sky123">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://skyi23.github.io/2022/09/28/windows 驱动基础/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/null" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/null">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/null">
    <!--- Page Info-->
    
    <title>
        
            windows 驱动基础 | sky123&#39;s site
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/css/build/tailwind.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" rel="stylesheet">
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"skyi23.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":true,"family":"JetBrains Mono","url":"https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap"}},"toc":{"enable":true,"max_depth":5,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"open_graph":{"enable":false,"image":"/images/redefine-og.webp","description":"Hexo Theme Redefine, Redefine Your Hexo Journey."},"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"sky123's blog","subtitle":{"text":["书有未曾经我读，事无不可对人言"],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":true,"version":"11.4.1"}},"version":"2.8.2","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"分类":{"icon":"fa-solid fa-folder","path":"/categories/"},"标签":{"icon":"fa-solid fa-tags","path":"/tags/"},"书签":{"icon":"fa-solid fa-bookmark","path":"/bookmarks/"}},"search":{"enable":true,"preload":true}},"page_templates":{"bookmarks_column":3,"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2024/11/7 00:00:00"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha256-TThEtR+XalhWKkfF383YLOrI50NGNeIqrzS+q08afrY=" crossorigin="anonymous"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>



<body>
	<div class="progress-bar-container">
	
	<span class="scroll-progress-bar"></span>
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                sky123&#39;s site
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/categories/"
                                        >
                                    <i class="fa-solid fa-folder fa-fw"></i>
                                    分类
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/tags/"
                                        >
                                    <i class="fa-solid fa-tags fa-fw"></i>
                                    标签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/bookmarks/"
                                        >
                                    <i class="fa-solid fa-bookmark fa-fw"></i>
                                    书签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/categories/"
                        >
                            <span>
                                分类
                            </span>
                            
                                <i class="fa-solid fa-folder fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/tags/"
                        >
                            <span>
                                标签
                            </span>
                            
                                <i class="fa-solid fa-tags fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/bookmarks/"
                        >
                            <span>
                                书签
                            </span>
                            
                                <i class="fa-solid fa-bookmark fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">11</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">14</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">37</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">windows 驱动基础</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/icon.jpg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">sky123</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2022-09-28 11:45:14</span>
        <span class="mobile">2022-09-28 11:45:14</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-06-26 10:13:10</span>
            <span class="mobile">2025-06-26 10:13:10</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/reverse/">reverse</a>&nbsp;
                        </li>
                    
                    
                
                    
                        
                            <li>></li>
                        
                        <li>
                            <a href="/categories/reverse/windows-kernel/">windows kernel</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/windows-kernel-reverse/">windows kernel reverse</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>21.4k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>87 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<h1 id="Windows-基础"><a href="#Windows-基础" class="headerlink" title="Windows 基础"></a>Windows 基础</h1><h2 id="内核对象"><a href="#内核对象" class="headerlink" title="内核对象"></a>内核对象</h2><p><strong>内核对象（Kernel Object）</strong>，是 Windows 内核里对各种内核资源进行统一管理、统一命名、统一访问控制、统一生命周期控制的一种抽象机制。</p>
<h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p>在没有内核对象之前，Windows 内核里存在着大量不同类型的资源（如设备，文件，进程线程等），这些资源每种结构体都不一样，但是每种都要支持用户态访问（有名字，有权限控制，有引用计数，有安全策略）。</p>
<p>因此 Windows 采用了一种类似 Linux 的 “万物皆文件” 的设计思想，即将每个需要统一管理的内核资源都被包装成一个 <strong>“内核对象”</strong>，交由 <strong>Object Manager（对象管理器）</strong> 组件管理。这样可以统一的解决下面几个问题：</p>
<table>
<thead>
<tr>
<th>典型问题</th>
<th>Object Manager 提供的统一解法</th>
</tr>
</thead>
<tbody><tr>
<td>内核里有驱动、设备、进程、互斥量、事件、共享内存等几十种资源，<em>各自</em>要命名、要 ACL、要引用计数、要调试符号。</td>
<td>定义 <strong>OBJECT_HEADER + OBJECT_BODY</strong> 模型；创建&#x2F;打开&#x2F;引用&#x2F;关闭&#x2F;删除流程全部交给 <strong>Object Manager</strong>（Ob）。</td>
</tr>
<tr>
<td>资源的生命周期复杂：谁来保证用完才释放？</td>
<td><code>PointerCount</code>（内核指针引用） + <code>HandleCount</code>（用户&#x2F;内核句柄数量）双计数模型，当二者皆为 0 时由 Ob 自动回收。</td>
</tr>
<tr>
<td>用户进程需要安全地访问部分内核资源</td>
<td>把 <strong>SECURITY_DESCRIPTOR</strong> 嵌进对象；用户通过系统调用走 <strong>SeAccessCheck</strong>。</td>
</tr>
<tr>
<td>调试&#x2F;监控工具需要统一查看</td>
<td>所有命名对象都挂进 <strong>对象目录树</strong>（Directory Object）；Windbg &#x2F; ETW &#x2F; AV 可以枚举。</td>
</tr>
</tbody></table>
<h3 id="内核对象结构"><a href="#内核对象结构" class="headerlink" title="内核对象结构"></a>内核对象结构</h3><p>每个内核对象在被 Object Manager 在分配时，自动套上了一个统一的“对象头部”+（可能存在的附加信息头）+ 对象体数据。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|---------------------------|</span><br><span class="line">| POOL_HEADER               |  内存池头部</span><br><span class="line">|---------------------------|</span><br><span class="line">| OBJECT_HEADER_NAME_INFO   |  名字信息 (可选)</span><br><span class="line">|---------------------------|</span><br><span class="line">| OBJECT_HEADER_HANDLE_INFO |  句柄信息 (可选)</span><br><span class="line">|---------------------------|</span><br><span class="line">| OBJECT_HEADER_QUOTA_INFO  |  配额信息 (可选)</span><br><span class="line">|---------------------------|</span><br><span class="line">| OBJECT_HEADER             |  内核对象统一头部 (必定存在)</span><br><span class="line">|---------------------------|</span><br><span class="line">| OBJECT_BODY               |  对象体结构 (如 DRIVER_OBJECT)</span><br><span class="line">|---------------------------|</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>OBJECT_HEADER</code> 在内核对象中一定存在，该结构体在不同版本的 Windows 中会发生变化，下面是一些常见字段：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>PointerCount</code> (LONG)</td>
<td>内核所有“裸指针”引用计数</td>
</tr>
<tr>
<td><code>HandleCount</code> (LONG)</td>
<td>所有进程句柄数量</td>
</tr>
<tr>
<td><code>Type</code> (POBJECT_TYPE)</td>
<td>指向 <code>DRIVER_OBJECT_TYPE</code> &#x2F; <code>DEVICE_OBJECT_TYPE</code>…</td>
</tr>
<tr>
<td><code>Flags</code></td>
<td><code>OB_FLAG_PERMANENT</code> &#x2F; <code>EXCLUSIVE</code> &#x2F; <code>KERNEL_MODE</code> 等</td>
</tr>
<tr>
<td><code>InfoMask</code></td>
<td>标记是否有 Name&#x2F;Handle&#x2F;Quota 这三种可选头</td>
</tr>
</tbody></table>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p><strong>Win11 以后 PatchGuard</strong> 会随机调整可选头偏移，驱动代码必须使用官方宏（<code>OBJECT_HEADER_NAME_INFO_OFFSET</code> 等）而非写死偏移。</p>

    </div>
  </div>

<h3 id="Object-Manager-命名空间"><a href="#Object-Manager-命名空间" class="headerlink" title="Object Manager 命名空间"></a>Object Manager 命名空间</h3><p><strong>Object Manager 命名空间</strong> 是 Windows 内核中统一管理一切内核对象的“对象目录树”。</p>
<ul>
<li>它的本质是一个内核内存中的<strong>目录树结构</strong>；</li>
<li>每个可以被命名的内核对象都被挂载在这棵树上；</li>
<li>Object Manager 负责解析路径、查找对象、引用计数、权限控制等一切逻辑。</li>
</ul>
<p>整个 Object Manager 命名空间以 <strong><code>\</code></strong> 为根目录，形成一棵类似文件系统的目录树。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">\                                （根目录，DirectoryObject）</span><br><span class="line">├── Driver                       所有驱动对象 (DriverObject)</span><br><span class="line">│     └── MyDriver</span><br><span class="line">│</span><br><span class="line">├── Device                       所有设备对象 (DeviceObject)</span><br><span class="line">│     └── Harddisk0</span><br><span class="line">│     └── Serial0</span><br><span class="line">│</span><br><span class="line">├── ??                           ★ 符号链接桥梁目录 (SymbolicLinkObject)</span><br><span class="line">│     ├── C:         → \Device\HarddiskVolume1</span><br><span class="line">│     ├── COM1       → \Device\Serial0</span><br><span class="line">│     └── MyLink     → \Device\MyDevice</span><br><span class="line">│</span><br><span class="line">├── BaseNamedObjects             ★ 用户会话 0 命名空间（全局同步对象）</span><br><span class="line">│     └── MyEvent</span><br><span class="line">│     └── MyMutex</span><br><span class="line">│</span><br><span class="line">├── Sessions                     ★ 多用户会话隔离目录</span><br><span class="line">│     └── 1</span><br><span class="line">│         └── BaseNamedObjects   （Session 1 的私有命名空间）</span><br><span class="line">│</span><br><span class="line">├── ObjectTypes                  ★ 已注册的内核对象类型列表</span><br><span class="line">├── Windows (部分版本存在)</span><br><span class="line">└── 其它系统内部目录</span><br></pre></td></tr></table></figure></div>

<p>其中每一类目录的具体作用如下：</p>
<table>
<thead>
<tr>
<th>目录名</th>
<th>作用</th>
<th>常见对象类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>\Driver</code></td>
<td>存放所有已注册的内核驱动对象</td>
<td><code>DriverObject</code></td>
</tr>
<tr>
<td><code>\Device</code></td>
<td>存放所有设备对象，供 I&#x2F;O 管理器使用</td>
<td><code>DeviceObject</code></td>
</tr>
<tr>
<td><code>\??</code></td>
<td>符号链接目录：Win32 路径与内核对象桥接</td>
<td><code>SymbolicLinkObject</code></td>
</tr>
<tr>
<td><code>\BaseNamedObjects</code></td>
<td>全局同步对象命名区（Session 0 共享）</td>
<td><code>Event</code> &#x2F; <code>Mutex</code> &#x2F; <code>Semaphore</code></td>
</tr>
<tr>
<td><code>\Sessions\N\BaseNamedObjects</code></td>
<td>多用户会话隔离命名空间</td>
<td>各自的同步对象</td>
</tr>
<tr>
<td><code>\ObjectTypes</code></td>
<td>存放系统内置的对象类型定义表</td>
<td><code>ObjectTypeObject</code></td>
</tr>
</tbody></table>
<p>其中 <code>\??</code> 目录（全名为 <code>DosDevices Directory</code>）是 Object Manager 里专门用来桥接 <strong>Win32 路径系统 ↔ 内核命名空间</strong> 的目录。它里面挂载的都是 <strong>符号链接对象（SymbolicLinkObject）</strong>，用于：</p>
<ul>
<li>盘符映射 (<code>C:</code> → <code>\Device\HarddiskVolumeX</code>)</li>
<li>传统设备名 (<code>COM1</code> → <code>\Device\Serial0</code>)</li>
<li>自定义设备别名（通过 <code>IoCreateSymbolicLink()</code> 创建）</li>
</ul>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>所以你看到的 <code>\\.\COM1</code>，Win32 实际内部转为 <code>\??\COM1</code>，由 Object Manager 查找对应符号链接完成跳转。</p>
<p><strong>只要某路径存在于 <code>\??\</code> 下，并且链接指向有效内核对象，用户态理论上就能访问。（不考虑权限问题）</strong></p>
<p><strong>如果路径不经过 <code>\??\</code>（例如裸的 <code>\Device\xxx</code>、<code>\Driver\xxx</code>、<code>\BaseNamedObjects\xxx</code>），则 3环无法直接访问。</strong></p>

    </div>
  </div>

<h3 id="常用-API"><a href="#常用-API" class="headerlink" title="常用 API"></a>常用 API</h3><ul>
<li><p><code>ObReferenceObjectByName</code> 函数可以用路径字符串找到任何已存在内核对象，并返回其内核对象指针。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">ObReferenceObjectByName</span><span class="params">(</span></span><br><span class="line"><span class="params">  IN PUNICODE_STRING ObjectName,   <span class="comment">// [输入] 要查找的对象完整路径名 (例如: &quot;\\Driver\\MyDriver&quot;)</span></span></span><br><span class="line"><span class="params">  IN ULONG Attributes,             <span class="comment">// [输入] 属性标志，常用 OBJ_CASE_INSENSITIVE (忽略大小写匹配)</span></span></span><br><span class="line"><span class="params">  IN PACCESS_STATE AccessState OPTIONAL, <span class="comment">// [输入] 安全访问状态，普通内核使用时传 NULL</span></span></span><br><span class="line"><span class="params">  IN ACCESS_MASK DesiredAccess,    <span class="comment">// [输入] 请求的访问权限，一般填 0 表示默认即可</span></span></span><br><span class="line"><span class="params">  IN POBJECT_TYPE ObjectType,      <span class="comment">// [输入] 对象类型指针，例如 *IoDriverObjectType、*IoDeviceObjectType 等</span></span></span><br><span class="line"><span class="params">  IN KPROCESSOR_MODE AccessMode,   <span class="comment">// [输入] 访问模式，一般传 KernelMode</span></span></span><br><span class="line"><span class="params">  IN PVOID ParseContext OPTIONAL,  <span class="comment">// [输入] 解析上下文 (高阶场景使用)，通常传 NULL</span></span></span><br><span class="line"><span class="params">  OUT PVOID *Object                <span class="comment">// [输出] 成功时返回获取到的对象指针 (注意：需 ObDereferenceObject 释放引用计数)</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><h3 id="四类常见路径"><a href="#四类常见路径" class="headerlink" title="四类常见路径"></a>四类常见路径</h3><p>Windows 系统有四种路径：</p>
<ul>
<li><p><strong>Win32 路径（DOS 路径）</strong> ：用户程序使用的路径，例如：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\System32\drivers\Test.sys</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>仅存在于 Win32 API 层；内核本身不识别盘符。</p>
</li>
<li><p>首次进入内核时经 <code>RtlDosPathNameToNtPathName</code> 转成 <code>\??\C:\...</code>。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p><code>\??</code> 是 Object Manager 命名空间下的一个目录，里面存放大量符号链接（充当快捷方式），这些符号链接用于将盘符、传统设备名等映射到内核对象的真实路径。当 Win32 子系统将用户空间的 DOS 路径传入内核时，会先将其转换为以 <code>\??</code> 为前缀的 NT 路径，由内核在 <code>\??</code> 目录中解析出对应的真实内核对象路径。</p>

    </div>
  </div></li>
</ul>
</li>
<li><p><strong>NT 文件路径</strong> ：I&#x2F;O 管理器与文件系统驱动的直接输入，例如：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\Device\HarddiskVolume1\Windows\System32\drivers\Test.sys</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>盘符被解析为真正卷设备对象。</p>
</li>
<li><p><code>ZwCreateFile/ZwOpenFile</code> 等内核 API 需传此类路径</p>
</li>
</ul>
</li>
<li><p><strong>Win32 设备路径 <code>\\.\</code></strong> </p>
<p>用户态的路径会被<strong>Win32默认认为要访问的是”文件系统”里的文件</strong>。Win32 会按照<strong>文件系统路径解析</strong>的逻辑进行处理：</p>
<ol>
<li><p>解析 <code>C:</code> 盘符；（由于设备路径缺少盘符，一般会在这一步报错❌）</p>
</li>
<li><p>找到其对应物理卷；</p>
</li>
<li><p>然后交给文件系统驱动处理。</p>
</li>
</ol>
<p>然而，像 COM1 串口、物理硬盘 (<code>PhysicalDrive0</code>)、USB 端口、命名管道、内核设备对象这些根本不属于文件系统。文件系统找不到这些对象，它们被挂在 <code>\Device\xxx</code> 下（内核对象管理器里）。因此<strong>如果用户程序也希望用标准的 <code>CreateFile()</code> 访问设备对象则 Win32 会试图当做文件路径来走，肯定会失败。</strong>于是微软在 Win32 设计了一个特殊标记机制：只要路径以 <code>\\.\</code> 开头，Win32 不参与文件系统逻辑，而是把后面的内容原样放进 <code>\??</code> 命名空间，留给内核对象管理器自己去解析。例如：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\\.\COM1        →  \??\COM1          →  \Device\Serial0</span><br><span class="line">\\.\PhysicalDrive0 →  \??\PhysicalDrive0 →  \Device\Harddisk0\DR0</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>Object Manager 路径</strong> ：所有内核对象的正式地址。样的路径仅对对象管理函数有效，如 <code>ObReferenceObjectByName</code>、<code>IoCreateDevice</code>、<code>IoCreateSymbolicLink</code> 等 API 可以直接使用；对文件 API 无意义。</p>
</li>
</ul>
<h3 id="典型解析链路"><a href="#典型解析链路" class="headerlink" title="典型解析链路"></a>典型解析链路</h3><p>文件示例：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CreateFile(&quot;C:\\Windows\\System32\\drivers\\Test.sys&quot;)</span><br><span class="line">      │</span><br><span class="line">      └─► Win32 → NT 转换</span><br><span class="line">              \??\C:\Windows\System32\drivers\Test.sys</span><br><span class="line">                   │</span><br><span class="line">                   └─► \??\C: (符号链接)</span><br><span class="line">                           ↓</span><br><span class="line">                          \Device\HarddiskVolume1</span><br><span class="line">                                │</span><br><span class="line">                                └─► 完整 NT 路径</span><br><span class="line">                                    \Device\HarddiskVolume1\Windows\System32\drivers\Test.sys</span><br></pre></td></tr></table></figure></div>

<p>设备示例：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CreateFile(&quot;\\\\.\\COM1&quot;)</span><br><span class="line">      │</span><br><span class="line">      └─► \??\COM1   (Win32 设备路径)</span><br><span class="line">             │</span><br><span class="line">             └─► 符号链接解析</span><br><span class="line">                  \Device\Serial0   ← 真实设备对象</span><br></pre></td></tr></table></figure></div>

<h1 id="驱动基本概念"><a href="#驱动基本概念" class="headerlink" title="驱动基本概念"></a>驱动基本概念</h1><p><strong>驱动程序（Driver）</strong>是运行在操作系统内核或用户模式中的软件组件，负责在操作系统与硬件设备之间“翻译”命令与数据。</p>
<h2 id="驱动框架"><a href="#驱动框架" class="headerlink" title="驱动框架"></a>驱动框架</h2><p>微软为简化驱动开发，提供了三种主要框架：</p>
<table>
<thead>
<tr>
<th>框架名</th>
<th>全称</th>
<th>运行模式</th>
<th>推荐用途</th>
</tr>
</thead>
<tbody><tr>
<td><strong>WDM</strong></td>
<td>Windows Driver Model</td>
<td>内核模式</td>
<td>底层控制、兼容性极强，但复杂</td>
</tr>
<tr>
<td><strong>KMDF</strong></td>
<td>Kernel-Mode Driver Framework</td>
<td>内核模式</td>
<td>封装了 WDM 的常见任务（如 PnP、电源管理、同步、I&#x2F;O 队列等），推荐用于大多数设备驱动开发</td>
</tr>
<tr>
<td><strong>UMDF</strong></td>
<td>User-Mode Driver Framework</td>
<td>用户模式</td>
<td>WDF 框架的另一部分，适用于开发<strong>运行在用户模式</strong>的驱动，推荐用于外围、低风险设备驱动</td>
</tr>
</tbody></table>
<p>考虑到兼容性，我们通常采用 WDM 框架开发驱动。</p>
<h2 id="驱动服务名"><a href="#驱动服务名" class="headerlink" title="驱动服务名"></a>驱动服务名</h2><p>驱动的<strong>服务名（Service Name）</strong>是系统用来识别和管理驱动程序的逻辑标识符，它是注册表 <code>HKLM\SYSTEM\CurrentControlSet\Services</code> 下的子项名称，也是驱动服务控制、注册、加载、配置等操作的核心索引键。</p>
<p>例如如果我们加载一个名称为 <code>Services.sys</code> 的驱动，则会在注册表中对应创建一个 <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services</code> 子项。</p>
<ul>
<li><code>CurrentControlSet</code> → 实际指向 <code>ControlSet001</code> 或 <code>ControlSet002</code>，系统启动时动态决定</li>
<li><code>Services</code> → 包含所有服务与驱动程序的定义项</li>
</ul>
<p>在该子项中通常有如下键值对：</p>
<table>
<thead>
<tr>
<th>键名</th>
<th>类型</th>
<th>示例值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ImagePath</strong></td>
<td><code>REG_EXPAND_SZ</code></td>
<td><code>\??\C:\Path\to\MyDriver.sys</code></td>
<td>驱动文件路径，通常位于 <code>%SystemRoot%\System32\drivers\</code></td>
</tr>
<tr>
<td><strong>Type</strong></td>
<td><code>REG_DWORD</code></td>
<td><code>1</code>, <code>2</code></td>
<td>指定服务&#x2F;驱动类型（详见下文）</td>
</tr>
<tr>
<td><strong>Start</strong></td>
<td><code>REG_DWORD</code></td>
<td><code>0</code>, <code>1</code>, <code>3</code></td>
<td>启动类型（详见下文）</td>
</tr>
<tr>
<td><strong>Group</strong></td>
<td><code>REG_SZ</code></td>
<td><code>Base</code>, <code>Boot Bus Extender</code></td>
<td>指定驱动分组，影响加载顺序</td>
</tr>
<tr>
<td><strong>ErrorControl</strong></td>
<td><code>REG_DWORD</code></td>
<td><code>1</code></td>
<td>启动失败时的处理方式</td>
</tr>
<tr>
<td><strong>DisplayName</strong></td>
<td><code>REG_SZ</code></td>
<td><code>My Sample Driver</code></td>
<td>控制面板中显示的服务名称（可选）</td>
</tr>
<tr>
<td><strong>Description</strong></td>
<td><code>REG_SZ</code></td>
<td><code>Test WDM Driver</code></td>
<td>人类可读描述信息（可选）</td>
</tr>
<tr>
<td><strong>Tag</strong></td>
<td><code>REG_DWORD</code></td>
<td>分组内排序标识（较少使用）</td>
<td></td>
</tr>
<tr>
<td><strong>Parameters</strong></td>
<td><code>REG_KEY</code></td>
<td>子键</td>
<td>自定义参数保存区，驱动可读取用于配置</td>
</tr>
</tbody></table>
<blockquote>
<p><code>\??\</code> 是 <strong>Windows 内核对象管理器</strong>（Object Manager）中的一个符号链接目录，代表当前会话的 <strong>DosDevices（用户态设备路径）目录</strong>。</p>
<p><code>\??\</code> 通常映射到 <code>\GLOBAL??</code>，用于解析用户模式中的路径名，如：</p>
<ul>
<li><code>\??\C:\Windows\System32</code> → 实际解析为 <code>\Device\HarddiskVolumeX\Windows\System32</code></li>
<li><code>\??\COM1</code> → 实际是 <code>\Device\Serial0</code></li>
</ul>
</blockquote>
<p>其中 <code>Start</code> 类型表示驱动何时启动，不同的值有如下含义：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
<th>示例用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>0</code></td>
<td><strong>BOOT_START</strong> ：引导时加载（Boot Loader 加载）</td>
<td>如磁盘控制器驱动</td>
</tr>
<tr>
<td><code>1</code></td>
<td><strong>SYSTEM_START</strong> ：内核初始化阶段加载</td>
<td>大多数普通内核驱动</td>
</tr>
<tr>
<td><code>2</code></td>
<td><strong>AUTO_START</strong> ：Service Control Manager 启动时加载</td>
<td>系统服务，非 PnP 驱动</td>
</tr>
<tr>
<td><code>3</code></td>
<td><strong>DEMAND_START</strong> ：按需手动启动</td>
<td>测试驱动、虚拟设备</td>
</tr>
<tr>
<td><code>4</code></td>
<td><strong>DISABLED</strong> ：禁用服务</td>
<td>禁用驱动或服务启动</td>
</tr>
</tbody></table>
<p><code>Type</code> 类型表示服务&#x2F;驱动的类别，不同的值有如下含义：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>1</code></td>
<td>内核驱动（<code>SERVICE_KERNEL_DRIVER</code>）</td>
<td><code>.sys</code> 驱动，运行在 Ring 0</td>
</tr>
<tr>
<td><code>2</code></td>
<td>文件系统驱动（<code>SERVICE_FILE_SYSTEM_DRIVER</code>）</td>
<td>NTFS、FAT 等</td>
</tr>
<tr>
<td><code>10</code></td>
<td>Win32 服务（用户模式，<code>SERVICE_WIN32_OWN_PROCESS</code>）</td>
<td>普通服务程序</td>
</tr>
</tbody></table>
<h2 id="驱动加载"><a href="#驱动加载" class="headerlink" title="驱动加载"></a>驱动加载</h2><p>Windows 支持两种主要的内核驱动加载方式：</p>
<ul>
<li>高层推荐方式：通过 <strong>SCM（服务控制管理器）</strong></li>
<li>底层直接方式：通过 <strong>ZwLoadDriver（系统调用）</strong></li>
</ul>
<p>这两种方式都依赖于 <strong>驱动服务名对应的注册表项</strong>。</p>
<ul>
<li>SCM 方式加载不是由本进程完成的（实际由系统进程，如 <code>services.exe</code>），因此在 0 环不容易通过行为定位到进程。</li>
<li>ZwLoadDriver 方式加载过程可控，不容易被系统策略拦截。实际情况下 <code>ZwLoadDriver</code> 方式加载签名异常驱动的成功率高一些。</li>
</ul>
<h3 id="SCM-加载（服务控制管理器）"><a href="#SCM-加载（服务控制管理器）" class="headerlink" title="SCM 加载（服务控制管理器）"></a>SCM 加载（服务控制管理器）</h3><p><strong>SCM 加载</strong>是 Windows 推荐的标准驱动加载方式。驱动作为一种特殊的“服务”被注册（类型为 <code>SERVICE_KERNEL_DRIVER</code>），然后由 <strong>服务控制管理器（SCM）</strong> 调用底层内核服务 <code>NtLoadDriver</code> 加载 <code>.sys</code> 驱动文件。</p>
<h4 id="原理流程"><a href="#原理流程" class="headerlink" title="原理流程"></a>原理流程</h4><p>Windows 把驱动程序视为一种特殊的服务，类型为 <code>SERVICE_KERNEL_DRIVER</code>。通过一套标准 API，开发者可以注册、启动、停止和卸载驱动。每个 API 都与注册表和内核交互紧密关联。</p>
<ul>
<li><p><strong><code>OpenSCManager</code></strong> ：连接到本地或远程计算机上的 SCM（服务控制管理器），并获取一个 SCM 句柄，用于后续服务管理操作。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SC_HANDLE <span class="title function_">OpenSCManager</span><span class="params">(</span></span><br><span class="line"><span class="params">    LPCSTR lpMachineName,     <span class="comment">// 计算机名，NULL 表示本地</span></span></span><br><span class="line"><span class="params">    LPCSTR lpDatabaseName,    <span class="comment">// 数据库名，通常为 NULL 或 &quot;ServicesActive&quot;</span></span></span><br><span class="line"><span class="params">    DWORD  dwDesiredAccess    <span class="comment">// 访问权限（如 SC_MANAGER_ALL_ACCESS）</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong><code>lpMachineName</code></strong> ：目标计算机名称。为 <code>NULL</code> 时表示本地计算机。</li>
<li><strong><code>lpDatabaseName</code></strong> ：服务数据库名称，通常为 <code>NULL</code> 或默认值 <code>&quot;ServicesActive&quot;</code>。</li>
<li><strong><code>dwDesiredAccess</code></strong> ：请求的访问权限。建议使用 <code>SC_MANAGER_ALL_ACCESS</code> 以便执行创建、删除等所有操作。</li>
</ul>
</li>
<li><p><strong><code>CreateService</code></strong> ：在 SCM 中注册一个新服务（或驱动），生成注册表项并配置驱动加载参数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SC_HANDLE <span class="title function_">CreateService</span><span class="params">(</span></span><br><span class="line"><span class="params">    SC_HANDLE hSCManager,           <span class="comment">// 打开的服务控制管理器句柄</span></span></span><br><span class="line"><span class="params">    LPCSTR lpServiceName,           <span class="comment">// 服务逻辑名称（注册表键名）</span></span></span><br><span class="line"><span class="params">    LPCSTR lpDisplayName,           <span class="comment">// 显示名称（服务管理器界面显示）</span></span></span><br><span class="line"><span class="params">    DWORD dwDesiredAccess,          <span class="comment">// 返回句柄的访问权限</span></span></span><br><span class="line"><span class="params">    DWORD dwServiceType,            <span class="comment">// 服务类型（如内核驱动）</span></span></span><br><span class="line"><span class="params">    DWORD dwStartType,              <span class="comment">// 启动类型（如手动、系统、引导）</span></span></span><br><span class="line"><span class="params">    DWORD dwErrorControl,           <span class="comment">// 启动失败时的系统响应方式</span></span></span><br><span class="line"><span class="params">    LPCSTR lpBinaryPathName,        <span class="comment">// 驱动/服务可执行文件路径</span></span></span><br><span class="line"><span class="params">    LPCSTR lpLoadOrderGroup,        <span class="comment">// 所属分组，决定加载顺序</span></span></span><br><span class="line"><span class="params">    LPDWORD lpdwTagId,              <span class="comment">// 输出的标签值（排序用）</span></span></span><br><span class="line"><span class="params">    LPCSTR lpDependencies,          <span class="comment">// 所依赖的服务列表（以双 \0 结尾）</span></span></span><br><span class="line"><span class="params">    LPCSTR lpServiceStartName,      <span class="comment">// 服务启动账户（驱动设为 NULL）</span></span></span><br><span class="line"><span class="params">    LPCSTR lpPassword               <span class="comment">// 启动账户的密码（驱动设为 NULL）</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong><code>hSCManager</code></strong> ：由 <code>OpenSCManager</code> 返回的句柄。</li>
<li><strong><code>lpServiceName</code></strong> ：服务的逻辑名称，对应注册表子项名，必须唯一。</li>
<li><strong><code>lpDisplayName</code></strong> ：显示名称，出现在服务管理器界面中。</li>
<li><strong><code>dwDesiredAccess</code></strong> ：服务句柄的访问权限，推荐 <code>SERVICE_ALL_ACCESS</code>。</li>
<li><strong><code>dwServiceType</code></strong> ：服务类型。驱动应设为 <code>SERVICE_KERNEL_DRIVER</code>（值 <code>0x1</code>）。</li>
<li><strong><code>dwStartType</code></strong> ：启动方式：<ul>
<li><code>SERVICE_BOOT_START</code>（0）→ 引导加载</li>
<li><code>SERVICE_SYSTEM_START</code>（1）→ 内核加载</li>
<li><code>SERVICE_DEMAND_START</code>（3）→ 手动加载</li>
</ul>
</li>
<li><strong><code>dwErrorControl</code></strong> ：启动失败时系统行为：<ul>
<li><code>SERVICE_ERROR_IGNORE</code>（0）→ 忽略错误</li>
<li><code>SERVICE_ERROR_NORMAL</code>（1）→ 记录日志</li>
<li><code>SERVICE_ERROR_SEVERE</code>（2）→ 启动安全模式</li>
</ul>
</li>
<li><strong><code>lpBinaryPathName</code></strong> ：驱动路径（如 <code>&quot;C:\\Drivers\\MyDriver.sys&quot;</code>）。</li>
<li><strong><code>lpLoadOrderGroup</code></strong> ：加载分组（如 <code>Base</code>，影响加载顺序，可为 NULL）。</li>
<li><strong><code>lpdwTagId</code></strong> ：输出值，指定分组内的排序标识（可为 NULL）。</li>
<li><strong><code>lpDependencies</code></strong> ：依赖服务名称，多个用 <code>\0</code> 分隔，以 <code>\0\0</code> 结尾。</li>
<li><strong><code>lpServiceStartName</code></strong> ：服务启动账户，驱动设为 <code>NULL</code> 表示 LocalSystem。</li>
<li><strong><code>lpPassword</code></strong> ：账户密码，驱动设为 <code>NULL</code>。</li>
</ul>
<p>对于我们测试的驱动，<code>CreateService</code> 示例传参如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CreateService(</span><br><span class="line">    hSCManager,                        <span class="comment">// 服务控制管理器句柄（来自 OpenSCManager）</span></span><br><span class="line">    <span class="string">&quot;MyDriver&quot;</span>,                        <span class="comment">// 服务名称（注册表键名，必须唯一）</span></span><br><span class="line">    <span class="string">&quot;My Kernel Driver&quot;</span>,               <span class="comment">// 服务显示名称（可在服务管理器中显示）</span></span><br><span class="line">    SERVICE_ALL_ACCESS,               <span class="comment">// 访问权限（允许所有操作：启动、停止、删除等）</span></span><br><span class="line">    SERVICE_KERNEL_DRIVER,            <span class="comment">// 服务类型：内核模式驱动（对应 .sys 文件）</span></span><br><span class="line">    SERVICE_DEMAND_START,             <span class="comment">// 启动类型：按需启动（需手动调用 StartService）</span></span><br><span class="line">    SERVICE_ERROR_NORMAL,             <span class="comment">// 错误控制：加载失败时记录日志，继续启动系统</span></span><br><span class="line">    <span class="string">&quot;C:\\Drivers\\MyDriver.sys&quot;</span>,      <span class="comment">// 驱动程序路径（必须为绝对路径）</span></span><br><span class="line">    <span class="literal">NULL</span>,                             <span class="comment">// 加载顺序组（不指定）</span></span><br><span class="line">    <span class="literal">NULL</span>,                             <span class="comment">// Tag ID 输出参数（排序标识，不需要时设 NULL）</span></span><br><span class="line">    <span class="literal">NULL</span>,                             <span class="comment">// 依赖服务列表（无依赖）</span></span><br><span class="line">    <span class="literal">NULL</span>,                             <span class="comment">// 启动账户（驱动使用 LocalSystem，设为 NULL）</span></span><br><span class="line">    <span class="literal">NULL</span>                              <span class="comment">// 启动账户密码（同上，设为 NULL）</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong><code>OpenService</code></strong> ：打开已存在的服务（或驱动），获取用于后续控制（启动、停止、删除）的句柄。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SC_HANDLE <span class="title function_">OpenService</span><span class="params">(</span></span><br><span class="line"><span class="params">    SC_HANDLE hSCManager,     <span class="comment">// 来自 OpenSCManager 的 SCM 句柄</span></span></span><br><span class="line"><span class="params">    LPCSTR lpServiceName,     <span class="comment">// 要打开的服务名</span></span></span><br><span class="line"><span class="params">    DWORD dwDesiredAccess     <span class="comment">// 所需权限（如 SERVICE_START | STOP）</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong><code>hSCManager</code></strong> ：由 <code>OpenSCManager</code> 获取的 SCM 句柄。</li>
<li><strong><code>lpServiceName</code></strong> ：服务名称，必须精确匹配已注册服务名。</li>
<li><strong><code>dwDesiredAccess</code></strong> ：访问权限（如 <code>SERVICE_START | SERVICE_STOP | DELETE</code>）。</li>
</ul>
</li>
<li><p><strong><code>StartService</code></strong> ：启动指定服务或驱动。对于驱动，会由 SCM 调用 <code>NtLoadDriver</code>，将 <code>.sys</code> 文件加载到内核。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">StartService</span><span class="params">(</span></span><br><span class="line"><span class="params">    SC_HANDLE hService,           <span class="comment">// 目标服务的句柄</span></span></span><br><span class="line"><span class="params">    DWORD dwNumServiceArgs,       <span class="comment">// 参数个数（驱动设为 0）</span></span></span><br><span class="line"><span class="params">    LPCSTR *lpServiceArgVectors   <span class="comment">// 参数数组（驱动设为 NULL）</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong><code>hService</code></strong> ：来自 <code>CreateService</code> 或 <code>OpenService</code> 的服务句柄。</li>
<li><strong><code>dwNumServiceArgs</code></strong> ：参数个数，驱动无参数则设为 <code>0</code>。</li>
<li><strong><code>lpServiceArgVectors</code></strong> ：参数数组，驱动无参数则设为 <code>NULL</code>。</li>
</ul>
</li>
<li><p><strong><code>ControlService</code></strong> ：向运行中的服务发送控制命令。用于停止驱动（需驱动实现 <code>Unload</code> 函数）。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">ControlService</span><span class="params">(</span></span><br><span class="line"><span class="params">    SC_HANDLE hService,              <span class="comment">// 服务句柄</span></span></span><br><span class="line"><span class="params">    DWORD dwControl,                 <span class="comment">// 控制命令（如 SERVICE_CONTROL_STOP）</span></span></span><br><span class="line"><span class="params">    LPSERVICE_STATUS lpServiceStatus <span class="comment">// 输出当前服务状态</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong><code>hService</code></strong> ：目标服务句柄。</li>
<li><strong><code>dwControl</code></strong> ：控制命令，停止服务时设为 <code>SERVICE_CONTROL_STOP</code>（0x1）。</li>
<li><strong><code>lpServiceStatus</code></strong> ：接收服务状态的结构体指针。</li>
</ul>
</li>
<li><p><strong><code>DeleteService</code></strong> ：删除指定服务或驱动注册信息（从注册表清除），不会立即卸载已加载驱动。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">DeleteService</span><span class="params">(</span></span><br><span class="line"><span class="params">    SC_HANDLE hService   <span class="comment">// 目标服务句柄</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong><code>hService</code></strong> ：目标服务句柄，需具有 <code>DELETE</code> 权限。</li>
</ul>
</li>
<li><p><strong><code>CloseServiceHandle</code></strong> ：关闭服务或 SCM 句柄，释放资源。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CloseServiceHandle</span><span class="params">(</span></span><br><span class="line"><span class="params">    SC_HANDLE hSCObject  <span class="comment">// 可为服务句柄或 SCM 句柄</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong><code>hSCObject</code></strong> ：服务或控制管理器的句柄。</li>
</ul>
</li>
</ul>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 打开服务控制管理器</span></span><br><span class="line">    SC_HANDLE hSCManager = OpenSCManager(<span class="literal">NULL</span>, <span class="literal">NULL</span>, SC_MANAGER_ALL_ACCESS);</span><br><span class="line">    <span class="keyword">if</span> (!hSCManager) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] OpenSCManager failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个内核驱动类型的服务</span></span><br><span class="line">    SC_HANDLE hService = CreateService(</span><br><span class="line">        hSCManager,</span><br><span class="line">        <span class="string">&quot;MyDriver&quot;</span>,                        <span class="comment">// 驱动服务名（逻辑名）</span></span><br><span class="line">        <span class="string">&quot;MyDriver&quot;</span>,                        <span class="comment">// 显示名称</span></span><br><span class="line">        SERVICE_ALL_ACCESS,               <span class="comment">// 权限</span></span><br><span class="line">        SERVICE_KERNEL_DRIVER,            <span class="comment">// 类型：内核驱动</span></span><br><span class="line">        SERVICE_DEMAND_START,             <span class="comment">// 启动方式：手动启动</span></span><br><span class="line">        SERVICE_ERROR_NORMAL,</span><br><span class="line">        <span class="string">&quot;C:\\Drivers\\MyDriver.sys&quot;</span>,      <span class="comment">// 驱动文件路径</span></span><br><span class="line">        <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!hService) &#123;</span><br><span class="line">        <span class="keyword">if</span> (GetLastError() == ERROR_SERVICE_EXISTS) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[*] 服务已存在，尝试打开...\n&quot;</span>);</span><br><span class="line">            hService = OpenService(hSCManager, <span class="string">&quot;MyDriver&quot;</span>, SERVICE_ALL_ACCESS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[-] CreateService failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">            CloseServiceHandle(hSCManager);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动驱动</span></span><br><span class="line">    <span class="keyword">if</span> (!StartService(hService, <span class="number">0</span>, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        DWORD err = GetLastError();</span><br><span class="line">        <span class="keyword">if</span> (err == ERROR_SERVICE_ALREADY_RUNNING) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[*] 驱动已在运行中。\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[-] StartService failed: %lu\n&quot;</span>, err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] 驱动已成功加载。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可选：停止驱动并删除服务</span></span><br><span class="line">    SERVICE_STATUS status;</span><br><span class="line">    ControlService(hService, SERVICE_CONTROL_STOP, &amp;status);</span><br><span class="line">    DeleteService(hService);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭句柄</span></span><br><span class="line">    CloseServiceHandle(hService);</span><br><span class="line">    CloseServiceHandle(hSCManager);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h4><p><strong>SCM（Service Control Manager）方式加载驱动</strong>，除了直接用 WinAPI 外，Windows 提供了标准命令行工具。</p>
<p><code>sc</code> 是 Windows 提供的服务控制命令行工具，全名为 <strong>Service Control</strong>。它支持创建、启动、停止、删除内核驱动服务。</p>
<ul>
<li><p><strong>创建服务（注册驱动）</strong></p>
<div class="code-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc create MyDriver <span class="built_in">type</span>= kernel binPath= &quot;C:\<span class="built_in">Path</span>\To\MyDriver.sys&quot;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>MyDriver</code>：驱动服务名（服务项名称）</li>
<li><code>type= kernel</code>：表示是内核驱动（不可省略）</li>
<li><code>binPath= ...</code>：驱动文件路径（推荐绝对路径）</li>
</ul>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p><code>type=</code>, <code>binPath=</code> 后必须留空格，语法严格。</p>

    </div>
  </div>
</li>
<li><p><strong>启动驱动服务（实际加载）</strong></p>
<p>会触发 Service Control Manager 调用 <code>NtLoadDriver</code> 加载 <code>.sys</code> 文件，驱动的 <code>DriverEntry</code> 将被执行。</p>
<div class="code-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc <span class="built_in">start</span> MyDriver</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>停止驱动服务（触发卸载）</strong></p>
<p>要求驱动实现了 <code>DriverUnload</code> 函数，否则会失败。</p>
<div class="code-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc stop MyDriver</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>删除服务（清除注册表项）</strong></p>
<div class="code-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc delete MyDriver</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="ZwLoadDriver（系统调用-注册表）"><a href="#ZwLoadDriver（系统调用-注册表）" class="headerlink" title="ZwLoadDriver（系统调用 + 注册表）"></a>ZwLoadDriver（系统调用 + 注册表）</h3><p>这是更“底层”的方式，绕过 SCM，直接调用内核的 <code>ZwLoadDriver</code> 系统服务加载驱动。常用于调试工具、PoC 框架、测试加载器或绕过方式。</p>
<h4 id="原理流程-1"><a href="#原理流程-1" class="headerlink" title="原理流程"></a>原理流程</h4><ol>
<li><p>首先用户态程序提前创建注册表项（路径一般为）：<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\MyDriver</code></p>
<p>其中必须设置至少两个关键键值：</p>
<ul>
<li><p><code>ImagePath</code>（<code>REG_EXPAND_SZ</code>）：驱动文件路径，如：<code>\??\C:\Path\to\MyDriver.sys</code></p>
</li>
<li><p><code>Type</code>（<code>DWORD</code>）：必须为 <code>1</code>，表示该服务为内核驱动。</p>
</li>
</ul>
</li>
<li><p>构造 NT 路径并调用 <code>ZwLoadDriver</code> 加载驱动，该函数原型如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NTSYSAPI NTSTATUS NTAPI <span class="title function_">ZwLoadDriver</span><span class="params">(</span></span><br><span class="line"><span class="params">    IN PUNICODE_STRING DriverServiceName</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>参数：注册表路径，格式为：<br><code>\Registry\Machine\System\CurrentControlSet\Services\MyDriver</code></li>
<li>返回值：NTSTATUS 错误码，常见：<ul>
<li><code>STATUS_SUCCESS</code>：成功</li>
<li><code>STATUS_OBJECT_NAME_NOT_FOUND</code>：注册表路径错误</li>
<li><code>STATUS_IMAGE_ALREADY_LOADED</code>：已加载</li>
</ul>
</li>
</ul>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p><code>ZwLoadDriver</code> 和 <code>NtLoadDriver</code> 实际上是同一个函数的两个符号。</p>
<p>在 <strong>Windows 内核设计中，<code>NtXxx</code> 和 <code>ZwXxx</code> 实际上代表的是</strong>同一个系统服务接口（Syscall）函数，但它们存在 <strong>调用上下文（user mode vs kernel mode）下的行为差异</strong> 和 <strong>API 访问路径差异</strong>，而 <strong>在用户态时，它们几乎是完全等价的入口符号</strong>。</p>

    </div>
  </div>
</li>
<li><p>与驱动加载类似，卸载驱动的时候需要调用 <code>ZwUnloadDriver</code>，并传入同样格式的注册表路径。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>驱动必须自己实现 <code>DriverUnload</code> 回调，系统才会调用卸载。</p>

    </div>
  </div>

<p> <code>ZwUnloadDriver</code> 函数原型如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NTSYSAPI NTSTATUS NTAPI <span class="title function_">ZwUnloadDriver</span><span class="params">(</span></span><br><span class="line"><span class="params">    IN PUNICODE_STRING DriverServiceName</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>参数同上，指定已加载驱动的注册表路径；</li>
<li>若驱动未实现 <code>DriverUnload</code>，调用将失败（一般是 <code>STATUS_INVALID_DEVICE_REQUEST</code>）。</li>
</ul>
</li>
<li><p>清理注册表项。 <strong><code>ZwUnloadDriver</code> 不会自动删除注册表项</strong> ，即驱动从内核卸载后，注册表中的服务项仍然存在，必须你手动清理。</p>
</li>
</ol>
<h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winternl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ntdll.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    NTSYSAPI NTSTATUS NTAPI <span class="title function_">ZwLoadDriver</span><span class="params">(IN PUNICODE_STRING DriverServiceName)</span>;</span><br><span class="line">    NTSYSAPI NTSTATUS NTAPI <span class="title function_">ZwUnloadDriver</span><span class="params">(IN PUNICODE_STRING DriverServiceName)</span>;</span><br><span class="line">    NTSYSAPI VOID NTAPI <span class="title function_">RtlInitUnicodeString</span><span class="params">(PUNICODE_STRING DestinationString, PCWSTR SourceString)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动提取驱动服务名（不含扩展名）</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">wstring</span> <span class="title function_">ExtractDriverName</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; fullPath)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> slash = fullPath.find_last_of(<span class="string">L&quot;\\/&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> dot = fullPath.find_last_of(<span class="string">L&#x27;.&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slash == <span class="built_in">std</span>::<span class="built_in">wstring</span>::npos) slash = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (dot == <span class="built_in">std</span>::<span class="built_in">wstring</span>::npos || dot &lt;= slash) dot = fullPath.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fullPath.substr(slash + <span class="number">1</span>, dot - slash - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造 \Registry\Machine\System\CurrentControlSet\Services\DriverName</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">wstring</span> <span class="title function_">BuildRegPath</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; driverName)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">L&quot;\\Registry\\Machine\\System\\CurrentControlSet\\Services\\&quot;</span> + driverName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册表项创建</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">CreateDriverServiceRegistry</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; driverName, <span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; driverPath)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">wstring</span> keyPath = <span class="string">L&quot;SYSTEM\\CurrentControlSet\\Services\\&quot;</span> + driverName;</span><br><span class="line">    HKEY hKey;</span><br><span class="line">    <span class="keyword">if</span> (RegCreateKeyW(HKEY_LOCAL_MACHINE, keyPath.c_str(), &amp;hKey) != ERROR_SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">std</span>::wcerr &lt;&lt; <span class="string">L&quot;[!] Failed to create registry key.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DWORD type = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">wstring</span> imagePath = <span class="string">L&quot;\\??\\&quot;</span> + driverPath;</span><br><span class="line">    <span class="keyword">if</span> (RegSetValueExW(hKey, <span class="string">L&quot;Type&quot;</span>, <span class="number">0</span>, REG_DWORD, reinterpret_cast&lt;<span class="type">const</span> BYTE*&gt;(&amp;type), <span class="keyword">sizeof</span>(type)) != ERROR_SUCCESS ||</span><br><span class="line">        RegSetValueExW(hKey, <span class="string">L&quot;ImagePath&quot;</span>, <span class="number">0</span>, REG_EXPAND_SZ,</span><br><span class="line">                       reinterpret_cast&lt;<span class="type">const</span> BYTE*&gt;(imagePath.c_str()),</span><br><span class="line">                       static_cast&lt;DWORD&gt;((imagePath.size() + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">wchar_t</span>))) != ERROR_SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">std</span>::wcerr &lt;&lt; <span class="string">L&quot;[!] Failed to set registry values.\n&quot;</span>;</span><br><span class="line">        RegCloseKey(hKey);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RegCloseKey(hKey);</span><br><span class="line">    <span class="built_in">std</span>::wcout &lt;&lt; <span class="string">L&quot;[+] Registry entry created at: &quot;</span> &lt;&lt; keyPath &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除服务对应注册表项</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeleteDriverServiceRegistry</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; driverName)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">wstring</span> keyPath = <span class="string">L&quot;SYSTEM\\CurrentControlSet\\Services\\&quot;</span> + driverName;</span><br><span class="line">    LONG result = RegDeleteKeyW(HKEY_LOCAL_MACHINE, keyPath.c_str());</span><br><span class="line">    <span class="keyword">if</span> (result == ERROR_SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">std</span>::wcout &lt;&lt; <span class="string">L&quot;[+] Registry key deleted: &quot;</span> &lt;&lt; keyPath &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::wcerr &lt;&lt; <span class="string">L&quot;[!] Failed to delete registry key. Error: &quot;</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">LoadDriver</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; driverName)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">wstring</span> regPath = BuildRegPath(driverName);</span><br><span class="line">    UNICODE_STRING ustr;</span><br><span class="line">    RtlInitUnicodeString(&amp;ustr, regPath.c_str());</span><br><span class="line"></span><br><span class="line">    NTSTATUS status = ZwLoadDriver(&amp;ustr);</span><br><span class="line">    <span class="built_in">std</span>::wcout &lt;&lt; <span class="string">L&quot;[+] ZwLoadDriver status: 0x&quot;</span> &lt;&lt; <span class="built_in">std</span>::hex &lt;&lt; status &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status == STATUS_SUCCESS || status == STATUS_IMAGE_ALREADY_LOADED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">UnloadDriver</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; driverName)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">wstring</span> regPath = BuildRegPath(driverName);</span><br><span class="line">    UNICODE_STRING ustr;</span><br><span class="line">    RtlInitUnicodeString(&amp;ustr, regPath.c_str());</span><br><span class="line"></span><br><span class="line">    NTSTATUS status = ZwUnloadDriver(&amp;ustr);</span><br><span class="line">    <span class="built_in">std</span>::wcout &lt;&lt; <span class="string">L&quot;[+] ZwUnloadDriver status: 0x&quot;</span> &lt;&lt; <span class="built_in">std</span>::hex &lt;&lt; status &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status == STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">wmain</span><span class="params">(<span class="type">int</span> argc, <span class="type">wchar_t</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::wcerr &lt;&lt; <span class="string">L&quot;Usage: DriverLoader.exe &lt;PathToDriver.sys&gt;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">wstring</span> driverPath = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">wstring</span> driverName = ExtractDriverName(driverPath);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::wcout &lt;&lt; <span class="string">L&quot;[+] Driver path: &quot;</span> &lt;&lt; driverPath &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::wcout &lt;&lt; <span class="string">L&quot;[+] Driver name: &quot;</span> &lt;&lt; driverName &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!CreateDriverServiceRegistry(driverName, driverPath)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!LoadDriver(driverName)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::wcerr &lt;&lt; <span class="string">L&quot;[!] Driver load failed.\n&quot;</span>;</span><br><span class="line">        DeleteDriverServiceRegistry(driverName);  <span class="comment">// 清理失败也清注册表</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::wcout &lt;&lt; <span class="string">L&quot;[+] Driver loaded successfully.\nPress Enter to unload...\n&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::wcin.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!UnloadDriver(driverName)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::wcerr &lt;&lt; <span class="string">L&quot;[!] Driver unload failed. Ensure DriverUnload is implemented.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DeleteDriverServiceRegistry(driverName);  <span class="comment">// 卸载成功后清理注册表</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::wcout &lt;&lt; <span class="string">L&quot;[+] Driver unloaded and registry cleaned up.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h1 id="驱动开发基础"><a href="#驱动开发基础" class="headerlink" title="驱动开发基础"></a>驱动开发基础</h1><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p>通常一个最基本的 WDM 驱动代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span>  <span class="comment">// 内核开发必要头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动卸载回调函数</span></span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(IN PDRIVER_OBJECT DriverObject)</span></span><br><span class="line">&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(DriverObject);</span><br><span class="line">    DbgPrint(<span class="string">&quot;Driver unloaded.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动入口函数（系统加载驱动时调用）</span></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)</span></span><br><span class="line">&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(RegistryPath);</span><br><span class="line">    DbgPrint(<span class="string">&quot;Driver loaded.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册卸载回调函数</span></span><br><span class="line">    DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>DriverEntry</code> 是 Windows 驱动程序的<strong>主入口函数（Entry Point）</strong>，等同于用户程序中的 <code>main()</code> 函数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(</span></span><br><span class="line"><span class="params">  IN PDRIVER_OBJECT DriverObject,    <span class="comment">// [输入] 驱动对象，由系统分配</span></span></span><br><span class="line"><span class="params">  IN PUNICODE_STRING RegistryPath    <span class="comment">// [输入] 驱动注册表路径</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<p>当<strong>驱动加载</strong>时，系统会调用此函数来完成驱动的初始化过程。</p>
<ul>
<li><p><strong><code>PDRIVER_OBJECT DriverObject</code></strong> ：内核为每个加载的驱动创建一个 <code>DRIVER_OBJECT</code> 结构，此参数就是它的指针。你需要通过它来注册 IRP 分发表、卸载函数、创建设备等。</p>
<p><code>DRIVER_OBJECT</code> 是 Windows 内核用来描述一个驱动程序核心信息的数据结构，驱动开发时我们通过它设置入口函数、分发表、卸载逻辑，是驱动生命周期管理的中心。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0xA8 bytes</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">DRIVER_OBJECT</span> &#123;</span></span><br><span class="line">    CSHORT Type;                             <span class="comment">// 内核对象类型 (固定 DRIVER_OBJECT(0x04))</span></span><br><span class="line">    CSHORT Size;                             <span class="comment">// 结构体大小 (0xA8 字节)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_OBJECT</span>* <span class="title">DeviceObject</span>;</span>     <span class="comment">// 📌设备对象链表头</span></span><br><span class="line">    ULONG Flags;                             <span class="comment">// 驱动状态标志</span></span><br><span class="line">    PVOID DriverStart;                       <span class="comment">// 📌驱动映像起始地址</span></span><br><span class="line">    ULONG DriverSize;                        <span class="comment">// 📌驱动映像总大小</span></span><br><span class="line">    PVOID DriverSection;                     <span class="comment">// 加载模块节点 (挂载到 PsLoadedModuleList)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DRIVER_EXTENSION</span>* <span class="title">DriverExtension</span>;</span>  <span class="comment">// 扩展区域 (含 AddDevice)</span></span><br><span class="line">    UNICODE_STRING DriverName;               <span class="comment">// 📌驱动名 (\Driver\XXX)</span></span><br><span class="line">    UNICODE_STRING* HardwareDatabase;        <span class="comment">// 硬件数据库路径 (历史用途)</span></span><br><span class="line">    PFAST_IO_DISPATCH FastIoDispatch;        <span class="comment">// 快速 I/O 分发表 (文件系统驱动用)</span></span><br><span class="line">    PDRIVER_INITIALIZE DriverInit;           <span class="comment">// 📌初始化入口 (内部使用)</span></span><br><span class="line">    PDRIVER_STARTIO DriverStartIo;           <span class="comment">// 串行化 I/O 支持 (极少用)</span></span><br><span class="line">    PDRIVER_UNLOAD DriverUnload;             <span class="comment">// 📌驱动卸载函数指针</span></span><br><span class="line">    PDRIVER_DISPATCH MajorFunction[<span class="number">28</span>];      <span class="comment">// 📌IRP 主功能分发表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>PUNICODE_STRING RegistryPath</code></strong> ：指向一个 Unicode 字符串，表示驱动在注册表中的键路径，如 <code>\Registry\Machine\System\CurrentControlSet\Services\MyDriver</code> 。</p>
</li>
</ul>
<p>在 <code>DriverEntry</code> 中，我们主要做一些初始化的操作，比如创建设备对象，初始化全局变量，注册 IRP 分发表等等。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <ul>
<li><p>在 <code>DriverEntry</code> 中要的是<strong>设置驱动卸载函数</strong> <code>DriverObject-&gt;DriverUnload</code>，<strong>如果这一步没有做则驱动无法卸载</strong>。</p>
</li>
<li><p><strong>只有全部成功后才返回 <code>STATUS_SUCCESS</code>，否则系统自动撤销加载</strong>。因此我们不需要担心在 <code>DriverEntry</code> 中由于出错提前返回没有设置设置驱动卸载函数而导致驱动无法卸载，因为驱动根本就没有加载成功。</p>
</li>
</ul>

    </div>
  </div>

<h2 id="功能技巧"><a href="#功能技巧" class="headerlink" title="功能技巧"></a>功能技巧</h2><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>几乎所有内核 API 和驱动入口函数都使用 <code>NTSTATUS</code> 类型作为返回值。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> LONG NTSTATUS;</span><br></pre></td></tr></table></figure></div>

<p>同时 WDK 中提供了几个宏用根据返回值判断 api 调用结果。</p>
<table>
<thead>
<tr>
<th>宏函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>NT_SUCCESS(Status)</code></td>
<td>判断是否成功（高位为 0）</td>
</tr>
<tr>
<td><code>NT_ERROR(Status)</code></td>
<td>判断是否是错误（高位为 1）</td>
</tr>
<tr>
<td><code>NT_WARNING(Status)</code></td>
<td>判断是否是警告</td>
</tr>
</tbody></table>
<p>因此一个标准的 API 调用的返回值检测应该是下面这种写法：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">MyFunction</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    NTSTATUS status = DoSomething();</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(status)) &#123;</span><br><span class="line">        <span class="keyword">return</span> status;  <span class="comment">// 向上传播错误</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继续处理...</span></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="日志输出"><a href="#日志输出" class="headerlink" title="日志输出"></a>日志输出</h3><p>内核调试输出需要使用专门的 api，并且输出内容走的是 <code>DbgPrint Buffer</code>，通常只有连接 WinDbg &#x2F; KD 等调试器时可实时显示；无内核调试连接时，有些版本仍可借助 DebugView（SysInternals 工具）捕获部分内核日志。</p>
<ul>
<li><p><code>DbgPrint</code>：最基本的内核调试输出函数，用法与 <code>printf</code> 类似，默认输出优先级较低，相当于 <code>DbgPrintEx(DPFLTR_DEFAULT_ID, DPFLTR_INFO_LEVEL, ...)</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ULONG <span class="title function_">DbgPrint</span><span class="params">(</span></span><br><span class="line"><span class="params">  PCSTR Format,  <span class="comment">// 格式化字符串，类似 printf()</span></span></span><br><span class="line"><span class="params">  ...            <span class="comment">// 可变参数</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>DbgPrintEx</code>：<code>DbgPrint</code> 的增强版，允许指定组件类别和日志等级，便于在复杂项目中分类控制输出。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ULONG <span class="title function_">DbgPrintEx</span><span class="params">(</span></span><br><span class="line"><span class="params">  ULONG ComponentId,  <span class="comment">// 模块分类 (WDF 框架建议填写 DPFLTR_DRIVER_FRAMEWORK_ID)</span></span></span><br><span class="line"><span class="params">  ULONG Level,        <span class="comment">// 日志级别 (DPFLTR_XXX_LEVEL)</span></span></span><br><span class="line"><span class="params">  PCSTR Format,       <span class="comment">// 格式化字符串</span></span></span><br><span class="line"><span class="params">  ...                 <span class="comment">// 可变参数</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<p>这里常见 <code>ComponentId</code> 值有：</p>
<ul>
<li><code>DPFLTR_DEFAULT_ID</code>：默认组件</li>
<li><code>DPFLTR_IO_ID</code>：I&#x2F;O 子系统</li>
<li><code>DPFLTR_PNP_ID</code>：PnP 子系统</li>
<li><code>DPFLTR_DRIVER_FRAMEWORK_ID</code>：WDF 框架日志</li>
</ul>
<p>常见的 <code>Level</code> 值有：</p>
<ul>
<li><code>DPFLTR_INFO_LEVEL</code>：普通信息</li>
<li><code>DPFLTR_WARNING_LEVEL</code>：警告</li>
<li><code>DPFLTR_ERROR_LEVEL</code>：错误</li>
<li><code>DPFLTR_MASK </code>：所有级别</li>
</ul>
</li>
<li><p><code>KdPrintEx</code>：实际上是对 <code>DbgPrintEx</code> 的宏封装，编写格式<strong>需使用两层括号</strong>，优势在于统一兼容内核版本控制，WDK 推荐使用，另外可以在 Release 版本自动去除日志输出。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KdPrintEx((DPFLTR_DEFAULT_ID, DPFLTR_INFO_LEVEL, <span class="string">&quot;MyDriver running.\n&quot;</span>));</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h3><p><code>DbgBreakPoint()</code> 是 <strong>Windows 内核提供的标准调试断点函数</strong>，专门用于<strong>驱动或内核模块中设置断点</strong>。它的作用是：当内核代码执行到 <code>DbgBreakPoint()</code> 处时，如果系统当前处于调试状态（例如 WinDbg 已附加），将触发调试器断点中断。</p>
<p><code>DbgBreakPoint()</code> 是由内核导出的函数，声明如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOID NTAPI <span class="title function_">DbgBreakPoint</span><span class="params">(VOID)</span>;</span><br></pre></td></tr></table></figure></div>



<p><code>kdBreakPoint</code></p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p>在 Windows 开发中有多种字符串类型，但是在内核驱动开发中为了安全起见，有额外引入了 <code>UNICODE_STRING</code> 这一新的字符串类型。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>UNICODE_STRING</code></td>
<td>UTF-16 编码，结构体包装</td>
<td>内核中最常见的字符串类型，用于路径、设备名、对象名等</td>
</tr>
<tr>
<td><code>WCHAR[]</code></td>
<td>C 风格宽字符串（null结尾）</td>
<td>常用于初始化 UNICODE_STRING</td>
</tr>
<tr>
<td><code>CHAR[]</code></td>
<td>C 风格窄字符串（null结尾）</td>
<td>常用于初始化 ANSI_STRING</td>
</tr>
<tr>
<td><code>PWSTR</code> &#x2F; <code>PCHAR</code></td>
<td>指向上述数组的指针</td>
<td>宽&#x2F;窄字符数组地址，传参常用</td>
</tr>
</tbody></table>
<h4 id="UNICODE-STRING"><a href="#UNICODE-STRING" class="headerlink" title="UNICODE_STRING"></a>UNICODE_STRING</h4><p><code>UNICODE_STRING</code> 字符串类型本质上就是将宽字符串利用一个结构体进行了一次封装。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> &#123;</span></span><br><span class="line">  USHORT Length;         <span class="comment">// 单位：字节，不包括 NULL</span></span><br><span class="line">  USHORT MaximumLength;  <span class="comment">// 最大长度（字节）</span></span><br><span class="line">  PWSTR  Buffer;         <span class="comment">// 指向宽字符串（WCHAR[]）</span></span><br><span class="line">&#125; UNICODE_STRING;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <ul>
<li><p><code>Length</code> 单位是字节，不是字符数；</p>
</li>
<li><p><code>Buffer</code> 不强制 <code>null</code> 结尾；</p>
</li>
</ul>

    </div>
  </div>

<p><code>UNICODE_STRING</code> 可以通过 <code>RtlInitUnicodeString</code> 函数和 <code>RTL_CONSTANT_STRING</code> 宏两种方式进行初始化。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>这两种初始化方法都不会拷贝字符串内容，而只设置结构体，指针仍指向原始常量字符串。</p>

    </div>
  </div>

<ul>
<li><p><code>RtlInitUnicodeString</code> 函数原型如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VOID <span class="title function_">RtlInitUnicodeString</span><span class="params">(</span></span><br><span class="line"><span class="params">  PUNICODE_STRING DestinationString,</span></span><br><span class="line"><span class="params">  PCWSTR          SourceString</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>该函数会设置结构体的 <code>Length</code>, <code>MaximumLength</code>, <code>Buffer</code> 字段。</li>
<li><code>SourceString</code> 必须是 null 结尾的常量或合法缓冲区</li>
</ul>
<p>示例代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UNICODE_STRING uStr;</span><br><span class="line">RtlInitUnicodeString(&amp;uStr, <span class="string">L&quot;\\Device\\MyDriver&quot;</span>);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>RTL_CONSTANT_STRING</code></p>
<p><code>RTL_CONSTANT_STRING</code> 用于编译期静态构造一个 <code>UNICODE_STRING</code>，该宏的定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RTL_CONSTANT_STRING(s) &#123; sizeof(s) - sizeof((s)[0]), sizeof(s), s &#125;</span></span><br></pre></td></tr></table></figure></div>

<p>示例代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNICODE_STRING path = RTL_CONSTANT_STRING(<span class="string">L&quot;\\Device\\MyDriver&quot;</span>);</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p><strong><code>RTL_CONSTANT_STRING</code> 不能用于变量字符串，只能用于编译期可见的字符串常量</strong>（即 <code>L&quot;...&quot;</code> 形式的字面量）。如果你错误地用它去初始化一个运行时变量，会导致：</p>
<ul>
<li><p><strong>结构体字段内容不正确</strong>（长度计算可能错误）</p>
</li>
<li><p><strong>潜在的内存越界访问</strong></p>
</li>
<li><p><strong>编译器不报错，但运行时行为未定义</strong></p>
</li>
</ul>

    </div>
  </div></li>
</ul>
<h4 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换</h4><p>在实际开发中，经常会遇到<strong>将用户传入的 ANSI 字符串转换为内核 API 可用格式</strong>这种需求，这就需要我们将 <code>char *</code> 字符串转换为 <code>UNICODE_STRING</code> 类型，具体步骤如下：</p>
<ol>
<li><p>首先我们需要利用 <code>RtlInitAnsiString</code> 函数将 <code>char *</code> 字符串转换为 <code>ANSI_STRING</code> 类型：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* ansi = <span class="string">&quot;MyDevice\\Test&quot;</span>;</span><br><span class="line">ANSI_STRING ansiStr;</span><br><span class="line"></span><br><span class="line">RtlInitAnsiString(&amp;ansiStr, ansi);</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>在有些教程中这一步会使用 <code>RtlInitString</code> 函数将将 <code>char *</code> 字符串转换为 <code>STRING</code> 类型，实际上这里的 <code>STRING</code> 类型实际上就是 <code>ANSI_STRING</code> 的旧别名，结构相同。</p>

    </div>
  </div>
</li>
<li><p>使用 <code>RtlAnsiStringToUnicodeString</code> 函数将 <code>ANSI_STRING</code> 字符串转换为 <code>UNICODE_STRING</code> 字符串。这里 <code>RtlAnsiStringToUnicodeString</code> 函数原型如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">RtlAnsiStringToUnicodeString</span><span class="params">(</span></span><br><span class="line"><span class="params">  PUNICODE_STRING DestinationString,</span></span><br><span class="line"><span class="params">  PCANSI_STRING SourceString,</span></span><br><span class="line"><span class="params">  BOOLEAN AllocateDestinationString</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>DestinationString</code>：输出的 Unicode 结构体</li>
<li><code>SourceString</code>：输入的 ANSI 结构体</li>
<li><code>AllocateDestinationString</code>：如果为 <code>TRUE</code>，系统会分配 <code>DestinationString-&gt;Buffer</code>；否则<strong>你必须事先分配好 <code>ANSI_STRING.Buffer</code></strong> 并设置 <code>MaximumLength</code>，否则可能崩溃或数据丢失。</li>
</ul>
<p>这里为了方便封装，我们采用 <code>AllocateDestinationString</code> 为 <code>TRUE</code> 的写法。对于这样产生的 <code>UNICODE_STRING</code> 字符串，使用完毕时候我们需要调用 <code>RtlFreeUnicodeString</code> 函数将其释放，这里释放的是 <code>ANSI_STRING.Buffer</code>。</p>
</li>
</ol>
<p>在实际开发中，我们一般习惯将上述步骤封装成一个函数：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">ConvertAnsiToUnicode</span><span class="params">(_In_ <span class="type">const</span> <span class="type">char</span>* input, _Out_ PUNICODE_STRING uStr)</span> &#123;</span><br><span class="line">    ANSI_STRING aStr;</span><br><span class="line">    RtlInitAnsiString(&amp;aStr, input);</span><br><span class="line">    <span class="keyword">return</span> RtlAnsiStringToUnicodeString(uStr, &amp;aStr, TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><ul>
<li><p><code>RtlStringCbPrintfA/W</code>：内核安全字符串格式化函数</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">RtlStringCbPrintfA</span><span class="params">(</span></span><br><span class="line"><span class="params">  _Out_  CHAR *pszDest,</span></span><br><span class="line"><span class="params">  _In_   <span class="type">size_t</span> cbDest,</span></span><br><span class="line"><span class="params">  _In_   <span class="type">const</span> CHAR *pszFormat,</span></span><br><span class="line"><span class="params">  ...</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">RtlStringCbPrintfW</span><span class="params">(</span></span><br><span class="line"><span class="params">  _Out_  WCHAR *pszDest,</span></span><br><span class="line"><span class="params">  _In_   <span class="type">size_t</span> cbDest,</span></span><br><span class="line"><span class="params">  _In_   <span class="type">const</span> WCHAR *pszFormat,</span></span><br><span class="line"><span class="params">  ...</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>pszDest</code>：输出目标缓冲区</li>
<li><code>cbDest</code>：缓冲区总字节数（注意单位：字节，不是字符数）</li>
<li><code>pszFormat</code>：格式化字符串，类似 <code>printf</code> 格式</li>
</ul>
</li>
<li><p><code>RtlCompareUnicodeString</code>：<code>UNICODE_STRING</code> 安全比较</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LONG <span class="title function_">RtlCompareUnicodeString</span><span class="params">(</span></span><br><span class="line"><span class="params">  _In_  <span class="type">const</span> UNICODE_STRING *String1,</span></span><br><span class="line"><span class="params">  _In_  <span class="type">const</span> UNICODE_STRING *String2,</span></span><br><span class="line"><span class="params">  _In_  BOOLEAN CaseInSensitive</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>CaseInSensitive</code>：是否大小写无关（<code>TRUE</code> 表示忽略大小写）</li>
<li>返回值：返回逻辑类似 C 标准库 <code>strcmp</code>。<ul>
<li><code>0</code>：相等</li>
<li><code>&lt;0</code>：<code>String1</code> 小于 <code>String2</code></li>
<li><code>&gt;0</code>：<code>String1</code> 大于 <code>String2</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="双向链表（LIST-ENTRY）"><a href="#双向链表（LIST-ENTRY）" class="headerlink" title="双向链表（LIST_ENTRY）"></a>双向链表（LIST_ENTRY）</h3><p>在 Windows 中有一个专门描述链表节点的结构 <code>LIST_ENTRY</code>，该结构定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> *<span class="title">Flink</span>;</span>  <span class="comment">// Forward Link (前向指针)</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> *<span class="title">Blink</span>;</span>  <span class="comment">// Backward Link (后向指针)</span></span><br><span class="line">&#125; LIST_ENTRY, *PLIST_ENTRY;</span><br></pre></td></tr></table></figure></div>

<p>在 Windows 的设计思想中，双向链表有两种成员组成：</p>
<ul>
<li><p><code>ListHead</code>：即链表头，通常类型为 <code>LIST_ENTRY</code> 结构体，有时会作为一个成员放到另一个结构体中，但是作为“链表头”本身仍是 <code>LIST_ENTRY</code> 类型。链表头自己<strong>不存储任何数据</strong>，只是链表控制块，但<strong>会被串到双向链表中</strong>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LIST_ENTRY MyList;</span><br><span class="line">InitializeListHead(&amp;MyList);</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>Windows 的 <code>LIST_ENTRY</code> 初始状态必须是：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ListHead-&gt;Flink = ListHead;</span><br><span class="line">ListHead-&gt;Blink = ListHead;</span><br></pre></td></tr></table></figure></div>

<p>任何链表必须先初始化，否则后续操作容易蓝屏。Windows有一个专门用于初始化 <code>ListEntry</code> 的函数 <code>InitializeListHead</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOID <span class="title function_">InitializeListHead</span><span class="params">(PLIST_ENTRY ListHead)</span>;</span><br></pre></td></tr></table></figure></div>

    </div>
  </div>
</li>
<li><p><code>Entry</code>：用来将节点链入双向链表中的一个结构体成员，类型同样为 <code>LIST_ENTRY</code>。例如下面这个结构体中的 <code>List</code> 就是一个 <code>Entry</code>，我们可以通过从链表头遍历双向链表找到所有链表中的 <code>MY_NODE</code> 结构体。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MY_NODE</span> &#123;</span></span><br><span class="line">    ULONG ID;</span><br><span class="line">    LIST_ENTRY List;</span><br><span class="line">&#125; MY_NODE;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>我们通过双向链表遍历找到的结构体地址实际上是 <code>List</code> 成员的地址，要想获取到结构体地址还需要借助 <code>CONTAINING_RECORD</code> 宏。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONTAINING_RECORD(address, type, field) \</span></span><br><span class="line"><span class="meta">    ((type *)((PCHAR)(address) - (ULONG_PTR)(&amp;((type *)0)-&gt;field)))</span></span><br></pre></td></tr></table></figure></div>

<p>例如：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PLIST_ENTRY pEntry = RemoveHeadList(&amp;MyList);</span><br><span class="line">PMY_NODE pNode = CONTAINING_RECORD(pEntry, MY_NODE, List);</span><br></pre></td></tr></table></figure></div>

    </div>
  </div></li>
</ul>
<p>针对双向链表，Windows 提供了众多 API 用于操作双向链表中的成员：</p>
<ul>
<li><p><code>InsertHeadList()</code>：将 <code>Entry</code> 插入到链表头部（头节点后，<code>ListHead-&gt;Flink</code> 方向）</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOLEAN <span class="title function_">InsertHeadList</span><span class="params">(</span></span><br><span class="line"><span class="params">  PLIST_ENTRY ListHead,</span></span><br><span class="line"><span class="params">  PLIST_ENTRY Entry</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>InsertTailList()</code>：插入到链表尾部（头节点前，<code>ListHead-&gt;Blink</code> 方向）</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOLEAN <span class="title function_">InsertTailList</span><span class="params">(</span></span><br><span class="line"><span class="params">  PLIST_ENTRY ListHead,</span></span><br><span class="line"><span class="params">  PLIST_ENTRY Entry</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>RemoveEntryList()</code>：从链表中删除指定节点。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BOOLEAN <span class="title function_">RemoveEntryList</span><span class="params">(</span></span><br><span class="line"><span class="params">  PLIST_ENTRY Entry</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>RemoveHeadList()</code>&#x2F;<code>RemoveTailList()</code>：移除链表头部第一个（最后一个）元素。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PLIST_ENTRY <span class="title function_">RemoveHeadList</span><span class="params">(PLIST_ENTRY ListHead)</span>;</span><br><span class="line">PLIST_ENTRY <span class="title function_">RemoveTailList</span><span class="params">(PLIST_ENTRY ListHead)</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>IsListEmpty()</code>：检查链表是否为空。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOLEAN <span class="title function_">IsListEmpty</span><span class="params">(PLIST_ENTRY ListHead)</span>;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="通用平衡树框架（RTL-GENERIC-TABLE）"><a href="#通用平衡树框架（RTL-GENERIC-TABLE）" class="headerlink" title="通用平衡树框架（RTL_GENERIC_TABLE）"></a>通用平衡树框架（RTL_GENERIC_TABLE）</h3><p><code>RTL_GENERIC_TABLE</code> 提供通用平衡树框架（Windows 早期是 Splay；Win7+ 全部切换为 AVL）,支持 <strong>按键快速查找&#x2F;插入&#x2F;删除</strong>。</p>
<p><code>RTL_GENERIC_TABLE</code> 的初始化函数 <code>RtlInitializeGenericTable</code> 定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">RtlInitializeGenericTable</span><span class="params">(</span></span><br><span class="line"><span class="params">    PRTL_GENERIC_TABLE Table,         <span class="comment">// [OUT] 指向 RTL_GENERIC_TABLE 结构体，初始化后返回表控制块</span></span></span><br><span class="line"><span class="params">    PRTL_GENERIC_COMPARE_ROUTINE CompareRoutine,  <span class="comment">// [IN] 比较函数指针：用于比较 Key 大小（必填）</span></span></span><br><span class="line"><span class="params">    PRTL_GENERIC_ALLOCATE_ROUTINE AllocateRoutine, <span class="comment">// [IN] 分配函数指针：用于为新节点分配内存（必填）</span></span></span><br><span class="line"><span class="params">    PRTL_GENERIC_FREE_ROUTINE FreeRoutine,        <span class="comment">// [IN] 释放函数指针：用于释放节点内存（必填）</span></span></span><br><span class="line"><span class="params">    PVOID TableContext                 <span class="comment">// [IN] 上下文参数（可选）：用户自定义传入，在回调函数中使用</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><code>Table</code>：用于保存初始化后的通用表结构体。你需要先定义好 <code>RTL_GENERIC_TABLE</code> 结构体，把地址传进来，内核将填充其中的指针和配置字段。</p>
</li>
<li><p><code>CompareRoutine</code>：<strong>比较函数指针</strong>，内核在插入&#x2F;查找&#x2F;删除时调用此函数以判定 Key 大小顺序。你需要实现此函数来定义排序规则，返回值为 <code>GenericLessThan</code> &#x2F; <code>GenericGreaterThan</code> &#x2F; <code>GenericEqual</code>。回调函数声明如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">RTL_GENERIC_COMPARE_RESULTS</span> <span class="params">(*PRTL_GENERIC_COMPARE_ROUTINE)</span><span class="params">(</span></span><br><span class="line"><span class="params">  PRTL_GENERIC_TABLE Table,</span></span><br><span class="line"><span class="params">  PVOID FirstStruct,</span></span><br><span class="line"><span class="params">  PVOID SecondStruct</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>AllocateRoutine</code>：<strong>分配函数指针</strong>，在插入新节点时，内核通过此函数为节点分配内存。通常传入封装好的 <code>ExAllocatePoolWithTag()</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">PVOID</span> <span class="params">(*PRTL_GENERIC_ALLOCATE_ROUTINE)</span><span class="params">(</span></span><br><span class="line"><span class="params">  PRTL_GENERIC_TABLE Table,</span></span><br><span class="line"><span class="params">  CLONG ByteSize</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>FreeRoutine</code>：<strong>释放函数指针</strong>，当删除节点时内核通过此函数释放节点内存。通常封装调用 <code>ExFreePool()</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">VOID</span> <span class="params">(*PRTL_GENERIC_FREE_ROUTINE)</span><span class="params">(</span></span><br><span class="line"><span class="params">  PRTL_GENERIC_TABLE Table,</span></span><br><span class="line"><span class="params">  PVOID Buffer</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>TableContext</code>：<strong>上下文指针</strong>，供你在比较函数 &#x2F; 分配函数内部做额外业务逻辑用（可选，可以传 <code>NULL</code>）。例如存放配置信息、同步锁、日志上下文等。</p>
</li>
</ul>
<p>另外 <code>RTL_GENERIC_TABLE</code> 提供了一系列的成员操作函数：</p>
<table>
<thead>
<tr>
<th>API</th>
<th>功能</th>
<th>复杂度</th>
</tr>
</thead>
<tbody><tr>
<td><code>RtlInsertElementGenericTable</code></td>
<td>若无重复，则插入新节点并返回指针</td>
<td>O(log N)</td>
</tr>
<tr>
<td><code>RtlLookupElementGenericTable</code></td>
<td>按键查找</td>
<td>O(log N)</td>
</tr>
<tr>
<td><code>RtlDeleteElementGenericTable</code></td>
<td>删除节点</td>
<td>O(log N)</td>
</tr>
<tr>
<td><code>RtlEnumerateGenericTable</code></td>
<td>按字典序迭代</td>
<td>O(1) 步进</td>
</tr>
<tr>
<td><code>RtlEnumerateGenericTableWithoutSplaying</code></td>
<td>枚举但不再平衡</td>
<td>Win7+ AVL 下同样平衡；保留兼容</td>
</tr>
<tr>
<td><code>RtlGetElementGenericTable</code></td>
<td>按序号 (0..N-1) 获取</td>
<td>O(N)</td>
</tr>
<tr>
<td><code>RtlNumberGenericTableElements</code></td>
<td>统计元素个数</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>RtlIsGenericTableEmpty</code></td>
<td>是否为空</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p>示例代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// =======================================</span></span><br><span class="line"><span class="comment">// 定义数据节点结构体</span></span><br><span class="line"><span class="comment">// 注意：平衡树节点头必须在首字段 (必须包含 RTL_BALANCED_LINKS)</span></span><br><span class="line"><span class="comment">// =======================================</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MY_DATA_ENTRY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    RTL_BALANCED_LINKS Links;  <span class="comment">// AVL树内部链接信息</span></span><br><span class="line">    ULONG Id;                  <span class="comment">// 主键字段，按此排序</span></span><br><span class="line">    ULONG X;                   <span class="comment">// 业务字段1</span></span><br><span class="line">    ULONG Y;                   <span class="comment">// 业务字段2</span></span><br><span class="line">&#125; MY_DATA_ENTRY, *PMY_DATA_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局通用表对象</span></span><br><span class="line">RTL_GENERIC_TABLE gTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =======================================</span></span><br><span class="line"><span class="comment">// 比较函数：用于排序/查找/去重</span></span><br><span class="line"><span class="comment">// 返回值决定二叉树排序方向</span></span><br><span class="line"><span class="comment">// =======================================</span></span><br><span class="line">RTL_GENERIC_COMPARE_RESULTS NTAPI <span class="title function_">MyCompare</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ <span class="keyword">struct</span> _RTL_GENERIC_TABLE *Table,</span></span><br><span class="line"><span class="params">    _In_ PVOID FirstStruct,</span></span><br><span class="line"><span class="params">    _In_ PVOID SecondStruct</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    PMY_DATA_ENTRY a = (PMY_DATA_ENTRY)FirstStruct;</span><br><span class="line">    PMY_DATA_ENTRY b = (PMY_DATA_ENTRY)SecondStruct;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a-&gt;Id &lt; b-&gt;Id) <span class="keyword">return</span> GenericLessThan;</span><br><span class="line">    <span class="keyword">if</span> (a-&gt;Id &gt; b-&gt;Id) <span class="keyword">return</span> GenericGreaterThan;</span><br><span class="line">    <span class="keyword">return</span> GenericEqual;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =======================================</span></span><br><span class="line"><span class="comment">// 分配函数：在插入新节点时被调用</span></span><br><span class="line"><span class="comment">// 注意：必须使用池分配内存</span></span><br><span class="line"><span class="comment">// =======================================</span></span><br><span class="line">PVOID NTAPI <span class="title function_">MyAllocate</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ <span class="keyword">struct</span> _RTL_GENERIC_TABLE *Table,</span></span><br><span class="line"><span class="params">    _In_ CLONG ByteSize</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ExAllocatePoolWithTag(NonPagedPoolNx, ByteSize, <span class="string">&#x27;TgDT&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =======================================</span></span><br><span class="line"><span class="comment">// 释放函数：在删除节点时被调用</span></span><br><span class="line"><span class="comment">// =======================================</span></span><br><span class="line">VOID NTAPI <span class="title function_">MyFree</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ <span class="keyword">struct</span> _RTL_GENERIC_TABLE *Table,</span></span><br><span class="line"><span class="params">    _In_ __drv_freesMem(Mem) _Post_invalid_ PVOID Buffer</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    ExFreePool(Buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =======================================</span></span><br><span class="line"><span class="comment">// 驱动卸载函数：清理通用表资源</span></span><br><span class="line"><span class="comment">// =======================================</span></span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(_In_ PDRIVER_OBJECT DriverObject)</span></span><br><span class="line">&#123;</span><br><span class="line">    PVOID RestartKey = <span class="literal">NULL</span>;</span><br><span class="line">    PMY_DATA_ENTRY pEntry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举删除表内所有元素，避免内存泄漏</span></span><br><span class="line">    <span class="keyword">while</span> ((pEntry = (PMY_DATA_ENTRY)RtlEnumerateGenericTable(&amp;gTable, &amp;RestartKey)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        BOOLEAN deleted = RtlDeleteElementGenericTable(&amp;gTable, pEntry);</span><br><span class="line">        UNREFERENCED_PARAMETER(deleted);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, <span class="string">&quot;Driver unloaded.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =======================================</span></span><br><span class="line"><span class="comment">// 驱动入口函数</span></span><br><span class="line"><span class="comment">// =======================================</span></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath)</span></span><br><span class="line">&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(RegistryPath);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化通用表</span></span><br><span class="line">    RtlInitializeGenericTable(&amp;gTable, MyCompare, MyAllocate, MyFree, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备测试数据</span></span><br><span class="line">    MY_DATA_ENTRY data[] = &#123;</span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">20</span> &#125;,</span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">2</span>, <span class="number">30</span>, <span class="number">40</span> &#125;,</span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">3</span>, <span class="number">50</span>, <span class="number">60</span> &#125;,</span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">4</span>, <span class="number">70</span>, <span class="number">80</span> &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入测试数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ARRAYSIZE(data); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        BOOLEAN newElement;</span><br><span class="line">        RtlInsertElementGenericTable(&amp;gTable, &amp;data[i], <span class="keyword">sizeof</span>(MY_DATA_ENTRY), &amp;newElement);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试查找</span></span><br><span class="line">    MY_DATA_ENTRY search = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    search.Id = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    PMY_DATA_ENTRY found = (PMY_DATA_ENTRY)RtlLookupElementGenericTable(&amp;gTable, &amp;search);</span><br><span class="line">    <span class="keyword">if</span> (found)</span><br><span class="line">    &#123;</span><br><span class="line">        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, <span class="string">&quot;Found: Id=%lu X=%lu Y=%lu\n&quot;</span>, found-&gt;Id, found-&gt;X, found-&gt;Y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有元素</span></span><br><span class="line">    PVOID RestartKey = <span class="literal">NULL</span>;</span><br><span class="line">    PMY_DATA_ENTRY pEntry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((pEntry = (PMY_DATA_ENTRY)RtlEnumerateGenericTable(&amp;gTable, &amp;RestartKey)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, <span class="string">&quot;Enumerate: Id=%lu X=%lu Y=%lu\n&quot;</span>, pEntry-&gt;Id, pEntry-&gt;X, pEntry-&gt;Y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="常用-API-1"><a href="#常用-API-1" class="headerlink" title="常用 API"></a>常用 API</h2><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>Windows 内核模式下有专门的内存申请&#x2F;释放函数 <code>ExAllocatePool</code>&#x2F;<code>ExAllocatePoolWithTag</code> 和 <code>ExFreePool</code>&#x2F;<code>ExFreePoolWithTag</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PVOID <span class="title function_">ExAllocatePoolWithTag</span><span class="params">(</span></span><br><span class="line"><span class="params">  POOL_TYPE PoolType,</span></span><br><span class="line"><span class="params">  SIZE_T NumberOfBytes,</span></span><br><span class="line"><span class="params">  ULONG Tag</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">ExFreePoolWithTag</span><span class="params">(</span></span><br><span class="line"><span class="params">  PVOID P,</span></span><br><span class="line"><span class="params">  ULONG Tag</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>PoolType</code>：选择使用的内存池类型，常见的内存池有：<ul>
<li><code>PagedPool</code>：分页池，内存可被交换到磁盘。</li>
<li><code>NonPagedPool</code>：非分页池，驻留物理内存，可执行。</li>
</ul>
</li>
<li><code>NumberOfBytes</code>：要申请的字节数，任意长度。</li>
<li><code>Tag</code>：内存标签，Windbg <code>!poolused</code>、<code>!pooltag</code> 可用此标签进行泄漏、溢出排查。<code>ExAllocatePool</code> 和 <code>ExFreePool</code> 函数缺少这个参数。</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>在内核中通常使用 <code>PsCreateSystemThread</code> 函数创建内核线程，该函数原型如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">PsCreateSystemThread</span><span class="params">(</span></span><br><span class="line"><span class="params">  OUT PHANDLE ThreadHandle,         <span class="comment">// [输出] 线程句柄，成功返回后需 ZwClose 关闭</span></span></span><br><span class="line"><span class="params">  IN ACCESS_MASK DesiredAccess,     <span class="comment">// [输入] 访问权限，通常填写 THREAD_ALL_ACCESS</span></span></span><br><span class="line"><span class="params">  IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,  <span class="comment">// [输入] 对象属性，内核线程一般填 NULL</span></span></span><br><span class="line"><span class="params">  IN HANDLE ProcessHandle OPTIONAL, <span class="comment">// [输入] 进程句柄，内核线程填 NULL (表示系统进程)</span></span></span><br><span class="line"><span class="params">  OUT PCLIENT_ID ClientId OPTIONAL, <span class="comment">// [输出] 线程 Client ID（包含 PID/TID），一般填 NULL</span></span></span><br><span class="line"><span class="params">  IN PKSTART_ROUTINE StartRoutine,  <span class="comment">// [输入] 线程入口函数 (函数指针)</span></span></span><br><span class="line"><span class="params">  IN PVOID StartContext             <span class="comment">// [输入] 入口函数参数 (传入自定义上下文)</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><code>ThreadHandle</code>：函数成功返回时，输出新创建线程的句柄。</p>
<ul>
<li>驱动一般创建完线程立即关闭句柄，因为不需要持续持有。</li>
<li>必须在成功创建后调用 <code>ZwClose()</code> 关闭句柄，否则可能会泄漏句柄表项。</li>
<li>即使关闭句柄，线程本身仍在运行，句柄只是内核对象的一个引用。</li>
</ul>
</li>
<li><p><code>DesiredAccess</code>：指定希望线程句柄具有的访问权限。因内核线程通常不操作自身句柄，直接用 <code>THREAD_ALL_ACCESS</code> 或 0 都可。</p>
</li>
<li><p><code>ObjectAttributes</code>：定义线程对象的名称、属性等。仅极少情况才会用，例如为线程创建命名对象供调试器附加。绝大部分内核驱动开发直接传 <code>NULL</code>。</p>
</li>
<li><p><code>ProcessHandle</code>：指定新线程在哪个进程空间中运行。</p>
<ul>
<li>传 <code>NULL</code> 表示创建的是内核线程（属于系统进程 <code>System</code>，PID&#x3D;4）。</li>
<li>若传入用户进程句柄，则创建用户进程中的远程线程。</li>
</ul>
</li>
<li><p><code>ClientId</code>：可选输出参数，返回新创建线程的唯一标识（进程 ID + 线程 ID）。如果不需要则传 <code>NULL</code> 即可。</p>
</li>
<li><p><code>StartRoutine</code>：线程的入口函数指针（回调函数），函数原型为：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOID <span class="title function_">StartRoutine</span><span class="params">(PVOID StartContext)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>必须确保该函数永远不返回，最后用 <code>PsTerminateSystemThread()</code> 主动结束线程。</li>
<li><code>StartContext</code> 参数由第七个参数传入，方便传递上下文数据。</li>
</ul>
</li>
<li><p><code>StartContext</code>：传入给入口函数的自定义参数，通常为结构体指针或简单数据，用于向新线程传递启动上下文信息（如配置、句柄、共享内存等）。</p>
</li>
</ul>
<p>示例代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程控制结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MY_THREAD_CONTEXT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    HANDLE ThreadHandle;</span><br><span class="line">    PETHREAD ThreadObject;</span><br><span class="line">    <span class="keyword">volatile</span> BOOLEAN ShouldStop;  <span class="comment">// 控制退出标志</span></span><br><span class="line">    ULONG Parameter;              <span class="comment">// 模拟业务参数</span></span><br><span class="line">&#125; MY_THREAD_CONTEXT, *PMY_THREAD_CONTEXT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程上下文全局变量 (可替换为动态分配)</span></span><br><span class="line">MY_THREAD_CONTEXT g_ThreadContext = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程入口函数</span></span><br><span class="line">VOID <span class="title function_">MyKernelThread</span><span class="params">(IN PVOID Context)</span></span><br><span class="line">&#123;</span><br><span class="line">    PMY_THREAD_CONTEXT ThreadCtx = (PMY_THREAD_CONTEXT)Context;</span><br><span class="line">    LARGE_INTEGER Interval;</span><br><span class="line">    Interval.QuadPart = <span class="number">-10</span> * <span class="number">1000</span> * <span class="number">1000LL</span>; <span class="comment">// 1秒</span></span><br><span class="line"></span><br><span class="line">    DbgPrint(<span class="string">&quot;内核线程启动，参数: %lu\n&quot;</span>, ThreadCtx-&gt;Parameter);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!ThreadCtx-&gt;ShouldStop)</span><br><span class="line">    &#123;</span><br><span class="line">        DbgPrint(<span class="string">&quot;线程循环执行中...\n&quot;</span>);</span><br><span class="line">        KeDelayExecutionThread(KernelMode, FALSE, &amp;Interval);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DbgPrint(<span class="string">&quot;内核线程检测到退出请求\n&quot;</span>);</span><br><span class="line">    PsTerminateSystemThread(STATUS_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建内核线程</span></span><br><span class="line">NTSTATUS <span class="title function_">StartKernelThread</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line"></span><br><span class="line">    g_ThreadContext.ShouldStop = FALSE;</span><br><span class="line">    g_ThreadContext.Parameter = <span class="number">1234</span>;  <span class="comment">// 模拟业务数据</span></span><br><span class="line"></span><br><span class="line">    status = PsCreateSystemThread(</span><br><span class="line">        &amp;g_ThreadContext.ThreadHandle,</span><br><span class="line">        THREAD_ALL_ACCESS,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        MyKernelThread,</span><br><span class="line">        &amp;g_ThreadContext</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">    &#123;</span><br><span class="line">        DbgPrint(<span class="string">&quot;创建内核线程失败: 0x%08X\n&quot;</span>, status);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用线程对象，方便后续等待退出</span></span><br><span class="line">    status = ObReferenceObjectByHandle(</span><br><span class="line">        g_ThreadContext.ThreadHandle,</span><br><span class="line">        THREAD_ALL_ACCESS,</span><br><span class="line">        *PsThreadType,</span><br><span class="line">        KernelMode,</span><br><span class="line">        (PVOID*)&amp;g_ThreadContext.ThreadObject,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    ZwClose(g_ThreadContext.ThreadHandle); <span class="comment">// 关闭句柄本身</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭线程</span></span><br><span class="line">VOID <span class="title function_">StopKernelThread</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (g_ThreadContext.ThreadObject)</span><br><span class="line">    &#123;</span><br><span class="line">        g_ThreadContext.ShouldStop = TRUE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待线程退出</span></span><br><span class="line">        KeWaitForSingleObject(</span><br><span class="line">            g_ThreadContext.ThreadObject,</span><br><span class="line">            Executive,</span><br><span class="line">            KernelMode,</span><br><span class="line">            FALSE,</span><br><span class="line">            <span class="literal">NULL</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        ObDereferenceObject(g_ThreadContext.ThreadObject);</span><br><span class="line">        g_ThreadContext.ThreadObject = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        DbgPrint(<span class="string">&quot;内核线程已成功退出并释放资源\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动入口</span></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)</span></span><br><span class="line">&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(RegistryPath);</span><br><span class="line">    DbgPrint(<span class="string">&quot;驱动加载\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(StartKernelThread()))</span><br><span class="line">    &#123;</span><br><span class="line">        DbgPrint(<span class="string">&quot;内核线程创建失败，驱动加载终止\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载例程</span></span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span><br><span class="line">&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(DriverObject);</span><br><span class="line">    DbgPrint(<span class="string">&quot;驱动卸载，准备停止线程\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    StopKernelThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="驱动隐藏"><a href="#驱动隐藏" class="headerlink" title="驱动隐藏"></a>驱动隐藏</h1><h2 id="隐藏思路"><a href="#隐藏思路" class="headerlink" title="隐藏思路"></a>隐藏思路</h2><p>在 Windows 内核中，驱动模块在系统内部存在两个最关键的暴露点：</p>
<ul>
<li><code>PsLoadedModuleList</code>：系统全局模块双向链表（记录所有已加载驱动模块）</li>
<li><code>DriverObject</code> 结构体：系统所有已注册的驱动对象（包含驱动模块信息）</li>
</ul>
<p>因此隐藏的本质是：</p>
<ul>
<li>从 <code>PsLoadedModuleList</code> 断链 → 让系统模块枚举 API 查不到</li>
<li>抹除 <code>DriverObject</code> 内关键字段 → 让安全软件和调试器无法逆推出模块信息</li>
</ul>
<h2 id="隐藏流程"><a href="#隐藏流程" class="headerlink" title="隐藏流程"></a>隐藏流程</h2><ol>
<li><strong>延迟隐藏逻辑</strong> ：如果在 <code>DriverEntry()</code> 阶段立即隐藏，可能会因为内核后续调用尚未完成而引发异常。这是因为驱动加载的后续流程可能会用到 <code>DriverObject</code> 结构体中一些对象。因此我们可以<strong>启动一个内核线程，延迟约 100ms 后再执行隐藏逻辑</strong>。</li>
<li><strong>断链模块表</strong> ：遍历 <code>PsLoadedModuleList</code>，逐个对比 <code>BaseDllName</code> 与目标模块名。找到后执行 <code>RemoveEntryList()</code> 完成断链。</li>
<li><strong>筛选合法伪造模块</strong> ：在遍历链表时顺便记录第一个合法存在的其它模块节点。该节点用作伪造用 <code>DriverSection</code>。</li>
<li><strong>定位 DriverObject</strong> ：使用内核 API <code>ObReferenceObjectByName()</code> 定位目标驱动的 <code>DriverObject</code>。</li>
<li><strong>抹除与伪造</strong> ：将 <code>DriverInit</code>、<code>DriverSection</code>、<code>Type</code> 字段抹除或伪造。其中 <code>DriverSection</code> 需要执行前面筛选的合法 <code>DriverSection</code>，防止安全软件在扫描 <code>DriverObject-&gt;DriverSection</code> 时蓝屏。</li>
</ol>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// =======================</span></span><br><span class="line"><span class="comment">// 精简版 KLDR_DATA_TABLE_ENTRY (省略部分字段)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 注意：这里用简化版结构体，</span></span><br><span class="line"><span class="comment">// 实际项目中可用 Windbg dt命令导出完整结构体以提升兼容性</span></span><br><span class="line"><span class="comment">// =======================</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KLDR_DATA_TABLE_ENTRY</span> &#123;</span></span><br><span class="line">    LIST_ENTRY InLoadOrderLinks;</span><br><span class="line">    ULONG __Undefined1;</span><br><span class="line">    ULONG __Undefined2;</span><br><span class="line">    ULONG __Undefined3;</span><br><span class="line">    ULONG NonPagedDebugInfo;</span><br><span class="line">    ULONG DllBase;</span><br><span class="line">    ULONG EntryPoint;</span><br><span class="line">    ULONG SizeOfImage;</span><br><span class="line">    UNICODE_STRING FullDllName;</span><br><span class="line">    UNICODE_STRING BaseDllName;</span><br><span class="line">    ULONG Flags;</span><br><span class="line">    USHORT LoadCount;</span><br><span class="line">    USHORT __Undefined5;</span><br><span class="line">    ULONG __Undefined6;</span><br><span class="line">    ULONG CheckSum;</span><br><span class="line">    ULONG TimeDateStamp;</span><br><span class="line">    <span class="comment">// ...(后续字段省略)</span></span><br><span class="line">&#125; KLDR_DATA_TABLE_ENTRY, *PKLDR_DATA_TABLE_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =======================</span></span><br><span class="line"><span class="comment">// 目标模块名称与DriverObject名称 (请根据目标驱动修改)</span></span><br><span class="line"><span class="comment">// =======================</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIDE_MODULE_NAME <span class="string">L&quot;TestDriver.sys&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIDE_DRIVER_OBJECT_NAME <span class="string">L&quot;\\Driver\\TestDriver&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐藏线程句柄</span></span><br><span class="line">HANDLE g_HideThreadHandle = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =======================</span></span><br><span class="line"><span class="comment">// 模块断链 + 伪造 DriverSection + DriverObject隐藏 统一逻辑</span></span><br><span class="line"><span class="comment">// =======================</span></span><br><span class="line">VOID <span class="title function_">UnlinkAndHide</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取 PsLoadedModuleList 链表头</span></span><br><span class="line">    PKLDR_DATA_TABLE_ENTRY pLdr = (PKLDR_DATA_TABLE_ENTRY)PsLoadedModuleList-&gt;Flink;</span><br><span class="line">    PLIST_ENTRY PsLoadedModuleListHead = pLdr-&gt;InLoadOrderLinks.Blink-&gt;Flink;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成目标模块名字符串用于匹配</span></span><br><span class="line">    UNICODE_STRING targetName;</span><br><span class="line">    RtlInitUnicodeString(&amp;targetName, HIDE_MODULE_NAME);</span><br><span class="line"></span><br><span class="line">    PKLDR_DATA_TABLE_ENTRY RemovedEntry = <span class="literal">NULL</span>;  <span class="comment">// 记录被断链的模块节点</span></span><br><span class="line">    PKLDR_DATA_TABLE_ENTRY FakeEntry = <span class="literal">NULL</span>;     <span class="comment">// 记录合法伪造用模块</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历模块链表</span></span><br><span class="line">    PLIST_ENTRY pList = PsLoadedModuleListHead-&gt;Flink;</span><br><span class="line">    <span class="keyword">while</span> (pList != PsLoadedModuleListHead)</span><br><span class="line">    &#123;</span><br><span class="line">        PKLDR_DATA_TABLE_ENTRY pEntry = CONTAINING_RECORD(pList, KLDR_DATA_TABLE_ENTRY, InLoadOrderLinks);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只判断 BaseDllName.Length 非 0 简化合法性判定</span></span><br><span class="line">        <span class="keyword">if</span> (pEntry-&gt;BaseDllName.Length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pList = pList-&gt;Flink;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否为要隐藏的目标模块</span></span><br><span class="line">        <span class="keyword">if</span> (RtlCompareUnicodeString(&amp;pEntry-&gt;BaseDllName, &amp;targetName, TRUE) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            DbgPrint(<span class="string">&quot;找到目标模块: %wZ -&gt; 执行断链隐藏\n&quot;</span>, &amp;pEntry-&gt;BaseDllName);</span><br><span class="line">            RemoveEntryList(&amp;pEntry-&gt;InLoadOrderLinks);</span><br><span class="line">            RemovedEntry = pEntry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (FakeEntry == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 记录第一个合法可伪造模块作为 DriverSection 替代项</span></span><br><span class="line">            FakeEntry = pEntry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pList = pList-&gt;Flink;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========================</span></span><br><span class="line">    <span class="comment">// DriverObject抹除及 DriverSection伪造逻辑</span></span><br><span class="line">    <span class="comment">// ========================</span></span><br><span class="line">    UNICODE_STRING drvName;</span><br><span class="line">    RtlInitUnicodeString(&amp;drvName, HIDE_DRIVER_OBJECT_NAME);</span><br><span class="line"></span><br><span class="line">    PDRIVER_OBJECT pTargetDriver = <span class="literal">NULL</span>;</span><br><span class="line">    NTSTATUS status = ObReferenceObjectByName(</span><br><span class="line">        &amp;drvName,</span><br><span class="line">        OBJ_CASE_INSENSITIVE,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        *IoDriverObjectType,</span><br><span class="line">        KernelMode,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        (PVOID*)&amp;pTargetDriver</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (NT_SUCCESS(status))</span><br><span class="line">    &#123;</span><br><span class="line">        DbgPrint(<span class="string">&quot;成功定位 DriverObject，执行隐藏逻辑\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 抹除关键字段 (防止逆向工具利用)</span></span><br><span class="line">        pTargetDriver-&gt;DriverInit = <span class="literal">NULL</span>;</span><br><span class="line">        pTargetDriver-&gt;Type = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 伪造合法 DriverSection 避免蓝屏</span></span><br><span class="line">        <span class="keyword">if</span> (FakeEntry != <span class="literal">NULL</span>)</span><br><span class="line">            pTargetDriver-&gt;DriverSection = FakeEntry;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 减少 ObReferenceObjectByName 增加的引用次数</span></span><br><span class="line">        ObDereferenceObject(pTargetDriver);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        DbgPrint(<span class="string">&quot;ObReferenceObjectByName 获取 DriverObject 失败: 0x%08X\n&quot;</span>, status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =======================</span></span><br><span class="line"><span class="comment">// 延迟隐藏线程逻辑 (核心隐藏动作在此执行)</span></span><br><span class="line"><span class="comment">// =======================</span></span><br><span class="line">VOID <span class="title function_">HideThreadProc</span><span class="params">(PVOID StartContext)</span></span><br><span class="line">&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(StartContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延迟 100ms 保证系统加载流程稳定</span></span><br><span class="line">    LARGE_INTEGER interval;</span><br><span class="line">    interval.QuadPart = <span class="number">-10</span> * <span class="number">1000</span> * <span class="number">100LL</span>; <span class="comment">// 100毫秒延迟</span></span><br><span class="line"></span><br><span class="line">    DbgPrint(<span class="string">&quot;隐藏线程启动，延迟 100ms 后执行隐藏流程\n&quot;</span>);</span><br><span class="line">    KeDelayExecutionThread(KernelMode, FALSE, &amp;interval);</span><br><span class="line"></span><br><span class="line">    UnlinkAndHide();</span><br><span class="line"></span><br><span class="line">    DbgPrint(<span class="string">&quot;隐藏逻辑完成，退出隐藏线程\n&quot;</span>);</span><br><span class="line">    PsTerminateSystemThread(STATUS_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =======================</span></span><br><span class="line"><span class="comment">// 驱动卸载逻辑</span></span><br><span class="line"><span class="comment">// =======================</span></span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span><br><span class="line">&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(DriverObject);</span><br><span class="line">    DbgPrint(<span class="string">&quot;驱动卸载完成\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =======================</span></span><br><span class="line"><span class="comment">// 驱动入口逻辑</span></span><br><span class="line"><span class="comment">// =======================</span></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)</span></span><br><span class="line">&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(RegistryPath);</span><br><span class="line">    DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line"></span><br><span class="line">    DbgPrint(<span class="string">&quot;驱动加载，准备启动隐藏线程\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    NTSTATUS status = PsCreateSystemThread(</span><br><span class="line">        &amp;g_HideThreadHandle,</span><br><span class="line">        THREAD_ALL_ACCESS,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">        HideThreadProc,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">    &#123;</span><br><span class="line">        DbgPrint(<span class="string">&quot;创建隐藏线程失败: 0x%08X\n&quot;</span>, status);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ZwClose(g_HideThreadHandle);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="驱动通信"><a href="#驱动通信" class="headerlink" title="驱动通信"></a>驱动通信</h1><h2 id="设备对象"><a href="#设备对象" class="headerlink" title="设备对象"></a>设备对象</h2><p>绝大多数情况下，一个内核驱动如果没有创建任何设备对象 (DeviceObject)，那么用户态（Ring3）无法直接与该驱动通信。这是因为设备对象是内核通信入口，<code>CreateFile</code> &#x2F; <code>DeviceIoControl</code> &#x2F; <code>ReadFile</code> &#x2F; <code>WriteFile</code> 等通信 API 只能打开设备对象。</p>
<p>设备对象主要有三类：</p>
<ul>
<li><strong>PDO（Physical Device Object）</strong> ：总线驱动创建，表示物理设备本身的存在性。例如 USB、PCI、SATA 控制器、蓝牙模块等。PDO 只描述：“有这么个硬件挂上来了”，不控制它如何工作。</li>
<li><strong>FDO（Functional Device Object）</strong> ：功能驱动创建，负责控制硬件功能、提供核心业务逻辑。FDO 负责解释 IRP 请求、控制硬件寄存器、管理协议栈、提供用户空间接口，真正把硬件功能带给系统。</li>
<li><strong>Filter Device Object</strong> ：过滤驱动创建，可插在 FDO 上下两侧，负责监控、修改、拦截 I&#x2F;O 请求，属于透明扩展层。它不控制硬件，而是做中间层逻辑处理。</li>
</ul>
<p>这些设备对象彼此层叠形成的一条逻辑设备处理链。用户与设备交互的数据在 I&#x2F;O 层叠栈中的设备对象中层层转发，每一层都可以可以拦截、监控、修改、阻断用户请求。这种结构被称为 <strong>I&#x2F;O 层叠栈（Stacked Device Stack）</strong>。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">用户 I/O 请求</span><br><span class="line">    ↓</span><br><span class="line">[Filter Device (Upper Filter)]</span><br><span class="line">    ↓</span><br><span class="line">[Functional Device (FDO)]</span><br><span class="line">    ↓</span><br><span class="line">[Filter Device (Lower Filter)]</span><br><span class="line">    ↓</span><br><span class="line">[Physical Device (PDO)]</span><br><span class="line">    ↓</span><br><span class="line">硬件</span><br></pre></td></tr></table></figure></div>

<p>不过大多数普通第三方内核驱动开发者实际上写的都是类似 <strong>FDO 或 Filter</strong>，<strong>PDO 只能由 Bus Driver 创建</strong>（通常系统自带）。</p>
<table>
<thead>
<tr>
<th>设备类型</th>
<th>PDO 创建者</th>
<th>FDO 创建者</th>
<th>Filter 创建者</th>
</tr>
</thead>
<tbody><tr>
<td>USB 存储</td>
<td>USB Hub 驱动</td>
<td>UAS 驱动（如 usbstor.sys）</td>
<td>杀毒软件过滤层</td>
</tr>
<tr>
<td>网卡</td>
<td>PCI Bus 驱动</td>
<td>NIC 功能驱动</td>
<td>防火墙、抓包驱动</td>
</tr>
<tr>
<td>虚拟设备</td>
<td>Root Enumerator</td>
<td>虚拟驱动</td>
<td>监控、调试工具</td>
</tr>
</tbody></table>
<p><strong>设备对象</strong>与<strong>驱动对象</strong>的关系：</p>
<ul>
<li>一个<strong>驱动</strong>可以<strong>创建</strong>（ <code>IoCreateDevice</code>）或<strong>附加</strong>（<code>IoAttachDevice</code>）多个<strong>设备对象</strong>，用于负责<strong>处理和过滤</strong>多个设备的消息。</li>
<li>一个<strong>物理设备</strong>可以绑定多个<strong>设备对象</strong>，这些设备对象形成了一个<strong>设备对象堆栈</strong>，可以层层过滤用户程序向设备发送的消息。</li>
</ul>
<h3 id="设备对象定义"><a href="#设备对象定义" class="headerlink" title="设备对象定义"></a>设备对象定义</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_OBJECT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SHORT Type;  <span class="comment">// 内核对象类型标识，固定为0x03表示DEVICE_OBJECT类型</span></span><br><span class="line">    USHORT Size;  <span class="comment">// 结构体大小（字节），不同版本Windows大小略有不同，典型为0xB8</span></span><br><span class="line">    LONG ReferenceCount;  <span class="comment">// 内核内部引用计数，自动维护，表示被多少模块或线程引用</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DRIVER_OBJECT</span>* <span class="title">DriverObject</span>;</span>  <span class="comment">// 📌当前设备对象所属的驱动对象指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_OBJECT</span>* <span class="title">NextDevice</span>;</span>  <span class="comment">// 📌同一个驱动下多个设备对象通过NextDevice组成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_OBJECT</span>* <span class="title">AttachedDevice</span>;</span>  <span class="comment">// 📌指向附加在本设备对象上的过滤设备对象（设备堆叠时使用）</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IRP</span>* <span class="title">CurrentIrp</span>;</span>  <span class="comment">// 当前处理的IRP，仅老式串行StartIo驱动模型下使用，绝大多数驱动不用管</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_TIMER</span>* <span class="title">Timer</span>;</span>  <span class="comment">// 设备专用I/O定时器指针，通过IoInitializeTimer注册，支持周期性回调</span></span><br><span class="line"></span><br><span class="line">    ULONG Flags;  <span class="comment">// 📌设备标志控制设备的I/O模型和电源行为，常见有：DO_BUFFERED_IO（缓冲IO）、DO_DIRECT_IO（直接IO）、DO_POWER_PAGABLE（分页支持）</span></span><br><span class="line">    ULONG Characteristics;  <span class="comment">// 设备特性标志，控制设备特性行为，例如FILE_REMOVABLE_MEDIA（可移动介质）、FILE_READ_ONLY_DEVICE（只读设备），普通控制驱动一般填0</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">VPB</span>* <span class="title">Vpb</span>;</span>  <span class="comment">// 卷参数块，仅文件系统与存储类驱动使用，普通控制型驱动恒为NULL</span></span><br><span class="line"></span><br><span class="line">    VOID* DeviceExtension;  <span class="comment">// 📌设备扩展区，驱动自定义业务数据区，创建设备时指定大小并在此区域挂载私有结构体</span></span><br><span class="line"></span><br><span class="line">    ULONG DeviceType;  <span class="comment">// 📌设备类型，定义设备类别，如FILE_DEVICE_UNKNOWN（控制型驱动通用）、FILE_DEVICE_DISK、FILE_DEVICE_NETWORK等</span></span><br><span class="line">    CHAR StackSize;  <span class="comment">// 📌设备栈深度，表示此设备在过滤栈中的层数，每附加一层过滤器栈自动+1</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ListEntry</span>;</span> <span class="class"><span class="keyword">struct</span> _<span class="title">WAIT_CONTEXT_BLOCK</span> <span class="title">Wcb</span>;</span> &#125; Queue;  <span class="comment">// 内核内部用队列或DMA上下文，极少数底层硬件驱动使用</span></span><br><span class="line"></span><br><span class="line">    ULONG AlignmentRequirement;  <span class="comment">// 设备I/O缓冲区内存对齐要求，DMA设备特别关注对齐要求，普通驱动为默认对齐</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KDEVICE_QUEUE</span> <span class="title">DeviceQueue</span>;</span>  <span class="comment">// 串行I/O请求队列，主要用于串口、磁带等硬件控制型串行设备</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KDPC</span> <span class="title">Dpc</span>;</span>  <span class="comment">// 延迟过程调用对象，用于中断下半部处理逻辑，配合ISR分离快速中断和实际数据处理</span></span><br><span class="line">    ULONG ActiveThreadCount;  <span class="comment">// 正在处理本设备对象IRP的线程数量，内核自动管理，用于内部同步统计</span></span><br><span class="line"></span><br><span class="line">    VOID* SecurityDescriptor;  <span class="comment">// 设备对象安全描述符，定义DACL权限控制，控制型驱动通常填NULL表示默认安全性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KEVENT</span> <span class="title">DeviceLock</span>;</span>  <span class="comment">// 内部同步锁，配合串行I/O等同步场景控制并发访问</span></span><br><span class="line"></span><br><span class="line">    USHORT SectorSize;  <span class="comment">// 扇区大小，存储设备使用，非存储型控制驱动通常为0</span></span><br><span class="line">    USHORT Spare1;  <span class="comment">// 保留字段，未来扩展用</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DEVOBJ_EXTENSION</span>* <span class="title">DeviceObjectExtension</span>;</span>  <span class="comment">// 内核扩展区，供PNP、电源管理等系统模块使用，驱动一般无需关心</span></span><br><span class="line">    VOID* Reserved;  <span class="comment">// 预留字段</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><code>DriverObject</code>：所属驱动的 <code>DriverObject</code>，用于找到<strong>设备对象所属的驱动对象</strong>。</p>
</li>
<li><p><code>NextDevice</code>：将<strong>一个驱动所属的所有设备对象</strong> <code>DriverObject</code> 串联成一个单向链表，链表头为 <code>DriverObject-&gt;DeviceObject</code>。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DriverObject</span><br><span class="line">  |</span><br><span class="line">  +--&gt; DeviceObject1 --&gt; DeviceObject2 --&gt; DeviceObject3 --&gt; NULL</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>AttachedDevice</code>：<code>AttachedDevice</code> 构成的是<strong>跨驱动</strong>的 <strong>I&#x2F;O 层叠栈（Stacked Device Stack）</strong>。它让不同驱动可以挂接在同一设备上层，共同参与 I&#x2F;O 请求的流转与处理。设备对象的 <code>AttachedDevice</code> 指向<strong>下一层</strong>的设备对象。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">IRP 入口</span><br><span class="line">   ↓</span><br><span class="line">DeviceObject_Filter3  &lt;-- 过滤层3（最上层）</span><br><span class="line">   ↓ AttachedDevice</span><br><span class="line">DeviceObject_Filter2  &lt;-- 过滤层2</span><br><span class="line">   ↓ AttachedDevice</span><br><span class="line">DeviceObject_Filter1  &lt;-- 过滤层1</span><br><span class="line">   ↓ AttachedDevice</span><br><span class="line">DeviceObject_Functional (FDO)  &lt;-- 功能设备对象 (目标核心驱动)</span><br><span class="line">   ↓ AttachedDevice</span><br><span class="line">DeviceObject_PDO  &lt;-- 物理设备对象 (底层物理设备)</span><br><span class="line">   ↓ AttachedDevice</span><br><span class="line">NULL</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>StackSize</code>：从当前设备对象所在的位置，往下直到整个设备栈的最底层（PDO）为止，所需要的 IRP 栈帧数量总和。换句话说：<strong>当前设备对象在整个 IRP 传递链中，自己算在内，往下有多少设备对象要参与。</strong></p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">用户层 I/O 请求</span><br><span class="line">    ↓</span><br><span class="line">[DeviceObject_Filter3]  StackSize=5</span><br><span class="line">    ↓</span><br><span class="line">[DeviceObject_Filter2]  StackSize=4</span><br><span class="line">    ↓</span><br><span class="line">[DeviceObject_Filter1]  StackSize=3</span><br><span class="line">    ↓</span><br><span class="line">[DeviceObject_FDO]      StackSize=2</span><br><span class="line">    ↓</span><br><span class="line">[DeviceObject_PDO]      StackSize=1</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="设备对象创建"><a href="#设备对象创建" class="headerlink" title="设备对象创建"></a>设备对象创建</h3><p>在内核中，设备对象通常通过 <code>IoCreateDevice</code> 函数进行创建，该函数由 I&#x2F;O 管理器提供，用于在 Object Manager 中注册新的设备对象，并分配相应的内存与扩展数据区。以下是函数原型：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">IoCreateDevice</span><span class="params">(</span></span><br><span class="line"><span class="params">  IN PDRIVER_OBJECT DriverObject,           <span class="comment">// [输入] 驱动对象指针</span></span></span><br><span class="line"><span class="params">  IN ULONG DeviceExtensionSize,             <span class="comment">// [输入] 设备扩展区大小（字节数）</span></span></span><br><span class="line"><span class="params">  IN PUNICODE_STRING DeviceName OPTIONAL,   <span class="comment">// [输入] 设备名称（Object Manager 路径）</span></span></span><br><span class="line"><span class="params">  IN DEVICE_TYPE DeviceType,                <span class="comment">// [输入] 设备类型标识</span></span></span><br><span class="line"><span class="params">  IN ULONG DeviceCharacteristics,           <span class="comment">// [输入] 设备特性标志</span></span></span><br><span class="line"><span class="params">  IN BOOLEAN Exclusive,                     <span class="comment">// [输入] 是否独占设备</span></span></span><br><span class="line"><span class="params">  OUT PDEVICE_OBJECT *DeviceObject          <span class="comment">// [输出] 返回新建的设备对象指针</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>DriverObject</code>：指定所属驱动对象，通常传入 <code>DriverEntry</code> 函数中的 <code>PDRIVER_OBJECT</code>，用于将新创建的设备对象挂接到驱动对象下，由驱动统一管理。</li>
<li><code>DeviceExtensionSize</code>：指定设备扩展区的大小（以字节为单位）。内核会在分配 <code>DEVICE_OBJECT</code> 结构时附加这一段额外空间，驱动可通过 <code>DeviceObject-&gt;DeviceExtension</code> 访问此区域，用于存储与设备实例相关的自定义上下文信息。如果不需要扩展区则传 <code>0</code>。</li>
<li><code>DeviceName</code>：指定设备对象的命名路径（完整的 Object Manager 路径），如 <code>\Device\MyDevice</code>。如果传入 <code>NULL</code>，则创建匿名设备对象，不注册命名空间，不可通过名称访问；一般控制型驱动需提供命名，供用户态程序通过符号链接访问。</li>
<li><code>DeviceType</code>：指定设备对象类型，用于指明设备类别，内核使用该类型决定某些默认行为。例如：<ul>
<li><code>FILE_DEVICE_UNKNOWN</code>：<strong>默认通用类型</strong>，绝大多数控制型驱动使用；</li>
<li><code>FILE_DEVICE_DISK</code>：磁盘设备；</li>
<li><code>FILE_DEVICE_NETWORK</code>：网络设备；</li>
<li><code>FILE_DEVICE_FILE_SYSTEM</code>：文件系统设备；</li>
<li>其他类型视具体功能选用。</li>
</ul>
</li>
<li><code>DeviceCharacteristics</code>：指定设备特性标志，用于控制设备的附加行为。常见取值包括：<ul>
<li><code>FILE_DEVICE_SECURE_OPEN</code>：启用安全性访问检查；</li>
<li><code>FILE_REMOVABLE_MEDIA</code>：表示可移动介质；</li>
<li>一般自定义控制型驱动可传 <code>0</code>，表示不声明任何特殊设备行为，内核使用默认通用行为对待该设备对象。</li>
</ul>
</li>
<li><code>Exclusive</code>：指定设备对象是否独占访问。当设为 <code>TRUE</code> 时，系统仅允许一个线程&#x2F;进程打开该设备对象，后续打开请求会失败（返回 <code>STATUS_DEVICE_BUSY</code>）。通常设为 <code>FALSE</code>，允许并发访问。</li>
<li><code>DeviceObject</code>：输出参数，返回成功创建的设备对象指针。驱动可通过此指针访问扩展区、设置属性，并在卸载时配合 <code>IoDeleteDevice</code> 正确释放内存资源。</li>
</ul>
<p>然而 <code>IoCreateDevice</code> 只负责把设备对象的内存空间从内核池分配出来，做了最基本初始化，但没有对外暴露接口。因此我们还要<strong>注册符号链接</strong>建立 Win32 层访问路径，确保用户态能够通过 <code>CreateFile()</code> 调用访问。</p>
<p>例如我们将设备名为 <code>\Device\MyDevice</code> 的设备通过 <code>IoCreateSymbolicLink</code> 创建了一个到 <code>\??\MyDevice</code> 的软连接：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设备命名：注册到 Object Manager 命名空间下</span></span><br><span class="line">UNICODE_STRING deviceName = RTL_CONSTANT_STRING(<span class="string">L&quot;\\Device\\MyDevice&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 符号链接命名：供用户态 CreateFile 使用 (Win32 层访问路径)</span></span><br><span class="line">UNICODE_STRING symLinkName = RTL_CONSTANT_STRING(<span class="string">L&quot;\\??\\MyDevice&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建符号链接 (供用户态访问)</span></span><br><span class="line">status = IoCreateSymbolicLink(&amp;symLinkName, &amp;deviceName);</span><br><span class="line"><span class="keyword">if</span> (!NT_SUCCESS(status)) &#123;</span><br><span class="line">    DbgPrint(<span class="string">&quot;IoCreateSymbolicLink 创建符号链接失败: 0x%08X\n&quot;</span>, status);</span><br><span class="line">    IoDeleteDevice(DeviceObject);  <span class="comment">// 创建失败时需回滚释放设备对象</span></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>那么用户程序就可以通过设备路径 <code>\\.\MyDevice</code> 来操作这个设备了。</p>
<p>最后我们需要对 <code>DeviceObject-&gt;Flags</code> <strong>清除初始化标志</strong>。这一步实际上是为了兼容一些老的操作系统，这一类操作系统不会自动去除初始化标志，导致设备对象创建之后始终处于未初始化状态，导致一些对设备的操作失败。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设备初始化完成，清除初始化标志 (兼容老系统)</span></span><br><span class="line">DeviceObject-&gt;Flags &amp;= ~DO_DEVICE_INITIALIZING;</span><br></pre></td></tr></table></figure></div>

<p>示例代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设备扩展结构体示例（自定义业务数据）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MY_DEVICE_EXTENSION</span> &#123;</span></span><br><span class="line">    ULONG ExampleField;</span><br><span class="line">&#125; MY_DEVICE_EXTENSION, *PMY_DEVICE_EXTENSION;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载例程声明</span></span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT DriverObject)</span>;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)</span></span><br><span class="line">&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(RegistryPath);</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    PDEVICE_OBJECT DeviceObject = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设备命名：注册到 Object Manager 命名空间下</span></span><br><span class="line">    UNICODE_STRING deviceName = RTL_CONSTANT_STRING(<span class="string">L&quot;\\Device\\MyDevice&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 符号链接命名：供用户态 CreateFile 使用 (Win32 层访问路径)</span></span><br><span class="line">    UNICODE_STRING symLinkName = RTL_CONSTANT_STRING(<span class="string">L&quot;\\??\\MyDevice&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建设备对象</span></span><br><span class="line">    status = IoCreateDevice(</span><br><span class="line">        DriverObject,                   <span class="comment">// 绑定到当前驱动</span></span><br><span class="line">        <span class="keyword">sizeof</span>(MY_DEVICE_EXTENSION),    <span class="comment">// 设备扩展区大小</span></span><br><span class="line">        &amp;deviceName,                    <span class="comment">// 设备名 (具名注册)</span></span><br><span class="line">        FILE_DEVICE_UNKNOWN,            <span class="comment">// 设备类型</span></span><br><span class="line">        <span class="number">0</span>,                              <span class="comment">// 设备特性 (默认传 0)</span></span><br><span class="line">        FALSE,                          <span class="comment">// 非独占 (允许并发访问)</span></span><br><span class="line">        &amp;DeviceObject                   <span class="comment">// 返回创建好的设备对象指针</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(status)) &#123;</span><br><span class="line">        DbgPrint(<span class="string">&quot;IoCreateDevice 创建设备失败: 0x%08X\n&quot;</span>, status);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建符号链接 (供用户态访问)</span></span><br><span class="line">    status = IoCreateSymbolicLink(&amp;symLinkName, &amp;deviceName);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(status)) &#123;</span><br><span class="line">        DbgPrint(<span class="string">&quot;IoCreateSymbolicLink 创建符号链接失败: 0x%08X\n&quot;</span>, status);</span><br><span class="line">        IoDeleteDevice(DeviceObject);  <span class="comment">// 创建失败时需回滚释放设备对象</span></span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设备初始化完成，清除初始化标志 (兼容老系统)</span></span><br><span class="line">    DeviceObject-&gt;Flags &amp;= ~DO_DEVICE_INITIALIZING;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册卸载例程</span></span><br><span class="line">    DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line"></span><br><span class="line">    DbgPrint(<span class="string">&quot;驱动加载成功，设备与符号链接已创建完成\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载例程 (驱动卸载时自动调用)</span></span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span><br><span class="line">&#123;</span><br><span class="line">    UNICODE_STRING symLinkName = RTL_CONSTANT_STRING(<span class="string">L&quot;\\??\\MyDevice&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除符号链接 (先删符号链接，再删设备对象)</span></span><br><span class="line">    IoDeleteSymbolicLink(&amp;symLinkName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放设备对象 (注意可能存在多个设备，需遍历释放)</span></span><br><span class="line">    PDEVICE_OBJECT DeviceObject = DriverObject-&gt;DeviceObject;</span><br><span class="line">    <span class="keyword">while</span> (DeviceObject != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PDEVICE_OBJECT NextDevice = DeviceObject-&gt;NextDevice;</span><br><span class="line">        IoDeleteDevice(DeviceObject);</span><br><span class="line">        DeviceObject = NextDevice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DbgPrint(<span class="string">&quot;驱动卸载完成，资源已释放\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="设备对象附加"><a href="#设备对象附加" class="headerlink" title="设备对象附加"></a>设备对象附加</h3><p>在 Windows 内核 I&#x2F;O 框架中，驱动可以将自己编写的设备对象附加到现有的设备对象之上，形成<strong>设备对象堆栈（Device Stack）</strong>。这种附加行为常用于开发过滤驱动、监控驱动、保护驱动、文件过滤驱动等场景。</p>
<p>内核提供 <code>IoAttachDevice</code> 或 <code>IoAttachDeviceToDeviceStack</code> 函数用于实现附加操作。</p>
<p><code>IoAttachDevice</code> 函数原型如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PDEVICE_OBJECT <span class="title function_">IoAttachDevice</span><span class="params">(</span></span><br><span class="line"><span class="params">  IN PDEVICE_OBJECT SourceDevice,   <span class="comment">// [输入] 自己新创建的设备对象</span></span></span><br><span class="line"><span class="params">  IN PUNICODE_STRING TargetDevice,  <span class="comment">// [输入] 要附加到的目标设备对象路径</span></span></span><br><span class="line"><span class="params">  OUT PDEVICE_OBJECT *AttachedTo    <span class="comment">// [输出] 实际附加成功后的目标设备对象指针</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>SourceDevice</code>：本驱动中用 <code>IoCreateDevice()</code> 创建好的设备对象，作为过滤层插入堆栈；</li>
<li><code>TargetDevice</code>：目标设备对象的全路径（如 <code>\Device\Harddisk0\DR0</code>），指定要附加到哪个设备；</li>
<li><code>AttachedTo</code>：附加成功后返回目标设备对象指针，即被附加的设备对象。也就是说附加后 <code>SourceDevice-&gt;AttachedDevice = AttachedTo</code>。</li>
</ul>
<p><code>IoAttachDeviceToDeviceStack</code> 则需要我们直接提供要被附加的设备对象，而不是设备路径，该函数定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PDEVICE_OBJECT <span class="title function_">IoAttachDeviceToDeviceStack</span><span class="params">(</span></span><br><span class="line"><span class="params">  IN PDEVICE_OBJECT SourceDevice,   <span class="comment">// [输入] 要附加的过滤设备对象 (本驱动创建)</span></span></span><br><span class="line"><span class="params">  IN PDEVICE_OBJECT TargetDevice    <span class="comment">// [输入] 目标设备对象 (被附加对象)</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><code>SourceDevice</code>：指定新创建的过滤层设备对象（一般通过 <code>IoCreateDevice()</code> 创建），将被插入到设备堆栈顶端，成为新的栈顶对象。附加成功后，该对象位于整个设备栈最顶层，优先接收 IRP 请求。</p>
</li>
<li><p><code>TargetDevice</code>：要附加的目标设备对象。<strong>系统会根据其 <code>AttachedDevice</code> 自动遍历整个设备栈，找到当前栈顶位置然后附加。</strong></p>
</li>
</ul>
<p>当完成附加后，当用户态通过 <code>CreateFile()</code> 打开设备时，虽然传入的设备路径仍然是被附加的设备对象。</p>
<p>但是由于我们在内核中通过 <code>IoAttachDeviceToDeviceStack()</code> 已经把自己的设备对象挂入了目标设备对象的 I&#x2F;O 栈顶，因此用户请求命中目标设备对象时，内核始终从栈顶开始派发 IRP。而我们的过滤设备对象就在这条栈上，所有请求自然会经过我们的驱动。</p>
<p>设备对象附加的示例代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">AttachToTargetDevice</span><span class="params">(PDEVICE_OBJECT MyDevice)</span></span><br><span class="line">&#123;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    PDEVICE_OBJECT TargetDevice = <span class="literal">NULL</span>;</span><br><span class="line">    UNICODE_STRING TargetDeviceName = RTL_CONSTANT_STRING(<span class="string">L&quot;\\Device\\Harddisk0\\DR0&quot;</span>);</span><br><span class="line"></span><br><span class="line">    status = IoGetDeviceObjectPointer(</span><br><span class="line">        &amp;TargetDeviceName,</span><br><span class="line">        FILE_READ_DATA,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        &amp;TargetDevice</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(status)) &#123;</span><br><span class="line">        DbgPrint(<span class="string">&quot;获取目标设备失败: 0x%08X\n&quot;</span>, status);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 附加到目标设备栈</span></span><br><span class="line">    PDEVICE_OBJECT AttachedTo = IoAttachDeviceToDeviceStack(MyDevice, TargetDevice);</span><br><span class="line">    <span class="keyword">if</span> (AttachedTo == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        DbgPrint(<span class="string">&quot;附加设备失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DbgPrint(<span class="string">&quot;成功附加到目标设备\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在驱动卸载的时候，我们需要在删除自己的设备对象之前先从设备栈分离。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IoDetachDevice(MyDeviceExtension-&gt;NextDevice);</span><br><span class="line">IoDeleteDevice(MyDeviceObject);</span><br></pre></td></tr></table></figure></div>

<h2 id="IRP（I-O-Request-Packet）"><a href="#IRP（I-O-Request-Packet）" class="headerlink" title="IRP（I&#x2F;O Request Packet）"></a>IRP（I&#x2F;O Request Packet）</h2><p><strong>IRP（I&#x2F;O Request Packet）</strong>是 Windows 内核 I&#x2F;O 子系统内部使用的统一请求数据结构，负责在设备驱动之间传递 I&#x2F;O 操作请求。所有内核驱动层（文件系统驱动、网络驱动、过滤驱动、控制驱动等等）之间的 I&#x2F;O 交互，都是通过 IRP 结构体完成。</p>
<h3 id="IRP-结构体"><a href="#IRP-结构体" class="headerlink" title="IRP 结构体"></a>IRP 结构体</h3><p><code>_IRP</code> 是内核 I&#x2F;O 子系统的核心数据结构，用于描述一次完整的 I&#x2F;O 请求状态与控制信息。所有 IRP 派发、过滤、传递、完成逻辑，都是围绕该结构体展开的。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0x70 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IRP</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SHORT Type;                     <span class="comment">// IRP对象标识，固定为0x06（IRP类型）</span></span><br><span class="line">    USHORT Size;                    <span class="comment">// IRP结构体大小 (当前为0x70)</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">MDL</span>* <span class="title">MdlAddress</span>;</span>        <span class="comment">// 📌内存描述列表 (用于 Direct I/O 模式时映射缓冲区)</span></span><br><span class="line"></span><br><span class="line">    ULONG Flags;                    <span class="comment">// IRP状态标志位，控制I/O管理器内部行为</span></span><br><span class="line">                                     <span class="comment">// 常见标志如：IRP_BUFFERED_IO, IRP_INPUT_OPERATION</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">IRP</span>* <span class="title">MasterIrp</span>;</span>     <span class="comment">// (分散聚集I/O使用)</span></span><br><span class="line">        LONG IrpCount;              <span class="comment">// (多IRP合并时的计数器)</span></span><br><span class="line">        VOID* SystemBuffer;         <span class="comment">// 📌(Buffered I/O 模式下的系统缓冲区指针)</span></span><br><span class="line">    &#125; AssociatedIrp;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ThreadListEntry</span>;</span> <span class="comment">// 挂接到线程 I/O 请求链的双向链表节点</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_STATUS_BLOCK</span> <span class="title">IoStatus</span>;</span>   <span class="comment">// 📌I/O 操作状态与返回值</span></span><br><span class="line"></span><br><span class="line">    CHAR RequestorMode;            <span class="comment">// 发起请求方的CPU模式：UserMode / KernelMode</span></span><br><span class="line">    UCHAR PendingReturned;         <span class="comment">// 内核内部标志，表示IRP是否挂起返回</span></span><br><span class="line">    CHAR StackCount;               <span class="comment">// 📌IRP栈总深度 (栈帧数量)</span></span><br><span class="line">    CHAR CurrentLocation;          <span class="comment">// 📌当前 IRP 栈位置 (栈帧索引)</span></span><br><span class="line"></span><br><span class="line">    UCHAR Cancel;                  <span class="comment">// 是否被请求取消 (1=正在取消)</span></span><br><span class="line">    UCHAR CancelIrql;              <span class="comment">// 取消时所处IRQL (中断优先级)</span></span><br><span class="line">    CHAR ApcEnvironment;           <span class="comment">// APC 环境信息</span></span><br><span class="line">    UCHAR AllocationFlags;         <span class="comment">// IRP分配标志 (一般由内核内部管理)</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_STATUS_BLOCK</span>* <span class="title">UserIosb</span>;</span>  <span class="comment">// 用户空间的 IO_STATUS_BLOCK 指针（异步操作返回）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KEVENT</span>* <span class="title">UserEvent</span>;</span>          <span class="comment">// 用户空间的同步事件（供异步通知）</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                VOID (*UserApcRoutine)(VOID* Context, <span class="keyword">struct</span> _IO_STATUS_BLOCK* IoStatus, ULONG Reserved);</span><br><span class="line">                                          <span class="comment">// 用户APC回调函数指针 (异步完成通知用)</span></span><br><span class="line">                VOID* IssuingProcess;    <span class="comment">// 发起IRP请求的进程 (内核内部用)</span></span><br><span class="line">            &#125;;</span><br><span class="line">            VOID* UserApcContext;        <span class="comment">// APC回调上下文参数</span></span><br><span class="line">        &#125; AsynchronousParameters;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">AllocationSize</span>;</span>  <span class="comment">// (文件系统使用: 分配文件大小)</span></span><br><span class="line">    &#125; Overlay;</span><br><span class="line"></span><br><span class="line">    VOID (*CancelRoutine)(<span class="keyword">struct</span> _DEVICE_OBJECT* DeviceObject, <span class="keyword">struct</span> _IRP* Irp);</span><br><span class="line">                                      <span class="comment">// 取消时调用的回调函数</span></span><br><span class="line"></span><br><span class="line">    VOID* UserBuffer;                <span class="comment">// 📌用户空间缓冲区 (Direct I/O 模式下映射)</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> _<span class="title">KDEVICE_QUEUE_ENTRY</span> <span class="title">DeviceQueueEntry</span>;</span> <span class="comment">// 设备队列链表节点</span></span><br><span class="line">                VOID* DriverContext[<span class="number">4</span>];   <span class="comment">// 驱动扩展上下文数据 (驱动自由使用)</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">ETHREAD</span>* <span class="title">Thread</span>;</span>      <span class="comment">// 所属线程对象指针</span></span><br><span class="line">            CHAR* AuxiliaryBuffer;        <span class="comment">// 辅助缓冲区 (文件系统扩展使用)</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ListEntry</span>;</span> <span class="comment">// 通用链表节点 (供I/O管理器组织IRP列表)</span></span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> _<span class="title">IO_STACK_LOCATION</span>* <span class="title">CurrentStackLocation</span>;</span> <span class="comment">// 📌当前IRP栈帧 (IO_STACK_LOCATION)           </span></span><br><span class="line">                ULONG PacketType;           <span class="comment">// 内部用标志</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">FILE_OBJECT</span>* <span class="title">OriginalFileObject</span>;</span> <span class="comment">// 原始文件对象</span></span><br><span class="line">        &#125; Overlay;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">KAPC</span> <span class="title">Apc</span>;</span>                  <span class="comment">// (特殊用法: 内核APC控制结构体)</span></span><br><span class="line">        VOID* CompletionKey;               <span class="comment">// (完成端口/队列扩展用)</span></span><br><span class="line">    &#125; Tail;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h4 id="I-O-层叠栈"><a href="#I-O-层叠栈" class="headerlink" title="I&#x2F;O 层叠栈"></a>I&#x2F;O 层叠栈</h4><p>由于 Windows 的<strong>设备对象</strong>组成了一个  <strong>I&#x2F;O 层叠栈（Stacked Device Stack）</strong>的结构，因此 <code>IRP</code> 为了能够在按照  <strong>I&#x2F;O 层叠栈（Stacked Device Stack）</strong>的结构回的调对应 <strong>IRP 派发函数</strong>传参，因此其内部也是一个类似堆栈的结构：</p>
<ul>
<li><code>StackCount</code>：总共有多少个设备对象参与 IRP 派发（即设备栈深度）。通常等于最上层 DeviceObject 的 <code>StackSize</code>。</li>
<li><code>CurrentLocation</code>：当前 IRP 正处于第几层派发阶段。每调用 <code>IoSkipCurrentIrpStackLocation()</code> 或 <code>IoCallDriver()</code> 时自动递减。</li>
<li><code>Tail.Overlay.CurrentStackLocation</code>：指向当前设备对象的 <code>IO_STACK_LOCATION</code> 结构，记录当前派发层级的参数、控制信息、IRP 参数（如 I&#x2F;O 控制码、读写长度等）。</li>
</ul>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">IRP 栈状态:</span><br><span class="line">StackCount = 5         ← 栈帧总数</span><br><span class="line">CurrentLocation = 3    ← 当前派发进度</span><br><span class="line">CurrentStackLocation → IO_STACK_LOCATION 3 (Filter1)</span><br><span class="line"></span><br><span class="line">设备对象堆叠对应关系:</span><br><span class="line">──────────────────────────────────────</span><br><span class="line">DeviceObject_Filter3   ←→  IO_STACK_LOCATION 5  (派发已完成)</span><br><span class="line">DeviceObject_Filter2   ←→  IO_STACK_LOCATION 4  (派发已完成)</span><br><span class="line">DeviceObject_Filter1   ←→  IO_STACK_LOCATION 3  ← 当前派发 (CurrentStackLocation 所在位置)</span><br><span class="line">DeviceObject_Functional(FDO) ←→ IO_STACK_LOCATION 2  (等待后续派发)</span><br><span class="line">DeviceObject_PDO       ←→  IO_STACK_LOCATION 1  (等待后续派发)</span><br><span class="line">──────────────────────────────────────</span><br></pre></td></tr></table></figure></div>

<p>很多关于 <code>IRP</code> 结构体的 API 本质上就是在操作这三个字段：</p>
<table>
<thead>
<tr>
<th>API 函数</th>
<th>作用</th>
<th>本质操作的字段变化</th>
</tr>
</thead>
<tbody><tr>
<td><code>IoGetCurrentIrpStackLocation()</code></td>
<td>获取当前派发栈帧指针</td>
<td>返回 <code>CurrentStackLocation</code></td>
</tr>
<tr>
<td><code>IoGetNextIrpStackLocation()</code></td>
<td>获取下一个栈帧指针（仅指针偏移，不修改位置）</td>
<td>返回 <code>CurrentStackLocation - 1</code></td>
</tr>
<tr>
<td><code>IoSetNextIrpStackLocation()</code></td>
<td>手动推进派发位置（很少用）</td>
<td><code>CurrentLocation--</code>，<code>CurrentStackLocation--</code></td>
</tr>
<tr>
<td><code>IoSkipCurrentIrpStackLocation()</code></td>
<td>抵消 <code>IoCallDriver </code> 函数内部的“推进派发位置”的操作，使得下一层设备对象仍然处理当前栈帧</td>
<td><code>CurrentLocation++</code>，<code>CurrentStackLocation++</code></td>
</tr>
</tbody></table>
<h4 id="参数结构"><a href="#参数结构" class="headerlink" title="参数结构"></a>参数结构</h4><p><code>IO_STACK_LOCATION</code> 中存储了参数信息，由于是所有类型的 IRP 派发函数公用，因此内部有一个联合体记录了每种类型的 IRP 派发函数对应的参数结构。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0x24 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_STACK_LOCATION</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    UCHAR MajorFunction;     <span class="comment">// 0x0 📌IRP 主功能码 (IRP_MJ_*)，驱动派发逻辑的核心依据</span></span><br><span class="line">    UCHAR MinorFunction;     <span class="comment">// 0x1 IRP 子功能码 (IRP_MN_*)，配合 MajorFunction 做更精细的区分</span></span><br><span class="line">    UCHAR Flags;             <span class="comment">// 0x2 控制标志，部分操作行为控制（如 SL_OVERRIDE_VERIFY_VOLUME 等）</span></span><br><span class="line">    UCHAR Control;           <span class="comment">// 0x3 I/O 子系统内部控制标志</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 📌参数联合体：根据不同的 MajorFunction 类型，使用对应的子结构</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  // <span class="title">IRP_MJ_CREATE</span> 使用</span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">IO_SECURITY_CONTEXT</span>* <span class="title">SecurityContext</span>;</span>    <span class="comment">// 0x4 安全上下文</span></span><br><span class="line">            ULONG Options;                                   <span class="comment">// 0x8 创建选项标志 (如 FILE_DIRECTORY_FILE 等)</span></span><br><span class="line">            USHORT FileAttributes;                           <span class="comment">// 0xC 文件属性 (如 FILE_ATTRIBUTE_NORMAL)</span></span><br><span class="line">            USHORT ShareAccess;                              <span class="comment">// 0xE 共享模式 (如 FILE_SHARE_READ)</span></span><br><span class="line">            ULONG EaLength;                                  <span class="comment">// 0x10 EA长度 (扩展属性)</span></span><br><span class="line">        &#125; Create;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  // <span class="title">IRP_MJ_CREATE_NAMED_PIPE</span> 使用</span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">IO_SECURITY_CONTEXT</span>* <span class="title">SecurityContext</span>;</span></span><br><span class="line">            ULONG Options;</span><br><span class="line">            USHORT Reserved;</span><br><span class="line">            USHORT ShareAccess;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">NAMED_PIPE_CREATE_PARAMETERS</span>* <span class="title">Parameters</span>;</span>  <span class="comment">// 0x10 命名管道专用参数</span></span><br><span class="line">        &#125; CreatePipe;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  // <span class="title">IRP_MJ_CREATE_MAILSLOT</span> 使用</span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">IO_SECURITY_CONTEXT</span>* <span class="title">SecurityContext</span>;</span></span><br><span class="line">            ULONG Options;</span><br><span class="line">            USHORT Reserved;</span><br><span class="line">            USHORT ShareAccess;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">MAILSLOT_CREATE_PARAMETERS</span>* <span class="title">Parameters</span>;</span></span><br><span class="line">        &#125; CreateMailslot;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  // <span class="title">IRP_MJ_READ</span> 使用</span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            ULONG Length;             <span class="comment">// 0x4 读取长度</span></span><br><span class="line">            ULONG Key;                <span class="comment">// 0x8 用于文件系统校验等用途</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">ByteOffset</span>;</span>  <span class="comment">// 0xC 读取偏移</span></span><br><span class="line">        &#125; Read;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  // <span class="title">IRP_MJ_WRITE</span> 使用</span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            ULONG Length;   </span><br><span class="line">            ULONG Key;</span><br><span class="line">            <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">ByteOffset</span>;</span></span><br><span class="line">        &#125; Write;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  // <span class="title">IRP_MJ_DEVICE_CONTROL</span> 使用</span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            ULONG OutputBufferLength;   <span class="comment">// 0x4 输出缓冲区长度</span></span><br><span class="line">            ULONG InputBufferLength;    <span class="comment">// 0x8 输入缓冲区长度</span></span><br><span class="line">            ULONG IoControlCode;        <span class="comment">// 0xC IOCTL 控制码</span></span><br><span class="line">            VOID* Type3InputBuffer;     <span class="comment">// 0x10 输入缓冲区指针 (IOCTL第三类缓冲模式用)</span></span><br><span class="line">        &#125; DeviceIoControl;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  // <span class="title">IRP_MJ_FILE_SYSTEM_CONTROL</span> (部分)</span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            ULONG OutputBufferLength;</span><br><span class="line">            ULONG InputBufferLength;</span><br><span class="line">            ULONG FsControlCode;</span><br><span class="line">            VOID* Type3InputBuffer;</span><br><span class="line">        &#125; FileSystemControl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其它子结构太多，简化列出部分常用：</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span> ULONG Length; &#125; SetEa;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span> ULONG Length; <span class="class"><span class="keyword">enum</span> _<span class="title">FILE_INFORMATION_CLASS</span> <span class="title">FileInformationClass</span>;</span> &#125; QueryFile;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="class"><span class="keyword">enum</span> _<span class="title">DEVICE_RELATION_TYPE</span> <span class="title">Type</span>;</span> &#125; QueryDeviceRelations;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="class"><span class="keyword">struct</span> _<span class="title">POWER_SEQUENCE</span>* <span class="title">PowerSequence</span>;</span> &#125; PowerSequence;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SCSI_REQUEST_BLOCK</span>* <span class="title">Srb</span>;</span> &#125; Scsi;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span> VOID* Argument1; VOID* Argument2; VOID* Argument3; VOID* Argument4; &#125; Others;</span><br><span class="line">        <span class="comment">// 还有很多其它子结构，类似逻辑。</span></span><br><span class="line">    &#125; Parameters;  <span class="comment">// 0x4 主参数区</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_OBJECT</span>* <span class="title">DeviceObject</span>;</span>  <span class="comment">// 0x14 当前派发到的设备对象 (本层目标设备)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">FILE_OBJECT</span>* <span class="title">FileObject</span>;</span>      <span class="comment">// 0x18 当前关联的文件对象 (通常在文件操作中使用)</span></span><br><span class="line">    </span><br><span class="line">    LONG (*CompletionRoutine)(<span class="keyword">struct</span> _DEVICE_OBJECT* DeviceObject, <span class="keyword">struct</span> _IRP* Irp, VOID* Context);  </span><br><span class="line">    <span class="comment">// 0x1C 完成例程回调函数指针 (用于注册完成回调逻辑)</span></span><br><span class="line"></span><br><span class="line">    VOID* Context;  <span class="comment">// 0x20 完成例程上下文参数 (传入 CompletionRoutine)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>通常我们会使用 <code>IoGetCurrentIrpStackLocation</code> 从 <code>IRP</code> 结构体中拿当前栈帧对应的 <code>IO_STACK_LOCATION</code> 参数。当然也可以通过 <code>IoGetNextIrpStackLocation</code> 获取下一层栈帧对应的 <code>IO_STACK_LOCATION</code> 参数或者手动解析 <code>IRP</code> 结构体拿任意一层的参数。</p>
<p>不过下一层的 <code>IO_STACK_LOCATION</code> 默认是空白的。如果我们作为过滤驱动，需要通过 <code>IoCopyCurrentIrpStackLocationToNext</code> 函数将当前栈帧中的参数拷贝到下一层才能让下一层的设备对象对应的驱动在当前栈帧中拿到参数。</p>
<p>而如果是底层设备栈的第一层（创建 IRP 时）则内核早已填好栈帧了，不会有这个问题。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">FORCEINLINE</span><br><span class="line">VOID <span class="title function_">IoCopyCurrentIrpStackLocationToNext</span><span class="params">(</span></span><br><span class="line"><span class="params">    _Inout_ PIRP Irp  <span class="comment">// [输入输出] 目标 IRP 指针</span></span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 获取当前栈帧 (当前派发层)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 获取下一层栈帧 (即 IoCallDriver 下一次派发使用的栈帧)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    PIO_STACK_LOCATION nextIrpSp = IoGetNextIrpStackLocation(Irp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 拷贝当前栈帧内容到下一栈帧 (注意只拷贝到 CompletionRoutine 之前的字段)</span></span><br><span class="line">    <span class="comment">// 即：将本层参数 (如 MajorFunction、Parameters、FileObject 等) 直接传递给下一层</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    RtlCopyMemory(</span><br><span class="line">        nextIrpSp,</span><br><span class="line">        irpSp,</span><br><span class="line">        FIELD_OFFSET(IO_STACK_LOCATION, CompletionRoutine)  <span class="comment">// 仅拷贝到 CompletionRoutine 之前</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 清空 Control 字段，保证新派发时控制标志干净</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    nextIrpSp-&gt;Control = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>另外通过 <code>IoSkipCurrentIrpStackLocation</code> 跳过当前设备对象的话也是同样的效果。</p>
<h4 id="返回结构"><a href="#返回结构" class="headerlink" title="返回结构"></a>返回结构</h4><p>对于参数传递，<code>IRP</code> 针对每层的设备对象都有对应的 <code>IO_STACK_LOCATION</code>，然而对于返回值，所有层最终共用同一个 <code>IoStatus</code> 返回区和缓冲区，只要有一层完成请求，设置好 <code>IoStatus.Status</code> 和 <code>IoStatus.Information</code> 即可。</p>
<p><code>IoStatus</code> 是 <code>IRP</code> 结构体中的一个成员，该成员类型为 <code>IO_STATUS_BLOCK</code>，定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0x8 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_STATUS_BLOCK</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        LONG Status;           <span class="comment">// IRP 完成状态码 (NTSTATUS)，表示 I/O 请求执行结果，供内核/用户态读取</span></span><br><span class="line">        VOID* Pointer;         <span class="comment">// 可选指针 (某些异步/特殊I/O场景用，极少用到)</span></span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG Information;         <span class="comment">// 通常存放返回的字节数（如 Read/Write 实际传输数据长度），供用户态API返回</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>Status</code> 最终会变成 Win32 API 的返回值，而 <code>Information</code> 会变成 Win32 API 返回的输出字节数。至于输出的数据的存放位置，这个取决于 <strong>I&#x2F;O 缓冲区机制</strong>。</p>
<table>
<thead>
<tr>
<th>I&#x2F;O 缓冲模式</th>
<th>数据缓冲区位置</th>
<th>数据写入哪</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Buffered I&#x2F;O (<code>DO_BUFFERED_IO</code>)</strong></td>
<td><code>Irp-&gt;AssociatedIrp.SystemBuffer</code></td>
<td>驱动填充 <code>SystemBuffer</code>，内核在 <code>IoCompleteRequest()</code> 时拷贝回用户缓冲区</td>
</tr>
<tr>
<td><strong>Direct I&#x2F;O (<code>DO_DIRECT_IO</code>)</strong></td>
<td><code>Irp-&gt;MdlAddress</code>（MDL映射的缓冲区）</td>
<td>驱动使用 <code>MmGetSystemAddressForMdlSafe()</code> 获得内核虚拟地址，直接写入用户缓冲区映射</td>
</tr>
<tr>
<td><strong>Neither I&#x2F;O</strong></td>
<td><code>Irp-&gt;UserBuffer</code>（直接原始用户地址）</td>
<td>驱动直接操作用户缓冲区（前提是地址合法性自己负责验证）</td>
</tr>
</tbody></table>
<h3 id="I-O-缓冲区机制"><a href="#I-O-缓冲区机制" class="headerlink" title="I&#x2F;O 缓冲区机制"></a>I&#x2F;O 缓冲区机制</h3><p>在驱动开发中，3 环用户程序与 0 环内核驱动需要频繁交换数据。交换数据的过程中需要内核I&#x2F;O管理器在两者之间做好<strong>地址转换、访问隔离、安全控制</strong>，为此 Windows 提供了 3 种 <strong>I&#x2F;O 缓冲区机制</strong>。</p>
<ul>
<li><strong>Buffered I&#x2F;O（系统缓冲 I&#x2F;O）</strong> </li>
<li><strong>Direct I&#x2F;O（直接 I&#x2F;O）</strong></li>
<li><strong>Neither I&#x2F;O（无缓冲 I&#x2F;O）</strong></li>
</ul>
<h4 id="I-O-缓冲区机制设置"><a href="#I-O-缓冲区机制设置" class="headerlink" title="I&#x2F;O 缓冲区机制设置"></a>I&#x2F;O 缓冲区机制设置</h4><p>在 Windows 内核中，用户态与内核态的数据传递的应用主要有两种场景：</p>
<ul>
<li>普通读写：<code>IRP_MJ_READ</code> &#x2F; <code>IRP_MJ_WRITE</code></li>
<li>设备控制：<code>IRP_MJ_DEVICE_CONTROL</code></li>
</ul>
<p>这两种场景的 I&#x2F;O 缓冲区机制的设置方法是不同的。</p>
<ul>
<li><p><strong>IRP_MJ_READ &#x2F; IRP_MJ_WRITE</strong> 这种类型的 IRP 派发函数主要由<strong>设备对象 <code>Flags</code></strong> 决定缓冲区模式。</p>
<p>当用户调用 <code>ReadFile()</code> &#x2F; <code>WriteFile()</code> 时，内核通过 IRP 派发到 <code>IRP_MJ_READ</code> &#x2F; <code>IRP_MJ_WRITE</code>。此时内核用 <strong><code>DeviceObject-&gt;Flags</code> 中的缓冲模式标志位</strong> 决定使用哪种缓冲机制：</p>
<ul>
<li><code>DO_BUFFERED_IO</code>：Buffered I&#x2F;O（系统缓冲 I&#x2F;O）</li>
<li><code>DO_DIRECT_IO</code>：Direct I&#x2F;O（直接 I&#x2F;O）</li>
</ul>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <ul>
<li><code>DO_BUFFERED_IO</code> 与 <code>DO_DIRECT_IO</code> 互斥，驱动在创建设备时只需二选一。</li>
<li>如果两个标志都未设置，默认当做 <code>Buffered I/O</code> 处理。</li>
<li><code>IRP_MJ_READ</code> &#x2F; <code>IRP_MJ_WRITE</code> 不存在 Neither I&#x2F;O（无缓冲 I&#x2F;O）模式。</li>
</ul>

    </div>
  </div>
</li>
<li><p><strong>IRP_MJ_DEVICE_CONTROL</strong> 这种类型的 IRP 派发函数主要由 <strong>IOCTL 控制码</strong>决定缓冲区模式。</p>
<p>WDK 提供的 <code>CTL_CODE</code> 宏用于在驱动开发中定义 IOCTL（Input&#x2F;Output Control）和 FSCTL（File System Control）请求的控制码。控制码本质上是一个 32 位整数，四个参数共同编码出一个唯一的请求类型，供内核和驱动识别具体的控制命令。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CTL_CODE(DeviceType, Function, Method, Access) ( \</span></span><br><span class="line"><span class="meta">    ((DeviceType) &lt;&lt; 16) | ((Access) &lt;&lt; 14) | ((Function) &lt;&lt; 2) | (Method) \</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>DeviceType</code>：设备类型代码，占用高 16 位（位 31-16）。如 <code>FILE_DEVICE_UNKNOWN</code>，<code>FILE_DEVICE_DISK</code> 等。由微软规范分配。</li>
<li><code>Access</code>：访问权限，占用 2 位（位 15-14），控制调用时用户需具备的访问权限。常见取值：<ul>
<li><code>FILE_ANY_ACCESS (0)</code>：不做权限限制</li>
<li><code>FILE_READ_ACCESS (1)</code>：需要读权限</li>
<li><code>FILE_WRITE_ACCESS (2)</code>：需要写权限</li>
<li><code>FILE_READ_ACCESS | FILE_WRITE_ACCESS (3)</code>：需同时具备读写权限</li>
</ul>
</li>
<li><code>Function</code>：功能号，占用 12 位（位 13-2），表示具体的功能编号。<ul>
<li>取值范围：0 ~ 4095</li>
<li>其中 0 ~ 2047 为微软保留，2048 ~ 4095 供厂商自定义。</li>
<li>通常你自己写驱动时使用 2048 以上的数字定义私有控制码，避免与系统冲突。</li>
</ul>
</li>
<li><code>Method</code>：缓冲区传递方式，占用 2 位（位 1-0），指定 I&#x2F;O 缓冲机制。对应四种传输模式：<ul>
<li><code>METHOD_BUFFERED (0)</code>：Buffered I&#x2F;O（系统缓冲 I&#x2F;O）</li>
<li><code>METHOD_IN_DIRECT (1)/METHOD_OUT_DIRECT (2)</code>：输入走 Buffered I&#x2F;O（系统缓冲 I&#x2F;O）；输出走 Direct I&#x2F;O（直接 I&#x2F;O）。</li>
<li><code>METHOD_NEITHER (3)</code>：Neither I&#x2F;O（无缓冲 I&#x2F;O）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Buffered-I-O（系统缓冲-I-O）"><a href="#Buffered-I-O（系统缓冲-I-O）" class="headerlink" title="Buffered I&#x2F;O（系统缓冲 I&#x2F;O）"></a>Buffered I&#x2F;O（系统缓冲 I&#x2F;O）</h4><p><strong>Buffered I&#x2F;O（系统缓冲 I&#x2F;O）</strong>机制指的是系统在内核空间自动分配一个<strong>中间缓冲区</strong>（<code>SystemBuffer</code>），用于驱动与用户态之间的数据交互。</p>
<p><img src="/2022/09/28/windows%20%E9%A9%B1%E5%8A%A8%E5%9F%BA%E7%A1%80/images/3mdlbffr.png" alt="说明用户缓冲区的缓冲 i/o 的关系图。"></p>
<ul>
<li><strong>输入数据</strong>： 用户数据从用户态缓冲区拷贝至 <code>Irp-&gt;AssociatedIrp.SystemBuffer</code>。</li>
<li><strong>输出数据</strong>： 驱动程序在处理完成后将结果放入 <code>SystemBuffer</code>，完成请求时，内核自动从 <code>SystemBuffer</code> 将数据拷贝回用户态缓冲区。</li>
</ul>
<p>这种方式对驱动开发者来说简单安全，避免了内核直接访问用户空间地址带来的复杂性，但是需要额外申请中间缓冲区和拷贝数据，效率较低，资源消耗较大，适用于小规模数据传输、配置参数交互。</p>
<h4 id="Neither-I-O（无缓冲-I-O）"><a href="#Neither-I-O（无缓冲-I-O）" class="headerlink" title="Neither I&#x2F;O（无缓冲 I&#x2F;O）"></a>Neither I&#x2F;O（无缓冲 I&#x2F;O）</h4><p><strong>Neither I&#x2F;O（无缓冲 I&#x2F;O）</strong>机制指的是内核不提供任何缓冲区转换或保护措施，驱动程序直接收到用户空间的<strong>原始虚拟地址</strong>指针（<code>Irp-&gt;UserBuffer</code>），需要自行探测、校验用户空间指针的合法性，风险较高。</p>
<p>在这种机制下，为了避免蓝屏驱动必须：</p>
<ul>
<li>主动调用 <code>ProbeForRead()</code> 探测读权限；<code>ProbeForWrite()</code> 探测写权限。</li>
<li>使用 <code>__try</code>&#x2F;<code>__except</code> 机制防止访问非法地址。</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Neither I/O 示例（需主动探测）</span></span><br><span class="line">PUCHAR userBuffer = (PUCHAR)Irp-&gt;UserBuffer;</span><br><span class="line">__try &#123;</span><br><span class="line">    ProbeForWrite(userBuffer, dataSize, <span class="keyword">sizeof</span>(UCHAR));</span><br><span class="line">    RtlCopyMemory(userBuffer, sourceData, dataSize);</span><br><span class="line">    Irp-&gt;IoStatus.Information = dataSize; <span class="comment">// 返回实际数据长度</span></span><br><span class="line">&#125; __except(EXCEPTION_EXECUTE_HANDLER) &#123;</span><br><span class="line">    status = GetExceptionCode();</span><br><span class="line">    Irp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>微软官方建议：探测用户地址空间 <strong>只能用 <code>ProbeForRead</code> &#x2F; <code>ProbeForWrite</code></strong> ，不要用 <code>MmIsAddressValid()</code>。因为对于用户缓冲区，<code>MmIsAddressValid()</code> <strong>既不可靠也不安全</strong>，在 IRQL &gt;&#x3D; DISPATCH_LEVEL 时调用还有可能蓝屏。</p>

    </div>
  </div>

<h4 id="Direct-I-O（直接-I-O）"><a href="#Direct-I-O（直接-I-O）" class="headerlink" title="Direct I&#x2F;O（直接 I&#x2F;O）"></a>Direct I&#x2F;O（直接 I&#x2F;O）</h4><p><strong>Buffered I&#x2F;O（系统缓冲 I&#x2F;O）</strong>方式<strong>拷贝数据太慢</strong>，尤其是大数据量时（如磁盘、网卡、DMA）。而 <strong>Neither I&#x2F;O（无缓冲 I&#x2F;O）</strong>这种内核态访问用户缓冲区的方式，又必须保证<strong>该内存合法</strong>且<strong>不会被换出物理内存</strong>，否则一旦页面失效，访问用户空间会蓝屏。</p>
<p><strong>Direct I&#x2F;O（直接 I&#x2F;O）</strong>在某种程度上是对 <strong>Neither I&#x2F;O（无缓冲 I&#x2F;O）</strong>的改进。该机制确保<strong>内核将用户缓冲区锁定为物理内存页面</strong>，并创建一个<strong>MDL（Memory Descriptor List）</strong>，驱动通过 <code>Irp-&gt;MdlAddress</code> 获取此MDL，再调用内核函数（如<code>MmGetSystemAddressForMdlSafe()</code>）<strong>将物理内存页映射为驱动可访问的内核虚拟地址</strong>。</p>
<p><img src="/2022/09/28/windows%20%E9%A9%B1%E5%8A%A8%E5%9F%BA%E7%A1%80/images/3mdldrct.png" alt="说明使用 dma 的设备的用户缓冲区上的直接 i/o 的示意图。"></p>
<p><code>MmGetSystemAddressForMdlSafe</code> 函数原型如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PVOID <span class="title function_">MmGetSystemAddressForMdlSafe</span><span class="params">(</span></span><br><span class="line"><span class="params">  IN PMDL Mdl,           <span class="comment">// [输入] 指向内存描述符列表的指针</span></span></span><br><span class="line"><span class="params">  IN ULONG Priority      <span class="comment">// [输入] 分配页表映射时的优先级</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>Mdl</code>：要映射的 MDL 地址（Memory Descriptor List）。通常是 <code>IRP-&gt;MdlAddress</code>，代表被 Direct I&#x2F;O 锁定的用户缓冲区物理页链表。</li>
<li><code>Priority</code>：映射操作时使用的内存分配优先级，指定内核在资源不足时如何处理：<ul>
<li><code>NormalPagePriority</code> — 普通优先级（标准使用，推荐）。</li>
<li><code>HighPagePriority</code> — 高优先级，尽量尝试分配映射资源。</li>
<li><code>LowPagePriority</code> — 低优先级，系统紧张时容易失败。</li>
<li><code>VeryLowPagePriority</code> — 极低优先级，仅适用于诊断或特殊情况。</li>
</ul>
</li>
</ul>
<p>示例代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Direct I/O 示例 (IRP_MJ_READ)</span></span><br><span class="line"><span class="keyword">if</span> (Irp-&gt;MdlAddress) &#123;</span><br><span class="line">    PUCHAR pBuffer = (PUCHAR)MmGetSystemAddressForMdlSafe(Irp-&gt;MdlAddress, NormalPagePriority);</span><br><span class="line">    <span class="keyword">if</span> (pBuffer) &#123;</span><br><span class="line">        <span class="comment">// 直接访问 pBuffer，无需额外拷贝</span></span><br><span class="line">        RtlCopyMemory(pBuffer, sourceData, dataSize);</span><br><span class="line">        Irp-&gt;IoStatus.Information = dataSize; <span class="comment">// 返回实际写入的数据长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这种机制安全且效率高，适用于大量数据传输（磁盘、网络、DMA设备）和性能要求较高的驱动程序。</p>
<h3 id="IRP-派发函数"><a href="#IRP-派发函数" class="headerlink" title="IRP 派发函数"></a>IRP 派发函数</h3><p><strong>IRP 派发函数</strong>是驱动程序中专门处理各类 IRP 请求的回调函数。当 I&#x2F;O 管理器收到用户或内核发起的 I&#x2F;O 请求时，系统会根据 IRP 的 <code>MajorFunction</code> 字段，自动把 IRP 分发到对应的派发函数。</p>
<h4 id="IRP-派发函数类别"><a href="#IRP-派发函数类别" class="headerlink" title="IRP 派发函数类别"></a>IRP 派发函数类别</h4><p>所有 IRP 派发函数的入口存放在 <code>PDRIVER_OBJECT</code> 结构体内的 <code>MajorFunction[]</code> 数组中：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DRIVER_OBJECT</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">  PDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + <span class="number">1</span>];</span><br><span class="line">  ...</span><br><span class="line">&#125; DRIVER_OBJECT, *PDRIVER_OBJECT;</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>MajorFunction</code> 是一个大小为 28 的函数指针数组，每个元素对应一个 IRP MajorFunction 编号，这些编号的宏定义如下：</p>
<table>
<thead>
<tr>
<th>IRP MajorFunction (值)</th>
<th>内核派发说明</th>
<th>Native API (Zw&#x2F;Nt)</th>
<th>Win32 API</th>
</tr>
</thead>
<tbody><tr>
<td><code>IRP_MJ_CREATE (0x00)</code></td>
<td>创建 &#x2F; 打开设备句柄</td>
<td><code>ZwCreateFile()</code> &#x2F; <code>NtCreateFile()</code></td>
<td><code>CreateFile()</code></td>
</tr>
<tr>
<td><code>IRP_MJ_CREATE_NAMED_PIPE (0x01)</code></td>
<td>命名管道专用</td>
<td><code>ZwCreateNamedPipeFile()</code></td>
<td><code>CreateNamedPipe()</code></td>
</tr>
<tr>
<td><code>IRP_MJ_CLOSE (0x02)</code></td>
<td>关闭设备句柄</td>
<td><code>ZwClose()</code></td>
<td><code>CloseHandle()</code></td>
</tr>
<tr>
<td><code>IRP_MJ_READ (0x03)</code></td>
<td>读取设备数据</td>
<td><code>ZwReadFile()</code></td>
<td><code>ReadFile()</code></td>
</tr>
<tr>
<td><code>IRP_MJ_WRITE (0x04)</code></td>
<td>写入设备数据</td>
<td><code>ZwWriteFile()</code></td>
<td><code>WriteFile()</code></td>
</tr>
<tr>
<td><code>IRP_MJ_QUERY_INFORMATION (0x05)</code></td>
<td>查询文件&#x2F;设备信息</td>
<td><code>ZwQueryInformationFile()</code></td>
<td><code>GetFileInformationByHandle()</code></td>
</tr>
<tr>
<td><code>IRP_MJ_SET_INFORMATION (0x06)</code></td>
<td>设置文件&#x2F;设备信息</td>
<td><code>ZwSetInformationFile()</code></td>
<td><code>SetFileInformationByHandle()</code></td>
</tr>
<tr>
<td><code>IRP_MJ_QUERY_EA (0x07)</code></td>
<td>查询扩展属性 (EA)</td>
<td><code>ZwQueryEaFile()</code></td>
<td>无直接 API</td>
</tr>
<tr>
<td><code>IRP_MJ_SET_EA (0x08)</code></td>
<td>设置扩展属性 (EA)</td>
<td><code>ZwSetEaFile()</code></td>
<td>无直接 API</td>
</tr>
<tr>
<td><code>IRP_MJ_FLUSH_BUFFERS (0x09)</code></td>
<td>刷新缓存区</td>
<td><code>ZwFlushBuffersFile()</code></td>
<td><code>FlushFileBuffers()</code></td>
</tr>
<tr>
<td><code>IRP_MJ_QUERY_VOLUME_INFORMATION (0x0A)</code></td>
<td>查询卷信息</td>
<td><code>ZwQueryVolumeInformationFile()</code></td>
<td><code>GetVolumeInformation()</code></td>
</tr>
<tr>
<td><code>IRP_MJ_SET_VOLUME_INFORMATION (0x0B)</code></td>
<td>设置卷信息</td>
<td><code>ZwSetVolumeInformationFile()</code></td>
<td>无直接 API</td>
</tr>
<tr>
<td><code>IRP_MJ_DIRECTORY_CONTROL (0x0C)</code></td>
<td>目录操作</td>
<td><code>ZwQueryDirectoryFile()</code></td>
<td><code>FindFirstFile()</code> &#x2F; <code>FindNextFile()</code></td>
</tr>
<tr>
<td><code>IRP_MJ_FILE_SYSTEM_CONTROL (0x0D)</code></td>
<td>文件系统控制</td>
<td><code>ZwFsControlFile()</code></td>
<td>无直接 API</td>
</tr>
<tr>
<td><code>IRP_MJ_DEVICE_CONTROL (0x0E)</code></td>
<td>设备控制（IOCTL）</td>
<td><code>ZwDeviceIoControlFile()</code></td>
<td><code>DeviceIoControl()</code></td>
</tr>
<tr>
<td><code>IRP_MJ_INTERNAL_DEVICE_CONTROL (0x0F)</code></td>
<td>内部设备控制</td>
<td>内核内部</td>
<td>无</td>
</tr>
<tr>
<td><code>IRP_MJ_SHUTDOWN (0x10)</code></td>
<td>关机通知</td>
<td><code>ZwShutdownSystem()</code></td>
<td>无</td>
</tr>
<tr>
<td><code>IRP_MJ_LOCK_CONTROL (0x11)</code></td>
<td>锁控制</td>
<td><code>ZwLockFile()</code> &#x2F; <code>ZwUnlockFile()</code></td>
<td><code>LockFile()</code> &#x2F; <code>UnlockFile()</code></td>
</tr>
<tr>
<td><code>IRP_MJ_CLEANUP (0x12)</code></td>
<td>句柄清理 (Close 前触发)</td>
<td>自动派发</td>
<td><code>CloseHandle()</code>（间接）</td>
</tr>
<tr>
<td><code>IRP_MJ_CREATE_MAILSLOT (0x13)</code></td>
<td>创建邮件槽</td>
<td><code>ZwCreateMailslotFile()</code></td>
<td><code>CreateMailslot()</code></td>
</tr>
<tr>
<td><code>IRP_MJ_QUERY_SECURITY (0x14)</code></td>
<td>查询安全信息</td>
<td><code>ZwQuerySecurityObject()</code></td>
<td><code>GetSecurityInfo()</code></td>
</tr>
<tr>
<td><code>IRP_MJ_SET_SECURITY (0x15)</code></td>
<td>设置安全信息</td>
<td><code>ZwSetSecurityObject()</code></td>
<td><code>SetSecurityInfo()</code></td>
</tr>
<tr>
<td><code>IRP_MJ_POWER (0x16)</code></td>
<td>电源管理</td>
<td>内核电源管理</td>
<td>无</td>
</tr>
<tr>
<td><code>IRP_MJ_SYSTEM_CONTROL (0x17)</code></td>
<td>WMI控制</td>
<td>WMI子系统派发</td>
<td>WMI系列API</td>
</tr>
<tr>
<td><code>IRP_MJ_DEVICE_CHANGE (0x18)</code></td>
<td>设备插拔通知</td>
<td>自动派发</td>
<td><code>RegisterDeviceNotification()</code> (部分场景)</td>
</tr>
<tr>
<td><code>IRP_MJ_QUERY_QUOTA (0x19)</code></td>
<td>查询磁盘配额</td>
<td><code>ZwQueryQuotaInformationFile()</code></td>
<td>无</td>
</tr>
<tr>
<td><code>IRP_MJ_SET_QUOTA (0x1A)</code></td>
<td>设置磁盘配额</td>
<td><code>ZwSetQuotaInformationFile()</code></td>
<td>无</td>
</tr>
<tr>
<td><code>IRP_MJ_PNP (0x1B)</code></td>
<td>即插即用</td>
<td>PnP子系统派发</td>
<td>设备管理器控制</td>
</tr>
<tr>
<td><code>IRP_MJ_PNP_POWER (0x1B)</code></td>
<td>历史兼容（已废弃别名）</td>
<td>——</td>
<td>——</td>
</tr>
<tr>
<td><code>IRP_MJ_MAXIMUM_FUNCTION (0x1B)</code></td>
<td>内核保留</td>
<td>——</td>
<td>——</td>
</tr>
</tbody></table>
<h4 id="IRP-派发函数注册"><a href="#IRP-派发函数注册" class="headerlink" title="IRP 派发函数注册"></a>IRP 派发函数注册</h4><p>每个 IRP 派发函数都有统一的标准函数签名：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">DispatchFunction</span><span class="params">(</span></span><br><span class="line"><span class="params">  PDEVICE_OBJECT DeviceObject,  <span class="comment">// [输入] 当前被调用的设备对象</span></span></span><br><span class="line"><span class="params">  PIRP Irp                      <span class="comment">// [输入] 当前要处理的 IRP 请求包</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<p>我们需要在 <code>DriverEntry()</code> 中定义该类型的函数，并将其注册到 <code>MajorFunction[]</code> 数组中。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DriverObject-&gt;MajorFunction[IRP_MJ_CREATE] = DispatchCreate;</span><br><span class="line">DriverObject-&gt;MajorFunction[IRP_MJ_CLOSE] = DispatchClose;</span><br><span class="line">DriverObject-&gt;MajorFunction[IRP_MJ_READ]  = DispatchRead;</span><br><span class="line">DriverObject-&gt;MajorFunction[IRP_MJ_WRITE] = DispatchWrite;</span><br><span class="line">DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = DispatchIoControl;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>最少也要注册 <code>IRP_MJ_CREATE</code> &#x2F; <code>IRP_MJ_CLOSE</code> &#x2F; <code>IRP_MJ_DEVICE_CONTROL</code>，否则基本无法和用户层通信。</p>
<ul>
<li><code>IRP_MJ_CREATE</code> 和 <code>IRP_MJ_DEVICE_CONTROL</code> 保证驱动能和用户交互，</li>
<li><code>IRP_MJ_CLOSE</code> 保证驱动能安全退出。</li>
</ul>

    </div>
  </div>

<h4 id="IRP-派发函数实现"><a href="#IRP-派发函数实现" class="headerlink" title="IRP 派发函数实现"></a>IRP 派发函数实现</h4><p>IRP 派发函数基本都是如下过程：<strong>取参数 → 业务逻辑处理 → 设置返回值 → 完成请求</strong></p>
<p>以 <code>IRP_MJ_DEVICE_CONTROL</code> 为例，常见的实现如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">MyDispatchDeviceControl</span><span class="params">(PDEVICE_OBJECT DeviceObject, PIRP Irp)</span></span><br><span class="line">&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(DeviceObject);</span><br><span class="line">    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);</span><br><span class="line">    NTSTATUS status = STATUS_INVALID_DEVICE_REQUEST;</span><br><span class="line">    ULONG_PTR info = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ULONG controlCode = irpSp-&gt;Parameters.DeviceIoControl.IoControlCode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (controlCode)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> IOCTL_MY_CUSTOM_COMMAND:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 示例：读取输入缓冲区内容</span></span><br><span class="line">            PUCHAR inputBuffer = (PUCHAR)Irp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">            ULONG inputLength = irpSp-&gt;Parameters.DeviceIoControl.InputBufferLength;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 业务逻辑处理...</span></span><br><span class="line"></span><br><span class="line">            status = STATUS_SUCCESS;</span><br><span class="line">            info = <span class="number">0</span>;  <span class="comment">// 需要返回的数据长度（若无数据返回则填 0）</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            status = STATUS_INVALID_DEVICE_REQUEST;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Irp-&gt;IoStatus.Status = status;</span><br><span class="line">    Irp-&gt;IoStatus.Information = info;</span><br><span class="line">    IoCompleteRequest(Irp, IO_NO_INCREMENT);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中关于最后的<strong>完成机制</strong>：</p>
<ul>
<li><p><code>Irp-&gt;IoStatus.Status</code>、<code>Irp-&gt;IoStatus.Information</code> 是<strong>IRP 完成结果</strong></p>
<ul>
<li><strong><code>IoStatus.Status</code></strong> —— 你要告诉 I&#x2F;O 管理器，这次 IRP 处理的结果：<ul>
<li>成功：<code>STATUS_SUCCESS</code></li>
<li>失败：其他各种 NTSTATUS 错误码</li>
</ul>
</li>
<li><strong><code>IoStatus.Information</code></strong> —— 返回给用户的附加数据长度（如：读取了多少字节、写入了多少字节、DeviceIoControl 输出了多少数据）</li>
</ul>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>这两个值并不会自动产生，而是你驱动在派发函数中自己填写进去的。否则内核无法知道你的处理结果。</p>

    </div>
  </div>
</li>
<li><p><code>IoCompleteRequest()</code> 的作用 —— <strong>提交完成、唤醒上层</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IoCompleteRequest(Irp, IO_NO_INCREMENT);</span><br></pre></td></tr></table></figure></div>

<p>这个 API 的职责是通知内核：<strong>这个 IRP 完成了</strong>，内核会：</p>
<ol>
<li>清理 IRP</li>
<li>唤醒等待该 IRP 完成的用户线程（如果是同步 I&#x2F;O）</li>
<li>让用户态的 <code>ReadFile()</code>、<code>WriteFile()</code>、<code>DeviceIoControl()</code> 等 API 得到返回</li>
<li>把刚才填的 <code>IoStatus.Status</code>、<code>Information</code> 传回用户态 API</li>
</ol>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>没有调用 IoCompleteRequest()，IRP 永远不会完成，用户线程会一直挂死等待。</p>

    </div>
  </div>
</li>
<li><p><code>return status</code> 是内核派发器 <code>IofCallDriver()</code> 内部会接收你的派发函数返回值（也就是 <code>return status</code>）。但注意：最终送到用户态的结果，并不是这个返回值，而是 <code>Irp-&gt;IoStatus.Status</code>。</p>
</li>
</ul>
<h4 id="IRP-派发过程"><a href="#IRP-派发过程" class="headerlink" title="IRP 派发过程"></a>IRP 派发过程</h4><p><strong>IRP 派发（IRP Dispatch）</strong>是 Windows 内核向驱动程序发送 I&#x2F;O 请求的核心机制。每个驱动通过注册的派发函数处理特定类型的 IRP（如 <code>READ</code>、<code>WRITE</code>、<code>DEVICE_CONTROL</code> 等），整个请求沿 I&#x2F;O 层叠栈（Stacked Device Stack）自顶向下传递。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p><strong>物理设备附加链（AttachedDevice 链）</strong>本身<strong>不会直接参与 IRP 派发逻辑</strong>，但它确实<strong>影响了 IRP 堆栈的分配深度（StackCount）</strong>。</p>

    </div>
  </div>

<p>IRP 派发是通过 <code>IoCallDriver</code> 函数实现的，该函数原型如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">IoCallDriver</span><span class="params">(</span></span><br><span class="line"><span class="params">    PDEVICE_OBJECT DeviceObject,  <span class="comment">// 目标设备对象（通常是下层驱动的 DeviceObject）</span></span></span><br><span class="line"><span class="params">    PIRP Irp                      <span class="comment">// 要派发的 I/O 请求包（IRP）</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>DeviceObject</code>：要将 IRP 派发给的目标设备对象（一般是下层的 Filter 或 Functional Device）。其对应的驱动由 <code>DeviceObject-&gt;DriverObject</code> 决定。</li>
<li><code>Irp</code>：要派发的 I&#x2F;O 请求数据包。调用本函数前，必须设置好 IRP 的栈帧位置（通常使用 <code>IoSkipCurrentIrpStackLocation()</code> 或手动设置 <code>CurrentLocation--</code>）。</li>
</ul>
<p><code>IoCallDriver</code> 将一个 IRP 派发到指定的设备对象所对应驱动的派发函数中。这是驱动中用于将 I&#x2F;O 请求“传递”给下层驱动的标准方式。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IoCallDriver(a,b)   \</span></span><br><span class="line"><span class="meta">        IofCallDriver(a,b)</span></span><br><span class="line"></span><br><span class="line">NTSTATUS FASTCALL <span class="title function_">IofCallDriver</span><span class="params">(</span></span><br><span class="line"><span class="params">    IN PDEVICE_OBJECT DeviceObject,</span></span><br><span class="line"><span class="params">    IN OUT PIRP Irp</span></span><br><span class="line"><span class="params">    )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pIofCallDriver != <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 如果开启了 I/O 验证器（Verifier），则这里会跳转到其 Hook 函数 (如 IovCallDriver / IoPerfCallDriver)。</span></span><br><span class="line">        <span class="comment">// 这些 Hook 模块用于在开发调试中插入额外的验证逻辑，辅助检测驱动Bug。</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">return</span> pIofCallDriver(DeviceObject, Irp, _ReturnAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则直接走默认 I/O 派发实现</span></span><br><span class="line">    <span class="keyword">return</span> IopfCallDriver(DeviceObject, Irp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS FORCEINLINE <span class="title function_">IopfCallDriver</span><span class="params">(</span></span><br><span class="line"><span class="params">    IN PDEVICE_OBJECT DeviceObject,</span></span><br><span class="line"><span class="params">    IN OUT PIRP Irp</span></span><br><span class="line"><span class="params">    )</span></span><br><span class="line">&#123;</span><br><span class="line">    PIO_STACK_LOCATION irpSp;</span><br><span class="line">    PDRIVER_OBJECT driverObject;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确认传入的确实是合法 IRP 对象</span></span><br><span class="line">    ASSERT( Irp-&gt;Type == IO_TYPE_IRP );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 核心逻辑：派发 IRP 前先将当前栈位置往下移动一层 (推进派发深度)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Irp-&gt;CurrentLocation--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈溢出检查：若已经到底还继续派发，直接蓝屏（BugCheck）</span></span><br><span class="line">    <span class="keyword">if</span> (Irp-&gt;CurrentLocation &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        KiBugCheck3(NO_MORE_IRP_STACK_LOCATIONS, (ULONG_PTR) Irp, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 计算新的栈帧指针：CurrentStackLocation 始终指向当前要派发的栈帧</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    irpSp = IoGetNextIrpStackLocation(Irp);</span><br><span class="line">    Irp-&gt;Tail.Overlay.CurrentStackLocation = irpSp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 记录本层设备对象指针，供下层驱动获取自身 DeviceObject</span></span><br><span class="line">    <span class="comment">// 通常派发 IRP 时下层驱动通过 irpSp-&gt;DeviceObject 知道自己是谁</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    irpSp-&gt;DeviceObject = DeviceObject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 获取目标驱动对象</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    driverObject = DeviceObject-&gt;DriverObject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 执行派发：调用目标驱动中对应的 MajorFunction 派发入口</span></span><br><span class="line">    <span class="comment">// irpSp-&gt;MajorFunction 记录了当前 IRP 的操作类型 (如 IRP_MJ_READ / IRP_MJ_WRITE 等)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    status = driverObject-&gt;MajorFunction[irpSp-&gt;MajorFunction](DeviceObject, Irp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>从 <code>IoCallDriver</code> 函数的实现来看，该函数会：</p>
<ol>
<li>推进 IRP 栈帧 <code>CurrentLocation--</code>，<code>Tail.Overlay.CurrentStackLocation--</code>。</li>
<li>调用下层驱动的的 IRP 派发函数 <code>DeviceObject-&gt;DriverObject-&gt;MajorFunction[Irp-&gt;Tail.Overlay.CurrentStackLocation-&gt;MajorFunction]</code>。</li>
</ol>
<p>而我们知道对于 IRP：</p>
<ul>
<li>如果是底层设备栈的第一层（创建 IRP 时）则内核早已填好栈帧了。</li>
<li>而下一层的 <code>Tail.Overlay.CurrentStackLocation</code> 默认是空白的。</li>
</ul>
<p>因此我们需要调用 <code>IoCopyCurrentIrpStackLocationToNext</code> 将当前 IRP 栈帧中的数据拷贝到下一层。这样才能确保过滤驱动不会影响到下层驱动的传参。</p>
<p>然而调用 <code>IoCallDriver</code> 函数会导致 IRP 堆栈减少一层，而如果我们没有事先做设备附加操作的话，可能会导致 IRP 堆栈层数不够造成蓝屏：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 核心逻辑：派发 IRP 前先将当前栈位置往下移动一层 (推进派发深度)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">Irp-&gt;CurrentLocation--;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈溢出检查：若已经到底还继续派发，直接蓝屏（BugCheck）</span></span><br><span class="line"><span class="keyword">if</span> (Irp-&gt;CurrentLocation &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    KiBugCheck3(NO_MORE_IRP_STACK_LOCATIONS, (ULONG_PTR) Irp, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们可以通过 <code>IoSetNextIrpStackLocation</code> 将 <code>CurrentLocation++</code>，<code>Tail.Overlay.CurrentStackLocation++</code> 来抵消 <code>IoCallDriver</code> 函数的影响。因此更通用的写法为：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">MyDispatchIoctl</span><span class="params">(PDEVICE_OBJECT DeviceObject, PIRP Irp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 可选处理参数</span></span><br><span class="line">    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 转发给下层</span></span><br><span class="line">    IoSkipCurrentIrpStackLocation(Irp);</span><br><span class="line">    <span class="keyword">return</span> IoCallDriver(LowerDeviceObject, Irp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> windows 驱动基础</li>
        <li><strong>Author:</strong> sky123</li>
        <li><strong>Created at
                :</strong> 2022-09-28 11:45:14</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2025-06-26 10:13:10
            </li>
        
        <li>
            <strong>Link:</strong> https://skyi23.github.io/2022/09/28/windows 驱动基础/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/windows-kernel-reverse/">#windows kernel reverse</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2022/09/28/windows%20%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">windows 系统调用</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2022/09/28/%E5%BC%82%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">异架构相关</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'skyI23/my-giscus-discussions',
                'data-repo-id': 'R_kgDONL9k_w',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDONL9k_84CkEdK',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">windows 驱动基础</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Windows-%E5%9F%BA%E7%A1%80"><span class="nav-text">Windows 基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1"><span class="nav-text">内核对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="nav-text">设计思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84"><span class="nav-text">内核对象结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-Manager-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-text">Object Manager 命名空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8-API"><span class="nav-text">常用 API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84"><span class="nav-text">路径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E7%B1%BB%E5%B8%B8%E8%A7%81%E8%B7%AF%E5%BE%84"><span class="nav-text">四类常见路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E8%A7%A3%E6%9E%90%E9%93%BE%E8%B7%AF"><span class="nav-text">典型解析链路</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">驱动基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6"><span class="nav-text">驱动框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E6%9C%8D%E5%8A%A1%E5%90%8D"><span class="nav-text">驱动服务名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E5%8A%A0%E8%BD%BD"><span class="nav-text">驱动加载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SCM-%E5%8A%A0%E8%BD%BD%EF%BC%88%E6%9C%8D%E5%8A%A1%E6%8E%A7%E5%88%B6%E7%AE%A1%E7%90%86%E5%99%A8%EF%BC%89"><span class="nav-text">SCM 加载（服务控制管理器）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E6%B5%81%E7%A8%8B"><span class="nav-text">原理流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-text">示例代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="nav-text">相关命令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZwLoadDriver%EF%BC%88%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-%E6%B3%A8%E5%86%8C%E8%A1%A8%EF%BC%89"><span class="nav-text">ZwLoadDriver（系统调用 + 注册表）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E6%B5%81%E7%A8%8B-1"><span class="nav-text">原理流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-1"><span class="nav-text">示例代码</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80"><span class="nav-text">驱动开发基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%A3%E7%A0%81"><span class="nav-text">基本代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD%E6%8A%80%E5%B7%A7"><span class="nav-text">功能技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA"><span class="nav-text">日志输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%AD%E7%82%B9"><span class="nav-text">断点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B"><span class="nav-text">字符串类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UNICODE-STRING"><span class="nav-text">UNICODE_STRING</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2"><span class="nav-text">字符串转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="nav-text">常用函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%EF%BC%88LIST-ENTRY%EF%BC%89"><span class="nav-text">双向链表（LIST_ENTRY）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E5%B9%B3%E8%A1%A1%E6%A0%91%E6%A1%86%E6%9E%B6%EF%BC%88RTL-GENERIC-TABLE%EF%BC%89"><span class="nav-text">通用平衡树框架（RTL_GENERIC_TABLE）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8-API-1"><span class="nav-text">常用 API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-text">线程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E9%9A%90%E8%97%8F"><span class="nav-text">驱动隐藏</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%90%E8%97%8F%E6%80%9D%E8%B7%AF"><span class="nav-text">隐藏思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%90%E8%97%8F%E6%B5%81%E7%A8%8B"><span class="nav-text">隐藏流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="nav-text">完整代码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E9%80%9A%E4%BF%A1"><span class="nav-text">驱动通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E5%AF%B9%E8%B1%A1"><span class="nav-text">设备对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E5%AF%B9%E8%B1%A1%E5%AE%9A%E4%B9%89"><span class="nav-text">设备对象定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA"><span class="nav-text">设备对象创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E5%AF%B9%E8%B1%A1%E9%99%84%E5%8A%A0"><span class="nav-text">设备对象附加</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IRP%EF%BC%88I-O-Request-Packet%EF%BC%89"><span class="nav-text">IRP（I&#x2F;O Request Packet）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IRP-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">IRP 结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#I-O-%E5%B1%82%E5%8F%A0%E6%A0%88"><span class="nav-text">I&#x2F;O 层叠栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E7%BB%93%E6%9E%84"><span class="nav-text">参数结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%84"><span class="nav-text">返回结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O-%E7%BC%93%E5%86%B2%E5%8C%BA%E6%9C%BA%E5%88%B6"><span class="nav-text">I&#x2F;O 缓冲区机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#I-O-%E7%BC%93%E5%86%B2%E5%8C%BA%E6%9C%BA%E5%88%B6%E8%AE%BE%E7%BD%AE"><span class="nav-text">I&#x2F;O 缓冲区机制设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Buffered-I-O%EF%BC%88%E7%B3%BB%E7%BB%9F%E7%BC%93%E5%86%B2-I-O%EF%BC%89"><span class="nav-text">Buffered I&#x2F;O（系统缓冲 I&#x2F;O）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Neither-I-O%EF%BC%88%E6%97%A0%E7%BC%93%E5%86%B2-I-O%EF%BC%89"><span class="nav-text">Neither I&#x2F;O（无缓冲 I&#x2F;O）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Direct-I-O%EF%BC%88%E7%9B%B4%E6%8E%A5-I-O%EF%BC%89"><span class="nav-text">Direct I&#x2F;O（直接 I&#x2F;O）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IRP-%E6%B4%BE%E5%8F%91%E5%87%BD%E6%95%B0"><span class="nav-text">IRP 派发函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IRP-%E6%B4%BE%E5%8F%91%E5%87%BD%E6%95%B0%E7%B1%BB%E5%88%AB"><span class="nav-text">IRP 派发函数类别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IRP-%E6%B4%BE%E5%8F%91%E5%87%BD%E6%95%B0%E6%B3%A8%E5%86%8C"><span class="nav-text">IRP 派发函数注册</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IRP-%E6%B4%BE%E5%8F%91%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="nav-text">IRP 派发函数实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IRP-%E6%B4%BE%E5%8F%91%E8%BF%87%E7%A8%8B"><span class="nav-text">IRP 派发过程</span></a></li></ol></li></ol></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2024</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">sky123</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        37 posts in total
                    </span>
                    
                        <span>
                            590.2k words in total
                        </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>



<script src="/js/build/libs/Swup.min.js"></script>

<script src="/js/build/libs/SwupSlideTheme.min.js"></script>

<script src="/js/build/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/build/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/build/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/build/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	
<script src="/js/build/tools/imageViewer.js" type="module"></script>

<script src="/js/build/utils.js" type="module"></script>

<script src="/js/build/main.js" type="module"></script>

<script src="/js/build/layouts/navbarShrink.js" type="module"></script>

<script src="/js/build/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/build/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/build/layouts/categoryList.js" type="module"></script>



    
<script src="/js/build/tools/localSearch.js" type="module"></script>




    
<script src="/js/build/tools/codeBlock.js" type="module"></script>




    
<script src="/js/build/layouts/lazyload.js" type="module"></script>




    
<script src="/js/build/tools/runtime.js"></script>

    
<script src="/js/build/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/build/libs/Typed.min.js"></script>

  
<script src="/js/build/plugins/typed.js" type="module"></script>




    
        
<script src="/js/build/libs/mermaid.min.js"></script>

    
    
<script src="/js/build/plugins/mermaid.js"></script>






    
<script src="/js/build/libs/anime.min.js"></script>





    
<script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script>





    
<script src="/js/build/layouts/bookmarkNav.js" type="module"></script>


	
</body>

</html>