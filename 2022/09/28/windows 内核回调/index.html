<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="sky123">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://skyi23.github.io/2022/09/28/windows 内核回调/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/null" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/null">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/null">
    <!--- Page Info-->
    
    <title>
        
            windows 内核回调 | sky123&#39;s site
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/css/build/tailwind.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" rel="stylesheet">
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"skyi23.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":true,"family":"JetBrains Mono","url":"https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap"}},"toc":{"enable":true,"max_depth":5,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"open_graph":{"enable":false,"image":"/images/redefine-og.webp","description":"Hexo Theme Redefine, Redefine Your Hexo Journey."},"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"sky123's blog","subtitle":{"text":["书有未曾经我读，事无不可对人言"],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":true,"version":"11.4.1"}},"version":"2.8.2","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"分类":{"icon":"fa-solid fa-folder","path":"/categories/"},"标签":{"icon":"fa-solid fa-tags","path":"/tags/"},"书签":{"icon":"fa-solid fa-bookmark","path":"/bookmarks/"}},"search":{"enable":true,"preload":true}},"page_templates":{"bookmarks_column":3,"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2024/11/7 00:00:00"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha256-TThEtR+XalhWKkfF383YLOrI50NGNeIqrzS+q08afrY=" crossorigin="anonymous"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>



<body>
	<div class="progress-bar-container">
	
	<span class="scroll-progress-bar"></span>
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                sky123&#39;s site
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/categories/"
                                        >
                                    <i class="fa-solid fa-folder fa-fw"></i>
                                    分类
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/tags/"
                                        >
                                    <i class="fa-solid fa-tags fa-fw"></i>
                                    标签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/bookmarks/"
                                        >
                                    <i class="fa-solid fa-bookmark fa-fw"></i>
                                    书签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/categories/"
                        >
                            <span>
                                分类
                            </span>
                            
                                <i class="fa-solid fa-folder fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/tags/"
                        >
                            <span>
                                标签
                            </span>
                            
                                <i class="fa-solid fa-tags fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/bookmarks/"
                        >
                            <span>
                                书签
                            </span>
                            
                                <i class="fa-solid fa-bookmark fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">11</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">14</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">40</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">windows 内核回调</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/icon.jpg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">sky123</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2022-09-28 11:45:14</span>
        <span class="mobile">2022-09-28 11:45:14</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-07-07 01:17:38</span>
            <span class="mobile">2025-07-07 01:17:38</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/reverse/">reverse</a>&nbsp;
                        </li>
                    
                    
                
                    
                        
                            <li>></li>
                        
                        <li>
                            <a href="/categories/reverse/windows-kernel/">windows kernel</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/windows-kernel-reverse/">windows kernel reverse</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>12.4k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>50 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<p><a class="link"   target="_blank" rel="noopener" href="https://www.vergiliusproject.com/" >https://www.vergiliusproject.com/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h1 id="系统通知型回调（Notify-Callbacks）"><a href="#系统通知型回调（Notify-Callbacks）" class="headerlink" title="系统通知型回调（Notify Callbacks）"></a>系统通知型回调（Notify Callbacks）</h1><p><strong>系统通知型回调</strong>是 Windows 内核提供的一类机制，允许内核模式驱动程序注册回调函数，以便在<strong>系统关键事件</strong>（如进程&#x2F;线程创建、模块加载、句柄操作、注册表修改等）发生时收到通知。</p>
<p>常见的<strong>系统通知型回调</strong>有下面几种类型：</p>
<table>
<thead>
<tr>
<th>事件类型</th>
<th>注册函数</th>
<th>回调函数类型</th>
</tr>
</thead>
<tbody><tr>
<td>进程创建&#x2F;退出</td>
<td><code>PsSetCreateProcessNotifyRoutine(Ex)</code></td>
<td><code>PCREATE_PROCESS_NOTIFY_ROUTINE(_EX)</code></td>
</tr>
<tr>
<td>线程创建&#x2F;退出</td>
<td><code>PsSetCreateThreadNotifyRoutine(Ex)</code></td>
<td><code>PCREATE_THREAD_NOTIFY_ROUTINE</code></td>
</tr>
<tr>
<td>模块加载（DLL、EXE、SYS）</td>
<td><code>PsSetLoadImageNotifyRoutine(Ex)</code></td>
<td><code>PLOAD_IMAGE_NOTIFY_ROUTINE</code></td>
</tr>
<tr>
<td>注册表修改</td>
<td><code>CmRegisterCallbackEx</code></td>
<td><code>PEX_CALLBACK_FUNCTION</code></td>
</tr>
<tr>
<td>对象句柄操作</td>
<td><code>ObRegisterCallbacks</code></td>
<td><code>POB_PRE_OPERATION_CALLBACK</code></td>
</tr>
<tr>
<td>文件系统操作</td>
<td><code>FltRegisterFilter</code> + <code>FltStartFiltering</code></td>
<td><code>FLT_PREOP_CALLBACK_ROUTINE</code> 等</td>
</tr>
<tr>
<td>注册表配置单元加载（Hive）</td>
<td><code>CmRegisterCallbackEx</code></td>
<td><code>PEX_CALLBACK_FUNCTION</code></td>
</tr>
</tbody></table>
<h2 id="进程回调"><a href="#进程回调" class="headerlink" title="进程回调"></a>进程回调</h2><p>进程回调是 Windows 内核为驱动提供的重要机制之一，它允许驱动<strong>在进程创建和退出时收到系统通知</strong>，以实现行为监控、日志记录、安全检测和控制等功能。</p>
<p>Windows 提供两种进程回调机制：</p>
<ul>
<li><code>PCREATE_PROCESS_NOTIFY_ROUTINE</code>（基础版）</li>
<li><code>PCREATE_PROCESS_NOTIFY_ROUTINE_EX</code>（扩展版，推荐）</li>
</ul>
<h3 id="基础回调注册"><a href="#基础回调注册" class="headerlink" title="基础回调注册"></a>基础回调注册</h3><p><code>PCREATE_PROCESS_NOTIFY_ROUTINE</code> 是 Windows 早期版本提供的进程回调函数类型，功能相对有限，仅提供进程的 PID、父进程 ID 和创建&#x2F;销毁事件标志。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">VOID</span> <span class="params">(*PCREATE_PROCESS_NOTIFY_ROUTINE)</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ HANDLE ParentId,   <span class="comment">// 父进程 PID</span></span></span><br><span class="line"><span class="params">    _In_ HANDLE ProcessId,  <span class="comment">// 当前进程 PID</span></span></span><br><span class="line"><span class="params">    _In_ BOOLEAN Create     <span class="comment">// TRUE 表示创建进程，FALSE 表示退出进程</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<p><code>PCREATE_PROCESS_NOTIFY_ROUTINE</code> 类型的回调需要通过 <code>PsSetCreateProcessNotifyRoutine</code> 函数<strong>注册</strong>和<strong>移除</strong>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NTKERNELAPI</span><br><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">PsSetCreateProcessNotifyRoutine</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PCREATE_PROCESS_NOTIFY_ROUTINE NotifyRoutine,  <span class="comment">// 回调函数，当进程创建或销毁时会被调用</span></span></span><br><span class="line"><span class="params">    _In_ BOOLEAN Remove                                    <span class="comment">// 布尔值，TRUE 表示移除回调函数，FALSE 表示注册回调</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<p>示例代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">VOID <span class="title function_">BasicProcessNotify</span><span class="params">(HANDLE ParentId, HANDLE ProcessId, BOOLEAN Create)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Create) &#123;</span><br><span class="line">        DbgPrint(<span class="string">&quot;创建进程：PID=%p，父PID=%p\n&quot;</span>, ProcessId, ParentId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        DbgPrint(<span class="string">&quot;退出进程：PID=%p\n&quot;</span>, ProcessId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PsSetCreateProcessNotifyRoutine(BasicProcessNotify, FALSE);  <span class="comment">// 注册</span></span><br><span class="line">PsSetCreateProcessNotifyRoutine(BasicProcessNotify, TRUE);   <span class="comment">// 卸载时移除</span></span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>如果我们注册了回调函数，但是在驱动卸载的时候没有移除回调函数，则由于实现回调函数的驱动被卸载了，因此会导致内核访问无效内存地址（<code>PAGE_FAULT_IN_NONPAGED_AREA</code>），引发蓝屏崩溃。</p>
<p>因此我们通常在驱动卸载函数中移除回调函数。而 <code>PsSetCreateProcessNotifyRoutine</code> 本身支持注册与移除（通过 <code>Remove=TRUE</code>）。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 驱动卸载函数 DriverUnload</span></span><br><span class="line">NTSTATUS <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT DriverObject)</span> &#123;</span><br><span class="line">    <span class="comment">// 关键：移除回调（第二个参数TRUE表示移除）</span></span><br><span class="line">    NTSTATUS status = PsSetCreateProcessNotifyRoutineEx(MyProcessCallback, TRUE);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(status)) &#123;</span><br><span class="line">        KdPrint((<span class="string">&quot;移除回调失败: 0x%X\n&quot;</span>, status));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<h3 id="扩展回调注册"><a href="#扩展回调注册" class="headerlink" title="扩展回调注册"></a>扩展回调注册</h3><p><code>PCREATE_PROCESS_NOTIFY_ROUTINE_EX</code> 是对基础回调的扩展，提供更丰富的进程创建上下文，包括 <code>EPROCESS</code> 指针、映像路径、命令行、映像对象等。该回调函数类型定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">VOID</span> <span class="params">(*PCREATE_PROCESS_NOTIFY_ROUTINE_EX)</span><span class="params">(</span></span><br><span class="line"><span class="params">    _Inout_ PEPROCESS Process,             <span class="comment">// 进程对象的指针，包含详细的进程信息</span></span></span><br><span class="line"><span class="params">    _In_ HANDLE ProcessId,                 <span class="comment">// 目标进程的 ID</span></span></span><br><span class="line"><span class="params">    _Inout_opt_ PPS_CREATE_NOTIFY_INFO CreateInfo <span class="comment">// 额外的创建通知信息（如命令行等）</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p><code>PCREATE_PROCESS_NOTIFY_ROUTINE_EX</code> 函数没有专门的参数来表示进程是被创建，但是 <code>CreateInfo</code> 参数只有进程创建的时候才非空，因此我们可以通过 <code>CreateInfo</code> 是否为 <code>NULL</code> 来确定进程是销毁还是创建。</p>
<ul>
<li>当进程<strong>正在创建</strong>时，<code>CreateInfo != NULL</code>；</li>
<li>当进程<strong>正在退出</strong>时，<code>CreateInfo == NULL</code>。</li>
</ul>

    </div>
  </div>

<p><code>PCREATE_PROCESS_NOTIFY_ROUTINE_EX</code> 不仅提供了进程 ID，还提供了进程的 <code>EPROCESS</code> 结构以及存放额外的信息的结构体 <code>PPS_CREATE_NOTIFY_INFO</code>，该结构体定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PS_CREATE_NOTIFY_INFO</span> &#123;</span></span><br><span class="line">    _In_ SIZE_T Size;                                     <span class="comment">// 0x00: 结构体大小，必须初始化为 sizeof(PS_CREATE_NOTIFY_INFO)</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        _In_ ULONG Flags;                                 <span class="comment">// 0x04: 进程创建特性标志位集合</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            _In_ ULONG FileOpenNameAvailable : <span class="number">1</span>;         <span class="comment">// bit0: 当设置为1时表示ImageFileName字段包含有效的映像文件名</span></span><br><span class="line">            _In_ ULONG IsSubsystemProcess : <span class="number">1</span>;            <span class="comment">// bit1: 当设置为1时表示该进程是子系统进程（如Win32子系统进程）</span></span><br><span class="line">            _In_ ULONG Reserved : <span class="number">30</span>;                     <span class="comment">// bit2-31: 保留位，必须设置为0，供系统将来使用</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    _In_ HANDLE ParentProcessId;                          <span class="comment">// 0x08: 父进程的进程ID（PID），标识创建此进程的父进程</span></span><br><span class="line">    _In_ CLIENT_ID CreatingThreadId;                      <span class="comment">// 0x0C: 创建此进程的线程ID（包含进程ID和线程ID的结构体）</span></span><br><span class="line">    _Inout_ <span class="class"><span class="keyword">struct</span> _<span class="title">FILE_OBJECT</span> *<span class="title">FileObject</span>;</span>              <span class="comment">// 0x14: 指向进程映像文件对象的指针，可用于文件重定向</span></span><br><span class="line">    _In_ PCUNICODE_STRING ImageFileName;                  <span class="comment">// 0x18: 指向进程映像文件完整路径的指针（NT路径格式）</span></span><br><span class="line">    _In_opt_ PCUNICODE_STRING CommandLine;                <span class="comment">// 0x1C: 指向进程命令行参数的指针（可选字段，在较新版本的 Windows 10/11 上才存在，低版本系统或某些子系统进程（如 csrss.exe）中会为 NULL）</span></span><br><span class="line">    _Inout_ NTSTATUS CreationStatus;                      <span class="comment">// 0x20: 进程创建状态码，驱动程序可修改此值来阻止进程创建</span></span><br><span class="line">&#125; PS_CREATE_NOTIFY_INFO, *PPS_CREATE_NOTIFY_INFO;</span><br></pre></td></tr></table></figure></div>

<p><code>PCREATE_PROCESS_NOTIFY_ROUTINE_EX</code> 回调函数是通过 <code>PsSetCreateProcessNotifyRoutineEx</code> 函数注册或删除的，注意不要与 <code>PsSetCreateProcessNotifyRoutine</code> 混用。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NTKERNELAPI </span><br><span class="line">NTSTATUS </span><br><span class="line"><span class="title function_">PsSetCreateProcessNotifyRoutineEx</span> <span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PCREATE_PROCESS_NOTIFY_ROUTINE_EX NotifyRoutine,  <span class="comment">// 扩展回调函数，提供更多的进程上下文信息</span></span></span><br><span class="line"><span class="params">    _In_ BOOLEAN Remove                                        <span class="comment">// 布尔值，TRUE 表示移除回调，FALSE 表示注册回调</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p><code>PsSetCreateProcessNotifyRoutineEx</code> 可能因未签名驱动被拒绝注册回调，返回错误码：<code>STATUS_ACCESS_DENIED (0xC0000022)</code>。</p>
<p>通过分析发现是 <code>MmVerifyCallbackFunction</code> 函数未通过回调函数的校验返回 <code>FALSE</code> 导致的。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">NTKERNELAPI</span><br><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">PsSetCreateProcessNotifyRoutineEx</span> <span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PCREATE_PROCESS_NOTIFY_ROUTINE_EX NotifyRoutine,</span></span><br><span class="line"><span class="params">    _In_ BOOLEAN Remove</span></span><br><span class="line"><span class="params">    )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PspSetCreateProcessNotifyRoutine(NotifyRoutine, Remove, TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTKERNELAPI</span><br><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">PspSetCreateProcessNotifyRoutine</span> <span class="params">(</span></span><br><span class="line"><span class="params">    PVOID NotifyRoutine,</span></span><br><span class="line"><span class="params">    BOOLEAN Remove,</span></span><br><span class="line"><span class="params">    BOOLEAN IsExtended</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    <span class="keyword">if</span> (IsExtended &amp;&amp; !MmVerifyCallbackFunction(NotifyRoutine)) &#123;</span><br><span class="line">        <span class="keyword">return</span> STATUS_ACCESS_DENIED;  <span class="comment">// 👈 返回 0xC0000022 错误码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>MmVerifyCallbackFunction</code> 函数会调用 <code>MiLookupDataTableEntry</code> 获取回调函数 <code>NotifyRoutine</code> 对应的 <code>PKLDR_DATA_TABLE_ENTRY</code> 结构，然后根据其中的 <code>Flags</code> 字段是否设置了 0x20 标志位确定是否返回 <code>TRUE</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NTKERNELAPI</span><br><span class="line">BOOLEAN</span><br><span class="line"><span class="title function_">MmVerifyCallbackFunction</span> <span class="params">(</span></span><br><span class="line"><span class="params">    PVOID NotifyRoutine</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    DataTableEntry = MiLookupDataTableEntry(NotifyRoutine, TRUE);</span><br><span class="line">    <span class="keyword">if</span> (DataTableEntry) &#123;</span><br><span class="line">        IsValidCallback = (DataTableEntry-&gt;Flags &amp; <span class="number">0x20</span>) != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    <span class="keyword">return</span> IsValidCallback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>MiLookupDataTableEntry</code> 会遍历所有已加载模块，判断传入的回调函数在哪个模块的地址范围内，返回该模块对应的 <code>KLDR_DATA_TABLE_ENTRY</code> 结构。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">PKLDR_DATA_TABLE_ENTRY</span><br><span class="line"><span class="title function_">MiLookupDataTableEntry</span> <span class="params">(</span></span><br><span class="line"><span class="params">    IN PVOID AddressWithinSection,  <span class="comment">// 输入参数：要在模块中查找的内存地址</span></span></span><br><span class="line"><span class="params">    IN ULONG ResourceHeld           <span class="comment">// 输入参数：指示是否已持有PsLoadedModuleResource资源锁</span></span></span><br><span class="line"><span class="params">    )</span></span><br><span class="line"><span class="comment">/*++</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">函数说明:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    本函数查找包含指定地址的已加载模块对应的数据表条目。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">参数说明:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    AddressWithinSection - 提供要查找的地址，该地址应包含在目标模块的代码段或数据段中</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ResourceHeld - 指示调用者是否已持有已加载模块资源锁：</span></span><br><span class="line"><span class="comment">                   TRUE  = 调用者已持有锁，不需要重复获取</span></span><br><span class="line"><span class="comment">                   FALSE = 调用者未持有锁，函数内部需要获取锁</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">返回值:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    返回映射到参数地址的已加载模块列表数据表条目的地址，如果未找到则返回NULL</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--*/</span></span><br><span class="line">&#123;</span><br><span class="line">    PKTHREAD CurrentThread;         <span class="comment">// 当前线程指针</span></span><br><span class="line">    PKLDR_DATA_TABLE_ENTRY DataTableEntry;  <span class="comment">// 遍历中的当前数据表条目</span></span><br><span class="line">    PKLDR_DATA_TABLE_ENTRY FoundEntry;      <span class="comment">// 找到的目标条目</span></span><br><span class="line">    PLIST_ENTRY NextEntry;          <span class="comment">// 指向加载模块列表中的下一个条目</span></span><br><span class="line"></span><br><span class="line">    PAGED_CODE();  <span class="comment">// 声明此函数可分页，但仅在安全环境下调用</span></span><br><span class="line"></span><br><span class="line">    FoundEntry = <span class="literal">NULL</span>;  <span class="comment">// 初始化查找结果为未找到</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 遍历已加载模块列表，查找包含指定地址的模块</span></span><br><span class="line">    <span class="comment">// 注意：如果模块正在卸载过程中，可能暂时不在列表中</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果调用者未持有资源锁，则在此处获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (!ResourceHeld) &#123;</span><br><span class="line">        CurrentThread = KeGetCurrentThread();</span><br><span class="line">        <span class="comment">// 进入关键区域并禁用APC</span></span><br><span class="line">        KeEnterCriticalRegionThread(CurrentThread);</span><br><span class="line">        <span class="comment">// 以共享模式获取已加载模块资源锁</span></span><br><span class="line">        ExAcquireResourceSharedLite(&amp;PsLoadedModuleResource, TRUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 调用者已持有锁，不需要额外获取</span></span><br><span class="line">        CurrentThread = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从已加载模块列表头部开始遍历</span></span><br><span class="line">    NextEntry = PsLoadedModuleList.Flink;</span><br><span class="line">    ASSERT(NextEntry != <span class="literal">NULL</span>);  <span class="comment">// 确保列表已初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历整个模块链表</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 通过链表指针获取当前模块的数据表条目</span></span><br><span class="line">        DataTableEntry = CONTAINING_RECORD(NextEntry,</span><br><span class="line">                                           KLDR_DATA_TABLE_ENTRY,</span><br><span class="line">                                           InLoadOrderLinks);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 📌检查当前模块的内存范围是否包含目标地址</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> (AddressWithinSection &gt;= DataTableEntry-&gt;DllBase &amp;&amp;  <span class="comment">// 地址 &gt;= 模块基址</span></span><br><span class="line">            AddressWithinSection &lt; (PVOID)((PUCHAR)DataTableEntry-&gt;DllBase + </span><br><span class="line">                                          DataTableEntry-&gt;SizeOfImage))  <span class="comment">// 地址 &lt; 模块结束地址</span></span><br><span class="line">        &#123;</span><br><span class="line">            FoundEntry = DataTableEntry;  <span class="comment">// 找到匹配模块</span></span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 跳出循环</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动到下一个模块</span></span><br><span class="line">        NextEntry = NextEntry-&gt;Flink;</span><br><span class="line">    &#125; <span class="keyword">while</span> (NextEntry != &amp;PsLoadedModuleList);  <span class="comment">// 直到回到列表头部</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果此函数获取了锁，需要释放它</span></span><br><span class="line">    <span class="keyword">if</span> (CurrentThread != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ExReleaseResourceLite(&amp;PsLoadedModuleResource);  <span class="comment">// 释放资源锁</span></span><br><span class="line">        KeLeaveCriticalRegionThread(CurrentThread);      <span class="comment">// 退出关键区域</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> FoundEntry;  <span class="comment">// 返回查找到的模块条目或NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>实际上上述检查只是判断驱动是否经过微软官方签名。而绕过方法也很简单，我们只需要修改驱动对应的 <code>KLDR_DATA_TABLE_ENTRY</code> 结构的 <code>Flags</code> 字段，使其 0x20 置位即可。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KLDR_DATA_TABLE_ENTRY</span> &#123;</span></span><br><span class="line">    LIST_ENTRY InLoadOrderLinks;</span><br><span class="line">    ULONG __Undefined1;</span><br><span class="line">    ULONG __Undefined2;</span><br><span class="line">    ULONG __Undefined3;</span><br><span class="line">    ULONG NonPagedDebugInfo;</span><br><span class="line">    ULONG DllBase;</span><br><span class="line">    ULONG EntryPoint;</span><br><span class="line">    ULONG SizeOfImage;</span><br><span class="line">    UNICODE_STRING FullDllName;</span><br><span class="line">    UNICODE_STRING BaseDllName;</span><br><span class="line">    ULONG Flags;</span><br><span class="line">    <span class="comment">// ...(后续字段省略)</span></span><br><span class="line">&#125; KLDR_DATA_TABLE_ENTRY, *PKLDR_DATA_TABLE_ENTRY;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)</span></span><br><span class="line">&#123;</span><br><span class="line">    PKLDR_DATA_TABLE_ENTRY DataTableEntry;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绕过驱动签名检测</span></span><br><span class="line">    DataTableEntry = (PKLDR_DATA_TABLE_ENTRY)DriverObject-&gt;DriverSection;</span><br><span class="line">    DataTableEntry-&gt;Flags |= <span class="number">0x20</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后续 PsSetCreateProcessNotifyRoutineEx 注册进程回调函数</span></span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    </span><br><span class="line">    DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<h3 id="进程回调分析"><a href="#进程回调分析" class="headerlink" title="进程回调分析"></a>进程回调分析</h3><h4 id="回调注册"><a href="#回调注册" class="headerlink" title="回调注册"></a>回调注册</h4><p>无论是否是扩展回调，进程回调最终都是通过 <code>PspSetCreateProcessNotifyRoutine</code> 函数注册的，而这个函数的第三个参数用来表示是否是扩展回调。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">NTKERNELAPI</span><br><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">PsSetCreateProcessNotifyRoutineEx</span> <span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PCREATE_PROCESS_NOTIFY_ROUTINE_EX NotifyRoutine,</span></span><br><span class="line"><span class="params">    _In_ BOOLEAN Remove</span></span><br><span class="line"><span class="params">    )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PspSetCreateProcessNotifyRoutine(NotifyRoutine, Remove, TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTKERNELAPI</span><br><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">PsSetCreateProcessNotifyRoutine</span> <span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PCREATE_PROCESS_NOTIFY_ROUTINE NotifyRoutine,</span></span><br><span class="line"><span class="params">    _In_ BOOLEAN Remove</span></span><br><span class="line"><span class="params">    )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PspSetCreateProcessNotifyRoutine(NotifyRoutine, Remove, TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTKERNELAPI</span><br><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">PspSetCreateProcessNotifyRoutine</span> <span class="params">(</span></span><br><span class="line"><span class="params">    PVOID NotifyRoutine,</span></span><br><span class="line"><span class="params">    BOOLEAN Remove,</span></span><br><span class="line"><span class="params">    BOOLEAN IsExtended</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<p><code>PspSetCreateProcessNotifyRoutine</code> 函数代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">PspSetCreateProcessNotifyRoutine</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PVOID NotifyRoutine,</span></span><br><span class="line"><span class="params">    _In_ BOOLEAN Remove,</span></span><br><span class="line"><span class="params">    _In_ BOOLEAN IsExtended</span></span><br><span class="line"><span class="params">    )</span></span><br><span class="line">&#123;</span><br><span class="line">    PEX_CALLBACK_ROUTINE_BLOCK CallbackBlock;</span><br><span class="line">    PPSP_NOTIFY_ENTRY NotifyEntry;</span><br><span class="line">    ULONG i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 注销路径：移除已注册的回调</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (Remove)</span><br><span class="line">    &#123;</span><br><span class="line">        PKTHREAD CurrentThread = KeGetCurrentThread();</span><br><span class="line">        KeEnterCriticalRegionThread(CurrentThread);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PSP_MAX_CREATE_PROCESS_NOTIFY; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            NotifyEntry-&gt;CallbackBlock = &amp;PspCreateProcessNotifyRoutine[i];</span><br><span class="line">            CallbackBlock = ExReferenceCallBackBlock(NotifyEntry);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (CallbackBlock == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// 检查回调函数是否匹配</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> ((PVOID)ExGetCallBackBlockRoutine(CallbackBlock) == NotifyRoutine)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// ⚠️类型必须匹配：不能用 EX 注销普通回调，反之亦然</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="keyword">if</span> ((IsExtended &amp;&amp; !NotifyEntry-&gt;IsExtended) ||</span><br><span class="line">                    (!IsExtended &amp;&amp; NotifyEntry-&gt;IsExtended))</span><br><span class="line">                &#123;</span><br><span class="line">                    ExDereferenceCallBackBlock((PEX_CALLBACK)&amp;NotifyEntry-&gt;CallbackBlock, CallbackBlock);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// 原子清除该回调槽</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="keyword">if</span> (ExCompareExchangeCallBack(</span><br><span class="line">                        (PEX_CALLBACK)&amp;NotifyEntry-&gt;CallbackBlock,</span><br><span class="line">                        <span class="literal">NULL</span>,</span><br><span class="line">                        CallbackBlock))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="comment">// 更新回调计数</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="keyword">if</span> (IsExtended)</span><br><span class="line">                        InterlockedDecrement(&amp;PspCreateProcessNotifyRoutineExCount);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        InterlockedDecrement(&amp;PspCreateProcessNotifyRoutineCount);</span><br><span class="line"></span><br><span class="line">                    ExDereferenceCallBackBlock((PEX_CALLBACK)&amp;NotifyEntry-&gt;CallbackBlock, CallbackBlock);</span><br><span class="line"></span><br><span class="line">                    KeLeaveCriticalRegionThread(CurrentThread);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="comment">// 等待所有正在执行的回调完成并释放资源</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    ExWaitForCallBacks(CallbackBlock);</span><br><span class="line">                    ExFreeCallBack(CallbackBlock);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// 匹配失败，释放引用</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            ExDereferenceCallBackBlock((PEX_CALLBACK)&amp;NotifyEntry-&gt;CallbackBlock, CallbackBlock);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        KeLeaveCriticalRegionThread(CurrentThread);</span><br><span class="line">        <span class="keyword">return</span> STATUS_PROCEDURE_NOT_FOUND;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// ⚠️EX 回调需验证是否为有效可回调地址（一般要求驱动签名）</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (IsExtended &amp;&amp; !MmVerifyCallbackFunction(NotifyRoutine))</span><br><span class="line">        <span class="keyword">return</span> STATUS_ACCESS_DENIED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 分配新的回调块</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    CallbackBlock = ExAllocateCallBack((PEX_CALLBACK_FUNCTION)NotifyRoutine, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!CallbackBlock)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 插入到空闲槽</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PSP_MAX_CREATE_PROCESS_NOTIFY; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        NotifyEntry-&gt;CallbackBlock = &amp;PspCreateProcessNotifyRoutine[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ExCompareExchangeCallBack(</span><br><span class="line">                NotifyEntry-&gt;CallbackBlock,</span><br><span class="line">                CallbackBlock,</span><br><span class="line">                <span class="literal">NULL</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// 设置 EX 标志</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            NotifyEntry-&gt;IsExtended = IsExtended;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (IsExtended)</span><br><span class="line">            &#123;</span><br><span class="line">                InterlockedIncrement(&amp;PspCreateProcessNotifyRoutineExCount);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!(PspNotifyEnableMask &amp; PSP_NOTIFY_PROCESS_EX))</span><br><span class="line">                &#123;</span><br><span class="line">                    InterlockedBitTestAndSet(&amp;PspNotifyEnableMask, PSP_NOTIFY_PROCESS_EX_BIT); <span class="comment">// 设置 bit2</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                InterlockedIncrement(&amp;PspCreateProcessNotifyRoutineCount);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!(PspNotifyEnableMask &amp; PSP_NOTIFY_PROCESS))</span><br><span class="line">                &#123;</span><br><span class="line">                    InterlockedBitTestAndSet(&amp;PspNotifyEnableMask, PSP_NOTIFY_PROCESS_BIT); <span class="comment">// 设置 bit1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 没有空位，释放回调块</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    ExFreeCallBack(CallbackBlock);</span><br><span class="line">    <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>对于<strong>注销流程</strong>，该函数的处理逻辑如下：</p>
<ol>
<li>进入线程临界区，防止回调数组竞争；</li>
<li>遍历回调槽 <code>PspCreateProcessNotifyRoutine[i]</code>：<ul>
<li>如果 <code>NotifyRoutine</code> 匹配，并且回调类型也匹配（EX&#x2F;普通）：<ul>
<li>使用 <code>ExCompareExchangeCallBack()</code> 原子替换为 <code>NULL</code>；</li>
<li>更新计数（<code>PspCreateProcessNotifyRoutineCount</code> 或 <code>ExCount</code>）；</li>
<li>等待所有正在执行的回调返回；</li>
<li>调用 <code>ExFreeCallBack()</code> 释放回调资源；</li>
<li>返回 <code>STATUS_SUCCESS</code>。</li>
</ul>
</li>
<li>否则，释放引用，继续查找；</li>
</ul>
</li>
<li>如果未找到匹配回调，返回 <code>STATUS_PROCEDURE_NOT_FOUND</code>。</li>
</ol>
<p>对于<strong>注册流程</strong>，该函数的处理逻辑如下：</p>
<ol>
<li>调用 <code>MmVerifyCallbackFunction</code> 校验函数地址安全性（如签名）；<ul>
<li>失败则返回 <code>STATUS_ACCESS_DENIED</code>。</li>
</ul>
</li>
<li>使用 <code>ExAllocateCallBack()</code> 创建 <code>CallbackBlock</code>；<ul>
<li>失败返回 <code>STATUS_INSUFFICIENT_RESOURCES</code>。</li>
</ul>
</li>
<li>遍历回调槽，尝试原子插入：<ul>
<li>插入成功则：<ul>
<li>设置 <code>IsExtended</code> 标志；</li>
<li>更新对应计数；</li>
<li>设置 <code>PspNotifyEnableMask</code> 中对应 bit（普通&#x2F;EX）；</li>
<li>返回 <code>STATUS_SUCCESS</code>。</li>
</ul>
</li>
</ul>
</li>
<li>所有槽都被占用时，释放分配的回调，返回 <code>STATUS_INVALID_PARAMETER</code>。</li>
</ol>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <ul>
<li>回调槽 <code>PspCreateProcessNotifyRoutine</code> 大小为 <code>PSP_MAX_CREATE_PROCESS_NOTIFY(64)</code>，也就是说我们最多注册 64 个进程回调函数（包括扩展回调和非扩展回调）。</li>
<li>回调函数会按照先后循序放入回调槽，越早注册的函数越靠前，后续也会越早调用，方便拦截后续的回调函数。</li>
</ul>

    </div>
  </div>

<h4 id="回调调用"><a href="#回调调用" class="headerlink" title="回调调用"></a>回调调用</h4><p>对于<strong>进程创建事件</strong>，进程回调函数会在 <code>PspInsertThread</code> 函数中被调用，这是因为第一个线程创建的时候一定是进程创建的时候。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Process-&gt;ActiveThreads == <span class="number">1</span>)  <span class="comment">// 创建主线程后首次触发进程通知</span></span><br><span class="line">&#123;</span><br><span class="line">    EtwTraceProcess(Process, ETW_EVENT_PROCESS_CREATE);  <span class="comment">// ETW 跟踪：创建进程事件（例如 PID 映射）</span></span><br><span class="line"></span><br><span class="line">    NTSTATUS CreationStatus = STATUS_SUCCESS;</span><br><span class="line">    BOOLEAN HasExNotify = (PspNotifyEnableMask &amp; PSP_NOTIFY_PROCESS_EX) != <span class="number">0</span>;  <span class="comment">// 是否启用扩展进程通知（Ex）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否启用了任何进程通知机制（普通或扩展）</span></span><br><span class="line">    <span class="keyword">if</span> (PspNotifyEnableMask &amp; (PSP_NOTIFY_PROCESS | PSP_NOTIFY_PROCESS_EX))</span><br><span class="line">    &#123;</span><br><span class="line">        PFILE_OBJECT FileObject = <span class="literal">NULL</span>;</span><br><span class="line">        BOOLEAN NeedDereference = FALSE;</span><br><span class="line">        PS_CREATE_NOTIFY_INFO NotifyInfo;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// -------------------------------</span></span><br><span class="line">        <span class="comment">// 构建扩展通知结构（EX 回调使用）</span></span><br><span class="line">        <span class="comment">// -------------------------------</span></span><br><span class="line">        <span class="keyword">if</span> (HasExNotify)</span><br><span class="line">        &#123;</span><br><span class="line">            NotifyInfo.Size = <span class="keyword">sizeof</span>(NotifyInfo);</span><br><span class="line">            NotifyInfo.Flags = <span class="number">0</span>;</span><br><span class="line">            NotifyInfo.ParentProcessId = Process-&gt;InheritedFromUniqueProcessId;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取当前线程 CID（Creator）</span></span><br><span class="line">            NotifyInfo.CreatingThreadId = CONTAINING_RECORD(</span><br><span class="line">                KeGetCurrentThread(), _ETHREAD, Tcb)-&gt;Cid;</span><br><span class="line"></span><br><span class="line">            NotifyInfo.CreationStatus = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取进程对应的文件对象（镜像句柄）</span></span><br><span class="line">            <span class="keyword">if</span> (CreateProcessContext &amp;&amp; CreateProcessContext-&gt;FileObject)</span><br><span class="line">            &#123;</span><br><span class="line">                FileObject = CreateProcessContext-&gt;FileObject;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                NeedDereference = TRUE;</span><br><span class="line">                PsReferenceProcessFilePointer(Process, &amp;FileObject);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            NotifyInfo.FileObject = FileObject;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断是否提供了映像文件名</span></span><br><span class="line">            <span class="keyword">if</span> (CreateProcessContext &amp;&amp; (CreateProcessContext-&gt;Flags &amp; <span class="number">0x20</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                NotifyInfo.ImageFileName = &amp;CreateProcessContext-&gt;ImageFileName;</span><br><span class="line">                NotifyInfo.FileOpenNameAvailable = TRUE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                NotifyInfo.ImageFileName = &amp;FileObject-&gt;FileName;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取命令行参数（以 UNICODE_STRING 形式）</span></span><br><span class="line">            <span class="keyword">if</span> (CreateProcessContext &amp;&amp; CreateProcessContext-&gt;CommandLine)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 通常为 RTL_USER_PROCESS_PARAMETERS 的偏移</span></span><br><span class="line">                NotifyInfo.CommandLine = CreateProcessContext-&gt;CommandLine + <span class="number">8</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                NotifyInfo.CommandLine = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// -------------------------------</span></span><br><span class="line">        <span class="comment">// 遍历注册的进程回调函数表</span></span><br><span class="line">        <span class="comment">// -------------------------------</span></span><br><span class="line">        EX_CALLBACK_ROUTINE_BLOCK* CallbackBlock;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_CREATE_PROCESS_NOTIFY; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            CallbackBlock = ExReferenceCallBackBlock(&amp;PspCreateProcessNotifyRoutine[i]);</span><br><span class="line">            <span class="keyword">if</span> (!CallbackBlock)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取注册的回调函数地址</span></span><br><span class="line">            PVOID NotifyRoutine = ExGetCallBackBlockRoutine(CallbackBlock);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (CallbackBlock-&gt;Context)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 扩展回调（带结构体）</span></span><br><span class="line">                <span class="keyword">if</span> (HasExNotify)</span><br><span class="line">                &#123;</span><br><span class="line">                    ((PCREATE_PROCESS_NOTIFY_ROUTINE_EX)NotifyRoutine)(</span><br><span class="line">                        Process,</span><br><span class="line">                        Process-&gt;UniqueProcessId,</span><br><span class="line">                        &amp;NotifyInfo);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 普通回调（旧式三参数）</span></span><br><span class="line">                ((PCREATE_PROCESS_NOTIFY_ROUTINE)NotifyRoutine)(</span><br><span class="line">                    Process-&gt;InheritedFromUniqueProcessId,</span><br><span class="line">                    Process-&gt;UniqueProcessId,</span><br><span class="line">                    TRUE);  <span class="comment">// TRUE 表示创建</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ExDereferenceCallBackBlock(CallbackBlock);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// -------------------------------</span></span><br><span class="line">            <span class="comment">// 回调请求中止进程创建</span></span><br><span class="line">            <span class="comment">// -------------------------------</span></span><br><span class="line">            <span class="keyword">if</span> (HasExNotify &amp;&amp; !NT_SUCCESS(NotifyInfo.CreationStatus))</span><br><span class="line">            &#123;</span><br><span class="line">                PsTerminateProcess(Process, NotifyInfo.CreationStatus);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果我们手动引用了文件对象，需要释放</span></span><br><span class="line">        <span class="keyword">if</span> (NeedDereference)</span><br><span class="line">            ObfDereferenceObject(FileObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <ul>
<li><p><code>PspNotifyEnableMask</code> 是一个<strong>全局的位掩码变量</strong>，用于控制<strong>系统通知类回调（如进程、线程、镜像加载等）</strong>的启用状态。它的每一位分别表示某一类回调是否启用。</p>
<p>  对于进程回调：</p>
<ul>
<li><strong>bit 1</strong>：即代码中的 <code>PSP_NOTIFY_PROCESS_BIT</code>，用于控制普通的 <code>PsSetCreateProcessNotifyRoutine</code> 回调是否启用。</li>
<li><strong>bit 2</strong>：即代码中的 <code>PSP_NOTIFY_PROCESS_EX_BIT</code>，用于控制扩展的 <code>PsSetCreateProcessNotifyRoutineEx</code> 回调是否启用。</li>
</ul>
<p>  因此我们可以短暂清空相关标志位来规避一些敏感行为的监控。
  </p>
</li>
<li><p>如果是<strong>扩展回调</strong>，则设置扩展回调的结构体中 <code>PS_CREATE_NOTIFY_INFO</code> 中的 <code>CreationStatus</code> 可以阻止进程创建。</p>
</li>
<li><p><code>NotifyInfo</code> 在调用扩展回调函数的过程中是共用的，因此我们可以通过修改 <code>NotifyInfo</code> 结构体中的内容从而影响到后续扩展回调函数的判断；同理，<code>Process</code> 结构体也可以被修改。</p>
</li>
</ul>

    </div>
  </div>

<p>对于<strong>进程退出事件</strong>则是在 <code>PspExitProcess</code> 函数中调用的回调函数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 如果启用了进程回调通知（普通或扩展）</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> (PspNotifyEnableMask &amp; (PSP_NOTIFY_PROCESS | PSP_NOTIFY_PROCESS_EX))</span><br><span class="line">&#123;</span><br><span class="line">    ULONG i;</span><br><span class="line">    PEX_CALLBACK_ROUTINE_BLOCK CallbackBlock;</span><br><span class="line">    PCREATE_PROCESS_NOTIFY_ROUTINE CallbackFunction;</span><br><span class="line">    PPSP_NOTIFY_ENTRY NotifyEntry = PspCreateProcessNotifyRoutine;</span><br><span class="line">    BOOLEAN ExtendedEnabled = (PspNotifyEnableMask &amp; PSP_NOTIFY_PROCESS_EX) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PSP_MAX_CREATE_PROCESS_NOTIFY; i++, NotifyEntry++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 尝试引用该回调槽的回调块（如果存在）</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        CallbackBlock = ExReferenceCallBackBlock((PEX_CALLBACK)&amp;NotifyEntry-&gt;CallbackBlock);</span><br><span class="line">        <span class="keyword">if</span> (CallbackBlock == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 如果类型不匹配则跳过（普通回调不调用扩展，反之亦然）</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> (NotifyEntry-&gt;IsExtended &amp;&amp; !ExtendedEnabled)</span><br><span class="line">        &#123;</span><br><span class="line">            ExDereferenceCallBackBlock((PEX_CALLBACK)&amp;NotifyEntry-&gt;CallbackBlock, CallbackBlock);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 提取回调函数指针并调用（Create=FALSE 表示进程退出）</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        CallbackFunction = (PCREATE_PROCESS_NOTIFY_ROUTINE)ExGetCallBackBlockRoutine(CallbackBlock);</span><br><span class="line">        CallbackFunction(</span><br><span class="line">            NotifyEntry-&gt;IsExtended ? Process-&gt;InheritedFromUniqueProcessId : Process-&gt;UniqueProcessId,</span><br><span class="line">            Process-&gt;UniqueProcessId,</span><br><span class="line">            FALSE</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 释放引用</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        ExDereferenceCallBackBlock((PEX_CALLBACK)&amp;NotifyEntry-&gt;CallbackBlock, CallbackBlock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="线程回调"><a href="#线程回调" class="headerlink" title="线程回调"></a>线程回调</h2><p>线程回调是 Windows 内核提供的重要机制之一，允许驱动在<strong>线程创建与销毁事件发生时接收通知</strong>，以实现监控、日志记录、安全检测等功能。Windows 提供了线程回调函数 <code>PCREATE_THREAD_NOTIFY_ROUTINE</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">VOID</span> <span class="params">(*PCREATE_THREAD_NOTIFY_ROUTINE)</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ HANDLE ProcessId,   <span class="comment">// 所属进程的 PID</span></span></span><br><span class="line"><span class="params">    _In_ HANDLE ThreadId,    <span class="comment">// 线程 ID</span></span></span><br><span class="line"><span class="params">    _In_ BOOLEAN Create      <span class="comment">// TRUE 表示线程创建，FALSE 表示线程销毁</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="基础回调注册-1"><a href="#基础回调注册-1" class="headerlink" title="基础回调注册"></a>基础回调注册</h3><p>与进程回调不同，线程回调函数 <code>PCREATE_THREAD_NOTIFY_ROUTINE</code> 的注册和移除函数是两个不同的函数：</p>
<ul>
<li><p><strong>注册线程回调</strong>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NTKERNELAPI</span><br><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">PsSetCreateThreadNotifyRoutine</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>移除线程回调</strong>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NTKERNELAPI</span><br><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">PsRemoveCreateThreadNotifyRoutine</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>示例代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">VOID <span class="title function_">MyThreadNotifyCallback</span><span class="params">(</span></span><br><span class="line"><span class="params">    HANDLE ProcessId,</span></span><br><span class="line"><span class="params">    HANDLE ThreadId,</span></span><br><span class="line"><span class="params">    BOOLEAN Create</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Create) &#123;</span><br><span class="line">        DbgPrint(<span class="string">&quot;线程创建: PID=%p, TID=%p\n&quot;</span>, ProcessId, ThreadId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        DbgPrint(<span class="string">&quot;线程销毁: PID=%p, TID=%p\n&quot;</span>, ProcessId, ThreadId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)</span></span><br><span class="line">&#123;</span><br><span class="line">    PsSetCreateThreadNotifyRoutine(MyThreadNotifyCallback);</span><br><span class="line">    DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span><br><span class="line">&#123;</span><br><span class="line">    PsRemoveCreateThreadNotifyRoutine(MyThreadNotifyCallback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="扩展回调注册-1"><a href="#扩展回调注册-1" class="headerlink" title="扩展回调注册"></a>扩展回调注册</h3><p><code>PsSetCreateThreadNotifyRoutineEx</code> 是 Windows 10 引入的增强线程回调接口，允许驱动程序注册用于监听系统范围内<strong>线程创建和销毁事件</strong>的回调函数。</p>
<p>该函数比旧的 <code>PsSetCreateThreadNotifyRoutine</code> 更灵活，支持控制回调类型（如是否在被创建线程的上下文中调用），并允许特权驱动在系统范围内对线程生命周期进行精细监控。</p>
<p><code>PsSetCreateThreadNotifyRoutineEx</code> 函数声明如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NTKERNELAPI</span><br><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">PsSetCreateThreadNotifyRoutineEx</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PSCREATETHREADNOTIFYTYPE NotifyType,    <span class="comment">// 枚举类型，表示要注册哪种类型的线程通知机制</span></span></span><br><span class="line"><span class="params">    _In_ PVOID NotifyInformation                 <span class="comment">// 实际上是 PCREATE_THREAD_NOTIFY_ROUTINE 的函数指针</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p><code>PsSetCreateThreadNotifyRoutineEx</code> 注册的回调函数依旧使用 <code>PsRemoveCreateThreadNotifyRoutine</code> 卸载。</p>

    </div>
  </div>

<p>其中 <code>PSCREATETHREADNOTIFYTYPE</code> 目前支持下面两种值：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">PSCREATETHREADNOTIFYTYPE</span> &#123;</span></span><br><span class="line">    PsCreateThreadNotifyNonSystem = <span class="number">0</span>,  <span class="comment">// 回调在新线程上执行</span></span><br><span class="line">    PsCreateThreadNotifySubsystems = <span class="number">1</span>  <span class="comment">// 回调为所有子系统线程调用</span></span><br><span class="line">&#125; PSCREATETHREADNOTIFYTYPE;</span><br></pre></td></tr></table></figure></div>

<h3 id="线程回调分析"><a href="#线程回调分析" class="headerlink" title="线程回调分析"></a>线程回调分析</h3><h4 id="回调注册-1"><a href="#回调注册-1" class="headerlink" title="回调注册"></a>回调注册</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 注册线程创建/退出通知回调（普通回调）</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">PsSetCreateThreadNotifyRoutine</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine</span></span><br><span class="line"><span class="params">    )</span></span><br><span class="line">&#123;</span><br><span class="line">    PEX_CALLBACK_ROUTINE_BLOCK CallbackBlock;</span><br><span class="line">    PEX_CALLBACK CallbackSlot;</span><br><span class="line">    ULONG Index;</span><br><span class="line"></span><br><span class="line">    PAGED_CODE();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 分配一个回调块，用于封装回调函数。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    CallbackBlock = ExAllocateCallBack((PEX_CALLBACK_FUNCTION)NotifyRoutine, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (CallbackBlock == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 在回调表中查找空槽插入回调。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">for</span> (Index = <span class="number">0</span>; Index &lt; PSP_MAX_CREATE_THREAD_NOTIFY; Index++)</span><br><span class="line">    &#123;</span><br><span class="line">        CallbackSlot = &amp;PspCreateThreadNotifyRoutine[Index];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ExCompareExchangeCallBack(</span><br><span class="line">                CallbackSlot,</span><br><span class="line">                CallbackBlock,</span><br><span class="line">                <span class="literal">NULL</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// 成功注册，更新回调计数。</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            InterlockedIncrement(&amp;PspCreateThreadNotifyRoutineCount);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// 如果尚未启用线程通知，设置对应的启用掩码位。</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (!(PspNotifyEnableMask &amp; PSP_NOTIFY_THREAD))</span><br><span class="line">            &#123;</span><br><span class="line">                InterlockedBitTestAndSet(&amp;PspNotifyEnableMask, PSP_NOTIFY_THREAD_BIT); <span class="comment">// 设置 bit3</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 未找到空槽，释放分配的回调块。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    ExFreeCallBack(CallbackBlock);</span><br><span class="line">    <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="回调移除"><a href="#回调移除" class="headerlink" title="回调移除"></a>回调移除</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">PsRemoveCreateThreadNotifyRoutine</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine</span></span><br><span class="line"><span class="params">    )</span></span><br><span class="line">&#123;</span><br><span class="line">    PKTHREAD CurrentThread;</span><br><span class="line">    PEX_CALLBACK_ROUTINE_BLOCK CallbackBlock;</span><br><span class="line">    ULONG i;</span><br><span class="line"></span><br><span class="line">    PAGED_CODE();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 禁用 APC 交付（进入关键区域）</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    CurrentThread = KeGetCurrentThread();</span><br><span class="line">    KeEnterCriticalRegionThread(CurrentThread);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PSP_MAX_CREATE_THREAD_NOTIFY; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 获取回调块引用，以便检查其实际回调函数</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        CallbackBlock = ExReferenceCallBackBlock(&amp;PspCreateThreadNotifyRoutine[i]);</span><br><span class="line">        <span class="keyword">if</span> (CallbackBlock == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 比较是否为目标回调函数</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> ((PCREATE_THREAD_NOTIFY_ROUTINE)ExGetCallBackBlockRoutine(CallbackBlock) == NotifyRoutine)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// 原子移除该回调块</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (ExCompareExchangeCallBack(</span><br><span class="line">                    &amp;PspCreateThreadNotifyRoutine[i],</span><br><span class="line">                    <span class="literal">NULL</span>,</span><br><span class="line">                    CallbackBlock))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// 减少注册计数</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                InterlockedDecrement(&amp;PspCreateThreadNotifyRoutineCount);</span><br><span class="line"></span><br><span class="line">                ExDereferenceCallBackBlock(&amp;PspCreateThreadNotifyRoutine[i], CallbackBlock);</span><br><span class="line"></span><br><span class="line">                KeLeaveCriticalRegionThread(CurrentThread);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// 等待所有执行中的回调完成并释放资源</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                ExWaitForCallBacks(CallbackBlock);</span><br><span class="line">                ExFreeCallBack(CallbackBlock);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 非匹配或交换失败，释放引用</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        ExDereferenceCallBackBlock(&amp;PspCreateThreadNotifyRoutine[i], CallbackBlock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 所有回调槽都未找到匹配项</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    KeLeaveCriticalRegionThread(CurrentThread);</span><br><span class="line">    <span class="keyword">return</span> STATUS_PROCEDURE_NOT_FOUND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="回调调用-1"><a href="#回调调用-1" class="headerlink" title="回调调用"></a>回调调用</h4><p>对于<strong>线程创建事件</strong>，线程回调函数在 <code>PspInsertThread</code> 函数中被调用。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 线程创建通知（无论是不是主线程）</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> (PspCreateThreadNotifyRoutineCount != <span class="number">0</span>) &#123;</span><br><span class="line">    ULONG Index;</span><br><span class="line">    PEX_CALLBACK_ROUTINE_BLOCK Callback;</span><br><span class="line">    PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Index = <span class="number">0</span>; Index &lt; PSP_MAX_CREATE_THREAD_NOTIFY; Index++) &#123;</span><br><span class="line">        Callback = ExReferenceCallBackBlock(&amp;PspCreateThreadNotifyRoutine[Index]);</span><br><span class="line">        <span class="keyword">if</span> (Callback != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            NotifyRoutine = (PCREATE_THREAD_NOTIFY_ROUTINE)ExGetCallBackBlockRoutine(Callback);</span><br><span class="line"></span><br><span class="line">            NotifyRoutine(CONTAINING_RECORD(Object-&gt;Tcb.Process, _EPROCESS, Pcb)-&gt;UniqueProcessId,</span><br><span class="line">                          Thread-&gt;Cid.UniqueThread,</span><br><span class="line">                          TRUE);</span><br><span class="line"></span><br><span class="line">            ExDereferenceCallBackBlock(&amp;PspCreateThreadNotifyRoutine[Index], Callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>对于<strong>线程退出事件</strong>，线程回调函数在 <code>PspExitThread</code> 函数中被调用。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 如果启用了线程回调（对应 bit 3），则遍历并调用回调函数</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> (PspNotifyEnableMask &amp; PSP_NOTIFY_THREAD)</span><br><span class="line">&#123;</span><br><span class="line">    PEX_CALLBACK_ROUTINE_BLOCK CallbackBlock;</span><br><span class="line">    PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine;</span><br><span class="line">    ULONG Index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Index = <span class="number">0</span>; Index &lt; PSP_MAX_CREATE_THREAD_NOTIFY; Index++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 尝试引用回调块，防止并发释放</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        CallbackBlock = ExReferenceCallBackBlock(&amp;PspCreateThreadNotifyRoutine[Index]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (CallbackBlock)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// 获取回调函数指针</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            NotifyRoutine = (PCREATE_THREAD_NOTIFY_ROUTINE)ExGetCallBackBlockRoutine(CallbackBlock);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// 执行回调：通知线程即将退出（第三个参数为 FALSE）</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            NotifyRoutine(</span><br><span class="line">                CONTAINING_RECORD(CurThread-&gt;Tcb.Process, _EPROCESS, Pcb)-&gt;UniqueProcessId,   <span class="comment">// 进程 ID</span></span><br><span class="line">                CurThread-&gt;Cid.UniqueThread,    <span class="comment">// 线程 ID</span></span><br><span class="line">                FALSE                      <span class="comment">// FALSE 表示线程退出</span></span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// 解除回调块的引用</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            ExDereferenceCallBackBlock(&amp;PspCreateThreadNotifyRoutine[Index], CallbackBlock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="模块回调"><a href="#模块回调" class="headerlink" title="模块回调"></a>模块回调</h2><p>模块回调是 Windows 内核提供的通知机制之一，允许驱动程序在<strong>任何模块（包括 EXE、DLL、SYS）加载到进程地址空间时收到通知</strong>，以便实现监控、日志记录、DLL 注入检测、签名验证等功能。</p>
<p>Windows 提供的模块回调函数类型为：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">VOID</span> <span class="params">(*PLOAD_IMAGE_NOTIFY_ROUTINE)</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_opt_ PUNICODE_STRING FullImageName, <span class="comment">// 映像完整路径（可能为 NULL）</span></span></span><br><span class="line"><span class="params">    _In_ HANDLE ProcessId,                  <span class="comment">// 映像加载目标进程 ID（0 表示系统进程）</span></span></span><br><span class="line"><span class="params">    _In_ PIMAGE_INFO ImageInfo              <span class="comment">// 映像加载信息结构体指针</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>PIMAGE_INFO</code> 结构体描述了加载的映像的地址、大小和加载类型等信息。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_INFO</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        ULONG Properties;                                         <span class="comment">// 0x00: 属性标志位集合（用于快速判断加载类型）</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ULONG ImageAddressingMode  : <span class="number">8</span>;  <span class="comment">// [bit 0–7]  映像寻址模式：0 = 32位，1 = 64位，其他值为保留</span></span><br><span class="line">            ULONG SystemModeImage      : <span class="number">1</span>;  <span class="comment">// [bit 8]    📌映像是否在内核模式下加载（例如内核驱动）</span></span><br><span class="line">            ULONG ImageMappedToAllPids : <span class="number">1</span>;  <span class="comment">// [bit 9]    是否映射到所有进程（例如共享模块）</span></span><br><span class="line">            ULONG ExtendedInfoPresent  : <span class="number">1</span>;  <span class="comment">// [bit 10]   是否存在扩展映像信息（IMAGE_INFO_EX 结构）</span></span><br><span class="line">            ULONG MachineTypeMismatch  : <span class="number">1</span>;  <span class="comment">// [bit 11]   架构不匹配标志（如加载 x86 模块到 x64）</span></span><br><span class="line">            ULONG ImageSignatureLevel  : <span class="number">4</span>;  <span class="comment">// [bit 12–15]映像签名级别（Windows Defender 驱动执行控制级别）</span></span><br><span class="line">            ULONG ImageSignatureType   : <span class="number">3</span>;  <span class="comment">// [bit 16–18]映像签名类型（PE 签名、Catalog 等）</span></span><br><span class="line">            ULONG ImagePartialMap      : <span class="number">1</span>;  <span class="comment">// [bit 19]   如果整个映像未完全映射则为 1（通常用于特殊加载方式）</span></span><br><span class="line">            ULONG Reserved             : <span class="number">12</span>; <span class="comment">// [bit 20–31]保留字段（必须为 0，供系统未来使用）</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    PVOID ImageBase;                        <span class="comment">// 0x04 / 0x08: 映像映射到进程地址空间中的基地址</span></span><br><span class="line">    ULONG ImageSelector;                    <span class="comment">// 0x08 / 0x10: 保留字段，仅用于 x86（段选择器，现代系统基本无用）</span></span><br><span class="line">    SIZE_T ImageSize;                       <span class="comment">// 0x0C / 0x18: 映像的大小（以字节为单位）</span></span><br><span class="line">    ULONG ImageSectionNumber;              <span class="comment">// 0x10 / 0x20: 所加载映像在 PE 文件中的节索引（可用于调试或定位符号）</span></span><br><span class="line"></span><br><span class="line">&#125; IMAGE_INFO, *PIMAGE_INFO;</span><br></pre></td></tr></table></figure></div>

<h3 id="基础回调注册-2"><a href="#基础回调注册-2" class="headerlink" title="基础回调注册"></a>基础回调注册</h3><p>模块回调函数 <code>PLOAD_IMAGE_NOTIFY_ROUTINE</code> 的注册和移除函数是两个不同的函数：</p>
<ul>
<li><p><strong>注册模块回调</strong>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NTKERNELAPI</span><br><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">PsSetLoadImageNotifyRoutine</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PLOAD_IMAGE_NOTIFY_ROUTINE NotifyRoutine</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>移除模块回调</strong>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NTKERNELAPI</span><br><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">PsRemoveLoadImageNotifyRoutine</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PLOAD_IMAGE_NOTIFY_ROUTINE NotifyRoutine</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>示例代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">VOID <span class="title function_">ImageLoadCallback</span><span class="params">(</span></span><br><span class="line"><span class="params">    PUNICODE_STRING FullImageName,</span></span><br><span class="line"><span class="params">    HANDLE ProcessId,</span></span><br><span class="line"><span class="params">    PIMAGE_INFO ImageInfo</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (FullImageName &amp;&amp; ProcessId != <span class="number">0</span>) &#123;</span><br><span class="line">        DbgPrint(<span class="string">&quot;进程 %p 加载映像：%wZ，基址=%p，大小=0x%Ix\n&quot;</span>,</span><br><span class="line">                 ProcessId,</span><br><span class="line">                 FullImageName,</span><br><span class="line">                 ImageInfo-&gt;ImageBase,</span><br><span class="line">                 ImageInfo-&gt;ImageSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)</span></span><br><span class="line">&#123;</span><br><span class="line">    PsSetLoadImageNotifyRoutine(ImageLoadCallback);</span><br><span class="line">    DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span><br><span class="line">&#123;</span><br><span class="line">    PsRemoveLoadImageNotifyRoutine(ImageLoadCallback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>模块回调的开关位于 <code>PspNotifyEnableMask</code> 的最低位。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define PSP_NOTIFY_IMAGE 1</span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<h3 id="扩展回调注册-2"><a href="#扩展回调注册-2" class="headerlink" title="扩展回调注册"></a>扩展回调注册</h3><p><code>PsSetLoadImageNotifyRoutineEx</code> 是 Win10 引入的模块回调注册函数，相比于旧的 <code>PsSetLoadImageNotifyRoutine</code>，此版本支持传入 <strong>Flags 参数</strong>，以便控制回调行为，如是否通知跨架构（x86&#x2F;x64）映像等。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">PsSetLoadImageNotifyRoutineEx</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PLOAD_IMAGE_NOTIFY_ROUTINE NotifyRoutine,</span></span><br><span class="line"><span class="params">    _In_ ULONG_PTR Flags</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>Flags</code> 目前官方仅定义支持 <code>PS_IMAGE_NOTIFY_CONFLICTING_ARCHITECTURE(0x1)</code>，表示启用跨架构通知（例如：在 x64 系统上也通知加载 x86 模块）。</p>
<h1 id="对象回调（Object-Callbacks）"><a href="#对象回调（Object-Callbacks）" class="headerlink" title="对象回调（Object Callbacks）"></a>对象回调（Object Callbacks）</h1><p>早期防护软件为了拦截对进程、线程等敏感对象的句柄创建&#x2F;复制，普遍使用 SSDT&#x2F;内核钩子等侵入式技术，极易引发系统不稳定。自 <strong>Windows Vista SP1 &#x2F; Windows Server 2008</strong> 起，微软在 Object Manager 上提供了 对<strong>象回调机制（Object Callbacks）</strong>。</p>
<p>在Windows内核中，<strong>对象回调机制（Object Callbacks）</strong>是一种安全和监控机制，允许内核模式驱动程序注册特定的回调函数，以监视或拦截对某些内核对象（例如进程、线程、文件等）的操作。</p>
<h2 id="对象回调使用"><a href="#对象回调使用" class="headerlink" title="对象回调使用"></a>对象回调使用</h2><h3 id="回调注册卸载"><a href="#回调注册卸载" class="headerlink" title="回调注册卸载"></a>回调注册卸载</h3><p>对象回调机制提供了专门的内核函数，用于驱动程序注册和卸载回调：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 注册对象访问回调（例如进程、线程、注册表键等的句柄创建/复制操作）</span></span><br><span class="line"><span class="comment">// 允许驱动拦截并修改访问权限，或进行安全检查与日志记录</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">NTKERNELAPI</span><br><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">ObRegisterCallbacks</span> <span class="params">(</span></span><br><span class="line"><span class="params">    _In_ POB_CALLBACK_REGISTRATION CallbackRegistration,  <span class="comment">// 指向 OB_CALLBACK_REGISTRATION 结构体：</span></span></span><br><span class="line"><span class="params">                                                          <span class="comment">// - 指定监控的对象类型（如 PsProcessType）</span></span></span><br><span class="line"><span class="params">                                                          <span class="comment">// - 指定回调函数（PreOperation / PostOperation）</span></span></span><br><span class="line"><span class="params">                                                          <span class="comment">// - 指定监控的操作类型（创建句柄 / 复制句柄）</span></span></span><br><span class="line"><span class="params">                                                          <span class="comment">// - Altitude：回调优先级字符串（必须唯一）</span></span></span><br><span class="line"><span class="params">    _Outptr_ PVOID *RegistrationHandle                     <span class="comment">// [输出] 返回注册后的句柄（保存驱动内部变量中），</span></span></span><br><span class="line"><span class="params">                                                          <span class="comment">// 可用于后续通过 ObUnRegisterCallbacks 取消回调</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 注销回调函数，释放先前注册的监控行为</span></span><br><span class="line"><span class="comment">// 若驱动卸载前未注销，将导致 BSOD（挂掉）</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">NTKERNELAPI</span><br><span class="line">VOID</span><br><span class="line"><span class="title function_">ObUnRegisterCallbacks</span> <span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PVOID RegistrationHandle                         <span class="comment">// 通过 ObRegisterCallbacks 返回的注册句柄</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p><code>ObRegisterCallbacks</code> 同样要求驱动签名，因此依旧需要进程扩展回调的绕过方法。</p>

    </div>
  </div>

<p>其中 <code>OB_CALLBACK_REGISTRATION</code> 结构用于描述一次对象访问回调注册请求，包含回调的元信息、目标对象类型、回调函数数组等。该结构体定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 结构体: OB_CALLBACK_REGISTRATION</span></span><br><span class="line"><span class="comment">// 用途: 用于描述一次对象访问回调注册请求，包含回调的元信息、目标对象类型、回调函数数组等。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 常用于调用 ObRegisterCallbacks 时填写，注册用于监控进程、线程、注册表等对象访问行为。</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OB_CALLBACK_REGISTRATION</span> &#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 结构体版本号，必须设置为 OB_FLT_REGISTRATION_VERSION（当前为 0x100）</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    USHORT Version;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// OperationRegistration 数组的元素数量，即要注册的对象类型数量（通常为 1~3）</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    USHORT OperationRegistrationCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 回调高度字符串，用于排序执行顺序。</span></span><br><span class="line">    <span class="comment">// Altitude 必须是全系统唯一的字符串，否则注册失败（建议格式：&lt;数字&gt;.&lt;驱动/产品标识符&gt;）</span></span><br><span class="line">    <span class="comment">// 越低的值越早执行（安全软件常注册较低值以优先拦截）</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    UNICODE_STRING Altitude;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 自定义上下文指针，在 PreOperation/PostOperation 回调中可通过 RegistrationContext 参数获取</span></span><br><span class="line">    <span class="comment">// 可用于传递驱动自己的状态结构等（可选）</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    PVOID RegistrationContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 指向 OB_OPERATION_REGISTRATION 数组，每个元素表示一个对象类型及其操作回调配置</span></span><br><span class="line">    <span class="comment">// 通常设置一个或多个项，例如进程对象、线程对象等</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    OB_OPERATION_REGISTRATION* OperationRegistration;</span><br><span class="line">&#125; OB_CALLBACK_REGISTRATION, *POB_CALLBACK_REGISTRATION;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <ul>
<li><code>Version</code>： 结构体版本号，必须设置为 <code>OB_FLT_REGISTRATION_VERSION(0x100)</code>，但是为了防止未来的兼容性问题，<strong>建议使用 <code>ObGetFilterVersion</code> 函数动态获取</strong>。</li>
<li><code>Altitude</code>：微软在内核回调机制（尤其是<strong>对象管理器回调</strong>和<strong>文件过滤驱动</strong>）中用于<strong>排序执行优先级</strong>的机制，本质上是一个<strong>全局唯一的字符串表示的“高度值”</strong>。为了同时支持<strong>优先级排序</strong>和<strong>阅读与区分</strong>，要求格式为 <code>&lt;数字&gt;.&lt;驱动/产品标识符&gt;</code>，例如 <code>320000.MyDriverName</code>。</li>
<li><code>RegistrationContext</code>：定义上下文指针，会作为参数 <code>RegistrationContext</code> 传递给每次触发的 <code>PreOperation</code> &#x2F; <code>PostOperation</code> 回调函数。</li>
</ul>

    </div>
  </div>

<p>我们注册的回调函数位于 <code>OperationRegistration</code> 指向的 <code>OB_OPERATION_REGISTRATION</code> 结构体数组，其中 <code>OperationRegistrationCount</code> 表示数组中元素的数量。<code>OB_OPERATION_REGISTRATION</code> 结构体定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 结构体: OB_OPERATION_REGISTRATION</span></span><br><span class="line"><span class="comment">// 用途: 描述驱动希望拦截的对象类型、操作类型以及对应的回调函数。</span></span><br><span class="line"><span class="comment">//       每个 OB_OPERATION_REGISTRATION 项表示一类对象（如进程、线程）的访问行为拦截配置。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 此结构体是 OB_CALLBACK_REGISTRATION 中的 OperationRegistration 成员的元素类型。</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OB_OPERATION_REGISTRATION</span> &#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 指向要监控的对象类型的全局指针，例如：</span></span><br><span class="line">    <span class="comment">//   - PsProcessType 表示进程对象（&quot;Process&quot;）</span></span><br><span class="line">    <span class="comment">//   - PsThreadType  表示线程对象（&quot;Thread&quot;）</span></span><br><span class="line">    <span class="comment">//   - ExEventObjectType 表示事件对象</span></span><br><span class="line">    <span class="comment">//   - CmKeyObjectType 表示注册表键（需包含 ntddk.h 并开启特定版本支持）</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 注：这些对象类型由系统导出，不能自己构造；也不能比较字符串名称。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    _In_ POBJECT_TYPE *ObjectType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 要拦截的操作类型，可以是以下之一或组合：</span></span><br><span class="line">    <span class="comment">//   - OB_OPERATION_HANDLE_CREATE：表示用户创建对象句柄（如 ZwOpenProcess）</span></span><br><span class="line">    <span class="comment">//   - OB_OPERATION_HANDLE_DUPLICATE：表示复制已有对象句柄（如 DuplicateHandle）</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 示例：拦截创建和复制操作</span></span><br><span class="line">    <span class="comment">//   Operations = OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    _In_ OB_OPERATION Operations;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 预操作回调函数，在对象句柄创建或复制之前被调用。</span></span><br><span class="line">    <span class="comment">// 可以检查访问权限、对象属性等，甚至拒绝访问。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 回调函数类型为：</span></span><br><span class="line">    <span class="comment">// OB_PREOP_CALLBACK_STATUS</span></span><br><span class="line">    <span class="comment">// (*POB_PRE_OPERATION_CALLBACK)(_Inout_ POB_PRE_OPERATION_INFORMATION OperationInformation);</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 返回 OB_PREOP_SUCCESS 表示继续；</span></span><br><span class="line">    <span class="comment">// 返回 OB_PREOP_COMPLETE 表示取消，并跳过后续操作。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    _In_ POB_PRE_OPERATION_CALLBACK PreOperation;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 后操作回调函数，在句柄创建/复制完成后调用（可选）</span></span><br><span class="line">    <span class="comment">// 一般用于记录日志或执行收尾操作，不能修改访问权限。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 回调函数类型为：</span></span><br><span class="line">    <span class="comment">// VOID (*POB_POST_OPERATION_CALLBACK)(_In_ POB_POST_OPERATION_INFORMATION OperationInformation);</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 若不需要后处理，可设为 NULL。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    _In_ POB_POST_OPERATION_CALLBACK PostOperation;</span><br><span class="line"></span><br><span class="line">&#125; OB_OPERATION_REGISTRATION, *POB_OPERATION_REGISTRATION;</span><br></pre></td></tr></table></figure></div>

<p>这个结构体描述了我们要注册的<strong>回调函数</strong>，以及回调函数监控的<strong>对象</strong>和<strong>事件</strong>。</p>
<ul>
<li><p>首先监控<strong>对象</strong>通过 <code>ObjectType</code> 字段描述，这个字段描述要拦截的<strong>对象种类</strong>，如进程、线程、注册表项等。我们需要将其填充为一个系统导出的全局的对象类型描述符指针。</p>
<table>
<thead>
<tr>
<th>对象名称</th>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>进程</td>
<td><code>PsProcessType</code></td>
<td>所有 <code>EPROCESS</code> 对象</td>
</tr>
<tr>
<td>线程</td>
<td><code>PsThreadType</code></td>
<td>所有 <code>ETHREAD</code> 对象</td>
</tr>
<tr>
<td>注册表键</td>
<td><code>CmKeyObjectType</code></td>
<td>所有注册表项对象（<code>KEY_OBJECT</code>）</td>
</tr>
<tr>
<td>事件</td>
<td><code>ExEventObjectType</code></td>
<td>事件对象（非用户事件）</td>
</tr>
<tr>
<td>信号量等</td>
<td><code>ExSemaphoreObjectType</code></td>
<td>同步对象（部分可见）</td>
</tr>
</tbody></table>
</li>
<li><p>监控<strong>事件</strong>通过 <code>Operations</code> 字段描述，用于指定拦截的<strong>操作类型</strong>（是句柄的创建，还是句柄的复制）。该字段是一个位标志（flags），值可以为以下之一或组合：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OB_OPERATION_HANDLE_CREATE     0x00000001  <span class="comment">// 例如 ZwOpenProcess</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OB_OPERATION_HANDLE_DUPLICATE  0x00000002  <span class="comment">// 例如 DuplicateHandle</span></span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>OB_OPERATION_HANDLE_CREATE</code>：当系统执行<strong>创建一个新对象句柄（handle）</strong>时触发此事件，也就是<strong>从用户态请求访问某个对象</strong>，比如进程、线程、注册表项等，进入内核后准备返回一个句柄。</li>
<li><code>OB_OPERATION_HANDLE_DUPLICATE</code>：当系统执行<strong>复制一个已存在的对象句柄</strong>时触发此事件，也就是一个进程希望将已有句柄复制到另一个进程的句柄表中。对应的 API 为 <code>ZwDuplicateObject</code>。</li>
</ul>
</li>
<li><p><code>OB_OPERATION_REGISTRATION</code> 中提供两种类型的<strong>回调函数</strong> <code>PreOperation</code> 和 <code>PostOperation</code>。其中：</p>
<ul>
<li><code>PreOperation</code>：在<strong>句柄创建&#x2F;复制发生之前</strong>调用，允许回调函数修改访问权限，直接阻止访问行为。</li>
<li><code>PostOperation</code>：在<strong>句柄创建&#x2F;复制完成之后</strong>调用，不再允许修改访问权限。</li>
</ul>
<p>注意这两个回调函数至少需要填写一个。</p>
</li>
</ul>
<p>回调函数注册的示例代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntstrsafe.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KLDR_DATA_TABLE_ENTRY</span> &#123;</span></span><br><span class="line">    LIST_ENTRY InLoadOrderLinks;</span><br><span class="line">    ULONG __Undefined1;</span><br><span class="line">    ULONG __Undefined2;</span><br><span class="line">    ULONG __Undefined3;</span><br><span class="line">    ULONG NonPagedDebugInfo;</span><br><span class="line">    ULONG DllBase;</span><br><span class="line">    ULONG EntryPoint;</span><br><span class="line">    ULONG SizeOfImage;</span><br><span class="line">    UNICODE_STRING FullDllName;</span><br><span class="line">    UNICODE_STRING BaseDllName;</span><br><span class="line">    ULONG Flags;</span><br><span class="line">    <span class="comment">// ...(后续字段省略)</span></span><br><span class="line">&#125; KLDR_DATA_TABLE_ENTRY, *PKLDR_DATA_TABLE_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调句柄，全局保存用于卸载时注销</span></span><br><span class="line"><span class="type">static</span> PVOID g_ObCallbackHandle = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 驱动卸载函数：注销回调</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span><br><span class="line">&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(DriverObject);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (g_ObCallbackHandle) &#123;</span><br><span class="line">        ObUnRegisterCallbacks(g_ObCallbackHandle);</span><br><span class="line">        g_ObCallbackHandle = <span class="literal">NULL</span>;</span><br><span class="line">        DbgPrint(<span class="string">&quot;Ob callback unregistered.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DbgPrint(<span class="string">&quot;Driver unloaded.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 驱动入口：注册回调函数</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)</span></span><br><span class="line">&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(RegistryPath);</span><br><span class="line"></span><br><span class="line">    PKLDR_DATA_TABLE_ENTRY DataTableEntry;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绕过驱动签名检测</span></span><br><span class="line">    DataTableEntry = (PKLDR_DATA_TABLE_ENTRY)DriverObject-&gt;DriverSection;</span><br><span class="line">    DataTableEntry-&gt;Flags |= <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line">    OB_CALLBACK_REGISTRATION callbackReg = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    OB_OPERATION_REGISTRATION opReg = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    UNICODE_STRING altitude = RTL_CONSTANT_STRING(<span class="string">L&quot;320000.MyProcessProtector&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填写操作注册结构（进程对象 + 创建句柄操作）</span></span><br><span class="line">    opReg.ObjectType = *PsProcessType;</span><br><span class="line">    opReg.Operations = OB_OPERATION_HANDLE_CREATE;</span><br><span class="line">    opReg.PreOperation = PreProcessHandleCreateCallback;</span><br><span class="line">    opReg.PostOperation = PostProcessHandleCreateCallback;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填写回调注册结构</span></span><br><span class="line">    callbackReg.Version = ObGetFilterVersion();  <span class="comment">// 推荐使用动态版本</span></span><br><span class="line">    callbackReg.OperationRegistrationCount = <span class="number">1</span>;</span><br><span class="line">    callbackReg.Altitude = altitude;</span><br><span class="line">    callbackReg.RegistrationContext = <span class="literal">NULL</span>;</span><br><span class="line">    callbackReg.OperationRegistration = &amp;opReg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册回调</span></span><br><span class="line">    NTSTATUS status = ObRegisterCallbacks(&amp;callbackReg, &amp;g_ObCallbackHandle);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(status)) &#123;</span><br><span class="line">        DbgPrint(<span class="string">&quot;ObRegisterCallbacks failed: 0x%08X\n&quot;</span>, status);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DbgPrint(<span class="string">&quot;Ob callback registered successfully.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="预操作回调函数"><a href="#预操作回调函数" class="headerlink" title="预操作回调函数"></a>预操作回调函数</h3><p><strong>预操作回调函数</strong>是 Windows 内核在执行某些对象访问操作（如进程、线程、注册表键的句柄创建或复制）之前，调用驱动提供的<strong>拦截处理函数</strong>。预操作回调函数类型声明如下，该函数会在，<strong>在对象的句柄尚未创建之前</strong>调用。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 函数类型: POB_PRE_OPERATION_CALLBACK</span></span><br><span class="line"><span class="comment">// 用途: 定义预操作回调函数的函数指针类型。</span></span><br><span class="line"><span class="comment">//       当进程尝试创建或复制对象句柄时（如 ZwOpenProcess），系统将在句柄创建前调用此函数，</span></span><br><span class="line"><span class="comment">//       驱动可根据访问目标、权限请求决定是否修改权限或拒绝访问。</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">OB_PREOP_CALLBACK_STATUS</span></span><br><span class="line"><span class="params">(*POB_PRE_OPERATION_CALLBACK)</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_    PVOID RegistrationContext,                          <span class="comment">// 注册时提供的上下文指针，驱动可用于传递状态或配置</span></span></span><br><span class="line"><span class="params">    _Inout_ POB_PRE_OPERATION_INFORMATION OperationInformation  <span class="comment">// 包含此次对象访问操作的详细信息（如下结构）</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>预操作回调函数只能返回 <code>OB_PREOP_SUCCESS</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">OB_PREOP_CALLBACK_STATUS</span> &#123;</span></span><br><span class="line">    OB_PREOP_SUCCESS</span><br><span class="line">&#125; OB_PREOP_CALLBACK_STATUS, *POB_PREOP_CALLBACK_STATUS;</span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<p>其中 <code>RegistrationContext</code> 参数来自于注册回调函数时 <code>OB_CALLBACK_REGISTRATION</code> 结构体的 <code>RegistrationContext</code> 成员，用于传递用户自定义的参数。</p>
<p>另外 <code>OperationInformation</code> 参数存放了发生回调时保存的信息，该参数对应的 <code>OB_PRE_OPERATION_INFORMATION</code> 结构体定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 结构体: OB_PRE_OPERATION_INFORMATION</span></span><br><span class="line"><span class="comment">// 用途: 描述一次“预操作”回调上下文信息，用于分析当前对象访问行为。</span></span><br><span class="line"><span class="comment">//       提供对象类型、目标对象、访问权限等关键参数，供驱动进行控制。</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OB_PRE_OPERATION_INFORMATION</span> &#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 当前操作类型：</span></span><br><span class="line">    <span class="comment">//   - OB_OPERATION_HANDLE_CREATE（0x1）：请求创建对象句柄</span></span><br><span class="line">    <span class="comment">//   - OB_OPERATION_HANDLE_DUPLICATE（0x2）：请求复制对象句柄</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    _In_ OB_OPERATION Operation;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        _In_ ULONG Flags;         <span class="comment">// 位标志字段，当前仅定义了 KernelHandle 位</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            _In_ ULONG KernelHandle : <span class="number">1</span>; <span class="comment">// 若为 1，表示此操作为内核句柄操作，驱动不可干预</span></span><br><span class="line">            _In_ ULONG Reserved     : <span class="number">31</span>;<span class="comment">// 保留，必须忽略</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 被访问的对象指针，例如 PEPROCESS（进程）、PETHREAD（线程）、PCM_KEY_BODY（注册表键）等</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    _In_ PVOID Object;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 被访问对象的类型指针，用于判断当前对象属于哪类（如 PsProcessType）</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    _In_ POBJECT_TYPE ObjectType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 用户可读写字段，用于驱动在 PreOperation 中设置自定义上下文，</span></span><br><span class="line">    <span class="comment">// 后续可在 PostOperation 中通过该字段获取（用于跨阶段共享状态）</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    _Out_ PVOID CallContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 包含访问操作的参数信息（联合体，依操作类型不同而异）</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    _In_ POB_PRE_OPERATION_PARAMETERS Parameters;</span><br><span class="line"></span><br><span class="line">&#125; OB_PRE_OPERATION_INFORMATION, *POB_PRE_OPERATION_INFORMATION;</span><br></pre></td></tr></table></figure></div>

<p><code>OB_PRE_OPERATION_INFORMATION</code> 结构体主要描述了<strong>事件类型</strong>和<strong>内核对象</strong>相关信息。</p>
<p>由于事件分为 <code>CREATE</code> 和 <code>DUPLICATE</code> 两种，因此事件参数字段 <code>Parameters</code> 是一个联合体 <code>OB_PRE_OPERATION_PARAMETERS</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 联合体: OB_PRE_OPERATION_PARAMETERS</span></span><br><span class="line"><span class="comment">// 用途: 根据当前操作类型（CREATE / DUPLICATE）提供不同的访问参数结构。</span></span><br><span class="line"><span class="comment">//       驱动在回调中通过 Operation 字段判断后选择访问对应成员。</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> _<span class="title">OB_PRE_OPERATION_PARAMETERS</span> &#123;</span></span><br><span class="line">    OB_PRE_CREATE_HANDLE_INFORMATION      CreateHandleInformation;     <span class="comment">// 用于 OB_OPERATION_HANDLE_CREATE</span></span><br><span class="line">    OB_PRE_DUPLICATE_HANDLE_INFORMATION   DuplicateHandleInformation;  <span class="comment">// 用于 OB_OPERATION_HANDLE_DUPLICATE</span></span><br><span class="line">&#125; OB_PRE_OPERATION_PARAMETERS, *POB_PRE_OPERATION_PARAMETERS;</span><br></pre></td></tr></table></figure></div>

<p><strong><code>CREATE</code> 事件</strong>的参数是通过 <code>OB_PRE_CREATE_HANDLE_INFORMATION</code> 结构体描述，该结构体定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 结构体: OB_PRE_CREATE_HANDLE_INFORMATION</span></span><br><span class="line"><span class="comment">// 用途: 当进程请求创建某对象（如进程、线程、注册表）的句柄时，此结构提供访问权限信息。</span></span><br><span class="line"><span class="comment">//       驱动可通过修改 DesiredAccess 字段来控制最终访问权限。</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OB_PRE_CREATE_HANDLE_INFORMATION</span> &#123;</span></span><br><span class="line">    _Inout_ ACCESS_MASK DesiredAccess;          <span class="comment">// 可修改：最终授予用户的访问权限</span></span><br><span class="line">    _In_    ACCESS_MASK OriginalDesiredAccess;  <span class="comment">// 只读：用户原始请求的访问权限</span></span><br><span class="line">&#125; OB_PRE_CREATE_HANDLE_INFORMATION, *POB_PRE_CREATE_HANDLE_INFORMATION;</span><br></pre></td></tr></table></figure></div>

<p>由于是在创建句柄前的回调，因此此时句柄还未创建，也就不会在参数中传入。</p>
<p>这里参数主要传入的是用户打开句柄时的请求权限， <strong><code>DesiredAccess</code> 和 <code>OriginalDesiredAccess</code> 的值传入的是一样的，但是我们只能通过修改 <code>DesiredAccess</code> 来设置最终授予用户的访问权限</strong>。</p>
<blockquote>
<p>Windows 内核之所以在 <code>OB_PRE_CREATE_HANDLE_INFORMATION</code> 中同时提供 <code>OriginalDesiredAccess</code>（只读）和 <code>DesiredAccess</code>（可修改），是为了 <strong>“保护请求意图” 与 “允许干预授权” 分离</strong> —— 这是一种安全审计 + 控制分层设计理念。</p>
</blockquote>
<p>例如下面这个示例代码可以给指定的进程句柄降权，从而达到了保护进程的目的。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要保护的目标进程 PID（可修改）</span></span><br><span class="line"><span class="type">static</span> HANDLE g_ProtectedPid = (HANDLE)<span class="number">1234</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// PreOperation 回调函数：用于检查并修改访问权限</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line">OB_PREOP_CALLBACK_STATUS</span><br><span class="line"><span class="title function_">PreProcessHandleCreateCallback</span><span class="params">(</span></span><br><span class="line"><span class="params">    _Inout_ POB_PRE_OPERATION_INFORMATION OperationInformation</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 只处理句柄创建操作</span></span><br><span class="line">    <span class="keyword">if</span> (OperationInformation-&gt;Operation != OB_OPERATION_HANDLE_CREATE)</span><br><span class="line">        <span class="keyword">return</span> OB_PREOP_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保是进程对象</span></span><br><span class="line">    <span class="keyword">if</span> (OperationInformation-&gt;ObjectType != *PsProcessType)</span><br><span class="line">        <span class="keyword">return</span> OB_PREOP_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取目标进程 PID</span></span><br><span class="line">    PEPROCESS targetProcess = (PEPROCESS)OperationInformation-&gt;Object;</span><br><span class="line">    HANDLE pid = PsGetProcessId(targetProcess);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == g_ProtectedPid) &#123;</span><br><span class="line">        ACCESS_MASK* pAccess = &amp;OperationInformation-&gt;Parameters</span><br><span class="line">            -&gt;CreateHandleInformation.DesiredAccess;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 剥除敏感权限</span></span><br><span class="line">        *pAccess &amp;= ~(PROCESS_TERMINATE | PROCESS_VM_WRITE | PROCESS_VM_READ);</span><br><span class="line"></span><br><span class="line">        DbgPrint(<span class="string">&quot;Protected PID %u: access 0x%08X denied sensitive permissions\n&quot;</span>,</span><br><span class="line">            (ULONG)(ULONG_PTR)pid, *pAccess);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OB_PREOP_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>另外我们还可以通过调整 <code>Altitude</code> 让我们的对象回调函数注册到进程保护模块的对象回调函数之后，这样我们就可以恢复被降权句柄的权限。</p>
<p><strong><code>DUPLICATE</code> 事件</strong>由于是进行<strong>句柄复制</strong>，因此会同时传递<strong>句柄权限</strong>，<strong>源进程</strong>和<strong>目标进程</strong>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 结构体: OB_PRE_DUPLICATE_HANDLE_INFORMATION</span></span><br><span class="line"><span class="comment">// 用途: 当进程请求复制某对象句柄到目标进程时（如 DuplicateHandle），</span></span><br><span class="line"><span class="comment">//       此结构提供权限与进程上下文信息，驱动可进行审查或限制。</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OB_PRE_DUPLICATE_HANDLE_INFORMATION</span> &#123;</span></span><br><span class="line">    _Inout_ ACCESS_MASK DesiredAccess;          <span class="comment">// 可修改：目标进程最终获得的访问权限</span></span><br><span class="line">    _In_    ACCESS_MASK OriginalDesiredAccess;  <span class="comment">// 只读：原始复制请求的权限</span></span><br><span class="line">    _In_    PVOID SourceProcess;                <span class="comment">// 源进程的 EPROCESS 指针（原始句柄所有者）</span></span><br><span class="line">    _In_    PVOID TargetProcess;                <span class="comment">// 目标进程的 EPROCESS 指针（接收者）</span></span><br><span class="line">&#125; OB_PRE_DUPLICATE_HANDLE_INFORMATION, *POB_PRE_DUPLICATE_HANDLE_INFORMATION;</span><br></pre></td></tr></table></figure></div>

<p>这里句柄权限同样分为 <code>DesiredAccess</code> 和 <code>OriginalDesiredAccess</code> 两种。</p>
<h3 id="后操作回调函数"><a href="#后操作回调函数" class="headerlink" title="后操作回调函数"></a>后操作回调函数</h3><p>后操作回调函数，是在<strong>对象访问操作（如创建或复制句柄）完成之后</strong>，由 Windows 内核自动调用的一个函数，用于通知驱动“这次访问操作已经完成”，供驱动执行<strong>观察、记录、收尾处理</strong>等任务。该函数类型 <code>POB_POST_OPERATION_CALLBACK</code> 定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 类型定义: POB_POST_OPERATION_CALLBACK</span></span><br><span class="line"><span class="comment">// 用途: 定义 Ob 对象回调机制中的“后操作回调函数”类型（PostOperation Callback）。</span></span><br><span class="line"><span class="comment">//       当对象句柄创建或复制操作完成后，系统调用该函数以通知驱动执行后续处理。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 特点:</span></span><br><span class="line"><span class="comment">//   - 回调在对象句柄操作完成后被调用（句柄已成功或失败创建/复制）</span></span><br><span class="line"><span class="comment">//   - 不允许修改访问权限、访问控制等核心参数</span></span><br><span class="line"><span class="comment">//   - 通常用于记录日志、行为审计、清理上下文或更新统计信息等</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 注册方式:</span></span><br><span class="line"><span class="comment">//   在 OB_OPERATION_REGISTRATION 中设置 PostOperation 成员指向此函数</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 注意:</span></span><br><span class="line"><span class="comment">//   - 此函数无法阻止访问操作（如拒绝句柄创建），仅用于观察结果</span></span><br><span class="line"><span class="comment">//   - 参数中的 RegistrationContext 来源于 OB_CALLBACK_REGISTRATION 中注册时提供的指针</span></span><br><span class="line"><span class="comment">//   - 参数 OperationInformation 包含操作类型、对象类型、返回状态、上下文等信息</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">VOID</span></span><br><span class="line"><span class="params">(*POB_POST_OPERATION_CALLBACK)</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PVOID RegistrationContext,                             <span class="comment">// 驱动注册时提供的上下文指针，用于传递状态或策略配置</span></span></span><br><span class="line"><span class="params">    _In_ POB_POST_OPERATION_INFORMATION OperationInformation    <span class="comment">// 本次对象访问操作的结果信息结构体（见对应结构定义）</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>OB_POST_OPERATION_INFORMATION</code> 与前面的 <code>OB_PRE_OPERATION_INFORMATION</code> 结构完全一致，只不过 <code>Parameters</code> 的类型由 <code>POB_PRE_OPERATION_PARAMETERS</code> 变成了 <code>POB_POST_OPERATION_PARAMETERS</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OB_POST_OPERATION_INFORMATION</span> &#123;</span></span><br><span class="line">    _In_ OB_OPERATION  Operation;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        _In_ ULONG Flags;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            _In_ ULONG KernelHandle:<span class="number">1</span>;</span><br><span class="line">            _In_ ULONG Reserved:<span class="number">31</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    _In_ PVOID                          Object;</span><br><span class="line">    _In_ POBJECT_TYPE                   ObjectType;</span><br><span class="line">    _In_ PVOID                          CallContext;</span><br><span class="line">    _In_ NTSTATUS                       ReturnStatus;</span><br><span class="line">    _In_ POB_POST_OPERATION_PARAMETERS  Parameters;</span><br><span class="line">&#125; OB_POST_OPERATION_INFORMATION,*POB_POST_OPERATION_INFORMATION;</span><br></pre></td></tr></table></figure></div>

<p>而由于后操作回调函数不修改权限，因此 <code>OB_POST_OPERATION_PARAMETERS</code> 中只有 <code>GrantedAccess</code>，并且对于 <code>DUPLICATE</code> 事件也不提供双方的进程对象地址。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OB_POST_CREATE_HANDLE_INFORMATION</span> &#123;</span></span><br><span class="line">    _In_ ACCESS_MASK            GrantedAccess;</span><br><span class="line">&#125; OB_POST_CREATE_HANDLE_INFORMATION, *POB_POST_CREATE_HANDLE_INFORMATION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OB_POST_DUPLICATE_HANDLE_INFORMATION</span> &#123;</span></span><br><span class="line">    _In_ ACCESS_MASK            GrantedAccess;</span><br><span class="line">&#125; OB_POST_DUPLICATE_HANDLE_INFORMATION, * POB_POST_DUPLICATE_HANDLE_INFORMATION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> _<span class="title">OB_POST_OPERATION_PARAMETERS</span> &#123;</span></span><br><span class="line">    _In_ OB_POST_CREATE_HANDLE_INFORMATION       CreateHandleInformation;</span><br><span class="line">    _In_ OB_POST_DUPLICATE_HANDLE_INFORMATION    DuplicateHandleInformation;</span><br><span class="line">&#125; OB_POST_OPERATION_PARAMETERS, *POB_POST_OPERATION_PARAMETERS;</span><br></pre></td></tr></table></figure></div>

<h2 id="回调相关结构"><a href="#回调相关结构" class="headerlink" title="回调相关结构"></a>回调相关结构</h2><p>对象回调的核心原理是在系统内核中维护一个“<strong>回调注册链表</strong>”，驱动程序通过提供的内核API注册自身的回调函数，并将其插入到对应对象类型（如进程或线程）的回调链表中。</p>
<p>每当内核执行对象操作（如打开句柄、复制句柄）时，都会主动遍历并调用这些注册的回调函数，进行拦截和控制。</p>
<h3 id="OBJECT-TYPE"><a href="#OBJECT-TYPE" class="headerlink" title="OBJECT_TYPE"></a>OBJECT_TYPE</h3><p><code>_OBJECT_TYPE</code> 结构体描述了 <strong>某一种对象类型的整体特征</strong>，例如进程（<code>PsProcessType</code>）、线程（<code>PsThreadType</code>）、文件（<code>IoFileObjectType</code>）等。每个类型在内核中都有一个唯一的 <code>_OBJECT_TYPE</code> 实例，供该类型的所有对象共享。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构大小：0x88 字节</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_TYPE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">TypeList</span>;</span>            <span class="comment">// 0x00: 对象类型链表，用于链接所有 OBJECT_TYPE 实例</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">Name</span>;</span>            <span class="comment">// 0x08: 对象类型名称（如 &quot;Process&quot;、&quot;Thread&quot; 等）</span></span><br><span class="line">    VOID* DefaultObject;                    <span class="comment">// 0x10: 默认对象实例（有些类型提供默认对象，例如 Token）</span></span><br><span class="line">    UCHAR Index;                            <span class="comment">// 0x14: 对象类型索引（用于快速标识类型）</span></span><br><span class="line">    ULONG TotalNumberOfObjects;             <span class="comment">// 0x18: 当前系统中该类型对象的总数量</span></span><br><span class="line">    ULONG TotalNumberOfHandles;             <span class="comment">// 0x1C: 当前系统中指向该类型对象的总句柄数</span></span><br><span class="line">    ULONG HighWaterNumberOfObjects;         <span class="comment">// 0x20: 历史最高同时存在的该类型对象数量</span></span><br><span class="line">    ULONG HighWaterNumberOfHandles;         <span class="comment">// 0x24: 历史最高同时存在的该类型对象句柄数量</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_TYPE_INITIALIZER</span> <span class="title">TypeInfo</span>;</span> <span class="comment">// 0x28: 类型初始化结构，定义该类型对象的行为（如回调、池分配方式等）</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EX_PUSH_LOCK</span> <span class="title">TypeLock</span>;</span>          <span class="comment">// 0x78: 用于保护该类型对象的同步锁</span></span><br><span class="line">    ULONG Key;                              <span class="comment">// 0x7C: 类型校验码或唯一标识符（某些版本中为保留字段）</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">CallbackList</span>;</span>        <span class="comment">// 0x80: 📌对象回调链表，用于支持注册的 ObRegisterCallbacks 回调</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>CallbackList</code> 是一个链表，存放我们注册的对象回调函数的存储结构 <code>OB_CALLBACK_ENTRY</code>。</p>
<h3 id="OBJECT-TYPE-INITIALIZER"><a href="#OBJECT-TYPE-INITIALIZER" class="headerlink" title="OBJECT_TYPE_INITIALIZER"></a>OBJECT_TYPE_INITIALIZER</h3><p><code>_OBJECT_TYPE_INITIALIZER</code> 定义了创建一个对象类型时需要提供的一组 <strong>初始化属性与行为接口</strong>。它是 <code>_OBJECT_TYPE</code> 中 <code>TypeInfo</code> 字段的类型。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0x50 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_TYPE_INITIALIZER</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    USHORT Length;                                          <span class="comment">// 0x00: 结构体大小（用于版本兼容与校验）</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        UCHAR ObjectTypeFlags;                              <span class="comment">// 0x02: 对象类型标志位字段（压缩位）</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            UCHAR CaseInsensitive         : <span class="number">1</span>;              <span class="comment">// [bit 0] 是否大小写不敏感（如符号链接对象）</span></span><br><span class="line">            UCHAR UnnamedObjectsOnly      : <span class="number">1</span>;              <span class="comment">// [bit 1] 是否只允许匿名对象（如事件、信号量等）</span></span><br><span class="line">            UCHAR UseDefaultObject        : <span class="number">1</span>;              <span class="comment">// [bit 2] 是否使用 DefaultObject 提供默认实例</span></span><br><span class="line">            UCHAR SecurityRequired        : <span class="number">1</span>;              <span class="comment">// [bit 3] 创建时是否必须提供安全描述符</span></span><br><span class="line">            UCHAR MaintainHandleCount     : <span class="number">1</span>;              <span class="comment">// [bit 4] 是否维护句柄引用计数</span></span><br><span class="line">            UCHAR MaintainTypeList        : <span class="number">1</span>;              <span class="comment">// [bit 5] 是否加入全局对象类型链表</span></span><br><span class="line">            UCHAR SupportsObjectCallbacks : <span class="number">1</span>;              <span class="comment">// [bit 6] 📌是否支持对象回调（如 ObRegisterCallbacks）</span></span><br><span class="line">            UCHAR Reserved                : <span class="number">1</span>;              <span class="comment">// [bit 7] 保留位</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ULONG ObjectTypeCode;                                   <span class="comment">// 0x04: 对象类型代码（仅供内核识别）</span></span><br><span class="line">    ULONG InvalidAttributes;                                <span class="comment">// 0x08: 无效的属性掩码（用于参数校验）</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">GENERIC_MAPPING</span> <span class="title">GenericMapping</span>;</span>                 <span class="comment">// 0x0C: 用于权限转换的通用映射（GENERIC_READ 等）</span></span><br><span class="line"></span><br><span class="line">    ULONG ValidAccessMask;                                  <span class="comment">// 0x1C: 📌可用的访问权限位（ObCheckObjectAccess 用）</span></span><br><span class="line">    ULONG RetainAccess;                                     <span class="comment">// 0x20: 必须保留的访问权限位（不会被剥夺）</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> _<span class="title">POOL_TYPE</span> <span class="title">PoolType</span>;</span>                               <span class="comment">// 0x24: 对象默认使用的内存池类型</span></span><br><span class="line"></span><br><span class="line">    ULONG DefaultPagedPoolCharge;                           <span class="comment">// 0x28: 分配分页池对象时的默认配额</span></span><br><span class="line">    ULONG DefaultNonPagedPoolCharge;                        <span class="comment">// 0x2C: 分配非分页池对象时的默认配额</span></span><br><span class="line"></span><br><span class="line">    VOID (*DumpProcedure)(                                   <span class="comment">// 0x30: 调试器 !object 调用的对象转储回调</span></span><br><span class="line">        VOID* Object,</span><br><span class="line">        <span class="keyword">struct</span> _OBJECT_DUMP_CONTROL* DumpControl</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    LONG (*OpenProcedure)(                                   <span class="comment">// 0x34: 对象被打开（NtOpenXXX）时的访问控制回调</span></span><br><span class="line">        <span class="keyword">enum</span> _OB_OPEN_REASON OpenReason,</span><br><span class="line">        CHAR PreviousMode,</span><br><span class="line">        <span class="keyword">struct</span> _EPROCESS* Process,</span><br><span class="line">        VOID* Object,</span><br><span class="line">        ULONG* GrantedAccess,</span><br><span class="line">        ULONG HandleCount</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    VOID (*CloseProcedure)(                                  <span class="comment">// 0x38: 对象句柄关闭（NtClose）时调用的回调</span></span><br><span class="line">        <span class="keyword">struct</span> _EPROCESS* Process,</span><br><span class="line">        VOID* Object,</span><br><span class="line">        ULONG GrantedAccess,</span><br><span class="line">        ULONG HandleCount</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    VOID (*DeleteProcedure)(                                 <span class="comment">// 0x3C: 对象引用归零被删除时触发的清理回调</span></span><br><span class="line">        VOID* Object</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    LONG (*ParseProcedure)(                                  <span class="comment">// 0x40: 对象路径解析（如 NtOpenFile 解析路径）</span></span><br><span class="line">        VOID* ParsedObject,</span><br><span class="line">        VOID* RemainingPath,</span><br><span class="line">        <span class="keyword">struct</span> _ACCESS_STATE* AccessState,</span><br><span class="line">        CHAR AccessMode,</span><br><span class="line">        ULONG Attributes,</span><br><span class="line">        <span class="keyword">struct</span> _UNICODE_STRING* CompleteName,</span><br><span class="line">        <span class="keyword">struct</span> _UNICODE_STRING* RemainingName,</span><br><span class="line">        VOID* Context,</span><br><span class="line">        <span class="keyword">struct</span> _SECURITY_QUALITY_OF_SERVICE* SecurityQos,</span><br><span class="line">        VOID** NewObject</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    LONG (*SecurityProcedure)(                               <span class="comment">// 0x44: 安全描述符读取/修改操作回调</span></span><br><span class="line">        VOID* Object,</span><br><span class="line">        <span class="keyword">enum</span> _SECURITY_OPERATION_CODE OperationCode,</span><br><span class="line">        ULONG* SecurityInformation,</span><br><span class="line">        VOID* SecurityDescriptor,</span><br><span class="line">        ULONG* BufferLength,</span><br><span class="line">        VOID** NewSecurityDescriptor,</span><br><span class="line">        <span class="keyword">enum</span> _POOL_TYPE PoolType,</span><br><span class="line">        <span class="keyword">struct</span> _GENERIC_MAPPING* Mapping,</span><br><span class="line">        CHAR AccessMode</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    LONG (*QueryNameProcedure)(                              <span class="comment">// 0x48: 查询对象名称信息的回调（如 NtQueryObject）</span></span><br><span class="line">        VOID* Object,</span><br><span class="line">        UCHAR HasAccess,</span><br><span class="line">        <span class="keyword">struct</span> _OBJECT_NAME_INFORMATION* NameInfo,</span><br><span class="line">        ULONG NameInfoLength,</span><br><span class="line">        ULONG* ReturnLength,</span><br><span class="line">        CHAR AccessMode</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    UCHAR (*OkayToCloseProcedure)(                           <span class="comment">// 0x4C: 判断是否允许关闭对象句柄（可用于保护特定句柄）</span></span><br><span class="line">        <span class="keyword">struct</span> _EPROCESS* Process,</span><br><span class="line">        VOID* Object,</span><br><span class="line">        VOID* Handle,</span><br><span class="line">        CHAR PreviousMode</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>SupportsObjectCallbacks</code> 决定对象回调是否有效，如果将这个位置 0 则对象回调会失效。不过这个位被 PG 监控，不能长期修改。</p>
<p>另外 <code>ValidAccessMask</code> 表示的是可用的访问权限，如果这个位置 0 则该对象无法打开。例如内核中的 <code>DbgkDebugObjectType</code> 指向 <code>DebugObject</code> 的对象类型，如果把该类型的 <code>ValidAccessMask</code> 置 0 则会导致全局调试禁用。</p>
<p><code>OBJECT_TYPE_INITIALIZER</code> 中还有一些列的回调函数，这些回调函数会针对不同内核对象的不同特性而指向不同的函数。</p>
<ul>
<li><strong><code>DumpProcedure</code></strong> ：供调试工具（如 WinDbg 的 <code>!object</code> 扩展）用于打印对象内部状态，包括类型、引用计数、属性等。</li>
<li><strong><code>OpenProcedure</code></strong> ：当对象句柄打开时回调，允许拦截或修改访问请求。比如安全软件会在此处检查权限或拒绝打开。这个函数会在 <code>ObpCreateHandle</code> 内部处理时调用那个预操作（PreOperation）回调，以便对访问进行管理。</li>
<li><strong><code>CloseProcedure</code></strong> ：句柄关闭时执行，常用于资源释放、日志记录或实现引用计数清理机制。在用户调用 <code>NtClose</code>、<code>CloseHandle</code> 或句柄被回收时触发。</li>
<li><strong><code>DeleteProcedure</code></strong> ：当对象未再被引用且要销毁前调用，允许释放分配的结构体、内存或执行其他最终清理工作。通常在 <code>ObDereferenceObject</code> 导致引用计数为零，内核准备释放该对象时调用。</li>
<li><strong><code>ParseProcedure</code></strong> ：负责解析特定命名空间路径（如文件系统、设备路径等），并创建或引用对应对象。如从 <code>\Device\...</code> 路径进行 <code>NtOpenFile</code> 时，内核遍历命名空间，并在每个组件调用该回调函数。</li>
<li><strong><code>SecurityProcedure</code></strong> ：例如在 <code>NtQuerySecurityObject</code>、<code>NtSetSecurityObject</code> 等操作中，被调用以读取、安全验证、设置或重新编码安全描述符。通常在对象需要读取、设置或枚举安全信息时，在 <code>ObpCreateHandle</code> 或 <code>ObQuerySecurityObject</code> 等路径中触发。</li>
<li><strong><code>QueryNameProcedure</code></strong> ：当用户通过 API 查询对象名称（如文件名、进程名、设备路径）时，负责填充输出缓冲区。在 <code>NtQueryObject(..., ObjectNameInformation)</code> 时调用，用于提供准确名称信息。</li>
<li><strong><code>OkayToCloseProcedure</code></strong> ：在某些安全敏感或关键对象上使用，可拒绝某进程关闭句柄的请求，从而防止被篡改或持久化控制。在 <code>NtClose</code> 处理阶段，如果此回调返回 <code>FALSE</code>，系统将拒绝关闭句柄。</li>
</ul>
<p>例如我们在调用 <code>NtClose(hObject)</code> 有如下过程：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">NtClose(hObject)</span><br><span class="line">│</span><br><span class="line">├─ ObpCloseHandle</span><br><span class="line">│   │</span><br><span class="line">│   ├─ 🎯 调用 ObpCloseHandleTableEntry</span><br><span class="line">│   │   │</span><br><span class="line">│   │   ├─ 🔍 调用 OkayToCloseProcedure（可拒绝句柄关闭）</span><br><span class="line">│   │   │     ├─ 返回 TRUE → 继续</span><br><span class="line">│   │   │     └─ 返回 FALSE → ❌ STATUS_HANDLE_NOT_CLOSABLE</span><br><span class="line">│   │   │</span><br><span class="line">│   │   └─ 🔢 调用 ObpDecrementHandleCount（递减句柄计数）</span><br><span class="line">│   │         │</span><br><span class="line">│   │         └─ 🔔 调用 CloseProcedure（不可拒绝，仅通知行为）</span><br><span class="line">│   │              └─ 适用于日志、资源同步、Handle DB 清理等</span><br><span class="line">│   │</span><br><span class="line">│   └─ ObDereferenceObject</span><br><span class="line">│       │</span><br><span class="line">│       └─ ObfDereferenceObjectWithTag</span><br><span class="line">│           │</span><br><span class="line">│           └─ ObpRemoveObjectRoutine（对象引用为 0 时触发）</span><br><span class="line">│               │</span><br><span class="line">│               ├─ 🔐 调用 SecurityProcedure（若注册）</span><br><span class="line">│               │     └─ 可校验、更新、释放安全描述符</span><br><span class="line">│               │</span><br><span class="line">│               └─ 💣 调用 DeleteProcedure（若注册）</span><br><span class="line">│                     └─ 最终释放资源、销毁对象</span><br></pre></td></tr></table></figure></div>

<h3 id="OB-CALLBACK-HANDLE"><a href="#OB-CALLBACK-HANDLE" class="headerlink" title="OB_CALLBACK_HANDLE"></a>OB_CALLBACK_HANDLE</h3><p>当我们调用 <code>ObRegisterCallbacks</code> 注册回调函数成功后会返回一个 <code>RegistrationHandle</code> 句柄。实际上 <code>RegistrationHandle</code> 指向的是 <code>OB_CALLBACK_HANDLE</code>（未公开）结构体。</p>
<p>这个结构体中保存了我们注册内核对象回调时的 <code>OB_CALLBACK_REGISTRATION</code> 结构体传递的信息，并且结构与 <code>OB_CALLBACK_REGISTRATION</code> 也非常相似。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 对象回调注册结构体（即 ObRegisterCallbacks 返回的 RegistrationHandle 所指向的结构）</span></span><br><span class="line"><span class="comment">// 用于表示一个完整的注册上下文，包括注册的回调项、Altitude 等信息。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OB_CALLBACK_HANDLE</span> &#123;</span></span><br><span class="line">    USHORT Version;                          <span class="comment">// 注册结构版本号，必须为 OB_FLT_REGISTRATION_VERSION</span></span><br><span class="line">    USHORT OperationRegistrationCount;       <span class="comment">// 实际成功注册的回调项数量（CallbackEntryArray 中的项数）</span></span><br><span class="line">    PVOID RegistrationContext;               <span class="comment">// 调用者定义的上下文，可在回调中访问</span></span><br><span class="line">    UNICODE_STRING Altitude;                 <span class="comment">// 注册高度（Altitude），用于排序回调优先级（越高越先执行）</span></span><br><span class="line">    OB_CALLBACK_ENTRY CallbackEntryArray[<span class="number">1</span>]; <span class="comment">// 变长数组，用于存储所有回调项（按需分配内存）</span></span><br><span class="line">&#125; OB_CALLBACK_HANDLE, *POB_CALLBACK_HANDLE;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p><code>ObRegisterCallbacks</code> 在申请 <code>OB_CALLBACK_HANDLE</code> 结构体所需内存时，会在 <code>OB_CALLBACK_HANDLE</code> 的最后额外多申请一部分内存，用于存放 <code>Altitude</code> 中的字符串。</p>

    </div>
  </div>

<p>其中 <code>CallbackEntryArray</code> 是一个 <code>OB_CALLBACK_ENTRY</code> 数组，对应着 <code>OB_CALLBACK_REGISTRATION</code> 的 <code>OperationRegistration</code> 字段。里面保存在我们注册的回调函数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 单个对象操作回调项，挂入指定对象类型的 CallbackList 中</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OB_CALLBACK_ENTRY</span> &#123;</span></span><br><span class="line">    LIST_ENTRY CallbackList;               <span class="comment">// 链表节点，挂入 ObjectType-&gt;CallbackList 链表</span></span><br><span class="line">    ULONG Operations;                      <span class="comment">// 触发操作标志：如 OB_OPERATION_HANDLE_CREATE / DUPLICATE</span></span><br><span class="line">    ULONG Flags;                           <span class="comment">// 状态标志：如 OB_CALLBACK_ACTIVE_FLAG</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">OB_CALLBACK_HANDLE</span>* <span class="title">CallbackHandle</span>;</span>  <span class="comment">// 所属回调句柄（OB_CALLBACK_HANDLE），用于回溯清理</span></span><br><span class="line">    POBJECT_TYPE ObjectType;              <span class="comment">// 注册目标对象类型（如 PsProcessType、PsThreadType）</span></span><br><span class="line">    POB_PRE_OPERATION_CALLBACK PreOperation;   <span class="comment">// 创建或复制前的预回调函数指针</span></span><br><span class="line">    POB_POST_OPERATION_CALLBACK PostOperation; <span class="comment">// 创建或复制后的后回调函数指针</span></span><br><span class="line">    EX_RUNDOWN_REF RundownRef;            <span class="comment">// Rundown 保护，用于延迟释放 CallbackEntry</span></span><br><span class="line">&#125; OB_CALLBACK_ENTRY, *POB_CALLBACK_ENTRY;</span><br></pre></td></tr></table></figure></div>

<p>这个结构通过 <code>CallbackList</code> 字段挂到 <code>OBJECT_TYPE</code> 的 <code>CallbackList</code> 链表上。</p>
<h2 id="对象回调分析"><a href="#对象回调分析" class="headerlink" title="对象回调分析"></a>对象回调分析</h2><h3 id="对象回调注册"><a href="#对象回调注册" class="headerlink" title="对象回调注册"></a>对象回调注册</h3><p><code>ObRegisterCallbacks</code> 根据我们传入的 <code>CallbackRegistration</code> 结构构造填充一个 <code>POB_CALLBACK_HANDLE</code> 结构，并调用 <code>ObpInsertCallbackByAltitude</code> 函数将其中 <code>CallbackEntryArray</code> 数组中的所有的 <code>POB_CALLBACK_ENTRY</code> 按照 <code>Altitude</code> 顺序挂到 <code>OBJECT_TYPE</code> 的 <code>CallbackList</code> 链表上。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS NTAPI <span class="title function_">ObRegisterCallbacks</span><span class="params">(</span></span><br><span class="line"><span class="params">    POB_CALLBACK_REGISTRATION CallbackRegistration,</span></span><br><span class="line"><span class="params">    PVOID* RegistrationHandle</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    USHORT RegistrationCount;</span><br><span class="line">    SIZE_T AllocationSize;</span><br><span class="line">    POB_CALLBACK_HANDLE CallbackHandle;</span><br><span class="line">    POB_CALLBACK_ENTRY CallbackEntry;</span><br><span class="line">    UNICODE_STRING* Altitude;</span><br><span class="line">    WCHAR* AltitudeBuffer;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    ULONG i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// [验证结构版本]</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> ((CallbackRegistration-&gt;Version &amp; <span class="number">0xFF00</span>) != OB_FLT_REGISTRATION_VERSION)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line"></span><br><span class="line">    RegistrationCount = CallbackRegistration-&gt;OperationRegistrationCount;</span><br><span class="line">    <span class="keyword">if</span> (RegistrationCount == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// [计算所需内存大小并分配]</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    AllocationSize =</span><br><span class="line">        FIELD_OFFSET(OB_CALLBACK_HANDLE, CallbackEntryArray) +      <span class="comment">// 固定部分</span></span><br><span class="line">        RegistrationCount * <span class="keyword">sizeof</span>(OB_CALLBACK_ENTRY) +             <span class="comment">// 全部回调项</span></span><br><span class="line">        CallbackRegistration-&gt;Altitude.Length;                      <span class="comment">// Altitude 字符串</span></span><br><span class="line"></span><br><span class="line">    CallbackHandle = (POB_CALLBACK_HANDLE)ExAllocatePoolWithTag(PagedPool, AllocationSize, <span class="string">&#x27;ObCl&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!CallbackHandle)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line"></span><br><span class="line">    RtlZeroMemory(CallbackHandle, AllocationSize);</span><br><span class="line"></span><br><span class="line">    CallbackHandle-&gt;Version = OB_FLT_REGISTRATION_VERSION;</span><br><span class="line">    CallbackHandle-&gt;RegistrationContext = CallbackRegistration-&gt;RegistrationContext;</span><br><span class="line">    CallbackHandle-&gt;OperationRegistrationCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// [拷贝 Altitude 字符串至结构尾部]</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    AltitudeBuffer = (WCHAR*)((PUCHAR)CallbackHandle + AllocationSize - CallbackRegistration-&gt;Altitude.Length);</span><br><span class="line">    RtlCopyMemory(AltitudeBuffer, CallbackRegistration-&gt;Altitude.Buffer, CallbackRegistration-&gt;Altitude.Length);</span><br><span class="line"></span><br><span class="line">    Altitude = &amp;CallbackHandle-&gt;Altitude;</span><br><span class="line">    Altitude-&gt;Length = CallbackRegistration-&gt;Altitude.Length;</span><br><span class="line">    Altitude-&gt;MaximumLength = Altitude-&gt;Length;</span><br><span class="line">    Altitude-&gt;Buffer = AltitudeBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// [逐项注册回调]</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; RegistrationCount; ++i) &#123;</span><br><span class="line">        <span class="type">const</span> OB_OPERATION_REGISTRATION* OperationRegistration = &amp;CallbackRegistration-&gt;OperationRegistration[i];</span><br><span class="line">        POBJECT_TYPE ObjectType = *OperationRegistration-&gt;ObjectType;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证对象类型支持回调</span></span><br><span class="line">        <span class="keyword">if</span> (!OperationRegistration-&gt;Operations || !ObjectType-&gt;TypeInfo.SupportsObjectCallbacks) &#123;</span><br><span class="line">            Status = STATUS_INVALID_PARAMETER;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证回调函数合法性</span></span><br><span class="line">        <span class="keyword">if</span> (OperationRegistration-&gt;PreOperation &amp;&amp;</span><br><span class="line">            !MmVerifyCallbackFunction((PVOID)OperationRegistration-&gt;PreOperation)) &#123;</span><br><span class="line">            Status = STATUS_ACCESS_DENIED;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (OperationRegistration-&gt;PostOperation &amp;&amp;</span><br><span class="line">            !MmVerifyCallbackFunction((PVOID)OperationRegistration-&gt;PostOperation)) &#123;</span><br><span class="line">            Status = STATUS_ACCESS_DENIED;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填充当前回调项</span></span><br><span class="line">        CallbackEntry = &amp;CallbackHandle-&gt;CallbackEntryArray[i];</span><br><span class="line">        CallbackEntry-&gt;Operations = OperationRegistration-&gt;Operations;</span><br><span class="line">        CallbackEntry-&gt;CallbackHandle = CallbackHandle;</span><br><span class="line">        CallbackEntry-&gt;ObjectType = ObjectType;</span><br><span class="line">        CallbackEntry-&gt;PreOperation = OperationRegistration-&gt;PreOperation;</span><br><span class="line">        CallbackEntry-&gt;PostOperation = OperationRegistration-&gt;PostOperation;</span><br><span class="line">        CallbackEntry-&gt;Reserved = <span class="number">0</span>;</span><br><span class="line">        InitializeListHead(&amp;CallbackEntry-&gt;CallbackList);</span><br><span class="line"></span><br><span class="line">        Status = ObpInsertCallbackByAltitude(CallbackEntry, ObjectType);</span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        CallbackHandle-&gt;OperationRegistrationCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// [失败时清理已插入回调]</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; CallbackHandle-&gt;OperationRegistrationCount; ++i) &#123;</span><br><span class="line">            POB_CALLBACK_ENTRY Entry = &amp;CallbackHandle-&gt;CallbackEntryArray[i];</span><br><span class="line">            POBJECT_TYPE ObjectType = Entry-&gt;ObjectType;</span><br><span class="line">            EX_PUSH_LOCK* Lock = &amp;ObjectType-&gt;TypeLock;</span><br><span class="line"></span><br><span class="line">            KeEnterCriticalRegion();</span><br><span class="line">            ExAcquirePushLockExclusive(Lock);</span><br><span class="line">            RemoveEntryList(&amp;Entry-&gt;CallbackList);</span><br><span class="line">            ExReleasePushLockExclusive(Lock);</span><br><span class="line">            KeLeaveCriticalRegion();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ExFreePoolWithTag(CallbackHandle, <span class="string">&#x27;ObCl&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">        <span class="comment">// [成功：标记所有回调为激活状态]</span></span><br><span class="line">        <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; CallbackHandle-&gt;OperationRegistrationCount; ++i) &#123;</span><br><span class="line">            CallbackHandle-&gt;CallbackEntryArray[i].Flags |= OB_CALLBACK_ACTIVE_FLAG;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *RegistrationHandle = CallbackHandle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>ObpInsertCallbackByAltitude</code> 函数则会根据 <code>Altitude</code> 找到合适的位置插入链表。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">ObpInsertCallbackByAltitude</span><span class="params">(</span></span><br><span class="line"><span class="params">    POB_CALLBACK_ENTRY CallbackEntry,</span></span><br><span class="line"><span class="params">    POBJECT_TYPE ObjectType</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    PLIST_ENTRY CallbackListHead;</span><br><span class="line">    PLIST_ENTRY Current;</span><br><span class="line">    UNICODE_STRING* Altitude;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// [进入关键区，获取对象类型的回调锁（PushLock 排他模式）]</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    KeEnterCriticalRegion();</span><br><span class="line">    ExAcquirePushLockExclusive(&amp;ObjectType-&gt;TypeLock);</span><br><span class="line"></span><br><span class="line">    CallbackListHead = &amp;ObjectType-&gt;CallbackList;</span><br><span class="line">    Current = CallbackListHead-&gt;Flink;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取插入项的 Altitude（优先级字符串）</span></span><br><span class="line">    Altitude = &amp;CallbackEntry-&gt;CallbackHandle-&gt;Altitude;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// [遍历对象类型的回调链表，按 Altitude 降序查找插入位置]</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">while</span> (Current != CallbackListHead) &#123;</span><br><span class="line">        POB_CALLBACK_ENTRY Entry =</span><br><span class="line">            CONTAINING_RECORD(Current, OB_CALLBACK_ENTRY, CallbackList);</span><br><span class="line"></span><br><span class="line">        POB_CALLBACK_HANDLE Registration = Entry-&gt;CallbackHandle;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> CompareResult = RtlCompareAltitudes(</span><br><span class="line">            &amp;Registration-&gt;Altitude,</span><br><span class="line">            Altitude</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (CompareResult &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Altitude 相同表示冲突</span></span><br><span class="line">            <span class="keyword">if</span> (CompareResult == <span class="number">0</span>) &#123;</span><br><span class="line">                Status = STATUS_FLT_INSTANCE_ALTITUDE_COLLISION;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Current = Current-&gt;Flink;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// [执行插入或因冲突返回错误]</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (NT_SUCCESS(Status)) &#123;</span><br><span class="line">        InsertTailList(Current-&gt;Blink, &amp;CallbackEntry-&gt;CallbackList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// [释放锁并恢复 APC 状态]</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    ExReleasePushLockExclusive(&amp;ObjectType-&gt;TypeLock);</span><br><span class="line">    KeLeaveCriticalRegion();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> windows 内核回调</li>
        <li><strong>Author:</strong> sky123</li>
        <li><strong>Created at
                :</strong> 2022-09-28 11:45:14</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2025-07-07 01:17:38
            </li>
        
        <li>
            <strong>Link:</strong> https://skyi23.github.io/2022/09/28/windows 内核回调/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/windows-kernel-reverse/">#windows kernel reverse</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2022/09/28/windows%20%E5%8F%A5%E6%9F%84%E8%A1%A8/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">windows 句柄表</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2022/09/28/windows%20%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">windows 系统调用</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'skyI23/my-giscus-discussions',
                'data-repo-id': 'R_kgDONL9k_w',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDONL9k_84CkEdK',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">windows 内核回调</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%9F%A5%E5%9E%8B%E5%9B%9E%E8%B0%83%EF%BC%88Notify-Callbacks%EF%BC%89"><span class="nav-text">系统通知型回调（Notify Callbacks）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%9B%9E%E8%B0%83"><span class="nav-text">进程回调</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E5%9B%9E%E8%B0%83%E6%B3%A8%E5%86%8C"><span class="nav-text">基础回调注册</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E5%9B%9E%E8%B0%83%E6%B3%A8%E5%86%8C"><span class="nav-text">扩展回调注册</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%9B%9E%E8%B0%83%E5%88%86%E6%9E%90"><span class="nav-text">进程回调分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E8%B0%83%E6%B3%A8%E5%86%8C"><span class="nav-text">回调注册</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E8%B0%83%E8%B0%83%E7%94%A8"><span class="nav-text">回调调用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%9B%9E%E8%B0%83"><span class="nav-text">线程回调</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E5%9B%9E%E8%B0%83%E6%B3%A8%E5%86%8C-1"><span class="nav-text">基础回调注册</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E5%9B%9E%E8%B0%83%E6%B3%A8%E5%86%8C-1"><span class="nav-text">扩展回调注册</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%9B%9E%E8%B0%83%E5%88%86%E6%9E%90"><span class="nav-text">线程回调分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E8%B0%83%E6%B3%A8%E5%86%8C-1"><span class="nav-text">回调注册</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E8%B0%83%E7%A7%BB%E9%99%A4"><span class="nav-text">回调移除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E8%B0%83%E8%B0%83%E7%94%A8-1"><span class="nav-text">回调调用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E5%9B%9E%E8%B0%83"><span class="nav-text">模块回调</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E5%9B%9E%E8%B0%83%E6%B3%A8%E5%86%8C-2"><span class="nav-text">基础回调注册</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E5%9B%9E%E8%B0%83%E6%B3%A8%E5%86%8C-2"><span class="nav-text">扩展回调注册</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%9B%9E%E8%B0%83%EF%BC%88Object-Callbacks%EF%BC%89"><span class="nav-text">对象回调（Object Callbacks）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%9B%9E%E8%B0%83%E4%BD%BF%E7%94%A8"><span class="nav-text">对象回调使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E8%B0%83%E6%B3%A8%E5%86%8C%E5%8D%B8%E8%BD%BD"><span class="nav-text">回调注册卸载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%84%E6%93%8D%E4%BD%9C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="nav-text">预操作回调函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E6%93%8D%E4%BD%9C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="nav-text">后操作回调函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E8%B0%83%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84"><span class="nav-text">回调相关结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#OBJECT-TYPE"><span class="nav-text">OBJECT_TYPE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OBJECT-TYPE-INITIALIZER"><span class="nav-text">OBJECT_TYPE_INITIALIZER</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OB-CALLBACK-HANDLE"><span class="nav-text">OB_CALLBACK_HANDLE</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%9B%9E%E8%B0%83%E5%88%86%E6%9E%90"><span class="nav-text">对象回调分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%9B%9E%E8%B0%83%E6%B3%A8%E5%86%8C"><span class="nav-text">对象回调注册</span></a></li></ol></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2024</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">sky123</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        40 posts in total
                    </span>
                    
                        <span>
                            646.6k words in total
                        </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>



<script src="/js/build/libs/Swup.min.js"></script>

<script src="/js/build/libs/SwupSlideTheme.min.js"></script>

<script src="/js/build/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/build/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/build/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/build/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	
<script src="/js/build/tools/imageViewer.js" type="module"></script>

<script src="/js/build/utils.js" type="module"></script>

<script src="/js/build/main.js" type="module"></script>

<script src="/js/build/layouts/navbarShrink.js" type="module"></script>

<script src="/js/build/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/build/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/build/layouts/categoryList.js" type="module"></script>



    
<script src="/js/build/tools/localSearch.js" type="module"></script>




    
<script src="/js/build/tools/codeBlock.js" type="module"></script>




    
<script src="/js/build/layouts/lazyload.js" type="module"></script>




    
<script src="/js/build/tools/runtime.js"></script>

    
<script src="/js/build/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/build/libs/Typed.min.js"></script>

  
<script src="/js/build/plugins/typed.js" type="module"></script>




    
        
<script src="/js/build/libs/mermaid.min.js"></script>

    
    
<script src="/js/build/plugins/mermaid.js"></script>






    
<script src="/js/build/libs/anime.min.js"></script>





    
<script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script>





    
<script src="/js/build/layouts/bookmarkNav.js" type="module"></script>


	
</body>

</html>