<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="sky123">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://skyi23.github.io/2022/09/28/windows 内核态逆向开发/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/null" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/null">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/null">
    <!--- Page Info-->
    
    <title>
        
            windows 内核态逆向开发 | sky123&#39;s site
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/css/build/tailwind.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" rel="stylesheet">
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"skyi23.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":true,"family":"JetBrains Mono","url":"https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap"}},"toc":{"enable":true,"max_depth":5,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"open_graph":{"enable":false,"image":"/images/redefine-og.webp","description":"Hexo Theme Redefine, Redefine Your Hexo Journey."},"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"sky123's blog","subtitle":{"text":["书有未曾经我读，事无不可对人言"],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":true,"version":"11.4.1"}},"version":"2.8.2","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"分类":{"icon":"fa-solid fa-folder","path":"/categories/"},"标签":{"icon":"fa-solid fa-tags","path":"/tags/"},"书签":{"icon":"fa-solid fa-bookmark","path":"/bookmarks/"}},"search":{"enable":true,"preload":true}},"page_templates":{"bookmarks_column":3,"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2024/11/7 00:00:00"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha256-TThEtR+XalhWKkfF383YLOrI50NGNeIqrzS+q08afrY=" crossorigin="anonymous"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>



<body>
	<div class="progress-bar-container">
	
	<span class="scroll-progress-bar"></span>
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                sky123&#39;s site
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/categories/"
                                        >
                                    <i class="fa-solid fa-folder fa-fw"></i>
                                    分类
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/tags/"
                                        >
                                    <i class="fa-solid fa-tags fa-fw"></i>
                                    标签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/bookmarks/"
                                        >
                                    <i class="fa-solid fa-bookmark fa-fw"></i>
                                    书签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/categories/"
                        >
                            <span>
                                分类
                            </span>
                            
                                <i class="fa-solid fa-folder fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/tags/"
                        >
                            <span>
                                标签
                            </span>
                            
                                <i class="fa-solid fa-tags fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/bookmarks/"
                        >
                            <span>
                                书签
                            </span>
                            
                                <i class="fa-solid fa-bookmark fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">11</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">14</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">35</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">windows 内核态逆向开发</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/icon.jpg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">sky123</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2022-09-28 11:45:14</span>
        <span class="mobile">2022-09-28 11:45:14</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-06-16 03:28:06</span>
            <span class="mobile">2025-06-16 03:28:06</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/reverse/">reverse</a>&nbsp;
                        </li>
                    
                    
                
                    
                        
                            <li>></li>
                        
                        <li>
                            <a href="/categories/reverse/windows-kernel/">windows kernel</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/windows-kernel-reverse/">windows kernel reverse</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>39.7k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>157 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<p><a class="link"   target="_blank" rel="noopener" href="https://www.vergiliusproject.com/" >https://www.vergiliusproject.com/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h1 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h1><p>参考 <a href="attachments/325462-sdm-vol-1-2abcd-3abcd.pdf">英特尔开发手册</a></p>
<h2 id="CPU-的模式"><a href="#CPU-的模式" class="headerlink" title="CPU 的模式"></a>CPU 的模式</h2><p>x86 CPU 的三个主要模式分别是实模式（Real Mode）、保护模式（Protected Mode）和虚拟8086模式（Virtual 8086 Mode）。它们各自的功能和特点如下：</p>
<h3 id="实模式（Real-Mode）"><a href="#实模式（Real-Mode）" class="headerlink" title="实模式（Real Mode）"></a>实模式（Real Mode）</h3><ul>
<li><strong>简介</strong> ：实模式是x86架构最早的工作模式，与8086 CPU的工作方式相同。</li>
<li><strong>内存管理</strong> ：在实模式下，CPU可以访问1MB的内存。内存地址是通过段寄存器和偏移地址组合来形成的，总地址空间为20位。</li>
<li><strong>特点</strong> ：<ul>
<li>没有内存保护机制，即程序可以访问所有内存区域，包括操作系统内核和其他程序的数据。</li>
<li>没有多任务支持，所有程序运行在同一个地址空间中。</li>
<li>简单的地址计算：物理地址 &#x3D; 段寄存器 * 16 + 偏移地址。</li>
</ul>
</li>
<li><strong>用途</strong> ：实模式主要用于早期的DOS操作系统和初始系统引导过程。</li>
</ul>
<h3 id="保护模式（Protected-Mode）"><a href="#保护模式（Protected-Mode）" class="headerlink" title="保护模式（Protected Mode）"></a>保护模式（Protected Mode）</h3><ul>
<li><strong>简介</strong> ：保护模式是为了提供更高级的内存管理和多任务处理而设计的，是现代操作系统（如Windows、Linux）运行的基础模式。</li>
<li><strong>内存管理</strong> ：保护模式下，CPU可以访问4GB的内存地址空间，使用32位地址。引入了分页（Paging）和分段（Segmentation）机制。</li>
<li><strong>特点</strong> ：<ul>
<li>支持内存保护，防止一个程序访问另一个程序的内存区域。</li>
<li>支持硬件级别的多任务处理，通过任务状态段（TSS）进行任务切换。</li>
<li>支持虚拟内存，通过分页机制，可以使用物理内存之外的存储空间。</li>
<li>提供特权级别（Privilege Levels），通常有四个环（Ring 0到Ring 3），用于控制访问权限和隔离内核与用户程序。</li>
</ul>
</li>
<li><strong>用途</strong> ：保护模式用于运行复杂的多任务操作系统，如Windows、Linux等。</li>
</ul>
<h3 id="虚拟8086模式（Virtual-8086-Mode）"><a href="#虚拟8086模式（Virtual-8086-Mode）" class="headerlink" title="虚拟8086模式（Virtual 8086 Mode）"></a>虚拟8086模式（Virtual 8086 Mode）</h3><ul>
<li><strong>简介</strong> ：虚拟8086模式是保护模式的一部分，允许在保护模式下运行实模式应用程序。它引入了一种机制，使得保护模式操作系统可以运行多个8086虚拟机。</li>
<li><strong>内存管理</strong> ：每个虚拟8086模式下的任务都有自己独立的1MB地址空间，模拟实模式的内存管理。</li>
<li><strong>特点</strong> ：<ul>
<li>兼容性：允许在现代操作系统上运行旧的实模式程序。</li>
<li>隔离：每个虚拟8086任务被隔离在自己的内存空间内，受保护模式的内存保护机制保护。</li>
<li>性能：在保护模式下，通过硬件支持的虚拟化技术，可以高效地执行实模式代码。</li>
</ul>
</li>
<li><strong>用途</strong> ：虚拟8086模式用于在保护模式操作系统（如Windows NT系列）中运行DOS程序。</li>
</ul>
<h2 id="保护模式下的地址"><a href="#保护模式下的地址" class="headerlink" title="保护模式下的地址"></a>保护模式下的地址</h2><p>在保护模式下，x86 CPU通过<strong>段式内存管理</strong>和<strong>分页机制</strong>来转换和管理<strong>逻辑地址</strong>、<strong>虚拟地址</strong>和<strong>物理地址</strong>。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/df792f4a88f2cc9705abc70c9ffd90bd.png"
                      alt="在这里插入图片描述"
                ></p>
<p>三种地址的转换具体如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/image-20250602014852488.png"
                      alt="image-20250602014852488"
                ></p>
<h3 id="逻辑地址（Logical-Address）"><a href="#逻辑地址（Logical-Address）" class="headerlink" title="逻辑地址（Logical Address）"></a>逻辑地址（Logical Address）</h3><ul>
<li><strong>组成</strong> ：<strong>逻辑地址</strong>由<strong>段选择子</strong>（Segment Selector）和<strong>段内偏移</strong>（Offset）组成。</li>
<li><strong>格式</strong> ：<code>Logical Address = Segment Selector:Offset</code></li>
<li><strong>作用</strong> ：逻辑地址是程序员在代码中使用的地址形式。<ul>
<li><strong>段选择子</strong>决定了使用哪个段描述符</li>
<li><strong>偏移量</strong>则指示在该段内的具体位置。</li>
</ul>
</li>
</ul>
<h3 id="虚拟地址（Virtual-Address）"><a href="#虚拟地址（Virtual-Address）" class="headerlink" title="虚拟地址（Virtual Address）"></a>虚拟地址（Virtual Address）</h3><ul>
<li><strong>生成</strong> ：通过<strong>段选择子</strong>从<strong>段描述符表</strong>（GDT或LDT）中找到对应的<strong>段描述符</strong>，利用<strong>段描述符中的基址</strong>（Base Address）加上<strong>偏移量</strong>（即逻辑地址中的段内偏移）得到虚拟地址。</li>
<li><strong>格式</strong> ：<code>Virtual Address = Base Address (from Segment Descriptor) + Offset</code></li>
<li><strong>作用</strong> ：虚拟地址是CPU在段内的线性地址，它可以直接被分页单元使用以进一步转换为物理地址。</li>
</ul>
<h3 id="物理地址（Physical-Address）"><a href="#物理地址（Physical-Address）" class="headerlink" title="物理地址（Physical Address）"></a>物理地址（Physical Address）</h3><ul>
<li><strong>生成</strong> ：<strong>虚拟地址</strong>通过<strong>分页机制</strong>（如果启用）被转换成<strong>物理地址</strong>。分页机制使用页目录（Page Directory）和页表（Page Table）来完成这个转换。</li>
<li><strong>作用</strong> ：物理地址是内存芯片上的实际地址，是最终用于存储器访问的地址。</li>
</ul>
<h2 id="段式内存管理"><a href="#段式内存管理" class="headerlink" title="段式内存管理"></a>段式内存管理</h2><p>段式内存管理（Segmentation）是x86架构保护模式下的内存管理机制之一。它通过将内存划分为多个段，每个段都有独立的基址、大小和访问权限，以便对内存进行更加灵活和安全的管理。</p>
<p>不过在 32 位下由于访问范围为 4GB，因此通常设置基址为 0 。</p>
<h3 id="段寄存器（Segment-Registers）"><a href="#段寄存器（Segment-Registers）" class="headerlink" title="段寄存器（Segment Registers）"></a>段寄存器（Segment Registers）</h3><p>段寄存器用于保存段选择子，指示当前正在使用的段。x86 CPU中有多个段寄存器，每个寄存器对应不同类型的内存段。</p>
<h4 id="主要段寄存器"><a href="#主要段寄存器" class="headerlink" title="主要段寄存器"></a>主要段寄存器</h4><p>32 位 Windows（x86）段寄存器：</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>Ring 3 (用户态)</th>
<th>Ring 0 (内核态)</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CS</td>
<td>0x1B</td>
<td>0x08</td>
<td>代码段</td>
</tr>
<tr>
<td>DS</td>
<td>0x23</td>
<td>0x10</td>
<td>数据段</td>
</tr>
<tr>
<td>SS</td>
<td>0x23</td>
<td>0x10</td>
<td>栈段</td>
</tr>
<tr>
<td>ES</td>
<td>0x23</td>
<td>0x10</td>
<td>额外数据段(一般等于 DS)</td>
</tr>
<tr>
<td>FS</td>
<td>0x3B</td>
<td>0x30</td>
<td>用户态: <code>TEB</code>，内核态: <code>KPCR</code></td>
</tr>
<tr>
<td>GS</td>
<td>0x00</td>
<td>0x00</td>
<td>通常未使用</td>
</tr>
</tbody></table>
<p> 64 位 Windows（x64）段寄存器：</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>Ring 3 (用户态)</th>
<th>Ring 0 (内核态)</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CS</td>
<td>0x33</td>
<td>0x10</td>
<td>代码段</td>
</tr>
<tr>
<td>DS</td>
<td>0x00</td>
<td>0x00</td>
<td>被忽略，平坦段</td>
</tr>
<tr>
<td>SS</td>
<td>0x00</td>
<td>0x00</td>
<td>被忽略，平坦段</td>
</tr>
<tr>
<td>ES</td>
<td>0x00</td>
<td>0x00</td>
<td>被忽略，平坦段</td>
</tr>
<tr>
<td>FS</td>
<td>0x00 (或用于 WOW64)</td>
<td>0x00</td>
<td>兼容层用，64 位下一般不用</td>
</tr>
<tr>
<td>GS</td>
<td>0x53 (或配置值)</td>
<td>0x10</td>
<td>用户态: <code>TEB</code>，内核态: <code>KPCR</code></td>
</tr>
</tbody></table>
<h4 id="段寄存器结构"><a href="#段寄存器结构" class="headerlink" title="段寄存器结构"></a>段寄存器结构</h4><p>在x86保护模式下，每个段寄存器有一个16位的可见部分（段选择子）和一个80位的隐含部分（包含段基址、界限和属性）。所以，段寄存器的总长度是96位，其中只有16位是可见的。当然不可见的部分其实对我们来说是透明的，因为这一部分在段寄存器中的属性是从段描述符中加载出来，以提高内存访问速度。</p>
<p>为了更准确地描述段寄存器，可以使用如下的结构体：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentRegister</span> &#123;</span></span><br><span class="line">    WORD Selector;     <span class="comment">// 段选择子 16位 可见</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        WORD Attributes; <span class="comment">// 段属性 16位 不可见</span></span><br><span class="line">        DWORD Limit;   <span class="comment">// 段大小 20位（界限）+ 12位标志，不可见</span></span><br><span class="line">        DWORD Base;    <span class="comment">// 段基址 32位 不可见</span></span><br><span class="line">    &#125; Hidden;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/4f2684f1ab4ad202e7f03c900f782bdb.png"
                      alt="在这里插入图片描述"
                ></p>
<ul>
<li><p><strong>Selector（段选择子）</strong> ：段寄存器中唯一可见的部分，它包含段选择子的索引、TI（表指示位）和RPL（请求特权级别）。Selector用于在GDT或LDT中查找段描述符。</p>
<ul>
<li><strong>索引（Index）</strong> ：段描述符在描述符表（GDT 或 LDT）中的索引。</li>
<li><strong>TI（Table Indicator）</strong> ：指示使用全局描述符表（GDT）还是局部描述符表（LDT）。<ul>
<li>0：使用 GDT。</li>
<li>1：使用 LDT。</li>
</ul>
</li>
<li><strong>RPL（Requested Privilege Level）</strong> ：请求的特权级别，用于权限检查。</li>
</ul>
</li>
<li><p><strong>Base（段基址）</strong> ：段的起始地址，由段描述符中的 Base 字段组成。Base 字段在段描述符中分为三部分（低、中、高），合并后形成完整的 32 位基址。</p>
</li>
<li><p><strong>Limit（段大小）</strong> ：段的界限，由段描述符中的 Limit 字段组成。Limit 字段也分为低 16 位和高 4 位，高 4 位包含在段描述符的高字节中。Limit 通常表示段的大小。</p>
</li>
<li><p><strong>Attributes（段属性）</strong> ：段的属性和类型信息，包括段的类型（代码段、数据段）、DPL（描述符特权级别）、存在位（P）、扩展向下位（D&#x2F;B）、可访问位（A）等。</p>
</li>
</ul>
<h4 id="段寄存器读写"><a href="#段寄存器读写" class="headerlink" title="段寄存器读写"></a>段寄存器读写</h4><h5 id="数据段寄存器"><a href="#数据段寄存器" class="headerlink" title="数据段寄存器"></a>数据段寄存器</h5><p>数据段寄存器读写通常是通过寄存器完成的，例如 <code>mov ds, ax</code>，<code>mov ax, es</code> 等。</p>
<p>另外 <code>push</code> 和 <code>pop</code> 这种栈操作指令同样可以读写数据段寄存器，例如 <code>push fs</code>，<code>pop fs</code> 等，在开发中我们通常利用这个方法来保存段寄存器环境。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p><code>ss</code> 寄存器也能通过 <code>mov</code> 指令修改，但是 <code>ss</code> 的 RPL 要保持不变。因为 <code>ss</code> 的 RPL 和 <code>cs</code> 的 RPL 同为 CPL，段权限管理要求 <code>cs</code> 和 <code>ss</code> 的 RPL 要始终保持相同，而仅通过 <code>mov</code> 指令修改 <code>ss</code> 的 RPL 显然不符合这一规定。</p>

    </div>
  </div>

<h5 id="代码段寄存器"><a href="#代码段寄存器" class="headerlink" title="代码段寄存器"></a>代码段寄存器</h5><p><code>cs</code> 寄存器不能通过 <code>mov</code> 和 <code>pop</code> 指令修改（不过可以使用 <code>push cs</code> 和 <code>mov ax, cs</code> 这种指令来读取 <code>cs</code> 寄存器的值），因此我们必须通过<strong>跨段跳转</strong>指令来修改 <code>cs</code> 寄存器。 例如 <code>jmp fword</code> 和 <code>call fword</code> 指令：</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">jmp</span> <span class="built_in">far</span> <span class="meta">segment</span>:offset</span><br><span class="line"><span class="keyword">call</span> <span class="built_in">far</span> <span class="meta">segment</span>:offset</span><br></pre></td></tr></table></figure></div>

<p>然而在 MSVC（尤其是 32 位 x86 平台）中的内联汇编在语法上不支持这种直接立即数跳转：</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">jmp</span> <span class="built_in">far</span> <span class="number">0x1234</span>:<span class="number">0x5678</span></span><br><span class="line"><span class="keyword">call</span> <span class="built_in">far</span> <span class="number">0x1234</span>:<span class="number">0x5678</span></span><br></pre></td></tr></table></figure></div>

<p>因此我们需要使用 <code>call fword ptr [mem]</code> 指令来代替：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FarPointer</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset;    <span class="comment">// 32 位</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> selector; <span class="comment">// 16 位</span></span><br><span class="line">&#125; fp = &#123;<span class="number">0x5678</span>, <span class="number">0x1234</span>&#125;;</span><br><span class="line"></span><br><span class="line">__asm &#123;</span><br><span class="line">    jmp fword ptr ds:[fp]</span><br><span class="line">    call fword ptr ds:[fp]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>对于 <code>call fword ptr</code> 和 <code>call far</code> 指令，如果 <strong>CPL 不变</strong>则会在向栈中依次压入<strong>调用者的 cs</strong> 和<strong>返回地址</strong>（CPL 变化的情况比较复杂，具体见调用门部分）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/image-20250603005133672.png"
                      alt="image-20250603005133672"
                ></p>
<p>因此我们返回时需要通过 <code>retf</code> 指令返回。如果调用前在栈上压入了参数，那么我们可以通过 <code>retf [参数的字节总数]</code> 来平衡堆栈。</p>
<p>为了避免编译器在函数代码中生成堆栈帧（<code>push ebp</code>&#x2F;<code>mov ebp, esp</code>…），我们需要借助<strong>裸函数（naked function）</strong>精确控制函数的入口和返回指令。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__declspec(naked) <span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        <span class="comment">// 这里写汇编指令</span></span><br><span class="line">        retf</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>除此之外中断指令 <code>int</code> 以及对应的返回指令 <code>iret</code> 同样会修改 <code>cs</code> 寄存器，具体同样见后面的分析。</p>
<h3 id="段描述符表（Descriptor-Table）"><a href="#段描述符表（Descriptor-Table）" class="headerlink" title="段描述符表（Descriptor Table）"></a>段描述符表（Descriptor Table）</h3><h4 id="段描述符表种类"><a href="#段描述符表种类" class="headerlink" title="段描述符表种类"></a>段描述符表种类</h4><p>段描述符表是存储段描述符的结构，定义了各个段的属性。x86 架构中有两种主要的段描述符表：<strong>全局描述符表（GDT）</strong>和<strong>局部描述符表（LDT）</strong>。</p>
<h5 id="全局描述符表（GDT-Global-Descriptor-Table）"><a href="#全局描述符表（GDT-Global-Descriptor-Table）" class="headerlink" title="全局描述符表（GDT, Global Descriptor Table）"></a>全局描述符表（GDT, Global Descriptor Table）</h5><ul>
<li><strong>作用</strong> ：全局描述符表用于定义系统范围内的段，包括代码段、数据段和系统段（如任务状态段TSS）。</li>
<li><strong>存储位置</strong> ：GDT存储在内存中的一个固定位置，其基址和界限由 GDTR（GDT Register）寄存器保存。</li>
<li><strong>访问方式</strong> ：通过段选择子中的 TI 位（Table Indicator）为 0 来选择 GDT 。</li>
<li><strong>相关汇编指令</strong> ：<ul>
<li><code>lgdt [mem]</code> → 加载 GDT</li>
<li><code>sgdt [mem]</code> → 存储 GDT（SGDT 可以在 Ring 3 执行，常用于探测系统）</li>
</ul>
</li>
</ul>
<p>关于 GDT 有如下常用的调试命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>r gdtr</code>&#x2F;<code>r gdtl</code></td>
<td>查看 GDT 基地址和长度</td>
</tr>
<tr>
<td><code>!gdt</code></td>
<td>列出当前处理器的 GDT 表项</td>
</tr>
<tr>
<td><code>!gdt &lt;n&gt;</code></td>
<td>查看某个段选择子的详细描述符</td>
</tr>
<tr>
<td><code>dg &lt;selector&gt; [count]</code></td>
<td>解析段选择子 <code>selector</code> 开始的 <code>count</code> 个段描述符</td>
</tr>
<tr>
<td><code>~&lt;n&gt;</code></td>
<td>切换到第 n 个处理器上下文</td>
</tr>
</tbody></table>
<h5 id="局部描述符表（LDT-Local-Descriptor-Table）"><a href="#局部描述符表（LDT-Local-Descriptor-Table）" class="headerlink" title="局部描述符表（LDT, Local Descriptor Table）"></a>局部描述符表（LDT, Local Descriptor Table）</h5><ul>
<li><p><strong>作用</strong> ：局部描述符表用于定义特定任务或进程的段，通常用于多任务环境中。</p>
</li>
<li><p><strong>存储位置</strong> ：LDT 也存储在内存中的一个固定位置，其基址和界限由 LDTR（LDT Register）寄存器保存。</p>
</li>
<li><p><strong>访问方式</strong> ：通过段选择子中的 TI 位为 1 来选择 LDT 。</p>
</li>
<li><p><strong>相关汇编指令</strong> ：</p>
<ul>
<li><code>lldt reg/mem</code> → 加载 LDTR</li>
<li><code>sldt reg/mem</code> → 存储 LDTR（Ring 3 可执行）</li>
<li><code>str reg/mem</code> → 存储任务寄存器（可用于 TSS 调试）</li>
</ul>
</li>
</ul>
<p>关于 LDT 有如下常用的调试命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>r ldtr</code>&#x2F;<code>r ldtl</code></td>
<td>查看 LDT 基地址和长度</td>
</tr>
</tbody></table>
<h4 id="段描述符（Segment-Descriptor）"><a href="#段描述符（Segment-Descriptor）" class="headerlink" title="段描述符（Segment Descriptor）"></a>段描述符（Segment Descriptor）</h4><p>段描述符是描述段属性的结构体，存储在GDT或LDT中。每个段描述符占用8个字节，包含段的基址、界限和属性等信息。</p>
<p>一个段描述符的结构如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/SegmentDescriptor.svg"
                      alt="Figure 3-8. Segment Descriptor"
                ></p>
<ul>
<li><p><strong>基址（Base Address）</strong> ：段的起始地址，由 8 位高位基址（<code>Base 31:24</code>）、8 位中位基址（<code>Base 23:16</code>）和 16 位低位基址（<code>Base Address 15:00</code>）组成，共32位。</p>
</li>
<li><p><strong>界限（Limit）</strong> ：段的大小，由 16 位低位界限（<code>Limit 15:0</code>）和 4 位高位界限（<code>Limit 19:16</code>）组成，共 20 位。</p>
</li>
<li><p><strong>P（Present）</strong> ：段存在位，1 表示段存在。段描述符加载时，首先看 P 位是否为 1 。</p>
</li>
<li><p><strong>DPL（Descriptor Privilege Level）</strong> ：描述符的特权级别，共 2 位。</p>
</li>
<li><p><strong>S（Descriptor Type）</strong>，<strong>Type</strong> ：<code>S</code> 描述符类型，<code>Type</code> 根据 <code>S</code> 的不同含义不同。</p>
<ul>
<li><p><code>S</code> 为 0 表示系统段，此时 <code>Type</code> 描述系统段的类型（如调用门，中断门，陷阱门等），含义如下表所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/image-20250602003006973.png"
                      alt="image-20250602003006973"
                ></p>
</li>
<li><p><code>S</code> 为 1 表示代码段或数据段，此时 <code>Type</code> 描述段的具体类型（如代码段、数据段）和访问权限，含义如下表所示。</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/image-20250601231301425.png"
                      alt="image-20250601231301425"
                ></p>
<p>另外 <code>Type</code> 对应代码段和数据段时分别引入了一个新概念：</p>
<ul>
<li><strong>一致代码段（Conforming Code Segment）</strong><ul>
<li>当 <code>Type</code> 的 11 位为 1 时段描述符表示的是代码段，此时如果 <code>C</code> 位（10 位）为 1 则表示为一致代码段。</li>
<li>一致代码段是指当 CPU 执行跨特权级的代码段切换（比如调用更高权限的代码段）时，<strong>不需要特权级检查</strong>，允许直接进入。</li>
<li>CPU 不会在段切换时更改 CPL（因为一致代码段特权级不敏感）。</li>
</ul>
</li>
<li><strong>向下拓展数据段（Expand-Down Data Segment）</strong><ul>
<li>当 <code>Type</code> 的 11 位为 0 时段描述符表示的是数据段，此时如果 <code>E</code> 位（10 位）为 1 则表示为向下拓展。</li>
<li>正常情况下的我们见到的数据段都是向上拓展的，即有效偏移范围是从 <code>0</code> 到 <code>Limit</code> 。</li>
<li>对于向下拓展的数据段，有效偏移范围是从 <code>Limit + 1</code> 到最大偏移值（例如，<code>0xFFFF</code> 或 <code>0xFFFFFFFF</code>，取决于段的大小）。由于 <code>Base + Limit</code> 会溢出，因此实际的有效范围是 <code>[Base, Base + Limit)</code> 之外的范围。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>G位（Granularity）</strong> ：决定界限单位。</p>
<ul>
<li>0 表示段寄存器的 <code>Limit</code> 元素单位为字节，即最大范围为 0x000FFFFF（1MB）。</li>
<li>1 表示段寄存器的 <code>Limit</code> 元素单位为 4KB ，即最大范围为 0xFFFFFFFF（4GB）。</li>
</ul>
</li>
<li><p><strong>D&#x2F;B 位（Default Operand Size &#x2F; Big）</strong> ：决定了默认的操作数和地址的大小，以及堆栈指针的大小。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>这里需要与 <code>Type</code> 位配合才能生效。<code>Type</code> 位决定了段描述符是<strong>代码段</strong>还是<strong>数据段</strong>，另外还决定了一些特性如<strong>向下拓展</strong>是否生效。</p>

    </div>
  </div>

<ul>
<li>对于代码段：<ul>
<li><strong>0</strong> ：默认操作数和地址大小为 16 位。例如 <code>push</code> 指令只能压 2 字节。</li>
<li><strong>1</strong> ：默认操作数和地址大小为 32 位。</li>
</ul>
</li>
<li>对于堆栈段：<ul>
<li><strong>0</strong> ：使用 16 位堆栈指针。</li>
<li><strong>1</strong> ：使用 32 位堆栈指针。</li>
</ul>
</li>
<li>对于数据段：<ul>
<li><strong>0</strong> ：向下拓展。</li>
<li><strong>1</strong> ：向上拓展。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>L 位（64-bit code segment）</strong> ：仅适用于 IA-32e 模式（64 位模式）的代码段。</p>
<ul>
<li><strong>0</strong> ：表示这是一个 16 位或 32 位代码段，具体取决于 <code>D/B</code> 位。</li>
<li><strong>1</strong> ：表示这是一个 64 位代码段，忽略 <code>D/B</code> 位。</li>
</ul>
</li>
<li><p><strong>AVL 位（Available for use by system software）</strong> ：供操作系统或其他系统软件使用，用于特定用途，例如标记段的状态，未被硬件使用。</p>
</li>
</ul>
<h3 id="段权限检测"><a href="#段权限检测" class="headerlink" title="段权限检测"></a>段权限检测</h3><h4 id="权限类型"><a href="#权限类型" class="headerlink" title="权限类型"></a>权限类型</h4><p>Ring Model 是一种 <strong>CPU 权限级别（Privilege Level）</strong> 的分层架构，主要用于操作系统中处理权限隔离和保护。它通过硬件机制，限制不同权限级别的代码对系统资源的访问，从而提高系统的安全性和稳定性。</p>
<p>Ring Model 的分层通常分为 4 个等级，编号从 0 到 3：<code>Ring 0</code>，<code> Ring 1</code>， <code>Ring 2</code>， <code>Ring 3</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/image-20250602015322945.png"
                      alt="image-20250602015322945"
                ></p>
<p>CPU 的权限等级主要有段机制来维护，具体来说段机制中有下面几个权限类型：</p>
<ul>
<li><strong>CPL（Current Privilege Level）</strong> ：表示当前程序的运行权限级别，由 CS 和 SS 的 RPL（低两位）决定，并且 CS 和 SS 的低两位一定相等（因为权限变化要求 CS 和 SS 同时修改，并且 CS 和 SS 必须变成相同是值）。</li>
<li><strong>RPL（Requested Privilege Level）</strong> ：请求访问段时指定的权限级别。通常由访存时使用的段寄存器的段选择子决定。</li>
<li><strong>DPL（Descriptor Privilege Level）</strong> ：段描述符中定义的段权限级别。</li>
</ul>
<h4 id="权限规则"><a href="#权限规则" class="headerlink" title="权限规则"></a>权限规则</h4><p>这里仅考虑常见的非一致代码段。</p>
<h5 id="权限检测规则"><a href="#权限检测规则" class="headerlink" title="权限检测规则"></a>权限检测规则</h5><ul>
<li>对于数据段：仅检测 DPL 与 CPL 之间的大小关系，当且仅当 DPL 在数值上大于等于 CPL（CPL ≤ DPL）时允许。例如当 CPL &#x3D;  DPL &#x3D; 3 时，即使 RPL &#x3D; 0 也允许访问。</li>
<li>对于堆栈段和代码段：当且仅当 CPL &#x3D; RPL &#x3D; DPL 时允许访问。因为堆栈段在数据段的基础上本身 RPL 就是 CPL，因此我们只需要知道这里比数据段严格，必须要求 CPL &#x3D; DPL。</li>
<li>对于系统段：CPL &#x3D; RPL ≤ 门描述符的 DPL</li>
</ul>
<h5 id="权限修改规则"><a href="#权限修改规则" class="headerlink" title="权限修改规则"></a>权限修改规则</h5><ul>
<li><p><code>cs</code> 的权限一旦改变，<code>ss</code> 的权限也要随着改变，<code>cs</code> 与 <code>ss</code> 的等级必须一样。</p>
</li>
<li><p><code>int</code>，<code>call far</code> 这一类的指令只能通过系统段提权或者不改变权限。</p>
</li>
<li><p><code>jmp far</code> 这一类指令不改变权限，除了 TSS（可以同时影响到 <code>cs</code> 和 <code>ss</code>）。</p>
</li>
<li><p><code>retf</code>，<code>iretd</code> 这一类指令只能同级跳转或者降权。</p>
</li>
</ul>
<h3 id="调用门"><a href="#调用门" class="headerlink" title="调用门"></a>调用门</h3><p>在 x86 保护模式下，调用门（Call Gate）是一种特殊的系统段描述符，存在于 <strong>GDT（全局描述符表）</strong>或 <strong>LDT（局部描述符表）</strong> 中。它的作用是：<strong>允许安全地从一个代码段转移到另一个代码段，通常伴随特权级切换</strong>。</p>
<h4 id="门描述符"><a href="#门描述符" class="headerlink" title="门描述符"></a>门描述符</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/Call-GateDescriptor.svg"
                      alt="Figure 5-8. Call-Gate Descriptor"
                ></p>
<ul>
<li><strong>偏移地址（Offset in Segment）</strong> ：目标代码段中被调用过程的入口的<strong>逻辑地址</strong>，分为 16 位的低位偏移（<code>Offset 15:00</code>）和 16 位的高位偏移（<code>Offset 31:16</code>），需要与段选择子指向的段描述符结合才能得到入口的<strong>线性地址</strong>。</li>
<li><strong>段选择子（Segment Selector）</strong> ：调用门要跳转到的目标代码段的选择子，用于在 GDT 或 LDT 中查找目标代码段的描述符。</li>
<li><strong>参数计数（Param Count）</strong> ：堆栈切换（权限改变）时需要从旧特权级堆栈复制到新特权级堆栈的参数个数，单位为字（16 位）或双字（32 位），具体取决于调用门的类型（位数）。</li>
<li><strong>类型（Type）</strong> ：4 位，表示调用门的类型。对于 32 位调用门，值为 <code>1100</code>（0xC）；对于 16 位调用门，值为 <code>0100</code>（0x4）。</li>
<li><strong>系统段标志（S）</strong> ：1 位，固定为 0，表示调用门是系统段，而不是普通的代码段或数据段。</li>
<li><strong>描述符特权级（DPL）</strong> ：2 位，表示访问调用门时所需的最低特权级，用于特权检查。</li>
<li><strong>段存在标志（P）</strong> ：1 位，表示调用门描述符是否存在。若为 0，访问该调用门会触发 #NP（Not Present）异常。</li>
</ul>
<h4 id="过程分析"><a href="#过程分析" class="headerlink" title="过程分析"></a>过程分析</h4><h5 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h5><p>当我们通过 <code>call/jmp far</code> 或者 <code>call/jmp fword ptr</code> 指令调用调用门：</p>
<ol>
<li><p><strong>根据指令中的段选择子找到调用门。</strong>（指令中的地址没有用到，最终跳转到的地址由调用门的门描述符中的 <code>Offset</code> 字段决定）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/image-20250602051346485.png"
                      alt="image-20250602051346485"
                ></p>
</li>
<li><p><strong>进行权限检查：</strong></p>
<ul>
<li>指令中的 RPL 不参与整个过程。</li>
<li>CPL 在数值上小于等于调用门 DPL。</li>
<li>调用门中代码段选择子的 RPL 在数值上小于等于对应的代码段的的 DPL（貌似不用满足，并且跳过去之后 CPL 还是设置为代码段的 DPL）。</li>
<li>如果是 <code>jmp</code> 则调用门的段描述符对应的代码段的 DPL 等于 CPL。（<code>jmp</code> 通过调用门提不了权）</li>
<li>如果是 <code>call</code> 则调用门的段描述符对应的代码段的 DPL 在数值上小于等于 CPL。</li>
</ul>
</li>
<li><p><strong>判断调用门是否提权：</strong></p>
<ul>
<li><p>如果没有权限变化则等价于普通的跨段跳转，只不过这里跳转的地址不是直接从操作数获取的。</p>
</li>
<li><p>如果权限发生变化则需要进行栈切换：</p>
<ul>
<li><p>从 TSS 中获取新的 <code>ss</code> 和 <code>esp</code> 更新对应的寄存器，期间会检测 <code>ss</code> 的权限以及 TSS 是否合法。</p>
</li>
<li><p>将原有的 <code>ss</code>，<code>esp</code>，参数（从原本的栈中拷贝，拷贝长度参考调用门描述符中的<strong>参数计数（Param Count）</strong>字段），<code>cs</code>，返回地址依次压入<strong>新</strong>的堆栈。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>原有的堆栈中只有参数，没有压入返回地址之类的东西。
     </p>

    </div>
  </div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/image-20250602053230511.png"
                      alt="image-20250602053230511"
                ></p>
</li>
<li><p>根据门描述符中表示的代码段还有调用门入口点更新 <code>cs</code>，<code>eip</code>。</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>至此我们完成的 <code>cs</code> 和栈的切换，跳转指调用门指定的代码开始执行。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>如果我们调试提权后的代码，则返回用户态之后会发生崩溃。</p>
<p>这是因为 <code>int 3</code> 对应的中断处理函数 <code>_KiTrap03</code> 会将 <code>fs</code> 寄存器修改为 0x30（这也是为什么我们下断点调试时发现 <code>fs</code> 的值发生变化），而由于我们通过调用门提权后处于 0 环权限，<code>_KiTrap03</code> 并不会恢复 <code>fs</code> 寄存器，因此我们在返回 3 环时需要手动还原 <code>fs</code> 寄存器。</p>

    </div>
  </div>

<h5 id="返回过程"><a href="#返回过程" class="headerlink" title="返回过程"></a>返回过程</h5><p>如果我们通过 <code>call</code> 长调用指令进行调用门跳转则需要通过 <code>retf</code> 指令返回。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>如果调用门规定了参数格式，则我们必须使用 <code>retf [参数的字节总数]</code> 来返回。</p>
<p>注意，<code>retf</code> 后面跟的是参数的字节数，而调用门的<strong>参数计数（Param Count）</strong>字段描述的是参数的个数。</p>

    </div>
  </div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/image-20250603020931539.png"
                      alt="image-20250603020931539"
                ></p>
<p>具体过程为：</p>
<ol>
<li><p><strong>进行权限检查</strong> ：根据栈中存放的 <code>cs</code> 寄存器判断是否发生权限（CPL）变化：</p>
<ul>
<li><p>如果没有发生权限变化则为普通的跨段跳转，不会发生栈切换。</p>
</li>
<li><p>如果发生权限变化则：</p>
<ul>
<li>只能是降权，即在数值上栈中保存的 <code>cs</code> 的 RPL 要大于 CPL。</li>
<li>对栈中保存的 <code>ss</code> 进行权限检查，要求返回后 <code>ss</code> 和 <code>cs</code> 的 DPL 要相等。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>恢复寄存器</strong> ：</p>
<ul>
<li>根据中保存的 <code>eip</code>，<code>cs</code> 恢复 <code>eip</code> 和 <code>cs</code> 寄存器。</li>
<li>如果降权则要在普通的跨段跳转返回的基础上根据栈中保存的 <code>esp</code> 和 <code>ss</code> 恢复堆栈。栈中保存的 <code>esp</code> 和 <code>ss</code> 的位置需要根据 <code>retf</code> 后面跟的参数字节数定位。</li>
</ul>
</li>
<li><p><strong>平衡堆栈</strong> ：</p>
<ul>
<li><p>如果权限不变则根据 <code>retf</code> 后面跟的参数字节数平衡掉压入的参数，另外还要平衡掉跨段跳转时压入的返回地址和 <code>cs</code>。</p>
</li>
<li><p>如果是降权则需要在<strong>原本的堆栈</strong>中根据 <code>retf</code> 后面跟的参数字节数平衡掉压入的参数。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>内核堆栈每次都是通过 TSS 的 <code>esp</code> 赋值，因此不需要平衡内核堆栈。</p>

    </div>
  </div></li>
</ul>
</li>
</ol>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><h3 id="什么是中断"><a href="#什么是中断" class="headerlink" title="什么是中断"></a>什么是中断</h3><p>中断（<strong>Interrupt</strong>）是计算机系统中一种<strong>异步事件通知机制</strong>，用于在处理器正在执行任务时，<strong>打断当前执行流程</strong>，让处理器去响应<strong>更紧急或更重要的事件</strong>。</p>
<p>中断机制为计算机系统提供了一种对事件的实时响应方式，同时保证处理器资源的高效利用。</p>
<p>按照<strong>来源</strong>划分，中断可以分为<strong>硬件中断</strong>和<strong>软件中断</strong> ：</p>
<ul>
<li><p><strong>硬件中断</strong> ：来自外部设备（如键盘、鼠标、定时器、网卡）发出的中断信号。如：键盘按键、鼠标移动、时钟滴答。</p>
</li>
<li><p><strong>软件中断</strong> ：由程序通过指令（如 <code>int</code>）显式触发，通常用于系统调用。</p>
</li>
</ul>
<p>按<strong>目的</strong>划分，中断可以分为<strong>可屏蔽中断（IRQ）</strong>，<strong>不可屏蔽中断（NMI）</strong>和<strong>异常（Exception）</strong> ：</p>
<ul>
<li><p><strong>可屏蔽中断（IRQ）</strong> ：可以被禁止（如设置 <code>IF=0</code>，<code>EFLAGS</code> 寄存器第 10 位）。大多数硬件中断都属于这一类。</p>
</li>
<li><p><strong>不可屏蔽中断（NMI）</strong> ：非常紧急，不能被屏蔽，比如内存校验出错。</p>
</li>
<li><p><strong>异常（Exception）</strong> ：由 CPU 自身执行错误或特定条件触发，如除 0、段错误、页错误等。属于“内部中断”。</p>
</li>
</ul>
<h3 id="中断描述符表（IDT-Interrupt-Descriptor-Table）"><a href="#中断描述符表（IDT-Interrupt-Descriptor-Table）" class="headerlink" title="中断描述符表（IDT,Interrupt Descriptor Table）"></a>中断描述符表（IDT,Interrupt Descriptor Table）</h3><p>与调用门不同，中断门的门描述符位于存储在 <strong>IDT（中断描述符表）</strong> 中。这是因为中断描述符要以“中断号”为索引，用于快速响应<strong>异步事件</strong>或异常情况，强调处理器控制流程的跳转，因此需要单开一个表存储。</p>
<p> 中断向量表（IDT）最多有 <strong>256 项</strong>（编号 0–255），每一项都对应一个中断&#x2F;异常，中断号就是中断向量表的下标。其中中断号 0–31（共 32 个）被 CPU 保留，用于异常处理，<strong>操作系统不得更改其语义</strong>。</p>
<table>
<thead>
<tr>
<th>中断号</th>
<th>异常简称</th>
<th>异常名称</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>#DE</td>
<td>Divide Error（除 0 错误）</td>
<td>Fault</td>
</tr>
<tr>
<td>1</td>
<td>#DB</td>
<td>Debug（调试异常）</td>
<td>Fault&#x2F;Trap</td>
</tr>
<tr>
<td>2</td>
<td>—</td>
<td>Non-Maskable Interrupt（NMI）</td>
<td>Interrupt</td>
</tr>
<tr>
<td>3</td>
<td>#BP</td>
<td>Breakpoint（断点）</td>
<td>Trap</td>
</tr>
<tr>
<td>4</td>
<td>#OF</td>
<td>Overflow（溢出）</td>
<td>Trap</td>
</tr>
<tr>
<td>5</td>
<td>#BR</td>
<td>BOUND Range Exceeded（数组越界）</td>
<td>Fault</td>
</tr>
<tr>
<td>6</td>
<td>#UD</td>
<td>Invalid Opcode（非法&#x2F;未定义指令）</td>
<td>Fault</td>
</tr>
<tr>
<td>7</td>
<td>#NM</td>
<td>Device Not Available（协处理器不可用）</td>
<td>Fault</td>
</tr>
<tr>
<td>8</td>
<td>#DF</td>
<td>Double Fault（双重故障）</td>
<td>Abort</td>
</tr>
<tr>
<td>9</td>
<td>—</td>
<td>Coprocessor Segment Overrun（协处理器段溢出）</td>
<td>Fault（已废弃）</td>
</tr>
<tr>
<td>10</td>
<td>#TS</td>
<td>Invalid TSS（任务状态段无效）</td>
<td>Fault</td>
</tr>
<tr>
<td>11</td>
<td>#NP</td>
<td>Segment Not Present（段不存在）</td>
<td>Fault</td>
</tr>
<tr>
<td>12</td>
<td>#SS</td>
<td>Stack Segment Fault（栈段错误）</td>
<td>Fault</td>
</tr>
<tr>
<td>13</td>
<td>#GP</td>
<td>General Protection Fault（一般保护异常）</td>
<td>Fault</td>
</tr>
<tr>
<td>14</td>
<td>#PF</td>
<td>Page Fault（页错误）</td>
<td>Fault</td>
</tr>
<tr>
<td>15</td>
<td>—</td>
<td>Reserved（保留）</td>
<td>—</td>
</tr>
<tr>
<td>16</td>
<td>#MF</td>
<td>x87 Floating-Point Error（浮点错误）</td>
<td>Fault</td>
</tr>
<tr>
<td>17</td>
<td>#AC</td>
<td>Alignment Check（对齐检查）</td>
<td>Fault</td>
</tr>
<tr>
<td>18</td>
<td>#MC</td>
<td>Machine Check（机器检查）</td>
<td>Abort</td>
</tr>
<tr>
<td>19</td>
<td>#XM&#x2F;#XF</td>
<td>SIMD Floating-Point Exception</td>
<td>Fault</td>
</tr>
<tr>
<td>20–31</td>
<td>—</td>
<td>Reserved（保留）</td>
<td>—</td>
</tr>
</tbody></table>
<p>中断号 32–255：<strong>可由操作系统自由使用</strong>，每一项都是一个“中断描述符”，可为以下几种类型：</p>
<table>
<thead>
<tr>
<th>描述符类型</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>中断门（Interrupt Gate）</td>
<td>常用于处理硬件中断，自动清除 IF 位，防止嵌套</td>
</tr>
<tr>
<td>陷阱门（Trap Gate）</td>
<td>常用于异常和调试，不清除 IF</td>
</tr>
<tr>
<td>任务门（Task Gate）</td>
<td>切换到另一个任务（TSS），操作系统不使用该功能</td>
</tr>
</tbody></table>
<p>关于 IDT 有如下常用的调试命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>r idtr</code>&#x2F;<code>r idtl</code></td>
<td>查看 IDT 基地址和长度</td>
</tr>
<tr>
<td><code>!idt</code></td>
<td>查看当前处理器 IDT 内容</td>
</tr>
<tr>
<td><code>!idt &lt;n&gt;</code></td>
<td>查看中断号 <code>&lt;n&gt;</code> 的处理函数</td>
</tr>
<tr>
<td><code>~&lt;n&gt;</code></td>
<td>切换到第 n 个处理器上下文</td>
</tr>
</tbody></table>
<h3 id="中断门"><a href="#中断门" class="headerlink" title="中断门"></a>中断门</h3><p><strong>中断门（Interrupt Gate）是 x86 架构中用于处理中断（硬件&#x2F;软件中断）和异常的一种特殊机制。</strong>它是一种描述符，存储在 <strong>IDT（中断描述符表）</strong> 中，用于指向中断&#x2F;异常处理程序的入口地址和相关属性。</p>
<p>中断门的作用是：<strong>当发生中断或异常时，CPU 通过中断门自动跳转到对应的处理函数</strong>，并进行必要的权限切换、堆栈切换等。</p>
<h4 id="门描述符-1"><a href="#门描述符-1" class="headerlink" title="门描述符"></a>门描述符</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/InterruptGateDescriptior.svg"
                      alt="InterruptGateDescriptior"
                ></p>
<ul>
<li><strong>偏移地址（Offset）</strong> ：目标代码段中中断处理程序入口的<strong>逻辑地址</strong>，分为 16 位的低位偏移（<code>Offset 15:00</code>）和 16 位的高位偏移（<code>Offset 31:16</code>），需要与段选择子指向的段描述符结合才能得到入口的<strong>线性地址</strong>。</li>
<li><strong>段选择子（Segment Selector）</strong> ：中断门要跳转到的目标代码段的选择子，用于在 GDT 或 LDT 中查找中断处理程序所在的段描述符。</li>
<li><strong>类型（Type）</strong> ：4 位，表示门描述符的类型。对于 32 位中断门，值为 <code>1110</code>（0xE）；表示该门在触发时会自动清除 EFLAGS 中的 IF 位，从而禁止中断嵌套。</li>
<li><strong>系统段标志（S）</strong> ：1 位，固定为 0，表示中断门是系统段，而不是普通的代码段或数据段。</li>
<li><strong>描述符特权级（DPL）</strong> ：2 位，表示访问中断门所需的最低特权级。在中断由软件触发（如 INT 指令）时进行特权检查；若 CPL &gt; DPL，则会触发 #GP 异常。</li>
<li><strong>段存在标志（P）</strong> ：1 位，表示中断门描述符是否存在。若为 0，访问该中断门会触发 #NP（Not Present）异常。</li>
</ul>
<h4 id="过程分析-1"><a href="#过程分析-1" class="headerlink" title="过程分析"></a>过程分析</h4><h5 id="调用过程-1"><a href="#调用过程-1" class="headerlink" title="调用过程"></a>调用过程</h5><p>当我们通过 <code>int n</code> 或指令触发中断：</p>
<ol>
<li><p><strong>根据中断向量在 IDT 中查找中断门描述符。</strong>（指令中的操作数 <code>n</code> 作为索引，找到对应的门描述符；跳转地址由中断门中的 <code>Offset</code> 和 <code>Segment Selector</code> 字段决定）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/image-20250603235057313.png"
                      alt="image-20250603235057313"
                ></p>
</li>
<li><p><strong>进行权限检查：</strong></p>
<ul>
<li>对于<strong>硬件中断</strong> ：<strong>不进行权限检查</strong>，中断处理程序直接执行。</li>
<li>对于<strong>软件中断（如 INT n）</strong> ：<ul>
<li>CPL（当前特权级）必须<strong>小于等于</strong>中断门的 DPL。</li>
<li>如果 CPL &gt; DPL，则触发 #GP 异常。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>判断是否发生权限变化（提权）</strong> ：</p>
<ul>
<li><p>如果中断门的目标代码段的 DPL &lt; CPL，则发生提权，需要进行<strong>堆栈切换</strong>。</p>
<ul>
<li>从 TSS 中查找对应的 <code>SS</code> 和 <code>ESP</code>，加载为新堆栈。</li>
<li>将当前栈的 <code>SS</code>、<code>ESP</code>、<code>EFLAGS</code>、<code>CS</code> 和 <code>EIP</code> 依次压入新堆栈中，形成完整的返回上下文。</li>
<li>若中断号是 <code>INT n</code> 且带有错误码，则错误码也一并压入堆栈（CPU 固定的几项，我们自己注册的没有）。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/image-20250603235355733.png"
                      alt="image-20250603235355733"
                ></p>
</li>
<li><p>如果没有权限变化（例如从 Ring 0 调用 Ring 0 中断门）则不会切换堆栈，仅将 <code>EFLAGS</code>、<code>CS</code>、<code>EIP</code> 压入当前堆栈。</p>
</li>
</ul>
</li>
<li><p><strong>修改 <code>EFLAGS</code> 寄存器</strong> ：中断门会清空 <code>EFLAGS</code> 寄存器中的下面几个标志位：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/image-20250604005350818.png"
                      alt="image-20250604005350818"
                ></p>
</li>
</ol>
<table>
<thead>
<tr>
<th>位名</th>
<th>含义</th>
<th>EFLAGS 位位置</th>
<th>修改行为 &#x2F; 说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>IF</strong> (Interrupt Flag)</td>
<td>中断允许标志：控制是否允许 CPU 响应<strong>可屏蔽中断（IRQ）</strong></td>
<td>位 9</td>
<td>当通过<strong>中断门进入中断处理程序时</strong>，CPU 会自动将 <code>IF = 0</code>，即<strong>暂时屏蔽其他中断</strong>，防止当前中断被新的中断打断。等中断处理结束后通过 <code>IRET</code> 恢复原 <code>EFLAGS</code>，<code>IF</code> 才可能再次为 1。这个行为只发生在中断门，<strong>陷阱门不会清除 IF</strong>，允许中断嵌套。</td>
</tr>
<tr>
<td><strong>TF</strong> (Trap Flag)</td>
<td>单步调试标志：控制是否在每条指令后触发调试异常（#DB）</td>
<td>位 8</td>
<td>进入中断处理程序前，CPU 会自动将 <code>TF</code> 清 0，<strong>禁止单步调试在中断处理流程中生效</strong>，避免调试器每条指令都触发中断，造成混乱甚至不可预期行为。恢复时，<code>IRET</code> 会将 <code>TF</code> 恢复为中断前的状态。</td>
</tr>
<tr>
<td><strong>NT</strong> (Nested Task)</td>
<td>嵌套任务标志：用于任务切换机制（与 TSS 和任务门相关）</td>
<td>位 14</td>
<td><code>NT = 1</code> 表示当前是嵌套任务。中断门触发时，<strong>即便不是 Task Gate 形式，也会清除 <code>NT</code> 位为 0</strong>，防止任务嵌套链在中断中干扰任务切换控制流。(如果是嵌套任务则 <code>iretd</code> 指令会根据任务段返回)</td>
</tr>
<tr>
<td><strong>VM</strong> (Virtual 8086 Mode)</td>
<td>虚拟 8086 模式标志：控制是否在 V8086 模拟环境中运行 16 位实模式代码</td>
<td>位 17</td>
<td>如果 CPU 当前处于 <code>VM = 1</code>（虚拟 8086 模式），当通过中断门执行 <code>INT n</code> 指令时，CPU 会自动清除 <code>VM</code>，<strong>退出 V86 模式，进入保护模式（Ring 0）</strong>，以便执行保护模式下的中断处理程序。这个过程伴随着堆栈切换、权限检查和返回机制，支持从实模式模拟环境跳转到内核态中断处理逻辑。</td>
</tr>
</tbody></table>
<ol start="5">
<li><p><strong>跳转到中断处理程序：</strong></p>
<ul>
<li>设置新的 <code>CS:EIP</code> 为门描述符中指定的目标。</li>
<li>开始执行中断处理程序。</li>
</ul>
</li>
</ol>
<h5 id="返回过程-1"><a href="#返回过程-1" class="headerlink" title="返回过程"></a>返回过程</h5><p>在中断处理程序结束时通过 <code>iret</code>（ 32 位 <code>iretd</code>，64 位 <code>iretq</code>）指令返回，具体过程为：</p>
<ol>
<li><strong>进行权限检查：</strong><ul>
<li>从栈中弹出 <code>EIP</code>、<code>CS</code> 和 <code>EFLAGS</code>。</li>
<li>如果发生过权限变化（即从高权限跳转到低权限）：<ul>
<li>同时还需要从栈中恢复 <code>SS</code> 和 <code>ESP</code>。</li>
<li>返回后会将 CPL 设置为 <code>CS</code> 描述符中的 DPL。</li>
</ul>
</li>
</ul>
</li>
<li><strong>恢复上下文：</strong><ul>
<li>设置 <code>CS:EIP</code> 为返回地址。</li>
<li>恢复原 <code>EFLAGS</code>。</li>
<li>如果发生过堆栈切换，则也恢复 <code>SS</code> 和 <code>ESP</code>，切回用户堆栈。</li>
</ul>
</li>
<li><strong>完成权限恢复与返回：</strong><ul>
<li>中断处理完毕，程序继续从中断发生处继续执行。</li>
</ul>
</li>
</ol>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <ul>
<li>若中断期间修改了段寄存器（如 <code>fs</code>），在返回到用户态前应手动还原。</li>
<li><code>iretd</code> 不能被 <code>retf 4</code> 代替，因为发送权限变化的时候 <code>retf 4</code> 还会平衡掉用户态栈中压入的参数，而 <code>int</code> 指令只在内核态栈中压入 <code>EFLAGS</code>，因此会导致堆栈不平衡。</li>
</ul>

    </div>
  </div>

<h3 id="陷阱门"><a href="#陷阱门" class="headerlink" title="陷阱门"></a>陷阱门</h3><p>陷阱门是一种<strong>门描述符</strong>，用于定义某个中断或异常发生时，处理器该跳转到哪段代码继续执行。它和中断门类似，都存在于 <strong>IDT（Interrupt Descriptor Table）</strong> 中，但行为略有不同，<strong>主要用于不会频繁嵌套、需要精细控制响应时机的异常或调试场景</strong>。</p>
<h4 id="门描述符-2"><a href="#门描述符-2" class="headerlink" title="门描述符"></a>门描述符</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/TrapGateDescriptior.svg"
                      alt="TrapGateDescriptior"
                ></p>
<p>陷阱门描述符与中断门描述符格式基本一致，唯一区别就是 <code>Type</code> 字段不同，由 <code>1110</code>（0xE）变为了 <code>1111</code>（0xF）。</p>
<h4 id="过程分析-2"><a href="#过程分析-2" class="headerlink" title="过程分析"></a>过程分析</h4><p>与中断门完全一致，唯一的不同点在于陷阱门不会清空 <code>EFLAGS</code> 的 <code>IF</code> 标志位。</p>
<h3 id="任务门"><a href="#任务门" class="headerlink" title="任务门"></a>任务门</h3><p><strong>任务门（Task Gate）</strong>是一种特殊的<strong>系统段描述符</strong>，用于在 <strong>x86 保护模式</strong>下实现<strong>任务切换（Task Switch）</strong>，其本质作用是<strong>指向一个任务（TSS），以便通过它进行硬件级别的任务切换</strong>。</p>
<p>然而<strong>现代操作系统几乎完全不用任务门（Task Gate）和硬件任务切换机制</strong>，无论是 Windows、Linux、macOS 还是虚拟化内核，<strong>都采用软件实现的任务调度和上下文切换机制</strong>。这是因为：</p>
<ul>
<li><strong>控制粒度太粗、太死板。</strong><ul>
<li>一旦使用任务门 → 切换的是整个 TSS + CR3 + 所有段寄存器 + GPR + EFLAGS + EIP。OS 不能只保存&#x2F;恢复一部分，比如只切换线程状态，不切换地址空间。而软件调度可以精细控制切换内容（比如 lazy FPU context switching、延迟页表切换等）。</li>
<li><strong>性能开销大。</strong>使用任务门意味着 CPU 要自动执行一整套验证、保存、加载流程，而软件调度只需要保存需要的部分上下文，用 <code>mov</code>, <code>push</code>, <code>pop</code> 就行，效率更高。</li>
<li><strong>异常可恢复性差。</strong>硬件任务切换由 CPU 自动执行的一整套流程，如果在任务切换“中间过程”如果出错，则当前处于模糊状态，OS 没办法清楚知道到底处在哪个任务上下文。最终会导致：<strong>陷入不可恢复状态 → Triple Fault（第三次错误） → CPU 复位重启</strong>，分析调试困难。</li>
</ul>
</li>
<li><strong>不利高并发场景。</strong>TSS 原生只支持一个任务状态。TSS 的 busy 位、防嵌套规则等，使得任务链和多线程管理变得复杂且危险，经常可能因为并发问题触发异常导致系统崩溃。Linux、Windows 等直接为每个 CPU 定义自己的调度器和线程控制块（TCB），避免使用硬件机制。</li>
<li><strong>兼容性差。</strong>硬件任务切换机制使得 OS 必须与 x86 的 GDT、IDT、TSS、任务门、段保护等高度绑定，导致 OS 无法跨架构通用，也难以模块化维护。</li>
</ul>
<p>因此现代操作系统中任务门的主要作用为：</p>
<ul>
<li><p><strong>TSS 的 ESP0 用于内核栈切换</strong> ：现代操作系统都需要为每个 CPU 设置一个 TSS，仅为了提供 Ring 3 → Ring 0 的栈切换支持。在中断门或系统调用触发从用户态切换到内核态时，CPU 自动从当前 CPU 的 TSS 中加载 <code>SS0</code> &#x2F; <code>ESP0</code> 作为临时新栈顶。</p>
</li>
<li><p><strong>双重错误（#DF）异常处理</strong> ：Intel 推荐用 <strong>任务门</strong> 描述符来设置 IDT 中的第 8 号向量（#DF），这样就可以防止中断嵌套导致的<strong>堆栈损坏</strong>引发 Triple Fault。我们在调试这类异常的时候可以根据这一性质找到出现异常的堆栈。</p>
<blockquote>
<p><em>“Some exception handlers, such as the double-fault exception handler, are typically set up with a task gate in the IDT. This enables the processor to switch to a known-good TSS and clean stack.”</em><br> — SDM Vol. 3, Section 6.15 “Exception and Interrupt Handling”</p>
</blockquote>
</li>
</ul>
<h4 id="任务段描述符（TSS-Descriptor）"><a href="#任务段描述符（TSS-Descriptor）" class="headerlink" title="任务段描述符（TSS Descriptor）"></a>任务段描述符（TSS Descriptor）</h4><p>任务段（TSS）描述符的定义如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/TSSDescriptior.svg"
                      alt="TSSDescriptior"
                ></p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>根据《Intel SDM（System Developer’s Manual）》中的明确规定：</p>
<blockquote>
<p><strong>“TSS descriptors may only be placed in the GDT; they cannot be placed in an LDT or the IDT.”</strong></p>
</blockquote>
<p><strong>任务段（TSS）描述符</strong>只能出现在 <strong>GDT（全局描述符表）</strong> 中，不能放在 LDT（局部描述符表）里。</p>

    </div>
  </div>

<ul>
<li><p><strong>段基址（Base Address）</strong> ：任务段（TSS）在内存中的线性地址，由三部分组成：<code>Base 15:00</code>、<code>Base 23:16</code> 和 <code>Base 31:24</code>，共同构成 32 位的段基址，用于定位 TSS 数据结构的起始地址。</p>
</li>
<li><p><strong>段限长（Segment Limit）</strong> ：指定任务段的长度，通常为 <code>0x67</code>（即 104 字节），分为低 16 位（<code>Limit 15:00</code>）和高 4 位（<code>Limit 19:16</code>）。如果 <code>G</code> 位为 0，则按字节为单位解释该限长。</p>
</li>
<li><p><strong>类型（Type）</strong> ：4 位，表示描述符的具体类型。对于 32 位可用任务段：</p>
<ul>
<li>类型值为 <code>1001</code>（0x9）说明该TSS段描述符未被加载到TR段寄存器中。</li>
<li>类型值为 <code>1011</code>（0xB）说明该TSS段描述符已被加载到TR段寄存器中。</li>
</ul>
</li>
<li><p><strong>系统段标志（S）</strong> ：1 位，必须固定为 0，表示该描述符是一个系统段，而非普通的代码段或数据段。TSS、LDT、门描述符等都属于系统段。</p>
</li>
<li><p><strong>描述符特权级（DPL）</strong> ：2 位，表示对该任务段的访问权限要求。在通过任务门或软件指令（如 <code>CALL</code>, <code>JMP</code>）触发任务切换时，当前特权级（CPL）必须 ≤ DPL，否则会触发 #GP（General Protection）异常。</p>
</li>
<li><p><strong>段存在标志（P）</strong> ：1 位，表示该任务段是否有效。若为 0，则尝试访问此任务段会触发 #NP（Not Present）异常；为 1 时表示段存在且可以使用。</p>
</li>
<li><p><strong>可用位（AVL）</strong> ：1 位，由操作系统自由使用，处理器不进行解释。常用于系统内部标记用途，例如多处理器状态跟踪或调试标志。</p>
</li>
<li><p><strong>默认操作数大小（D&#x2F;B）</strong> ：1 位，对于任务段必须设置为 0，否则行为未定义。该位在代码段中表示默认指令大小（16&#x2F;32 位），但在 TSS 描述符中无实际意义。</p>
</li>
<li><p><strong>粒度（G）</strong> ：1 位，控制段限长的单位。当为 0 时，段限长以字节为单位解释（TSS 推荐）；若为 1，则以 4KB 页为单位（不建议用于 TSS）。</p>
</li>
</ul>
<h4 id="任务寄存器（TR，Task-Register）"><a href="#任务寄存器（TR，Task-Register）" class="headerlink" title="任务寄存器（TR，Task Register）"></a>任务寄存器（TR，Task Register）</h4><p><strong>TR（Task Register，任务寄存器）</strong>是 x86 处理器中的一个系统段寄存器，用于引用当前正在使用的任务状态段（TSS）。</p>
<p>TR 寄存器会保存当前活动 TSS 的 <strong>段选择子</strong>（32 位下默认是 28），并缓存当前 TSS 的 <strong>基地址</strong> 和 <strong>限长</strong>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/image-20250604014705925.png"
                      alt="image-20250604014705925"
                ></p>
<p><code>TR</code> 寄存器可以通过 <code>LTR</code> 和 <code>STR</code> 指令进行读写，不过这两个指令都是 <strong>特权指令</strong>，<strong>只能在特权级 0（CPL &#x3D; 0）下执行</strong>。</p>
<ul>
<li><code>STR r16/m16</code>：从 <code>TR</code> 读取当前任务段选择子。</li>
<li><code>LTR r/m16</code>：向 <code>TR</code> 加载任务段选择子。</li>
</ul>
<h4 id="任务段（TSS，Task-State-Segment）"><a href="#任务段（TSS，Task-State-Segment）" class="headerlink" title="任务段（TSS，Task State Segment）"></a>任务段（TSS，Task State Segment）</h4><p><strong>任务段（TSS，Task State Segment）</strong>是 x86 架构中为支持<strong>多任务操作系统</strong>设计的一个特殊机制，它定义了一段特殊的内存结构，用于<strong>保存任务（线程&#x2F;进程）的运行上下文和特权级切换信息</strong>。</p>
<p>虽然现代操作系统（如 Windows 和 Linux）<strong>不再使用“硬件任务切换”</strong>（TSS 最初的主要目的），但 TSS 在 <strong>中断处理、安全控制、特权切换时仍然是必不可少的组件</strong>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/image-20250604014908047.png"
                      alt="image-20250604014908047"
                ></p>
<ul>
<li><p><strong>Previous Task Link</strong> ：上一个任务字段。如果使用任务切换（如使用<code>jmp TSS selector</code>），这里保存前一个任务的 TSS 选择子。由于 Windows 基本不使用硬件任务切换（而是用软件方式），因此此字段一般无实际用途。</p>
</li>
<li><p><strong>栈切换相关字段</strong> ：</p>
<ul>
<li><strong>ESP0 &#x2F; SS0</strong> ： Windows 在处理系统调用（如<code>sysenter</code>或<code>int 0x2e</code>）和异常（如页错误）时依赖这两个字段快速切换内核栈。当 CPU 从用户态（CPL&#x3D;3）切换到内核态（CPL&#x3D;0）时，会自动加载这两个字段的值作为内核栈的临时基地址（<code>SS:ESP</code>）。</li>
<li><strong>ESP1 &#x2F; SS1，ESP2 &#x2F; SS2</strong> ：较少用，仅在三层栈（Ring1、Ring2）情况下切换，<strong>Windows 不使用</strong>，这些字段保留。</li>
</ul>
</li>
<li><p><strong>CR3（PDBR）</strong> ：存储页目录基地址寄存器（CR3），用于指向进程的页表。如果用任务切换机制，CPU 会自动加载 CR3 切换页表。</p>
</li>
<li><p><strong>通用寄存器和段寄存器</strong> ：这些是当通过任务切换机制（<code>CALL/JMP TSS</code>）切换任务时自动保存的内容。</p>
<ul>
<li><strong>通用寄存器</strong> ：EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP</li>
<li><strong>段寄存器</strong> ：ES, CS, SS, DS, FS, GS</li>
<li><strong>其他</strong> ：EIP、EFLAGS</li>
</ul>
</li>
<li><p><strong>LDT Segment Selector</strong> ：指定当前任务使用的 LDT（Local Descriptor Table）。</p>
</li>
<li><p><strong>T（Trap）位</strong> ：如果置 1，则在任务切换到此 TSS 时触发调试异常（#DB）</p>
</li>
<li><p><strong>I&#x2F;O Map Base Address</strong> ：指定 TSS 后面的 I&#x2F;O 权限位图偏移，用于控制任务是否可以访问某些 I&#x2F;O 端口，某些驱动或 VM 技术中使用。</p>
</li>
<li><p><strong>SSP（Shadow Stack Pointer）</strong> ：当启用 Intel CET（Control-flow Enforcement Technology）时，记录 Shadow Stack 的指针。<strong>Windows 10+ 在启用 CET 保护（比如 MS Edge 浏览器）时会使用它。</strong></p>
<blockquote>
<p>Intel CET（Control-flow Enforcement Technology，<strong>控制流强制技术</strong>）是 Intel 推出的一个 <strong>硬件级安全特性</strong>。CET 有两个核心组件：</p>
<ul>
<li><strong>Shadow Stack（影子栈）</strong> ：CPU 维护一个只写入返回地址的“只读”影子栈。每次函数调用（<code>CALL</code>）时，返回地址会同时写入正常栈和影子栈。当执行 <code>RET</code> 时，CPU 会比对影子栈的返回地址，不一致则触发异常。</li>
<li><strong>Indirect Branch Tracking（IBT）</strong> ： 限制间接跳转（<code>JMP</code>、<code>CALL</code> 到寄存器&#x2F;内存）只能跳转到<strong>有效的目标地址</strong>。要跳转的目标必须以特殊指令（如 <code>ENDBR32</code> 或 <code>ENDBR64</code>）开头，否则触发异常。</li>
</ul>
</blockquote>
</li>
</ul>
<p><code>ntkrpamp!_KTSS</code> 是 Windows 内核中用于描述任务状态段（TSS，Task State Segment）的结构体，主要用于 x86 架构下的特权级堆栈切换、I&#x2F;O 端口访问控制等功能。</p>
<p>虽然现代 Windows 系统主要采用软件方式进行任务切换，但仍为每个处理器维护一个 TSS 结构，特别是在处理特定异常（如双重故障）时，硬件任务切换机制仍可能被触发。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x20ac bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">KTSS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    USHORT Backlink;                                                        <span class="comment">//0x0</span></span><br><span class="line">    USHORT Reserved0;                                                       <span class="comment">//0x2</span></span><br><span class="line">    ULONG Esp0;                                                             <span class="comment">//0x4</span></span><br><span class="line">    USHORT Ss0;                                                             <span class="comment">//0x8</span></span><br><span class="line">    USHORT Reserved1;                                                       <span class="comment">//0xa</span></span><br><span class="line">    ULONG NotUsed1[<span class="number">4</span>];                                                      <span class="comment">//0xc</span></span><br><span class="line">    ULONG CR3;                                                              <span class="comment">//0x1c</span></span><br><span class="line">    ULONG Eip;                                                              <span class="comment">//0x20</span></span><br><span class="line">    ULONG EFlags;                                                           <span class="comment">//0x24</span></span><br><span class="line">    ULONG Eax;                                                              <span class="comment">//0x28</span></span><br><span class="line">    ULONG Ecx;                                                              <span class="comment">//0x2c</span></span><br><span class="line">    ULONG Edx;                                                              <span class="comment">//0x30</span></span><br><span class="line">    ULONG Ebx;                                                              <span class="comment">//0x34</span></span><br><span class="line">    ULONG Esp;                                                              <span class="comment">//0x38</span></span><br><span class="line">    ULONG Ebp;                                                              <span class="comment">//0x3c</span></span><br><span class="line">    ULONG Esi;                                                              <span class="comment">//0x40</span></span><br><span class="line">    ULONG Edi;                                                              <span class="comment">//0x44</span></span><br><span class="line">    USHORT Es;                                                              <span class="comment">//0x48</span></span><br><span class="line">    USHORT Reserved2;                                                       <span class="comment">//0x4a</span></span><br><span class="line">    USHORT Cs;                                                              <span class="comment">//0x4c</span></span><br><span class="line">    USHORT Reserved3;                                                       <span class="comment">//0x4e</span></span><br><span class="line">    USHORT Ss;                                                              <span class="comment">//0x50</span></span><br><span class="line">    USHORT Reserved4;                                                       <span class="comment">//0x52</span></span><br><span class="line">    USHORT Ds;                                                              <span class="comment">//0x54</span></span><br><span class="line">    USHORT Reserved5;                                                       <span class="comment">//0x56</span></span><br><span class="line">    USHORT Fs;                                                              <span class="comment">//0x58</span></span><br><span class="line">    USHORT Reserved6;                                                       <span class="comment">//0x5a</span></span><br><span class="line">    USHORT Gs;                                                              <span class="comment">//0x5c</span></span><br><span class="line">    USHORT Reserved7;                                                       <span class="comment">//0x5e</span></span><br><span class="line">    USHORT LDT;                                                             <span class="comment">//0x60</span></span><br><span class="line">    USHORT Reserved8;                                                       <span class="comment">//0x62</span></span><br><span class="line">    USHORT Flags;                                                           <span class="comment">//0x64</span></span><br><span class="line">    USHORT IoMapBase;                                                       <span class="comment">//0x66</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KiIoAccessMap</span> <span class="title">IoMaps</span>[1];</span>                                        <span class="comment">//0x68</span></span><br><span class="line">    UCHAR IntDirectionMap[<span class="number">32</span>];                                              <span class="comment">//0x208c</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>Windows 默认不使用 <code>ESP1</code> &#x2F; <code>SS1</code> 和 <code>ESP2</code> &#x2F; <code>SS2</code> 等<strong>特权级备用栈（Ring 1 和 Ring 2 的栈）</strong>，所以在它所定义的 <code>_KTSS</code> 结构体中，这些字段会被统一省略或标为保留（<code>Reserved1</code>，<code>NotUsed1</code>）。</p>

    </div>
  </div>

<h4 id="任务门描述符（Task-Gate-Descriptor）"><a href="#任务门描述符（Task-Gate-Descriptor）" class="headerlink" title="任务门描述符（Task Gate Descriptor）"></a>任务门描述符（Task Gate Descriptor）</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/TaskGateDescriptior.svg"
                      alt="TaskGateDescriptior"
                ></p>
<ul>
<li><p><strong>段选择子（TSS Segment Selector）</strong> ：表示该任务门对应的目标任务段（TSS）。该字段占据描述符的第 0–15 位，其值应为 GDT 中某个 <strong>TSS 段描述符的选择子</strong>。当任务门被触发时，处理器会使用该选择子来访问并加载目标 TSS，实现硬件任务切换。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/image-20250604014810467.png"
                      alt="image-20250604014810467"
                ></p>
</li>
<li><p><strong>类型（Type）</strong> ：4 位，位于描述符的第 40–43 位，用于标识该描述符的具体类型。对于任务门而言，该字段的值为 <code>0101</code>（即 0x5），表示“32 位任务门（Task Gate）”。该类型值要求处理器在使用该描述符时执行<strong>硬件任务切换流程</strong>。</p>
</li>
<li><p><strong>系统段标志（S）</strong> ：1 位，位于第 44 位，必须固定为 0，表示该描述符是一个 <strong>系统段</strong>，而非普通的数据段或代码段。所有任务门、中断门、陷阱门、TSS 和 LDT 描述符都属于系统段。</p>
</li>
<li><p><strong>描述符特权级（DPL）</strong> ：2 位，位于第 45–46 位，表示访问该任务门所需的最小权限级别。在尝试通过 <code>CALL</code>, <code>JMP</code>, 或 <code>INT</code> 指令使用该任务门时，如果当前特权级（CPL）高于该值，将会触发 <code>#GP</code>（General Protection）异常。该字段用于控制访问粒度，例如可限制用户态程序不可使用该门。</p>
</li>
<li><p><strong>段存在标志（P）</strong> ：1 位，位于第 47 位，用于表示该任务门描述符是否有效。当该位为 0 时，尝试访问该任务门会导致处理器抛出 <code>#NP</code>（Segment Not Present）异常。为 1 时表示描述符存在且可使用。</p>
</li>
</ul>
<h4 id="调用过程（任务切换机制）"><a href="#调用过程（任务切换机制）" class="headerlink" title="调用过程（任务切换机制）"></a>调用过程（任务切换机制）</h4><p>“任务门调用”是间接的任务切换方式，通过门找到 TSS；“任务段描述符调用”是直接调用 TSS 来切换任务。它们最终都会导致 TSS 被加载和任务切换，但路径和机制不同。</p>
<table>
<thead>
<tr>
<th>比较点</th>
<th>任务段描述符调用</th>
<th>任务门调用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>调用方式</strong></td>
<td><code>CALL TSS_selector</code> 或 <code>JMP TSS_selector</code>（选择子直接指向 TSS 描述符）</td>
<td><code>CALL</code>, <code>JMP</code>, 或 <code>INT</code> 到一个任务门（描述符中包含 TSS 选择子）</td>
</tr>
<tr>
<td><strong>位置</strong></td>
<td>TSS 必须在 <strong>GDT 中</strong></td>
<td>任务门可以在 <strong>GDT、LDT、IDT</strong></td>
</tr>
<tr>
<td><strong>是否间接</strong></td>
<td>❌ 否，直接引用 TSS</td>
<td>✅ 是，门中保存 TSS 的选择子</td>
</tr>
<tr>
<td><strong>可用于中断</strong></td>
<td>❌ 否，不能嵌入到 IDT</td>
<td>✅ 是，任务门可以作为中断门放入 IDT（任务型中断）</td>
</tr>
<tr>
<td><strong>权限检查点</strong></td>
<td>直接检查 TSS 描述符的 DPL</td>
<td>先检查门的 DPL，再检查 TSS 描述符的 DPL</td>
</tr>
<tr>
<td><strong>用途</strong></td>
<td>通常用于显式调度（早期OS设计）</td>
<td>可用于中断&#x2F;异常自动触发任务切换（支持隔离的 handler）</td>
</tr>
<tr>
<td><strong>效率与灵活性</strong></td>
<td>较低</td>
<td>稍好，但仍落后于软件上下文切换</td>
</tr>
<tr>
<td><strong>现代操作系统使用情况</strong></td>
<td>❌ 弃用</td>
<td>❌ 弃用（包括 Windows&#x2F;Linux）</td>
</tr>
</tbody></table>
<h5 id="任务段描述符调用过程"><a href="#任务段描述符调用过程" class="headerlink" title="任务段描述符调用过程"></a>任务段描述符调用过程</h5><p>使用 <code>CALL TSS_selector</code> 或 <code>JMP TSS_selector</code> 指令，其中选择子（Selector）指向 <strong>GDT 中的任务段描述符（TSS Descriptor）</strong>。</p>
<ol>
<li><p><strong>权限检查</strong> ：<code>max(CPL,RPL) ≤ DPL</code>，否则 <code>#GP(selector)</code></p>
</li>
<li><p><strong>存在检查</strong> ：P&#x3D;0 → <code>#NP(selector)</code></p>
</li>
<li><p><strong>类型检查</strong> ：Busy TSS 调用 → <code>#GP(selector)</code></p>
</li>
<li><p><strong>段限长检查</strong> ：limit &lt; 0x67 → <code>#GP(selector)</code></p>
</li>
<li><p><strong>加载新任务</strong></p>
<ul>
<li><p>将当前任务的上下文（寄存器、EIP、EFLAGS、段寄存器等）保存到当前 TSS；</p>
</li>
<li><p>设置 TR（Task Register）指向新的 TSS；</p>
</li>
<li><p><strong>目标 TSS 类型字段自动由 0x9 → 0xB</strong>，表示忙状态。</p>
</li>
<li><p><strong>载入新任务状态</strong> ：CR3、LDTR、EFLAGS、EIP、通用&#x2F;段寄存器</p>
</li>
<li><p>对 <code>CALL</code>：设置 <code>EFLAGS.NT=1</code> 并把当前 TSS 段选择子写到新 <code>TSS.Backlink</code>；<strong>对 <code>JMP</code> 不设置。</strong>因此如果想用 <code>JMP</code> 进行任务切换直接 <code>iretd</code> 返回会蓝屏。 </p>
<blockquote>
<p>When a <strong>CALL instruction</strong>, an interrupt, or an exception causes a task switch:<br> the processor copies the segment selector for the current TSS to the <strong>previous task link field (Backlink)</strong> of the TSS for the new task;<br> it then sets <strong>EFLAGS.NT &#x3D; 1</strong>.</p>
<p>当一个 <strong>CALL 指令、中断或异常</strong> 触发任务切换时：<br> 处理器将当前 TSS 的段选择子写入新任务的 TSS 的 <strong>Backlink 字段</strong>，并设置 <strong>EFLAGS.NT &#x3D; 1</strong>。</p>
<p>When a <strong>JMP instruction</strong> causes a task switch, the new task is <strong>not nested</strong>.<br> The previous task link field is <strong>not used</strong> and <strong>EFLAGS.NT &#x3D; 0</strong>.</p>
<p>当一个 <strong>JMP 指令</strong> 引发任务切换时，新任务<strong>不被视为嵌套任务</strong>，不会使用 backlink，<strong>EFLAGS.NT &#x3D; 0</strong>。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h5 id="任务门调用过程"><a href="#任务门调用过程" class="headerlink" title="任务门调用过程"></a>任务门调用过程</h5><ol>
<li><p><strong>权限检查</strong> 对任务门（同样比较 CPL&#x2F;RPL 与 DPL）</p>
</li>
<li><p><strong>取出任务门中的 TSS Selector</strong></p>
</li>
<li><p>后续步骤与直接调用任务段相同。</p>
</li>
</ol>
<h5 id="返回过程-2"><a href="#返回过程-2" class="headerlink" title="返回过程"></a>返回过程</h5><ol>
<li><p>当执行 <code>iretd</code> 指令的时候，CPU 发现 <code>EFLAGS.NT=1</code>，识别为<strong>任务返回</strong>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/image-20250606011634326.png"
                      alt="image-20250606011634326"
                ></p>
<ul>
<li><p>任务状态段（TSS）中的“<strong>前一个任务链接字段</strong>”（Previous Task Link，有时也称为“backlink”）以及 <strong>EFLAGS 寄存器中的 NT 标志</strong>，用于将控制流<strong>返回到前一个任务</strong>。</p>
</li>
<li><p>当 <code>EFLAGS.NT = 1</code> 时，表示当前正在执行的任务是<strong>嵌套在另一个任务之内</strong>。</p>
</li>
</ul>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>如果我们调试任务切换的代码，由于 <code>int 3</code> 中断会将 <code>EFLAGS.NT</code> 为置 0，导致返回的时候是通过堆栈返回，造成蓝屏。</p>

    </div>
  </div>
</li>
<li><p>读取当前 TSS 的 <strong>Backlink</strong> → 找到前一个 TSS 描述符。</p>
</li>
<li><p>对当前任务段执行与调用流程相同的有效性检查（<code>P=1</code>, <code>limit≥0x67</code>, <code>Type=Busy</code>）</p>
</li>
<li><p>保存当前任务状态到当前 TSS，因为 IRET 任务返回也属于任务切换。</p>
</li>
<li><p>清除当前 TSS Busy 位。</p>
</li>
<li><p>加载前一任务 TSS 内容 → 寄存器、EIP、EFLAGS。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>如果 <strong>分页未启用</strong>（即 <code>CR0.PG = 0</code>），那么虽然 TSS 中的 CR3 字段仍会被读出来，<strong>但不会写入 CR3 寄存器</strong>。在 Intel 开发文档原文如下：</p>
<blockquote>
<p>If paging is not enabled, a PDBR value is read from the new task’s TSS, but it is not loaded into CR3.</p>
</blockquote>

    </div>
  </div>
</li>
<li><p>写 TR &#x3D; 前一 TSS selector，恢复其 Busy 状态。</p>
</li>
<li><p>清除 <code>EFLAGS.NT</code></p>
</li>
<li><p>跳回前一任务继续执行</p>
</li>
</ol>
<h2 id="页式内存管理"><a href="#页式内存管理" class="headerlink" title="页式内存管理"></a>页式内存管理</h2><p>Intel CPU 支持下面几种分页模式：</p>
<table>
<thead>
<tr>
<th>分页模式</th>
<th>地址宽度</th>
<th>页目录结构</th>
<th>页大小</th>
<th>是否支持 NX（DEP）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>非 PAE 分页</strong></td>
<td>32-bit</td>
<td>2 级（10+10+12）<br />CR3 → PDE → PTE</td>
<td>4 KB</td>
<td>❌ 否</td>
</tr>
<tr>
<td><strong>PAE 分页</strong></td>
<td>36-bit（最多64GB）</td>
<td>3 级（2+9+9+12）<br />CR3 → PDPT → PDE → PTE</td>
<td>4 KB, 2 MB</td>
<td>✅ 是</td>
</tr>
<tr>
<td><strong>x64 长模式分页</strong></td>
<td>48-bit（理论）</td>
<td>4 级（9+9+9+9+12）<br />CR3 → PML4 → PDPT → PDE → PTE</td>
<td>4 KB, 2 MB, 1 GB</td>
<td>✅ 是</td>
</tr>
</tbody></table>
<p>页式内存管理由 CPU 和操作系统共同维护：</p>
<ul>
<li><strong>CPU</strong> 主要负责<strong>地址转换过程</strong>。CPU 在执行指令时，如果涉及内存访问（如 <code>mov eax, [esp+0x10]</code>），就会自动触发地址翻译流程（虚拟 → 线性 → 物理）。</li>
<li><strong>操作系统</strong>主要负责<strong>页表结构维护</strong>。操作系统负责在内存中创建、更新和删除页表各层的表项，以决定每个虚拟地址该映射到哪个物理地址。</li>
</ul>
<p>有时候 CPU 还要与操作系统紧密配合，比如如果 CPU 发现访问的地址页表中标记为不存在（P&#x3D;0），则触发 #PF 缺页异常，此时需要由操作系统进行缺页处理或报错终止程序。</p>
<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><h4 id="Windows-XP-32-位"><a href="#Windows-XP-32-位" class="headerlink" title="Windows XP 32 位"></a>Windows XP 32 位</h4><p>Windows XP 32 位按照是否支持 PAE 和是否支持多处理器分为 4 个内核。</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>支持 PAE</th>
<th>支持 SMP（多处理器）</th>
<th>用途与说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ntoskrnl.exe</code></td>
<td>❌ 否</td>
<td>❌ 否</td>
<td>标准 <strong>单处理器</strong>，<strong>非 PAE</strong> 模式使用</td>
</tr>
<tr>
<td><code>ntkrnlpa.exe</code></td>
<td>✅ 是</td>
<td>❌ 否</td>
<td>单处理器，<strong>启用 PAE</strong> 的内核</td>
</tr>
<tr>
<td><code>ntkrnlmp.exe</code></td>
<td>❌ 否</td>
<td>✅ 是</td>
<td>多处理器 SMP，<strong>非 PAE</strong> 模式使用</td>
</tr>
<tr>
<td><code>ntkrpamp.exe</code></td>
<td>✅ 是</td>
<td>✅ 是</td>
<td>多处理器 SMP，<strong>启用 PAE</strong> 的完整内核（PAE + MP 全支持）</td>
</tr>
</tbody></table>
<p>我们通过 <code>boot.ini</code> 指定 <code>/PAE</code> 参数，并可通过 <code>/KERNEL=xxx.exe</code> 可以显式指定要加载的内核映像。</p>
<blockquote>
<p><code>boot.ini</code> 是 Windows NT 系列（如 Windows XP、2000、Server 2003）中用于控制启动引导参数的配置文件。它属于 NT Loader（ntldr）引导机制的一部分</p>
</blockquote>
<div class="code-container" data-rel="Ini"><figure class="iseeu highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[boot loader]</span></span><br><span class="line"><span class="attr">timeout</span>=<span class="number">5</span></span><br><span class="line"><span class="attr">default</span>=multi(<span class="number">0</span>)disk(<span class="number">0</span>)rdisk(<span class="number">0</span>)partition(<span class="number">1</span>)\WINDOWS</span><br><span class="line"><span class="section">[operating systems]</span></span><br><span class="line">multi(0)disk(0)rdisk(0)partition(1)\<span class="attr">WINDOWS</span>=<span class="string">&quot;Windows XP (PAE)&quot;</span> /fastdetect /PAE</span><br><span class="line">multi(0)disk(0)rdisk(0)partition(1)\<span class="attr">WINDOWS</span>=<span class="string">&quot;Windows XP (No PAE)&quot;</span> /fastdetect /NOPAE</span><br></pre></td></tr></table></figure></div>

<p> 启动时你将看到两个选项：</p>
<ul>
<li><code>Windows XP (PAE)</code> 会启用 PAE 分页，可能加载 <code>ntkrnlpa.exe</code> &#x2F; <code>ntkrpamp.exe</code></li>
<li><code>Windows XP (No PAE)</code> 会强制关闭 PAE，使用 <code>ntoskrnl.exe</code> &#x2F; <code>ntkrnlmp.exe</code></li>
</ul>
<h4 id="Windows-Vista-7-32-位"><a href="#Windows-Vista-7-32-位" class="headerlink" title="Windows Vista &#x2F; 7 32 位"></a>Windows Vista &#x2F; 7 32 位</h4><p>Windows Vista &#x2F; 7 32 位后不再区分 <code>mp</code> 和 <code>up</code>，统一支持 SMP。<strong>也不再使用 <code>ntkrnlmp.exe</code> 等文件</strong>。并且这个版本之后不再使用 <code>boot.ini</code> 而是使用 <code>bcdedit</code> 修改 PAE 状态。</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>支持 PAE</th>
<th>支持多核 (SMP)</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ntoskrnl.exe</code></td>
<td>❌ 否</td>
<td>✅ 是</td>
<td>默认内核映像，未启用 PAE 时使用</td>
</tr>
<tr>
<td><code>ntkrnlpa.exe</code></td>
<td>✅ 是</td>
<td>✅ 是</td>
<td>启用 PAE 时使用（通过 <code>bcdedit /set pae ForceEnable</code>）</td>
</tr>
</tbody></table>
<p><strong>从 Windows Vista 开始（包括 Windows 7&#x2F;8&#x2F;10&#x2F;11）就已经彻底废除了 <code>boot.ini</code></strong> ，转而使用新的引导配置机制 <strong>BCD（Boot Configuration Data）</strong>。该机制通过 <code>bcdedit</code> 命令进行配置，具体步骤为：</p>
<ol>
<li><p><strong>复制当前默认启动配置</strong></p>
<div class="code-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /<span class="built_in">copy</span> &#123;current&#125; /d &quot;Windows <span class="number">7</span> - No PAE&quot;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>这会复制当前启动项，生成一个新 GUID（比如 <code>&#123;3e9a0...&#125;</code>）。</li>
<li>新启动项会出现在启动菜单中，名字叫 <strong>“Windows 7 - No PAE”</strong>。</li>
</ul>
<p>正常情况下系统返回类似下面这段输出：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The entry was successfully copied to &#123;3e9a0123-xxxx-xxxx&#125;.</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>给这个新启动项设置关闭 PAE 参数</strong></p>
<div class="code-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /<span class="built_in">set</span> &#123;<span class="number">3</span>e9a0123-xxxx-xxxx&#125; pae ForceDisable</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p>再次开机时会看到：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Windows 7</span><br><span class="line">Windows 7 - No PAE</span><br></pre></td></tr></table></figure></div>

<ul>
<li>第一个启用 PAE，可能支持 DEP、安全保护机制；</li>
<li>第二个禁用 PAE，用于兼容旧驱动或调试。</li>
</ul>
<h4 id="Windows-64-位"><a href="#Windows-64-位" class="headerlink" title="Windows 64 位"></a>Windows 64 位</h4><p>Windows 7 &#x2F; 10 &#x2F; 11 等 64 位系统使用长模式分页，<code>ntoskrnl.exe</code> 已合并所有功能模块，不再有 PAE &#x2F; 非 PAE 区分，也不再需要多个版本。</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>支持 PAE</th>
<th>支持多核 (SMP)</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ntoskrnl.exe</code></td>
<td>✅ 是</td>
<td>✅ 是</td>
<td>唯一内核映像，默认启用 PAE + SMP + NX（DEP）等</td>
</tr>
</tbody></table>
<h3 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h3><p><code>CR0</code>～<code>CR4</code> 是 x86 架构中的 <strong>控制寄存器（Control Registers）</strong>，它们是 <strong>CPU 控制系统级特性和行为的关键寄存器</strong>。这些寄存器 <strong>只能在特权级 0（Ring 0）下访问</strong>，用于开启分页、保护模式、中断响应、缓存控制等功能。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/image-20250609044743350.png"
                      alt="image-20250609044743350"
                ></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>状态</th>
<th>主要功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>CR0</code></td>
<td>使用中</td>
<td>启用保护模式、分页机制、缓存控制、对齐检查、写保护等</td>
</tr>
<tr>
<td><code>CR1</code></td>
<td><strong>保留</strong></td>
<td><strong>未使用，Intel 架构中始终保留</strong></td>
</tr>
<tr>
<td><code>CR2</code></td>
<td>使用中</td>
<td>保存最近一次<strong>页错误异常（#PF）</strong>的线性地址</td>
</tr>
<tr>
<td><code>CR3</code></td>
<td>使用中</td>
<td><strong>页目录基地址</strong>（或 PAE 下页目录指针表地址），分页的起点</td>
</tr>
<tr>
<td><code>CR4</code></td>
<td>使用中</td>
<td>启用各种扩展功能，如 PAE、大页、PGE、SMEP、SMAP 等</td>
</tr>
<tr>
<td><code>CR8</code></td>
<td>64 位专用</td>
<td>控制 <strong>中断优先级（Task Priority Level）</strong>，用于高级中断屏蔽</td>
</tr>
</tbody></table>
<h4 id="CR0"><a href="#CR0" class="headerlink" title="CR0"></a>CR0</h4><p>CR0 控制的是处理器的基本操作模式，特别是保护模式、分页机制、缓存和协处理器等。其关键位如下：</p>
<table>
<thead>
<tr>
<th>位号</th>
<th>名称</th>
<th>含义 &amp; 功能</th>
</tr>
</thead>
<tbody><tr>
<td>31</td>
<td><strong>PG</strong></td>
<td>📌 <strong>Paging Enable</strong> ：启用分页机制。需要 <code>PE=1</code>（保护模式）才能生效。</td>
</tr>
<tr>
<td>30</td>
<td><strong>CD</strong></td>
<td>📌 <strong>Cache Disable</strong> ：禁止 CPU 缓存，设为 1 时强制所有访问绕过缓存（需配合 <code>NW=0</code>）。</td>
</tr>
<tr>
<td>29</td>
<td><strong>NW</strong></td>
<td>📌 <strong>Not Write-through</strong> ：当 <code>CD=0</code> 时决定写回&#x2F;直写策略（Write-back&#x2F;Write-through）。</td>
</tr>
<tr>
<td>18</td>
<td><strong>AM</strong></td>
<td><strong>Alignment Mask</strong> ：启用对对齐错误的检测。需 <code>EFLAGS.AC=1</code>、<code>CPL=3</code> 且当前处于保护模式或 V8086 模式。</td>
</tr>
<tr>
<td>16</td>
<td><strong>WP</strong></td>
<td>📌 <strong>Write Protect</strong> ：设置为 1 时，内核模式代码无法写入只读页（即使 <code>U/S=0</code>）。常用于 Copy-On-Write（COW）。</td>
</tr>
<tr>
<td>5</td>
<td><strong>NE</strong></td>
<td><strong>Numeric Error</strong> ：启用内部机制报告 x87 浮点错误；为 0 时使用 PC 式 FERR# 引脚。</td>
</tr>
<tr>
<td>4</td>
<td><strong>ET</strong></td>
<td><strong>Extension Type</strong>（已弃用）：在现代 CPU 中固定为 1。</td>
</tr>
<tr>
<td>3</td>
<td><strong>TS</strong></td>
<td><strong>Task Switched</strong> ：任务切换后由 CPU 设置，用于延迟保存 FPU&#x2F;MMX&#x2F;SSE 状态。与 <code>EM/MP</code> 配合控制 FPU 异常。</td>
</tr>
<tr>
<td>2</td>
<td><strong>EM</strong></td>
<td><strong>Emulation</strong> ：启用浮点指令模拟（禁用 FPU、MMX、SSE 指令，抛出 #NM &#x2F; #UD）。</td>
</tr>
<tr>
<td>1</td>
<td><strong>MP</strong></td>
<td><strong>Monitor Coprocessor</strong> ：配合 <code>TS</code> 控制 <code>WAIT/FWAIT</code> 指令是否触发 #NM。</td>
</tr>
<tr>
<td>0</td>
<td><strong>PE</strong></td>
<td>📌 <strong>Protection Enable</strong> ：启用保护模式。仅此位不足以开启分页，需同时 <code>PG=1</code> 才行。</td>
</tr>
</tbody></table>
<h4 id="CR2"><a href="#CR2" class="headerlink" title="CR2"></a>CR2</h4><table>
<thead>
<tr>
<th>内容</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Page Fault Linear Address</strong></td>
<td>仅当发生页错误（#PF）时，由处理器自动写入导致错误的线性地址。调试和异常处理中使用频繁。</td>
</tr>
</tbody></table>
<h4 id="CR3"><a href="#CR3" class="headerlink" title="CR3"></a>CR3</h4><p>仅在分页启用（<code>CR0.PG=1</code>）时生效，用于指示页目录（或 PDPTE）的物理地址：</p>
<table>
<thead>
<tr>
<th>位号</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>31:12</td>
<td><strong>Page Directory Base</strong></td>
<td>页目录&#x2F;页目录指针表的物理地址高位。必须 4KB 对齐，低 12 位为 0。</td>
</tr>
<tr>
<td>4</td>
<td><strong>PCD</strong></td>
<td>Page-level Cache Disable：控制页表访问的缓存行为。为 1 则关闭缓存。</td>
</tr>
<tr>
<td>3</td>
<td><strong>PWT</strong></td>
<td>Page-level Write-Through：控制页表访问的写策略。</td>
</tr>
<tr>
<td>2:0, 11:5, 63:32</td>
<td>-</td>
<td>保留&#x2F;忽略位，在 PAE 或 IA-32e 模式下含义不同。</td>
</tr>
</tbody></table>
<p>注意：在 PAE&#x2F;64 位模式下，<code>CR3</code> 不直接索引 PDE&#x2F;PTE，而是用于定位 <strong>PDPTE 表</strong>。</p>
<h4 id="CR4"><a href="#CR4" class="headerlink" title="CR4"></a>CR4</h4><p>提供了分页、虚拟化、异常处理、SIMD 等新机制的开关，位数最多，关键位如下：</p>
<table>
<thead>
<tr>
<th>位号</th>
<th>名称</th>
<th>功能简述</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td><strong>VME</strong></td>
<td>Virtual-8086 Mode Extensions（虚拟中断处理）</td>
</tr>
<tr>
<td>1</td>
<td><strong>PVI</strong></td>
<td>Protected-mode Virtual Interrupts，支持虚拟 8086 中断</td>
</tr>
<tr>
<td>2</td>
<td><strong>TSD</strong></td>
<td>限制 <code>RDTSC</code> 指令只能在 CPL&#x3D;0 执行</td>
</tr>
<tr>
<td>3</td>
<td><strong>DE</strong></td>
<td>禁用对 DR4&#x2F;DR5 寄存器的访问（生成 #UD），否则 CPU 会将对 <code>DR4</code> 和 <code>DR5</code> 的访问重定向到 <code>DR6</code> 和 <code>DR7</code>，这是为了兼容旧软件（早期 IA-32 处理器中曾使用 DR4&#x2F;DR5）</td>
</tr>
<tr>
<td>4</td>
<td><strong>PSE</strong></td>
<td>📌 启用 4MB 大页（非 PAE 下）</td>
</tr>
<tr>
<td>5</td>
<td><strong>PAE</strong></td>
<td>📌 启用物理地址扩展（使用 PDPTE 层、36 位物理地址）</td>
</tr>
<tr>
<td>6</td>
<td><strong>MCE</strong></td>
<td>启用机器检查异常（Machine Check Exception）</td>
</tr>
<tr>
<td>7</td>
<td><strong>PGE</strong></td>
<td>📌 启用全局页（带 <code>G</code> 标志的页不因 CR3 更新而清空 TLB）</td>
</tr>
<tr>
<td>8</td>
<td><strong>PCE</strong></td>
<td>用户态也能执行 <code>RDPMC</code> 指令</td>
</tr>
<tr>
<td>9</td>
<td><strong>OSFXSR</strong></td>
<td>OS 支持 <code>FXSAVE/FXRSTOR</code>，支持 SSE&#x2F;SSE2</td>
</tr>
<tr>
<td>10</td>
<td><strong>OSXMMEXCPT</strong></td>
<td>OS 支持 SSE 异常处理（#XM）</td>
</tr>
<tr>
<td>11</td>
<td><strong>UMIP</strong></td>
<td>用户模式禁止访问 <code>SGDT/SIDT/STR/SMSW/SLDT</code></td>
</tr>
<tr>
<td>12</td>
<td><strong>LA57</strong></td>
<td>启用 5 级分页，支持 57 位线性地址</td>
</tr>
<tr>
<td>13</td>
<td><strong>VMXE</strong></td>
<td>启用虚拟化扩展（VMX）</td>
</tr>
<tr>
<td>14</td>
<td><strong>SMXE</strong></td>
<td>启用安全模式扩展（SMX）</td>
</tr>
<tr>
<td>16</td>
<td><strong>FSGSBASE</strong></td>
<td>允许直接读写 <code>FS/GS</code> 基址</td>
</tr>
<tr>
<td>17</td>
<td><strong>PCIDE</strong></td>
<td>启用进程上下文标识（不刷新 TLB 切换上下文）</td>
</tr>
<tr>
<td>18</td>
<td><strong>OSXSAVE</strong></td>
<td>OS 支持 <code>XSAVE/XRSTOR/XGETBV/XSETBV</code></td>
</tr>
<tr>
<td>19</td>
<td><strong>KL</strong></td>
<td>启用 AES Key Locker</td>
</tr>
<tr>
<td>20</td>
<td><strong>SMEP</strong></td>
<td>Supervisor Mode Execution Protection（防止内核执行用户页）</td>
</tr>
<tr>
<td>21</td>
<td><strong>SMAP</strong></td>
<td>Supervisor Mode Access Protection（防止内核访问用户页）</td>
</tr>
<tr>
<td>22</td>
<td><strong>PKE</strong></td>
<td>启用用户页保护键（Protection Key）机制</td>
</tr>
<tr>
<td>23</td>
<td><strong>CET</strong></td>
<td>启用控制流强制（CET）技术</td>
</tr>
<tr>
<td>24</td>
<td><strong>PKS</strong></td>
<td>启用 supervisor 页面的保护键机制</td>
</tr>
</tbody></table>
<h4 id="CR8"><a href="#CR8" class="headerlink" title="CR8"></a>CR8</h4><table>
<thead>
<tr>
<th>位号</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>3:0</td>
<td><strong>TPL</strong></td>
<td>Task Priority Level：中断优先级阈值；<code>0</code> 表示允许所有中断，<code>15</code> 表示屏蔽所有中断。仅在 IA-32e 模式（64 位）使用。</td>
</tr>
</tbody></table>
<h3 id="非-PAE-分页"><a href="#非-PAE-分页" class="headerlink" title="非 PAE 分页"></a>非 PAE 分页</h3><p>在 32 位系统中，如果 <code>CR0.PG = 1</code>（启用分页）且 <code>CR4.PAE = 0</code>（未启用 PAE）则为非 PAE 分页模式，也就是我们常说的 10-10-12 分页模式。</p>
<h4 id="页表结构"><a href="#页表结构" class="headerlink" title="页表结构"></a>页表结构</h4><p><strong>在不考虑大页的情况下</strong>，非 PAE 分页模式的页表结构如下图所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/NO-PAE.svg"
                      alt="NO-PAE"
                ></p>
<p>该模式通过 <strong>2 级页表结构</strong>，将 32 位的线性地址映射到 <strong>最多 4GB 的物理地址空间</strong>。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>层级</th>
<th>数量与结构</th>
<th>每项大小 &#x2F; 总大小</th>
<th>作用说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>页目录表（Page Directory）</strong></td>
<td>一级结构</td>
<td>每进程 1 个，含 1024 个页目录项（PDE）</td>
<td>每项 4 字节，共 4KB</td>
<td>每项控制 <strong>4MB 线性空间</strong>，可指向页表或直接映射一个 4MB 大页（需 <code>CR4.PSE=1</code>）</td>
</tr>
<tr>
<td><strong>页表（Page Table）</strong></td>
<td>二级结构</td>
<td>最多 1024 个，每表含 1024 个页表项（PTE）</td>
<td>每项 4 字节，共 4KB</td>
<td>每项映射一个 <strong>4KB 物理页框</strong>，控制 4KB 线性空间。由 PDE 间接索引获得</td>
</tr>
</tbody></table>
<h5 id="地址转换过程"><a href="#地址转换过程" class="headerlink" title="地址转换过程"></a>地址转换过程</h5><p>非 PAE 分页模式的线性地址到物理地址的转换过程如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/image-20250607022406579.png"
                      alt="image-20250607022406579"
                ></p>
<p><strong>线性地址</strong>由高到低划分为 <strong>10 位 PDE 索引</strong>、<strong>10 位 PTE 索引</strong> 和 <strong>12 位页内偏移</strong>，其中 10，10，12 恰好对应：</p>
<ul>
<li>一个页目录表包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span></span></span></span> 个 PDE。</li>
<li>一个页表包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span></span></span></span> 个 PTE。</li>
<li>一个内存页大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span></span></span></span> 字节。</li>
</ul>
<p>例如假设线性地址为 <code>0x12345678</code>，则具体的转换过程如下：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>PDE Index</td>
<td>0x48</td>
<td>CR3 指向页目录 → 第 0x48 项 PDE</td>
</tr>
<tr>
<td>PTE Index</td>
<td>0xD1</td>
<td>PDE 指向的页表 → 第 0xD1 项 PTE</td>
</tr>
<tr>
<td>Offset</td>
<td>0x678</td>
<td>页内偏移，定位物理页中的位置</td>
</tr>
</tbody></table>
<h5 id="页目录自映射"><a href="#页目录自映射" class="headerlink" title="页目录自映射"></a>页目录自映射</h5><p>另外，为了方便操作系统在内核态访问并维护自身的页表结构，Windows 会设置页目录表中 <strong>第 <code>0x301</code> 项（769 项）</strong> 的 <strong>页目录项 PDE</strong> 指向<strong>页目录表自身的物理地址</strong>，实现所谓的 <strong>页目录自映射</strong>（Page Directory Self-Mapping）机制。这样，整个页目录表和所有页表都可以通过一组固定的线性地址访问。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/NO-PAE-flat.svg"
                      alt="NO-PAE-flat"
                ></p>
<ul>
<li><p><strong>页目录表</strong>的<strong>线性地址</strong>为：<code>0x300 &lt;&lt; (12 + 10) | 0x300 &lt;&lt; 12 = 0xC0300000</code></p>
<ul>
<li><p>第 <code>N</code> 个 PDE 的<strong>线性地址</strong>为：<code>0xC0300000 + (N - 1) * 4</code>（后面加的是第 <code>N</code> 个 PDE 在页目录表中的偏移）</p>
</li>
<li><p>第 0x301 个 PDE 存放着<strong>页目录表的物理地址</strong>，对应<strong>线性地址</strong>为：<code>0xC0300000 + 0x300 * 4 = 0xC0300c00</code></p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>因此我们可以从 <code>0xC0300c00</code> 地址读取到<strong>页目录表的物理地址</strong>。</p>

    </div>
  </div>
</li>
<li><p>线性地址 <code>p</code> 对应的 PDE 的线性地址为：<code>0xC0300000 | ((p &gt;&gt; (12 + 10)) * 4) = 0xC0300000 | p &gt;&gt; 20 &amp; 0xFFC</code></p>
</li>
</ul>
</li>
<li><p><strong>第一个 PDE</strong> 指向的<strong>页表</strong>（如果有）基址对应的<strong>线性地址</strong>为：<code>0x300 &lt;&lt; (12 + 10) = 0xC0000000</code></p>
<ul>
<li><p>第 <code>N</code> 个 PDE 指向的页表（如果有）基址对应的线性地址为：<code>0xC0000000 | (N - 1) &lt;&lt; 12 = 0xC0000000 + (N - 1) * 0x1000</code></p>
</li>
<li><p>第 <code>N</code> 个 PDE 指向的页表的第 <code>M</code> 个 PTE的线性地址为：<code>0xC0000000 | (N - 1) &lt;&lt; 12 | (M - 1) * 4 = 0xC0000000 + (N - 1) * 0x1000 + (M - 1) * 4</code></p>
</li>
<li><p>线性地址 <code>p</code> 对应的 PTE 的线性地址为：<code>0xC0000000 | ((p &gt;&gt; 12) * 4) = 0xC0000000 | p &gt;&gt; 10 &amp; 0x3FFFFC</code></p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>这个公式计算 PTE 的 PTE 时会找到指向 PTE 所在页表的 PDE 的线性地址；同理在计算 PDE 的 PTE 时会找到 <code>PDE[0x300]</code> 的线性地址。
  </p>

    </div>
  </div></li>
</ul>
</li>
</ul>
<h4 id="页表属性"><a href="#页表属性" class="headerlink" title="页表属性"></a>页表属性</h4><p>在非 PAE 分页模式下，页表相关属性如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/image-20250607042913949.png"
                      alt="image-20250607042913949"
                ></p>
<p><strong>其中 PDE（页目录项）主要有两种类型</strong>，取决于 <strong>PDE 的第 7 位（PS 位）</strong> 的取值，这两种 PDE 的结构稍有不同。</p>
<table>
<thead>
<tr>
<th>页大小</th>
<th>PS 位</th>
<th>解释方式</th>
<th>PDE 指向的对象</th>
<th>后续结构</th>
</tr>
</thead>
<tbody><tr>
<td><strong>4KB</strong> 页</td>
<td>0</td>
<td>二级页表结构</td>
<td>指向一个<strong>页表</strong>（PTE 数组）</td>
<td>需要查找 PTE</td>
</tr>
<tr>
<td><strong>4MB</strong> 页</td>
<td>1</td>
<td>一级页表结构（大页）</td>
<td>直接映射一个<strong>4MB 页框</strong></td>
<td>不查 PTE，直接定位物理页</td>
</tr>
</tbody></table>
<h5 id="CR3-1"><a href="#CR3-1" class="headerlink" title="CR3"></a>CR3</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/CR3.svg"
                      alt="CR3"
                ></p>
<ul>
<li><p><strong>页目录基地址（Address of page directory）</strong> ：<strong>CR3 的 Bits[31:12]</strong> 存储的是页目录的 <strong>物理地址的高 20 位</strong>（即第 12~31 位）。因为页目录必须 4KB 对齐，因此其低 12 位始终为 0，<strong>不会在 CR3 中存储</strong>。另外 <code>Bits[63:32]</code> 仅在 64 位模式下使用，在普通 32 位分页中忽略。</p>
</li>
<li><p><strong>页级写通标志（PWT, Page-level Write Through）</strong> ：位于 CR3 的 <strong>第 3 位</strong>，指定访问页目录时所用内存类型是否为<strong>直写缓存策略</strong>（Write-Through）。仅在启用页表缓存机制时生效，属于 <strong>间接影响</strong>。</p>
<blockquote>
<p><strong>直写缓存策略</strong>（Write-Through）指的是每次 <strong>CPU 写数据到缓存时</strong>，<strong>也会立即写入主内存</strong>，也就是说主内存始终是最新数据。</p>
</blockquote>
</li>
<li><p><strong>页级缓存禁止（PCD, Page-level Cache Disable）</strong> ：位于 CR3 的 <strong>第 4 位</strong>，指定是否对页目录表所在的内存区域禁用缓存。如果设为 1，则 CR3 所指向的整个页目录将不会被缓存，即<strong>CR3 所指向的</strong>页目录表所在内存区域，<strong>不会进入 CPU 的缓存系统</strong>（如 L1&#x2F;L2&#x2F;L3 cache），<strong>每次访问都直接访问内存（DRAM）</strong>。</p>
</li>
</ul>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>在调试的时候，我们可以通过 <code>!process 0 0</code> 来获取<strong>页目录基地址</strong>。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !process 0 0</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">Failed to get VadRoot</span><br><span class="line">PROCESS 8a01dda0  SessionId: 0  Cid: 0498    Peb: 7ffde000  ParentCid: 05f8</span><br><span class="line">    DirBase: a9024000  ObjectTable: e1bf5dc8  HandleCount:  52.</span><br><span class="line">    Image: notepad.exe</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>DirBase</code> 的值 <code>a9024000</code> 就是<strong>页目录基地址</strong>的<strong>物理地址</strong>。</p>

    </div>
  </div>

<h5 id="PDE"><a href="#PDE" class="headerlink" title="PDE"></a>PDE</h5><p>首先对于 4KB 页对应的 PDE，该页目录项的结构如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/PDE-4K.svg"
                      alt="PDE-4K"
                ></p>
<ul>
<li><p><strong>存在位（P, Present）</strong> ：表示该 PDE 是否有效，这里需要设置为 1 表示有效。</p>
<ul>
<li>1：该 PDE 有效，处理器可使用；</li>
<li>0：该 PDE 无效效，访问相关内存地址会触发 <strong>#PF（Page Fault）</strong>。</li>
</ul>
</li>
<li><p><strong>读&#x2F;写标志（R&#x2F;W, Read&#x2F;Write）</strong> ：控制该页是否可写。</p>
<ul>
<li>0：只读；</li>
<li>1：可读可写（实际受 <code>CR0.WP</code> 影响）。</li>
</ul>
</li>
<li><p><strong>用户&#x2F;特权标志（U&#x2F;S, User&#x2F;Supervisor）</strong> ：控制访问权限级别。</p>
<ul>
<li>0：仅 CPL 0~2（内核）可访问；</li>
<li>1：所有特权级（包括用户态）可访问。</li>
</ul>
</li>
<li><p><strong>页级直写缓存策略（PWT, Page-level Write Through）</strong> ：控制缓存策略。</p>
<ul>
<li>1：<strong>Write-Through</strong>（写同时写入主存和缓存）；</li>
<li>0：<strong>Write-Back</strong>（只写缓存，主存延迟刷新）。</li>
</ul>
</li>
<li><p><strong>页级缓存禁止（PCD, Page-level Cache Disable）</strong> ：控制是否禁用该页表所在区域的缓存。</p>
<ul>
<li>1：<strong>禁止缓存</strong>，每次访问都直接访问主内存；</li>
<li>0：允许缓存。</li>
</ul>
</li>
<li><p><strong>访问位（A, Accessed）</strong> ：由处理器在访问该 PDE（即页表）时自动置 1。OS 可用来统计页面活跃度、用于换页算法。</p>
</li>
<li><p><strong>页大小标志（PS, Page Size）</strong> ：指定 PDE 是映射页表还是映射 4MB 大页。</p>
<ul>
<li>0：PDE 指向一个 <strong>页表</strong>（常见）；</li>
<li>1：PDE 直接映射一个 <strong>4MB 大页</strong>（需 <code>CR4.PSE=1</code>）。</li>
</ul>
</li>
<li><p><strong>页表物理基地址（Page Table Base Address）</strong> ：用于指定页表的 <strong>物理地址的高 20 位</strong>，表示该 PDE 所对应页表的实际位置。因为页表是 4KB 对齐，低 12 位为 0，因此未在 PDE 中存储，实际页表地址为 <code>PDE[31:12] &lt;&lt; 12</code>。</p>
</li>
</ul>
<p>而对于 4MB PDE，由于是直接记录物理页的地址，因此比 4KB PTE 多了一些 PTE 相关的属性。另外就是由于从 <code>10-10-12</code> 变成了 <code>10-22</code>，也就是说指向的物理页大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>22</mn></msup></mrow><annotation encoding="application/x-tex">2^{22}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">22</span></span></span></span></span></span></span></span></span></span></span></span> 字节，基址关于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>22</mn></msup></mrow><annotation encoding="application/x-tex">2^{22}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">22</span></span></span></span></span></span></span></span></span></span></span></span> 对齐，因此只需要 <code>32 - 22 = 10</code> 比特来记录物理页的物理地址。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/image-20250607234821590.png"
                      alt="image-20250607234821590"
                ></p>
<p>4MB PDE 的各字段分布如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/PDE-4M.svg"
                      alt="PDE-4M"
                ></p>
<p>相对于 4KB PDE 有变化的属性如下：</p>
<ul>
<li><p><strong>脏位（D, Dirty）</strong> ：当该页<strong>被写入</strong>过时，自动由 CPU 置 <code>1</code>，用于操作系统判断是否需要回写磁盘。</p>
</li>
<li><p><strong>页面大小（PS, Page Size）</strong> ：固定为 <code>1</code>，表示这是一个 4MB 大页项，而非指向页表（4KB 页面）。</p>
</li>
<li><p><strong>全局页（G, Global）</strong> ：为 <code>1</code> 时表示该页为全局页（不因 CR3 切换被 TLB 清除），仅当 <code>CR4.PGE=1</code> 有效。</p>
</li>
<li><p><strong>PAT 位（Page Attribute Table）</strong> ：CPU 用来选择<strong>内存缓存类型</strong>的一个控制位，它和 CR0、CR3 中的 PCD&#x2F;PWT 配合，最终决定某一页（或一块内存）<strong>以什么样的缓存策略访问</strong>。</p>
</li>
<li><p><strong>页框基址（Page Frame Address）</strong> ：存储 4MB 页起始的<strong>物理地址高 10 位</strong>。低 22 位默认为 0（因为对齐到 4MB）。另外如果 <strong>支持 PSE-36 机制</strong> 并且 <strong>处理器支持的最大物理地址宽度为 36</strong>，则页框基址可以存储 14 位，可以映射 64 GB 的物理地址。</p>
</li>
</ul>
<h5 id="PTE"><a href="#PTE" class="headerlink" title="PTE"></a>PTE</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/PTE.svg"
                      alt="PTE"
                ></p>
<p>前面两种 PDT 基本包含了 PTE 的所有属性，PTE 主要变化就是在 4MB PDT 的基础上把 <code>PAT</code> 字段移动到了 <code>PS</code> 字段上（PTE 不需要 <code>PS</code> 字段）。</p>
<h3 id="PAE-分页"><a href="#PAE-分页" class="headerlink" title="PAE 分页"></a>PAE 分页</h3><p>在 32 位处理器中，若设置 <code>CR0.PG = 1</code>（启用分页）<strong>且</strong> <code>CR4.PAE = 1</code>（启用物理地址扩展），则启用 <strong>PAE 分页模式</strong>，也就是我们常说的 2-9-9-12 分页模式。此时每个进程的线性地址空间仍为 4GB，但可访问的<strong>物理地址上限扩展到 64GB（36 位地址）</strong>。</p>
<h4 id="页表结构-1"><a href="#页表结构-1" class="headerlink" title="页表结构"></a>页表结构</h4><p>PAE 模式采用 <strong>3 级页表结构</strong>。<strong>在不考虑大页的情况下</strong>，PAE 分页模式的页表结构如下图所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/PAE.svg"
                      alt="PAE"
                ></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>层级</th>
<th>数量与结构</th>
<th>每项大小 &#x2F; 总大小</th>
<th>作用说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>页目录指针表（PDPT）</strong></td>
<td>顶层结构</td>
<td>每进程 1 个，含 4 项</td>
<td>每项 8 字节，共 32B</td>
<td>每项指向一个页目录，控制 1GB 线性空间</td>
</tr>
<tr>
<td><strong>页目录表（Page Directory）</strong></td>
<td>一级结构</td>
<td>最多 4 个，每表含 512 项 PDE</td>
<td>每项 8 字节，共 4KB</td>
<td>每项指向一个页表，或直接映射 2MB 大页（需 PS&#x3D;1）</td>
</tr>
<tr>
<td><strong>页表（Page Table）</strong></td>
<td>二级结构</td>
<td>最多 512 个，每表含 512 项 PTE</td>
<td>每项 8 字节，共 4KB</td>
<td>每项映射 4KB 物理页，提供最小的线性地址映射单元</td>
</tr>
</tbody></table>
<h5 id="地址转换过程-1"><a href="#地址转换过程-1" class="headerlink" title="地址转换过程"></a>地址转换过程</h5><p>PAE 分页模式的线性地址到物理地址的转换过程如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/image-20250608014033134.png"
                      alt="image-20250608014033134"
                ></p>
<p>PAE 模式下将 32 位线性地址按如下方式拆分，即 <strong>2-9-9-12</strong> 分层结构。</p>
<ul>
<li><code>Bits[31:30]</code>（2 位）：选择 PDPT 中的页目录项（最多 4 项）</li>
<li><code>Bits[29:21]</code>（9 位）：选择页目录中的 PDE（最多 512 项）</li>
<li><code>Bits[20:12]</code>（9 位）：选择页表中的 PTE（最多 512 项）</li>
<li><code>Bits[11:0]</code>（12 位）：页内偏移（4KB）</li>
</ul>
<p>如果是大页模式，则线性地址低 21 比特作为 2MB 大小物理页的页内偏移。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/image-20250608014252251.png"
                      alt="image-20250608014252251"
                ></p>
<h5 id="页目录自映射-1"><a href="#页目录自映射-1" class="headerlink" title="页目录自映射"></a>页目录自映射</h5><p>PAE 分页模式下的<strong>页目录自映射</strong>（Page Directory Self-Mapping）机制也发生变化。由于 PDPTE 代替了 CR3 的功能，因此需要由第 4 个页目录表实现页目录自映射机制。该页目录表的前 4 项分别指向 4 个页目录表，因此在线性地址空间中，4 个页目录表以及对应映射的页表分布如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/PAE-flat.svg"
                      alt="PAE-flat"
                ></p>
<p>根据<strong>页目录自映射</strong>的特性可知，对应一个线性地址 <code>p</code> ：</p>
<ul>
<li>对应的 PTE 的线性地址为：<code>0xC0000000 | ((p &gt;&gt; 12) * 8) = 0xC0000000 | (p &gt;&gt; 9 &amp; 0x7FFFF8)</code>。<ul>
<li><code>(p &gt;&gt; 12) * 8</code> 中右移 12 是在计算页框编号，也就是第几个 PTE；乘 8 是在计算页框号对应的 PTE 的偏移。这种计算方法是从页表分布上推导出来的。</li>
<li><code>(p &gt;&gt; 12) * 8 = p &gt;&gt; 9 &amp; 0x7FFFF8</code>，而右移 9 使得 32 位地址中最高 2 位放在 <code>2-9-9-12</code> 中第一个 “9” 的范围内，从另一个角度印证了只需要第 3 个页目录表的前 4 个 PDE 就可以实现页目录<strong>自映射机制</strong>。</li>
</ul>
</li>
<li>对应的 PDE 的线性地址为：<code>0xC0600000 | ((p &gt;&gt; (12 + 9)) * 8) = 0xC0600000 | p &gt;&gt; 18 &amp; 0x3FF8</code>。</li>
</ul>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <ul>
<li>PAE 分页模式物理地址寻址增大不是因为分页层数增多，而是因为每一个页表项从 4 字节增加到 8 字节，导致物理地址字段长度增大。</li>
<li>新增<strong>页目录指针表（PDPT）</strong>的原因是每一个页表项从 4 字节增加到 8 字节，导致索引范围从 1024（10 bits）减小到 512（9 bits）,空出了 2 bits。</li>
<li><strong>页目录指针表（PDPT）</strong>的作用是代替非 PAE 模式的 CR3，从而避免利用<strong>页目录自映射</strong>（Page Directory Self-Mapping）机制从固定线性地址读取到 CR3 存储的值。</li>
</ul>

    </div>
  </div>

<h4 id="页表属性-1"><a href="#页表属性-1" class="headerlink" title="页表属性"></a>页表属性</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/image-20250608023903628.png"
                      alt="image-20250608023903628"
                ></p>
<h5 id="CR3-2"><a href="#CR3-2" class="headerlink" title="CR3"></a>CR3</h5><p>在开启 PAE 之后，CR3 寄存器的字段发生了一些变化。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/CR3-PAE.svg"
                      alt="CR3-PAE"
                ></p>
<ul>
<li><p><strong>CR3 在 PAE 模式下</strong>，其 Bits[31:5] 存放 PDPTE 表的<strong>物理地址高位</strong>（因 32 字节对齐，所以低 5 位为 0）。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>在调试时我们可以通过 <code>!process 0 0</code> 输出的 <code>DirBase</code> 是关于 0x20 还是 0x1000 对齐快速判断出当前是否是 PAE 分页模式。</p>

    </div>
  </div>
</li>
<li><p>将 CR3 中的 <code>PWT</code> 和 <code>PCD</code> 字段转移到了 PWPTE 中。</p>
</li>
</ul>
<h5 id="PDPTE"><a href="#PDPTE" class="headerlink" title="PDPTE"></a>PDPTE</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/PDPTE.svg"
                      alt="PDPTE"
                ></p>
<p>PDPTE 中主要承担了非 PAE 分页中的 CR3 的功能，唯一的区别就是 PDPTE 比 CR3 多了一个 <code>P</code> 标志位表示该 PDPTE 是否有效。</p>
<p>另外就是由于物理地址增大到 36 bits，因此页目录表地址字段增大到 36 - 12 &#x3D; 24 bits。</p>
<h5 id="PDE-1"><a href="#PDE-1" class="headerlink" title="PDE"></a>PDE</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/PDE-4K-PAE.svg"
                      alt="PDE-4K-PAE"
                ></p>
<p>对于 <code>PS</code> 位为 0 的 PDE，各字段分布基本和非 PAE 分页模式一致，只不过页表地址字段从原来的 20 bits 增加到 24 bits。</p>
<p>另外 PAE 模式的 PDE 新增了一个 <code>XD</code> 字段，即 <strong>Execute Disable</strong>（不可执行页）位。如果启用了 <code>IA32_EFER.NXE</code>（No eXecute Enable），则可以使用该位禁用页的代码执行，用于实现 <strong>DEP（数据执行保护）</strong> 等安全特性。如果 <code>NXE</code> 没启用，该位为 <strong>保留位</strong>（必须为 0）。</p>
<blockquote>
<p><code>IA32_EFER.NXE</code> 是 Intel x86 架构中一个控制位，用于 <strong>开启“不可执行页”功能（Execute Disable，XD）</strong>，位于 <strong><code>IA32_EFER</code>（扩展功能使能寄存器）</strong> 的 <strong>第 11 位</strong>。</p>
<p><strong><code>IA32_EFER</code> 是一个寄存器</strong>，更准确地说，它是一个 <strong>Model-Specific Register（MSR，模型特定寄存器）</strong>。因为这个寄存器是 Intel 专门定义的一类控制寄存器，不像通用寄存器那样在汇编中直接访问。要通过 <code>RDMSR</code> 和 <code>WRMSR</code> 指令来读写。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/PDR-2M-PAE.svg"
                      alt="PDR-2M-PAE"
                ></p>
<p>对于  <code>PS</code> 位为 1 的 PDE，各字段分布基本和非 PAE 分页模式同样基本一致。不同点是由于大页的大小有 4MB 减半到 2MB，因此地址字段的起始位从 22 减小到 21。</p>
<h5 id="PTE-1"><a href="#PTE-1" class="headerlink" title="PTE"></a>PTE</h5><p>PTE 除了内存页物理地址字段长度增加外基本无变化。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/09/28/windows%20%E5%86%85%E6%A0%B8%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/images/PTE-PAE.svg"
                      alt="PTE-PAE"
                ></p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>分页不仅仅是地址映射，它与 CPU 的<strong>缓存体系</strong>（L1&#x2F;L2&#x2F;L3 Cache）与 <strong>TLB（Translation Lookaside Buffer）</strong> 紧密配合，高效完成地址转换与缓存一致性管理。</p>
<pre class="mermaid">flowchart TD
    %% ───── 1. 发起访问 ─────
    subgraph LA["线性地址"]
        A0["发起内存访问<br/>(CPU 指令)"]
    end
    A0 --> B1[TLB 查询]

    %% ───── 2. TLB 分支 ─────
    B1 -->|命中| C0[得到物理页基址<br/>+ 权限/属性<br/>Write/Exec 检查]
    B1 -->|未命中| PWalk["Page Walk<br/>(CR3→PDPTE→PDE→PTE)"]

    %% ---- Page Walk 子流程 ----
    subgraph Page_Table["页表遍历 (硬件完成)"]
        PWalk --> P1[PDPTE<br/>① 定位 1 GB 区域]
        P1 --> P2[PDE<br/>② 定位 2 MB 区域<br/>或继续页表]
        P2 --> P3[PTE<br/>③ 定位 4 KB 页框]
        P3 --> PT_Exit[得到物理页基址]
    end
    PT_Exit --> UpdateTLB["写入/更新 TLB<br/>(缓存映射)"]
    UpdateTLB --> C0

    %% ---- 3. 权限检查 ----
    C0 -->|权限允许| L1[L1 Cache 查询]
    C0 -->|权限不允许| PageFault[#PF → Page-Fault Handler]

    %% ---- 写时复制（COW） ----
    PageFault -->|写时复制触发| DoCOW[COW：分配新页+复制+更新页表]
    %% 触发 invlpg，刷本虚拟页的 TLB 项
    DoCOW -.invLPG(TLB flush).-> L1

    %% 非法访问
    PageFault -->|非法访问等| Kill[进程终止 / 抛异常]

    %% ---- 4. Cache → DRAM ----
    L1 -->|命中| Return[返回数据]
    L1 -->|未命中| L2[L2 Cache 查询]
    L2 -->|命中| Return
    L2 -->|未命中| L3["L3 (LLC) 查询"]
    L3 -->|命中| Return
    L3 -->|未命中| DRAM[主存 DRAM 访问]
    DRAM --> FillCache["加载到 L1<br/>(并按一致性写入 L2/L3)"]
    FillCache --> Return

    %% ---- 样式：仅热点节点上色（不含 DRAM） ----
    classDef hot fill:#d5f5d5,stroke:#2c6a21;
    class C0,L1,L2,L3,FillCache,Return hot;</pre>

<h4 id="CPU-缓存层级结构（L1-L2-L3）"><a href="#CPU-缓存层级结构（L1-L2-L3）" class="headerlink" title="CPU 缓存层级结构（L1 &#x2F; L2 &#x2F; L3）"></a>CPU 缓存层级结构（L1 &#x2F; L2 &#x2F; L3）</h4><p>CPU Cache 是 CPU 内部用于缓存主存（DRAM）数据的硬件单元，用于提升访问频繁数据的速度。主要分为多级：</p>
<table>
<thead>
<tr>
<th>缓存级别</th>
<th>延迟（大致）</th>
<th>每核独立？</th>
<th>存什么？</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>L1 Cache</td>
<td>1~3 cycle</td>
<td>✅ 是</td>
<td>指令 &#x2F; 数据</td>
<td>最快</td>
</tr>
<tr>
<td>L2 Cache</td>
<td>10~20 cycle</td>
<td>✅ 是</td>
<td>L1 的后备</td>
<td>大</td>
</tr>
<tr>
<td>L3 Cache</td>
<td>40~70 cycle</td>
<td>⛔ 否，共享</td>
<td>所有数据（共享页表）</td>
<td>更大更慢</td>
</tr>
</tbody></table>
<p>这些缓存用于存储「最近访问的内存数据」，而数据来自「物理地址」，也就是说 <strong>CPU Cache 缓存的是“物理地址 → 数据”的映射。</strong></p>
<h5 id="缓存类型"><a href="#缓存类型" class="headerlink" title="缓存类型"></a>缓存类型</h5><p>内存的 <strong>缓存类型（Cache Type）</strong> 决定了 CPU 如何对某块物理内存进行缓存操作，包括：是否缓存、以何种策略缓存、如何写入内存等。缓存类型不仅影响性能，还关系到设备访问的一致性和可靠性（例如访问显存、MMIO 寄存器时必须禁止缓存）。</p>
<table>
<thead>
<tr>
<th>PAT 编码</th>
<th>MTRR 编码</th>
<th>名称（缩写）</th>
<th>中文释义</th>
<th>特征说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>00h</code></td>
<td><code>06h</code></td>
<td><strong>Write-Back (WB)</strong></td>
<td>写回缓存</td>
<td><strong>默认策略</strong>。读写均使用缓存（L1&#x2F;L2&#x2F;L3）；<strong>写操作只更新缓存，延迟刷新主存</strong>（由缓存一致性机制控制）。<strong>性能最佳</strong>，支持预取、读写合并、乱序执行等，<strong>适用于普通主存数据访问</strong>。</td>
</tr>
<tr>
<td><code>01h</code></td>
<td><code>04h</code></td>
<td><strong>Write-Through (WT)</strong></td>
<td>直写缓存</td>
<td><strong>写操作同时写入缓存和主存</strong>，保证主存数据始终最新；<strong>读操作仍可命中缓存</strong>。适用于<strong>对主存一致性要求高</strong>的区域，如共享内存。<strong>写性能低于 WB</strong>。</td>
</tr>
<tr>
<td><code>02h</code></td>
<td><code>07h</code></td>
<td><strong>Uncached Minus (UC-)</strong></td>
<td>弱无缓存</td>
<td><strong>Intel 专有类型</strong>。行为类似 UC，但<strong>允许有限度的预取和请求合并</strong>。部分 CPU 可能仍使用缓存机制优化访问。适合<strong>性能敏感但对一致性要求略低</strong>的设备地址映射区域。</td>
</tr>
<tr>
<td><code>03h</code></td>
<td><code>00h</code></td>
<td><strong>Uncacheable (UC)</strong></td>
<td>不可缓存</td>
<td><strong>完全禁用缓存</strong> ：所有访问<strong>直接访问主存</strong>，不使用缓存、不支持预取、合并、乱序。适用于 <strong>MMIO、设备寄存器、显存帧缓冲</strong>等 <strong>对时序要求严格</strong>的场景。</td>
</tr>
<tr>
<td><code>04h</code></td>
<td><code>01h</code></td>
<td><strong>Write-Combining (WC)</strong></td>
<td>写合并</td>
<td><strong>不缓存读操作</strong>，但<strong>写操作可合并多个写入请求后批量写入主存</strong>。适用于<strong>图像缓冲区、视频帧缓冲、DMA 区域等大吞吐场景</strong>。<strong>写性能提升显著</strong>，但不保证一致性。</td>
</tr>
<tr>
<td><code>05h</code></td>
<td><code>05h</code></td>
<td><strong>Write-Protected (WP)</strong></td>
<td>只读缓存</td>
<td><strong>只读可缓存</strong>，但<strong>所有写操作必须访问主存</strong>（写不命中缓存）。适用于<strong>代码段或受保护数据页</strong>，<strong>防止意外修改或提升写安全性</strong>。</td>
</tr>
<tr>
<td><code>07h</code></td>
<td><code>00h</code></td>
<td><strong>UC（冗余编码）</strong></td>
<td>与 UC 等效</td>
<td>与 <code>03h</code> <strong>完全等价</strong>，行为与 UC 一致，出于<strong>兼容性考虑保留</strong>此编码。部分 BIOS&#x2F;固件使用该编码表示 UC。</td>
</tr>
</tbody></table>
<p>我们常见的几种内存的缓存机制如下：</p>
<table>
<thead>
<tr>
<th>区域</th>
<th>推荐类型</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>显卡显存（MMIO）</td>
<td><code>UC</code> &#x2F; <code>WC</code></td>
<td>避免缓存污染 &#x2F; 提高写效率</td>
</tr>
<tr>
<td>页表 &#x2F; CR3</td>
<td><code>WT</code> &#x2F; <code>UC</code></td>
<td>保证一致性</td>
</tr>
<tr>
<td>普通内核代码页</td>
<td><code>WB</code></td>
<td>高效指令读取</td>
</tr>
<tr>
<td>DMA 缓冲区</td>
<td><code>UC</code> &#x2F; <code>WC</code></td>
<td>避免设备与 CPU 缓存不一致</td>
</tr>
<tr>
<td>用户态栈 &#x2F; 堆</td>
<td><code>WB</code></td>
<td>高频读写，性能关键</td>
</tr>
</tbody></table>
<h5 id="缓存类型的配置机制"><a href="#缓存类型的配置机制" class="headerlink" title="缓存类型的配置机制"></a>缓存类型的配置机制</h5><p>缓存类型是 <strong>多个机制共同决定的结果</strong>，包括：</p>
<table>
<thead>
<tr>
<th>来源</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>页表项的 PCD &#x2F; PWT &#x2F; PAT 位</strong></td>
<td>控制页级别的缓存策略</td>
</tr>
<tr>
<td><strong>IA32_PAT 寄存器</strong></td>
<td>定义 PAT 编码与缓存类型的映射</td>
</tr>
<tr>
<td><strong>MTRR（Memory Type Range Register）</strong></td>
<td>控制物理地址范围的默认缓存类型</td>
</tr>
<tr>
<td><strong>固定类型内存（如设备寄存器）</strong></td>
<td>固定为 UC（不可缓存）或 WC（写合并）等类型</td>
</tr>
</tbody></table>
<p>每个页表项（PDE&#x2F;PTE）都有这三位控制缓存：</p>
<table>
<thead>
<tr>
<th>位名</th>
<th>含义</th>
<th>取值 1 的效果</th>
</tr>
</thead>
<tbody><tr>
<td><code>PWT</code></td>
<td>Page-level Write-Through</td>
<td>采用 Write-Through 策略</td>
</tr>
<tr>
<td><code>PCD</code></td>
<td>Page-level Cache Disable</td>
<td>禁用缓存（Uncached）</td>
</tr>
<tr>
<td><code>PAT</code></td>
<td>Page Attribute Table</td>
<td>用于选择 PAT 中的映射项（解释见下）</td>
</tr>
</tbody></table>
<p>这三位组成一个 <strong>3 位索引（b2b1b0 &#x3D; PAT,PWT,PCD）</strong>，共可表示 <strong>8 种编码（0~7）</strong>，再由 <strong><code>IA32_PAT</code></strong> 映射到缓存类型。</p>
<table>
<thead>
<tr>
<th>编号（索引）</th>
<th>对应组合（PAT:PWT:PCD）</th>
<th>默认缓存类型（如 IA32 手册）</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0:0:0</td>
<td>Write-Back (WB)</td>
</tr>
<tr>
<td>1</td>
<td>0:0:1</td>
<td>Write-Through (WT)</td>
</tr>
<tr>
<td>2</td>
<td>0:1:0</td>
<td>Uncached Minus (UC-)</td>
</tr>
<tr>
<td>3</td>
<td>0:1:1</td>
<td>Uncached (UC)</td>
</tr>
<tr>
<td>4</td>
<td>1:0:0</td>
<td>Write-Combining (WC)</td>
</tr>
<tr>
<td>5</td>
<td>1:0:1</td>
<td>Write-Protected (WP)</td>
</tr>
<tr>
<td>6</td>
<td>1:1:0</td>
<td>保留</td>
</tr>
<tr>
<td>7</td>
<td>1:1:1</td>
<td>UC（冗余）</td>
</tr>
</tbody></table>
<p>最终使用哪种类型由 CPU 按一定优先级解析这些机制的组合。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 固定类型区域（如 ROM/显存）？</span><br><span class="line">   是 → 使用平台指定类型（如 UC）</span><br><span class="line"></span><br><span class="line">2. 页表项中 PCD/PWT/PAT 存在？</span><br><span class="line">   是 → 用它们组成 PAT 索引 → 查询 IA32_PAT → 得到类型</span><br><span class="line"></span><br><span class="line">3. MTRR 中匹配该物理地址？</span><br><span class="line">   是 → 使用 MTRR 设置的缓存类型</span><br><span class="line"></span><br><span class="line">4. 否则 → 使用默认缓存策略（通常是 WB）</span><br></pre></td></tr></table></figure></div>

<h4 id="TLB（Translation-Lookaside-Buffer）"><a href="#TLB（Translation-Lookaside-Buffer）" class="headerlink" title="TLB（Translation Lookaside Buffer）"></a>TLB（Translation Lookaside Buffer）</h4><p><strong>TLB 是一种「地址映射的缓存」</strong>，专门缓存页表翻译（虚拟 → 物理）。</p>
<h5 id="TLB-属性"><a href="#TLB-属性" class="headerlink" title="TLB 属性"></a>TLB 属性</h5><p>通常 TLB 中的每一项包含如下属性：</p>
<ul>
<li><code>LA</code>：线性地址（Linear Address）</li>
<li><code>PA</code>：物理地址（Physical Address）</li>
<li><code>ATTR</code>：权限与属性字段（如 R&#x2F;W, U&#x2F;S, PWT, PCD, PAT 等）<ul>
<li>非 PAE（<code>10-10-12</code>）下：<code>ATTR = PDE 属性 &amp; PTE 属性</code></li>
<li>PAE（或 4级页表，如 <code>9-9-9-12</code>）下：<code>ATTR = PDPTE 属性 &amp; PDE 属性 &amp; PTE 属性</code></li>
</ul>
</li>
<li><code>LRU</code>：最近最少使用（Least Recently Used）统计信息，TLB替换策略之一</li>
</ul>
<p><strong>这些都是标准硬件 TLB 中会缓存的内容</strong>，尤其现代 CPU 会把 PTE&#x2F;PDE&#x2F;PDPTE 的<strong>属性字段</strong>也缓存进去，加快访问判断速度，避免再次查页表。</p>
<p>当 TLB 未命中时 → 需要查完整页表 → 增加延迟 → 加载结果再写入 TLB。</p>
<h5 id="TLB-类型"><a href="#TLB-类型" class="headerlink" title="TLB 类型"></a>TLB 类型</h5><p>在典型的 x86 CPU（从 Intel 486 起）中，为了提高虚拟地址到物理地址转换的效率，CPU 内部通常设置多组 TLB 缓存，按用途和页大小分为：</p>
<ul>
<li><strong>Instruction TLB for 4KB pages</strong> ：用于缓存指令取值所需的 4KB 页映射；</li>
<li><strong>Data TLB for 4KB pages</strong> ：用于缓存数据访问所需的 4KB 页映射；</li>
<li><strong>Instruction TLB for large pages (2MB&#x2F;4MB)</strong> ：用于缓存代码段中的大页映射；</li>
<li><strong>Data TLB for large pages (2MB&#x2F;4MB)</strong> ：用于缓存数据段中的大页映射；</li>
</ul>
<p>在现代 CPU 架构中，上述 TLB 有可能是多级的（L1&#x2F;L2），并支持更多页大小（如 1GB），具体组织方式视 CPU 实现而定。</p>
<h5 id="TLB-控制位"><a href="#TLB-控制位" class="headerlink" title="TLB 控制位"></a>TLB 控制位</h5><table>
<thead>
<tr>
<th>标志位</th>
<th>寄存器</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CR4.PGE</strong></td>
<td>CR4[7]</td>
<td>开启全局页（Global Page）支持；全局页不因 CR3 切换被刷新</td>
</tr>
<tr>
<td><strong>PDE&#x2F;PTE.G</strong></td>
<td>页表项 bit 8</td>
<td>与 CR4.PGE 配合，标记页项为全局页，避免频繁清除</td>
</tr>
<tr>
<td><strong>CR4.PCIDE</strong></td>
<td>CR4[17]</td>
<td>启用 PCID 支持，配合 CR3 实现不清 TLB 的上下文切换</td>
</tr>
</tbody></table>
<h5 id="TLB-刷新方式"><a href="#TLB-刷新方式" class="headerlink" title="TLB 刷新方式"></a>TLB 刷新方式</h5><p>TLB（Translation Lookaside Buffer）是一个 <strong>缓存虚拟地址到物理地址映射</strong> 的结构（即<strong>页表的副本</strong>）。当页表发生变更后，<strong>TLB 中的内容可能过时</strong>，这时候就必须刷新 TLB，防止地址转换错误。</p>
<p>常见的 TLB 刷新方式如下：</p>
<ul>
<li><p><strong>写入 <code>CR3</code>（页目录基地址）寄存器</strong> 是最常见的刷新方式，不论 CR3 的值是否真的改变，CR3 寄存器写入都会导致 TLB 被清空（传统 x86）。不过这种方式<strong>性能损耗较大</strong>，因为所有地址映射都要重新查页表。<strong>如果禁用 <code>CR4.PGE</code>，G 页也会被清除。</strong></p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="built_in">cr3</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cr3</span>, <span class="built_in">eax</span>     <span class="comment">; 触发完整 TLB flush</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>局部刷新（invlpg 指令）</strong>只刷新一个页（以页为单位），但是可以<strong>无视 <code>G</code> 标志位强制刷新</strong>。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">invlpg</span> [<span class="number">0x8048000</span>] <span class="comment">; 使虚拟地址 0x8048000 的 TLB 项失效</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h1 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h1><h2 id="Windows-基础"><a href="#Windows-基础" class="headerlink" title="Windows 基础"></a>Windows 基础</h2><h3 id="内核对象"><a href="#内核对象" class="headerlink" title="内核对象"></a>内核对象</h3><p><strong>内核对象（Kernel Object）</strong>，是 Windows 内核里对各种内核资源进行统一管理、统一命名、统一访问控制、统一生命周期控制的一种抽象机制。</p>
<h4 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h4><p>在没有内核对象之前，Windows 内核里存在着大量不同类型的资源（如设备，文件，进程线程等），这些资源每种结构体都不一样，但是每种都要支持用户态访问（有名字，有权限控制，有引用计数，有安全策略）。</p>
<p>因此 Windows 采用了一种类似 Linux 的 “万物皆文件” 的设计思想，即将每个需要统一管理的内核资源都被包装成一个 <strong>“内核对象”</strong>，交由 <strong>Object Manager（对象管理器）</strong> 组件管理。这样可以统一的解决下面几个问题：</p>
<table>
<thead>
<tr>
<th>典型问题</th>
<th>Object Manager 提供的统一解法</th>
</tr>
</thead>
<tbody><tr>
<td>内核里有驱动、设备、进程、互斥量、事件、共享内存等几十种资源，<em>各自</em>要命名、要 ACL、要引用计数、要调试符号。</td>
<td>定义 <strong>OBJECT_HEADER + OBJECT_BODY</strong> 模型；创建&#x2F;打开&#x2F;引用&#x2F;关闭&#x2F;删除流程全部交给 <strong>Object Manager</strong>（Ob）。</td>
</tr>
<tr>
<td>资源的生命周期复杂：谁来保证用完才释放？</td>
<td><code>PointerCount</code>（内核指针引用） + <code>HandleCount</code>（用户&#x2F;内核句柄数量）双计数模型，当二者皆为 0 时由 Ob 自动回收。</td>
</tr>
<tr>
<td>用户进程需要安全地访问部分内核资源</td>
<td>把 <strong>SECURITY_DESCRIPTOR</strong> 嵌进对象；用户通过系统调用走 <strong>SeAccessCheck</strong>。</td>
</tr>
<tr>
<td>调试&#x2F;监控工具需要统一查看</td>
<td>所有命名对象都挂进 <strong>对象目录树</strong>（Directory Object）；Windbg &#x2F; ETW &#x2F; AV 可以枚举。</td>
</tr>
</tbody></table>
<h4 id="内核对象结构"><a href="#内核对象结构" class="headerlink" title="内核对象结构"></a>内核对象结构</h4><p>每个内核对象在被 Object Manager 在分配时，自动套上了一个统一的“对象头部”+（可能存在的附加信息头）+ 对象体数据。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|---------------------------|</span><br><span class="line">| POOL_HEADER               |  内存池头部</span><br><span class="line">|---------------------------|</span><br><span class="line">| OBJECT_HEADER_NAME_INFO   |  名字信息 (可选)</span><br><span class="line">|---------------------------|</span><br><span class="line">| OBJECT_HEADER_HANDLE_INFO |  句柄信息 (可选)</span><br><span class="line">|---------------------------|</span><br><span class="line">| OBJECT_HEADER_QUOTA_INFO  |  配额信息 (可选)</span><br><span class="line">|---------------------------|</span><br><span class="line">| OBJECT_HEADER             |  内核对象统一头部 (必定存在)</span><br><span class="line">|---------------------------|</span><br><span class="line">| OBJECT_BODY               |  对象体结构 (如 DRIVER_OBJECT)</span><br><span class="line">|---------------------------|</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>OBJECT_HEADER</code> 在内核对象中一定存在，该结构体在不同版本的 Windows 中会发生变化，下面是一些常见字段：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>PointerCount</code> (LONG)</td>
<td>内核所有“裸指针”引用计数</td>
</tr>
<tr>
<td><code>HandleCount</code> (LONG)</td>
<td>所有进程句柄数量</td>
</tr>
<tr>
<td><code>Type</code> (POBJECT_TYPE)</td>
<td>指向 <code>DRIVER_OBJECT_TYPE</code> &#x2F; <code>DEVICE_OBJECT_TYPE</code>…</td>
</tr>
<tr>
<td><code>Flags</code></td>
<td><code>OB_FLAG_PERMANENT</code> &#x2F; <code>EXCLUSIVE</code> &#x2F; <code>KERNEL_MODE</code> 等</td>
</tr>
<tr>
<td><code>InfoMask</code></td>
<td>标记是否有 Name&#x2F;Handle&#x2F;Quota 这三种可选头</td>
</tr>
</tbody></table>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p><strong>Win11 以后 PatchGuard</strong> 会随机调整可选头偏移，驱动代码必须使用官方宏（<code>OBJECT_HEADER_NAME_INFO_OFFSET</code> 等）而非写死偏移。</p>

    </div>
  </div>

<h4 id="Object-Manager-命名空间"><a href="#Object-Manager-命名空间" class="headerlink" title="Object Manager 命名空间"></a>Object Manager 命名空间</h4><p><strong>Object Manager 命名空间</strong> 是 Windows 内核中统一管理一切内核对象的“对象目录树”。</p>
<ul>
<li>它的本质是一个内核内存中的<strong>目录树结构</strong>；</li>
<li>每个可以被命名的内核对象都被挂载在这棵树上；</li>
<li>Object Manager 负责解析路径、查找对象、引用计数、权限控制等一切逻辑。</li>
</ul>
<p>整个 Object Manager 命名空间以 <strong><code>\</code></strong> 为根目录，形成一棵类似文件系统的目录树。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">\                                （根目录，DirectoryObject）</span><br><span class="line">├── Driver                       所有驱动对象 (DriverObject)</span><br><span class="line">│     └── MyDriver</span><br><span class="line">│</span><br><span class="line">├── Device                       所有设备对象 (DeviceObject)</span><br><span class="line">│     └── Harddisk0</span><br><span class="line">│     └── Serial0</span><br><span class="line">│</span><br><span class="line">├── ??                           ★ 符号链接桥梁目录 (SymbolicLinkObject)</span><br><span class="line">│     ├── C:         → \Device\HarddiskVolume1</span><br><span class="line">│     ├── COM1       → \Device\Serial0</span><br><span class="line">│     └── MyLink     → \Device\MyDevice</span><br><span class="line">│</span><br><span class="line">├── BaseNamedObjects             ★ 用户会话 0 命名空间（全局同步对象）</span><br><span class="line">│     └── MyEvent</span><br><span class="line">│     └── MyMutex</span><br><span class="line">│</span><br><span class="line">├── Sessions                     ★ 多用户会话隔离目录</span><br><span class="line">│     └── 1</span><br><span class="line">│         └── BaseNamedObjects   （Session 1 的私有命名空间）</span><br><span class="line">│</span><br><span class="line">├── ObjectTypes                  ★ 已注册的内核对象类型列表</span><br><span class="line">├── Windows (部分版本存在)</span><br><span class="line">└── 其它系统内部目录</span><br></pre></td></tr></table></figure></div>

<p>其中每一类目录的具体作用如下：</p>
<table>
<thead>
<tr>
<th>目录名</th>
<th>作用</th>
<th>常见对象类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>\Driver</code></td>
<td>存放所有已注册的内核驱动对象</td>
<td><code>DriverObject</code></td>
</tr>
<tr>
<td><code>\Device</code></td>
<td>存放所有设备对象，供 I&#x2F;O 管理器使用</td>
<td><code>DeviceObject</code></td>
</tr>
<tr>
<td><code>\??</code></td>
<td>符号链接目录：Win32 路径与内核对象桥接</td>
<td><code>SymbolicLinkObject</code></td>
</tr>
<tr>
<td><code>\BaseNamedObjects</code></td>
<td>全局同步对象命名区（Session 0 共享）</td>
<td><code>Event</code> &#x2F; <code>Mutex</code> &#x2F; <code>Semaphore</code></td>
</tr>
<tr>
<td><code>\Sessions\N\BaseNamedObjects</code></td>
<td>多用户会话隔离命名空间</td>
<td>各自的同步对象</td>
</tr>
<tr>
<td><code>\ObjectTypes</code></td>
<td>存放系统内置的对象类型定义表</td>
<td><code>ObjectTypeObject</code></td>
</tr>
</tbody></table>
<p>其中 <code>\??</code> 目录（全名为 <code>DosDevices Directory</code>）是 Object Manager 里专门用来桥接 <strong>Win32 路径系统 ↔ 内核命名空间</strong> 的目录。它里面挂载的都是 <strong>符号链接对象（SymbolicLinkObject）</strong>，用于：</p>
<ul>
<li>盘符映射 (<code>C:</code> → <code>\Device\HarddiskVolumeX</code>)</li>
<li>传统设备名 (<code>COM1</code> → <code>\Device\Serial0</code>)</li>
<li>自定义设备别名（通过 <code>IoCreateSymbolicLink()</code> 创建）</li>
</ul>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>所以你看到的 <code>\\.\COM1</code>，Win32 实际内部转为 <code>\??\COM1</code>，由 Object Manager 查找对应符号链接完成跳转。</p>
<p><strong>只要某路径存在于 <code>\??\</code> 下，并且链接指向有效内核对象，用户态理论上就能访问。（不考虑权限问题）</strong></p>
<p><strong>如果路径不经过 <code>\??\</code>（例如裸的 <code>\Device\xxx</code>、<code>\Driver\xxx</code>、<code>\BaseNamedObjects\xxx</code>），则 3环无法直接访问。</strong></p>

    </div>
  </div>

<h4 id="常用-API"><a href="#常用-API" class="headerlink" title="常用 API"></a>常用 API</h4><ul>
<li><p><code>ObReferenceObjectByName</code> 函数可以用路径字符串找到任何已存在内核对象，并返回其内核对象指针。</p>
  <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">ObReferenceObjectByName</span><span class="params">(</span></span><br><span class="line"><span class="params">  IN PUNICODE_STRING ObjectName,   <span class="comment">// [输入] 要查找的对象完整路径名 (例如: &quot;\\Driver\\MyDriver&quot;)</span></span></span><br><span class="line"><span class="params">  IN ULONG Attributes,             <span class="comment">// [输入] 属性标志，常用 OBJ_CASE_INSENSITIVE (忽略大小写匹配)</span></span></span><br><span class="line"><span class="params">  IN PACCESS_STATE AccessState OPTIONAL, <span class="comment">// [输入] 安全访问状态，普通内核使用时传 NULL</span></span></span><br><span class="line"><span class="params">  IN ACCESS_MASK DesiredAccess,    <span class="comment">// [输入] 请求的访问权限，一般填 0 表示默认即可</span></span></span><br><span class="line"><span class="params">  IN POBJECT_TYPE ObjectType,      <span class="comment">// [输入] 对象类型指针，例如 *IoDriverObjectType、*IoDeviceObjectType 等</span></span></span><br><span class="line"><span class="params">  IN KPROCESSOR_MODE AccessMode,   <span class="comment">// [输入] 访问模式，一般传 KernelMode</span></span></span><br><span class="line"><span class="params">  IN PVOID ParseContext OPTIONAL,  <span class="comment">// [输入] 解析上下文 (高阶场景使用)，通常传 NULL</span></span></span><br><span class="line"><span class="params">  OUT PVOID *Object                <span class="comment">// [输出] 成功时返回获取到的对象指针 (注意：需 ObDereferenceObject 释放引用计数)</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><h4 id="四类常见路径"><a href="#四类常见路径" class="headerlink" title="四类常见路径"></a>四类常见路径</h4><p>Windows 系统有四种路径：</p>
<ul>
<li><p><strong>Win32 路径（DOS 路径）</strong> ：用户程序使用的路径，例如：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\System32\drivers\Test.sys</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>仅存在于 Win32 API 层；内核本身不识别盘符。</p>
</li>
<li><p>首次进入内核时经 <code>RtlDosPathNameToNtPathName</code> 转成 <code>\??\C:\...</code>。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p><code>\??</code> 是 Object Manager 命名空间下的一个目录，里面存放大量符号链接（充当快捷方式），这些符号链接用于将盘符、传统设备名等映射到内核对象的真实路径。当 Win32 子系统将用户空间的 DOS 路径传入内核时，会先将其转换为以 <code>\??</code> 为前缀的 NT 路径，由内核在 <code>\??</code> 目录中解析出对应的真实内核对象路径。</p>

    </div>
  </div></li>
</ul>
</li>
<li><p><strong>NT 文件路径</strong> ：I&#x2F;O 管理器与文件系统驱动的直接输入，例如：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\Device\HarddiskVolume1\Windows\System32\drivers\Test.sys</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>盘符被解析为真正卷设备对象。</p>
</li>
<li><p><code>ZwCreateFile/ZwOpenFile</code> 等内核 API 需传此类路径</p>
</li>
</ul>
</li>
<li><p><strong>Win32 设备路径 <code>\\.\</code></strong> </p>
<p>用户态的路径会被<strong>Win32默认认为要访问的是”文件系统”里的文件</strong>。Win32 会按照<strong>文件系统路径解析</strong>的逻辑进行处理：</p>
<ol>
<li><p>解析 <code>C:</code> 盘符；（由于设备路径缺少盘符，一般会在这一步报错❌）</p>
</li>
<li><p>找到其对应物理卷；</p>
</li>
<li><p>然后交给文件系统驱动处理。</p>
</li>
</ol>
<p>然而，像 COM1 串口、物理硬盘 (<code>PhysicalDrive0</code>)、USB 端口、命名管道、内核设备对象这些根本不属于文件系统。文件系统找不到这些对象，它们被挂在 <code>\Device\xxx</code> 下（内核对象管理器里）。因此<strong>如果用户程序也希望用标准的 <code>CreateFile()</code> 访问设备对象则 Win32 会试图当做文件路径来走，肯定会失败。</strong>于是微软在 Win32 设计了一个特殊标记机制：只要路径以 <code>\\.\</code> 开头，Win32 不参与文件系统逻辑，而是把后面的内容原样放进 <code>\??</code> 命名空间，留给内核对象管理器自己去解析。例如：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\\.\COM1        →  \??\COM1          →  \Device\Serial0</span><br><span class="line">\\.\PhysicalDrive0 →  \??\PhysicalDrive0 →  \Device\Harddisk0\DR0</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>Object Manager 路径</strong> ：所有内核对象的正式地址。样的路径仅对对象管理函数有效，如 <code>ObReferenceObjectByName</code>、<code>IoCreateDevice</code>、<code>IoCreateSymbolicLink</code> 等 API 可以直接使用；对文件 API 无意义。</p>
</li>
</ul>
<h4 id="典型解析链路"><a href="#典型解析链路" class="headerlink" title="典型解析链路"></a>典型解析链路</h4><p>文件示例：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CreateFile(&quot;C:\\Windows\\System32\\drivers\\Test.sys&quot;)</span><br><span class="line">      │</span><br><span class="line">      └─► Win32 → NT 转换</span><br><span class="line">              \??\C:\Windows\System32\drivers\Test.sys</span><br><span class="line">                   │</span><br><span class="line">                   └─► \??\C: (符号链接)</span><br><span class="line">                           ↓</span><br><span class="line">                          \Device\HarddiskVolume1</span><br><span class="line">                                │</span><br><span class="line">                                └─► 完整 NT 路径</span><br><span class="line">                                    \Device\HarddiskVolume1\Windows\System32\drivers\Test.sys</span><br></pre></td></tr></table></figure></div>

<p>设备示例：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CreateFile(&quot;\\\\.\\COM1&quot;)</span><br><span class="line">      │</span><br><span class="line">      └─► \??\COM1   (Win32 设备路径)</span><br><span class="line">             │</span><br><span class="line">             └─► 符号链接解析</span><br><span class="line">                  \Device\Serial0   ← 真实设备对象</span><br></pre></td></tr></table></figure></div>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="驱动基本概念"><a href="#驱动基本概念" class="headerlink" title="驱动基本概念"></a>驱动基本概念</h2><p><strong>驱动程序（Driver）</strong>是运行在操作系统内核或用户模式中的软件组件，负责在操作系统与硬件设备之间“翻译”命令与数据。</p>
<h3 id="驱动框架"><a href="#驱动框架" class="headerlink" title="驱动框架"></a>驱动框架</h3><p>微软为简化驱动开发，提供了三种主要框架：</p>
<table>
<thead>
<tr>
<th>框架名</th>
<th>全称</th>
<th>运行模式</th>
<th>推荐用途</th>
</tr>
</thead>
<tbody><tr>
<td><strong>WDM</strong></td>
<td>Windows Driver Model</td>
<td>内核模式</td>
<td>底层控制、兼容性极强，但复杂</td>
</tr>
<tr>
<td><strong>KMDF</strong></td>
<td>Kernel-Mode Driver Framework</td>
<td>内核模式</td>
<td>封装了 WDM 的常见任务（如 PnP、电源管理、同步、I&#x2F;O 队列等），推荐用于大多数设备驱动开发</td>
</tr>
<tr>
<td><strong>UMDF</strong></td>
<td>User-Mode Driver Framework</td>
<td>用户模式</td>
<td>WDF 框架的另一部分，适用于开发<strong>运行在用户模式</strong>的驱动，推荐用于外围、低风险设备驱动</td>
</tr>
</tbody></table>
<p>考虑到兼容性，我们通常采用 WDM 框架开发驱动。</p>
<h3 id="驱动服务名"><a href="#驱动服务名" class="headerlink" title="驱动服务名"></a>驱动服务名</h3><p>驱动的<strong>服务名（Service Name）</strong>是系统用来识别和管理驱动程序的逻辑标识符，它是注册表 <code>HKLM\SYSTEM\CurrentControlSet\Services</code> 下的子项名称，也是驱动服务控制、注册、加载、配置等操作的核心索引键。</p>
<p>例如如果我们加载一个名称为 <code>Services.sys</code> 的驱动，则会在注册表中对应创建一个 <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services</code> 子项。</p>
<ul>
<li><code>CurrentControlSet</code> → 实际指向 <code>ControlSet001</code> 或 <code>ControlSet002</code>，系统启动时动态决定</li>
<li><code>Services</code> → 包含所有服务与驱动程序的定义项</li>
</ul>
<p>在该子项中通常有如下键值对：</p>
<table>
<thead>
<tr>
<th>键名</th>
<th>类型</th>
<th>示例值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ImagePath</strong></td>
<td><code>REG_EXPAND_SZ</code></td>
<td><code>\??\C:\Path\to\MyDriver.sys</code></td>
<td>驱动文件路径，通常位于 <code>%SystemRoot%\System32\drivers\</code></td>
</tr>
<tr>
<td><strong>Type</strong></td>
<td><code>REG_DWORD</code></td>
<td><code>1</code>, <code>2</code></td>
<td>指定服务&#x2F;驱动类型（详见下文）</td>
</tr>
<tr>
<td><strong>Start</strong></td>
<td><code>REG_DWORD</code></td>
<td><code>0</code>, <code>1</code>, <code>3</code></td>
<td>启动类型（详见下文）</td>
</tr>
<tr>
<td><strong>Group</strong></td>
<td><code>REG_SZ</code></td>
<td><code>Base</code>, <code>Boot Bus Extender</code></td>
<td>指定驱动分组，影响加载顺序</td>
</tr>
<tr>
<td><strong>ErrorControl</strong></td>
<td><code>REG_DWORD</code></td>
<td><code>1</code></td>
<td>启动失败时的处理方式</td>
</tr>
<tr>
<td><strong>DisplayName</strong></td>
<td><code>REG_SZ</code></td>
<td><code>My Sample Driver</code></td>
<td>控制面板中显示的服务名称（可选）</td>
</tr>
<tr>
<td><strong>Description</strong></td>
<td><code>REG_SZ</code></td>
<td><code>Test WDM Driver</code></td>
<td>人类可读描述信息（可选）</td>
</tr>
<tr>
<td><strong>Tag</strong></td>
<td><code>REG_DWORD</code></td>
<td>分组内排序标识（较少使用）</td>
<td></td>
</tr>
<tr>
<td><strong>Parameters</strong></td>
<td><code>REG_KEY</code></td>
<td>子键</td>
<td>自定义参数保存区，驱动可读取用于配置</td>
</tr>
</tbody></table>
<blockquote>
<p><code>\??\</code> 是 <strong>Windows 内核对象管理器</strong>（Object Manager）中的一个符号链接目录，代表当前会话的 <strong>DosDevices（用户态设备路径）目录</strong>。</p>
<p><code>\??\</code> 通常映射到 <code>\GLOBAL??</code>，用于解析用户模式中的路径名，如：</p>
<ul>
<li><code>\??\C:\Windows\System32</code> → 实际解析为 <code>\Device\HarddiskVolumeX\Windows\System32</code></li>
<li><code>\??\COM1</code> → 实际是 <code>\Device\Serial0</code></li>
</ul>
</blockquote>
<p>其中 <code>Start</code> 类型表示驱动何时启动，不同的值有如下含义：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
<th>示例用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>0</code></td>
<td><strong>BOOT_START</strong> ：引导时加载（Boot Loader 加载）</td>
<td>如磁盘控制器驱动</td>
</tr>
<tr>
<td><code>1</code></td>
<td><strong>SYSTEM_START</strong> ：内核初始化阶段加载</td>
<td>大多数普通内核驱动</td>
</tr>
<tr>
<td><code>2</code></td>
<td><strong>AUTO_START</strong> ：Service Control Manager 启动时加载</td>
<td>系统服务，非 PnP 驱动</td>
</tr>
<tr>
<td><code>3</code></td>
<td><strong>DEMAND_START</strong> ：按需手动启动</td>
<td>测试驱动、虚拟设备</td>
</tr>
<tr>
<td><code>4</code></td>
<td><strong>DISABLED</strong> ：禁用服务</td>
<td>禁用驱动或服务启动</td>
</tr>
</tbody></table>
<p><code>Type</code> 类型表示服务&#x2F;驱动的类别，不同的值有如下含义：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>1</code></td>
<td>内核驱动（<code>SERVICE_KERNEL_DRIVER</code>）</td>
<td><code>.sys</code> 驱动，运行在 Ring 0</td>
</tr>
<tr>
<td><code>2</code></td>
<td>文件系统驱动（<code>SERVICE_FILE_SYSTEM_DRIVER</code>）</td>
<td>NTFS、FAT 等</td>
</tr>
<tr>
<td><code>10</code></td>
<td>Win32 服务（用户模式，<code>SERVICE_WIN32_OWN_PROCESS</code>）</td>
<td>普通服务程序</td>
</tr>
</tbody></table>
<h3 id="驱动加载"><a href="#驱动加载" class="headerlink" title="驱动加载"></a>驱动加载</h3><p>Windows 支持两种主要的内核驱动加载方式：</p>
<ul>
<li>高层推荐方式：通过 <strong>SCM（服务控制管理器）</strong></li>
<li>底层直接方式：通过 <strong>ZwLoadDriver（系统调用）</strong></li>
</ul>
<p>这两种方式都依赖于 <strong>驱动服务名对应的注册表项</strong>。</p>
<ul>
<li>SCM 方式加载不是由本进程完成的（实际由系统进程，如 <code>services.exe</code>），因此在 0 环不容易通过行为定位到进程。</li>
<li>ZwLoadDriver 方式加载过程可控，不容易被系统策略拦截。实际情况下 <code>ZwLoadDriver</code> 方式加载签名异常驱动的成功率高一些。</li>
</ul>
<h4 id="SCM-加载（服务控制管理器）"><a href="#SCM-加载（服务控制管理器）" class="headerlink" title="SCM 加载（服务控制管理器）"></a>SCM 加载（服务控制管理器）</h4><p><strong>SCM 加载</strong>是 Windows 推荐的标准驱动加载方式。驱动作为一种特殊的“服务”被注册（类型为 <code>SERVICE_KERNEL_DRIVER</code>），然后由 <strong>服务控制管理器（SCM）</strong> 调用底层内核服务 <code>NtLoadDriver</code> 加载 <code>.sys</code> 驱动文件。</p>
<h5 id="原理流程"><a href="#原理流程" class="headerlink" title="原理流程"></a>原理流程</h5><p>Windows 把驱动程序视为一种特殊的服务，类型为 <code>SERVICE_KERNEL_DRIVER</code>。通过一套标准 API，开发者可以注册、启动、停止和卸载驱动。每个 API 都与注册表和内核交互紧密关联。</p>
<ul>
<li><p><strong><code>OpenSCManager</code></strong> ：连接到本地或远程计算机上的 SCM（服务控制管理器），并获取一个 SCM 句柄，用于后续服务管理操作。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SC_HANDLE <span class="title function_">OpenSCManager</span><span class="params">(</span></span><br><span class="line"><span class="params">    LPCSTR lpMachineName,     <span class="comment">// 计算机名，NULL 表示本地</span></span></span><br><span class="line"><span class="params">    LPCSTR lpDatabaseName,    <span class="comment">// 数据库名，通常为 NULL 或 &quot;ServicesActive&quot;</span></span></span><br><span class="line"><span class="params">    DWORD  dwDesiredAccess    <span class="comment">// 访问权限（如 SC_MANAGER_ALL_ACCESS）</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong><code>lpMachineName</code></strong> ：目标计算机名称。为 <code>NULL</code> 时表示本地计算机。</li>
<li><strong><code>lpDatabaseName</code></strong> ：服务数据库名称，通常为 <code>NULL</code> 或默认值 <code>&quot;ServicesActive&quot;</code>。</li>
<li><strong><code>dwDesiredAccess</code></strong> ：请求的访问权限。建议使用 <code>SC_MANAGER_ALL_ACCESS</code> 以便执行创建、删除等所有操作。</li>
</ul>
</li>
<li><p><strong><code>CreateService</code></strong> ：在 SCM 中注册一个新服务（或驱动），生成注册表项并配置驱动加载参数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SC_HANDLE <span class="title function_">CreateService</span><span class="params">(</span></span><br><span class="line"><span class="params">    SC_HANDLE hSCManager,           <span class="comment">// 打开的服务控制管理器句柄</span></span></span><br><span class="line"><span class="params">    LPCSTR lpServiceName,           <span class="comment">// 服务逻辑名称（注册表键名）</span></span></span><br><span class="line"><span class="params">    LPCSTR lpDisplayName,           <span class="comment">// 显示名称（服务管理器界面显示）</span></span></span><br><span class="line"><span class="params">    DWORD dwDesiredAccess,          <span class="comment">// 返回句柄的访问权限</span></span></span><br><span class="line"><span class="params">    DWORD dwServiceType,            <span class="comment">// 服务类型（如内核驱动）</span></span></span><br><span class="line"><span class="params">    DWORD dwStartType,              <span class="comment">// 启动类型（如手动、系统、引导）</span></span></span><br><span class="line"><span class="params">    DWORD dwErrorControl,           <span class="comment">// 启动失败时的系统响应方式</span></span></span><br><span class="line"><span class="params">    LPCSTR lpBinaryPathName,        <span class="comment">// 驱动/服务可执行文件路径</span></span></span><br><span class="line"><span class="params">    LPCSTR lpLoadOrderGroup,        <span class="comment">// 所属分组，决定加载顺序</span></span></span><br><span class="line"><span class="params">    LPDWORD lpdwTagId,              <span class="comment">// 输出的标签值（排序用）</span></span></span><br><span class="line"><span class="params">    LPCSTR lpDependencies,          <span class="comment">// 所依赖的服务列表（以双 \0 结尾）</span></span></span><br><span class="line"><span class="params">    LPCSTR lpServiceStartName,      <span class="comment">// 服务启动账户（驱动设为 NULL）</span></span></span><br><span class="line"><span class="params">    LPCSTR lpPassword               <span class="comment">// 启动账户的密码（驱动设为 NULL）</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong><code>hSCManager</code></strong> ：由 <code>OpenSCManager</code> 返回的句柄。</li>
<li><strong><code>lpServiceName</code></strong> ：服务的逻辑名称，对应注册表子项名，必须唯一。</li>
<li><strong><code>lpDisplayName</code></strong> ：显示名称，出现在服务管理器界面中。</li>
<li><strong><code>dwDesiredAccess</code></strong> ：服务句柄的访问权限，推荐 <code>SERVICE_ALL_ACCESS</code>。</li>
<li><strong><code>dwServiceType</code></strong> ：服务类型。驱动应设为 <code>SERVICE_KERNEL_DRIVER</code>（值 <code>0x1</code>）。</li>
<li><strong><code>dwStartType</code></strong> ：启动方式：<ul>
<li><code>SERVICE_BOOT_START</code>（0）→ 引导加载</li>
<li><code>SERVICE_SYSTEM_START</code>（1）→ 内核加载</li>
<li><code>SERVICE_DEMAND_START</code>（3）→ 手动加载</li>
</ul>
</li>
<li><strong><code>dwErrorControl</code></strong> ：启动失败时系统行为：<ul>
<li><code>SERVICE_ERROR_IGNORE</code>（0）→ 忽略错误</li>
<li><code>SERVICE_ERROR_NORMAL</code>（1）→ 记录日志</li>
<li><code>SERVICE_ERROR_SEVERE</code>（2）→ 启动安全模式</li>
</ul>
</li>
<li><strong><code>lpBinaryPathName</code></strong> ：驱动路径（如 <code>&quot;C:\\Drivers\\MyDriver.sys&quot;</code>）。</li>
<li><strong><code>lpLoadOrderGroup</code></strong> ：加载分组（如 <code>Base</code>，影响加载顺序，可为 NULL）。</li>
<li><strong><code>lpdwTagId</code></strong> ：输出值，指定分组内的排序标识（可为 NULL）。</li>
<li><strong><code>lpDependencies</code></strong> ：依赖服务名称，多个用 <code>\0</code> 分隔，以 <code>\0\0</code> 结尾。</li>
<li><strong><code>lpServiceStartName</code></strong> ：服务启动账户，驱动设为 <code>NULL</code> 表示 LocalSystem。</li>
<li><strong><code>lpPassword</code></strong> ：账户密码，驱动设为 <code>NULL</code>。</li>
</ul>
<p>对于我们测试的驱动，<code>CreateService</code> 示例传参如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CreateService(</span><br><span class="line">    hSCManager,                        <span class="comment">// 服务控制管理器句柄（来自 OpenSCManager）</span></span><br><span class="line">    <span class="string">&quot;MyDriver&quot;</span>,                        <span class="comment">// 服务名称（注册表键名，必须唯一）</span></span><br><span class="line">    <span class="string">&quot;My Kernel Driver&quot;</span>,               <span class="comment">// 服务显示名称（可在服务管理器中显示）</span></span><br><span class="line">    SERVICE_ALL_ACCESS,               <span class="comment">// 访问权限（允许所有操作：启动、停止、删除等）</span></span><br><span class="line">    SERVICE_KERNEL_DRIVER,            <span class="comment">// 服务类型：内核模式驱动（对应 .sys 文件）</span></span><br><span class="line">    SERVICE_DEMAND_START,             <span class="comment">// 启动类型：按需启动（需手动调用 StartService）</span></span><br><span class="line">    SERVICE_ERROR_NORMAL,             <span class="comment">// 错误控制：加载失败时记录日志，继续启动系统</span></span><br><span class="line">    <span class="string">&quot;C:\\Drivers\\MyDriver.sys&quot;</span>,      <span class="comment">// 驱动程序路径（必须为绝对路径）</span></span><br><span class="line">    <span class="literal">NULL</span>,                             <span class="comment">// 加载顺序组（不指定）</span></span><br><span class="line">    <span class="literal">NULL</span>,                             <span class="comment">// Tag ID 输出参数（排序标识，不需要时设 NULL）</span></span><br><span class="line">    <span class="literal">NULL</span>,                             <span class="comment">// 依赖服务列表（无依赖）</span></span><br><span class="line">    <span class="literal">NULL</span>,                             <span class="comment">// 启动账户（驱动使用 LocalSystem，设为 NULL）</span></span><br><span class="line">    <span class="literal">NULL</span>                              <span class="comment">// 启动账户密码（同上，设为 NULL）</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong><code>OpenService</code></strong> ：打开已存在的服务（或驱动），获取用于后续控制（启动、停止、删除）的句柄。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SC_HANDLE <span class="title function_">OpenService</span><span class="params">(</span></span><br><span class="line"><span class="params">    SC_HANDLE hSCManager,     <span class="comment">// 来自 OpenSCManager 的 SCM 句柄</span></span></span><br><span class="line"><span class="params">    LPCSTR lpServiceName,     <span class="comment">// 要打开的服务名</span></span></span><br><span class="line"><span class="params">    DWORD dwDesiredAccess     <span class="comment">// 所需权限（如 SERVICE_START | STOP）</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong><code>hSCManager</code></strong> ：由 <code>OpenSCManager</code> 获取的 SCM 句柄。</li>
<li><strong><code>lpServiceName</code></strong> ：服务名称，必须精确匹配已注册服务名。</li>
<li><strong><code>dwDesiredAccess</code></strong> ：访问权限（如 <code>SERVICE_START | SERVICE_STOP | DELETE</code>）。</li>
</ul>
</li>
<li><p><strong><code>StartService</code></strong> ：启动指定服务或驱动。对于驱动，会由 SCM 调用 <code>NtLoadDriver</code>，将 <code>.sys</code> 文件加载到内核。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">StartService</span><span class="params">(</span></span><br><span class="line"><span class="params">    SC_HANDLE hService,           <span class="comment">// 目标服务的句柄</span></span></span><br><span class="line"><span class="params">    DWORD dwNumServiceArgs,       <span class="comment">// 参数个数（驱动设为 0）</span></span></span><br><span class="line"><span class="params">    LPCSTR *lpServiceArgVectors   <span class="comment">// 参数数组（驱动设为 NULL）</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong><code>hService</code></strong> ：来自 <code>CreateService</code> 或 <code>OpenService</code> 的服务句柄。</li>
<li><strong><code>dwNumServiceArgs</code></strong> ：参数个数，驱动无参数则设为 <code>0</code>。</li>
<li><strong><code>lpServiceArgVectors</code></strong> ：参数数组，驱动无参数则设为 <code>NULL</code>。</li>
</ul>
</li>
<li><p><strong><code>ControlService</code></strong> ：向运行中的服务发送控制命令。用于停止驱动（需驱动实现 <code>Unload</code> 函数）。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">ControlService</span><span class="params">(</span></span><br><span class="line"><span class="params">    SC_HANDLE hService,              <span class="comment">// 服务句柄</span></span></span><br><span class="line"><span class="params">    DWORD dwControl,                 <span class="comment">// 控制命令（如 SERVICE_CONTROL_STOP）</span></span></span><br><span class="line"><span class="params">    LPSERVICE_STATUS lpServiceStatus <span class="comment">// 输出当前服务状态</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong><code>hService</code></strong> ：目标服务句柄。</li>
<li><strong><code>dwControl</code></strong> ：控制命令，停止服务时设为 <code>SERVICE_CONTROL_STOP</code>（0x1）。</li>
<li><strong><code>lpServiceStatus</code></strong> ：接收服务状态的结构体指针。</li>
</ul>
</li>
<li><p><strong><code>DeleteService</code></strong> ：删除指定服务或驱动注册信息（从注册表清除），不会立即卸载已加载驱动。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">DeleteService</span><span class="params">(</span></span><br><span class="line"><span class="params">    SC_HANDLE hService   <span class="comment">// 目标服务句柄</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong><code>hService</code></strong> ：目标服务句柄，需具有 <code>DELETE</code> 权限。</li>
</ul>
</li>
<li><p><strong><code>CloseServiceHandle</code></strong> ：关闭服务或 SCM 句柄，释放资源。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CloseServiceHandle</span><span class="params">(</span></span><br><span class="line"><span class="params">    SC_HANDLE hSCObject  <span class="comment">// 可为服务句柄或 SCM 句柄</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong><code>hSCObject</code></strong> ：服务或控制管理器的句柄。</li>
</ul>
</li>
</ul>
<h5 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h5><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 打开服务控制管理器</span></span><br><span class="line">    SC_HANDLE hSCManager = OpenSCManager(<span class="literal">NULL</span>, <span class="literal">NULL</span>, SC_MANAGER_ALL_ACCESS);</span><br><span class="line">    <span class="keyword">if</span> (!hSCManager) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] OpenSCManager failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个内核驱动类型的服务</span></span><br><span class="line">    SC_HANDLE hService = CreateService(</span><br><span class="line">        hSCManager,</span><br><span class="line">        <span class="string">&quot;MyDriver&quot;</span>,                        <span class="comment">// 驱动服务名（逻辑名）</span></span><br><span class="line">        <span class="string">&quot;MyDriver&quot;</span>,                        <span class="comment">// 显示名称</span></span><br><span class="line">        SERVICE_ALL_ACCESS,               <span class="comment">// 权限</span></span><br><span class="line">        SERVICE_KERNEL_DRIVER,            <span class="comment">// 类型：内核驱动</span></span><br><span class="line">        SERVICE_DEMAND_START,             <span class="comment">// 启动方式：手动启动</span></span><br><span class="line">        SERVICE_ERROR_NORMAL,</span><br><span class="line">        <span class="string">&quot;C:\\Drivers\\MyDriver.sys&quot;</span>,      <span class="comment">// 驱动文件路径</span></span><br><span class="line">        <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!hService) &#123;</span><br><span class="line">        <span class="keyword">if</span> (GetLastError() == ERROR_SERVICE_EXISTS) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[*] 服务已存在，尝试打开...\n&quot;</span>);</span><br><span class="line">            hService = OpenService(hSCManager, <span class="string">&quot;MyDriver&quot;</span>, SERVICE_ALL_ACCESS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[-] CreateService failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">            CloseServiceHandle(hSCManager);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动驱动</span></span><br><span class="line">    <span class="keyword">if</span> (!StartService(hService, <span class="number">0</span>, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        DWORD err = GetLastError();</span><br><span class="line">        <span class="keyword">if</span> (err == ERROR_SERVICE_ALREADY_RUNNING) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[*] 驱动已在运行中。\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[-] StartService failed: %lu\n&quot;</span>, err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] 驱动已成功加载。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可选：停止驱动并删除服务</span></span><br><span class="line">    SERVICE_STATUS status;</span><br><span class="line">    ControlService(hService, SERVICE_CONTROL_STOP, &amp;status);</span><br><span class="line">    DeleteService(hService);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭句柄</span></span><br><span class="line">    CloseServiceHandle(hService);</span><br><span class="line">    CloseServiceHandle(hSCManager);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h5><p><strong>SCM（Service Control Manager）方式加载驱动</strong>，除了直接用 WinAPI 外，Windows 提供了标准命令行工具。</p>
<p><code>sc</code> 是 Windows 提供的服务控制命令行工具，全名为 <strong>Service Control</strong>。它支持创建、启动、停止、删除内核驱动服务。</p>
<ul>
<li><strong>创建服务（注册驱动）</strong></li>
</ul>
  <div class="code-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc create MyDriver <span class="built_in">type</span>= kernel binPath= &quot;C:\<span class="built_in">Path</span>\To\MyDriver.sys&quot;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>MyDriver</code>：驱动服务名（服务项名称）</li>
<li><code>type= kernel</code>：表示是内核驱动（不可省略）</li>
<li><code>binPath= ...</code>：驱动文件路径（推荐绝对路径）</li>
</ul>
  
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p><code>type=</code>, <code>binPath=</code> 后必须留空格，语法严格。</p>

    </div>
  </div>

<ul>
<li><p><strong>启动驱动服务（实际加载）</strong></p>
<p>会触发 Service Control Manager 调用 <code>NtLoadDriver</code> 加载 <code>.sys</code> 文件，驱动的 <code>DriverEntry</code> 将被执行。</p>
<div class="code-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc <span class="built_in">start</span> MyDriver</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>停止驱动服务（触发卸载）</strong></p>
<p>要求驱动实现了 <code>DriverUnload</code> 函数，否则会失败。</p>
<div class="code-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc stop MyDriver</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>删除服务（清除注册表项）</strong></p>
<div class="code-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc delete MyDriver</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="ZwLoadDriver（系统调用-注册表）"><a href="#ZwLoadDriver（系统调用-注册表）" class="headerlink" title="ZwLoadDriver（系统调用 + 注册表）"></a>ZwLoadDriver（系统调用 + 注册表）</h4><p>这是更“底层”的方式，绕过 SCM，直接调用内核的 <code>ZwLoadDriver</code> 系统服务加载驱动。常用于调试工具、PoC 框架、测试加载器或绕过方式。</p>
<h5 id="原理流程-1"><a href="#原理流程-1" class="headerlink" title="原理流程"></a>原理流程</h5><ol>
<li><p>首先用户态程序提前创建注册表项（路径一般为）：<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\MyDriver</code></p>
<p>其中必须设置至少两个关键键值：</p>
<ul>
<li><p><code>ImagePath</code>（<code>REG_EXPAND_SZ</code>）：驱动文件路径，如：<code>\??\C:\Path\to\MyDriver.sys</code></p>
</li>
<li><p><code>Type</code>（<code>DWORD</code>）：必须为 <code>1</code>，表示该服务为内核驱动。</p>
</li>
</ul>
</li>
<li><p>构造 NT 路径并调用 <code>ZwLoadDriver</code> 加载驱动，该函数原型如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NTSYSAPI NTSTATUS NTAPI <span class="title function_">ZwLoadDriver</span><span class="params">(</span></span><br><span class="line"><span class="params">    IN PUNICODE_STRING DriverServiceName</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>参数：注册表路径，格式为：<br> <code>\Registry\Machine\System\CurrentControlSet\Services\MyDriver</code></li>
<li>返回值：NTSTATUS 错误码，常见：<ul>
<li><code>STATUS_SUCCESS</code>：成功</li>
<li><code>STATUS_OBJECT_NAME_NOT_FOUND</code>：注册表路径错误</li>
<li><code>STATUS_IMAGE_ALREADY_LOADED</code>：已加载</li>
</ul>
</li>
</ul>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p><code>ZwLoadDriver</code> 和 <code>NtLoadDriver</code> 实际上是同一个函数的两个符号。</p>
<p>在 <strong>Windows 内核设计中，<code>NtXxx</code> 和 <code>ZwXxx</code> 实际上代表的是</strong>同一个系统服务接口（Syscall）函数，但它们存在 <strong>调用上下文（user mode vs kernel mode）下的行为差异</strong> 和 <strong>API 访问路径差异</strong>，而 <strong>在用户态时，它们几乎是完全等价的入口符号</strong>。</p>

    </div>
  </div>
</li>
<li><p>与驱动加载类似，卸载驱动的时候需要调用 <code>ZwUnloadDriver</code>，并传入同样格式的注册表路径。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>驱动必须自己实现 <code>DriverUnload</code> 回调，系统才会调用卸载。</p>

    </div>
  </div>

<p> <code>ZwUnloadDriver</code> 函数原型如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NTSYSAPI NTSTATUS NTAPI <span class="title function_">ZwUnloadDriver</span><span class="params">(</span></span><br><span class="line"><span class="params">    IN PUNICODE_STRING DriverServiceName</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>参数同上，指定已加载驱动的注册表路径；</li>
<li>若驱动未实现 <code>DriverUnload</code>，调用将失败（一般是 <code>STATUS_INVALID_DEVICE_REQUEST</code>）。</li>
</ul>
</li>
<li><p>清理注册表项。**<code>ZwUnloadDriver</code> 不会自动删除注册表项**，即驱动从内核卸载后，注册表中的服务项仍然存在，必须你手动清理。</p>
</li>
</ol>
<h5 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h5><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winternl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ntdll.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    NTSYSAPI NTSTATUS NTAPI <span class="title function_">ZwLoadDriver</span><span class="params">(IN PUNICODE_STRING DriverServiceName)</span>;</span><br><span class="line">    NTSYSAPI NTSTATUS NTAPI <span class="title function_">ZwUnloadDriver</span><span class="params">(IN PUNICODE_STRING DriverServiceName)</span>;</span><br><span class="line">    NTSYSAPI VOID NTAPI <span class="title function_">RtlInitUnicodeString</span><span class="params">(PUNICODE_STRING DestinationString, PCWSTR SourceString)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动提取驱动服务名（不含扩展名）</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">wstring</span> <span class="title function_">ExtractDriverName</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; fullPath)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> slash = fullPath.find_last_of(<span class="string">L&quot;\\/&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> dot = fullPath.find_last_of(<span class="string">L&#x27;.&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slash == <span class="built_in">std</span>::<span class="built_in">wstring</span>::npos) slash = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (dot == <span class="built_in">std</span>::<span class="built_in">wstring</span>::npos || dot &lt;= slash) dot = fullPath.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fullPath.substr(slash + <span class="number">1</span>, dot - slash - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造 \Registry\Machine\System\CurrentControlSet\Services\DriverName</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">wstring</span> <span class="title function_">BuildRegPath</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; driverName)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">L&quot;\\Registry\\Machine\\System\\CurrentControlSet\\Services\\&quot;</span> + driverName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册表项创建</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">CreateDriverServiceRegistry</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; driverName, <span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; driverPath)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">wstring</span> keyPath = <span class="string">L&quot;SYSTEM\\CurrentControlSet\\Services\\&quot;</span> + driverName;</span><br><span class="line">    HKEY hKey;</span><br><span class="line">    <span class="keyword">if</span> (RegCreateKeyW(HKEY_LOCAL_MACHINE, keyPath.c_str(), &amp;hKey) != ERROR_SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">std</span>::wcerr &lt;&lt; <span class="string">L&quot;[!] Failed to create registry key.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DWORD type = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">wstring</span> imagePath = <span class="string">L&quot;\\??\\&quot;</span> + driverPath;</span><br><span class="line">    <span class="keyword">if</span> (RegSetValueExW(hKey, <span class="string">L&quot;Type&quot;</span>, <span class="number">0</span>, REG_DWORD, reinterpret_cast&lt;<span class="type">const</span> BYTE*&gt;(&amp;type), <span class="keyword">sizeof</span>(type)) != ERROR_SUCCESS ||</span><br><span class="line">        RegSetValueExW(hKey, <span class="string">L&quot;ImagePath&quot;</span>, <span class="number">0</span>, REG_EXPAND_SZ,</span><br><span class="line">                       reinterpret_cast&lt;<span class="type">const</span> BYTE*&gt;(imagePath.c_str()),</span><br><span class="line">                       static_cast&lt;DWORD&gt;((imagePath.size() + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">wchar_t</span>))) != ERROR_SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">std</span>::wcerr &lt;&lt; <span class="string">L&quot;[!] Failed to set registry values.\n&quot;</span>;</span><br><span class="line">        RegCloseKey(hKey);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RegCloseKey(hKey);</span><br><span class="line">    <span class="built_in">std</span>::wcout &lt;&lt; <span class="string">L&quot;[+] Registry entry created at: &quot;</span> &lt;&lt; keyPath &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除服务对应注册表项</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeleteDriverServiceRegistry</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; driverName)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">wstring</span> keyPath = <span class="string">L&quot;SYSTEM\\CurrentControlSet\\Services\\&quot;</span> + driverName;</span><br><span class="line">    LONG result = RegDeleteKeyW(HKEY_LOCAL_MACHINE, keyPath.c_str());</span><br><span class="line">    <span class="keyword">if</span> (result == ERROR_SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">std</span>::wcout &lt;&lt; <span class="string">L&quot;[+] Registry key deleted: &quot;</span> &lt;&lt; keyPath &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::wcerr &lt;&lt; <span class="string">L&quot;[!] Failed to delete registry key. Error: &quot;</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">LoadDriver</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; driverName)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">wstring</span> regPath = BuildRegPath(driverName);</span><br><span class="line">    UNICODE_STRING ustr;</span><br><span class="line">    RtlInitUnicodeString(&amp;ustr, regPath.c_str());</span><br><span class="line"></span><br><span class="line">    NTSTATUS status = ZwLoadDriver(&amp;ustr);</span><br><span class="line">    <span class="built_in">std</span>::wcout &lt;&lt; <span class="string">L&quot;[+] ZwLoadDriver status: 0x&quot;</span> &lt;&lt; <span class="built_in">std</span>::hex &lt;&lt; status &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status == STATUS_SUCCESS || status == STATUS_IMAGE_ALREADY_LOADED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">UnloadDriver</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; driverName)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">wstring</span> regPath = BuildRegPath(driverName);</span><br><span class="line">    UNICODE_STRING ustr;</span><br><span class="line">    RtlInitUnicodeString(&amp;ustr, regPath.c_str());</span><br><span class="line"></span><br><span class="line">    NTSTATUS status = ZwUnloadDriver(&amp;ustr);</span><br><span class="line">    <span class="built_in">std</span>::wcout &lt;&lt; <span class="string">L&quot;[+] ZwUnloadDriver status: 0x&quot;</span> &lt;&lt; <span class="built_in">std</span>::hex &lt;&lt; status &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status == STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">wmain</span><span class="params">(<span class="type">int</span> argc, <span class="type">wchar_t</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::wcerr &lt;&lt; <span class="string">L&quot;Usage: DriverLoader.exe &lt;PathToDriver.sys&gt;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">wstring</span> driverPath = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">wstring</span> driverName = ExtractDriverName(driverPath);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::wcout &lt;&lt; <span class="string">L&quot;[+] Driver path: &quot;</span> &lt;&lt; driverPath &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::wcout &lt;&lt; <span class="string">L&quot;[+] Driver name: &quot;</span> &lt;&lt; driverName &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!CreateDriverServiceRegistry(driverName, driverPath)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!LoadDriver(driverName)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::wcerr &lt;&lt; <span class="string">L&quot;[!] Driver load failed.\n&quot;</span>;</span><br><span class="line">        DeleteDriverServiceRegistry(driverName);  <span class="comment">// 清理失败也清注册表</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::wcout &lt;&lt; <span class="string">L&quot;[+] Driver loaded successfully.\nPress Enter to unload...\n&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::wcin.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!UnloadDriver(driverName)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::wcerr &lt;&lt; <span class="string">L&quot;[!] Driver unload failed. Ensure DriverUnload is implemented.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DeleteDriverServiceRegistry(driverName);  <span class="comment">// 卸载成功后清理注册表</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::wcout &lt;&lt; <span class="string">L&quot;[+] Driver unloaded and registry cleaned up.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="驱动开发基础"><a href="#驱动开发基础" class="headerlink" title="驱动开发基础"></a>驱动开发基础</h2><h3 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h3><p>通常一个最基本的 WDM 驱动代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span>  <span class="comment">// 内核开发必要头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动卸载回调函数</span></span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(IN PDRIVER_OBJECT DriverObject)</span></span><br><span class="line">&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(DriverObject);</span><br><span class="line">    DbgPrint(<span class="string">&quot;Driver unloaded.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动入口函数（系统加载驱动时调用）</span></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)</span></span><br><span class="line">&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(RegistryPath);</span><br><span class="line">    DbgPrint(<span class="string">&quot;Driver loaded.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册卸载回调函数</span></span><br><span class="line">    DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>DriverEntry</code> 是 Windows 驱动程序的<strong>主入口函数（Entry Point）</strong>，等同于用户程序中的 <code>main()</code> 函数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(</span></span><br><span class="line"><span class="params">  IN PDRIVER_OBJECT DriverObject,    <span class="comment">// [输入] 驱动对象，由系统分配</span></span></span><br><span class="line"><span class="params">  IN PUNICODE_STRING RegistryPath    <span class="comment">// [输入] 驱动注册表路径</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<p>当<strong>驱动加载</strong>时，系统会调用此函数来完成驱动的初始化过程。</p>
<ul>
<li><p><strong><code>PDRIVER_OBJECT DriverObject</code></strong> ：内核为每个加载的驱动创建一个 <code>DRIVER_OBJECT</code> 结构，此参数就是它的指针。你需要通过它来注册 IRP 分发表、卸载函数、创建设备等。</p>
<p>  <code>DRIVER_OBJECT</code> 是 Windows 内核用来描述一个驱动程序核心信息的数据结构，驱动开发时我们通过它设置入口函数、分发表、卸载逻辑，是驱动生命周期管理的中心。</p>
  <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0xA8 bytes</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">DRIVER_OBJECT</span> &#123;</span></span><br><span class="line">    CSHORT Type;                             <span class="comment">// 内核对象类型 (固定 DRIVER_OBJECT(0x04))</span></span><br><span class="line">    CSHORT Size;                             <span class="comment">// 结构体大小 (0xA8 字节)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_OBJECT</span>* <span class="title">DeviceObject</span>;</span>     <span class="comment">// 📌设备对象链表头</span></span><br><span class="line">    ULONG Flags;                             <span class="comment">// 驱动状态标志</span></span><br><span class="line">    PVOID DriverStart;                       <span class="comment">// 📌驱动映像起始地址</span></span><br><span class="line">    ULONG DriverSize;                        <span class="comment">// 📌驱动映像总大小</span></span><br><span class="line">    PVOID DriverSection;                     <span class="comment">// 加载模块节点 (挂载到 PsLoadedModuleList)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DRIVER_EXTENSION</span>* <span class="title">DriverExtension</span>;</span>  <span class="comment">// 扩展区域 (含 AddDevice)</span></span><br><span class="line">    UNICODE_STRING DriverName;               <span class="comment">// 📌驱动名 (\Driver\XXX)</span></span><br><span class="line">    UNICODE_STRING* HardwareDatabase;        <span class="comment">// 硬件数据库路径 (历史用途)</span></span><br><span class="line">    PFAST_IO_DISPATCH FastIoDispatch;        <span class="comment">// 快速 I/O 分发表 (文件系统驱动用)</span></span><br><span class="line">    PDRIVER_INITIALIZE DriverInit;           <span class="comment">// 📌初始化入口 (内部使用)</span></span><br><span class="line">    PDRIVER_STARTIO DriverStartIo;           <span class="comment">// 串行化 I/O 支持 (极少用)</span></span><br><span class="line">    PDRIVER_UNLOAD DriverUnload;             <span class="comment">// 📌驱动卸载函数指针</span></span><br><span class="line">    PDRIVER_DISPATCH MajorFunction[<span class="number">28</span>];      <span class="comment">// 📌IRP 主功能分发表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>PUNICODE_STRING RegistryPath</code></strong> ：指向一个 Unicode 字符串，表示驱动在注册表中的键路径，如 <code>\Registry\Machine\System\CurrentControlSet\Services\MyDriver</code> 。</p>
</li>
</ul>
<p>在 <code>DriverEntry</code> 中，我们主要做一些初始化的操作，比如创建设备对象，初始化全局变量，注册 IRP 分发表等等。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <ul>
<li><p>在 <code>DriverEntry</code> 中要的是<strong>设置驱动卸载函数</strong> <code>DriverObject-&gt;DriverUnload</code>，<strong>如果这一步没有做则驱动无法卸载</strong>。</p>
</li>
<li><p><strong>只有全部成功后才返回 <code>STATUS_SUCCESS</code>，否则系统自动撤销加载</strong>。因此我们不需要担心在 <code>DriverEntry</code> 中由于出错提前返回没有设置设置驱动卸载函数而导致驱动无法卸载，因为驱动根本就没有加载成功。</p>
</li>
</ul>

    </div>
  </div>

<h3 id="功能技巧"><a href="#功能技巧" class="headerlink" title="功能技巧"></a>功能技巧</h3><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>几乎所有内核 API 和驱动入口函数都使用 <code>NTSTATUS</code> 类型作为返回值。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> LONG NTSTATUS;</span><br></pre></td></tr></table></figure></div>

<p>同时 WDK 中提供了几个宏用根据返回值判断 api 调用结果。</p>
<table>
<thead>
<tr>
<th>宏函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>NT_SUCCESS(Status)</code></td>
<td>判断是否成功（高位为 0）</td>
</tr>
<tr>
<td><code>NT_ERROR(Status)</code></td>
<td>判断是否是错误（高位为 1）</td>
</tr>
<tr>
<td><code>NT_WARNING(Status)</code></td>
<td>判断是否是警告</td>
</tr>
</tbody></table>
<p>因此一个标准的 API 调用的返回值检测应该是下面这种写法：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">MyFunction</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    NTSTATUS status = DoSomething();</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(status)) &#123;</span><br><span class="line">        <span class="keyword">return</span> status;  <span class="comment">// 向上传播错误</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继续处理...</span></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="日志输出"><a href="#日志输出" class="headerlink" title="日志输出"></a>日志输出</h4><p>内核调试输出需要使用专门的 api，并且输出内容走的是 <code>DbgPrint Buffer</code>，通常只有连接 WinDbg &#x2F; KD 等调试器时可实时显示；无内核调试连接时，有些版本仍可借助 DebugView（SysInternals 工具）捕获部分内核日志。</p>
<ul>
<li><p><code>DbgPrint</code>：最基本的内核调试输出函数，用法与 <code>printf</code> 类似，默认输出优先级较低，相当于 <code>DbgPrintEx(DPFLTR_DEFAULT_ID, DPFLTR_INFO_LEVEL, ...)</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ULONG <span class="title function_">DbgPrint</span><span class="params">(</span></span><br><span class="line"><span class="params">  PCSTR Format,  <span class="comment">// 格式化字符串，类似 printf()</span></span></span><br><span class="line"><span class="params">  ...            <span class="comment">// 可变参数</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>DbgPrintEx</code>：<code>DbgPrint</code> 的增强版，允许指定组件类别和日志等级，便于在复杂项目中分类控制输出。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ULONG <span class="title function_">DbgPrintEx</span><span class="params">(</span></span><br><span class="line"><span class="params">  ULONG ComponentId,  <span class="comment">// 模块分类 (WDF 框架建议填写 DPFLTR_DRIVER_FRAMEWORK_ID)</span></span></span><br><span class="line"><span class="params">  ULONG Level,        <span class="comment">// 日志级别 (DPFLTR_XXX_LEVEL)</span></span></span><br><span class="line"><span class="params">  PCSTR Format,       <span class="comment">// 格式化字符串</span></span></span><br><span class="line"><span class="params">  ...                 <span class="comment">// 可变参数</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<p>这里常见 <code>ComponentId</code> 值有：</p>
<ul>
<li><code>DPFLTR_DEFAULT_ID</code>：默认组件</li>
<li><code>DPFLTR_IO_ID</code>：I&#x2F;O 子系统</li>
<li><code>DPFLTR_PNP_ID</code>：PnP 子系统</li>
<li><code>DPFLTR_DRIVER_FRAMEWORK_ID</code>：WDF 框架日志</li>
</ul>
<p>常见的 <code>Level</code> 值有：</p>
<ul>
<li><code>DPFLTR_INFO_LEVEL</code>：普通信息</li>
<li><code>DPFLTR_WARNING_LEVEL</code>：警告</li>
<li><code>DPFLTR_ERROR_LEVEL</code>：错误</li>
<li><code>DPFLTR_MASK </code>：所有级别</li>
</ul>
</li>
<li><p><code>KdPrintEx</code>：实际上是对 <code>DbgPrintEx</code> 的宏封装，编写格式<strong>需使用两层括号</strong>，优势在于统一兼容内核版本控制，WDK 推荐使用，另外可以在 Release 版本自动去除日志输出。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KdPrintEx((DPFLTR_DEFAULT_ID, DPFLTR_INFO_LEVEL, <span class="string">&quot;MyDriver running.\n&quot;</span>));</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h4><p><code>DbgBreakPoint()</code> 是 <strong>Windows 内核提供的标准调试断点函数</strong>，专门用于<strong>驱动或内核模块中设置断点</strong>。它的作用是：当内核代码执行到 <code>DbgBreakPoint()</code> 处时，如果系统当前处于调试状态（例如 WinDbg 已附加），将触发调试器断点中断。</p>
<p><code>DbgBreakPoint()</code> 是由内核导出的函数，声明如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOID NTAPI <span class="title function_">DbgBreakPoint</span><span class="params">(VOID)</span>;</span><br></pre></td></tr></table></figure></div>



<p><code>kdBreakPoint</code></p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><h5 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h5><p>在 Windows 开发中有多种字符串类型，但是在内核驱动开发中为了安全起见，有额外引入了 <code>UNICODE_STRING</code> 这一新的字符串类型。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>UNICODE_STRING</code></td>
<td>UTF-16 编码，结构体包装</td>
<td>内核中最常见的字符串类型，用于路径、设备名、对象名等</td>
</tr>
<tr>
<td><code>WCHAR[]</code></td>
<td>C 风格宽字符串（null结尾）</td>
<td>常用于初始化 UNICODE_STRING</td>
</tr>
<tr>
<td><code>CHAR[]</code></td>
<td>C 风格窄字符串（null结尾）</td>
<td>常用于初始化 ANSI_STRING</td>
</tr>
<tr>
<td><code>PWSTR</code> &#x2F; <code>PCHAR</code></td>
<td>指向上述数组的指针</td>
<td>宽&#x2F;窄字符数组地址，传参常用</td>
</tr>
</tbody></table>
<h5 id="UNICODE-STRING"><a href="#UNICODE-STRING" class="headerlink" title="UNICODE_STRING"></a>UNICODE_STRING</h5><p><code>UNICODE_STRING</code> 字符串类型本质上就是将宽字符串利用一个结构体进行了一次封装。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> &#123;</span></span><br><span class="line">  USHORT Length;         <span class="comment">// 单位：字节，不包括 NULL</span></span><br><span class="line">  USHORT MaximumLength;  <span class="comment">// 最大长度（字节）</span></span><br><span class="line">  PWSTR  Buffer;         <span class="comment">// 指向宽字符串（WCHAR[]）</span></span><br><span class="line">&#125; UNICODE_STRING;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <ul>
<li><p><code>Length</code> 单位是字节，不是字符数；</p>
</li>
<li><p><code>Buffer</code> 不强制 <code>null</code> 结尾；</p>
</li>
</ul>

    </div>
  </div>

<p><code>UNICODE_STRING</code> 可以通过 <code>RtlInitUnicodeString</code> 函数和 <code>RTL_CONSTANT_STRING</code> 宏两种方式进行初始化。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>这两种初始化方法都不会拷贝字符串内容，而只设置结构体，指针仍指向原始常量字符串。</p>

    </div>
  </div>

<ul>
<li><p><code>RtlInitUnicodeString</code> 函数原型如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VOID <span class="title function_">RtlInitUnicodeString</span><span class="params">(</span></span><br><span class="line"><span class="params">  PUNICODE_STRING DestinationString,</span></span><br><span class="line"><span class="params">  PCWSTR          SourceString</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>该函数会设置结构体的 <code>Length</code>, <code>MaximumLength</code>, <code>Buffer</code> 字段。</li>
<li><code>SourceString</code> 必须是 null 结尾的常量或合法缓冲区</li>
</ul>
<p>示例代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UNICODE_STRING uStr;</span><br><span class="line">RtlInitUnicodeString(&amp;uStr, <span class="string">L&quot;\\Device\\MyDriver&quot;</span>);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>RTL_CONSTANT_STRING</code></p>
<p><code>RTL_CONSTANT_STRING</code> 用于编译期静态构造一个 <code>UNICODE_STRING</code>，该宏的定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RTL_CONSTANT_STRING(s) &#123; sizeof(s) - sizeof((s)[0]), sizeof(s), s &#125;</span></span><br></pre></td></tr></table></figure></div>

<p>示例代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNICODE_STRING path = RTL_CONSTANT_STRING(<span class="string">L&quot;\\Device\\MyDriver&quot;</span>);</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p><strong><code>RTL_CONSTANT_STRING</code> 不能用于变量字符串，只能用于编译期可见的字符串常量</strong>（即 <code>L&quot;...&quot;</code> 形式的字面量）。如果你错误地用它去初始化一个运行时变量，会导致：</p>
<ul>
<li><p><strong>结构体字段内容不正确</strong>（长度计算可能错误）</p>
</li>
<li><p><strong>潜在的内存越界访问</strong></p>
</li>
<li><p><strong>编译器不报错，但运行时行为未定义</strong></p>
</li>
</ul>

    </div>
  </div></li>
</ul>
<h5 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换</h5><p>在实际开发中，经常会遇到<strong>将用户传入的 ANSI 字符串转换为内核 API 可用格式</strong>这种需求，这就需要我们将 <code>char *</code> 字符串转换为 <code>UNICODE_STRING</code> 类型，具体步骤如下：</p>
<ol>
<li><p>首先我们需要利用 <code>RtlInitAnsiString</code> 函数将 <code>char *</code> 字符串转换为 <code>ANSI_STRING</code> 类型：</p>
 <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* ansi = <span class="string">&quot;MyDevice\\Test&quot;</span>;</span><br><span class="line">ANSI_STRING ansiStr;</span><br><span class="line"></span><br><span class="line">RtlInitAnsiString(&amp;ansiStr, ansi);</span><br></pre></td></tr></table></figure></div>

 
  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>在有些教程中这一步会使用 <code>RtlInitString</code> 函数将将 <code>char *</code> 字符串转换为 <code>STRING</code> 类型，实际上这里的 <code>STRING</code> 类型实际上就是 <code>ANSI_STRING</code> 的旧别名，结构相同。</p>

    </div>
  </div>
</li>
<li><p>使用 <code>RtlAnsiStringToUnicodeString</code> 函数将 <code>ANSI_STRING</code> 字符串转换为 <code>UNICODE_STRING</code> 字符串。这里 <code>RtlAnsiStringToUnicodeString</code> 函数原型如下：</p>
 <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">RtlAnsiStringToUnicodeString</span><span class="params">(</span></span><br><span class="line"><span class="params">  PUNICODE_STRING DestinationString,</span></span><br><span class="line"><span class="params">  PCANSI_STRING SourceString,</span></span><br><span class="line"><span class="params">  BOOLEAN AllocateDestinationString</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>DestinationString</code>：输出的 Unicode 结构体</li>
<li><code>SourceString</code>：输入的 ANSI 结构体</li>
<li><code>AllocateDestinationString</code>：如果为 <code>TRUE</code>，系统会分配 <code>DestinationString-&gt;Buffer</code>；否则<strong>你必须事先分配好 <code>ANSI_STRING.Buffer</code></strong> 并设置 <code>MaximumLength</code>，否则可能崩溃或数据丢失。</li>
</ul>
<p> 这里为了方便封装，我们采用 <code>AllocateDestinationString</code> 为 <code>TRUE</code> 的写法。对于这样产生的 <code>UNICODE_STRING</code> 字符串，使用完毕时候我们需要调用 <code>RtlFreeUnicodeString</code> 函数将其释放，这里释放的是 <code>ANSI_STRING.Buffer</code>。</p>
</li>
</ol>
<p>在实际开发中，我们一般习惯将上述步骤封装成一个函数：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">ConvertAnsiToUnicode</span><span class="params">(_In_ <span class="type">const</span> <span class="type">char</span>* input, _Out_ PUNICODE_STRING uStr)</span> &#123;</span><br><span class="line">    ANSI_STRING aStr;</span><br><span class="line">    RtlInitAnsiString(&amp;aStr, input);</span><br><span class="line">    <span class="keyword">return</span> RtlAnsiStringToUnicodeString(uStr, &amp;aStr, TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h5><ul>
<li><p><code>RtlStringCbPrintfA/W</code>：内核安全字符串格式化函数</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">RtlStringCbPrintfA</span><span class="params">(</span></span><br><span class="line"><span class="params">  _Out_  CHAR *pszDest,</span></span><br><span class="line"><span class="params">  _In_   <span class="type">size_t</span> cbDest,</span></span><br><span class="line"><span class="params">  _In_   <span class="type">const</span> CHAR *pszFormat,</span></span><br><span class="line"><span class="params">  ...</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">RtlStringCbPrintfW</span><span class="params">(</span></span><br><span class="line"><span class="params">  _Out_  WCHAR *pszDest,</span></span><br><span class="line"><span class="params">  _In_   <span class="type">size_t</span> cbDest,</span></span><br><span class="line"><span class="params">  _In_   <span class="type">const</span> WCHAR *pszFormat,</span></span><br><span class="line"><span class="params">  ...</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>pszDest</code>：输出目标缓冲区</li>
<li><code>cbDest</code>：缓冲区总字节数（注意单位：字节，不是字符数）</li>
<li><code>pszFormat</code>：格式化字符串，类似 <code>printf</code> 格式</li>
</ul>
</li>
<li><p><code>RtlCompareUnicodeString</code>：<code>UNICODE_STRING</code> 安全比较</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LONG <span class="title function_">RtlCompareUnicodeString</span><span class="params">(</span></span><br><span class="line"><span class="params">  _In_  <span class="type">const</span> UNICODE_STRING *String1,</span></span><br><span class="line"><span class="params">  _In_  <span class="type">const</span> UNICODE_STRING *String2,</span></span><br><span class="line"><span class="params">  _In_  BOOLEAN CaseInSensitive</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>CaseInSensitive</code>：是否大小写无关（<code>TRUE</code> 表示忽略大小写）</li>
<li>返回值：返回逻辑类似 C 标准库 <code>strcmp</code>。<ul>
<li><code>0</code>：相等</li>
<li><code>&lt;0</code>：<code>String1</code> 小于 <code>String2</code></li>
<li><code>&gt;0</code>：<code>String1</code> 大于 <code>String2</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="双向链表（LIST-ENTRY）"><a href="#双向链表（LIST-ENTRY）" class="headerlink" title="双向链表（LIST_ENTRY）"></a>双向链表（LIST_ENTRY）</h4><p>在 Windows 中有一个专门描述链表节点的结构 <code>LIST_ENTRY</code>，该结构定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> *<span class="title">Flink</span>;</span>  <span class="comment">// Forward Link (前向指针)</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> *<span class="title">Blink</span>;</span>  <span class="comment">// Backward Link (后向指针)</span></span><br><span class="line">&#125; LIST_ENTRY, *PLIST_ENTRY;</span><br></pre></td></tr></table></figure></div>

<p>在 Windows 的设计思想中，双向链表有两种成员组成：</p>
<ul>
<li><p><code>ListHead</code>：即链表头，通常类型为 <code>LIST_ENTRY</code> 结构体，有时会作为一个成员放到另一个结构体中，但是作为“链表头”本身仍是 <code>LIST_ENTRY</code> 类型。链表头自己<strong>不存储任何数据</strong>，只是链表控制块，但<strong>会被串到双向链表中</strong>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LIST_ENTRY MyList;</span><br><span class="line">InitializeListHead(&amp;MyList);</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>Windows 的 <code>LIST_ENTRY</code> 初始状态必须是：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ListHead-&gt;Flink = ListHead;</span><br><span class="line">ListHead-&gt;Blink = ListHead;</span><br></pre></td></tr></table></figure></div>

<p>任何链表必须先初始化，否则后续操作容易蓝屏。Windows有一个专门用于初始化 <code>ListEntry</code> 的函数 <code>InitializeListHead</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOID <span class="title function_">InitializeListHead</span><span class="params">(PLIST_ENTRY ListHead)</span>;</span><br></pre></td></tr></table></figure></div>

    </div>
  </div>
</li>
<li><p><code>Entry</code>：用来将节点链入双向链表中的一个结构体成员，类型同样为 <code>LIST_ENTRY</code>。例如下面这个结构体中的 <code>List</code> 就是一个 <code>Entry</code>，我们可以通过从链表头遍历双向链表找到所有链表中的 <code>MY_NODE</code> 结构体。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MY_NODE</span> &#123;</span></span><br><span class="line">    ULONG ID;</span><br><span class="line">    LIST_ENTRY List;</span><br><span class="line">&#125; MY_NODE;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>我们通过双向链表遍历找到的结构体地址实际上是 <code>List</code> 成员的地址，要想获取到结构体地址还需要借助 <code>CONTAINING_RECORD</code> 宏。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONTAINING_RECORD(address, type, field) \</span></span><br><span class="line"><span class="meta">    ((type *)((PCHAR)(address) - (ULONG_PTR)(&amp;((type *)0)-&gt;field)))</span></span><br></pre></td></tr></table></figure></div>

<p>例如：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PLIST_ENTRY pEntry = RemoveHeadList(&amp;MyList);</span><br><span class="line">PMY_NODE pNode = CONTAINING_RECORD(pEntry, MY_NODE, List);</span><br></pre></td></tr></table></figure></div>

    </div>
  </div></li>
</ul>
<p>针对双向链表，Windows 提供了众多 API 用于操作双向链表中的成员：</p>
<ul>
<li><p><code>InsertHeadList()</code>：将 <code>Entry</code> 插入到链表头部（头节点后，<code>ListHead-&gt;Flink</code> 方向）</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOLEAN <span class="title function_">InsertHeadList</span><span class="params">(</span></span><br><span class="line"><span class="params">  PLIST_ENTRY ListHead,</span></span><br><span class="line"><span class="params">  PLIST_ENTRY Entry</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>InsertTailList()</code>：插入到链表尾部（头节点前，<code>ListHead-&gt;Blink</code> 方向）</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOLEAN <span class="title function_">InsertTailList</span><span class="params">(</span></span><br><span class="line"><span class="params">  PLIST_ENTRY ListHead,</span></span><br><span class="line"><span class="params">  PLIST_ENTRY Entry</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>RemoveEntryList()</code>：从链表中删除指定节点。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BOOLEAN <span class="title function_">RemoveEntryList</span><span class="params">(</span></span><br><span class="line"><span class="params">  PLIST_ENTRY Entry</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>RemoveHeadList()</code>&#x2F;<code>RemoveTailList()</code>：移除链表头部第一个（最后一个）元素。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PLIST_ENTRY <span class="title function_">RemoveHeadList</span><span class="params">(PLIST_ENTRY ListHead)</span>;</span><br><span class="line">PLIST_ENTRY <span class="title function_">RemoveTailList</span><span class="params">(PLIST_ENTRY ListHead)</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>IsListEmpty()</code>：检查链表是否为空。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOLEAN <span class="title function_">IsListEmpty</span><span class="params">(PLIST_ENTRY ListHead)</span>;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="通用平衡树框架（RTL-GENERIC-TABLE）"><a href="#通用平衡树框架（RTL-GENERIC-TABLE）" class="headerlink" title="通用平衡树框架（RTL_GENERIC_TABLE）"></a>通用平衡树框架（RTL_GENERIC_TABLE）</h4><p><code>RTL_GENERIC_TABLE</code> 提供通用平衡树框架（Windows 早期是 Splay；Win7+ 全部切换为 AVL）,支持 <strong>按键快速查找&#x2F;插入&#x2F;删除</strong>。</p>
<p><code>RTL_GENERIC_TABLE</code> 的初始化函数 <code>RtlInitializeGenericTable</code> 定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">RtlInitializeGenericTable</span><span class="params">(</span></span><br><span class="line"><span class="params">    PRTL_GENERIC_TABLE Table,         <span class="comment">// [OUT] 指向 RTL_GENERIC_TABLE 结构体，初始化后返回表控制块</span></span></span><br><span class="line"><span class="params">    PRTL_GENERIC_COMPARE_ROUTINE CompareRoutine,  <span class="comment">// [IN] 比较函数指针：用于比较 Key 大小（必填）</span></span></span><br><span class="line"><span class="params">    PRTL_GENERIC_ALLOCATE_ROUTINE AllocateRoutine, <span class="comment">// [IN] 分配函数指针：用于为新节点分配内存（必填）</span></span></span><br><span class="line"><span class="params">    PRTL_GENERIC_FREE_ROUTINE FreeRoutine,        <span class="comment">// [IN] 释放函数指针：用于释放节点内存（必填）</span></span></span><br><span class="line"><span class="params">    PVOID TableContext                 <span class="comment">// [IN] 上下文参数（可选）：用户自定义传入，在回调函数中使用</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><code>Table</code>：用于保存初始化后的通用表结构体。你需要先定义好 <code>RTL_GENERIC_TABLE</code> 结构体，把地址传进来，内核将填充其中的指针和配置字段。</p>
</li>
<li><p><code>CompareRoutine</code>：<strong>比较函数指针</strong>，内核在插入&#x2F;查找&#x2F;删除时调用此函数以判定 Key 大小顺序。你需要实现此函数来定义排序规则，返回值为 <code>GenericLessThan</code> &#x2F; <code>GenericGreaterThan</code> &#x2F; <code>GenericEqual</code>。回调函数声明如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">RTL_GENERIC_COMPARE_RESULTS</span> <span class="params">(*PRTL_GENERIC_COMPARE_ROUTINE)</span><span class="params">(</span></span><br><span class="line"><span class="params">  PRTL_GENERIC_TABLE Table,</span></span><br><span class="line"><span class="params">  PVOID FirstStruct,</span></span><br><span class="line"><span class="params">  PVOID SecondStruct</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>AllocateRoutine</code>：<strong>分配函数指针</strong>，在插入新节点时，内核通过此函数为节点分配内存。通常传入封装好的 <code>ExAllocatePoolWithTag()</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">PVOID</span> <span class="params">(*PRTL_GENERIC_ALLOCATE_ROUTINE)</span><span class="params">(</span></span><br><span class="line"><span class="params">  PRTL_GENERIC_TABLE Table,</span></span><br><span class="line"><span class="params">  CLONG ByteSize</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>FreeRoutine</code>：<strong>释放函数指针</strong>，当删除节点时内核通过此函数释放节点内存。通常封装调用 <code>ExFreePool()</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">VOID</span> <span class="params">(*PRTL_GENERIC_FREE_ROUTINE)</span><span class="params">(</span></span><br><span class="line"><span class="params">  PRTL_GENERIC_TABLE Table,</span></span><br><span class="line"><span class="params">  PVOID Buffer</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>TableContext</code>：<strong>上下文指针</strong>，供你在比较函数 &#x2F; 分配函数内部做额外业务逻辑用（可选，可以传 <code>NULL</code>）。例如存放配置信息、同步锁、日志上下文等。</p>
</li>
</ul>
<p>另外 <code>RTL_GENERIC_TABLE</code> 提供了一系列的成员操作函数：</p>
<table>
<thead>
<tr>
<th>API</th>
<th>功能</th>
<th>复杂度</th>
</tr>
</thead>
<tbody><tr>
<td><code>RtlInsertElementGenericTable</code></td>
<td>若无重复，则插入新节点并返回指针</td>
<td>O(log N)</td>
</tr>
<tr>
<td><code>RtlLookupElementGenericTable</code></td>
<td>按键查找</td>
<td>O(log N)</td>
</tr>
<tr>
<td><code>RtlDeleteElementGenericTable</code></td>
<td>删除节点</td>
<td>O(log N)</td>
</tr>
<tr>
<td><code>RtlEnumerateGenericTable</code></td>
<td>按字典序迭代</td>
<td>O(1) 步进</td>
</tr>
<tr>
<td><code>RtlEnumerateGenericTableWithoutSplaying</code></td>
<td>枚举但不再平衡</td>
<td>Win7+ AVL 下同样平衡；保留兼容</td>
</tr>
<tr>
<td><code>RtlGetElementGenericTable</code></td>
<td>按序号 (0..N-1) 获取</td>
<td>O(N)</td>
</tr>
<tr>
<td><code>RtlNumberGenericTableElements</code></td>
<td>统计元素个数</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>RtlIsGenericTableEmpty</code></td>
<td>是否为空</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p>示例代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// =======================================</span></span><br><span class="line"><span class="comment">// 定义数据节点结构体</span></span><br><span class="line"><span class="comment">// 注意：平衡树节点头必须在首字段 (必须包含 RTL_BALANCED_LINKS)</span></span><br><span class="line"><span class="comment">// =======================================</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MY_DATA_ENTRY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    RTL_BALANCED_LINKS Links;  <span class="comment">// AVL树内部链接信息</span></span><br><span class="line">    ULONG Id;                  <span class="comment">// 主键字段，按此排序</span></span><br><span class="line">    ULONG X;                   <span class="comment">// 业务字段1</span></span><br><span class="line">    ULONG Y;                   <span class="comment">// 业务字段2</span></span><br><span class="line">&#125; MY_DATA_ENTRY, *PMY_DATA_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局通用表对象</span></span><br><span class="line">RTL_GENERIC_TABLE gTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =======================================</span></span><br><span class="line"><span class="comment">// 比较函数：用于排序/查找/去重</span></span><br><span class="line"><span class="comment">// 返回值决定二叉树排序方向</span></span><br><span class="line"><span class="comment">// =======================================</span></span><br><span class="line">RTL_GENERIC_COMPARE_RESULTS NTAPI <span class="title function_">MyCompare</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ <span class="keyword">struct</span> _RTL_GENERIC_TABLE *Table,</span></span><br><span class="line"><span class="params">    _In_ PVOID FirstStruct,</span></span><br><span class="line"><span class="params">    _In_ PVOID SecondStruct</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    PMY_DATA_ENTRY a = (PMY_DATA_ENTRY)FirstStruct;</span><br><span class="line">    PMY_DATA_ENTRY b = (PMY_DATA_ENTRY)SecondStruct;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a-&gt;Id &lt; b-&gt;Id) <span class="keyword">return</span> GenericLessThan;</span><br><span class="line">    <span class="keyword">if</span> (a-&gt;Id &gt; b-&gt;Id) <span class="keyword">return</span> GenericGreaterThan;</span><br><span class="line">    <span class="keyword">return</span> GenericEqual;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =======================================</span></span><br><span class="line"><span class="comment">// 分配函数：在插入新节点时被调用</span></span><br><span class="line"><span class="comment">// 注意：必须使用池分配内存</span></span><br><span class="line"><span class="comment">// =======================================</span></span><br><span class="line">PVOID NTAPI <span class="title function_">MyAllocate</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ <span class="keyword">struct</span> _RTL_GENERIC_TABLE *Table,</span></span><br><span class="line"><span class="params">    _In_ CLONG ByteSize</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ExAllocatePoolWithTag(NonPagedPoolNx, ByteSize, <span class="string">&#x27;TgDT&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =======================================</span></span><br><span class="line"><span class="comment">// 释放函数：在删除节点时被调用</span></span><br><span class="line"><span class="comment">// =======================================</span></span><br><span class="line">VOID NTAPI <span class="title function_">MyFree</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ <span class="keyword">struct</span> _RTL_GENERIC_TABLE *Table,</span></span><br><span class="line"><span class="params">    _In_ __drv_freesMem(Mem) _Post_invalid_ PVOID Buffer</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    ExFreePool(Buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =======================================</span></span><br><span class="line"><span class="comment">// 驱动卸载函数：清理通用表资源</span></span><br><span class="line"><span class="comment">// =======================================</span></span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(_In_ PDRIVER_OBJECT DriverObject)</span></span><br><span class="line">&#123;</span><br><span class="line">    PVOID RestartKey = <span class="literal">NULL</span>;</span><br><span class="line">    PMY_DATA_ENTRY pEntry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举删除表内所有元素，避免内存泄漏</span></span><br><span class="line">    <span class="keyword">while</span> ((pEntry = (PMY_DATA_ENTRY)RtlEnumerateGenericTable(&amp;gTable, &amp;RestartKey)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        BOOLEAN deleted = RtlDeleteElementGenericTable(&amp;gTable, pEntry);</span><br><span class="line">        UNREFERENCED_PARAMETER(deleted);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, <span class="string">&quot;Driver unloaded.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =======================================</span></span><br><span class="line"><span class="comment">// 驱动入口函数</span></span><br><span class="line"><span class="comment">// =======================================</span></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath)</span></span><br><span class="line">&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(RegistryPath);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化通用表</span></span><br><span class="line">    RtlInitializeGenericTable(&amp;gTable, MyCompare, MyAllocate, MyFree, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备测试数据</span></span><br><span class="line">    MY_DATA_ENTRY data[] = &#123;</span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">20</span> &#125;,</span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">2</span>, <span class="number">30</span>, <span class="number">40</span> &#125;,</span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">3</span>, <span class="number">50</span>, <span class="number">60</span> &#125;,</span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">4</span>, <span class="number">70</span>, <span class="number">80</span> &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入测试数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ARRAYSIZE(data); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        BOOLEAN newElement;</span><br><span class="line">        RtlInsertElementGenericTable(&amp;gTable, &amp;data[i], <span class="keyword">sizeof</span>(MY_DATA_ENTRY), &amp;newElement);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试查找</span></span><br><span class="line">    MY_DATA_ENTRY search = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    search.Id = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    PMY_DATA_ENTRY found = (PMY_DATA_ENTRY)RtlLookupElementGenericTable(&amp;gTable, &amp;search);</span><br><span class="line">    <span class="keyword">if</span> (found)</span><br><span class="line">    &#123;</span><br><span class="line">        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, <span class="string">&quot;Found: Id=%lu X=%lu Y=%lu\n&quot;</span>, found-&gt;Id, found-&gt;X, found-&gt;Y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有元素</span></span><br><span class="line">    PVOID RestartKey = <span class="literal">NULL</span>;</span><br><span class="line">    PMY_DATA_ENTRY pEntry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((pEntry = (PMY_DATA_ENTRY)RtlEnumerateGenericTable(&amp;gTable, &amp;RestartKey)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, <span class="string">&quot;Enumerate: Id=%lu X=%lu Y=%lu\n&quot;</span>, pEntry-&gt;Id, pEntry-&gt;X, pEntry-&gt;Y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="常用-API-1"><a href="#常用-API-1" class="headerlink" title="常用 API"></a>常用 API</h3><h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><p>Windows 内核模式下有专门的内存申请&#x2F;释放函数 <code>ExAllocatePool</code>&#x2F;<code>ExAllocatePoolWithTag</code> 和 <code>ExFreePool</code>&#x2F;<code>ExFreePoolWithTag</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PVOID <span class="title function_">ExAllocatePoolWithTag</span><span class="params">(</span></span><br><span class="line"><span class="params">  POOL_TYPE PoolType,</span></span><br><span class="line"><span class="params">  SIZE_T NumberOfBytes,</span></span><br><span class="line"><span class="params">  ULONG Tag</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">ExFreePoolWithTag</span><span class="params">(</span></span><br><span class="line"><span class="params">  PVOID P,</span></span><br><span class="line"><span class="params">  ULONG Tag</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>PoolType</code>：选择使用的内存池类型，常见的内存池有：<ul>
<li><code>PagedPool</code>：分页池，内存可被交换到磁盘。</li>
<li><code>NonPagedPool</code>：非分页池，驻留物理内存，可执行。</li>
</ul>
</li>
<li><code>NumberOfBytes</code>：要申请的字节数，任意长度。</li>
<li><code>Tag</code>：内存标签，Windbg <code>!poolused</code>、<code>!pooltag</code> 可用此标签进行泄漏、溢出排查。<code>ExAllocatePool</code> 和 <code>ExFreePool</code> 函数缺少这个参数。</li>
</ul>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>在内核中通常使用 <code>PsCreateSystemThread</code> 函数创建内核线程，该函数原型如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">PsCreateSystemThread</span><span class="params">(</span></span><br><span class="line"><span class="params">  OUT PHANDLE ThreadHandle,         <span class="comment">// [输出] 线程句柄，成功返回后需 ZwClose 关闭</span></span></span><br><span class="line"><span class="params">  IN ACCESS_MASK DesiredAccess,     <span class="comment">// [输入] 访问权限，通常填写 THREAD_ALL_ACCESS</span></span></span><br><span class="line"><span class="params">  IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,  <span class="comment">// [输入] 对象属性，内核线程一般填 NULL</span></span></span><br><span class="line"><span class="params">  IN HANDLE ProcessHandle OPTIONAL, <span class="comment">// [输入] 进程句柄，内核线程填 NULL (表示系统进程)</span></span></span><br><span class="line"><span class="params">  OUT PCLIENT_ID ClientId OPTIONAL, <span class="comment">// [输出] 线程 Client ID（包含 PID/TID），一般填 NULL</span></span></span><br><span class="line"><span class="params">  IN PKSTART_ROUTINE StartRoutine,  <span class="comment">// [输入] 线程入口函数 (函数指针)</span></span></span><br><span class="line"><span class="params">  IN PVOID StartContext             <span class="comment">// [输入] 入口函数参数 (传入自定义上下文)</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><code>ThreadHandle</code>：函数成功返回时，输出新创建线程的句柄。</p>
<ul>
<li>驱动一般创建完线程立即关闭句柄，因为不需要持续持有。</li>
<li>必须在成功创建后调用 <code>ZwClose()</code> 关闭句柄，否则可能会泄漏句柄表项。</li>
<li>即使关闭句柄，线程本身仍在运行，句柄只是内核对象的一个引用。</li>
</ul>
</li>
<li><p><code>DesiredAccess</code>：指定希望线程句柄具有的访问权限。因内核线程通常不操作自身句柄，直接用 <code>THREAD_ALL_ACCESS</code> 或 0 都可。</p>
</li>
<li><p><code>ObjectAttributes</code>：定义线程对象的名称、属性等。仅极少情况才会用，例如为线程创建命名对象供调试器附加。绝大部分内核驱动开发直接传 <code>NULL</code>。</p>
</li>
<li><p><code>ProcessHandle</code>：指定新线程在哪个进程空间中运行。</p>
<ul>
<li>传 <code>NULL</code> 表示创建的是内核线程（属于系统进程 <code>System</code>，PID&#x3D;4）。</li>
<li>若传入用户进程句柄，则创建用户进程中的远程线程。</li>
</ul>
</li>
<li><p><code>ClientId</code>：可选输出参数，返回新创建线程的唯一标识（进程 ID + 线程 ID）。如果不需要则传 <code>NULL</code> 即可。</p>
</li>
<li><p><code>StartRoutine</code>：线程的入口函数指针（回调函数），函数原型为：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOID <span class="title function_">StartRoutine</span><span class="params">(PVOID StartContext)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>必须确保该函数永远不返回，最后用 <code>PsTerminateSystemThread()</code> 主动结束线程。</li>
<li><code>StartContext</code> 参数由第七个参数传入，方便传递上下文数据。</li>
</ul>
</li>
<li><p><code>StartContext</code>：传入给入口函数的自定义参数，通常为结构体指针或简单数据，用于向新线程传递启动上下文信息（如配置、句柄、共享内存等）。</p>
</li>
</ul>
<p>示例代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程控制结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MY_THREAD_CONTEXT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    HANDLE ThreadHandle;</span><br><span class="line">    PETHREAD ThreadObject;</span><br><span class="line">    <span class="keyword">volatile</span> BOOLEAN ShouldStop;  <span class="comment">// 控制退出标志</span></span><br><span class="line">    ULONG Parameter;              <span class="comment">// 模拟业务参数</span></span><br><span class="line">&#125; MY_THREAD_CONTEXT, *PMY_THREAD_CONTEXT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程上下文全局变量 (可替换为动态分配)</span></span><br><span class="line">MY_THREAD_CONTEXT g_ThreadContext = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程入口函数</span></span><br><span class="line">VOID <span class="title function_">MyKernelThread</span><span class="params">(IN PVOID Context)</span></span><br><span class="line">&#123;</span><br><span class="line">    PMY_THREAD_CONTEXT ThreadCtx = (PMY_THREAD_CONTEXT)Context;</span><br><span class="line">    LARGE_INTEGER Interval;</span><br><span class="line">    Interval.QuadPart = <span class="number">-10</span> * <span class="number">1000</span> * <span class="number">1000LL</span>; <span class="comment">// 1秒</span></span><br><span class="line"></span><br><span class="line">    DbgPrint(<span class="string">&quot;内核线程启动，参数: %lu\n&quot;</span>, ThreadCtx-&gt;Parameter);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!ThreadCtx-&gt;ShouldStop)</span><br><span class="line">    &#123;</span><br><span class="line">        DbgPrint(<span class="string">&quot;线程循环执行中...\n&quot;</span>);</span><br><span class="line">        KeDelayExecutionThread(KernelMode, FALSE, &amp;Interval);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DbgPrint(<span class="string">&quot;内核线程检测到退出请求\n&quot;</span>);</span><br><span class="line">    PsTerminateSystemThread(STATUS_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建内核线程</span></span><br><span class="line">NTSTATUS <span class="title function_">StartKernelThread</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line"></span><br><span class="line">    g_ThreadContext.ShouldStop = FALSE;</span><br><span class="line">    g_ThreadContext.Parameter = <span class="number">1234</span>;  <span class="comment">// 模拟业务数据</span></span><br><span class="line"></span><br><span class="line">    status = PsCreateSystemThread(</span><br><span class="line">        &amp;g_ThreadContext.ThreadHandle,</span><br><span class="line">        THREAD_ALL_ACCESS,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        MyKernelThread,</span><br><span class="line">        &amp;g_ThreadContext</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">    &#123;</span><br><span class="line">        DbgPrint(<span class="string">&quot;创建内核线程失败: 0x%08X\n&quot;</span>, status);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用线程对象，方便后续等待退出</span></span><br><span class="line">    status = ObReferenceObjectByHandle(</span><br><span class="line">        g_ThreadContext.ThreadHandle,</span><br><span class="line">        THREAD_ALL_ACCESS,</span><br><span class="line">        *PsThreadType,</span><br><span class="line">        KernelMode,</span><br><span class="line">        (PVOID*)&amp;g_ThreadContext.ThreadObject,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    ZwClose(g_ThreadContext.ThreadHandle); <span class="comment">// 关闭句柄本身</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭线程</span></span><br><span class="line">VOID <span class="title function_">StopKernelThread</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (g_ThreadContext.ThreadObject)</span><br><span class="line">    &#123;</span><br><span class="line">        g_ThreadContext.ShouldStop = TRUE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待线程退出</span></span><br><span class="line">        KeWaitForSingleObject(</span><br><span class="line">            g_ThreadContext.ThreadObject,</span><br><span class="line">            Executive,</span><br><span class="line">            KernelMode,</span><br><span class="line">            FALSE,</span><br><span class="line">            <span class="literal">NULL</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        ObDereferenceObject(g_ThreadContext.ThreadObject);</span><br><span class="line">        g_ThreadContext.ThreadObject = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        DbgPrint(<span class="string">&quot;内核线程已成功退出并释放资源\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动入口</span></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)</span></span><br><span class="line">&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(RegistryPath);</span><br><span class="line">    DbgPrint(<span class="string">&quot;驱动加载\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(StartKernelThread()))</span><br><span class="line">    &#123;</span><br><span class="line">        DbgPrint(<span class="string">&quot;内核线程创建失败，驱动加载终止\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载例程</span></span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span><br><span class="line">&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(DriverObject);</span><br><span class="line">    DbgPrint(<span class="string">&quot;驱动卸载，准备停止线程\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    StopKernelThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="驱动隐藏"><a href="#驱动隐藏" class="headerlink" title="驱动隐藏"></a>驱动隐藏</h2><h3 id="隐藏思路"><a href="#隐藏思路" class="headerlink" title="隐藏思路"></a>隐藏思路</h3><p>在 Windows 内核中，驱动模块在系统内部存在两个最关键的暴露点：</p>
<ul>
<li><code>PsLoadedModuleList</code>：系统全局模块双向链表（记录所有已加载驱动模块）</li>
<li><code>DriverObject</code> 结构体：系统所有已注册的驱动对象（包含驱动模块信息）</li>
</ul>
<p>因此隐藏的本质是：</p>
<ul>
<li>从 <code>PsLoadedModuleList</code> 断链 → 让系统模块枚举 API 查不到</li>
<li>抹除 <code>DriverObject</code> 内关键字段 → 让安全软件和调试器无法逆推出模块信息</li>
</ul>
<h3 id="隐藏流程"><a href="#隐藏流程" class="headerlink" title="隐藏流程"></a>隐藏流程</h3><ol>
<li><strong>延迟隐藏逻辑</strong> ：如果在 <code>DriverEntry()</code> 阶段立即隐藏，可能会因为内核后续调用尚未完成而引发异常。这是因为驱动加载的后续流程可能会用到 <code>DriverObject</code> 结构体中一些对象。因此我们可以<strong>启动一个内核线程，延迟约 100ms 后再执行隐藏逻辑</strong>。</li>
<li><strong>断链模块表</strong> ：遍历 <code>PsLoadedModuleList</code>，逐个对比 <code>BaseDllName</code> 与目标模块名。找到后执行 <code>RemoveEntryList()</code> 完成断链。</li>
<li><strong>筛选合法伪造模块</strong> ：在遍历链表时顺便记录第一个合法存在的其它模块节点。该节点用作伪造用 <code>DriverSection</code>。</li>
<li><strong>定位 DriverObject</strong> ：使用内核 API <code>ObReferenceObjectByName()</code> 定位目标驱动的 <code>DriverObject</code>。</li>
<li><strong>抹除与伪造</strong> ：将 <code>DriverInit</code>、<code>DriverSection</code>、<code>Type</code> 字段抹除或伪造。其中 <code>DriverSection</code> 需要执行前面筛选的合法 <code>DriverSection</code>，防止安全软件在扫描 <code>DriverObject-&gt;DriverSection</code> 时蓝屏。</li>
</ol>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// =======================</span></span><br><span class="line"><span class="comment">// 精简版 KLDR_DATA_TABLE_ENTRY (省略部分字段)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 注意：这里用简化版结构体，</span></span><br><span class="line"><span class="comment">// 实际项目中可用 Windbg dt命令导出完整结构体以提升兼容性</span></span><br><span class="line"><span class="comment">// =======================</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KLDR_DATA_TABLE_ENTRY</span> &#123;</span></span><br><span class="line">    LIST_ENTRY InLoadOrderLinks;</span><br><span class="line">    ULONG __Undefined1;</span><br><span class="line">    ULONG __Undefined2;</span><br><span class="line">    ULONG __Undefined3;</span><br><span class="line">    ULONG NonPagedDebugInfo;</span><br><span class="line">    ULONG DllBase;</span><br><span class="line">    ULONG EntryPoint;</span><br><span class="line">    ULONG SizeOfImage;</span><br><span class="line">    UNICODE_STRING FullDllName;</span><br><span class="line">    UNICODE_STRING BaseDllName;</span><br><span class="line">    ULONG Flags;</span><br><span class="line">    USHORT LoadCount;</span><br><span class="line">    USHORT __Undefined5;</span><br><span class="line">    ULONG __Undefined6;</span><br><span class="line">    ULONG CheckSum;</span><br><span class="line">    ULONG TimeDateStamp;</span><br><span class="line">    <span class="comment">// ...(后续字段省略)</span></span><br><span class="line">&#125; KLDR_DATA_TABLE_ENTRY, *PKLDR_DATA_TABLE_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =======================</span></span><br><span class="line"><span class="comment">// 目标模块名称与DriverObject名称 (请根据目标驱动修改)</span></span><br><span class="line"><span class="comment">// =======================</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIDE_MODULE_NAME <span class="string">L&quot;TestDriver.sys&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIDE_DRIVER_OBJECT_NAME <span class="string">L&quot;\\Driver\\TestDriver&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐藏线程句柄</span></span><br><span class="line">HANDLE g_HideThreadHandle = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =======================</span></span><br><span class="line"><span class="comment">// 模块断链 + 伪造 DriverSection + DriverObject隐藏 统一逻辑</span></span><br><span class="line"><span class="comment">// =======================</span></span><br><span class="line">VOID <span class="title function_">UnlinkAndHide</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取 PsLoadedModuleList 链表头</span></span><br><span class="line">    PKLDR_DATA_TABLE_ENTRY pLdr = (PKLDR_DATA_TABLE_ENTRY)PsLoadedModuleList-&gt;Flink;</span><br><span class="line">    PLIST_ENTRY PsLoadedModuleListHead = pLdr-&gt;InLoadOrderLinks.Blink-&gt;Flink;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成目标模块名字符串用于匹配</span></span><br><span class="line">    UNICODE_STRING targetName;</span><br><span class="line">    RtlInitUnicodeString(&amp;targetName, HIDE_MODULE_NAME);</span><br><span class="line"></span><br><span class="line">    PKLDR_DATA_TABLE_ENTRY RemovedEntry = <span class="literal">NULL</span>;  <span class="comment">// 记录被断链的模块节点</span></span><br><span class="line">    PKLDR_DATA_TABLE_ENTRY FakeEntry = <span class="literal">NULL</span>;     <span class="comment">// 记录合法伪造用模块</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历模块链表</span></span><br><span class="line">    PLIST_ENTRY pList = PsLoadedModuleListHead-&gt;Flink;</span><br><span class="line">    <span class="keyword">while</span> (pList != PsLoadedModuleListHead)</span><br><span class="line">    &#123;</span><br><span class="line">        PKLDR_DATA_TABLE_ENTRY pEntry = CONTAINING_RECORD(pList, KLDR_DATA_TABLE_ENTRY, InLoadOrderLinks);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只判断 BaseDllName.Length 非 0 简化合法性判定</span></span><br><span class="line">        <span class="keyword">if</span> (pEntry-&gt;BaseDllName.Length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pList = pList-&gt;Flink;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否为要隐藏的目标模块</span></span><br><span class="line">        <span class="keyword">if</span> (RtlCompareUnicodeString(&amp;pEntry-&gt;BaseDllName, &amp;targetName, TRUE) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            DbgPrint(<span class="string">&quot;找到目标模块: %wZ -&gt; 执行断链隐藏\n&quot;</span>, &amp;pEntry-&gt;BaseDllName);</span><br><span class="line">            RemoveEntryList(&amp;pEntry-&gt;InLoadOrderLinks);</span><br><span class="line">            RemovedEntry = pEntry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (FakeEntry == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 记录第一个合法可伪造模块作为 DriverSection 替代项</span></span><br><span class="line">            FakeEntry = pEntry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pList = pList-&gt;Flink;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========================</span></span><br><span class="line">    <span class="comment">// DriverObject抹除及 DriverSection伪造逻辑</span></span><br><span class="line">    <span class="comment">// ========================</span></span><br><span class="line">    UNICODE_STRING drvName;</span><br><span class="line">    RtlInitUnicodeString(&amp;drvName, HIDE_DRIVER_OBJECT_NAME);</span><br><span class="line"></span><br><span class="line">    PDRIVER_OBJECT pTargetDriver = <span class="literal">NULL</span>;</span><br><span class="line">    NTSTATUS status = ObReferenceObjectByName(</span><br><span class="line">        &amp;drvName,</span><br><span class="line">        OBJ_CASE_INSENSITIVE,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        *IoDriverObjectType,</span><br><span class="line">        KernelMode,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        (PVOID*)&amp;pTargetDriver</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (NT_SUCCESS(status))</span><br><span class="line">    &#123;</span><br><span class="line">        DbgPrint(<span class="string">&quot;成功定位 DriverObject，执行隐藏逻辑\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 抹除关键字段 (防止逆向工具利用)</span></span><br><span class="line">        pTargetDriver-&gt;DriverInit = <span class="literal">NULL</span>;</span><br><span class="line">        pTargetDriver-&gt;Type = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 伪造合法 DriverSection 避免蓝屏</span></span><br><span class="line">        <span class="keyword">if</span> (FakeEntry != <span class="literal">NULL</span>)</span><br><span class="line">            pTargetDriver-&gt;DriverSection = FakeEntry;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 减少 ObReferenceObjectByName 增加的引用次数</span></span><br><span class="line">        ObDereferenceObject(pTargetDriver);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        DbgPrint(<span class="string">&quot;ObReferenceObjectByName 获取 DriverObject 失败: 0x%08X\n&quot;</span>, status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =======================</span></span><br><span class="line"><span class="comment">// 延迟隐藏线程逻辑 (核心隐藏动作在此执行)</span></span><br><span class="line"><span class="comment">// =======================</span></span><br><span class="line">VOID <span class="title function_">HideThreadProc</span><span class="params">(PVOID StartContext)</span></span><br><span class="line">&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(StartContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延迟 100ms 保证系统加载流程稳定</span></span><br><span class="line">    LARGE_INTEGER interval;</span><br><span class="line">    interval.QuadPart = <span class="number">-10</span> * <span class="number">1000</span> * <span class="number">100LL</span>; <span class="comment">// 100毫秒延迟</span></span><br><span class="line"></span><br><span class="line">    DbgPrint(<span class="string">&quot;隐藏线程启动，延迟 100ms 后执行隐藏流程\n&quot;</span>);</span><br><span class="line">    KeDelayExecutionThread(KernelMode, FALSE, &amp;interval);</span><br><span class="line"></span><br><span class="line">    UnlinkAndHide();</span><br><span class="line"></span><br><span class="line">    DbgPrint(<span class="string">&quot;隐藏逻辑完成，退出隐藏线程\n&quot;</span>);</span><br><span class="line">    PsTerminateSystemThread(STATUS_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =======================</span></span><br><span class="line"><span class="comment">// 驱动卸载逻辑</span></span><br><span class="line"><span class="comment">// =======================</span></span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span><br><span class="line">&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(DriverObject);</span><br><span class="line">    DbgPrint(<span class="string">&quot;驱动卸载完成\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =======================</span></span><br><span class="line"><span class="comment">// 驱动入口逻辑</span></span><br><span class="line"><span class="comment">// =======================</span></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)</span></span><br><span class="line">&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(RegistryPath);</span><br><span class="line">    DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line"></span><br><span class="line">    DbgPrint(<span class="string">&quot;驱动加载，准备启动隐藏线程\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    NTSTATUS status = PsCreateSystemThread(</span><br><span class="line">        &amp;g_HideThreadHandle,</span><br><span class="line">        THREAD_ALL_ACCESS,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">        HideThreadProc,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">    &#123;</span><br><span class="line">        DbgPrint(<span class="string">&quot;创建隐藏线程失败: 0x%08X\n&quot;</span>, status);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ZwClose(g_HideThreadHandle);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="驱动通信"><a href="#驱动通信" class="headerlink" title="驱动通信"></a>驱动通信</h2><h3 id="设备对象"><a href="#设备对象" class="headerlink" title="设备对象"></a>设备对象</h3><p>绝大多数情况下，一个内核驱动如果没有创建任何设备对象 (DeviceObject)，那么用户态（Ring3）无法直接与该驱动通信。这是因为设备对象是内核通信入口，<code>CreateFile</code> &#x2F; <code>DeviceIoControl</code> &#x2F; <code>ReadFile</code> &#x2F; <code>WriteFile</code> 等通信 API 只能打开设备对象。</p>
<p>设备对象主要有三类：</p>
<ul>
<li><strong>PDO（Physical Device Object）</strong> ：总线驱动创建，表示物理设备本身的存在性。例如 USB、PCI、SATA 控制器、蓝牙模块等。PDO 只描述：“有这么个硬件挂上来了”，不控制它如何工作。</li>
<li><strong>FDO（Functional Device Object）</strong> ：功能驱动创建，负责控制硬件功能、提供核心业务逻辑。FDO 负责解释 IRP 请求、控制硬件寄存器、管理协议栈、提供用户空间接口，真正把硬件功能带给系统。</li>
<li><strong>Filter Device Object</strong> ：过滤驱动创建，可插在 FDO 上下两侧，负责监控、修改、拦截 I&#x2F;O 请求，属于透明扩展层。它不控制硬件，而是做中间层逻辑处理。</li>
</ul>
<p>这些设备对象彼此层叠形成的一条逻辑设备处理链。用户与设备交互的数据在 I&#x2F;O 层叠栈中的设备对象中层层转发，每一层都可以可以拦截、监控、修改、阻断用户请求。这种结构被称为 <strong>I&#x2F;O 层叠栈（Stacked Device Stack）</strong>。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">用户 I/O 请求</span><br><span class="line">    ↓</span><br><span class="line">[Filter Device (Upper Filter)]</span><br><span class="line">    ↓</span><br><span class="line">[Functional Device (FDO)]</span><br><span class="line">    ↓</span><br><span class="line">[Filter Device (Lower Filter)]</span><br><span class="line">    ↓</span><br><span class="line">[Physical Device (PDO)]</span><br><span class="line">    ↓</span><br><span class="line">硬件</span><br></pre></td></tr></table></figure></div>

<p>不过大多数普通第三方内核驱动开发者实际上写的都是类似 <strong>FDO 或 Filter</strong>，<strong>PDO 只能由 Bus Driver 创建</strong>（通常系统自带）。</p>
<table>
<thead>
<tr>
<th>设备类型</th>
<th>PDO 创建者</th>
<th>FDO 创建者</th>
<th>Filter 创建者</th>
</tr>
</thead>
<tbody><tr>
<td>USB 存储</td>
<td>USB Hub 驱动</td>
<td>UAS 驱动（如 usbstor.sys）</td>
<td>杀毒软件过滤层</td>
</tr>
<tr>
<td>网卡</td>
<td>PCI Bus 驱动</td>
<td>NIC 功能驱动</td>
<td>防火墙、抓包驱动</td>
</tr>
<tr>
<td>虚拟设备</td>
<td>Root Enumerator</td>
<td>虚拟驱动</td>
<td>监控、调试工具</td>
</tr>
</tbody></table>
<p><strong>设备对象</strong>与<strong>驱动对象</strong>的关系：</p>
<ul>
<li>一个<strong>驱动</strong>可以<strong>创建</strong>（ <code>IoCreateDevice</code>）或<strong>附加</strong>（<code>IoAttachDevice</code>）多个<strong>设备对象</strong>，用于负责<strong>处理和过滤</strong>多个设备的消息。</li>
<li>一个<strong>物理设备</strong>可以绑定多个<strong>设备对象</strong>，这些设备对象形成了一个<strong>设备对象堆栈</strong>，可以层层过滤用户程序向设备发送的消息。</li>
</ul>
<h4 id="设备对象定义"><a href="#设备对象定义" class="headerlink" title="设备对象定义"></a>设备对象定义</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_OBJECT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SHORT Type;  <span class="comment">// 内核对象类型标识，固定为0x03表示DEVICE_OBJECT类型</span></span><br><span class="line">    USHORT Size;  <span class="comment">// 结构体大小（字节），不同版本Windows大小略有不同，典型为0xB8</span></span><br><span class="line">    LONG ReferenceCount;  <span class="comment">// 内核内部引用计数，自动维护，表示被多少模块或线程引用</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DRIVER_OBJECT</span>* <span class="title">DriverObject</span>;</span>  <span class="comment">// 📌当前设备对象所属的驱动对象指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_OBJECT</span>* <span class="title">NextDevice</span>;</span>  <span class="comment">// 📌同一个驱动下多个设备对象通过NextDevice组成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_OBJECT</span>* <span class="title">AttachedDevice</span>;</span>  <span class="comment">// 📌指向附加在本设备对象上的过滤设备对象（设备堆叠时使用）</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IRP</span>* <span class="title">CurrentIrp</span>;</span>  <span class="comment">// 当前处理的IRP，仅老式串行StartIo驱动模型下使用，绝大多数驱动不用管</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_TIMER</span>* <span class="title">Timer</span>;</span>  <span class="comment">// 设备专用I/O定时器指针，通过IoInitializeTimer注册，支持周期性回调</span></span><br><span class="line"></span><br><span class="line">    ULONG Flags;  <span class="comment">// 📌设备标志控制设备的I/O模型和电源行为，常见有：DO_BUFFERED_IO（缓冲IO）、DO_DIRECT_IO（直接IO）、DO_POWER_PAGABLE（分页支持）</span></span><br><span class="line">    ULONG Characteristics;  <span class="comment">// 设备特性标志，控制设备特性行为，例如FILE_REMOVABLE_MEDIA（可移动介质）、FILE_READ_ONLY_DEVICE（只读设备），普通控制驱动一般填0</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">VPB</span>* <span class="title">Vpb</span>;</span>  <span class="comment">// 卷参数块，仅文件系统与存储类驱动使用，普通控制型驱动恒为NULL</span></span><br><span class="line"></span><br><span class="line">    VOID* DeviceExtension;  <span class="comment">// 📌设备扩展区，驱动自定义业务数据区，创建设备时指定大小并在此区域挂载私有结构体</span></span><br><span class="line"></span><br><span class="line">    ULONG DeviceType;  <span class="comment">// 📌设备类型，定义设备类别，如FILE_DEVICE_UNKNOWN（控制型驱动通用）、FILE_DEVICE_DISK、FILE_DEVICE_NETWORK等</span></span><br><span class="line">    CHAR StackSize;  <span class="comment">// 📌设备栈深度，表示此设备在过滤栈中的层数，每附加一层过滤器栈自动+1</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ListEntry</span>;</span> <span class="class"><span class="keyword">struct</span> _<span class="title">WAIT_CONTEXT_BLOCK</span> <span class="title">Wcb</span>;</span> &#125; Queue;  <span class="comment">// 内核内部用队列或DMA上下文，极少数底层硬件驱动使用</span></span><br><span class="line"></span><br><span class="line">    ULONG AlignmentRequirement;  <span class="comment">// 设备I/O缓冲区内存对齐要求，DMA设备特别关注对齐要求，普通驱动为默认对齐</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KDEVICE_QUEUE</span> <span class="title">DeviceQueue</span>;</span>  <span class="comment">// 串行I/O请求队列，主要用于串口、磁带等硬件控制型串行设备</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KDPC</span> <span class="title">Dpc</span>;</span>  <span class="comment">// 延迟过程调用对象，用于中断下半部处理逻辑，配合ISR分离快速中断和实际数据处理</span></span><br><span class="line">    ULONG ActiveThreadCount;  <span class="comment">// 正在处理本设备对象IRP的线程数量，内核自动管理，用于内部同步统计</span></span><br><span class="line"></span><br><span class="line">    VOID* SecurityDescriptor;  <span class="comment">// 设备对象安全描述符，定义DACL权限控制，控制型驱动通常填NULL表示默认安全性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KEVENT</span> <span class="title">DeviceLock</span>;</span>  <span class="comment">// 内部同步锁，配合串行I/O等同步场景控制并发访问</span></span><br><span class="line"></span><br><span class="line">    USHORT SectorSize;  <span class="comment">// 扇区大小，存储设备使用，非存储型控制驱动通常为0</span></span><br><span class="line">    USHORT Spare1;  <span class="comment">// 保留字段，未来扩展用</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DEVOBJ_EXTENSION</span>* <span class="title">DeviceObjectExtension</span>;</span>  <span class="comment">// 内核扩展区，供PNP、电源管理等系统模块使用，驱动一般无需关心</span></span><br><span class="line">    VOID* Reserved;  <span class="comment">// 预留字段</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><code>DriverObject</code>：所属驱动的 <code>DriverObject</code>，用于找到<strong>设备对象所属的驱动对象</strong>。</p>
</li>
<li><p><code>NextDevice</code>：将<strong>一个驱动所属的所有设备对象</strong> <code>DriverObject</code> 串联成一个单向链表，链表头为 <code>DriverObject-&gt;DeviceObject</code>。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DriverObject</span><br><span class="line">  |</span><br><span class="line">  +--&gt; DeviceObject1 --&gt; DeviceObject2 --&gt; DeviceObject3 --&gt; NULL</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>AttachedDevice</code>：<code>AttachedDevice</code> 构成的是<strong>跨驱动</strong>的 <strong>I&#x2F;O 层叠栈（Stacked Device Stack）</strong>。它让不同驱动可以挂接在同一设备上层，共同参与 I&#x2F;O 请求的流转与处理。设备对象的 <code>AttachedDevice</code> 指向<strong>下一层</strong>的设备对象。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">IRP 入口</span><br><span class="line">   ↓</span><br><span class="line">DeviceObject_Filter3  &lt;-- 过滤层3（最上层）</span><br><span class="line">   ↓ AttachedDevice</span><br><span class="line">DeviceObject_Filter2  &lt;-- 过滤层2</span><br><span class="line">   ↓ AttachedDevice</span><br><span class="line">DeviceObject_Filter1  &lt;-- 过滤层1</span><br><span class="line">   ↓ AttachedDevice</span><br><span class="line">DeviceObject_Functional (FDO)  &lt;-- 功能设备对象 (目标核心驱动)</span><br><span class="line">   ↓ AttachedDevice</span><br><span class="line">DeviceObject_PDO  &lt;-- 物理设备对象 (底层物理设备)</span><br><span class="line">   ↓ AttachedDevice</span><br><span class="line">NULL</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>StackSize</code>：从当前设备对象所在的位置，往下直到整个设备栈的最底层（PDO）为止，所需要的 IRP 栈帧数量总和。换句话说：<strong>当前设备对象在整个 IRP 传递链中，自己算在内，往下有多少设备对象要参与。</strong></p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">用户层 I/O 请求</span><br><span class="line">    ↓</span><br><span class="line">[DeviceObject_Filter3]  StackSize=5</span><br><span class="line">    ↓</span><br><span class="line">[DeviceObject_Filter2]  StackSize=4</span><br><span class="line">    ↓</span><br><span class="line">[DeviceObject_Filter1]  StackSize=3</span><br><span class="line">    ↓</span><br><span class="line">[DeviceObject_FDO]      StackSize=2</span><br><span class="line">    ↓</span><br><span class="line">[DeviceObject_PDO]      StackSize=1</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="设备对象创建"><a href="#设备对象创建" class="headerlink" title="设备对象创建"></a>设备对象创建</h4><p>在内核中，设备对象通常通过 <code>IoCreateDevice</code> 函数进行创建，该函数由 I&#x2F;O 管理器提供，用于在 Object Manager 中注册新的设备对象，并分配相应的内存与扩展数据区。以下是函数原型：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">IoCreateDevice</span><span class="params">(</span></span><br><span class="line"><span class="params">  IN PDRIVER_OBJECT DriverObject,           <span class="comment">// [输入] 驱动对象指针</span></span></span><br><span class="line"><span class="params">  IN ULONG DeviceExtensionSize,             <span class="comment">// [输入] 设备扩展区大小（字节数）</span></span></span><br><span class="line"><span class="params">  IN PUNICODE_STRING DeviceName OPTIONAL,   <span class="comment">// [输入] 设备名称（Object Manager 路径）</span></span></span><br><span class="line"><span class="params">  IN DEVICE_TYPE DeviceType,                <span class="comment">// [输入] 设备类型标识</span></span></span><br><span class="line"><span class="params">  IN ULONG DeviceCharacteristics,           <span class="comment">// [输入] 设备特性标志</span></span></span><br><span class="line"><span class="params">  IN BOOLEAN Exclusive,                     <span class="comment">// [输入] 是否独占设备</span></span></span><br><span class="line"><span class="params">  OUT PDEVICE_OBJECT *DeviceObject          <span class="comment">// [输出] 返回新建的设备对象指针</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>DriverObject</code>：指定所属驱动对象，通常传入 <code>DriverEntry</code> 函数中的 <code>PDRIVER_OBJECT</code>，用于将新创建的设备对象挂接到驱动对象下，由驱动统一管理。</li>
<li><code>DeviceExtensionSize</code>：指定设备扩展区的大小（以字节为单位）。内核会在分配 <code>DEVICE_OBJECT</code> 结构时附加这一段额外空间，驱动可通过 <code>DeviceObject-&gt;DeviceExtension</code> 访问此区域，用于存储与设备实例相关的自定义上下文信息。如果不需要扩展区则传 <code>0</code>。</li>
<li><code>DeviceName</code>：指定设备对象的命名路径（完整的 Object Manager 路径），如 <code>\Device\MyDevice</code>。如果传入 <code>NULL</code>，则创建匿名设备对象，不注册命名空间，不可通过名称访问；一般控制型驱动需提供命名，供用户态程序通过符号链接访问。</li>
<li><code>DeviceType</code>：指定设备对象类型，用于指明设备类别，内核使用该类型决定某些默认行为。例如：<ul>
<li><code>FILE_DEVICE_UNKNOWN</code>：<strong>默认通用类型</strong>，绝大多数控制型驱动使用；</li>
<li><code>FILE_DEVICE_DISK</code>：磁盘设备；</li>
<li><code>FILE_DEVICE_NETWORK</code>：网络设备；</li>
<li><code>FILE_DEVICE_FILE_SYSTEM</code>：文件系统设备；</li>
<li>其他类型视具体功能选用。</li>
</ul>
</li>
<li><code>DeviceCharacteristics</code>：指定设备特性标志，用于控制设备的附加行为。常见取值包括：<ul>
<li><code>FILE_DEVICE_SECURE_OPEN</code>：启用安全性访问检查；</li>
<li><code>FILE_REMOVABLE_MEDIA</code>：表示可移动介质；</li>
<li>一般自定义控制型驱动可传 <code>0</code>，表示不声明任何特殊设备行为，内核使用默认通用行为对待该设备对象。</li>
</ul>
</li>
<li><code>Exclusive</code>：指定设备对象是否独占访问。当设为 <code>TRUE</code> 时，系统仅允许一个线程&#x2F;进程打开该设备对象，后续打开请求会失败（返回 <code>STATUS_DEVICE_BUSY</code>）。通常设为 <code>FALSE</code>，允许并发访问。</li>
<li><code>DeviceObject</code>：输出参数，返回成功创建的设备对象指针。驱动可通过此指针访问扩展区、设置属性，并在卸载时配合 <code>IoDeleteDevice</code> 正确释放内存资源。</li>
</ul>
<p>然而 <code>IoCreateDevice</code> 只负责把设备对象的内存空间从内核池分配出来，做了最基本初始化，但没有对外暴露接口。因此我们还要<strong>注册符号链接</strong>建立 Win32 层访问路径，确保用户态能够通过 <code>CreateFile()</code> 调用访问。</p>
<p>例如我们将设备名为 <code>\Device\MyDevice</code> 的设备通过 <code>IoCreateSymbolicLink</code> 创建了一个到 <code>\??\MyDevice</code> 的软连接：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设备命名：注册到 Object Manager 命名空间下</span></span><br><span class="line">UNICODE_STRING deviceName = RTL_CONSTANT_STRING(<span class="string">L&quot;\\Device\\MyDevice&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 符号链接命名：供用户态 CreateFile 使用 (Win32 层访问路径)</span></span><br><span class="line">UNICODE_STRING symLinkName = RTL_CONSTANT_STRING(<span class="string">L&quot;\\??\\MyDevice&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建符号链接 (供用户态访问)</span></span><br><span class="line">status = IoCreateSymbolicLink(&amp;symLinkName, &amp;deviceName);</span><br><span class="line"><span class="keyword">if</span> (!NT_SUCCESS(status)) &#123;</span><br><span class="line">    DbgPrint(<span class="string">&quot;IoCreateSymbolicLink 创建符号链接失败: 0x%08X\n&quot;</span>, status);</span><br><span class="line">    IoDeleteDevice(DeviceObject);  <span class="comment">// 创建失败时需回滚释放设备对象</span></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>那么用户程序就可以通过设备路径 <code>\\.\MyDevice</code> 来操作这个设备了。</p>
<p>最后我们需要对 <code>DeviceObject-&gt;Flags</code> <strong>清除初始化标志</strong>。这一步实际上是为了兼容一些老的操作系统，这一类操作系统不会自动去除初始化标志，导致设备对象创建之后始终处于未初始化状态，导致一些对设备的操作失败。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设备初始化完成，清除初始化标志 (兼容老系统)</span></span><br><span class="line">DeviceObject-&gt;Flags &amp;= ~DO_DEVICE_INITIALIZING;</span><br></pre></td></tr></table></figure></div>

<p>示例代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设备扩展结构体示例（自定义业务数据）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MY_DEVICE_EXTENSION</span> &#123;</span></span><br><span class="line">    ULONG ExampleField;</span><br><span class="line">&#125; MY_DEVICE_EXTENSION, *PMY_DEVICE_EXTENSION;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载例程声明</span></span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT DriverObject)</span>;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)</span></span><br><span class="line">&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(RegistryPath);</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    PDEVICE_OBJECT DeviceObject = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设备命名：注册到 Object Manager 命名空间下</span></span><br><span class="line">    UNICODE_STRING deviceName = RTL_CONSTANT_STRING(<span class="string">L&quot;\\Device\\MyDevice&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 符号链接命名：供用户态 CreateFile 使用 (Win32 层访问路径)</span></span><br><span class="line">    UNICODE_STRING symLinkName = RTL_CONSTANT_STRING(<span class="string">L&quot;\\??\\MyDevice&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建设备对象</span></span><br><span class="line">    status = IoCreateDevice(</span><br><span class="line">        DriverObject,                   <span class="comment">// 绑定到当前驱动</span></span><br><span class="line">        <span class="keyword">sizeof</span>(MY_DEVICE_EXTENSION),    <span class="comment">// 设备扩展区大小</span></span><br><span class="line">        &amp;deviceName,                    <span class="comment">// 设备名 (具名注册)</span></span><br><span class="line">        FILE_DEVICE_UNKNOWN,            <span class="comment">// 设备类型</span></span><br><span class="line">        <span class="number">0</span>,                              <span class="comment">// 设备特性 (默认传 0)</span></span><br><span class="line">        FALSE,                          <span class="comment">// 非独占 (允许并发访问)</span></span><br><span class="line">        &amp;DeviceObject                   <span class="comment">// 返回创建好的设备对象指针</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(status)) &#123;</span><br><span class="line">        DbgPrint(<span class="string">&quot;IoCreateDevice 创建设备失败: 0x%08X\n&quot;</span>, status);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建符号链接 (供用户态访问)</span></span><br><span class="line">    status = IoCreateSymbolicLink(&amp;symLinkName, &amp;deviceName);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(status)) &#123;</span><br><span class="line">        DbgPrint(<span class="string">&quot;IoCreateSymbolicLink 创建符号链接失败: 0x%08X\n&quot;</span>, status);</span><br><span class="line">        IoDeleteDevice(DeviceObject);  <span class="comment">// 创建失败时需回滚释放设备对象</span></span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设备初始化完成，清除初始化标志 (兼容老系统)</span></span><br><span class="line">    DeviceObject-&gt;Flags &amp;= ~DO_DEVICE_INITIALIZING;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册卸载例程</span></span><br><span class="line">    DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line"></span><br><span class="line">    DbgPrint(<span class="string">&quot;驱动加载成功，设备与符号链接已创建完成\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载例程 (驱动卸载时自动调用)</span></span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span><br><span class="line">&#123;</span><br><span class="line">    UNICODE_STRING symLinkName = RTL_CONSTANT_STRING(<span class="string">L&quot;\\??\\MyDevice&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除符号链接 (先删符号链接，再删设备对象)</span></span><br><span class="line">    IoDeleteSymbolicLink(&amp;symLinkName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放设备对象 (注意可能存在多个设备，需遍历释放)</span></span><br><span class="line">    PDEVICE_OBJECT DeviceObject = DriverObject-&gt;DeviceObject;</span><br><span class="line">    <span class="keyword">while</span> (DeviceObject != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PDEVICE_OBJECT NextDevice = DeviceObject-&gt;NextDevice;</span><br><span class="line">        IoDeleteDevice(DeviceObject);</span><br><span class="line">        DeviceObject = NextDevice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DbgPrint(<span class="string">&quot;驱动卸载完成，资源已释放\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="设备对象附加"><a href="#设备对象附加" class="headerlink" title="设备对象附加"></a>设备对象附加</h4><p>在 Windows 内核 I&#x2F;O 框架中，驱动可以将自己编写的设备对象附加到现有的设备对象之上，形成<strong>设备对象堆栈（Device Stack）</strong>。这种附加行为常用于开发过滤驱动、监控驱动、保护驱动、文件过滤驱动等场景。</p>
<p>内核提供 <code>IoAttachDevice</code> 或 <code>IoAttachDeviceToDeviceStack</code> 函数用于实现附加操作。</p>
<p><code>IoAttachDevice</code> 函数原型如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PDEVICE_OBJECT <span class="title function_">IoAttachDevice</span><span class="params">(</span></span><br><span class="line"><span class="params">  IN PDEVICE_OBJECT SourceDevice,   <span class="comment">// [输入] 自己新创建的设备对象</span></span></span><br><span class="line"><span class="params">  IN PUNICODE_STRING TargetDevice,  <span class="comment">// [输入] 要附加到的目标设备对象路径</span></span></span><br><span class="line"><span class="params">  OUT PDEVICE_OBJECT *AttachedTo    <span class="comment">// [输出] 实际附加成功后的目标设备对象指针</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>SourceDevice</code>：本驱动中用 <code>IoCreateDevice()</code> 创建好的设备对象，作为过滤层插入堆栈；</li>
<li><code>TargetDevice</code>：目标设备对象的全路径（如 <code>\Device\Harddisk0\DR0</code>），指定要附加到哪个设备；</li>
<li><code>AttachedTo</code>：附加成功后返回目标设备对象指针，即被附加的设备对象。也就是说附加后 <code>SourceDevice-&gt;AttachedDevice = AttachedTo</code>。</li>
</ul>
<p><code>IoAttachDeviceToDeviceStack</code> 则需要我们直接提供要被附加的设备对象，而不是设备路径，该函数定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PDEVICE_OBJECT <span class="title function_">IoAttachDeviceToDeviceStack</span><span class="params">(</span></span><br><span class="line"><span class="params">  IN PDEVICE_OBJECT SourceDevice,   <span class="comment">// [输入] 要附加的过滤设备对象 (本驱动创建)</span></span></span><br><span class="line"><span class="params">  IN PDEVICE_OBJECT TargetDevice    <span class="comment">// [输入] 目标设备对象 (被附加对象)</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><code>SourceDevice</code>：指定新创建的过滤层设备对象（一般通过 <code>IoCreateDevice()</code> 创建），将被插入到设备堆栈顶端，成为新的栈顶对象。附加成功后，该对象位于整个设备栈最顶层，优先接收 IRP 请求。</p>
</li>
<li><p><code>TargetDevice</code>：要附加的目标设备对象。<strong>系统会根据其 <code>AttachedDevice</code> 自动遍历整个设备栈，找到当前栈顶位置然后附加。</strong></p>
</li>
</ul>
<p>当完成附加后，当用户态通过 <code>CreateFile()</code> 打开设备时，虽然传入的设备路径仍然是被附加的设备对象。</p>
<p>但是由于我们在内核中通过 <code>IoAttachDeviceToDeviceStack()</code> 已经把自己的设备对象挂入了目标设备对象的 I&#x2F;O 栈顶，因此用户请求命中目标设备对象时，内核始终从栈顶开始派发 IRP。而我们的过滤设备对象就在这条栈上，所有请求自然会经过我们的驱动。</p>
<p>设备对象附加的示例代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">AttachToTargetDevice</span><span class="params">(PDEVICE_OBJECT MyDevice)</span></span><br><span class="line">&#123;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    PDEVICE_OBJECT TargetDevice = <span class="literal">NULL</span>;</span><br><span class="line">    UNICODE_STRING TargetDeviceName = RTL_CONSTANT_STRING(<span class="string">L&quot;\\Device\\Harddisk0\\DR0&quot;</span>);</span><br><span class="line"></span><br><span class="line">    status = IoGetDeviceObjectPointer(</span><br><span class="line">        &amp;TargetDeviceName,</span><br><span class="line">        FILE_READ_DATA,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        &amp;TargetDevice</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(status)) &#123;</span><br><span class="line">        DbgPrint(<span class="string">&quot;获取目标设备失败: 0x%08X\n&quot;</span>, status);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 附加到目标设备栈</span></span><br><span class="line">    PDEVICE_OBJECT AttachedTo = IoAttachDeviceToDeviceStack(MyDevice, TargetDevice);</span><br><span class="line">    <span class="keyword">if</span> (AttachedTo == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        DbgPrint(<span class="string">&quot;附加设备失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DbgPrint(<span class="string">&quot;成功附加到目标设备\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在驱动卸载的时候，我们需要在删除自己的设备对象之前先从设备栈分离。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IoDetachDevice(MyDeviceExtension-&gt;NextDevice);</span><br><span class="line">IoDeleteDevice(MyDeviceObject);</span><br></pre></td></tr></table></figure></div>

<h3 id="IRP（I-O-Request-Packet）"><a href="#IRP（I-O-Request-Packet）" class="headerlink" title="IRP（I&#x2F;O Request Packet）"></a>IRP（I&#x2F;O Request Packet）</h3><p><strong>IRP（I&#x2F;O Request Packet）</strong>是 Windows 内核 I&#x2F;O 子系统内部使用的统一请求数据结构，负责在设备驱动之间传递 I&#x2F;O 操作请求。所有内核驱动层（文件系统驱动、网络驱动、过滤驱动、控制驱动等等）之间的 I&#x2F;O 交互，都是通过 IRP 结构体完成。</p>
<h4 id="IRP-结构体"><a href="#IRP-结构体" class="headerlink" title="IRP 结构体"></a>IRP 结构体</h4><p><code>_IRP</code> 是内核 I&#x2F;O 子系统的核心数据结构，用于描述一次完整的 I&#x2F;O 请求状态与控制信息。所有 IRP 派发、过滤、传递、完成逻辑，都是围绕该结构体展开的。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0x70 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IRP</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SHORT Type;                     <span class="comment">// IRP对象标识，固定为0x06（IRP类型）</span></span><br><span class="line">    USHORT Size;                    <span class="comment">// IRP结构体大小 (当前为0x70)</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">MDL</span>* <span class="title">MdlAddress</span>;</span>        <span class="comment">// 📌内存描述列表 (用于 Direct I/O 模式时映射缓冲区)</span></span><br><span class="line"></span><br><span class="line">    ULONG Flags;                    <span class="comment">// IRP状态标志位，控制I/O管理器内部行为</span></span><br><span class="line">                                     <span class="comment">// 常见标志如：IRP_BUFFERED_IO, IRP_INPUT_OPERATION</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">IRP</span>* <span class="title">MasterIrp</span>;</span>     <span class="comment">// (分散聚集I/O使用)</span></span><br><span class="line">        LONG IrpCount;              <span class="comment">// (多IRP合并时的计数器)</span></span><br><span class="line">        VOID* SystemBuffer;         <span class="comment">// 📌(Buffered I/O 模式下的系统缓冲区指针)</span></span><br><span class="line">    &#125; AssociatedIrp;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ThreadListEntry</span>;</span> <span class="comment">// 挂接到线程 I/O 请求链的双向链表节点</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_STATUS_BLOCK</span> <span class="title">IoStatus</span>;</span>   <span class="comment">// 📌I/O 操作状态与返回值</span></span><br><span class="line"></span><br><span class="line">    CHAR RequestorMode;            <span class="comment">// 发起请求方的CPU模式：UserMode / KernelMode</span></span><br><span class="line">    UCHAR PendingReturned;         <span class="comment">// 内核内部标志，表示IRP是否挂起返回</span></span><br><span class="line">    CHAR StackCount;               <span class="comment">// 📌IRP栈总深度 (栈帧数量)</span></span><br><span class="line">    CHAR CurrentLocation;          <span class="comment">// 📌当前 IRP 栈位置 (栈帧索引)</span></span><br><span class="line"></span><br><span class="line">    UCHAR Cancel;                  <span class="comment">// 是否被请求取消 (1=正在取消)</span></span><br><span class="line">    UCHAR CancelIrql;              <span class="comment">// 取消时所处IRQL (中断优先级)</span></span><br><span class="line">    CHAR ApcEnvironment;           <span class="comment">// APC 环境信息</span></span><br><span class="line">    UCHAR AllocationFlags;         <span class="comment">// IRP分配标志 (一般由内核内部管理)</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_STATUS_BLOCK</span>* <span class="title">UserIosb</span>;</span>  <span class="comment">// 用户空间的 IO_STATUS_BLOCK 指针（异步操作返回）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KEVENT</span>* <span class="title">UserEvent</span>;</span>          <span class="comment">// 用户空间的同步事件（供异步通知）</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                VOID (*UserApcRoutine)(VOID* Context, <span class="keyword">struct</span> _IO_STATUS_BLOCK* IoStatus, ULONG Reserved);</span><br><span class="line">                                          <span class="comment">// 用户APC回调函数指针 (异步完成通知用)</span></span><br><span class="line">                VOID* IssuingProcess;    <span class="comment">// 发起IRP请求的进程 (内核内部用)</span></span><br><span class="line">            &#125;;</span><br><span class="line">            VOID* UserApcContext;        <span class="comment">// APC回调上下文参数</span></span><br><span class="line">        &#125; AsynchronousParameters;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">AllocationSize</span>;</span>  <span class="comment">// (文件系统使用: 分配文件大小)</span></span><br><span class="line">    &#125; Overlay;</span><br><span class="line"></span><br><span class="line">    VOID (*CancelRoutine)(<span class="keyword">struct</span> _DEVICE_OBJECT* DeviceObject, <span class="keyword">struct</span> _IRP* Irp);</span><br><span class="line">                                      <span class="comment">// 取消时调用的回调函数</span></span><br><span class="line"></span><br><span class="line">    VOID* UserBuffer;                <span class="comment">// 📌用户空间缓冲区 (Direct I/O 模式下映射)</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> _<span class="title">KDEVICE_QUEUE_ENTRY</span> <span class="title">DeviceQueueEntry</span>;</span> <span class="comment">// 设备队列链表节点</span></span><br><span class="line">                VOID* DriverContext[<span class="number">4</span>];   <span class="comment">// 驱动扩展上下文数据 (驱动自由使用)</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">ETHREAD</span>* <span class="title">Thread</span>;</span>      <span class="comment">// 所属线程对象指针</span></span><br><span class="line">            CHAR* AuxiliaryBuffer;        <span class="comment">// 辅助缓冲区 (文件系统扩展使用)</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ListEntry</span>;</span> <span class="comment">// 通用链表节点 (供I/O管理器组织IRP列表)</span></span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> _<span class="title">IO_STACK_LOCATION</span>* <span class="title">CurrentStackLocation</span>;</span> <span class="comment">// 📌当前IRP栈帧 (IO_STACK_LOCATION)           </span></span><br><span class="line">                ULONG PacketType;           <span class="comment">// 内部用标志</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">FILE_OBJECT</span>* <span class="title">OriginalFileObject</span>;</span> <span class="comment">// 原始文件对象</span></span><br><span class="line">        &#125; Overlay;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">KAPC</span> <span class="title">Apc</span>;</span>                  <span class="comment">// (特殊用法: 内核APC控制结构体)</span></span><br><span class="line">        VOID* CompletionKey;               <span class="comment">// (完成端口/队列扩展用)</span></span><br><span class="line">    &#125; Tail;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h5 id="I-O-层叠栈"><a href="#I-O-层叠栈" class="headerlink" title="I&#x2F;O 层叠栈"></a>I&#x2F;O 层叠栈</h5><p>由于 Windows 的<strong>设备对象</strong>组成了一个  <strong>I&#x2F;O 层叠栈（Stacked Device Stack）</strong>的结构，因此 <code>IRP</code> 为了能够在按照  <strong>I&#x2F;O 层叠栈（Stacked Device Stack）</strong>的结构回的调对应 <strong>IRP 派发函数</strong>传参，因此其内部也是一个类似堆栈的结构：</p>
<ul>
<li><code>StackCount</code>：总共有多少个设备对象参与 IRP 派发（即设备栈深度）。通常等于最上层 DeviceObject 的 <code>StackSize</code>。</li>
<li><code>CurrentLocation</code>：当前 IRP 正处于第几层派发阶段。每调用 <code>IoSkipCurrentIrpStackLocation()</code> 或 <code>IoCallDriver()</code> 时自动递减。</li>
<li><code>Tail.Overlay.CurrentStackLocation</code>：指向当前设备对象的 <code>IO_STACK_LOCATION</code> 结构，记录当前派发层级的参数、控制信息、IRP 参数（如 I&#x2F;O 控制码、读写长度等）。</li>
</ul>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">IRP 栈状态:</span><br><span class="line">StackCount = 5         ← 栈帧总数</span><br><span class="line">CurrentLocation = 3    ← 当前派发进度</span><br><span class="line">CurrentStackLocation → IO_STACK_LOCATION 3 (Filter1)</span><br><span class="line"></span><br><span class="line">设备对象堆叠对应关系:</span><br><span class="line">──────────────────────────────────────</span><br><span class="line">DeviceObject_Filter3   ←→  IO_STACK_LOCATION 5  (派发已完成)</span><br><span class="line">DeviceObject_Filter2   ←→  IO_STACK_LOCATION 4  (派发已完成)</span><br><span class="line">DeviceObject_Filter1   ←→  IO_STACK_LOCATION 3  ← 当前派发 (CurrentStackLocation 所在位置)</span><br><span class="line">DeviceObject_Functional(FDO) ←→ IO_STACK_LOCATION 2  (等待后续派发)</span><br><span class="line">DeviceObject_PDO       ←→  IO_STACK_LOCATION 1  (等待后续派发)</span><br><span class="line">──────────────────────────────────────</span><br></pre></td></tr></table></figure></div>

<p>很多关于 <code>IRP</code> 结构体的 API 本质上就是在操作这三个字段：</p>
<table>
<thead>
<tr>
<th>API 函数</th>
<th>作用</th>
<th>本质操作的字段变化</th>
</tr>
</thead>
<tbody><tr>
<td><code>IoGetCurrentIrpStackLocation()</code></td>
<td>获取当前派发栈帧指针</td>
<td>返回 <code>CurrentStackLocation</code></td>
</tr>
<tr>
<td><code>IoGetNextIrpStackLocation()</code></td>
<td>获取下一个栈帧指针（仅指针偏移，不修改位置）</td>
<td>返回 <code>CurrentStackLocation - 1</code></td>
</tr>
<tr>
<td><code>IoSetNextIrpStackLocation()</code></td>
<td>手动推进派发位置（很少用）</td>
<td><code>CurrentLocation--</code>，<code>CurrentStackLocation--</code></td>
</tr>
<tr>
<td><code>IoSkipCurrentIrpStackLocation()</code></td>
<td>抵消 <code>IoCallDriver </code> 函数内部的“推进派发位置”的操作，使得下一层设备对象仍然处理当前栈帧</td>
<td><code>CurrentLocation++</code>，<code>CurrentStackLocation++</code></td>
</tr>
</tbody></table>
<h5 id="参数结构"><a href="#参数结构" class="headerlink" title="参数结构"></a>参数结构</h5><p><code>IO_STACK_LOCATION</code> 中存储了参数信息，由于是所有类型的 IRP 派发函数公用，因此内部有一个联合体记录了每种类型的 IRP 派发函数对应的参数结构。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0x24 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_STACK_LOCATION</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    UCHAR MajorFunction;     <span class="comment">// 0x0 📌IRP 主功能码 (IRP_MJ_*)，驱动派发逻辑的核心依据</span></span><br><span class="line">    UCHAR MinorFunction;     <span class="comment">// 0x1 IRP 子功能码 (IRP_MN_*)，配合 MajorFunction 做更精细的区分</span></span><br><span class="line">    UCHAR Flags;             <span class="comment">// 0x2 控制标志，部分操作行为控制（如 SL_OVERRIDE_VERIFY_VOLUME 等）</span></span><br><span class="line">    UCHAR Control;           <span class="comment">// 0x3 I/O 子系统内部控制标志</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 📌参数联合体：根据不同的 MajorFunction 类型，使用对应的子结构</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  // <span class="title">IRP_MJ_CREATE</span> 使用</span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">IO_SECURITY_CONTEXT</span>* <span class="title">SecurityContext</span>;</span>    <span class="comment">// 0x4 安全上下文</span></span><br><span class="line">            ULONG Options;                                   <span class="comment">// 0x8 创建选项标志 (如 FILE_DIRECTORY_FILE 等)</span></span><br><span class="line">            USHORT FileAttributes;                           <span class="comment">// 0xC 文件属性 (如 FILE_ATTRIBUTE_NORMAL)</span></span><br><span class="line">            USHORT ShareAccess;                              <span class="comment">// 0xE 共享模式 (如 FILE_SHARE_READ)</span></span><br><span class="line">            ULONG EaLength;                                  <span class="comment">// 0x10 EA长度 (扩展属性)</span></span><br><span class="line">        &#125; Create;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  // <span class="title">IRP_MJ_CREATE_NAMED_PIPE</span> 使用</span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">IO_SECURITY_CONTEXT</span>* <span class="title">SecurityContext</span>;</span></span><br><span class="line">            ULONG Options;</span><br><span class="line">            USHORT Reserved;</span><br><span class="line">            USHORT ShareAccess;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">NAMED_PIPE_CREATE_PARAMETERS</span>* <span class="title">Parameters</span>;</span>  <span class="comment">// 0x10 命名管道专用参数</span></span><br><span class="line">        &#125; CreatePipe;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  // <span class="title">IRP_MJ_CREATE_MAILSLOT</span> 使用</span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">IO_SECURITY_CONTEXT</span>* <span class="title">SecurityContext</span>;</span></span><br><span class="line">            ULONG Options;</span><br><span class="line">            USHORT Reserved;</span><br><span class="line">            USHORT ShareAccess;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">MAILSLOT_CREATE_PARAMETERS</span>* <span class="title">Parameters</span>;</span></span><br><span class="line">        &#125; CreateMailslot;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  // <span class="title">IRP_MJ_READ</span> 使用</span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            ULONG Length;             <span class="comment">// 0x4 读取长度</span></span><br><span class="line">            ULONG Key;                <span class="comment">// 0x8 用于文件系统校验等用途</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">ByteOffset</span>;</span>  <span class="comment">// 0xC 读取偏移</span></span><br><span class="line">        &#125; Read;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  // <span class="title">IRP_MJ_WRITE</span> 使用</span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            ULONG Length;   </span><br><span class="line">            ULONG Key;</span><br><span class="line">            <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">ByteOffset</span>;</span></span><br><span class="line">        &#125; Write;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  // <span class="title">IRP_MJ_DEVICE_CONTROL</span> 使用</span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            ULONG OutputBufferLength;   <span class="comment">// 0x4 输出缓冲区长度</span></span><br><span class="line">            ULONG InputBufferLength;    <span class="comment">// 0x8 输入缓冲区长度</span></span><br><span class="line">            ULONG IoControlCode;        <span class="comment">// 0xC IOCTL 控制码</span></span><br><span class="line">            VOID* Type3InputBuffer;     <span class="comment">// 0x10 输入缓冲区指针 (IOCTL第三类缓冲模式用)</span></span><br><span class="line">        &#125; DeviceIoControl;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  // <span class="title">IRP_MJ_FILE_SYSTEM_CONTROL</span> (部分)</span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            ULONG OutputBufferLength;</span><br><span class="line">            ULONG InputBufferLength;</span><br><span class="line">            ULONG FsControlCode;</span><br><span class="line">            VOID* Type3InputBuffer;</span><br><span class="line">        &#125; FileSystemControl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其它子结构太多，简化列出部分常用：</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span> ULONG Length; &#125; SetEa;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span> ULONG Length; <span class="class"><span class="keyword">enum</span> _<span class="title">FILE_INFORMATION_CLASS</span> <span class="title">FileInformationClass</span>;</span> &#125; QueryFile;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="class"><span class="keyword">enum</span> _<span class="title">DEVICE_RELATION_TYPE</span> <span class="title">Type</span>;</span> &#125; QueryDeviceRelations;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="class"><span class="keyword">struct</span> _<span class="title">POWER_SEQUENCE</span>* <span class="title">PowerSequence</span>;</span> &#125; PowerSequence;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SCSI_REQUEST_BLOCK</span>* <span class="title">Srb</span>;</span> &#125; Scsi;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span> VOID* Argument1; VOID* Argument2; VOID* Argument3; VOID* Argument4; &#125; Others;</span><br><span class="line">        <span class="comment">// 还有很多其它子结构，类似逻辑。</span></span><br><span class="line">    &#125; Parameters;  <span class="comment">// 0x4 主参数区</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_OBJECT</span>* <span class="title">DeviceObject</span>;</span>  <span class="comment">// 0x14 当前派发到的设备对象 (本层目标设备)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">FILE_OBJECT</span>* <span class="title">FileObject</span>;</span>      <span class="comment">// 0x18 当前关联的文件对象 (通常在文件操作中使用)</span></span><br><span class="line">    </span><br><span class="line">    LONG (*CompletionRoutine)(<span class="keyword">struct</span> _DEVICE_OBJECT* DeviceObject, <span class="keyword">struct</span> _IRP* Irp, VOID* Context);  </span><br><span class="line">    <span class="comment">// 0x1C 完成例程回调函数指针 (用于注册完成回调逻辑)</span></span><br><span class="line"></span><br><span class="line">    VOID* Context;  <span class="comment">// 0x20 完成例程上下文参数 (传入 CompletionRoutine)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>通常我们会使用 <code>IoGetCurrentIrpStackLocation</code> 从 <code>IRP</code> 结构体中拿当前栈帧对应的 <code>IO_STACK_LOCATION</code> 参数。当然也可以通过 <code>IoGetNextIrpStackLocation</code> 获取下一层栈帧对应的 <code>IO_STACK_LOCATION</code> 参数或者手动解析 <code>IRP</code> 结构体拿任意一层的参数。</p>
<p>不过下一层的 <code>IO_STACK_LOCATION</code> 默认是空白的。如果我们作为过滤驱动，需要通过 <code>IoCopyCurrentIrpStackLocationToNext</code> 函数将当前栈帧中的参数拷贝到下一层才能让下一层的设备对象对应的驱动在当前栈帧中拿到参数。</p>
<p>而如果是底层设备栈的第一层（创建 IRP 时）则内核早已填好栈帧了，不会有这个问题。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">FORCEINLINE</span><br><span class="line">VOID <span class="title function_">IoCopyCurrentIrpStackLocationToNext</span><span class="params">(</span></span><br><span class="line"><span class="params">    _Inout_ PIRP Irp  <span class="comment">// [输入输出] 目标 IRP 指针</span></span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 获取当前栈帧 (当前派发层)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 获取下一层栈帧 (即 IoCallDriver 下一次派发使用的栈帧)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    PIO_STACK_LOCATION nextIrpSp = IoGetNextIrpStackLocation(Irp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 拷贝当前栈帧内容到下一栈帧 (注意只拷贝到 CompletionRoutine 之前的字段)</span></span><br><span class="line">    <span class="comment">// 即：将本层参数 (如 MajorFunction、Parameters、FileObject 等) 直接传递给下一层</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    RtlCopyMemory(</span><br><span class="line">        nextIrpSp,</span><br><span class="line">        irpSp,</span><br><span class="line">        FIELD_OFFSET(IO_STACK_LOCATION, CompletionRoutine)  <span class="comment">// 仅拷贝到 CompletionRoutine 之前</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 清空 Control 字段，保证新派发时控制标志干净</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    nextIrpSp-&gt;Control = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>另外通过 <code>IoSkipCurrentIrpStackLocation</code> 跳过当前设备对象的话也是同样的效果。</p>
<h5 id="返回结构"><a href="#返回结构" class="headerlink" title="返回结构"></a>返回结构</h5><p>对于参数传递，<code>IRP</code> 针对每层的设备对象都有对应的 <code>IO_STACK_LOCATION</code>，然而对于返回值，所有层最终共用同一个 <code>IoStatus</code> 返回区和缓冲区，只要有一层完成请求，设置好 <code>IoStatus.Status</code> 和 <code>IoStatus.Information</code> 即可。</p>
<p><code>IoStatus</code> 是 <code>IRP</code> 结构体中的一个成员，该成员类型为 <code>IO_STATUS_BLOCK</code>，定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0x8 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_STATUS_BLOCK</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        LONG Status;           <span class="comment">// IRP 完成状态码 (NTSTATUS)，表示 I/O 请求执行结果，供内核/用户态读取</span></span><br><span class="line">        VOID* Pointer;         <span class="comment">// 可选指针 (某些异步/特殊I/O场景用，极少用到)</span></span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG Information;         <span class="comment">// 通常存放返回的字节数（如 Read/Write 实际传输数据长度），供用户态API返回</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>Status</code> 最终会变成 Win32 API 的返回值，而 <code>Information</code> 会变成 Win32 API 返回的输出字节数。至于输出的数据的存放位置，这个取决于 <strong>I&#x2F;O 缓冲区管理方式</strong>。</p>
<table>
<thead>
<tr>
<th>I&#x2F;O 缓冲模式</th>
<th>数据缓冲区位置</th>
<th>数据写入哪</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Buffered I&#x2F;O (<code>DO_BUFFERED_IO</code>)</strong></td>
<td><code>Irp-&gt;AssociatedIrp.SystemBuffer</code></td>
<td>驱动填充 <code>SystemBuffer</code>，内核在 <code>IoCompleteRequest()</code> 时拷贝回用户缓冲区</td>
</tr>
<tr>
<td><strong>Direct I&#x2F;O (<code>DO_DIRECT_IO</code>)</strong></td>
<td><code>Irp-&gt;MdlAddress</code>（MDL映射的缓冲区）</td>
<td>驱动使用 <code>MmGetSystemAddressForMdlSafe()</code> 获得内核虚拟地址，直接写入用户缓冲区映射</td>
</tr>
<tr>
<td><strong>Neither I&#x2F;O</strong></td>
<td><code>Irp-&gt;UserBuffer</code>（直接原始用户地址）</td>
<td>驱动直接操作用户缓冲区（前提是地址合法性自己负责验证）</td>
</tr>
</tbody></table>
<h4 id="IRP-派发函数"><a href="#IRP-派发函数" class="headerlink" title="IRP 派发函数"></a>IRP 派发函数</h4><p><strong>IRP 派发函数</strong>是驱动程序中专门处理各类 IRP 请求的回调函数。当 I&#x2F;O 管理器收到用户或内核发起的 I&#x2F;O 请求时，系统会根据 IRP 的 <code>MajorFunction</code> 字段，自动把 IRP 分发到对应的派发函数。</p>
<h5 id="IRP-派发函数类别"><a href="#IRP-派发函数类别" class="headerlink" title="IRP 派发函数类别"></a>IRP 派发函数类别</h5><p>所有 IRP 派发函数的入口存放在 <code>PDRIVER_OBJECT</code> 结构体内的 <code>MajorFunction[]</code> 数组中：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DRIVER_OBJECT</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">  PDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + <span class="number">1</span>];</span><br><span class="line">  ...</span><br><span class="line">&#125; DRIVER_OBJECT, *PDRIVER_OBJECT;</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>MajorFunction</code> 是一个大小为 28 的函数指针数组，每个元素对应一个 IRP MajorFunction 编号，这些编号的宏定义如下：</p>
<table>
<thead>
<tr>
<th>IRP MajorFunction (值)</th>
<th>内核派发说明</th>
<th>Native API (Zw&#x2F;Nt)</th>
<th>Win32 API</th>
</tr>
</thead>
<tbody><tr>
<td><code>IRP_MJ_CREATE (0x00)</code></td>
<td>创建 &#x2F; 打开设备句柄</td>
<td><code>ZwCreateFile()</code> &#x2F; <code>NtCreateFile()</code></td>
<td><code>CreateFile()</code></td>
</tr>
<tr>
<td><code>IRP_MJ_CREATE_NAMED_PIPE (0x01)</code></td>
<td>命名管道专用</td>
<td><code>ZwCreateNamedPipeFile()</code></td>
<td><code>CreateNamedPipe()</code></td>
</tr>
<tr>
<td><code>IRP_MJ_CLOSE (0x02)</code></td>
<td>关闭设备句柄</td>
<td><code>ZwClose()</code></td>
<td><code>CloseHandle()</code></td>
</tr>
<tr>
<td><code>IRP_MJ_READ (0x03)</code></td>
<td>读取设备数据</td>
<td><code>ZwReadFile()</code></td>
<td><code>ReadFile()</code></td>
</tr>
<tr>
<td><code>IRP_MJ_WRITE (0x04)</code></td>
<td>写入设备数据</td>
<td><code>ZwWriteFile()</code></td>
<td><code>WriteFile()</code></td>
</tr>
<tr>
<td><code>IRP_MJ_QUERY_INFORMATION (0x05)</code></td>
<td>查询文件&#x2F;设备信息</td>
<td><code>ZwQueryInformationFile()</code></td>
<td><code>GetFileInformationByHandle()</code></td>
</tr>
<tr>
<td><code>IRP_MJ_SET_INFORMATION (0x06)</code></td>
<td>设置文件&#x2F;设备信息</td>
<td><code>ZwSetInformationFile()</code></td>
<td><code>SetFileInformationByHandle()</code></td>
</tr>
<tr>
<td><code>IRP_MJ_QUERY_EA (0x07)</code></td>
<td>查询扩展属性 (EA)</td>
<td><code>ZwQueryEaFile()</code></td>
<td>无直接 API</td>
</tr>
<tr>
<td><code>IRP_MJ_SET_EA (0x08)</code></td>
<td>设置扩展属性 (EA)</td>
<td><code>ZwSetEaFile()</code></td>
<td>无直接 API</td>
</tr>
<tr>
<td><code>IRP_MJ_FLUSH_BUFFERS (0x09)</code></td>
<td>刷新缓存区</td>
<td><code>ZwFlushBuffersFile()</code></td>
<td><code>FlushFileBuffers()</code></td>
</tr>
<tr>
<td><code>IRP_MJ_QUERY_VOLUME_INFORMATION (0x0A)</code></td>
<td>查询卷信息</td>
<td><code>ZwQueryVolumeInformationFile()</code></td>
<td><code>GetVolumeInformation()</code></td>
</tr>
<tr>
<td><code>IRP_MJ_SET_VOLUME_INFORMATION (0x0B)</code></td>
<td>设置卷信息</td>
<td><code>ZwSetVolumeInformationFile()</code></td>
<td>无直接 API</td>
</tr>
<tr>
<td><code>IRP_MJ_DIRECTORY_CONTROL (0x0C)</code></td>
<td>目录操作</td>
<td><code>ZwQueryDirectoryFile()</code></td>
<td><code>FindFirstFile()</code> &#x2F; <code>FindNextFile()</code></td>
</tr>
<tr>
<td><code>IRP_MJ_FILE_SYSTEM_CONTROL (0x0D)</code></td>
<td>文件系统控制</td>
<td><code>ZwFsControlFile()</code></td>
<td>无直接 API</td>
</tr>
<tr>
<td><code>IRP_MJ_DEVICE_CONTROL (0x0E)</code></td>
<td>设备控制（IOCTL）</td>
<td><code>ZwDeviceIoControlFile()</code></td>
<td><code>DeviceIoControl()</code></td>
</tr>
<tr>
<td><code>IRP_MJ_INTERNAL_DEVICE_CONTROL (0x0F)</code></td>
<td>内部设备控制</td>
<td>内核内部</td>
<td>无</td>
</tr>
<tr>
<td><code>IRP_MJ_SHUTDOWN (0x10)</code></td>
<td>关机通知</td>
<td><code>ZwShutdownSystem()</code></td>
<td>无</td>
</tr>
<tr>
<td><code>IRP_MJ_LOCK_CONTROL (0x11)</code></td>
<td>锁控制</td>
<td><code>ZwLockFile()</code> &#x2F; <code>ZwUnlockFile()</code></td>
<td><code>LockFile()</code> &#x2F; <code>UnlockFile()</code></td>
</tr>
<tr>
<td><code>IRP_MJ_CLEANUP (0x12)</code></td>
<td>句柄清理 (Close 前触发)</td>
<td>自动派发</td>
<td><code>CloseHandle()</code>（间接）</td>
</tr>
<tr>
<td><code>IRP_MJ_CREATE_MAILSLOT (0x13)</code></td>
<td>创建邮件槽</td>
<td><code>ZwCreateMailslotFile()</code></td>
<td><code>CreateMailslot()</code></td>
</tr>
<tr>
<td><code>IRP_MJ_QUERY_SECURITY (0x14)</code></td>
<td>查询安全信息</td>
<td><code>ZwQuerySecurityObject()</code></td>
<td><code>GetSecurityInfo()</code></td>
</tr>
<tr>
<td><code>IRP_MJ_SET_SECURITY (0x15)</code></td>
<td>设置安全信息</td>
<td><code>ZwSetSecurityObject()</code></td>
<td><code>SetSecurityInfo()</code></td>
</tr>
<tr>
<td><code>IRP_MJ_POWER (0x16)</code></td>
<td>电源管理</td>
<td>内核电源管理</td>
<td>无</td>
</tr>
<tr>
<td><code>IRP_MJ_SYSTEM_CONTROL (0x17)</code></td>
<td>WMI控制</td>
<td>WMI子系统派发</td>
<td>WMI系列API</td>
</tr>
<tr>
<td><code>IRP_MJ_DEVICE_CHANGE (0x18)</code></td>
<td>设备插拔通知</td>
<td>自动派发</td>
<td><code>RegisterDeviceNotification()</code> (部分场景)</td>
</tr>
<tr>
<td><code>IRP_MJ_QUERY_QUOTA (0x19)</code></td>
<td>查询磁盘配额</td>
<td><code>ZwQueryQuotaInformationFile()</code></td>
<td>无</td>
</tr>
<tr>
<td><code>IRP_MJ_SET_QUOTA (0x1A)</code></td>
<td>设置磁盘配额</td>
<td><code>ZwSetQuotaInformationFile()</code></td>
<td>无</td>
</tr>
<tr>
<td><code>IRP_MJ_PNP (0x1B)</code></td>
<td>即插即用</td>
<td>PnP子系统派发</td>
<td>设备管理器控制</td>
</tr>
<tr>
<td><code>IRP_MJ_PNP_POWER (0x1B)</code></td>
<td>历史兼容（已废弃别名）</td>
<td>——</td>
<td>——</td>
</tr>
<tr>
<td><code>IRP_MJ_MAXIMUM_FUNCTION (0x1B)</code></td>
<td>内核保留</td>
<td>——</td>
<td>——</td>
</tr>
</tbody></table>
<h5 id="IRP-派发函数类别注册"><a href="#IRP-派发函数类别注册" class="headerlink" title="IRP 派发函数类别注册"></a>IRP 派发函数类别注册</h5><p>每个 IRP 派发函数都有统一的标准函数签名：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">DispatchFunction</span><span class="params">(</span></span><br><span class="line"><span class="params">  PDEVICE_OBJECT DeviceObject,  <span class="comment">// [输入] 当前被调用的设备对象</span></span></span><br><span class="line"><span class="params">  PIRP Irp                      <span class="comment">// [输入] 当前要处理的 IRP 请求包</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>

<p>我们需要在 <code>DriverEntry()</code> 中定义该类型的函数，并将其注册到 <code>MajorFunction[]</code> 数组中。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DriverObject-&gt;MajorFunction[IRP_MJ_CREATE] = DispatchCreate;</span><br><span class="line">DriverObject-&gt;MajorFunction[IRP_MJ_CLOSE] = DispatchClose;</span><br><span class="line">DriverObject-&gt;MajorFunction[IRP_MJ_READ]  = DispatchRead;</span><br><span class="line">DriverObject-&gt;MajorFunction[IRP_MJ_WRITE] = DispatchWrite;</span><br><span class="line">DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = DispatchIoControl;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>最少也要注册 <code>IRP_MJ_CREATE</code> &#x2F; <code>IRP_MJ_CLOSE</code> &#x2F; <code>IRP_MJ_DEVICE_CONTROL</code>，否则基本无法和用户层通信。</p>
<ul>
<li><code>IRP_MJ_CREATE</code> 和 <code>IRP_MJ_DEVICE_CONTROL</code> 保证驱动能和用户交互，</li>
<li><code>IRP_MJ_CLOSE</code> 保证驱动能安全退出。</li>
</ul>

    </div>
  </div>

<h4 id="I-O-缓冲区管理方式"><a href="#I-O-缓冲区管理方式" class="headerlink" title="I&#x2F;O 缓冲区管理方式"></a>I&#x2F;O 缓冲区管理方式</h4><p>在驱动开发中，3 环用户程序与 0 环内核驱动需要频繁交换数据。交换数据的过程中需要内核I&#x2F;O管理器在两者之间做好<strong>地址转换、访问隔离、安全控制</strong>，为此 Windows 提供了 3 种 <strong>I&#x2F;O 缓冲区管理方式</strong>。</p>
<ul>
<li><strong>Buffered I&#x2F;O（系统缓冲 I&#x2F;O）</strong> </li>
<li><strong>Direct I&#x2F;O（直接 I&#x2F;O）</strong></li>
<li><strong>Neither I&#x2F;O（无缓冲 I&#x2F;O）</strong></li>
</ul>
<h5 id="设置-I-O-缓冲区管理方式"><a href="#设置-I-O-缓冲区管理方式" class="headerlink" title="设置 I&#x2F;O 缓冲区管理方式"></a>设置 I&#x2F;O 缓冲区管理方式</h5><p>在 Windows 内核中，用户态与内核态的数据传递的应用主要有两种场景：</p>
<ul>
<li>普通读写：<code>IRP_MJ_READ</code> &#x2F; <code>IRP_MJ_WRITE</code></li>
<li>设备控制：<code>IRP_MJ_DEVICE_CONTROL</code></li>
</ul>
<p>这两种场景的 I&#x2F;O 缓冲区管理方式的设置方法是不同的。</p>
<ul>
<li><p><strong>IRP_MJ_READ &#x2F; IRP_MJ_WRITE</strong> 这种类型的 IRP 派发函数主要由<strong>设备对象 <code>Flags</code></strong> 决定缓冲区模式。</p>
<p>当用户调用 <code>ReadFile()</code> &#x2F; <code>WriteFile()</code> 时，内核通过 IRP 派发到 <code>IRP_MJ_READ</code> &#x2F; <code>IRP_MJ_WRITE</code>。此时内核用 <strong><code>DeviceObject-&gt;Flags</code> 中的缓冲模式标志位</strong> 决定使用哪种缓冲机制：</p>
<ul>
<li><code>DO_BUFFERED_IO</code>：Buffered I&#x2F;O（系统缓冲 I&#x2F;O）</li>
<li><code>DO_DIRECT_IO</code>：Direct I&#x2F;O（直接 I&#x2F;O）</li>
</ul>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <ul>
<li><code>DO_BUFFERED_IO</code> 与 <code>DO_DIRECT_IO</code> 互斥，驱动在创建设备时只需二选一。</li>
<li>如果两个标志都未设置，默认当做 <code>Buffered I/O</code> 处理。</li>
<li><code>IRP_MJ_READ</code> &#x2F; <code>IRP_MJ_WRITE</code> 不存在 Neither I&#x2F;O（无缓冲 I&#x2F;O）模式。</li>
</ul>

    </div>
  </div>
</li>
<li><p><strong>IRP_MJ_DEVICE_CONTROL</strong> 这种类型的 IRP 派发函数主要由 <strong>IOCTL 控制码</strong>决定缓冲区模式。</p>
<p>WDK 提供的 <code>CTL_CODE</code> 宏用于在驱动开发中定义 IOCTL（Input&#x2F;Output Control）和 FSCTL（File System Control）请求的控制码。控制码本质上是一个 32 位整数，四个参数共同编码出一个唯一的请求类型，供内核和驱动识别具体的控制命令。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CTL_CODE(DeviceType, Function, Method, Access) ( \</span></span><br><span class="line"><span class="meta">    ((DeviceType) &lt;&lt; 16) | ((Access) &lt;&lt; 14) | ((Function) &lt;&lt; 2) | (Method) \</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>DeviceType</code>：设备类型代码，占用高 16 位（位 31-16）。如 <code>FILE_DEVICE_UNKNOWN</code>，<code>FILE_DEVICE_DISK</code> 等。由微软规范分配。</li>
<li><code>Access</code>：访问权限，占用 2 位（位 15-14），控制调用时用户需具备的访问权限。常见取值：<ul>
<li><code>FILE_ANY_ACCESS (0)</code>：不做权限限制</li>
<li><code>FILE_READ_ACCESS (1)</code>：需要读权限</li>
<li><code>FILE_WRITE_ACCESS (2)</code>：需要写权限</li>
<li><code>FILE_READ_ACCESS | FILE_WRITE_ACCESS (3)</code>：需同时具备读写权限</li>
</ul>
</li>
<li><code>Function</code>：功能号，占用 12 位（位 13-2），表示具体的功能编号。<ul>
<li>取值范围：0 ~ 4095</li>
<li>其中 0 ~ 2047 为微软保留，2048 ~ 4095 供厂商自定义。</li>
<li>通常你自己写驱动时使用 2048 以上的数字定义私有控制码，避免与系统冲突。</li>
</ul>
</li>
<li><code>Method</code>：缓冲区传递方式，占用 2 位（位 1-0），指定 I&#x2F;O 缓冲机制。对应四种传输模式：<ul>
<li><code>METHOD_BUFFERED (0)</code>：Buffered I&#x2F;O（系统缓冲 I&#x2F;O）</li>
<li><code>METHOD_IN_DIRECT (1)/METHOD_OUT_DIRECT (2)</code>：输入走 Buffered I&#x2F;O（系统缓冲 I&#x2F;O）；输出走 Direct I&#x2F;O（直接 I&#x2F;O）。</li>
<li><code>METHOD_NEITHER (3)</code>：Neither I&#x2F;O（无缓冲 I&#x2F;O）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="Buffered-I-O（系统缓冲-I-O）"><a href="#Buffered-I-O（系统缓冲-I-O）" class="headerlink" title="Buffered I&#x2F;O（系统缓冲 I&#x2F;O）"></a>Buffered I&#x2F;O（系统缓冲 I&#x2F;O）</h5><h5 id="Direct-I-O（直接-I-O）"><a href="#Direct-I-O（直接-I-O）" class="headerlink" title="Direct I&#x2F;O（直接 I&#x2F;O）"></a>Direct I&#x2F;O（直接 I&#x2F;O）</h5><h5 id="Neither-I-O（无缓冲-I-O）"><a href="#Neither-I-O（无缓冲-I-O）" class="headerlink" title="Neither I&#x2F;O（无缓冲 I&#x2F;O）"></a>Neither I&#x2F;O（无缓冲 I&#x2F;O）</h5><h4 id="IRP-派发过程"><a href="#IRP-派发过程" class="headerlink" title="IRP 派发过程"></a>IRP 派发过程</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IoCallDriver(a,b)   \</span></span><br><span class="line"><span class="meta">        IofCallDriver(a,b)</span></span><br><span class="line"></span><br><span class="line">NTSTATUS FASTCALL <span class="title function_">IofCallDriver</span><span class="params">(</span></span><br><span class="line"><span class="params">    IN PDEVICE_OBJECT DeviceObject,</span></span><br><span class="line"><span class="params">    IN OUT PIRP Irp</span></span><br><span class="line"><span class="params">    )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pIofCallDriver != <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 如果开启了 I/O 验证器（Verifier），则这里会跳转到其 Hook 函数 (如 IovCallDriver / IoPerfCallDriver)。</span></span><br><span class="line">        <span class="comment">// 这些 Hook 模块用于在开发调试中插入额外的验证逻辑，辅助检测驱动Bug。</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">return</span> pIofCallDriver(DeviceObject, Irp, _ReturnAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则直接走默认 I/O 派发实现</span></span><br><span class="line">    <span class="keyword">return</span> IopfCallDriver(DeviceObject, Irp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS FORCEINLINE <span class="title function_">IopfCallDriver</span><span class="params">(</span></span><br><span class="line"><span class="params">    IN PDEVICE_OBJECT DeviceObject,</span></span><br><span class="line"><span class="params">    IN OUT PIRP Irp</span></span><br><span class="line"><span class="params">    )</span></span><br><span class="line">&#123;</span><br><span class="line">    PIO_STACK_LOCATION irpSp;</span><br><span class="line">    PDRIVER_OBJECT driverObject;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确认传入的确实是合法 IRP 对象</span></span><br><span class="line">    ASSERT( Irp-&gt;Type == IO_TYPE_IRP );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 核心逻辑：派发 IRP 前先将当前栈位置往下移动一层 (推进派发深度)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Irp-&gt;CurrentLocation--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈溢出检查：若已经到底还继续派发，直接蓝屏（BugCheck）</span></span><br><span class="line">    <span class="keyword">if</span> (Irp-&gt;CurrentLocation &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        KiBugCheck3(NO_MORE_IRP_STACK_LOCATIONS, (ULONG_PTR) Irp, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 计算新的栈帧指针：CurrentStackLocation 始终指向当前要派发的栈帧</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    irpSp = IoGetNextIrpStackLocation(Irp);</span><br><span class="line">    Irp-&gt;Tail.Overlay.CurrentStackLocation = irpSp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 记录本层设备对象指针，供下层驱动获取自身 DeviceObject</span></span><br><span class="line">    <span class="comment">// 通常派发 IRP 时下层驱动通过 irpSp-&gt;DeviceObject 知道自己是谁</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    irpSp-&gt;DeviceObject = DeviceObject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 获取目标驱动对象</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    driverObject = DeviceObject-&gt;DriverObject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 执行派发：调用目标驱动中对应的 MajorFunction 派发入口</span></span><br><span class="line">    <span class="comment">// irpSp-&gt;MajorFunction 记录了当前 IRP 的操作类型 (如 IRP_MJ_READ / IRP_MJ_WRITE 等)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    status = driverObject-&gt;MajorFunction[irpSp-&gt;MajorFunction](DeviceObject, Irp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><h1 id="进程线程"><a href="#进程线程" class="headerlink" title="进程线程"></a>进程线程</h1><h1 id="句柄表"><a href="#句柄表" class="headerlink" title="句柄表"></a>句柄表</h1>
		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> windows 内核态逆向开发</li>
        <li><strong>Author:</strong> sky123</li>
        <li><strong>Created at
                :</strong> 2022-09-28 11:45:14</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2025-06-16 03:28:06
            </li>
        
        <li>
            <strong>Link:</strong> https://skyi23.github.io/2022/09/28/windows 内核态逆向开发/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/windows-kernel-reverse/">#windows kernel reverse</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2022/09/28/windows%20%E7%94%A8%E6%88%B7%E6%80%81%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">windows 用户态逆向开发</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2022/09/28/%E5%BC%82%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">异架构相关</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'skyI23/my-giscus-discussions',
                'data-repo-id': 'R_kgDONL9k_w',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDONL9k_84CkEdK',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">windows 内核态逆向开发</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F"><span class="nav-text">保护模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU-%E7%9A%84%E6%A8%A1%E5%BC%8F"><span class="nav-text">CPU 的模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E6%A8%A1%E5%BC%8F%EF%BC%88Real-Mode%EF%BC%89"><span class="nav-text">实模式（Real Mode）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%EF%BC%88Protected-Mode%EF%BC%89"><span class="nav-text">保护模式（Protected Mode）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F8086%E6%A8%A1%E5%BC%8F%EF%BC%88Virtual-8086-Mode%EF%BC%89"><span class="nav-text">虚拟8086模式（Virtual 8086 Mode）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%9C%B0%E5%9D%80"><span class="nav-text">保护模式下的地址</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%EF%BC%88Logical-Address%EF%BC%89"><span class="nav-text">逻辑地址（Logical Address）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%EF%BC%88Virtual-Address%EF%BC%89"><span class="nav-text">虚拟地址（Virtual Address）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%88Physical-Address%EF%BC%89"><span class="nav-text">物理地址（Physical Address）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AE%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">段式内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88Segment-Registers%EF%BC%89"><span class="nav-text">段寄存器（Segment Registers）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">主要段寄存器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84"><span class="nav-text">段寄存器结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%BB%E5%86%99"><span class="nav-text">段寄存器读写</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">数据段寄存器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">代码段寄存器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%EF%BC%88Descriptor-Table%EF%BC%89"><span class="nav-text">段描述符表（Descriptor Table）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%E7%A7%8D%E7%B1%BB"><span class="nav-text">段描述符表种类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%EF%BC%88GDT-Global-Descriptor-Table%EF%BC%89"><span class="nav-text">全局描述符表（GDT, Global Descriptor Table）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%EF%BC%88LDT-Local-Descriptor-Table%EF%BC%89"><span class="nav-text">局部描述符表（LDT, Local Descriptor Table）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%88Segment-Descriptor%EF%BC%89"><span class="nav-text">段描述符（Segment Descriptor）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AE%B5%E6%9D%83%E9%99%90%E6%A3%80%E6%B5%8B"><span class="nav-text">段权限检测</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E7%B1%BB%E5%9E%8B"><span class="nav-text">权限类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E8%A7%84%E5%88%99"><span class="nav-text">权限规则</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E6%A3%80%E6%B5%8B%E8%A7%84%E5%88%99"><span class="nav-text">权限检测规则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E4%BF%AE%E6%94%B9%E8%A7%84%E5%88%99"><span class="nav-text">权限修改规则</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E9%97%A8"><span class="nav-text">调用门</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-text">门描述符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="nav-text">过程分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B"><span class="nav-text">调用过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E8%BF%87%E7%A8%8B"><span class="nav-text">返回过程</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD"><span class="nav-text">中断</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E6%96%AD"><span class="nav-text">什么是中断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%EF%BC%88IDT-Interrupt-Descriptor-Table%EF%BC%89"><span class="nav-text">中断描述符表（IDT,Interrupt Descriptor Table）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E9%97%A8"><span class="nav-text">中断门</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6-1"><span class="nav-text">门描述符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90-1"><span class="nav-text">过程分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B-1"><span class="nav-text">调用过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E8%BF%87%E7%A8%8B-1"><span class="nav-text">返回过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%B7%E9%98%B1%E9%97%A8"><span class="nav-text">陷阱门</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6-2"><span class="nav-text">门描述符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90-2"><span class="nav-text">过程分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E9%97%A8"><span class="nav-text">任务门</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%88TSS-Descriptor%EF%BC%89"><span class="nav-text">任务段描述符（TSS Descriptor）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88TR%EF%BC%8CTask-Register%EF%BC%89"><span class="nav-text">任务寄存器（TR，Task Register）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E6%AE%B5%EF%BC%88TSS%EF%BC%8CTask-State-Segment%EF%BC%89"><span class="nav-text">任务段（TSS，Task State Segment）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E9%97%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%88Task-Gate-Descriptor%EF%BC%89"><span class="nav-text">任务门描述符（Task Gate Descriptor）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%EF%BC%88%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E6%9C%BA%E5%88%B6%EF%BC%89"><span class="nav-text">调用过程（任务切换机制）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B"><span class="nav-text">任务段描述符调用过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E9%97%A8%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B"><span class="nav-text">任务门调用过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E8%BF%87%E7%A8%8B-2"><span class="nav-text">返回过程</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">页式内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="nav-text">环境配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Windows-XP-32-%E4%BD%8D"><span class="nav-text">Windows XP 32 位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Windows-Vista-7-32-%E4%BD%8D"><span class="nav-text">Windows Vista &#x2F; 7 32 位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Windows-64-%E4%BD%8D"><span class="nav-text">Windows 64 位</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">控制寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CR0"><span class="nav-text">CR0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CR2"><span class="nav-text">CR2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CR3"><span class="nav-text">CR3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CR4"><span class="nav-text">CR4</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CR8"><span class="nav-text">CR8</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E-PAE-%E5%88%86%E9%A1%B5"><span class="nav-text">非 PAE 分页</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="nav-text">页表结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="nav-text">地址转换过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%B5%E7%9B%AE%E5%BD%95%E8%87%AA%E6%98%A0%E5%B0%84"><span class="nav-text">页目录自映射</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8%E5%B1%9E%E6%80%A7"><span class="nav-text">页表属性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CR3-1"><span class="nav-text">CR3</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#PDE"><span class="nav-text">PDE</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#PTE"><span class="nav-text">PTE</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PAE-%E5%88%86%E9%A1%B5"><span class="nav-text">PAE 分页</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84-1"><span class="nav-text">页表结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B-1"><span class="nav-text">地址转换过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%B5%E7%9B%AE%E5%BD%95%E8%87%AA%E6%98%A0%E5%B0%84-1"><span class="nav-text">页目录自映射</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8%E5%B1%9E%E6%80%A7-1"><span class="nav-text">页表属性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CR3-2"><span class="nav-text">CR3</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#PDPTE"><span class="nav-text">PDPTE</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#PDE-1"><span class="nav-text">PDE</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#PTE-1"><span class="nav-text">PTE</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98"><span class="nav-text">缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU-%E7%BC%93%E5%AD%98%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84%EF%BC%88L1-L2-L3%EF%BC%89"><span class="nav-text">CPU 缓存层级结构（L1 &#x2F; L2 &#x2F; L3）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%B1%BB%E5%9E%8B"><span class="nav-text">缓存类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%85%8D%E7%BD%AE%E6%9C%BA%E5%88%B6"><span class="nav-text">缓存类型的配置机制</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TLB%EF%BC%88Translation-Lookaside-Buffer%EF%BC%89"><span class="nav-text">TLB（Translation Lookaside Buffer）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#TLB-%E5%B1%9E%E6%80%A7"><span class="nav-text">TLB 属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TLB-%E7%B1%BB%E5%9E%8B"><span class="nav-text">TLB 类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TLB-%E6%8E%A7%E5%88%B6%E4%BD%8D"><span class="nav-text">TLB 控制位</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TLB-%E5%88%B7%E6%96%B0%E6%96%B9%E5%BC%8F"><span class="nav-text">TLB 刷新方式</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8"><span class="nav-text">驱动</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Windows-%E5%9F%BA%E7%A1%80"><span class="nav-text">Windows 基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1"><span class="nav-text">内核对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="nav-text">设计思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84"><span class="nav-text">内核对象结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-Manager-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-text">Object Manager 命名空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8-API"><span class="nav-text">常用 API</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84"><span class="nav-text">路径</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9B%E7%B1%BB%E5%B8%B8%E8%A7%81%E8%B7%AF%E5%BE%84"><span class="nav-text">四类常见路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E8%A7%A3%E6%9E%90%E9%93%BE%E8%B7%AF"><span class="nav-text">典型解析链路</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text"></span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">驱动基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6"><span class="nav-text">驱动框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E6%9C%8D%E5%8A%A1%E5%90%8D"><span class="nav-text">驱动服务名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E5%8A%A0%E8%BD%BD"><span class="nav-text">驱动加载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SCM-%E5%8A%A0%E8%BD%BD%EF%BC%88%E6%9C%8D%E5%8A%A1%E6%8E%A7%E5%88%B6%E7%AE%A1%E7%90%86%E5%99%A8%EF%BC%89"><span class="nav-text">SCM 加载（服务控制管理器）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E6%B5%81%E7%A8%8B"><span class="nav-text">原理流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-text">示例代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="nav-text">相关命令</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ZwLoadDriver%EF%BC%88%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-%E6%B3%A8%E5%86%8C%E8%A1%A8%EF%BC%89"><span class="nav-text">ZwLoadDriver（系统调用 + 注册表）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E6%B5%81%E7%A8%8B-1"><span class="nav-text">原理流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-1"><span class="nav-text">示例代码</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80"><span class="nav-text">驱动开发基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%A3%E7%A0%81"><span class="nav-text">基本代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD%E6%8A%80%E5%B7%A7"><span class="nav-text">功能技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA"><span class="nav-text">日志输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%AD%E7%82%B9"><span class="nav-text">断点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B"><span class="nav-text">字符串类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#UNICODE-STRING"><span class="nav-text">UNICODE_STRING</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2"><span class="nav-text">字符串转换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="nav-text">常用函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%EF%BC%88LIST-ENTRY%EF%BC%89"><span class="nav-text">双向链表（LIST_ENTRY）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E5%B9%B3%E8%A1%A1%E6%A0%91%E6%A1%86%E6%9E%B6%EF%BC%88RTL-GENERIC-TABLE%EF%BC%89"><span class="nav-text">通用平衡树框架（RTL_GENERIC_TABLE）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8-API-1"><span class="nav-text">常用 API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">内存管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-text">线程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E9%9A%90%E8%97%8F"><span class="nav-text">驱动隐藏</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%90%E8%97%8F%E6%80%9D%E8%B7%AF"><span class="nav-text">隐藏思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%90%E8%97%8F%E6%B5%81%E7%A8%8B"><span class="nav-text">隐藏流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="nav-text">完整代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E9%80%9A%E4%BF%A1"><span class="nav-text">驱动通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E5%AF%B9%E8%B1%A1"><span class="nav-text">设备对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E5%AF%B9%E8%B1%A1%E5%AE%9A%E4%B9%89"><span class="nav-text">设备对象定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA"><span class="nav-text">设备对象创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E5%AF%B9%E8%B1%A1%E9%99%84%E5%8A%A0"><span class="nav-text">设备对象附加</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IRP%EF%BC%88I-O-Request-Packet%EF%BC%89"><span class="nav-text">IRP（I&#x2F;O Request Packet）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IRP-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">IRP 结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#I-O-%E5%B1%82%E5%8F%A0%E6%A0%88"><span class="nav-text">I&#x2F;O 层叠栈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E7%BB%93%E6%9E%84"><span class="nav-text">参数结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%84"><span class="nav-text">返回结构</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IRP-%E6%B4%BE%E5%8F%91%E5%87%BD%E6%95%B0"><span class="nav-text">IRP 派发函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#IRP-%E6%B4%BE%E5%8F%91%E5%87%BD%E6%95%B0%E7%B1%BB%E5%88%AB"><span class="nav-text">IRP 派发函数类别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#IRP-%E6%B4%BE%E5%8F%91%E5%87%BD%E6%95%B0%E7%B1%BB%E5%88%AB%E6%B3%A8%E5%86%8C"><span class="nav-text">IRP 派发函数类别注册</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#I-O-%E7%BC%93%E5%86%B2%E5%8C%BA%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-text">I&#x2F;O 缓冲区管理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE-I-O-%E7%BC%93%E5%86%B2%E5%8C%BA%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-text">设置 I&#x2F;O 缓冲区管理方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Buffered-I-O%EF%BC%88%E7%B3%BB%E7%BB%9F%E7%BC%93%E5%86%B2-I-O%EF%BC%89"><span class="nav-text">Buffered I&#x2F;O（系统缓冲 I&#x2F;O）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Direct-I-O%EF%BC%88%E7%9B%B4%E6%8E%A5-I-O%EF%BC%89"><span class="nav-text">Direct I&#x2F;O（直接 I&#x2F;O）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Neither-I-O%EF%BC%88%E6%97%A0%E7%BC%93%E5%86%B2-I-O%EF%BC%89"><span class="nav-text">Neither I&#x2F;O（无缓冲 I&#x2F;O）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IRP-%E6%B4%BE%E5%8F%91%E8%BF%87%E7%A8%8B"><span class="nav-text">IRP 派发过程</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-text">系统调用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B"><span class="nav-text">进程线程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%A5%E6%9F%84%E8%A1%A8"><span class="nav-text">句柄表</span></a></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2024</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">sky123</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        35 posts in total
                    </span>
                    
                        <span>
                            574.9k words in total
                        </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>



<script src="/js/build/libs/Swup.min.js"></script>

<script src="/js/build/libs/SwupSlideTheme.min.js"></script>

<script src="/js/build/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/build/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/build/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/build/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	
<script src="/js/build/tools/imageViewer.js" type="module"></script>

<script src="/js/build/utils.js" type="module"></script>

<script src="/js/build/main.js" type="module"></script>

<script src="/js/build/layouts/navbarShrink.js" type="module"></script>

<script src="/js/build/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/build/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/build/layouts/categoryList.js" type="module"></script>



    
<script src="/js/build/tools/localSearch.js" type="module"></script>




    
<script src="/js/build/tools/codeBlock.js" type="module"></script>




    
<script src="/js/build/layouts/lazyload.js" type="module"></script>




    
<script src="/js/build/tools/runtime.js"></script>

    
<script src="/js/build/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/build/libs/Typed.min.js"></script>

  
<script src="/js/build/plugins/typed.js" type="module"></script>




    
        
<script src="/js/build/libs/mermaid.min.js"></script>

    
    
<script src="/js/build/plugins/mermaid.js"></script>






    
<script src="/js/build/libs/anime.min.js"></script>





    
<script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script>





    
<script src="/js/build/layouts/bookmarkNav.js" type="module"></script>


	
</body>

</html>