<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="sky123">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://skyi23.github.io/2022/09/28/windows 进程线程/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/null" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/null">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/null">
    <!--- Page Info-->
    
    <title>
        
            windows 进程线程 | sky123&#39;s site
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/css/build/tailwind.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" rel="stylesheet">
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"skyi23.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":true,"family":"JetBrains Mono","url":"https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap"}},"toc":{"enable":true,"max_depth":5,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"open_graph":{"enable":false,"image":"/images/redefine-og.webp","description":"Hexo Theme Redefine, Redefine Your Hexo Journey."},"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"sky123's blog","subtitle":{"text":["书有未曾经我读，事无不可对人言"],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":true,"version":"11.4.1"}},"version":"2.8.2","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"分类":{"icon":"fa-solid fa-folder","path":"/categories/"},"标签":{"icon":"fa-solid fa-tags","path":"/tags/"},"书签":{"icon":"fa-solid fa-bookmark","path":"/bookmarks/"}},"search":{"enable":true,"preload":true}},"page_templates":{"bookmarks_column":3,"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2024/11/7 00:00:00"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha256-TThEtR+XalhWKkfF383YLOrI50NGNeIqrzS+q08afrY=" crossorigin="anonymous"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>



<body>
	<div class="progress-bar-container">
	
	<span class="scroll-progress-bar"></span>
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                sky123&#39;s site
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/categories/"
                                        >
                                    <i class="fa-solid fa-folder fa-fw"></i>
                                    分类
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/tags/"
                                        >
                                    <i class="fa-solid fa-tags fa-fw"></i>
                                    标签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/bookmarks/"
                                        >
                                    <i class="fa-solid fa-bookmark fa-fw"></i>
                                    书签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/categories/"
                        >
                            <span>
                                分类
                            </span>
                            
                                <i class="fa-solid fa-folder fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/tags/"
                        >
                            <span>
                                标签
                            </span>
                            
                                <i class="fa-solid fa-tags fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/bookmarks/"
                        >
                            <span>
                                书签
                            </span>
                            
                                <i class="fa-solid fa-bookmark fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">11</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">14</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">39</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">windows 进程线程</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/icon.jpg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">sky123</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2022-09-28 11:45:14</span>
        <span class="mobile">2022-09-28 11:45:14</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-07-01 10:04</span>
            <span class="mobile">2025-07-01 10:04</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/reverse/">reverse</a>&nbsp;
                        </li>
                    
                    
                
                    
                        
                            <li>></li>
                        
                        <li>
                            <a href="/categories/reverse/windows-kernel/">windows kernel</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/windows-kernel-reverse/">windows kernel reverse</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>24.4k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>102 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<p><a class="link"   target="_blank" rel="noopener" href="https://www.vergiliusproject.com/" >https://www.vergiliusproject.com/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h1 id="KPCR"><a href="#KPCR" class="headerlink" title="KPCR"></a>KPCR</h1><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0x3748 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">KPCR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">NT_TIB</span> <span class="title">NtTib</span>;</span>                                              <span class="comment">// 0x00: 用户模式线程信息（TEB 的一部分）</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span>* <span class="title">Used_ExceptionList</span>;</span>     <span class="comment">// 0x00: 当前线程异常链表（与 fs:[0] 一致）</span></span><br><span class="line">            VOID* Used_StackBase;                                          <span class="comment">// 0x04: 当前线程栈顶指针</span></span><br><span class="line">            VOID* Spare2;                                                 <span class="comment">// 0x08: 保留字段</span></span><br><span class="line">            VOID* TssCopy;                                                <span class="comment">// 0x0C: 当前处理器使用的 TSS（任务状态段）地址（调度中用于设置 esp0）</span></span><br><span class="line">            ULONG ContextSwitches;                                        <span class="comment">// 0x10: 当前处理器发生的上下文切换次数（调度计数）</span></span><br><span class="line">            ULONG SetMemberCopy;                                          <span class="comment">// 0x14: 当前 CPU 在处理器集合中的位图（如 PRCB SetMember）</span></span><br><span class="line">            VOID* Used_Self;                                              <span class="comment">// 0x18: 指向当前线程的 TEB（Thread Environment Block）</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KPCR</span>* <span class="title">SelfPcr</span>;</span>                                                <span class="comment">// 0x1C: 自身 KPCR 地址，用于快速访问自身结构（fs:[1Ch]）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KPRCB</span>* <span class="title">Prcb</span>;</span>                                                  <span class="comment">// 0x20: 指向当前处理器的 PRCB（每核一个）</span></span><br><span class="line">    UCHAR Irql;                                                           <span class="comment">// 0x24: 当前处理器的 IRQL（中断优先级级别）</span></span><br><span class="line">    ULONG IRR;                                                            <span class="comment">// 0x28: 中断请求寄存器值（仅软件模拟）</span></span><br><span class="line">    ULONG IrrActive;                                                      <span class="comment">// 0x2C: 当前激活的 IRR 位（软中断管理）</span></span><br><span class="line">    ULONG IDR;                                                            <span class="comment">// 0x30: 中断分发寄存器（Interrupt Dispatch Register）</span></span><br><span class="line">    VOID* KdVersionBlock;                                                 <span class="comment">// 0x34: 用于内核调试器的版本信息块</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KIDTENTRY</span>* <span class="title">IDT</span>;</span>                                               <span class="comment">// 0x38: 中断描述符表（IDT）指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KGDTENTRY</span>* <span class="title">GDT</span>;</span>                                               <span class="comment">// 0x3C: 全局描述符表（GDT）指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KTSS</span>* <span class="title">TSS</span>;</span>                                                    <span class="comment">// 0x40: TSS 指针（可能为历史保留字段，实际调度用 TssCopy）</span></span><br><span class="line">    USHORT MajorVersion;                                                  <span class="comment">// 0x44: KPCR 主版本号</span></span><br><span class="line">    USHORT MinorVersion;                                                  <span class="comment">// 0x46: KPCR 次版本号</span></span><br><span class="line">    ULONG SetMember;                                                      <span class="comment">// 0x48: 当前处理器的位标识（如 1 &lt;&lt; ProcessorNumber）</span></span><br><span class="line">    ULONG StallScaleFactor;                                               <span class="comment">// 0x4C: 延迟循环校准比例，用于时间延迟函数（KeStallExecutionProcessor）</span></span><br><span class="line">    UCHAR SpareUnused;                                                    <span class="comment">// 0x50: 未使用（可能为对齐用途）</span></span><br><span class="line">    UCHAR Number;                                                         <span class="comment">// 0x51: 当前处理器编号（Processor Number）</span></span><br><span class="line">    UCHAR Spare0;                                                         <span class="comment">// 0x52: 保留</span></span><br><span class="line">    UCHAR SecondLevelCacheAssociativity;                                  <span class="comment">// 0x53: 二级缓存的相联度</span></span><br><span class="line">    ULONG VdmAlert;                                                       <span class="comment">// 0x54: 虚拟 DOS 模式支持相关（V86 模式通知）</span></span><br><span class="line">    ULONG KernelReserved[<span class="number">14</span>];                                             <span class="comment">// 0x58: 内核保留字段（未公开使用）</span></span><br><span class="line">    ULONG SecondLevelCacheSize;                                           <span class="comment">// 0x90: 当前处理器二级缓存大小（单位：字节）</span></span><br><span class="line">    ULONG HalReserved[<span class="number">16</span>];                                                <span class="comment">// 0x94: HAL 保留字段（如 ACPI/APIC 中断管理）</span></span><br><span class="line">    ULONG InterruptMode;                                                  <span class="comment">// 0xD4: 中断控制模式（边沿/电平等）</span></span><br><span class="line">    UCHAR Spare1;                                                         <span class="comment">// 0xD8: 保留（对齐或系统保留）</span></span><br><span class="line">    ULONG KernelReserved2[<span class="number">17</span>];                                            <span class="comment">// 0xDC: 更多内核保留字段（结构对齐 + Future use）</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KPRCB</span> <span class="title">PrcbData</span>;</span>                                               <span class="comment">// 0x120: 当前处理器的 PRCB 数据区（调度器核心状态）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>



<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">KPRCB</span> &#123;</span></span><br><span class="line">    USHORT MinorVersion;                          <span class="comment">// 0x0: PRCB 的结构版本号低位，用于内核组件检查兼容性</span></span><br><span class="line">    USHORT MajorVersion;                          <span class="comment">// 0x2: PRCB 的结构版本号高位，配合 MinorVersion 共同判断结构版本</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KTHREAD</span>* <span class="title">CurrentThread</span>;</span>               <span class="comment">// 0x4: 当前处理器正在执行的线程，线程调度切换的来源</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KTHREAD</span>* <span class="title">NextThread</span>;</span>                  <span class="comment">// 0x8: 被计划切换到当前处理器的线程，参与调度选择</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KTHREAD</span>* <span class="title">IdleThread</span>;</span>                  <span class="comment">// 0xc: 当无其他线程可调度时绑定的空闲线程，用于节能或等待</span></span><br><span class="line">    UCHAR LegacyNumber;                           <span class="comment">// 0x10: 逻辑处理器编号（旧逻辑），用于与历史多处理器调度逻辑兼容</span></span><br><span class="line">    UCHAR NestingLevel;                           <span class="comment">// 0x11: 中断嵌套层级，嵌套越深表示处于更深层次中断或异常中</span></span><br><span class="line">    USHORT BuildType;                             <span class="comment">// 0x12: 内核构建类型（如调试/零售版本）影响行为检查和断言启用</span></span><br><span class="line">    CHAR CpuType;                                 <span class="comment">// 0x14: 当前处理器的类型编码，用于平台差异判断</span></span><br><span class="line">    CHAR CpuID;                                   <span class="comment">// 0x15: 当前处理器的具体实现编号</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        USHORT CpuStep;                           <span class="comment">// 0x16: 汇总的 CPU 步进信息，含型号与修订</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR CpuStepping;                    <span class="comment">// 0x16: CPU 的修订版本（如 A0/B1 步进）</span></span><br><span class="line">            UCHAR CpuModel;                       <span class="comment">// 0x17: CPU 的型号编号，区别不同微架构</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KPROCESSOR_STATE</span> <span class="title">ProcessorState</span>;</span>      <span class="comment">// 0x18: 当前处理器完整的寄存器上下文，用于异常与上下文切换保存</span></span><br><span class="line">    ULONG KernelReserved[<span class="number">16</span>];                     <span class="comment">// 0x338: 内核保留空间，供未来扩展或临时变量使用</span></span><br><span class="line">    ULONG HalReserved[<span class="number">16</span>];                        <span class="comment">// 0x378: 硬件抽象层保留空间，与底层硬件配置和状态相关</span></span><br><span class="line">    ULONG CFlushSize;                             <span class="comment">// 0x3b8: Cache 刷新操作的粒度大小（字节）</span></span><br><span class="line">    UCHAR CoresPerPhysicalProcessor;              <span class="comment">// 0x3bc: 每个物理处理器所包含的核心数，用于调度拓扑</span></span><br><span class="line">    UCHAR LogicalProcessorsPerCore;               <span class="comment">// 0x3bd: 每个核心上的逻辑处理器数量（如支持超线程时为 2）</span></span><br><span class="line">    UCHAR PrcbPad0[<span class="number">2</span>];                            <span class="comment">// 0x3be: 对齐填充字节，无具体功能</span></span><br><span class="line">    ULONG MHz;                                    <span class="comment">// 0x3c0: 当前处理器运行频率（单位 MHz）</span></span><br><span class="line">    UCHAR CpuVendor;                              <span class="comment">// 0x3c4: CPU 厂商标识（如 Intel、AMD）</span></span><br><span class="line">    UCHAR GroupIndex;                             <span class="comment">// 0x3c5: 所属调度组的索引值</span></span><br><span class="line">    USHORT Group;                                 <span class="comment">// 0x3c6: 所在的处理器组编号（支持多组时使用）</span></span><br><span class="line">    ULONG GroupSetMember;                         <span class="comment">// 0x3c8: 当前处理器在组内的成员掩码</span></span><br><span class="line">    ULONG Number;                                 <span class="comment">// 0x3cc: 当前 PRCB 的编号（即逻辑处理器号）</span></span><br><span class="line">    UCHAR PrcbPad1[<span class="number">72</span>];                           <span class="comment">// 0x3d0: 对齐与保留空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KSPIN_LOCK_QUEUE</span> <span class="title">LockQueue</span>[17];</span>       <span class="comment">// 0x418: 自旋锁队列数组，表示多个锁的排队状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KTHREAD</span>* <span class="title">NpxThread</span>;</span>                   <span class="comment">// 0x4a0: 当前使用浮点/扩展寄存器状态的线程</span></span><br><span class="line">    ULONG InterruptCount;                         <span class="comment">// 0x4a4: 当前处理器累计接收中断的次数</span></span><br><span class="line">    ULONG KernelTime;                             <span class="comment">// 0x4a8: 当前线程在内核态所运行的时间累计</span></span><br><span class="line">    ULONG UserTime;                               <span class="comment">// 0x4ac: 当前线程在用户态所运行的时间累计</span></span><br><span class="line">    ULONG DpcTime;                                <span class="comment">// 0x4b0: DPC（延迟过程调用）占用的处理器时间</span></span><br><span class="line">    ULONG DpcTimeCount;                           <span class="comment">// 0x4b4: DPC 调用次数计数</span></span><br><span class="line">    ULONG InterruptTime;                          <span class="comment">// 0x4b8: 处理器用于处理中断的时间累计</span></span><br><span class="line">    ULONG AdjustDpcThreshold;                     <span class="comment">// 0x4bc: 动态调整 DPC 的调度触发阈值，用于自适应优化</span></span><br><span class="line">    ULONG PageColor;                              <span class="comment">// 0x4c0: 当前处理器页分配颜色值，影响缓存局部性</span></span><br><span class="line">    UCHAR DebuggerSavedIRQL;                      <span class="comment">// 0x4c4: 调试器保存的中断优先级级别</span></span><br><span class="line">    UCHAR NodeColor;                              <span class="comment">// 0x4c5: NUMA 节点着色标识，用于内存分配优化</span></span><br><span class="line">    UCHAR PrcbPad20[<span class="number">2</span>];                           <span class="comment">// 0x4c6: 对齐用填充字节</span></span><br><span class="line">    ULONG NodeShiftedColor;                       <span class="comment">// 0x4c8: 页颜色值向左移位后的结果（结合 NUMA 计算）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KNODE</span>* <span class="title">ParentNode</span>;</span>                    <span class="comment">// 0x4cc: 指向所属 NUMA 节点的数据结构</span></span><br><span class="line">    ULONG SecondaryColorMask;                     <span class="comment">// 0x4d0: 用于二级着色策略的掩码值（高级页分配策略）</span></span><br><span class="line">    ULONG DpcTimeLimit;                           <span class="comment">// 0x4d4: 每次 DPC 执行的最大时间限制（单位 Tick）</span></span><br><span class="line">    ULONG PrcbPad21[<span class="number">2</span>];                           <span class="comment">// 0x4d8: 保留填充字段</span></span><br><span class="line">    ULONG CcFastReadNoWait;                       <span class="comment">// 0x4e0: Fast I/O 快速读取（无等待）命中的次数</span></span><br><span class="line">    ULONG CcFastReadWait;                         <span class="comment">// 0x4e4: Fast I/O 快速读取发生等待后完成的次数</span></span><br><span class="line">    ULONG CcFastReadNotPossible;                  <span class="comment">// 0x4e8: Fast I/O 快速路径不可用的尝试次数</span></span><br><span class="line">    ULONG CcCopyReadNoWait;                       <span class="comment">// 0x4ec: CopyRead 操作中无等待直接完成的次数</span></span><br><span class="line">    ULONG CcCopyReadWait;                         <span class="comment">// 0x4f0: CopyRead 操作等待后完成的次数</span></span><br><span class="line">    ULONG CcCopyReadNoWaitMiss;                   <span class="comment">// 0x4f4: CopyRead 快速路径失败的次数（进入慢路径）</span></span><br><span class="line">    <span class="keyword">volatile</span> LONG MmSpinLockOrdering;             <span class="comment">// 0x4f8: 内存管理中锁获取顺序调试字段，用于死锁检测</span></span><br><span class="line">    <span class="keyword">volatile</span> LONG IoReadOperationCount;           <span class="comment">// 0x4fc: 当前处理器累计发出的 IO 读操作次数</span></span><br><span class="line">    <span class="keyword">volatile</span> LONG IoWriteOperationCount;          <span class="comment">// 0x500: 当前处理器累计发出的 IO 写操作次数</span></span><br><span class="line">    <span class="keyword">volatile</span> LONG IoOtherOperationCount;          <span class="comment">// 0x504: 其他类型 IO 操作（如设备控制）计数</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">IoReadTransferCount</span>;</span>     <span class="comment">// 0x508: IO 读请求累计传输的总字节数</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">IoWriteTransferCount</span>;</span>    <span class="comment">// 0x510: IO 写请求累计传输的总字节数</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">IoOtherTransferCount</span>;</span>    <span class="comment">// 0x518: IO 控制/分页等其他操作的传输总字节数</span></span><br><span class="line">    ULONG CcFastMdlReadNoWait;                    <span class="comment">// 0x520: 使用 MDL 的快速读取操作（无等待）成功次数</span></span><br><span class="line">    ULONG CcFastMdlReadWait;                      <span class="comment">// 0x524: 使用 MDL 的快速读取操作发生等待的次数</span></span><br><span class="line">    ULONG CcFastMdlReadNotPossible;               <span class="comment">// 0x528: 无法执行快速 MDL 读取的尝试次数</span></span><br><span class="line">    ULONG CcMapDataNoWait;                        <span class="comment">// 0x52c: 映射数据页操作中无需等待即成功的次数</span></span><br><span class="line">    ULONG CcMapDataWait;                          <span class="comment">// 0x530: 映射数据页操作发生等待后完成的次数</span></span><br><span class="line">    ULONG CcPinMappedDataCount;                   <span class="comment">// 0x534: 被固定映射的数据页数量，防止被分页或清除</span></span><br><span class="line">    ULONG CcPinReadNoWait;                        <span class="comment">// 0x538: 固定数据页后读取（无等待）成功的次数</span></span><br><span class="line">    ULONG CcPinReadWait;                          <span class="comment">// 0x53c: 固定数据页后读取发生等待的次数</span></span><br><span class="line">    ULONG CcMdlReadNoWait;                        <span class="comment">// 0x540: 使用 MDL 的无等待读取次数</span></span><br><span class="line">    ULONG CcMdlReadWait;                          <span class="comment">// 0x544: 使用 MDL 的读取操作发生等待的次数</span></span><br><span class="line">    ULONG CcLazyWriteHotSpots;                    <span class="comment">// 0x548: Lazy Writer 命中的热点页数量</span></span><br><span class="line">    ULONG CcLazyWriteIos;                         <span class="comment">// 0x54c: Lazy Writer 触发的实际写入 IO 次数</span></span><br><span class="line">    ULONG CcLazyWritePages;                       <span class="comment">// 0x550: Lazy Writer 写出的页数总计</span></span><br><span class="line">    ULONG CcDataFlushes;                          <span class="comment">// 0x554: 数据缓存主动刷新次数（由系统调用等触发）</span></span><br><span class="line">    ULONG CcDataPages;                            <span class="comment">// 0x558: 被刷新操作影响的数据页总数</span></span><br><span class="line">    ULONG CcLostDelayedWrites;                    <span class="comment">// 0x55c: 丢失的延迟写记录次数（写回前被删除或失败）</span></span><br><span class="line">    ULONG CcFastReadResourceMiss;                 <span class="comment">// 0x560: Fast I/O 快速读取因资源竞争（如锁被占用）而失败的次数</span></span><br><span class="line">    ULONG CcCopyReadWaitMiss;                     <span class="comment">// 0x564: CopyRead 操作尝试快速路径但因等待失败进入慢路径的次数</span></span><br><span class="line">    ULONG CcFastMdlReadResourceMiss;              <span class="comment">// 0x568: 快速 MDL 读取因锁或资源冲突失败的尝试次数</span></span><br><span class="line">    ULONG CcMapDataNoWaitMiss;                    <span class="comment">// 0x56c: 映射数据页的快速路径失败的次数（需等待资源）</span></span><br><span class="line">    ULONG CcMapDataWaitMiss;                      <span class="comment">// 0x570: 映射数据页在等待后仍失败的次数（如被抢占）</span></span><br><span class="line">    ULONG CcPinReadNoWaitMiss;                    <span class="comment">// 0x574: 固定页读取尝试无等待路径失败的次数</span></span><br><span class="line">    ULONG CcPinReadWaitMiss;                      <span class="comment">// 0x578: 固定页读取在等待后仍失败的次数</span></span><br><span class="line">    ULONG CcMdlReadNoWaitMiss;                    <span class="comment">// 0x57c: MDL 读取尝试快速路径失败的次数</span></span><br><span class="line">    ULONG CcMdlReadWaitMiss;                      <span class="comment">// 0x580: MDL 读取在等待后仍然失败的次数</span></span><br><span class="line">    ULONG CcReadAheadIos;                         <span class="comment">// 0x584: 后台预读操作产生的 IO 次数（提高性能）</span></span><br><span class="line">    ULONG KeAlignmentFixupCount;                 <span class="comment">// 0x588: 因对齐错误而触发修复的异常次数（通常为非对齐内存访问）</span></span><br><span class="line">    ULONG KeExceptionDispatchCount;              <span class="comment">// 0x58c: 异常调度处理的次数（如访问冲突、除零）</span></span><br><span class="line">    ULONG KeSystemCalls;                         <span class="comment">// 0x590: 当前处理器处理的系统调用总次数</span></span><br><span class="line">    ULONG AvailableTime;                         <span class="comment">// 0x594: 当前处理器可用于调度的时间窗口（单位为 tick）</span></span><br><span class="line">    ULONG PrcbPad22[<span class="number">2</span>];                          <span class="comment">// 0x598: 保留字段，对齐用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">PP_LOOKASIDE_LIST</span> <span class="title">PPLookasideList</span>[16];</span> <span class="comment">// 0x5a0: 预分配非分页内存池 Lookaside 列表数组（提升分配效率）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">GENERAL_LOOKASIDE_POOL</span> <span class="title">PPNPagedLookasideList</span>[32];</span> <span class="comment">// 0x620: 用于非分页内存池的小块分配优化结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">GENERAL_LOOKASIDE_POOL</span> <span class="title">PPPagedLookasideList</span>[32];</span> <span class="comment">// 0xf20: 用于分页内存池的小块分配优化结构</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONG PacketBarrier;                <span class="comment">// 0x1820: 同步屏障，确保处理器间的数据一致性操作按顺序生效</span></span><br><span class="line">    <span class="keyword">volatile</span> LONG ReverseStall;                  <span class="comment">// 0x1824: 调试/性能监控字段，用于反向暂停信号</span></span><br><span class="line">    VOID* IpiFrame;                              <span class="comment">// 0x1828: IPI（中断）处理使用的帧缓存</span></span><br><span class="line">    UCHAR PrcbPad3[<span class="number">52</span>];                          <span class="comment">// 0x182c: 填充保留字段</span></span><br><span class="line">    VOID* <span class="keyword">volatile</span> CurrentPacket[<span class="number">3</span>];             <span class="comment">// 0x1860: 当前 IPI 通信处理的数据包（3 个参数）</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONG TargetSet;                    <span class="comment">// 0x186c: IPI 的目标处理器集合（掩码）</span></span><br><span class="line">    VOID (* <span class="keyword">volatile</span> WorkerRoutine)(VOID*, VOID*, VOID*, VOID*); <span class="comment">// 0x1870: 用于执行调度工作项的通用函数指针</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONG IpiFrozen;                    <span class="comment">// 0x1874: 当前处理器是否被冻结（用于停核或调试）</span></span><br><span class="line">    UCHAR PrcbPad4[<span class="number">40</span>];                          <span class="comment">// 0x1878: 对齐与保留字段</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONG RequestSummary;               <span class="comment">// 0x18a0: 当前处理器接收的请求概要标志位（调度/DPC/异步操作）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KPRCB</span>* <span class="title">volatile</span> <span class="title">SignalDone</span>;</span>          <span class="comment">// 0x18a4: IPI 通信完成信号指针，接收方写入确认</span></span><br><span class="line">    UCHAR PrcbPad50[<span class="number">56</span>];                         <span class="comment">// 0x18a8: 填充空间，供扩展使用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KDPC_DATA</span> <span class="title">DpcData</span>[2];</span>                <span class="comment">// 0x18e0: DPC 调度队列数据（Normal 和 Threaded 两类）</span></span><br><span class="line">    VOID* DpcStack;                              <span class="comment">// 0x1908: 当前正在使用的 DPC 栈地址</span></span><br><span class="line">    LONG MaximumDpcQueueDepth;                   <span class="comment">// 0x190c: DPC 队列允许的最大深度，超过后触发立即执行</span></span><br><span class="line">    ULONG DpcRequestRate;                        <span class="comment">// 0x1910: DPC 请求速率统计值（单位时间内请求次数）</span></span><br><span class="line">    ULONG MinimumDpcRate;                        <span class="comment">// 0x1914: 最小允许的 DPC 请求速率，低于此速率可降频</span></span><br><span class="line">    ULONG DpcLastCount;                          <span class="comment">// 0x1918: 上次计数周期内处理的 DPC 数量</span></span><br><span class="line">    ULONG PrcbLock;                              <span class="comment">// 0x191c: 用于保护 PRCB 内部数据结构的自旋锁</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KGATE</span> <span class="title">DpcGate</span>;</span>                       <span class="comment">// 0x1920: DPC 同步门，用于协调 DPC 激活与处理器休眠</span></span><br><span class="line">    UCHAR ThreadDpcEnable;                       <span class="comment">// 0x1930: 指示当前线程是否允许执行 DPC（线程局部控制）</span></span><br><span class="line">    <span class="keyword">volatile</span> UCHAR QuantumEnd;                   <span class="comment">// 0x1931: 标识是否到达线程的时间片末尾（触发调度）</span></span><br><span class="line">    <span class="keyword">volatile</span> UCHAR DpcRoutineActive;             <span class="comment">// 0x1932: 当前处理器是否正在执行 DPC（防止嵌套）</span></span><br><span class="line">    <span class="keyword">volatile</span> UCHAR IdleSchedule;                 <span class="comment">// 0x1933: 指示是否处于空闲线程调度状态</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">volatile</span> LONG DpcRequestSummary;         <span class="comment">// 0x1934: DPC 请求标志位（包括 Timer/DPC/Idle）</span></span><br><span class="line">        SHORT DpcRequestSlot[<span class="number">2</span>];                 <span class="comment">//         拆分视图：表示不同类型的 DPC 请求</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            SHORT NormalDpcState;                <span class="comment">//         普通 DPC 状态标志</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="keyword">volatile</span> USHORT DpcThreadActive : <span class="number">1</span>; <span class="comment">//     表示线程 DPC 是否处于活动状态</span></span><br><span class="line">                SHORT ThreadDpcState;            <span class="comment">//         线程 DPC 的完整状态位（包含是否运行/启用）</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">volatile</span> ULONG TimerHand;                    <span class="comment">// 0x1938: 当前处理器计时器扫描器的位置</span></span><br><span class="line">    ULONG LastTick;                              <span class="comment">// 0x193c: 上一次系统 tick 的时间戳</span></span><br><span class="line">    LONG MasterOffset;                           <span class="comment">// 0x1940: 在多处理器系统中记录主处理器的时间偏移</span></span><br><span class="line">    ULONG PrcbPad41[<span class="number">2</span>];                          <span class="comment">// 0x1944: 填充字段</span></span><br><span class="line">    ULONG PeriodicCount;                         <span class="comment">// 0x194c: 周期性计数器，用于触发周期任务（如调度）</span></span><br><span class="line">    ULONG PeriodicBias;                          <span class="comment">// 0x1950: 周期性偏移值，用于负载均衡</span></span><br><span class="line">    ULONGLONG TickOffset;                        <span class="comment">// 0x1958: 当前 tick 偏移值，用于时间轮精确推进</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KTIMER_TABLE</span> <span class="title">TimerTable</span>;</span>             <span class="comment">// 0x1960: 当前处理器的内核计时器表（高效定时器轮）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KDPC</span> <span class="title">CallDpc</span>;</span>                        <span class="comment">// 0x31a0: 用于通用函数调度的 DPC 对象</span></span><br><span class="line">    LONG ClockKeepAlive;                         <span class="comment">// 0x31c0: 防止处理器休眠的保持计数（如调试、实时线程）</span></span><br><span class="line">    UCHAR ClockCheckSlot;                        <span class="comment">// 0x31c4: 时钟检查槽位编号，用于统计校准</span></span><br><span class="line">    UCHAR ClockPollCycle;                        <span class="comment">// 0x31c5: 用于控制时钟轮询周期（优化性能）</span></span><br><span class="line">    UCHAR PrcbPad6[<span class="number">2</span>];                           <span class="comment">// 0x31c6: 填充字段</span></span><br><span class="line">    LONG DpcWatchdogPeriod;                      <span class="comment">// 0x31c8: DPC 看门狗触发周期阈值（单位 tick）</span></span><br><span class="line">    LONG DpcWatchdogCount;                       <span class="comment">// 0x31cc: 累计检测到 DPC 执行超时的次数</span></span><br><span class="line">    LONG ThreadWatchdogPeriod;                   <span class="comment">// 0x31d0: 线程执行看门狗周期（用于检测卡死）</span></span><br><span class="line">    LONG ThreadWatchdogCount;                    <span class="comment">// 0x31d4: 累计触发线程看门狗的次数</span></span><br><span class="line">    <span class="keyword">volatile</span> LONG KeSpinLockOrdering;            <span class="comment">// 0x31d8: 内核锁顺序调试字段，用于检查死锁问题</span></span><br><span class="line">    ULONG PrcbPad70[<span class="number">1</span>];                          <span class="comment">// 0x31dc: 填充空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">WaitListHead</span>;</span>             <span class="comment">// 0x31e0: 当前处理器就绪队列中的等待线程链表头</span></span><br><span class="line">    ULONG WaitLock;                              <span class="comment">// 0x31e8: 用于保护 WaitList 的自旋锁</span></span><br><span class="line">    ULONG ReadySummary;                          <span class="comment">// 0x31ec: 表示当前就绪队列中线程的优先级分布摘要</span></span><br><span class="line">    ULONG QueueIndex;                            <span class="comment">// 0x31f0: 当前使用的就绪队列索引，用于负载均衡</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">SINGLE_LIST_ENTRY</span> <span class="title">DeferredReadyListHead</span>;</span> <span class="comment">// 0x31f4: 延迟加入就绪队列的线程列表头（如 APC 延后切换）</span></span><br><span class="line">    ULONGLONG StartCycles;                       <span class="comment">// 0x31f8: 当前线程启动以来的周期计数器值（用于 CPU 时间统计）</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONGLONG CycleTime;                <span class="comment">// 0x3200: 当前处理器累计运行的总时钟周期</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONG HighCycleTime;                <span class="comment">// 0x3208: CycleTime 的高位部分（便于 32 位系统支持）</span></span><br><span class="line">    ULONG PrcbPad71;                             <span class="comment">// 0x320c: 填充字段</span></span><br><span class="line">    ULONGLONG PrcbPad72[<span class="number">2</span>];                      <span class="comment">// 0x3210: 填充字段，可能用于对齐或未来扩展</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">DispatcherReadyListHead</span>[32];</span> <span class="comment">// 0x3220: 每个优先级对应的就绪线程队列链表头（共 32 个优先级）</span></span><br><span class="line">    VOID* ChainedInterruptList;                  <span class="comment">// 0x3320: 链式中断处理函数链表，用于处理级联中断控制器</span></span><br><span class="line">    LONG LookasideIrpFloat;                      <span class="comment">// 0x3324: Lookaside IRP 分配/释放之间的漂移值，用于调优</span></span><br><span class="line">    <span class="keyword">volatile</span> LONG MmPageFaultCount;              <span class="comment">// 0x3328: 当前处理器处理的缺页异常次数（用于内存管理性能分析）</span></span><br><span class="line">    <span class="keyword">volatile</span> LONG MmCopyOnWriteCount;            <span class="comment">// 0x332c: 拷贝写时异常（COW）触发次数</span></span><br><span class="line">    <span class="keyword">volatile</span> LONG MmTransitionCount;             <span class="comment">// 0x3330: 内存页从无效状态过渡为有效的次数</span></span><br><span class="line">    <span class="keyword">volatile</span> LONG MmCacheTransitionCount;        <span class="comment">// 0x3334: 缓存页状态转换次数（如从 standby 到 active）</span></span><br><span class="line">    <span class="keyword">volatile</span> LONG MmDemandZeroCount;             <span class="comment">// 0x3338: 处理器上零页需求次数（如首次分配新页）</span></span><br><span class="line">    <span class="keyword">volatile</span> LONG MmPageReadCount;               <span class="comment">// 0x333c: 处理器累计完成的页读取次数（从磁盘到内存）</span></span><br><span class="line">    <span class="keyword">volatile</span> LONG MmPageReadIoCount;             <span class="comment">// 0x3340: 实际触发 IO 操作的页读取次数</span></span><br><span class="line">    <span class="keyword">volatile</span> LONG MmCacheReadCount;              <span class="comment">// 0x3344: 从缓存中直接读取页的次数（无需 IO）</span></span><br><span class="line">    <span class="keyword">volatile</span> LONG MmCacheIoCount;                <span class="comment">// 0x3348: 通过缓存路径触发 IO 的读取次数</span></span><br><span class="line">    <span class="keyword">volatile</span> LONG MmDirtyPagesWriteCount;        <span class="comment">// 0x334c: 脏页写回磁盘的次数</span></span><br><span class="line">    <span class="keyword">volatile</span> LONG MmDirtyWriteIoCount;           <span class="comment">// 0x3350: 实际 IO 层面写出脏页的次数</span></span><br><span class="line">    <span class="keyword">volatile</span> LONG MmMappedPagesWriteCount;       <span class="comment">// 0x3354: 映射文件页写回的次数</span></span><br><span class="line">    <span class="keyword">volatile</span> LONG MmMappedWriteIoCount;          <span class="comment">// 0x3358: 映射写触发的实际 IO 次数</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONG CachedCommit;                 <span class="comment">// 0x335c: 当前已缓存但尚未提交的虚拟内存页数</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONG CachedResidentAvailable;      <span class="comment">// 0x3360: 当前可用于驻留页的缓存数量</span></span><br><span class="line">    VOID* HyperPte;                              <span class="comment">// 0x3364: 用于 Hyper-V 下映射虚拟 PTE 页的指针</span></span><br><span class="line">    UCHAR PrcbPad8[<span class="number">4</span>];                           <span class="comment">// 0x3368: 对齐保留字段</span></span><br><span class="line">    UCHAR VendorString[<span class="number">13</span>];                      <span class="comment">// 0x336c: 处理器厂商名称字符串（如 &quot;GenuineIntel&quot;）</span></span><br><span class="line">    UCHAR InitialApicId;                         <span class="comment">// 0x3379: 本地 APIC 的初始 ID（用于中断路由）</span></span><br><span class="line">    UCHAR LogicalProcessorsPerPhysicalProcessor; <span class="comment">// 0x337a: 每个物理处理器的逻辑处理器数（如超线程为 2）</span></span><br><span class="line">    UCHAR PrcbPad9[<span class="number">5</span>];                           <span class="comment">// 0x337b: 填充保留字段</span></span><br><span class="line">    ULONG FeatureBits;                           <span class="comment">// 0x3380: 当前处理器支持的特性位掩码（如 SSE、SMEP）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">UpdateSignature</span>;</span>        <span class="comment">// 0x3388: 内核热补丁系统使用的更新签名</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONGLONG IsrTime;                  <span class="comment">// 0x3390: 累计中断服务例程消耗的时间（周期数）</span></span><br><span class="line">    ULONGLONG RuntimeAccumulation;               <span class="comment">// 0x3398: 当前处理器所有线程运行总时间（tick 累积）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">PROCESSOR_POWER_STATE</span> <span class="title">PowerState</span>;</span>    <span class="comment">// 0x33a0: 当前处理器的电源管理状态（如 C 状态、P 状态）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KDPC</span> <span class="title">DpcWatchdogDpc</span>;</span>                 <span class="comment">// 0x3468: 用于检测 DPC 超时的 DPC 对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KTIMER</span> <span class="title">DpcWatchdogTimer</span>;</span>             <span class="comment">// 0x3488: DPC 看门狗定时器，对应定期检查是否卡住</span></span><br><span class="line">    VOID* WheaInfo;                              <span class="comment">// 0x34b0: 指向 WHEA（硬件错误体系）上下文信息</span></span><br><span class="line">    VOID* EtwSupport;                            <span class="comment">// 0x34b4: ETW（事件跟踪）支持结构，用于调试/性能分析</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">SLIST_HEADER</span> <span class="title">InterruptObjectPool</span>;</span>     <span class="comment">// 0x34b8: 中断对象池，用于快速分配中断处理结构</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">SLIST_HEADER</span> <span class="title">HypercallPageList</span>;</span>       <span class="comment">// 0x34c0: Hyper-V 下的 Hypercall 页链表</span></span><br><span class="line">    VOID* HypercallPageVirtual;                  <span class="comment">// 0x34c8: Hypercall 虚拟页地址（供 Hyper-V 使用）</span></span><br><span class="line">    VOID* VirtualApicAssist;                     <span class="comment">// 0x34cc: 虚拟化辅助结构，用于管理 APIC 虚拟行为</span></span><br><span class="line">    ULONGLONG* StatisticsPage;                   <span class="comment">// 0x34d0: 指向当前处理器的统计信息页（调试/性能用）</span></span><br><span class="line">    VOID* RateControl;                           <span class="comment">// 0x34d4: 用于调节处理器性能状态的控制结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">CACHE_DESCRIPTOR</span> <span class="title">Cache</span>[5];</span>           <span class="comment">// 0x34d8: 当前处理器的缓存层级描述（L1/L2/L3）</span></span><br><span class="line">    ULONG CacheCount;                            <span class="comment">// 0x3514: 实际有效的 Cache 描述符数量</span></span><br><span class="line">    ULONG CacheProcessorMask[<span class="number">5</span>];                 <span class="comment">// 0x3518: 每个缓存层级对应的处理器掩码（关联核心）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KAFFINITY_EX</span> <span class="title">PackageProcessorSet</span>;</span>    <span class="comment">// 0x352c: 当前处理器所在处理器包的亲和掩码</span></span><br><span class="line">    ULONG PrcbPad91[<span class="number">1</span>];                          <span class="comment">// 0x3538: 填充字段</span></span><br><span class="line">    ULONG CoreProcessorSet;                      <span class="comment">// 0x353c: 表示所属核心组内的处理器掩码</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KDPC</span> <span class="title">TimerExpirationDpc</span>;</span>             <span class="comment">// 0x3540: 用于处理计时器过期的 DPC 回调</span></span><br><span class="line">    ULONG SpinLockAcquireCount;                  <span class="comment">// 0x3560: 当前处理器尝试获取自旋锁的次数</span></span><br><span class="line">    ULONG SpinLockContentionCount;               <span class="comment">// 0x3564: 发生锁竞争（失败）后重试的次数</span></span><br><span class="line">    ULONG SpinLockSpinCount;                     <span class="comment">// 0x3568: 自旋次数总计（衡量锁效率）</span></span><br><span class="line">    ULONG IpiSendRequestBroadcastCount;          <span class="comment">// 0x356c: 广播 IPI 请求发送次数</span></span><br><span class="line">    ULONG IpiSendRequestRoutineCount;            <span class="comment">// 0x3570: 单播 IPI 请求（例程）发送次数</span></span><br><span class="line">    ULONG IpiSendSoftwareInterruptCount;         <span class="comment">// 0x3574: 软件中断（软 IPI）发送次数</span></span><br><span class="line">    ULONG ExInitializeResourceCount;             <span class="comment">// 0x3578: 初始化资源锁的次数（如 ERESOURCE）</span></span><br><span class="line">    ULONG ExReInitializeResourceCount;           <span class="comment">// 0x357c: 重新初始化资源锁的次数</span></span><br><span class="line">    ULONG ExDeleteResourceCount;                 <span class="comment">// 0x3580: 删除资源锁的次数</span></span><br><span class="line">    ULONG ExecutiveResourceAcquiresCount;        <span class="comment">// 0x3584: 成功获取 ERESOURCE 锁（独占/共享）的总次数</span></span><br><span class="line">    ULONG ExecutiveResourceContentionsCount;     <span class="comment">// 0x3588: 获取 ERESOURCE 锁时发生竞争的次数</span></span><br><span class="line">    ULONG ExecutiveResourceReleaseExclusiveCount; <span class="comment">// 0x358c: 释放独占资源锁的次数</span></span><br><span class="line">    ULONG ExecutiveResourceReleaseSharedCount;   <span class="comment">// 0x3590: 释放共享资源锁的次数</span></span><br><span class="line">    ULONG ExecutiveResourceConvertsCount;        <span class="comment">// 0x3594: 将资源锁从共享转换为独占的次数</span></span><br><span class="line">    ULONG ExAcqResExclusiveAttempts;             <span class="comment">// 0x3598: 尝试获取独占资源锁的总次数</span></span><br><span class="line">    ULONG ExAcqResExclusiveAcquiresExclusive;    <span class="comment">// 0x359c: 成功独占获取资源锁的次数</span></span><br><span class="line">    ULONG ExAcqResExclusiveAcquiresExclusiveRecursive; <span class="comment">// 0x35a0: 递归独占获取资源锁的次数</span></span><br><span class="line">    ULONG ExAcqResExclusiveWaits;                <span class="comment">// 0x35a4: 独占获取资源锁发生等待的次数</span></span><br><span class="line">    ULONG ExAcqResExclusiveNotAcquires;          <span class="comment">// 0x35a8: 获取独占锁失败的次数</span></span><br><span class="line">    ULONG ExAcqResSharedAttempts;                <span class="comment">// 0x35ac: 尝试获取共享锁的次数</span></span><br><span class="line">    ULONG ExAcqResSharedAcquiresExclusive;       <span class="comment">// 0x35b0: 共享获取请求被提升为独占的次数</span></span><br><span class="line">    ULONG ExAcqResSharedAcquiresShared;          <span class="comment">// 0x35b4: 成功获取共享资源锁的次数</span></span><br><span class="line">    ULONG ExAcqResSharedAcquiresSharedRecursive; <span class="comment">// 0x35b8: 递归共享获取资源锁的次数</span></span><br><span class="line">    ULONG ExAcqResSharedWaits;                   <span class="comment">// 0x35bc: 获取共享锁发生等待的次数</span></span><br><span class="line">    ULONG ExAcqResSharedNotAcquires;             <span class="comment">// 0x35c0: 获取共享锁失败的次数</span></span><br><span class="line">    ULONG ExAcqResSharedStarveExclusiveAttempts; <span class="comment">// 0x35c4: 共享锁试图饥饿独占锁的尝试次数</span></span><br><span class="line">    ULONG ExAcqResSharedStarveExclusiveAcquiresExclusive; <span class="comment">// 0x35c8: 在饥饿独占状态下成功获取独占锁的次数</span></span><br><span class="line">    ULONG ExAcqResSharedStarveExclusiveAcquiresShared; <span class="comment">// 0x35cc: 饥饿独占时成功获取共享锁的次数</span></span><br><span class="line">    ULONG ExAcqResSharedStarveExclusiveAcquiresSharedRecursive; <span class="comment">// 0x35d0: 饥饿独占中递归共享获取的次数</span></span><br><span class="line">    ULONG ExAcqResSharedStarveExclusiveWaits;    <span class="comment">// 0x35d4: 饥饿独占获取资源锁等待的次数</span></span><br><span class="line">    ULONG ExAcqResSharedStarveExclusiveNotAcquires; <span class="comment">// 0x35d8: 饥饿独占获取资源锁失败的次数</span></span><br><span class="line">    ULONG ExAcqResSharedWaitForExclusiveAttempts; <span class="comment">// 0x35dc: 等待获取独占资源锁的尝试次数</span></span><br><span class="line">    ULONG ExAcqResSharedWaitForExclusiveAcquiresExclusive; <span class="comment">// 0x35e0: 成功等待并获取独占资源锁的次数</span></span><br><span class="line">    ULONG ExAcqResSharedWaitForExclusiveAcquiresShared; <span class="comment">// 0x35e4: 成功等待并获取共享资源锁的次数</span></span><br><span class="line">    ULONG ExAcqResSharedWaitForExclusiveAcquiresSharedRecursive; <span class="comment">// 0x35e8: 递归等待获取共享锁的次数</span></span><br><span class="line">    ULONG ExAcqResSharedWaitForExclusiveWaits;   <span class="comment">// 0x35ec: 等待独占锁发生实际等待的次数</span></span><br><span class="line">    ULONG ExAcqResSharedWaitForExclusiveNotAcquires; <span class="comment">// 0x35f0: 等待独占锁但最终未获得的次数</span></span><br><span class="line">    ULONG ExSetResOwnerPointerExclusive;         <span class="comment">// 0x35f4: 设置资源锁独占拥有者的次数</span></span><br><span class="line">    ULONG ExSetResOwnerPointerSharedNew;         <span class="comment">// 0x35f8: 设置新的共享锁拥有者的次数</span></span><br><span class="line">    ULONG ExSetResOwnerPointerSharedOld;         <span class="comment">// 0x35fc: 替换旧共享锁拥有者的次数</span></span><br><span class="line">    ULONG ExTryToAcqExclusiveAttempts;           <span class="comment">// 0x3600: 尝试无等待方式获取独占锁的次数</span></span><br><span class="line">    ULONG ExTryToAcqExclusiveAcquires;           <span class="comment">// 0x3604: 成功获取的无等待独占锁次数</span></span><br><span class="line">    ULONG ExBoostExclusiveOwner;                 <span class="comment">// 0x3608: 提升独占锁持有线程优先级的次数</span></span><br><span class="line">    ULONG ExBoostSharedOwners;                   <span class="comment">// 0x360c: 提升共享锁持有线程优先级的次数</span></span><br><span class="line">    ULONG ExEtwSynchTrackingNotificationsCount;  <span class="comment">// 0x3610: ETW 同步跟踪通知的总次数</span></span><br><span class="line">    ULONG ExEtwSynchTrackingNotificationsAccountedCount; <span class="comment">// 0x3614: 实际被记录统计的 ETW 跟踪通知次数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">CONTEXT</span>* <span class="title">Context</span>;</span>                    <span class="comment">// 0x3618: 指向当前线程的上下文信息结构（调试或中断使用）</span></span><br><span class="line">    ULONG ContextFlags;                          <span class="comment">// 0x361c: 当前上下文结构的标志位（控制保存的内容）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">XSAVE_AREA</span>* <span class="title">ExtendedState</span>;</span>           <span class="comment">// 0x3620: 扩展寄存器（如 AVX）状态保存区域</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>





<h1 id="进程相关"><a href="#进程相关" class="headerlink" title="进程相关"></a>进程相关</h1><h2 id="进程结构"><a href="#进程结构" class="headerlink" title="进程结构"></a>进程结构</h2><p>Windows 进程的完整描述确实涉及 <strong><code>KPROCESS</code>、<code>EPROCESS</code>、<code>PEB</code></strong> 三个结构，它们分别代表：</p>
<ul>
<li><code>KPROCESS</code>：进程的内核调度上下文（最底层、最精简）</li>
<li><code>EPROCESS</code>：内核中代表进程的主对象，包含完整管理信息（含 <code>KPROCESS</code>）</li>
<li><code>PEB</code>：用户态结构，向 ntdll 和应用程序提供运行环境（仅用户可见）</li>
</ul>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <ul>
<li><p>由于 <code>KPROCESS</code> 是 <code>EPROCESS</code> 的第一个成员 <code>Pcb</code>，因此 <code>KPROCESS</code> 和 <code>EPROCESS</code> 的地址是相同的。</p>
</li>
<li><p>WDK 中导入的一个全局变量 <code>PsInitialSystemProcess</code> 指向系统启动后创建的第一个进程（PID 4），即 <code>System</code> 进程。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> NTKERNELAPI PEPROCESS PsInitialSystemProcess;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>我们可以通过 <code>PsGetCurrentProcess</code> 可以获取到当前线程的 <code>KPROCESS</code> 地址，该函数实现如下：</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PsGetCurrentProcess proc <span class="built_in">near</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">eax</span>, <span class="built_in">fs</span>:[KPCR<span class="number">.</span>PrcbData<span class="number">.</span>CurrentThread]   </span><br><span class="line">    <span class="comment">; eax ← 当前处理器上的当前线程指针 (_KTHREAD*)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">eax</span>+_KTHREAD<span class="number">.</span>ApcState<span class="number">.</span>Process]    </span><br><span class="line">    <span class="comment">; eax ← 当前线程所隶属的进程指针 (_EPROCESS*)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">retn</span></span><br><span class="line">    <span class="comment">; 返回 eax（即 _EPROCESS*）</span></span><br><span class="line"></span><br><span class="line">PsGetCurrentProcess endp</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>通过 <code>PsGetProcessPeb</code> 可以获取到用户态的 <code>PEB</code> 的地址。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PPEB <span class="title function_">PsGetProcessPeb</span><span class="params">(__in PEPROCESS Process)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Process-&gt;Peb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>

    </div>
  </div>

<h3 id="KPROCESS"><a href="#KPROCESS" class="headerlink" title="KPROCESS"></a>KPROCESS</h3><p><code>KPROCESS</code> 调度器层面的“进程调度结构体”，轻量，仅描述 CPU 调度相关属性。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0x98 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">KPROCESS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DISPATCHER_HEADER</span> <span class="title">Header</span>;</span>             <span class="comment">// 0x00: 内核对象头，支持调度器的等待/信号机制（继承自调度器对象）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ProfileListHead</span>;</span>           <span class="comment">// 0x10: 性能分析器使用的链表，用于跟踪采样信息</span></span><br><span class="line">    ULONG DirectoryTableBase;                     <span class="comment">// 0x18: 📌页目录基址（CR3），用于进程虚拟地址空间的转换</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KGDTENTRY</span> <span class="title">LdtDescriptor</span>;</span>              <span class="comment">// 0x1C: 进程的 LDT（本地描述符表）描述符（32位兼容）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KIDTENTRY</span> <span class="title">Int21Descriptor</span>;</span>            <span class="comment">// 0x24: 兼容 INT 21H（DOS 中断）的描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ThreadListHead</span>;</span>            <span class="comment">// 0x2C: 📌本进程包含的所有线程链表头（每个 ETHREAD 挂在上面）</span></span><br><span class="line">    ULONG ProcessLock;                            <span class="comment">// 0x34: 内部同步锁，用于进程结构保护</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KAFFINITY_EX</span> <span class="title">Affinity</span>;</span>                <span class="comment">// 0x38: 允许在哪些处理器组（NUMA node）上运行的亲和性掩码</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ReadyListHead</span>;</span>             <span class="comment">// 0x44: 当前进程就绪线程列表（调度器使用）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">SINGLE_LIST_ENTRY</span> <span class="title">SwapListEntry</span>;</span>      <span class="comment">// 0x4C: 换出链表，用于支持进程的虚拟内存分页</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KAFFINITY_EX</span> <span class="title">ActiveProcessors</span>;</span><span class="comment">// 0x50: 当前活跃运行该进程线程的处理器掩码</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="keyword">volatile</span> LONG AutoAlignment:<span class="number">1</span>;        <span class="comment">// 0x5C.0: 自动对齐模式（用于捕获未对齐访问）</span></span><br><span class="line">            <span class="keyword">volatile</span> LONG DisableBoost:<span class="number">1</span>;         <span class="comment">// 0x5C.1: 禁用线程优先级提升（防止因等待而提升优先级）</span></span><br><span class="line">            <span class="keyword">volatile</span> LONG DisableQuantum:<span class="number">1</span>;       <span class="comment">// 0x5C.2: 禁用时间片限制（不被抢占）</span></span><br><span class="line">            <span class="keyword">volatile</span> ULONG ActiveGroupsMask:<span class="number">1</span>;    <span class="comment">// 0x5C.3: 活跃处理器组标志</span></span><br><span class="line">            <span class="keyword">volatile</span> LONG ReservedFlags:<span class="number">28</span>;       <span class="comment">// 0x5C.4~31: 保留</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">volatile</span> LONG ProcessFlags;               <span class="comment">// 0x5C: 原始标志位表示，整体视图</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    CHAR BasePriority;                            <span class="comment">// 0x60: 初始线程优先级（线程继承此值）</span></span><br><span class="line">    CHAR QuantumReset;                            <span class="comment">// 0x61: 时间片重置值（用于线程运行时刷新）</span></span><br><span class="line">    UCHAR Visited;                                <span class="comment">// 0x62: NUMA 节点访问标志（内部使用）</span></span><br><span class="line">    UCHAR Unused3;                                <span class="comment">// 0x63: 保留</span></span><br><span class="line"></span><br><span class="line">    ULONG ThreadSeed[<span class="number">1</span>];                          <span class="comment">// 0x64: 用于线程亲和性随机调度的种子</span></span><br><span class="line">    USHORT IdealNode[<span class="number">1</span>];                          <span class="comment">// 0x68: 线程理想的 NUMA 节点</span></span><br><span class="line">    USHORT IdealGlobalNode;                       <span class="comment">// 0x6A: 全局理想节点编号</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">KEXECUTE_OPTIONS</span> <span class="title">Flags</span>;</span>                <span class="comment">// 0x6C: 执行选项（禁止动态代码等安全配置）</span></span><br><span class="line">    UCHAR Unused1;                                <span class="comment">// 0x6D: 保留</span></span><br><span class="line">    USHORT IopmOffset;                            <span class="comment">// 0x6E: IO 权限位图偏移（用于 Virtual 8086 模式 I/O 控制）</span></span><br><span class="line"></span><br><span class="line">    ULONG Unused4;                                <span class="comment">// 0x70: 保留</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">KSTACK_COUNT</span> <span class="title">StackCount</span>;</span>               <span class="comment">// 0x74: 栈引用计数（线程栈使用情况）</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ProcessListEntry</span>;</span>          <span class="comment">// 0x78: 调度器用的进程链表项（可能链接所有活跃进程）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> ULONGLONG CycleTime;                 <span class="comment">// 0x80: 此进程被调度的 CPU 时间（时钟周期）</span></span><br><span class="line">    ULONG KernelTime;                             <span class="comment">// 0x88: 内核模式运行时间（单位：100ns）</span></span><br><span class="line">    ULONG UserTime;                               <span class="comment">// 0x8C: 用户模式运行时间（单位：100ns）</span></span><br><span class="line"></span><br><span class="line">    VOID* VdmTrapcHandler;                        <span class="comment">// 0x90: 虚拟 DOS 兼容处理程序（V86 模式支持）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h3 id="EPROCESS"><a href="#EPROCESS" class="headerlink" title="EPROCESS"></a>EPROCESS</h3><p><code>EPROCESS</code> 是 Windows 内核中最核心的进程对象结构，管理进程生命周期、对象句柄、内存空间等。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">EPROCESS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KPROCESS</span> <span class="title">Pcb</span>;</span>                         <span class="comment">// 0x00: 📌进程调度器相关信息（KPROCESS，前面已详细注释）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EX_PUSH_LOCK</span> <span class="title">ProcessLock</span>;</span>             <span class="comment">// 0x98: 进程结构体自旋锁（用于多核同步）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">CreateTime</span>;</span>              <span class="comment">// 0xA0: 进程创建时间</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">ExitTime</span>;</span>                <span class="comment">// 0xA8: 进程退出时间（如果还在运行则为 0）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EX_RUNDOWN_REF</span> <span class="title">RundownProtect</span>;</span>        <span class="comment">// 0xB0: 清理保护机制（防止进程在使用中被删除）</span></span><br><span class="line">    VOID* UniqueProcessId;                        <span class="comment">// 0xB4: 📌当前进程的唯一 PID（HANDLE 类型）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ActiveProcessLinks</span>;</span>        <span class="comment">// 0xB8: 📌所有活动进程的双向链表</span></span><br><span class="line">    ULONG ProcessQuotaUsage[<span class="number">2</span>];                   <span class="comment">// 0xC0: 当前使用的分页池和非分页池配额</span></span><br><span class="line">    ULONG ProcessQuotaPeak[<span class="number">2</span>];                    <span class="comment">// 0xC8: 使用分页池和非分页池配额的历史峰值</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONG CommitCharge;                  <span class="comment">// 0xD0: 当前已提交虚拟内存（以页为单位）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EPROCESS_QUOTA_BLOCK</span>* <span class="title">QuotaBlock</span>;</span>     <span class="comment">// 0xD4: 引用进程所属的配额块</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">PS_CPU_QUOTA_BLOCK</span>* <span class="title">CpuQuotaBlock</span>;</span>    <span class="comment">// 0xD8: CPU 使用配额控制结构</span></span><br><span class="line">    ULONG PeakVirtualSize;                        <span class="comment">// 0xDC: 虚拟内存使用峰值</span></span><br><span class="line">    ULONG VirtualSize;                            <span class="comment">// 0xE0: 当前虚拟内存使用量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">SessionProcessLinks</span>;</span>       <span class="comment">// 0xE4: 当前进程所属 session 的进程链表</span></span><br><span class="line">    VOID* DebugPort;                              <span class="comment">// 0xEC: 📌调试器端口（被调试时非 NULL）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        VOID* ExceptionPortData;                  <span class="comment">// 0xF0: 异常端口数据（调试器使用）</span></span><br><span class="line">        ULONG ExceptionPortValue;</span><br><span class="line">        ULONG ExceptionPortState:<span class="number">3</span>;               <span class="comment">// 异常端口状态位</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">HANDLE_TABLE</span>* <span class="title">ObjectTable</span>;</span>            <span class="comment">// 0xF4: 📌当前进程句柄表（用于对象管理）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EX_FAST_REF</span> <span class="title">Token</span>;</span>                    <span class="comment">// 0xF8: 📌进程访问令牌（权限、安全上下文）</span></span><br><span class="line">    ULONG WorkingSetPage;                         <span class="comment">// 0xFC: 工作集起始页（即最小驻留页数）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EX_PUSH_LOCK</span> <span class="title">AddressCreationLock</span>;</span>     <span class="comment">// 0x100: 地址空间创建时使用的锁</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ETHREAD</span>* <span class="title">RotateInProgress</span>;</span>            <span class="comment">// 0x104: 正在切换线程（调度使用）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ETHREAD</span>* <span class="title">ForkInProgress</span>;</span>              <span class="comment">// 0x108: 正在进行 fork 操作的线程</span></span><br><span class="line">    ULONG HardwareTrigger;                        <span class="comment">// 0x10C: 硬件相关标志，可能由调试或诊断工具触发</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">MM_AVL_TABLE</span>* <span class="title">PhysicalVadRoot</span>;</span>        <span class="comment">// 0x110: VAD AVL 树根指针（描述虚拟内存分布）</span></span><br><span class="line">    VOID* CloneRoot;                              <span class="comment">// 0x114: 克隆 VAD 树根（用于进程克隆）</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONG NumberOfPrivatePages;          <span class="comment">// 0x118: 分配给进程的私有页数</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONG NumberOfLockedPages;           <span class="comment">// 0x11C: 被锁定（不可换出）的页数</span></span><br><span class="line">    VOID* Win32Process;                           <span class="comment">// 0x120: 指向 Win32 子系统使用的进程结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EJOB</span>* <span class="title">volatile</span> <span class="title">Job</span>;</span>                   <span class="comment">// 0x124: 所属作业对象（Job 对象）</span></span><br><span class="line">    VOID* SectionObject;                          <span class="comment">// 0x128: 映像节对象（表示映像在内存中的映射）</span></span><br><span class="line">    VOID* SectionBaseAddress;                     <span class="comment">// 0x12C: 映像加载的基址（即 EXE 的加载地址）</span></span><br><span class="line">    ULONG Cookie;                                 <span class="comment">// 0x130: 安全 cookie（用于防护堆栈溢出等）</span></span><br><span class="line">    ULONG Spare8;                                 <span class="comment">// 0x134: 保留字段</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">PAGEFAULT_HISTORY</span>* <span class="title">WorkingSetWatch</span>;</span>   <span class="comment">// 0x138: 页面错误历史记录（用于诊断内存访问）</span></span><br><span class="line">    VOID* Win32WindowStation;                     <span class="comment">// 0x13C: 进程关联的窗口站</span></span><br><span class="line">    VOID* InheritedFromUniqueProcessId;           <span class="comment">// 0x140: 父进程 PID（如果有）</span></span><br><span class="line">    VOID* LdtInformation;                         <span class="comment">// 0x144: 本地描述符表（LDT）信息（32位支持）</span></span><br><span class="line">    VOID* VdmObjects;                             <span class="comment">// 0x148: 虚拟 DOS 支持结构体（V86 模式）</span></span><br><span class="line">    ULONG ConsoleHostProcess;                     <span class="comment">// 0x14C: 控制台宿主进程 PID（仅控制台进程使用）</span></span><br><span class="line">    VOID* DeviceMap;                              <span class="comment">// 0x150: 设备映射信息（如 \\Device\\HarddiskX）</span></span><br><span class="line">    VOID* EtwDataSource;                          <span class="comment">// 0x154: ETW 跟踪数据源指针</span></span><br><span class="line">    VOID* FreeTebHint;                            <span class="comment">// 0x158: 用于优化 TEB 分配的 hint 指针</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">HARDWARE_PTE</span> <span class="title">PageDirectoryPte</span>;</span>    <span class="comment">// 0x160: 页目录表条目（硬件 PTE 格式）</span></span><br><span class="line">        ULONGLONG Filler;</span><br><span class="line">    &#125;;</span><br><span class="line">    VOID* Session;                                <span class="comment">// 0x168: 当前进程所属的 session 对象</span></span><br><span class="line">    UCHAR ImageFileName[<span class="number">15</span>];                      <span class="comment">// 0x16C: 📌可执行文件名称（不带路径）</span></span><br><span class="line">    UCHAR PriorityClass;                          <span class="comment">// 0x17B: 优先级类别（与线程优先级相关）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">JobLinks</span>;</span>                  <span class="comment">// 0x17C: Job 对象下进程的链表节点</span></span><br><span class="line">    VOID* LockedPagesList;                        <span class="comment">// 0x184: 锁定页链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ThreadListHead</span>;</span>            <span class="comment">// 0x188: 当前进程线程链表头</span></span><br><span class="line">    VOID* SecurityPort;                           <span class="comment">// 0x190: 安全通信端口（IPC）</span></span><br><span class="line">    VOID* PaeTop;                                 <span class="comment">// 0x194: PAE 页表顶端指针（仅在 PAE 模式使用）</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONG ActiveThreads;                 <span class="comment">// 0x198: 当前活跃线程数量</span></span><br><span class="line">    ULONG ImagePathHash;                          <span class="comment">// 0x19C: 映像路径哈希值（用于快速查找）</span></span><br><span class="line">    ULONG DefaultHardErrorProcessing;             <span class="comment">// 0x1A0: 错误处理策略（如是否弹框）</span></span><br><span class="line">    LONG LastThreadExitStatus;                    <span class="comment">// 0x1A4: 最后一个线程的退出码</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">PEB</span>* <span class="title">Peb</span>;</span>                             <span class="comment">// 0x1A8: 📌指向用户态的 PEB 结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EX_FAST_REF</span> <span class="title">PrefetchTrace</span>;</span>            <span class="comment">// 0x1AC: 预取跟踪结构</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">ReadOperationCount</span>;</span>      <span class="comment">// 0x1B0: 读操作次数</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">WriteOperationCount</span>;</span>     <span class="comment">// 0x1B8: 写操作次数</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">OtherOperationCount</span>;</span>     <span class="comment">// 0x1C0: 其他操作次数</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">ReadTransferCount</span>;</span>       <span class="comment">// 0x1C8: 读取字节数总和</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">WriteTransferCount</span>;</span>      <span class="comment">// 0x1D0: 写入字节数总和</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">OtherTransferCount</span>;</span>      <span class="comment">// 0x1D8: 其他传输字节数</span></span><br><span class="line">    ULONG CommitChargeLimit;                      <span class="comment">// 0x1E0: 提交内存配额上限</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONG CommitChargePeak;              <span class="comment">// 0x1E4: 提交内存配额峰值</span></span><br><span class="line">    VOID* AweInfo;                                <span class="comment">// 0x1E8: Address Windowing Extensions 支持</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">SE_AUDIT_PROCESS_CREATION_INFO</span> <span class="title">SeAuditProcessCreationInfo</span>;</span> <span class="comment">// 0x1EC: 📌审计信息，指向映像路径（可能包含命令行、EXE 路径）的结构体，供审计系统使用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">MMSUPPORT</span> <span class="title">Vm</span>;</span>                         <span class="comment">// 0x1F0: 进程的内存管理器支持结构（MMSUPPORT）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">MmProcessLinks</span>;</span>            <span class="comment">// 0x25C: 用于分页内存管理的进程链表</span></span><br><span class="line">    VOID* HighestUserAddress;                     <span class="comment">// 0x264: 用户态可访问的最高地址</span></span><br><span class="line">    ULONG ModifiedPageCount;                      <span class="comment">// 0x268: 被修改的页面计数</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ULONG Flags2;                             <span class="comment">// 0x26C: 与调度、NUMA、安全、资源管理有关的扩展状态标志</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            ULONG JobNotReallyActive:<span class="number">1</span>;         <span class="comment">// bit 0: 进程关联的 Job 对象当前未被视为活跃状态</span></span><br><span class="line">            ULONG AccountingFolded:<span class="number">1</span>;           <span class="comment">// bit 1: 资源使用计数合并入 Job，不独立统计进程自身</span></span><br><span class="line">            ULONG NewProcessReported:<span class="number">1</span>;         <span class="comment">// bit 2: 进程创建事件已上报（防止重复报告）</span></span><br><span class="line">            ULONG ExitProcessReported:<span class="number">1</span>;        <span class="comment">// bit 3: 进程退出事件已上报</span></span><br><span class="line">            ULONG ReportCommitChanges:<span class="number">1</span>;        <span class="comment">// bit 4: 提交内存变化需要通知资源跟踪</span></span><br><span class="line">            ULONG LastReportMemory:<span class="number">1</span>;           <span class="comment">// bit 5: 记录上次内存报告（用于比较/优化）</span></span><br><span class="line">            ULONG ReportPhysicalPageChanges:<span class="number">1</span>;  <span class="comment">// bit 6: 页面物理位置变化需上报（诊断用途）</span></span><br><span class="line">            ULONG HandleTableRundown:<span class="number">1</span>;         <span class="comment">// bit 7: 句柄表正在清理中</span></span><br><span class="line">            ULONG NeedsHandleRundown:<span class="number">1</span>;         <span class="comment">// bit 8: 需要清理句柄表</span></span><br><span class="line">            ULONG RefTraceEnabled:<span class="number">1</span>;            <span class="comment">// bit 9: 启用引用计数跟踪</span></span><br><span class="line">            ULONG NumaAware:<span class="number">1</span>;                  <span class="comment">// bit10: 该进程为 NUMA 感知进程</span></span><br><span class="line">            ULONG ProtectedProcess:<span class="number">1</span>;           <span class="comment">// bit11: 📌受保护进程（如 lsass，不可注入/调试）</span></span><br><span class="line">            ULONG DefaultPagePriority:<span class="number">3</span>;        <span class="comment">// bit12–14: 默认页面优先级（用于分页决策）</span></span><br><span class="line">            ULONG PrimaryTokenFrozen:<span class="number">1</span>;         <span class="comment">// bit15: 主令牌被冻结（不可替换）</span></span><br><span class="line">            ULONG ProcessVerifierTarget:<span class="number">1</span>;      <span class="comment">// bit16: 启用进程验证器跟踪</span></span><br><span class="line">            ULONG StackRandomizationDisabled:<span class="number">1</span>; <span class="comment">// bit17: 禁用堆栈地址随机化（如调试中）</span></span><br><span class="line">            ULONG AffinityPermanent:<span class="number">1</span>;          <span class="comment">// bit18: 永久绑定 CPU 亲和性</span></span><br><span class="line">            ULONG AffinityUpdateEnable:<span class="number">1</span>;       <span class="comment">// bit19: 允许动态更新亲和性</span></span><br><span class="line">            ULONG PropagateNode:<span class="number">1</span>;              <span class="comment">// bit20: 跨 NUMA 节点传播数据</span></span><br><span class="line">            ULONG ExplicitAffinity:<span class="number">1</span>;           <span class="comment">// bit21: 已显式设置亲和性</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ULONG Flags;                              <span class="comment">// 0x270: 控制进程生命周期、内存行为、调试行为等的主状态标志</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            ULONG CreateReported:<span class="number">1</span>;           <span class="comment">// bit 0: 已报告进程创建事件（如 ETW）</span></span><br><span class="line">            ULONG NoDebugInherit:<span class="number">1</span>;           <span class="comment">// bit 1: 禁止继承调试器（子进程隔离）</span></span><br><span class="line">            ULONG ProcessExiting:<span class="number">1</span>;           <span class="comment">// bit 2: 进程正在退出（终止流程中）</span></span><br><span class="line">            ULONG ProcessDelete:<span class="number">1</span>;            <span class="comment">// bit 3: 进程对象标记为删除</span></span><br><span class="line">            ULONG Wow64SplitPages:<span class="number">1</span>;          <span class="comment">// bit 4: 启用分页拆分机制（32位兼容性）</span></span><br><span class="line">            ULONG VmDeleted:<span class="number">1</span>;                <span class="comment">// bit 5: 虚拟内存空间已销毁</span></span><br><span class="line">            ULONG OutswapEnabled:<span class="number">1</span>;           <span class="comment">// bit 6: 允许被换出内存（Outswap）</span></span><br><span class="line">            ULONG Outswapped:<span class="number">1</span>;               <span class="comment">// bit 7: 已被换出内存</span></span><br><span class="line">            ULONG ForkFailed:<span class="number">1</span>;               <span class="comment">// bit 8: Fork 操作失败</span></span><br><span class="line">            ULONG Wow64VaSpace4Gb:<span class="number">1</span>;          <span class="comment">// bit 9: 启用 Wow64 的完整 4GB 虚拟地址空间</span></span><br><span class="line">            ULONG AddressSpaceInitialized:<span class="number">2</span>;  <span class="comment">// bit10–11: 地址空间初始化状态（0=未初始化，1=中，2=完成）</span></span><br><span class="line">            ULONG SetTimerResolution:<span class="number">1</span>;       <span class="comment">// bit12: 请求高分辨率定时器</span></span><br><span class="line">            ULONG BreakOnTermination:<span class="number">1</span>;       <span class="comment">// bit13: 📌终止进程时触发调试器中断</span></span><br><span class="line">            ULONG DeprioritizeViews:<span class="number">1</span>;        <span class="comment">// bit14: 降低视图优先级</span></span><br><span class="line">            ULONG WriteWatch:<span class="number">1</span>;               <span class="comment">// bit15: 启用写入监控页机制</span></span><br><span class="line">            ULONG ProcessInSession:<span class="number">1</span>;         <span class="comment">// bit16: 进程属于用户会话</span></span><br><span class="line">            ULONG OverrideAddressSpace:<span class="number">1</span>;     <span class="comment">// bit17: 允许覆盖地址空间</span></span><br><span class="line">            ULONG HasAddressSpace:<span class="number">1</span>;          <span class="comment">// bit18: 地址空间已分配</span></span><br><span class="line">            ULONG LaunchPrefetched:<span class="number">1</span>;         <span class="comment">// bit19: 由预取器发起的进程</span></span><br><span class="line">            ULONG InjectInpageErrors:<span class="number">1</span>;       <span class="comment">// bit20: 启用页错误注入</span></span><br><span class="line">            ULONG VmTopDown:<span class="number">1</span>;                <span class="comment">// bit21: 自顶向下分配地址空间</span></span><br><span class="line">            ULONG ImageNotifyDone:<span class="number">1</span>;          <span class="comment">// bit22: 映像加载通知已完成</span></span><br><span class="line">            ULONG PdeUpdateNeeded:<span class="number">1</span>;          <span class="comment">// bit23: 需要更新页目录项</span></span><br><span class="line">            ULONG VdmAllowed:<span class="number">1</span>;               <span class="comment">// bit24: 允许 V86 模式执行（虚拟 8086）</span></span><br><span class="line">            ULONG CrossSessionCreate:<span class="number">1</span>;       <span class="comment">// bit25: 允许跨会话创建</span></span><br><span class="line">            ULONG ProcessInserted:<span class="number">1</span>;          <span class="comment">// bit26: 📌进程已插入系统链表</span></span><br><span class="line">            ULONG DefaultIoPriority:<span class="number">3</span>;        <span class="comment">// bit27–29: 默认 I/O 优先级（0=低优先，3=普通）</span></span><br><span class="line">            ULONG ProcessSelfDelete:<span class="number">1</span>;        <span class="comment">// bit30: 允许进程自删除（常用于恶意进程清理）</span></span><br><span class="line">            ULONG SetTimerResolutionLink:<span class="number">1</span>;   <span class="comment">// bit31: 关联定时器精度链表</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    LONG ExitStatus;                              <span class="comment">// 0x274: 📌进程的退出码，259（0x103）是 Windows 的“还在运行”的默认占位退出码，可以借此判断进程是否退出</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">MM_AVL_TABLE</span> <span class="title">VadRoot</span>;</span>                 <span class="comment">// 0x278: 📌VAD 树（内存分配记录 AVL 树）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ALPC_PROCESS_CONTEXT</span> <span class="title">AlpcContext</span>;</span>     <span class="comment">// 0x298: ALPC 本地进程通信上下文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">TimerResolutionLink</span>;</span>       <span class="comment">// 0x2A8: 定时器精度链接节点</span></span><br><span class="line">    ULONG RequestedTimerResolution;               <span class="comment">// 0x2B0: 请求的定时器精度</span></span><br><span class="line">    ULONG ActiveThreadsHighWatermark;             <span class="comment">// 0x2B4: 活跃线程历史最高值</span></span><br><span class="line">    ULONG SmallestTimerResolution;                <span class="comment">// 0x2B8: 系统允许的最小定时器分辨率</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">PO_DIAG_STACK_RECORD</span>* <span class="title">TimerResolutionStackRecord</span>;</span> <span class="comment">// 0x2BC: 用于记录调用栈等定时器信息</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h3 id="PEB"><a href="#PEB" class="headerlink" title="PEB"></a>PEB</h3><p><code>PEB</code> 仅存在于用户模式，描述当前进程的用户态环境，如模块、堆、TLS、参数等。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">PEB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    UCHAR InheritedAddressSpace;            <span class="comment">// 0x00: 是否继承地址空间（fork 子进程时为 TRUE）</span></span><br><span class="line">    UCHAR ReadImageFileExecOptions;         <span class="comment">// 0x01: 是否读取镜像执行选项（调试器等兼容选项）</span></span><br><span class="line">    UCHAR BeingDebugged;                    <span class="comment">// 0x02: 当前进程是否正在被调试（由调试器设置）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        UCHAR BitField;                     <span class="comment">// 0x03: 标志位集合</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            UCHAR ImageUsesLargePages:<span class="number">1</span>;            <span class="comment">// bit 0: 镜像是否使用大页内存</span></span><br><span class="line">            UCHAR IsProtectedProcess:<span class="number">1</span>;             <span class="comment">// bit 1: 是否为受保护进程（如 lsass）</span></span><br><span class="line">            UCHAR IsLegacyProcess:<span class="number">1</span>;                <span class="comment">// bit 2: 是否为传统进程（兼容旧系统）</span></span><br><span class="line">            UCHAR IsImageDynamicallyRelocated:<span class="number">1</span>;    <span class="comment">// bit 3: 是否启用了 ASLR（地址随机化）</span></span><br><span class="line">            UCHAR SkipPatchingUser32Forwarders:<span class="number">1</span>;   <span class="comment">// bit 4: 是否跳过 User32.dll 的 API 前向导出修补</span></span><br><span class="line">            UCHAR SpareBits:<span class="number">3</span>;                      <span class="comment">// bit 5-7: 保留位</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    VOID* Mutant;                          <span class="comment">// 0x04: 用于同步的互斥体句柄（防止并发创建）</span></span><br><span class="line">    VOID* ImageBaseAddress;               <span class="comment">// 0x08: 主模块（EXE）加载基地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">PEB_LDR_DATA</span>* <span class="title">Ldr</span>;</span>            <span class="comment">// 0x0C: 指向模块加载器（LDR）数据结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_USER_PROCESS_PARAMETERS</span>* <span class="title">ProcessParameters</span>;</span> <span class="comment">// 0x10: 进程参数，如命令行、环境变量等</span></span><br><span class="line">    VOID* SubSystemData;                  <span class="comment">// 0x14: 子系统专用数据（如 POSIX 子系统）</span></span><br><span class="line">    VOID* ProcessHeap;                    <span class="comment">// 0x18: 默认进程堆的地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_CRITICAL_SECTION</span>* <span class="title">FastPebLock</span>;</span>  <span class="comment">// 0x1C: 用于快速同步的临界区锁</span></span><br><span class="line">    VOID* AtlThunkSListPtr;               <span class="comment">// 0x20: ATL thunk 使用的单链表指针</span></span><br><span class="line">    VOID* IFEOKey;                        <span class="comment">// 0x24: 映像文件执行选项（Image File Execution Options）注册表键句柄</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ULONG CrossProcessFlags;          <span class="comment">// 0x28: 进程状态标志</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            ULONG ProcessInJob:<span class="number">1</span>;         <span class="comment">// bit 0: 进程是否属于 Job 对象</span></span><br><span class="line">            ULONG ProcessInitializing:<span class="number">1</span>;  <span class="comment">// bit 1: 进程是否尚在初始化中</span></span><br><span class="line">            ULONG ProcessUsingVEH:<span class="number">1</span>;      <span class="comment">// bit 2: 是否使用 VEH 异常处理（Vectored Exception Handler）</span></span><br><span class="line">            ULONG ProcessUsingVCH:<span class="number">1</span>;      <span class="comment">// bit 3: 是否使用 VCH 异常处理（Vectored Continue Handler）</span></span><br><span class="line">            ULONG ProcessUsingFTH:<span class="number">1</span>;      <span class="comment">// bit 4: 是否启用了故障容错处理（Fault Tolerant Heap）</span></span><br><span class="line">            ULONG ReservedBits0:<span class="number">27</span>;       <span class="comment">// bit 5-31: 保留</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        VOID* KernelCallbackTable;        <span class="comment">// 0x2C: 内核模式回调表（如 GUI 回调）</span></span><br><span class="line">        VOID* UserSharedInfoPtr;          <span class="comment">//        用户共享信息结构指针</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ULONG SystemReserved[<span class="number">1</span>];             <span class="comment">// 0x30: 系统保留字段</span></span><br><span class="line">    ULONG AtlThunkSListPtr32;            <span class="comment">// 0x34: ATL thunk 用于 32 位兼容的单链表指针</span></span><br><span class="line">    VOID* ApiSetMap;                     <span class="comment">// 0x38: API Set 映射结构（用于模块重定向）</span></span><br><span class="line">    ULONG TlsExpansionCounter;           <span class="comment">// 0x3C: TLS 扩展槽计数器</span></span><br><span class="line">    VOID* TlsBitmap;                     <span class="comment">// 0x40: TLS 位图指针（标记可用的 TLS 插槽）</span></span><br><span class="line">    ULONG TlsBitmapBits[<span class="number">2</span>];             <span class="comment">// 0x44: TLS 位图本体（64 个槽）</span></span><br><span class="line">    VOID* ReadOnlySharedMemoryBase;      <span class="comment">// 0x4C: 只读共享内存基地址（Windows 内部用途）</span></span><br><span class="line">    VOID* HotpatchInformation;           <span class="comment">// 0x50: 热补丁相关结构体</span></span><br><span class="line">    VOID** ReadOnlyStaticServerData;     <span class="comment">// 0x54: 静态服务器数据的指针数组</span></span><br><span class="line">    VOID* AnsiCodePageData;              <span class="comment">// 0x58: ANSI 码页数据（LCID 对应）</span></span><br><span class="line">    VOID* OemCodePageData;               <span class="comment">// 0x5C: OEM 码页数据</span></span><br><span class="line">    VOID* UnicodeCaseTableData;          <span class="comment">// 0x60: Unicode 大小写映射表</span></span><br><span class="line">    ULONG NumberOfProcessors;            <span class="comment">// 0x64: 系统中可用的逻辑处理器数量</span></span><br><span class="line">    ULONG NtGlobalFlag;                  <span class="comment">// 0x68: 全局标志位（调试器、特殊分配等标记）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">CriticalSectionTimeout</span>;</span>  <span class="comment">// 0x70: 临界区超时时间（用于死锁检测）</span></span><br><span class="line">    ULONG HeapSegmentReserve;            <span class="comment">// 0x78: 堆段保留大小</span></span><br><span class="line">    ULONG HeapSegmentCommit;             <span class="comment">// 0x7C: 堆段提交大小</span></span><br><span class="line">    ULONG HeapDeCommitTotalFreeThreshold;<span class="comment">// 0x80: 堆释放总阈值</span></span><br><span class="line">    ULONG HeapDeCommitFreeBlockThreshold;<span class="comment">// 0x84: 堆释放单块阈值</span></span><br><span class="line">    ULONG NumberOfHeaps;                 <span class="comment">// 0x88: 当前进程拥有的堆数量</span></span><br><span class="line">    ULONG MaximumNumberOfHeaps;          <span class="comment">// 0x8C: 最大堆数量</span></span><br><span class="line">    VOID** ProcessHeaps;                 <span class="comment">// 0x90: 堆数组指针（实际堆地址数组）</span></span><br><span class="line">    VOID* GdiSharedHandleTable;          <span class="comment">// 0x94: GDI 共享句柄表</span></span><br><span class="line">    VOID* ProcessStarterHelper;          <span class="comment">// 0x98: 启动帮助函数</span></span><br><span class="line">    ULONG GdiDCAttributeList;            <span class="comment">// 0x9C: GDI DC 属性位图（标识属性状态）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_CRITICAL_SECTION</span>* <span class="title">LoaderLock</span>;</span>  <span class="comment">// 0xA0: Ldr 模块加载器锁</span></span><br><span class="line">    ULONG OSMajorVersion;                <span class="comment">// 0xA4: 操作系统主版本号</span></span><br><span class="line">    ULONG OSMinorVersion;                <span class="comment">// 0xA8: 操作系统次版本号</span></span><br><span class="line">    USHORT OSBuildNumber;                <span class="comment">// 0xAC: 构建号（Build Number）</span></span><br><span class="line">    USHORT OSCSDVersion;                 <span class="comment">// 0xAE: 客户服务描述版本（如 SP1）</span></span><br><span class="line">    ULONG OSPlatformId;                  <span class="comment">// 0xB0: 平台 ID（Win32 NT = 2）</span></span><br><span class="line">    ULONG ImageSubsystem;                <span class="comment">// 0xB4: 子系统类型（GUI = 2, CUI = 3）</span></span><br><span class="line">    ULONG ImageSubsystemMajorVersion;    <span class="comment">// 0xB8: 子系统主版本号</span></span><br><span class="line">    ULONG ImageSubsystemMinorVersion;    <span class="comment">// 0xBC: 子系统次版本号</span></span><br><span class="line">    ULONG ActiveProcessAffinityMask;     <span class="comment">// 0xC0: 进程默认亲和性掩码</span></span><br><span class="line">    ULONG GdiHandleBuffer[<span class="number">34</span>];           <span class="comment">// 0xC4: 用于 GDI 的句柄缓存（优化）</span></span><br><span class="line">    VOID (*PostProcessInitRoutine)();    <span class="comment">// 0x14C: 进程初始化后回调函数</span></span><br><span class="line">    VOID* TlsExpansionBitmap;            <span class="comment">// 0x150: 扩展 TLS 位图</span></span><br><span class="line">    ULONG TlsExpansionBitmapBits[<span class="number">32</span>];    <span class="comment">// 0x154: TLS 扩展槽使用位图</span></span><br><span class="line">    ULONG SessionId;                     <span class="comment">// 0x1D4: 当前 Session 的 ID</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">ULARGE_INTEGER</span> <span class="title">AppCompatFlags</span>;</span>        <span class="comment">// 0x1D8: 应用兼容性标志</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">ULARGE_INTEGER</span> <span class="title">AppCompatFlagsUser</span>;</span>    <span class="comment">// 0x1E0: 用户级应用兼容性标志</span></span><br><span class="line">    VOID* pShimData;                     <span class="comment">// 0x1E8: Shim 层数据（兼容性修复层）</span></span><br><span class="line">    VOID* AppCompatInfo;                 <span class="comment">// 0x1EC: 应用兼容性信息结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">CSDVersion</span>;</span>   <span class="comment">// 0x1F0: 系统版本描述字符串（如 &quot;Service Pack 1&quot;）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ACTIVATION_CONTEXT_DATA</span>* <span class="title">ActivationContextData</span>;</span> <span class="comment">// 0x1F8: 激活上下文信息（Side-by-Side）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ASSEMBLY_STORAGE_MAP</span>* <span class="title">ProcessAssemblyStorageMap</span>;</span> <span class="comment">// 0x1FC: 应用程序集存储映射表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ACTIVATION_CONTEXT_DATA</span>* <span class="title">SystemDefaultActivationContextData</span>;</span> <span class="comment">// 0x200: 系统默认激活上下文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ASSEMBLY_STORAGE_MAP</span>* <span class="title">SystemAssemblyStorageMap</span>;</span> <span class="comment">// 0x204: 系统程序集映射表</span></span><br><span class="line">    ULONG MinimumStackCommit;            <span class="comment">// 0x208: 最小堆栈提交大小</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">FLS_CALLBACK_INFO</span>* <span class="title">FlsCallback</span>;</span>      <span class="comment">// 0x20C: FLS 回调函数指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">FlsListHead</span>;</span>      <span class="comment">// 0x210: FLS 数据链表</span></span><br><span class="line">    VOID* FlsBitmap;                     <span class="comment">// 0x218: FLS 插槽使用位图</span></span><br><span class="line">    ULONG FlsBitmapBits[<span class="number">4</span>];              <span class="comment">// 0x21C: FLS 插槽实际位图（128 位）</span></span><br><span class="line">    ULONG FlsHighIndex;                  <span class="comment">// 0x22C: 当前最大 FLS 插槽索引</span></span><br><span class="line">    VOID* WerRegistrationData;           <span class="comment">// 0x230: Windows 错误报告注册数据</span></span><br><span class="line">    VOID* WerShipAssertPtr;              <span class="comment">// 0x234: Ship Assert 支持结构</span></span><br><span class="line">    VOID* pContextData;                  <span class="comment">// 0x238: 上下文数据（调试器/CLR）</span></span><br><span class="line">    VOID* pImageHeaderHash;              <span class="comment">// 0x23C: 镜像头部哈希值（完整性验证）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ULONG TracingFlags;              <span class="comment">// 0x240: 跟踪标志</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            ULONG HeapTracingEnabled:<span class="number">1</span>;         <span class="comment">// bit 0: 启用堆跟踪</span></span><br><span class="line">            ULONG CritSecTracingEnabled:<span class="number">1</span>;      <span class="comment">// bit 1: 启用临界区跟踪</span></span><br><span class="line">            ULONG SpareTracingBits:<span class="number">30</span>;          <span class="comment">// bit 2-31: 保留</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="进程防护技巧"><a href="#进程防护技巧" class="headerlink" title="进程防护技巧"></a>进程防护技巧</h2><h3 id="进程查找"><a href="#进程查找" class="headerlink" title="进程查找"></a>进程查找</h3><p>这里主要是根据进程名查找进程对象 <code>EPROCESS</code>，这是通常进行进程保护的第一步。</p>
<h4 id="遍历进程链表"><a href="#遍历进程链表" class="headerlink" title="遍历进程链表"></a>遍历进程链表</h4><p><code>EPROCESS</code> 的 <code>ActiveProcessLinks</code> 字段表示当前活动的进程的 <code>EPROCESS</code> 构成的双向链表，我们可以遍历这个双向链表来查找指定进程名对应的 <code>EPROCESS</code>。</p>
<p>然而 <code>EPROCESS</code> 的 <code>ActiveProcessLinks</code> 字段在不同版本的操作系统中的偏移不同，一种思路是通过 <code>PsGetProcessId</code> 函数来定位 <code>UniqueProcessId</code> 字段。</p>
<p>对于 32 位我们只需要搜索 <code>8B 80</code> 然后取后面的 4 字节即可。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; void* __stdcall PsGetProcessId(PEPROCESS Process)</span></span><br><span class="line">_PsGetProcessId@<span class="number">4</span> proc <span class="built_in">near</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">edi</span>, <span class="built_in">edi</span>                      <span class="comment">; 标准的“热补丁”对齐占位指令</span></span><br><span class="line">    <span class="keyword">push</span>    <span class="built_in">ebp</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">ebp</span>, <span class="built_in">esp</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+Process]                  <span class="comment">; 获取参数：PEPROCESS Process</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">eax</span>+_EPROCESS<span class="number">.</span>UniqueProcessId] <span class="comment">; 👈 8B 80 xx xx xx xx</span></span><br><span class="line">    <span class="comment">; 提取 EPROCESS 结构中的 UniqueProcessId 字段</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pop</span>     <span class="built_in">ebp</span></span><br><span class="line">    <span class="keyword">retn</span>    <span class="number">4</span>                             <span class="comment">; __stdcall 调用约定，清理参数</span></span><br><span class="line"></span><br><span class="line">_PsGetProcessId@<span class="number">4</span> endp</span><br></pre></td></tr></table></figure></div>

<p>对于 64 位我们只需要取 <code>PsGetProcessId</code> 后面 3 字节偏移位置的 4 字节即可。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; HANDLE __stdcall PsGetProcessId(_EPROCESS *Process)</span></span><br><span class="line">PsGetProcessId proc <span class="built_in">near</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">rax</span>, [<span class="built_in">rcx</span>+_EPROCESS<span class="number">.</span>UniqueProcessId] <span class="comment">; 👈 48 8B 81 xx xx xx xx</span></span><br><span class="line">    <span class="comment">; 获取 _EPROCESS 结构中的 UniqueProcessId 字段</span></span><br><span class="line">    <span class="keyword">retn</span></span><br><span class="line"></span><br><span class="line">PsGetProcessId endp</span><br></pre></td></tr></table></figure></div>

<p>由于 <code>UniqueProcessId</code> 与 <code>ActiveProcessLinks</code> 相邻，因此可以定位到 <code>ActiveProcessLinks</code> 字段的偏移。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 _EPROCESS 结构中的 UniqueProcessId 字段偏移</span></span><br><span class="line">ULONG <span class="title function_">GetUniqueProcessIdOffset</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">    <span class="comment">// 64 位版本：通过 PsGetProcessId 后的 3 字节偏移获取 UniqueProcessId 偏移</span></span><br><span class="line">    ULONG offset = *(ULONG*)((PUCHAR)PsGetProcessId + <span class="number">3</span>);  <span class="comment">// 获取 PsGetProcessId 后 3 字节偏移</span></span><br><span class="line">    <span class="keyword">return</span> offset; <span class="comment">// 直接返回 UniqueProcessId 的偏移</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// 32 位版本：通过特征匹配获取 UniqueProcessId 偏移</span></span><br><span class="line">    PUCHAR base = (PUCHAR)PsGetProcessId;  <span class="comment">// 获取 PsGetProcessId 函数的基址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x40</span>; i++) &#123;</span><br><span class="line">        PUCHAR p = base + i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找指令：mov eax, [eax + offset] -&gt; 8B 80 xx xx xx xx</span></span><br><span class="line">        <span class="keyword">if</span> (p[<span class="number">0</span>] == <span class="number">0x8B</span> &amp;&amp; p[<span class="number">1</span>] == <span class="number">0x80</span>) &#123;</span><br><span class="line">            ULONG pidOffset = *(ULONG*)(p + <span class="number">2</span>); <span class="comment">// 获取偏移值（跳过 8B 80）</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 确保 offset 合理</span></span><br><span class="line">            <span class="keyword">if</span> (pidOffset &gt;= <span class="number">0x80</span> &amp;&amp; pidOffset &lt; <span class="number">0x1000</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> pidOffset; <span class="comment">// 返回 UniqueProcessId 的偏移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 未找到有效的偏移</span></span><br><span class="line">    <span class="keyword">return</span> (ULONG)<span class="number">-1</span>; <span class="comment">// 0xFFFFFFFF</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算 ActiveProcessLinks 偏移</span></span><br><span class="line">ULONG <span class="title function_">DetectActiveProcessLinksOffset</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ULONG UniqueProcessIdOffset = GetUniqueProcessIdOffset();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果返回 -1 表示没找到偏移</span></span><br><span class="line">    <span class="keyword">if</span> (UniqueProcessIdOffset == (ULONG)<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (ULONG)<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ActiveProcessLinks 紧跟在 UniqueProcessId 后面</span></span><br><span class="line">    <span class="keyword">return</span> UniqueProcessIdOffset + <span class="keyword">sizeof</span>(<span class="type">void</span>*);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>之后就是链表遍历的过程。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p><code>SeLocateProcessImageName</code> 通过 <code>EPROCESS</code> 的 <code>SeAuditProcessCreationInfo</code> 字段可以获取完整映像路径，要想与查找的进程名进行需要提取映像路径中的文件名。</p>
<p>提取文件名需要从后向前查找第一个 <code>L&#39;\\&#39;</code> 字符然后取后面的字符串。</p>
<p><code>wcsrchr</code> 需要以 <code>L&#39;\0&#39;</code> 结尾的字符串，但 <code>UNICODE_STRING.Buffer</code> 只是个 <strong>定长缓存，不一定以 <code>L&#39;\0&#39;</code> 结尾</strong>，因此需要手动向后遍历查找 <code>L&#39;\\&#39;</code>。</p>

    </div>
  </div>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntstrsafe.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">PEPROCESS <span class="title function_">FindProcessByNameW</span><span class="params">(PCWSTR targetName)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 动态检测 ActiveProcessLinks 在 EPROCESS 中的偏移</span></span><br><span class="line">    ULONG activeLinksOffset = DetectActiveProcessLinksOffset();</span><br><span class="line">    <span class="keyword">if</span> (activeLinksOffset == (ULONG)<span class="number">-1</span>) &#123;</span><br><span class="line">        DbgPrint(<span class="string">&quot;[-] Failed to detect ActiveProcessLinks offset.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从系统进程开始遍历 ActiveProcessLinks 双向链表</span></span><br><span class="line">    PEPROCESS systemProcess = PsInitialSystemProcess;</span><br><span class="line">    PLIST_ENTRY head = (PLIST_ENTRY)((PUCHAR)systemProcess + activeLinksOffset);</span><br><span class="line">    PLIST_ENTRY entry = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化目标文件名为 UNICODE_STRING</span></span><br><span class="line">    UNICODE_STRING target;</span><br><span class="line">    RtlInitUnicodeString(&amp;target, targetName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 从当前链表节点反推出所在的 EPROCESS 结构地址</span></span><br><span class="line">        PEPROCESS process = (PEPROCESS)((PUCHAR)entry - activeLinksOffset);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取完整的映像路径，如：\Device\HarddiskVolumeX\Windows\System32\notepad.exe</span></span><br><span class="line">        UNICODE_STRING *imagePath = <span class="literal">NULL</span>;</span><br><span class="line">        NTSTATUS status = SeLocateProcessImageName(process, &amp;imagePath);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (NT_SUCCESS(status) &amp;&amp; imagePath &amp;&amp; imagePath-&gt;Buffer) &#123;</span><br><span class="line">            <span class="comment">// 提取最后一个反斜杠后的文件名部分</span></span><br><span class="line">            USHORT length = imagePath-&gt;Length / <span class="keyword">sizeof</span>(WCHAR);</span><br><span class="line">            USHORT offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (USHORT i = length; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (imagePath-&gt;Buffer[i - <span class="number">1</span>] == <span class="string">L&#x27;\\&#x27;</span>) &#123;</span><br><span class="line">                    offset = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 构造 UNICODE_STRING 表示文件名部分（避免直接使用 _wcsicmp 越界）</span></span><br><span class="line">            UNICODE_STRING fileName = &#123;</span><br><span class="line">                .Buffer = &amp;imagePath-&gt;Buffer[offset],</span><br><span class="line">                .Length = (length - offset) * <span class="keyword">sizeof</span>(WCHAR),</span><br><span class="line">                .MaximumLength = (length - offset) * <span class="keyword">sizeof</span>(WCHAR)</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不区分大小写比较文件名</span></span><br><span class="line">            <span class="keyword">if</span> (RtlEqualUnicodeString(&amp;fileName, &amp;target, TRUE)) &#123;</span><br><span class="line">                ExFreePool(imagePath);</span><br><span class="line">                <span class="keyword">return</span> process; <span class="comment">// 找到匹配进程，立即返回</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ExFreePool(imagePath);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        entry = entry-&gt;Flink;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (entry != head &amp;&amp; entry != <span class="literal">NULL</span>); <span class="comment">// 遍历至循环结束或异常中止</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 未找到目标进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="枚举进程-Id"><a href="#枚举进程-Id" class="headerlink" title="枚举进程 Id"></a>枚举进程 Id</h4><p>在某些场景下（如内核 Rootkit），<code>ActiveProcessLinks</code> 链表可能被恶意修改（如断链）以隐藏进程。这种情况下，仅靠 <code>ActiveProcessLinks</code> 遍历将无法发现目标进程。</p>
<p>Windows 为所有活动进程维护了系统对象句柄表。<code>PsLookupProcessByProcessId</code> 会通过这些内核内部机制而不是链表查找 <code>EPROCESS</code>，因此仍能定位被“断链”隐藏的进程。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>进程 ID 通常是 4 的倍数，递增步长为 4。这是因为进程 ID 是句柄，类型为 <code>EXHANDLE</code>，最低 2 位是保留位。</p>

    </div>
  </div>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntstrsafe.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取路径中的最后一个文件名部分（非 NULL 结尾，手动构造 UNICODE_STRING）</span></span><br><span class="line"><span class="type">static</span> BOOLEAN <span class="title function_">ExtractFileNameFromPath</span><span class="params">(PUNICODE_STRING fullPath, UNICODE_STRING* fileName)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!fullPath || !fullPath-&gt;Buffer || fullPath-&gt;Length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    PWCH start = fullPath-&gt;Buffer;</span><br><span class="line">    USHORT length = fullPath-&gt;Length / <span class="keyword">sizeof</span>(WCHAR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向前扫描，查找最后一个反斜杠</span></span><br><span class="line">    USHORT i;</span><br><span class="line">    <span class="keyword">for</span> (i = length; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fullPath-&gt;Buffer[i - <span class="number">1</span>] == <span class="string">L&#x27;\\&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// i 是文件名在 fullPath 中的起始索引</span></span><br><span class="line">    fileName-&gt;Buffer = &amp;fullPath-&gt;Buffer[i];</span><br><span class="line">    fileName-&gt;Length = (length - i) * <span class="keyword">sizeof</span>(WCHAR);</span><br><span class="line">    fileName-&gt;MaximumLength = fileName-&gt;Length;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据进程名查找 EPROCESS（使用 SeLocateProcessImageName 获取完整路径）</span></span><br><span class="line">PEPROCESS <span class="title function_">FindProcessByNameW</span><span class="params">(PCWSTR targetName)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!targetName)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    UNICODE_STRING targetStr;</span><br><span class="line">    RtlInitUnicodeString(&amp;targetStr, targetName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ULONG_PTR pid = <span class="number">4</span>; pid &lt; <span class="number">0x100000</span>; pid += <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PEPROCESS tempProcess = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(PsLookupProcessByProcessId((HANDLE)pid, &amp;tempProcess)))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳过已经退出的进程</span></span><br><span class="line">        <span class="keyword">if</span> (PsGetProcessExitStatus(tempProcess) != STATUS_PENDING) &#123;</span><br><span class="line">            ObDereferenceObject(tempProcess);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取进程映像路径</span></span><br><span class="line">        PUNICODE_STRING imagePath = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(SeLocateProcessImageName(tempProcess, &amp;imagePath)) || !imagePath) &#123;</span><br><span class="line">            ObDereferenceObject(tempProcess);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        UNICODE_STRING exeName;</span><br><span class="line">        <span class="keyword">if</span> (ExtractFileNameFromPath(imagePath, &amp;exeName)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (RtlCompareUnicodeString(&amp;exeName, &amp;targetStr, TRUE) == <span class="number">0</span>) &#123;</span><br><span class="line">                ExFreePool(imagePath);</span><br><span class="line">                <span class="keyword">return</span> tempProcess; <span class="comment">// 匹配成功，返回</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清理并继续</span></span><br><span class="line">        ExFreePool(imagePath);</span><br><span class="line">        ObDereferenceObject(tempProcess);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>Windows 内核中的 <code>PEPROCESS</code> 是一种引用计数对象。当调用 <code>PsLookupProcessByProcessId</code> 时系统会对该进程对象 <strong>引用计数 +1</strong>。这个引用是你“拥有”的，意味着你必须在用完后 <strong>调用 <code>ObDereferenceObject</code></strong> 来 <strong>减少引用计数</strong>，否则会导致内核对象泄漏（内核内存无法释放，进程无法完全终止）。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PEPROCESS proc = FindProcessByNameW(<span class="string">L&quot;notepad.exe&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (proc) &#123;</span><br><span class="line">    DbgPrint(<span class="string">&quot;找到进程: %p\n&quot;</span>, proc);</span><br><span class="line">    ObDereferenceObject(proc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    DbgPrint(<span class="string">&quot;未找到目标进程\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<h3 id="进程隐藏"><a href="#进程隐藏" class="headerlink" title="进程隐藏"></a>进程隐藏</h3><h4 id="进程断链"><a href="#进程断链" class="headerlink" title="进程断链"></a>进程断链</h4><p>Windows 操作系统通过双向链表来管理所有运行中的进程，进程之间通过 <code>ActiveProcessLinks</code> 字段相互连接。通过从该链表中移除目标进程，可以实现进程隐藏。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntstrsafe.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">HideProcessByNameW</span><span class="params">(PCWSTR targetName)</span></span><br><span class="line">&#123;</span><br><span class="line">    PEPROCESS targetProcess = FindProcessByNameW(targetName);  <span class="comment">// 获取目标进程的 EPROCESS</span></span><br><span class="line">    <span class="keyword">if</span> (!targetProcess) &#123;</span><br><span class="line">        DbgPrint(<span class="string">&quot;[-] Process not found.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// 没有找到进程，退出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态检测 ActiveProcessLinks 在 EPROCESS 中的偏移</span></span><br><span class="line">    ULONG activeLinksOffset = DetectActiveProcessLinksOffset();</span><br><span class="line">    <span class="keyword">if</span> (activeLinksOffset == (ULONG)<span class="number">-1</span>) &#123;</span><br><span class="line">        DbgPrint(<span class="string">&quot;[-] Failed to detect ActiveProcessLinks offset.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// 获取偏移失败，退出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 EPROCESS 获取 ActiveProcessLinks 双向链表中的指针</span></span><br><span class="line">    PLIST_ENTRY activeLinks = (PLIST_ENTRY)((PUCHAR)targetProcess + activeLinksOffset);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 RemoveEntryList API 从链表中移除目标进程</span></span><br><span class="line">    RemoveEntryList(activeLinks);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理目标进程的链表指针，确保该节点不再关联任何链表</span></span><br><span class="line">    InitializeListHead(activeLinks);  <span class="comment">// 将链表头部的 Flink 和 Blink 指向自己</span></span><br><span class="line"></span><br><span class="line">    DbgPrint(<span class="string">&quot;[+] Successfully hid process %ws\n&quot;</span>, targetName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="修改进程-ID"><a href="#修改进程-ID" class="headerlink" title="修改进程 ID"></a>修改进程 ID</h4><p>在某些情况下，修改进程的 <code>PID</code>（进程 ID）可能是实现进程隐藏的另一个重要步骤。通过修改 <code>EPROCESS</code> 结构中的 <code>UniqueProcessId</code> 字段，可以伪造进程的 ID，使得它在系统中的任务管理器中无法正常找到被隐藏进程。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>由于部分操作系统的进程管理器的实现问题，<code>PID</code> 重复会导致其显示出错。</p>

    </div>
  </div>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">VOID <span class="title function_">ChangeProcessIdByNameW</span><span class="params">(PCWSTR targetName, ULONG newPid)</span></span><br><span class="line">&#123;</span><br><span class="line">    PEPROCESS targetProcess = FindProcessByNameW(targetName);  <span class="comment">// 获取目标进程的 EPROCESS</span></span><br><span class="line">    <span class="keyword">if</span> (!targetProcess) &#123;</span><br><span class="line">        DbgPrint(<span class="string">&quot;[-] Process not found.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// 没有找到进程，退出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态检测 UniqueProcessId 在 EPROCESS 中的偏移</span></span><br><span class="line">    ULONG pidOffset = GetUniqueProcessIdOffset();</span><br><span class="line">    <span class="keyword">if</span> (pidOffset == (ULONG)<span class="number">-1</span>) &#123;</span><br><span class="line">        DbgPrint(<span class="string">&quot;[-] Failed to detect UniqueProcessId offset.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// 获取偏移失败，退出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取目标进程的 UniqueProcessId 字段地址</span></span><br><span class="line">    ULONG* pidAddr = (ULONG*)((PUCHAR)targetProcess + pidOffset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改进程的 PID</span></span><br><span class="line">    *pidAddr = newPid;</span><br><span class="line"></span><br><span class="line">    DbgPrint(<span class="string">&quot;[+] Successfully changed process %ws PID to %lu\n&quot;</span>, targetName, newPid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="进程保护"><a href="#进程保护" class="headerlink" title="进程保护"></a>进程保护</h3><h4 id="BreakOnTermination-Flags-bit13"><a href="#BreakOnTermination-Flags-bit13" class="headerlink" title="BreakOnTermination (Flags bit13)"></a>BreakOnTermination (Flags bit13)</h4><p><code>BreakOnTermination</code> 是一种机制，在进程即将被终止时触发断点。通常用于调试进程的终止过程，帮助开发人员在进程即将结束时进行故障排除或保存重要信息。</p>
<p>如果该标志位置为 1，则当其他进程终止被保护的进程时，系统会触发蓝屏。这种保护机制用于防止重要进程的意外终止，通过检测进程结束时是否存在其他进程的干扰，如果发现不当操作，系统会抛出异常，进而引发蓝屏，以确保系统的完整性和安全性。</p>
<h4 id="ProcessInserted-Flags-bit26"><a href="#ProcessInserted-Flags-bit26" class="headerlink" title="ProcessInserted (Flags bit26)"></a>ProcessInserted (Flags bit26)</h4><p>如果 <code>ProcessInserted</code> 标志位设置为 0，则当其他进程尝试打开受保护进程时，它们可以成功获取该进程的句柄，但无法将该句柄插入到自身进程的句柄表中。最终的结果是，该进程无法被正常操作，即使可以获得句柄，仍然无法进行操作（如调试、修改等）。</p>
<p>此标志位用于限制对进程句柄的访问，确保在某些情况下，其他进程无法通过获得句柄对受保护进程进行修改或干预。常见的应用场景包括防止恶意软件或不当操作干扰受保护进程的运行。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p><code>ProcessInserted</code> 设置为 0，进程自身也将无法创建线程、访问或操作其他句柄，甚至可能无法执行对自身的管理操作。具体来说，创建新线程、分配内存、访问文件句柄等操作将受到影响，导致进程无法正常执行这些任务。</p>

    </div>
  </div>

<h4 id="ProtectedProcess-Flags2-bit11"><a href="#ProtectedProcess-Flags2-bit11" class="headerlink" title="ProtectedProcess (Flags2 bit11)"></a>ProtectedProcess (Flags2 bit11)</h4><p><code>ProtectedProcess</code> 是一种通过在操作系统中标记进程来防止其被结束或修改的技术。它可以确保某些关键进程（如操作系统服务或反病毒进程）不被恶意软件或未经授权的操作干扰。</p>
<p><code>ProtectedProcess</code> 标志与 <code>CreateProcess</code> 函数中的 <code>dwCreationFlags</code> 参数中的 <code>CREATE_PROTECTED_PROCESS</code> 标志位相关。使用 <code>CREATE_PROTECTED_PROCESS</code> 启动的进程会被标记为受保护进程。然而，要使进程成为受保护进程，二进制文件必须具有由 Microsoft 提供的特殊签名。当前，只有 Microsoft 提供的进程和二进制文件才能享受此保护，非 Microsoft 的二进制文件无法直接成为受保护进程。</p>
<p>此标志机制通过严格限制对受保护进程的访问，防止它们被外部操作（如终止、调试或挂起）影响，通常用于保护系统的关键进程或高安全性进程，以保障系统的稳定性和安全性。</p>
<h1 id="线程相关"><a href="#线程相关" class="headerlink" title="线程相关"></a>线程相关</h1><h2 id="线程结构"><a href="#线程结构" class="headerlink" title="线程结构"></a>线程结构</h2><h3 id="KTHREAD"><a href="#KTHREAD" class="headerlink" title="KTHREAD"></a>KTHREAD</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">KTHREAD</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DISPATCHER_HEADER</span> <span class="title">Header</span>;</span>             <span class="comment">// 0x00: 调度器头，支持线程同步、定时器等</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONGLONG CycleTime;                 <span class="comment">// 0x10: 累计使用的 CPU 时间（时间戳计数）</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONG HighCycleTime;                 <span class="comment">// 0x18: CycleTime 的高 32 位</span></span><br><span class="line">    ULONGLONG QuantumTarget;                      <span class="comment">// 0x20: 时间片截止时间</span></span><br><span class="line">    VOID* InitialStack;                           <span class="comment">// 0x28: 📌栈底指针</span></span><br><span class="line">    VOID* <span class="keyword">volatile</span> StackLimit;                    <span class="comment">// 0x2C: 📌栈顶界限（溢出保护）</span></span><br><span class="line">    VOID* KernelStack;                            <span class="comment">// 0x30: 📌当前内核栈指针，用户线程切换的时候保存 ESP</span></span><br><span class="line">    ULONG ThreadLock;                             <span class="comment">// 0x34: 自旋锁，用于线程结构保护</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">KWAIT_STATUS_REGISTER</span> <span class="title">WaitRegister</span>;</span>    <span class="comment">// 0x38: 等待状态寄存器（压缩状态位）</span></span><br><span class="line">    <span class="keyword">volatile</span> UCHAR Running;                       <span class="comment">// 0x39: 📌当前是否正在运行（1 表示运行）</span></span><br><span class="line">    UCHAR Alerted[<span class="number">2</span>];                             <span class="comment">// 0x3A: 📌[0]=内核APC警报, [1]=用户APC警报</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ULONG KernelStackResident:<span class="number">1</span>;          <span class="comment">// bit  0: 栈是否驻留在内存中</span></span><br><span class="line">            ULONG ReadyTransition:<span class="number">1</span>;              <span class="comment">// bit  1: 准备态转运行态</span></span><br><span class="line">            ULONG ProcessReadyQueue:<span class="number">1</span>;            <span class="comment">// bit  2: 线程是否在进程就绪队列中</span></span><br><span class="line">            ULONG WaitNext:<span class="number">1</span>;                     <span class="comment">// bit  3: 是否立即等待下一个事件</span></span><br><span class="line">            ULONG SystemAffinityActive:<span class="number">1</span>;         <span class="comment">// bit  4: 是否强制使用系统亲和性</span></span><br><span class="line">            ULONG Alertable:<span class="number">1</span>;                    <span class="comment">// bit  5: 📌是否可以中断（用于 APC）</span></span><br><span class="line">            ULONG GdiFlushActive:<span class="number">1</span>;               <span class="comment">// bit  6: 是否在刷新 GDI 缓存</span></span><br><span class="line">            ULONG UserStackWalkActive:<span class="number">1</span>;          <span class="comment">// bit  7: 是否正在遍历用户栈</span></span><br><span class="line">            ULONG ApcInterruptRequest:<span class="number">1</span>;          <span class="comment">// bit  8: 📌是否请求 APC 中断</span></span><br><span class="line">            ULONG ForceDeferSchedule:<span class="number">1</span>;           <span class="comment">// bit  9: 是否强制延迟调度</span></span><br><span class="line">            ULONG QuantumEndMigrate:<span class="number">1</span>;            <span class="comment">// bit 10: 是否允许量子结束时迁移</span></span><br><span class="line">            ULONG UmsDirectedSwitchEnable:<span class="number">1</span>;      <span class="comment">// bit 11: 是否启用 UMS 指定切换</span></span><br><span class="line">            ULONG TimerActive:<span class="number">1</span>;                  <span class="comment">// bit 12: 线程是否激活了计时器</span></span><br><span class="line">            ULONG SystemThread:<span class="number">1</span>;                 <span class="comment">// bit 13: 是否为系统线程（非用户）</span></span><br><span class="line">            ULONG Reserved:<span class="number">18</span>;                    <span class="comment">// bit 14-31: 保留位</span></span><br><span class="line">        &#125;;</span><br><span class="line">        LONG MiscFlags;                           <span class="comment">// 0x3C: 以上所有位的组合访问</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">KAPC_STATE</span> <span class="title">ApcState</span>;</span>              <span class="comment">// 0x40: 📌APC 状态，含队列与锁</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR ApcStateFill[<span class="number">23</span>];               <span class="comment">// 填充</span></span><br><span class="line">            CHAR Priority;                        <span class="comment">// 0x57: 当前线程调度优先级</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">volatile</span> ULONG NextProcessor;                <span class="comment">// 0x58: 调度目标 CPU</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONG DeferredProcessor;            <span class="comment">// 0x5C: 被延迟分配的 CPU</span></span><br><span class="line">    ULONG ApcQueueLock;                          <span class="comment">// 0x60: APC 队列互斥锁</span></span><br><span class="line">    ULONG ContextSwitches;                       <span class="comment">// 0x64: 上下文切换计数器</span></span><br><span class="line">    <span class="keyword">volatile</span> UCHAR State;                        <span class="comment">// 0x68: 线程状态（Initialized 等）</span></span><br><span class="line">    CHAR NpxState;                               <span class="comment">// 0x69: 协处理器状态</span></span><br><span class="line">    UCHAR WaitIrql;                              <span class="comment">// 0x6A: 等待时提升的 IRQL</span></span><br><span class="line">    CHAR WaitMode;                               <span class="comment">// 0x6B: 等待模式（内核 / 用户）</span></span><br><span class="line">    <span class="keyword">volatile</span> LONG WaitStatus;                    <span class="comment">// 0x6C: 等待完成状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KWAIT_BLOCK</span>* <span class="title">WaitBlockList</span>;</span>          <span class="comment">// 0x70: 等待块链表指针</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">WaitListEntry</span>;</span>        <span class="comment">// 0x74: 等待对象链表节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">SINGLE_LIST_ENTRY</span> <span class="title">SwapListEntry</span>;</span> <span class="comment">// 0x74: 用于交换线程的备用单链</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KQUEUE</span>* <span class="title">volatile</span> <span class="title">Queue</span>;</span>              <span class="comment">// 0x7C: 所在等待队列</span></span><br><span class="line">    ULONG WaitTime;                              <span class="comment">// 0x80: 等待开始时间</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            SHORT KernelApcDisable;              <span class="comment">// 0x84: 禁止内核 APC</span></span><br><span class="line">            SHORT SpecialApcDisable;             <span class="comment">// 0x86: 禁止特殊 APC（如调度）</span></span><br><span class="line">        &#125;;</span><br><span class="line">        ULONG CombinedApcDisable;                <span class="comment">// 0x84: 合并后的 APC 禁止位</span></span><br><span class="line">    &#125;;</span><br><span class="line">    VOID* Teb;                                   <span class="comment">// 0x88: 📌用户线程环境块 TEB 指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KTIMER</span> <span class="title">Timer</span>;</span>                        <span class="comment">// 0x90: 内核定时器对象</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ULONG AutoAlignment:<span class="number">1</span>;               <span class="comment">// bit  0: 栈自动对齐</span></span><br><span class="line">            ULONG DisableBoost:<span class="number">1</span>;                <span class="comment">// bit  1: 禁用优先级提升</span></span><br><span class="line">            ULONG EtwStackTraceApc1Inserted:<span class="number">1</span>;   <span class="comment">// bit  2: ETW APC1 插入标志</span></span><br><span class="line">            ULONG EtwStackTraceApc2Inserted:<span class="number">1</span>;   <span class="comment">// bit  3: ETW APC2 插入标志</span></span><br><span class="line">            ULONG CalloutActive:<span class="number">1</span>;               <span class="comment">// bit  4: 回调活动中</span></span><br><span class="line">            ULONG ApcQueueable:<span class="number">1</span>;                <span class="comment">// bit  5: 是否允许 APC 入队</span></span><br><span class="line">            ULONG EnableStackSwap:<span class="number">1</span>;             <span class="comment">// bit  6: 启用栈切换</span></span><br><span class="line">            ULONG GuiThread:<span class="number">1</span>;                   <span class="comment">// bit  7: 是否 GUI 线程</span></span><br><span class="line">            ULONG UmsPerformingSyscall:<span class="number">1</span>;        <span class="comment">// bit  8: UMS 正在执行系统调用</span></span><br><span class="line">            ULONG VdmSafe:<span class="number">1</span>;                     <span class="comment">// bit  9: VDM 兼容（16 位支持）</span></span><br><span class="line">            ULONG UmsDispatched:<span class="number">1</span>;               <span class="comment">// bit 10: 已分派为 UMS 线程</span></span><br><span class="line">            ULONG ReservedFlags:<span class="number">21</span>;              <span class="comment">// bit 11-31: 保留</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">volatile</span> LONG ThreadFlags;               <span class="comment">// 0xB8: 所有标志位联合体访问</span></span><br><span class="line">    &#125;;</span><br><span class="line">    VOID* ServiceTable;                          <span class="comment">// 0xBC: 系统调用服务表（指向 SSDT）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KWAIT_BLOCK</span> <span class="title">WaitBlock</span>[4];</span>           <span class="comment">// 0xC0: 最多支持同时等待 4 个同步对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">QueueListEntry</span>;</span>          <span class="comment">// 0x120: 在线程队列（如工作队列）中的节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KTRAP_FRAME</span>* <span class="title">TrapFrame</span>;</span>             <span class="comment">// 0x128: 当前陷阱帧指针（中断或异常时的栈帧）</span></span><br><span class="line">    VOID* FirstArgument;                        <span class="comment">// 0x12C: 初始参数（如新线程的入口参数）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        VOID* CallbackStack;                    <span class="comment">// 0x130: 当前正在执行的回调栈地址</span></span><br><span class="line">        ULONG CallbackDepth;                    <span class="comment">// 0x130: 回调嵌套深度</span></span><br><span class="line">    &#125;;</span><br><span class="line">    UCHAR ApcStateIndex;                        <span class="comment">// 0x134: 📌APC 状态索引（内核/用户）</span></span><br><span class="line">    CHAR BasePriority;                          <span class="comment">// 0x135: 初始基本优先级</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        CHAR PriorityDecrement;                 <span class="comment">// 0x136: 当前优先级减少值（优先级衰减）</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR ForegroundBoost : <span class="number">4</span>;          <span class="comment">// bit 0-3: 前台线程优先级提升</span></span><br><span class="line">            UCHAR UnusualBoost   : <span class="number">4</span>;           <span class="comment">// bit 4-7: 特殊调度场景提升</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    UCHAR Preempted;                            <span class="comment">// 0x137: 是否被抢占</span></span><br><span class="line">    UCHAR AdjustReason;                         <span class="comment">// 0x138: 优先级调整原因</span></span><br><span class="line">    CHAR AdjustIncrement;                       <span class="comment">// 0x139: 优先级调整增量</span></span><br><span class="line">    CHAR PreviousMode;                          <span class="comment">// 0x13A: 上下文切换前的 CPU 模式（用户/内核）</span></span><br><span class="line">    CHAR Saturation;                            <span class="comment">// 0x13B: 饱和度指标，用于调度策略</span></span><br><span class="line">    ULONG SystemCallNumber;                     <span class="comment">// 0x13C: 上次系统调用号</span></span><br><span class="line">    ULONG FreezeCount;                          <span class="comment">// 0x140: 冻结计数（例如调试器挂起）</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> _<span class="title">GROUP_AFFINITY</span> <span class="title">UserAffinity</span>;</span> <span class="comment">// 0x144: 用户设置的 CPU 亲和性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KPROCESS</span>* <span class="title">Process</span>;</span>                  <span class="comment">// 0x150: 📌所属进程的 `_KPROCESS` 指针</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> _<span class="title">GROUP_AFFINITY</span> <span class="title">Affinity</span>;</span>   <span class="comment">// 0x154: 当前线程亲和性掩码（活动 CPU 集）</span></span><br><span class="line">    ULONG IdealProcessor;                       <span class="comment">// 0x160: 调度器理想的运行 CPU</span></span><br><span class="line">    ULONG UserIdealProcessor;                   <span class="comment">// 0x164: 用户设置的理想处理器编号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KAPC_STATE</span>* <span class="title">ApcStatePointer</span>[2];</span>     <span class="comment">// 0x168: 指向内核 / 用户 APC 状态</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">KAPC_STATE</span> <span class="title">SavedApcState</span>;</span>       <span class="comment">// 0x170: 保存的 APC 状态（线程挂起/恢复时）</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR SavedApcStateFill[<span class="number">23</span>];        <span class="comment">// 填充对齐</span></span><br><span class="line">            UCHAR WaitReason;                   <span class="comment">// 0x187: 当前线程的等待原因（调试、同步等）</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    CHAR SuspendCount;                          <span class="comment">// 0x188: 被挂起次数（非 0 时线程暂停）</span></span><br><span class="line">    CHAR Spare1;                                <span class="comment">// 0x189: 保留</span></span><br><span class="line">    UCHAR OtherPlatformFill;                    <span class="comment">// 0x18A: 多平台兼容保留位</span></span><br><span class="line">    VOID* <span class="keyword">volatile</span> Win32Thread;                 <span class="comment">// 0x18C: 指向 Win32 子系统线程结构（如 CSR）</span></span><br><span class="line">    VOID* StackBase;                            <span class="comment">// 0x190: 栈基地址（高地址）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">KAPC</span> <span class="title">SuspendApc</span>;</span>                <span class="comment">// 0x194: 用于挂起线程的 APC 对象</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR SuspendApcFill0[<span class="number">1</span>];           <span class="comment">// 0x194</span></span><br><span class="line">            UCHAR ResourceIndex;                <span class="comment">// 0x195: 分配资源索引</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR SuspendApcFill1[<span class="number">3</span>];           <span class="comment">// 0x194</span></span><br><span class="line">            UCHAR QuantumReset;                 <span class="comment">// 0x197: 时间片重置标志</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR SuspendApcFill2[<span class="number">4</span>];           <span class="comment">// 0x194</span></span><br><span class="line">            ULONG KernelTime;                   <span class="comment">// 0x198: 已消耗的内核时间</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR SuspendApcFill3[<span class="number">36</span>];          <span class="comment">// 0x194</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">KPRCB</span>* <span class="title">volatile</span> <span class="title">WaitPrcb</span>;</span>   <span class="comment">// 0x1B8: 当前等待的 PRCB（处理器控制块）</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR SuspendApcFill4[<span class="number">40</span>];          <span class="comment">// 0x194</span></span><br><span class="line">            VOID* LegoData;                     <span class="comment">// 0x1BC: LEGO 用户模式调度器数据</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR SuspendApcFill5[<span class="number">47</span>];          <span class="comment">// 0x194</span></span><br><span class="line">            UCHAR LargeStack;                   <span class="comment">// 0x1C3: 是否使用大栈（&gt;默认大小）</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG UserTime;                             <span class="comment">// 0x1C4: 已消耗的用户模式时间</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">KSEMAPHORE</span> <span class="title">SuspendSemaphore</span>;</span>    <span class="comment">// 0x1C8: 挂起信号量（用于线程恢复）</span></span><br><span class="line">        UCHAR SuspendSemaphorefill[<span class="number">20</span>];         <span class="comment">// 填充用</span></span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG SListFaultCount;                      <span class="comment">// 0x1DC: SList 异常计数（栈溢出等）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ThreadListEntry</span>;</span>         <span class="comment">// 0x1E0: 📌线程链表节点（进程中的线程列表）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">MutantListHead</span>;</span>          <span class="comment">// 0x1E8: 线程持有的互斥体链表头</span></span><br><span class="line">    VOID* SListFaultAddress;                    <span class="comment">// 0x1F0: 最后一个异常 SList 操作地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KTHREAD_COUNTERS</span>* <span class="title">ThreadCounters</span>;</span>   <span class="comment">// 0x1F4: 性能统计计数器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">XSTATE_SAVE</span>* <span class="title">XStateSave</span>;</span>            <span class="comment">// 0x1F8: 扩展浮点 / AVX 状态保存结构</span></span><br><span class="line">&#125;; <span class="comment">// 0x200 bytes</span></span><br></pre></td></tr></table></figure></div>

<h3 id="ETHREAD"><a href="#ETHREAD" class="headerlink" title="ETHREAD"></a>ETHREAD</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0x2B8 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">ETHREAD</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KTHREAD</span> <span class="title">Tcb</span>;</span>                            <span class="comment">// 0x000: 内核线程结构（线程控制块，KTHREAD）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">CreateTime</span>;</span>               <span class="comment">// 0x200: 线程创建时间（自系统启动以来的时间）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">ExitTime</span>;</span>             <span class="comment">// 0x208: 线程退出时间（0 表示未退出）</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">KeyedWaitChain</span>;</span>         <span class="comment">// 0x208: 用于 Keyed Event 同步的链表</span></span><br><span class="line">    &#125;;</span><br><span class="line">    LONG ExitStatus;                               <span class="comment">// 0x210: 线程退出状态码（如 0 为正常）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">PostBlockList</span>;</span>          <span class="comment">// 0x214: APC 完成时挂起的 IRP 等列表</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            VOID* ForwardLinkShadow;               <span class="comment">// 0x214: 内部链接指针</span></span><br><span class="line">            VOID* StartAddress;                    <span class="comment">// 0x218: 📌用户模式下的线程起始地址</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">TERMINATION_PORT</span>* <span class="title">TerminationPort</span>;</span> <span class="comment">// 0x21C: 通知线程终止的端口对象</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">ETHREAD</span>* <span class="title">ReaperLink</span>;</span>               <span class="comment">// 0x21C: 用于线程回收（Reaper）链表</span></span><br><span class="line">        VOID* KeyedWaitValue;                      <span class="comment">// 0x21C: Keyed Event 用的值</span></span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG ActiveTimerListLock;                     <span class="comment">// 0x220: 活动定时器链表锁</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ActiveTimerListHead</span>;</span>        <span class="comment">// 0x224: 活动定时器链表头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">CLIENT_ID</span> <span class="title">Cid</span>;</span>                         <span class="comment">// 0x22C: 📌客户端 ID（包含进程 ID 和线程 ID）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">KSEMAPHORE</span> <span class="title">KeyedWaitSemaphore</span>;</span>     <span class="comment">// 0x234: Keyed Event 信号量</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">KSEMAPHORE</span> <span class="title">AlpcWaitSemaphore</span>;</span>      <span class="comment">// 0x234: ALPC 使用的信号量</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">PS_CLIENT_SECURITY_CONTEXT</span> <span class="title">ClientSecurity</span>;</span> <span class="comment">// 0x248: 线程安全上下文（用于模拟）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">IrpList</span>;</span>                    <span class="comment">// 0x24C: 线程持有的 IRP 链表</span></span><br><span class="line">    ULONG TopLevelIrp;                             <span class="comment">// 0x254: 用于避免 IRP 嵌套递归</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_OBJECT</span>* <span class="title">DeviceToVerify</span>;</span>         <span class="comment">// 0x258: 安全检查使用的设备对象</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">PSP_CPU_QUOTA_APC</span>* <span class="title">CpuQuotaApc</span>;</span>         <span class="comment">// 0x25C: CPU 配额 APC（调控线程使用时间）</span></span><br><span class="line">    VOID* Win32StartAddress;                       <span class="comment">// 0x260: 📌Win32 子系统看到的起始地址</span></span><br><span class="line">    VOID* LegacyPowerObject;                       <span class="comment">// 0x264: 旧版电源对象（已废弃）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ThreadListEntry</span>;</span>            <span class="comment">// 0x268: 所在进程线程列表的节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EX_RUNDOWN_REF</span> <span class="title">RundownProtect</span>;</span>         <span class="comment">// 0x270: Rundown 保护机制（防止销毁中访问）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EX_PUSH_LOCK</span> <span class="title">ThreadLock</span>;</span>               <span class="comment">// 0x274: 线程对象自旋锁</span></span><br><span class="line">    ULONG ReadClusterSize;                         <span class="comment">// 0x278: 用于文件读取的集群大小优化</span></span><br><span class="line">    <span class="keyword">volatile</span> LONG MmLockOrdering;                  <span class="comment">// 0x27C: 内存管理器锁顺序调试字段</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        ULONG CrossThreadFlags;                    <span class="comment">// 0x280: 跨线程共享的状态标志</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ULONG Terminated               : <span class="number">1</span>;    <span class="comment">// bit 0: 线程已终止</span></span><br><span class="line">            ULONG ThreadInserted           : <span class="number">1</span>;    <span class="comment">// bit 1: 📌插入线程调度队列</span></span><br><span class="line">            ULONG HideFromDebugger         : <span class="number">1</span>;    <span class="comment">// bit 2: 📌隐藏线程以防调试</span></span><br><span class="line">            ULONG ActiveImpersonationInfo  : <span class="number">1</span>;    <span class="comment">// bit 3: 当前线程启用了模拟令牌</span></span><br><span class="line">            ULONG Reserved                 : <span class="number">1</span>;    <span class="comment">// bit 4: 保留位</span></span><br><span class="line">            ULONG HardErrorsAreDisabled    : <span class="number">1</span>;    <span class="comment">// bit 5: 禁用硬错误弹窗</span></span><br><span class="line">            ULONG BreakOnTermination       : <span class="number">1</span>;    <span class="comment">// bit 6: 📌线程终止时触发断点（调试用）</span></span><br><span class="line">            ULONG SkipCreationMsg          : <span class="number">1</span>;    <span class="comment">// bit 7: 跳过创建消息通知</span></span><br><span class="line">            ULONG SkipTerminationMsg       : <span class="number">1</span>;    <span class="comment">// bit 8: 跳过终止消息通知</span></span><br><span class="line">            ULONG CopyTokenOnOpen          : <span class="number">1</span>;    <span class="comment">// bit 9: 打开线程时复制其访问令牌</span></span><br><span class="line">            ULONG ThreadIoPriority         : <span class="number">3</span>;    <span class="comment">// bit 10–12: IO 优先级（0~7）</span></span><br><span class="line">            ULONG ThreadPagePriority       : <span class="number">3</span>;    <span class="comment">// bit 13–15: 页面优先级（0~7）</span></span><br><span class="line">            ULONG RundownFail              : <span class="number">1</span>;    <span class="comment">// bit 16: Rundown 阶段失败标记</span></span><br><span class="line">            ULONG NeedsWorkingSetAging     : <span class="number">1</span>;    <span class="comment">// bit 17: 需要工作集老化处理</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        ULONG SameThreadPassiveFlags;             <span class="comment">// 0x284: 被动线程上下文状态位（当前线程本地）</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ULONG ActiveExWorker                : <span class="number">1</span>;  <span class="comment">// bit 0: 是否为激活的工作线程（Ex worker）</span></span><br><span class="line">            ULONG ExWorkerCanWaitUser           : <span class="number">1</span>;  <span class="comment">// bit 1: Ex worker 是否可以等待用户对象</span></span><br><span class="line">            ULONG MemoryMaker                   : <span class="number">1</span>;  <span class="comment">// bit 2: 是否参与内存页生成（如内存映射）</span></span><br><span class="line">            ULONG ClonedThread                  : <span class="number">1</span>;  <span class="comment">// bit 3: 是否为克隆线程（CreateRemoteThreadEx 等）</span></span><br><span class="line">            ULONG KeyedEventInUse               : <span class="number">1</span>;  <span class="comment">// bit 4: 是否正在使用 KeyedEvent</span></span><br><span class="line">            ULONG RateApcState                  : <span class="number">2</span>;  <span class="comment">// bit 5–6: 用于页面优先级/调度器统计用途</span></span><br><span class="line">            ULONG SelfTerminate                 : <span class="number">1</span>;  <span class="comment">// bit 7: 是否调用 PsTerminateThread 终止自身</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        ULONG SameThreadApcFlags;                 <span class="comment">// 0x288: 当前线程用于 APC 管理的状态标志位</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR Spare                              : <span class="number">1</span>;  <span class="comment">// bit  0: 保留</span></span><br><span class="line">            <span class="keyword">volatile</span> UCHAR StartAddressInvalid       : <span class="number">1</span>;  <span class="comment">// bit  1: 启动地址是否无效（调试或错误状态）</span></span><br><span class="line">            UCHAR EtwPageFaultCalloutActive          : <span class="number">1</span>;  <span class="comment">// bit  2: 是否正在处理 ETW 页面错误回调</span></span><br><span class="line">            UCHAR OwnsProcessWorkingSetExclusive     : <span class="number">1</span>;  <span class="comment">// bit  3: 是否独占进程工作集</span></span><br><span class="line">            UCHAR OwnsProcessWorkingSetShared        : <span class="number">1</span>;  <span class="comment">// bit  4: 是否共享进程工作集</span></span><br><span class="line">            UCHAR OwnsSystemCacheWorkingSetExclusive : <span class="number">1</span>;  <span class="comment">// bit  5: 是否独占系统缓存工作集</span></span><br><span class="line">            UCHAR OwnsSystemCacheWorkingSetShared    : <span class="number">1</span>;  <span class="comment">// bit  6: 是否共享系统缓存工作集</span></span><br><span class="line">            UCHAR OwnsSessionWorkingSetExclusive     : <span class="number">1</span>;  <span class="comment">// bit  7: 是否独占 session 工作集</span></span><br><span class="line">            UCHAR OwnsSessionWorkingSetShared        : <span class="number">1</span>;  <span class="comment">// bit  8: 是否共享 session 工作集</span></span><br><span class="line">            UCHAR OwnsProcessAddressSpaceExclusive   : <span class="number">1</span>;  <span class="comment">// bit  9: 是否独占进程地址空间</span></span><br><span class="line">            UCHAR OwnsProcessAddressSpaceShared      : <span class="number">1</span>;  <span class="comment">// bit 10: 是否共享进程地址空间</span></span><br><span class="line">            UCHAR SuppressSymbolLoad                 : <span class="number">1</span>;  <span class="comment">// bit 11: 禁用符号加载（用于调试）</span></span><br><span class="line">            UCHAR Prefetching                        : <span class="number">1</span>;  <span class="comment">// bit 12: 是否正在预取内存</span></span><br><span class="line">            UCHAR OwnsDynamicMemoryShared            : <span class="number">1</span>;  <span class="comment">// bit 13: 是否共享动态内存访问</span></span><br><span class="line">            UCHAR OwnsChangeControlAreaExclusive     : <span class="number">1</span>;  <span class="comment">// bit 14: 是否独占控制区（节段/文件映射）</span></span><br><span class="line">            UCHAR OwnsChangeControlAreaShared        : <span class="number">1</span>;  <span class="comment">// bit 15: 是否共享控制区</span></span><br><span class="line">            UCHAR OwnsPagedPoolWorkingSetExclusive   : <span class="number">1</span>;  <span class="comment">// bit 16: 是否独占分页池工作集</span></span><br><span class="line">            UCHAR OwnsPagedPoolWorkingSetShared      : <span class="number">1</span>;  <span class="comment">// bit 17: 是否共享分页池工作集</span></span><br><span class="line">            UCHAR OwnsSystemPtesWorkingSetExclusive  : <span class="number">1</span>;  <span class="comment">// bit 18: 是否独占系统 PTE 工作集</span></span><br><span class="line">            UCHAR OwnsSystemPtesWorkingSetShared     : <span class="number">1</span>;  <span class="comment">// bit 19: 是否共享系统 PTE 工作集</span></span><br><span class="line">            UCHAR TrimTrigger                        : <span class="number">2</span>;  <span class="comment">// bit 20–21: 页面修剪触发器标志</span></span><br><span class="line">            UCHAR Spare1                             : <span class="number">2</span>;  <span class="comment">// bit 22–23: 保留</span></span><br><span class="line">            UCHAR PriorityRegionActive;                    <span class="comment">// 0x28B: 当前是否处于优先处理区域（内存调度相关）</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    UCHAR CacheManagerActive;                      <span class="comment">// 0x28C: 是否参与 Cache Manager 操作</span></span><br><span class="line">    UCHAR DisablePageFaultClustering;              <span class="comment">// 0x28D: 是否禁用页面错误聚类（优化调入）</span></span><br><span class="line">    UCHAR ActiveFaultCount;                        <span class="comment">// 0x28E: 当前活动页面错误计数</span></span><br><span class="line">    UCHAR LockOrderState;                          <span class="comment">// 0x28F: 锁顺序状态标志（死锁检测辅助）</span></span><br><span class="line"></span><br><span class="line">    ULONG AlpcMessageId;                           <span class="comment">// 0x290: 当前正在处理的 ALPC 消息 ID</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        VOID* AlpcMessage;                         <span class="comment">// 0x294: 当前 ALPC 消息的指针</span></span><br><span class="line">        ULONG AlpcReceiveAttributeSet;             <span class="comment">// 0x294: ALPC 接收消息时的属性掩码</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">AlpcWaitListEntry</span>;</span>          <span class="comment">// 0x298: 等待 ALPC 消息时的链表节点</span></span><br><span class="line">    ULONG CacheManagerCount;                       <span class="comment">// 0x2A0: 参与 Cache Manager 调度的次数</span></span><br><span class="line">    ULONG IoBoostCount;                            <span class="comment">// 0x2A4: IO 优先级提升计数</span></span><br><span class="line">    ULONG IrpListLock;                             <span class="comment">// 0x2A8: IRP 列表自旋锁</span></span><br><span class="line">    VOID* ReservedForSynchTracking;                <span class="comment">// 0x2AC: 同步追踪保留字段</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">SINGLE_LIST_ENTRY</span> <span class="title">CmCallbackListHead</span>;</span>  <span class="comment">// 0x2B0: 注册表回调链表头（用于 Cm 注册通知）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h3 id="TEB"><a href="#TEB" class="headerlink" title="TEB"></a>TEB</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">TEB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">NT_TIB</span> <span class="title">NtTib</span>;</span>                                                   <span class="comment">// 0x0  存储线程信息块（TIB），包括堆栈指针、异常处理信息等。</span></span><br><span class="line">    VOID* EnvironmentPointer;                                               <span class="comment">// 0x1c 指向当前线程环境块的指针，通常包含与线程环境相关的信息。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">CLIENT_ID</span> <span class="title">ClientId</span>;</span>                                             <span class="comment">// 0x20 存储线程的客户端ID（包含进程ID和线程ID）。</span></span><br><span class="line">    VOID* ActiveRpcHandle;                                                  <span class="comment">// 0x28 当前活动的 RPC 句柄，用于跟踪线程参与的 RPC 调用。</span></span><br><span class="line">    VOID* ThreadLocalStoragePointer;                                        <span class="comment">// 0x2c 指向线程本地存储（TLS）区域的指针。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">PEB</span>* <span class="title">ProcessEnvironmentBlock</span>;</span>                                   <span class="comment">// 0x30 指向进程环境块（PEB）的指针，包含进程的全局信息。</span></span><br><span class="line">    ULONG LastErrorValue;                                                   <span class="comment">// 0x34 线程的最后错误值，用于记录线程的错误状态。</span></span><br><span class="line">    ULONG CountOfOwnedCriticalSections;                                     <span class="comment">// 0x38 线程拥有的临界区数量，表示该线程管理的临界区的数量。</span></span><br><span class="line">    VOID* CsrClientThread;                                                  <span class="comment">// 0x3c 指向客户端线程信息的指针。</span></span><br><span class="line">    VOID* Win32ThreadInfo;                                                  <span class="comment">// 0x40 指向 Windows 32 位线程信息的指针，通常用于存储 Windows 特定的线程信息。</span></span><br><span class="line">    ULONG User32Reserved[<span class="number">26</span>];                                               <span class="comment">// 0x44 保留字段，供用户使用的 32 位操作系统相关数据。</span></span><br><span class="line">    ULONG UserReserved[<span class="number">5</span>];                                                  <span class="comment">// 0xac 额外的用户保留数据。</span></span><br><span class="line">    VOID* WOW32Reserved;                                                    <span class="comment">// 0xc0 32 位应用程序的相关数据，供 WOW（Windows on Windows）支持使用。</span></span><br><span class="line">    ULONG CurrentLocale;                                                    <span class="comment">// 0xc4 当前线程的区域设置标识符。</span></span><br><span class="line">    ULONG FpSoftwareStatusRegister;                                         <span class="comment">// 0xc8 用于存储浮点运算软件状态寄存器的值。</span></span><br><span class="line">    VOID* SystemReserved1[<span class="number">54</span>];                                              <span class="comment">// 0xcc 保留字段，供系统内部使用。</span></span><br><span class="line">    LONG ExceptionCode;                                                     <span class="comment">// 0x1a4 存储与当前线程异常相关的代码。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ACTIVATION_CONTEXT_STACK</span>* <span class="title">ActivationContextStackPointer</span>;</span>        <span class="comment">// 0x1a8 指向激活上下文堆栈的指针，通常用于存储与应用程序活动相关的上下文信息。</span></span><br><span class="line">    UCHAR SpareBytes[<span class="number">36</span>];                                                   <span class="comment">// 0x1ac 保留字节，供未来使用。</span></span><br><span class="line">    ULONG TxFsContext;                                                      <span class="comment">// 0x1d0 用于跟踪事务文件系统（TxFs）上下文的字段。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">GDI_TEB_BATCH</span> <span class="title">GdiTebBatch</span>;</span>                                      <span class="comment">// 0x1d4 与 GDI（图形设备接口）相关的线程批处理信息。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">CLIENT_ID</span> <span class="title">RealClientId</span>;</span>                                         <span class="comment">// 0x6b4 线程的实际客户端ID，包含进程ID和线程ID。</span></span><br><span class="line">    VOID* GdiCachedProcessHandle;                                           <span class="comment">// 0x6bc 存储 GDI 缓存的进程句柄。</span></span><br><span class="line">    ULONG GdiClientPID;                                                     <span class="comment">// 0x6c0 GDI 客户端进程ID。</span></span><br><span class="line">    ULONG GdiClientTID;                                                     <span class="comment">// 0x6c4 GDI 客户端线程ID。</span></span><br><span class="line">    VOID* GdiThreadLocalInfo;                                               <span class="comment">// 0x6c8 存储 GDI 线程本地信息的指针。</span></span><br><span class="line">    ULONG Win32ClientInfo[<span class="number">62</span>];                                              <span class="comment">// 0x6cc 存储 Windows 32 位客户端信息的数组。</span></span><br><span class="line">    VOID* glDispatchTable[<span class="number">233</span>];                                             <span class="comment">// 0x7c4 OpenGL 调度表，包含图形渲染相关的函数指针。</span></span><br><span class="line">    ULONG glReserved1[<span class="number">29</span>];                                                  <span class="comment">// 0xb68 OpenGL 保留字段。</span></span><br><span class="line">    VOID* glReserved2;                                                      <span class="comment">// 0xbdc 额外的 OpenGL 保留字段。</span></span><br><span class="line">    VOID* glSectionInfo;                                                    <span class="comment">// 0xbe0 OpenGL 部分信息。</span></span><br><span class="line">    VOID* glSection;                                                        <span class="comment">// 0xbe4 OpenGL 部分数据。</span></span><br><span class="line">    VOID* glTable;                                                          <span class="comment">// 0xbe8 OpenGL 表格数据。</span></span><br><span class="line">    VOID* glCurrentRC;                                                      <span class="comment">// 0xbec 当前渲染上下文。</span></span><br><span class="line">    VOID* glContext;                                                        <span class="comment">// 0xbf0 OpenGL 上下文。</span></span><br><span class="line">    ULONG LastStatusValue;                                                  <span class="comment">// 0xbf4 记录线程的最后状态值。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">StaticUnicodeString</span>;</span>                             <span class="comment">// 0xbf8 静态 Unicode 字符串，用于存储静态字符串数据。</span></span><br><span class="line">    WCHAR StaticUnicodeBuffer[<span class="number">261</span>];                                         <span class="comment">// 0xc00 静态 Unicode 字符串缓冲区。</span></span><br><span class="line">    VOID* DeallocationStack;                                                <span class="comment">// 0xe0c 用于存储内存回收的堆栈指针。</span></span><br><span class="line">    VOID* TlsSlots[<span class="number">64</span>];                                                     <span class="comment">// 0xe10 线程本地存储（TLS）槽数组，用于存储每个槽中的 TLS 数据。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">TlsLinks</span>;</span>                                            <span class="comment">// 0xf10 与 TLS 相关的链表。</span></span><br><span class="line">    VOID* Vdm;                                                              <span class="comment">// 0xf18 VDM（虚拟 DOS 模式）相关数据。</span></span><br><span class="line">    VOID* ReservedForNtRpc;                                                 <span class="comment">// 0xf1c 保留给 NT RPC 的数据。</span></span><br><span class="line">    VOID* DbgSsReserved[<span class="number">2</span>];                                                 <span class="comment">// 0xf20 用于调试 SS（子系统）相关的保留数据。</span></span><br><span class="line">    ULONG HardErrorMode;                                                    <span class="comment">// 0xf28 用于线程处理硬错误模式的状态。</span></span><br><span class="line">    VOID* Instrumentation[<span class="number">9</span>];                                               <span class="comment">// 0xf2c 用于线程的性能监控和调试数据的数组。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">GUID</span> <span class="title">ActivityId</span>;</span>                                                <span class="comment">// 0xf50 当前线程的活动标识符（GUID）。</span></span><br><span class="line">    VOID* SubProcessTag;                                                    <span class="comment">// 0xf60 子进程标记。</span></span><br><span class="line">    VOID* EtwLocalData;                                                     <span class="comment">// 0xf64 本地 ETW（事件跟踪）数据。</span></span><br><span class="line">    VOID* EtwTraceData;                                                     <span class="comment">// 0xf68 ETW 追踪数据。</span></span><br><span class="line">    VOID* WinSockData;                                                      <span class="comment">// 0xf6c 与 Windows Sockets（WinSock）相关的数据。</span></span><br><span class="line">    ULONG GdiBatchCount;                                                    <span class="comment">// 0xf70 GDI 批量计数。</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">PROCESSOR_NUMBER</span> <span class="title">CurrentIdealProcessor</span>;</span>                     <span class="comment">// 0xf74 当前理想处理器的编号。</span></span><br><span class="line">        ULONG IdealProcessorValue;                                          <span class="comment">// 0xf74 理想处理器的数值表示。</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            UCHAR ReservedPad0;                                             <span class="comment">// 0xf74 保留字段。</span></span><br><span class="line">            UCHAR ReservedPad1;                                             <span class="comment">// 0xf75 保留字段。</span></span><br><span class="line">            UCHAR ReservedPad2;                                             <span class="comment">// 0xf76 保留字段。</span></span><br><span class="line">            UCHAR IdealProcessor;                                           <span class="comment">// 0xf77 理想处理器的编号。</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG GuaranteedStackBytes;                                             <span class="comment">// 0xf78 保证的栈空间字节数。</span></span><br><span class="line">    VOID* ReservedForPerf;                                                  <span class="comment">// 0xf7c 保留给性能监控的空间。</span></span><br><span class="line">    VOID* ReservedForOle;                                                   <span class="comment">// 0xf80 保留给 OLE（对象链接和嵌入）相关数据。</span></span><br><span class="line">    ULONG WaitingOnLoaderLock;                                              <span class="comment">// 0xf84 用于表示当前线程是否在等待加载锁。</span></span><br><span class="line">    VOID* SavedPriorityState;                                               <span class="comment">// 0xf88 保存的线程优先级状态。</span></span><br><span class="line">    ULONG SoftPatchPtr1;                                                    <span class="comment">// 0xf8c 软件补丁指针1。</span></span><br><span class="line">    VOID* ThreadPoolData;                                                   <span class="comment">// 0xf90 线程池数据。</span></span><br><span class="line">    VOID** TlsExpansionSlots;                                               <span class="comment">// 0xf94 扩展的 TLS 槽数组。</span></span><br><span class="line">    ULONG MuiGeneration;                                                    <span class="comment">// 0xf98 MUI（多语言用户界面）版本。</span></span><br><span class="line">    ULONG IsImpersonating;                                                  <span class="comment">// 0xf9c 标志，表示线程是否在模拟其他安全主体。</span></span><br><span class="line">    VOID* NlsCache;                                                         <span class="comment">// 0xfa0 国家语言支持（NLS）缓存。</span></span><br><span class="line">    VOID* pShimData;                                                        <span class="comment">// 0xfa4 与程序兼容性（Shim）相关的数据。</span></span><br><span class="line">    ULONG HeapVirtualAffinity;                                              <span class="comment">// 0xfa8 堆的虚拟亲和性。</span></span><br><span class="line">    VOID* CurrentTransactionHandle;                                         <span class="comment">// 0xfac 当前事务的句柄。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">TEB_ACTIVE_FRAME</span>* <span class="title">ActiveFrame</span>;</span>                                  <span class="comment">// 0xfb0 活动帧信息。</span></span><br><span class="line">    VOID* FlsData;                                                          <span class="comment">// 0xfb4 与 FLS（线程本地存储）相关的数据。</span></span><br><span class="line">    VOID* PreferredLanguages;                                               <span class="comment">// 0xfb8 用户首选语言列表。</span></span><br><span class="line">    VOID* UserPrefLanguages;                                                <span class="comment">// 0xfbc 用户偏好的语言列表。</span></span><br><span class="line">    VOID* MergedPrefLanguages;                                              <span class="comment">// 0xfc0 合并的语言偏好列表。</span></span><br><span class="line">    ULONG MuiImpersonation;                                                 <span class="comment">// 0xfc4 MUI 模拟状态。</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">volatile</span> USHORT CrossTebFlags;                                      <span class="comment">// 0xfc8 用于线程的跨 TEB 标志。</span></span><br><span class="line">        USHORT SpareCrossTebBits:<span class="number">16</span>;                                        <span class="comment">// 0xfc8 备用的跨 TEB 位。</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        USHORT SameTebFlags;                                                <span class="comment">// 0xfca 同一线程环境块（TEB）标志</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            USHORT SafeThunkCall:<span class="number">1</span>;                                         <span class="comment">// bit 0: 安全调用标志</span></span><br><span class="line">            USHORT InDebugPrint:<span class="number">1</span>;                                          <span class="comment">// bit 1: 当前线程处于调试打印模式</span></span><br><span class="line">            USHORT HasFiberData:<span class="number">1</span>;                                          <span class="comment">// bit 2: 当前线程拥有纤程数据</span></span><br><span class="line">            USHORT SkipThreadAttach:<span class="number">1</span>;                                      <span class="comment">// bit 3: 跳过线程附加操作</span></span><br><span class="line">            USHORT WerInShipAssertCode:<span class="number">1</span>;                                   <span class="comment">// bit 4: 标志，表示线程处于断言代码中</span></span><br><span class="line">            USHORT RanProcessInit:<span class="number">1</span>;                                        <span class="comment">// bit 5: 标志，表示进程初始化已完成</span></span><br><span class="line">            USHORT ClonedThread:<span class="number">1</span>;                                          <span class="comment">// bit 6: 标志，表示该线程为克隆线程</span></span><br><span class="line">            USHORT SuppressDebugMsg:<span class="number">1</span>;                                      <span class="comment">// bit 7: 是否抑制调试信息</span></span><br><span class="line">            USHORT DisableUserStackWalk:<span class="number">1</span>;                                  <span class="comment">// bit 8: 禁用用户栈跟踪</span></span><br><span class="line">            USHORT RtlExceptionAttached:<span class="number">1</span>;                                  <span class="comment">// bit 9: 标志，表示 RTL 异常已附加</span></span><br><span class="line">            USHORT InitialThread:<span class="number">1</span>;                                         <span class="comment">// bit 10: 标志，表示这是初始线程</span></span><br><span class="line">            USHORT SpareSameTebBits:<span class="number">5</span>;                                      <span class="comment">// bit 11-15: 备用位，暂时未使用</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    VOID* TxnScopeEnterCallback;                                            <span class="comment">// 0xfcc 事务作用域进入回调函数。</span></span><br><span class="line">    VOID* TxnScopeExitCallback;                                             <span class="comment">// 0xfd0 事务作用域退出回调函数。</span></span><br><span class="line">    VOID* TxnScopeContext;                                                  <span class="comment">// 0xfd4 事务作用域上下文数据。</span></span><br><span class="line">    ULONG LockCount;                                                        <span class="comment">// 0xfd8 锁计数，表示当前线程持有的锁的数量。</span></span><br><span class="line">    ULONG SpareUlong0;                                                      <span class="comment">// 0xfdc 备用的 ULONG 数据。</span></span><br><span class="line">    VOID* ResourceRetValue;                                                 <span class="comment">// 0xfe0 资源返回值。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h2><p><strong>线程切换（Thread Context Switch）</strong>是指操作系统将 CPU 执行权从一个线程转移到另一个线程的过程。这个过程中，系统需要<strong>保存当前线程的上下文</strong>（CPU 寄存器、程序计数器、栈指针等），并<strong>恢复另一个线程的上下文</strong>，使其可以从上次停止的位置继续执行。</p>
<p>在 Windows 内核中，线程对象由结构体 <code>_KTHREAD</code> 表示，其 <code>State</code> 字段（类型为 <code>KTHREAD_STATE</code>）用于标识线程当前所处的调度阶段。该状态直接影响调度器是否会选择该线程参与运行。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 线程调度状态（KTHREAD_STATE）</span></span><br><span class="line"><span class="comment">// 表示线程在调度器中的生命周期状态。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">KTHREAD_STATE</span> &#123;</span></span><br><span class="line">    Initialized,    <span class="comment">// （0）已初始化：线程对象已构造但尚未调度</span></span><br><span class="line">    Ready,          <span class="comment">// （1）就绪：线程已插入就绪队列，等待运行</span></span><br><span class="line">    Running,        <span class="comment">// （2）运行中：线程正在某处理器上执行</span></span><br><span class="line">    Standby,        <span class="comment">// （3）待命：被选为下一个要运行的线程</span></span><br><span class="line">    Terminated,     <span class="comment">// （4）已终止：线程执行完毕，等待资源释放</span></span><br><span class="line">    Waiting,        <span class="comment">// （5）等待中：线程正在等待某个事件或超时</span></span><br><span class="line">    Transition,     <span class="comment">// （6）过渡态：资源尚未准备好，暂不可调度</span></span><br><span class="line">    DeferredReady,  <span class="comment">// （7）延迟就绪：满足就绪条件但延后入队</span></span><br><span class="line">    GateWait        <span class="comment">// （8）等待 Gate：等待底层同步对象 Gate</span></span><br><span class="line">&#125; KTHREAD_STATE;</span><br></pre></td></tr></table></figure></div>

<p>Windows 的线程切换可以分为两种主要类型：</p>
<ul>
<li><strong>抢占式线程切换（Preemptive Context Switch）</strong> ：由系统调度器（Scheduler）主动发起，强制当前线程让出 CPU。这个过程非线程自身控制，可能在任意用户态或内核态发生。常见的触发过程如下：<ul>
<li>当前线程的时间片耗尽（Quantum 用尽）；</li>
<li>有更高优先级的线程进入 Ready 状态；</li>
<li>电源管理事件（如睡眠&#x2F;唤醒）；</li>
<li>核心调度器策略判断需换出当前线程。</li>
</ul>
</li>
<li><strong>协作式线程切换（Voluntary &#x2F; Cooperative Context Switch）</strong> ：线程自身调用系统服务（如阻塞调用）主动放弃 CPU 使用权。这种情况是线程主动调用内核 API 完成，对于 UI 线程、I&#x2F;O 密集型线程非常常见。常见的触发方式包括：<ul>
<li>调用休眠或等待类 API，例如 <code>Sleep()</code>、<code>WaitForSingleObject()</code>、<code>NtDelayExecution()</code>；</li>
<li>调用 <code>KiSwapThread()</code> 主动让出 CPU；</li>
<li>执行同步或阻塞型 I&#x2F;O 操作（如 <code>ReadFile()</code>，在数据尚未就绪时会导致线程阻塞）。</li>
</ul>
</li>
</ul>
<h3 id="线程切换过程"><a href="#线程切换过程" class="headerlink" title="线程切换过程"></a>线程切换过程</h3><p>不论是哪种线程切换方式，最终线程切换都是调用 <code>KiSwapContext</code> 函数完成。这个函数是 Windows 内核调度器中的线程上下文切换包装函数，具体作用是<strong>保存调用者环境，准备参数（OldThread &#x2F; NewThread &#x2F; WaitIrql &#x2F; KPCR），调用核心的 <code>_SwapContext</code> 函数进行线程切换，然后恢复环境返回</strong>。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>由于这个函数内部发生了线程切换，因此从这个函数返回时的堆栈不一定是这个函数调用时的堆栈。</p>

    </div>
  </div>

<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">@KiSwapContext@<span class="number">8</span> proc <span class="built_in">near</span>               <span class="comment">; KiSwapContext(int OldThread, int NewThread)</span></span><br><span class="line">                                         <span class="comment">; 用于调度器切换线程上下文</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; ------------------------------------------------------------</span></span><br><span class="line"><span class="comment">; 保存调用者现场（用于保护寄存器）</span></span><br><span class="line"><span class="comment">; ------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">sub</span>     <span class="built_in">esp</span>, <span class="number">10h</span>                     <span class="comment">; 为保存 ebx/esi/edi/ebp 开辟栈空间</span></span><br><span class="line">    <span class="keyword">mov</span>     [<span class="built_in">esp</span>+<span class="number">10h</span>-<span class="number">4</span>], <span class="built_in">ebx</span>             <span class="comment">; 保存 ebx（寄存器变量）</span></span><br><span class="line">    <span class="keyword">mov</span>     [<span class="built_in">esp</span>+<span class="number">10h</span>-<span class="number">8</span>], <span class="built_in">esi</span>             <span class="comment">; 保存 esi（新线程指针）</span></span><br><span class="line">    <span class="keyword">mov</span>     [<span class="built_in">esp</span>+<span class="number">10h</span>-<span class="number">0Ch</span>], <span class="built_in">edi</span>           <span class="comment">; 保存 edi（旧线程指针）</span></span><br><span class="line">    <span class="keyword">mov</span>     [<span class="built_in">esp</span>+<span class="number">10h</span>-<span class="number">10h</span>], <span class="built_in">ebp</span>           <span class="comment">; 保存 ebp（调用者帧指针）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; ------------------------------------------------------------</span></span><br><span class="line"><span class="comment">; 获取当前处理器的 KPCR（fs:[0] 存储 _KPCR.SelfPcr 指针）</span></span><br><span class="line"><span class="comment">; ------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">ebx</span>, large <span class="built_in">fs</span>:_KPCR<span class="number">.</span>SelfPcr  <span class="comment">; KPCR（核本地数据）基址 =&gt; ebx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; ------------------------------------------------------------</span></span><br><span class="line"><span class="comment">; 参数处理与寄存器设置</span></span><br><span class="line"><span class="comment">; ------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">edi</span>, <span class="built_in">ecx</span>                     <span class="comment">; edi = OldThread（旧线程）</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">esi</span>, <span class="built_in">edx</span>                     <span class="comment">; esi = NewThread（新线程）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">movzx</span>   <span class="built_in">ecx</span>, [<span class="built_in">edi</span>+_KTHREAD<span class="number">.</span>WaitIrql] <span class="comment">; ecx = 旧线程的等待 IRQL，用于 SwapContext 控制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; ------------------------------------------------------------</span></span><br><span class="line"><span class="comment">; 调用 SwapContext（核心上下文切换逻辑）</span></span><br><span class="line"><span class="comment">; 参数：ECX=WaitIrql，ESI=NewThread，EDI=OldThread，EBX=KPCR</span></span><br><span class="line"><span class="comment">; ------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">call</span>    _SwapContext@<span class="number">0</span>               <span class="comment">; 进入调度器切换线程上下文</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; ------------------------------------------------------------</span></span><br><span class="line"><span class="comment">; 恢复调用者现场（恢复保存的寄存器）</span></span><br><span class="line"><span class="comment">; ------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">ebp</span>, [<span class="built_in">esp</span>+<span class="number">10h</span>-<span class="number">10h</span>]           <span class="comment">; 恢复调用者的 ebp</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">edi</span>, [<span class="built_in">esp</span>+<span class="number">10h</span>-<span class="number">0Ch</span>]           <span class="comment">; 恢复旧线程指针</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">esi</span>, [<span class="built_in">esp</span>+<span class="number">10h</span>-<span class="number">8</span>]            <span class="comment">; 恢复新线程指针</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">ebx</span>, [<span class="built_in">esp</span>+<span class="number">10h</span>-<span class="number">4</span>]             <span class="comment">; 恢复 ebx</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">esp</span>, <span class="number">10h</span>                     <span class="comment">; 回收本地栈空间</span></span><br><span class="line">    <span class="keyword">retn</span>                                <span class="comment">; 返回调用者（调度完成）</span></span><br><span class="line"></span><br><span class="line">@KiSwapContext@<span class="number">8</span> endp</span><br></pre></td></tr></table></figure></div>

<p><code>_SwapContext</code> 是线程切换的核心函数，我们主要关注其中的：</p>
<ul>
<li>切换内核栈：<code>ESP &lt;=&gt; KTHREAD.KernelStack</code></li>
<li>切换 <code>CR3</code>：<code>CR3 &lt;=&gt; KTHREAD.DirectoryTableBase</code></li>
</ul>
<p>除此之外，由于 CPU 核心不是线程独占的，因此线程切换的时候还需要更新与 CPU 核心绑定的结构中跟新线程相关的信息：</p>
<ul>
<li>更新 <code>TSS</code> 中的 <code>ESP0</code> 指向新内核栈的 <code>TRAP_FRAME</code> 尾部。</li>
<li>更新 <code>KPCR</code> 和 GDT 表中对应的 <code>FS</code> 段指向新线程的 <code>TEB</code>。</li>
<li>更新 <code>KPCR</code> 中的异常链表。</li>
</ul>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line">_SwapContext@<span class="number">0</span> proc <span class="built_in">near</span>                     <span class="comment">; 上下文切换主函数，保存当前线程状态，切换到目标线程</span></span><br><span class="line">                                            <span class="comment">; 原型（按调用约定及调用点推断）：</span></span><br><span class="line">                                            <span class="comment">; int __stdcall _SwapContext(</span></span><br><span class="line">                                            <span class="comment">;     _KPCR *Pcr,              ← 传入 ebx</span></span><br><span class="line">                                            <span class="comment">;     _KTHREAD *OldThread,     ← 传入 edi</span></span><br><span class="line">                                            <span class="comment">;     _KTHREAD *NewThread,     ← 传入 esi</span></span><br><span class="line">                                            <span class="comment">;     UCHAR WaitIrql           ← 传入 ecx</span></span><br><span class="line">                                            <span class="comment">; );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 参数说明：</span></span><br><span class="line"><span class="comment">;   ebx = 当前处理器的 KPCR（Kernel Processor Control Region）</span></span><br><span class="line"><span class="comment">;   edi = 老线程（即当前正在运行的线程，_KTHREAD *）</span></span><br><span class="line"><span class="comment">;   esi = 新线程（即即将被切换进来的线程，_KTHREAD *）</span></span><br><span class="line"><span class="comment">;   ecx = 当前线程的 WaitIrql，用于指示切换时的中断请求级别</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; ------------------------------------------------------------</span></span><br><span class="line"><span class="comment">; 检查目标线程是否已被其他处理器标记为 Running 状态；</span></span><br><span class="line"><span class="comment">; 若已运行，则自旋等待（避免多核同时调度该线程）；</span></span><br><span class="line"><span class="comment">; ------------------------------------------------------------</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">CheckRunningFlag:</span></span><br><span class="line">    <span class="keyword">cmp</span>     [<span class="built_in">esi</span>+_ETHREAD<span class="number">.</span>Tcb<span class="number">.</span>Running], <span class="number">0</span>        <span class="comment">; 检查目标线程 Running 状态位（Running == 1 表示该线程正在执行中）</span></span><br><span class="line">    <span class="keyword">jz</span>      SetRunning                           <span class="comment">; 若未运行，跳转设置 Running 状态为 1</span></span><br><span class="line">    <span class="keyword">pause</span>                                        <span class="comment">; 自旋等待，减轻总线压力，适用于多处理器下等待资源</span></span><br><span class="line">    <span class="keyword">jmp</span>     CheckRunningFlag                     <span class="comment">; 循环检查直到 Running 被清除为止（即等待其他处理器完成切换）</span></span><br><span class="line"><span class="comment">; ------------------------------------------------------------</span></span><br><span class="line"><span class="comment">; 设置目标线程为 Running 状态；</span></span><br><span class="line"><span class="comment">; 同时统计老线程的实际运行时间（基于 TSC）并更新当前 PRCB 的运行周期；</span></span><br><span class="line"><span class="comment">; ------------------------------------------------------------</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">SetRunning:</span></span><br><span class="line">    <span class="keyword">mov</span>     [<span class="built_in">esi</span>+_ETHREAD<span class="number">.</span>Tcb<span class="number">.</span>Running], <span class="number">1</span>        <span class="comment">; 将目标线程标记为 Running，防止其他处理器并发调度该线程</span></span><br><span class="line">    <span class="keyword">push</span>    <span class="built_in">ecx</span>                                  <span class="comment">; 保存 ecx（WaitIrql），后续可能被 clobber</span></span><br><span class="line">    <span class="keyword">cli</span>                                          <span class="comment">; 清除中断标志位，避免在更新周期时发生中断切换</span></span><br><span class="line">    <span class="keyword">dec</span>     [<span class="built_in">ebx</span>+_KPCR<span class="number">.</span>PrcbData<span class="number">.</span>NestingLevel]    <span class="comment">; 将 NestingLevel 减 1，进入调度器内部处理（防止递归调度）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rdtsc</span>                                        <span class="comment">; 获取当前时间戳计数器（EDX:EAX = TSC 当前值，单位为周期）</span></span><br><span class="line">    <span class="keyword">sub</span>     <span class="built_in">eax</span>, [<span class="built_in">ebx</span>+_KPCR<span class="number">.</span>PrcbData<span class="number">.</span>StartCycles]       <span class="comment">; 当前 TSC（低）- 上次记录的起始 TSC（低） = 本次运行周期（低）</span></span><br><span class="line">    <span class="keyword">sbb</span>     <span class="built_in">edx</span>, [<span class="built_in">ebx</span>+_KPCR<span class="number">.</span>PrcbData<span class="number">.</span>StartCycles+<span class="number">4</span>]     <span class="comment">; 当前 TSC（高）- 上次记录的 TSC（高） - 借位</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">add</span>     [<span class="built_in">ebx</span>+_KPCR<span class="number">.</span>PrcbData<span class="number">.</span>CycleTime], <span class="built_in">eax</span>         <span class="comment">; 将本次运行周期加到 PRCB 的累计周期（低位）</span></span><br><span class="line">    <span class="keyword">adc</span>     [<span class="built_in">ebx</span>+_KPCR<span class="number">.</span>PrcbData<span class="number">.</span>CycleTime+<span class="number">4</span>], <span class="built_in">edx</span>       <span class="comment">; 累加高位并处理进位</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">add</span>     [<span class="built_in">ebx</span>+_KPCR<span class="number">.</span>PrcbData<span class="number">.</span>StartCycles], <span class="built_in">eax</span>       <span class="comment">; 更新 StartCycles 为当前 TSC，作为下次计时起点（低位）</span></span><br><span class="line">    <span class="keyword">adc</span>     [<span class="built_in">ebx</span>+_KPCR<span class="number">.</span>PrcbData<span class="number">.</span>StartCycles+<span class="number">4</span>], <span class="built_in">edx</span>     <span class="comment">; 高位更新</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; ------------------------------------------------------------</span></span><br><span class="line"><span class="comment">; 检查线程调度控制标志位：</span></span><br><span class="line"><span class="comment">; 若启用了 CpuThrottled（限速）或 CounterProfiling（性能分析），则进入特殊路径；</span></span><br><span class="line"><span class="comment">; ------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">test</span>    [<span class="built_in">esi</span>+_KTHREAD<span class="number">.</span>Header<span class="number">.</span>ThreadControlFlags], <span class="number">5</span> <span class="comment">; bit0: CpuThrottled, bit2: CounterProfiling</span></span><br><span class="line">                                                              <span class="comment">; 若线程启用限速或被调度用于分析，进入特殊处理逻辑</span></span><br><span class="line">    <span class="keyword">jnz</span>     HandleProfiling                                  <span class="comment">; 分支到 profiling/throttling 特殊处理流程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; ------------------------------------------------------------</span></span><br><span class="line"><span class="comment">; 正常路径继续：更新调度信息，保存老线程上下文；</span></span><br><span class="line"><span class="comment">; ------------------------------------------------------------</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">ContinueContextSwitch:</span></span><br><span class="line">    <span class="keyword">sti</span>                                          <span class="comment">; 恢复中断使能，允许抢占中断（已完成时间计算）</span></span><br><span class="line">    <span class="keyword">inc</span>     [<span class="built_in">ebx</span>+_KPCR<span class="number">.</span>ContextSwitches]          <span class="comment">; 增加当前处理器上的上下文切换计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">push</span>    [<span class="built_in">ebx</span>+_KPCR<span class="number">.</span>NtTib<span class="number">.</span>ExceptionList]      <span class="comment">; 保存老线程的异常处理链表头（挂接在 TIB 中）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; ------------------------------------------------------------</span></span><br><span class="line"><span class="comment">; 判断老线程是否使用过浮点环境（FPU）；</span></span><br><span class="line"><span class="comment">; 若使用过则保存其 FPU 状态；</span></span><br><span class="line"><span class="comment">; ------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">ebp</span>, <span class="built_in">cr0</span>                             <span class="comment">; 读取 CR0 控制寄存器（判断 FPU 是否启用）</span></span><br><span class="line">    <span class="keyword">movsx</span>   <span class="built_in">eax</span>, [<span class="built_in">edi</span>+_KTHREAD<span class="number">.</span>NpxState]         <span class="comment">; 获取老线程的 NpxState（记录 FPU 使用情况）</span></span><br><span class="line">    <span class="keyword">test</span>    <span class="built_in">al</span>, <span class="built_in">al</span>                               <span class="comment">; NpxState == 0 表示未使用 FPU</span></span><br><span class="line">    <span class="keyword">jz</span>      SkipFpuSave                          <span class="comment">; 若未使用，跳过 FPU 保存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">ecx</span>, [<span class="built_in">edi</span>+_KTHREAD<span class="number">.</span>InitialStack]     <span class="comment">; 获取老线程的初始栈地址（ESP 原始值）</span></span><br><span class="line">    <span class="keyword">test</span>    <span class="built_in">ebp</span>, <span class="number">0Eh</span>                             <span class="comment">; 检查 EM（bit2）或 TS（bit3）是否设置</span></span><br><span class="line">    <span class="keyword">jz</span>      SkipCr0Restore</span><br><span class="line">    <span class="keyword">and</span>     <span class="built_in">ebp</span>, <span class="number">0FFFFFFF1h</span>                      <span class="comment">; 清除 EM 和 TS，允许访问浮点指令</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">cr0</span>, <span class="built_in">ebp</span>                             <span class="comment">; 更新 CR0</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">SkipCr0Restore:</span></span><br><span class="line">    <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">ecx</span>-<span class="number">210h</span>]                      <span class="comment">; 栈顶下移 0x210 字节用于保存 fxsave 区域</span></span><br><span class="line">    <span class="keyword">cdq</span>                                          <span class="comment">; 清空 edx（部分兼容性指令，不影响 fxsave）</span></span><br><span class="line">    <span class="keyword">fxsave</span>  [<span class="built_in">ecx</span>]                                <span class="comment">; 使用 fxsave 保存 FPU/MMX/XMM 状态</span></span><br><span class="line">    <span class="keyword">and</span>     [<span class="built_in">edi</span>+_KTHREAD<span class="number">.</span>NpxState], <span class="number">0F8h</span>        <span class="comment">; 清除 NpxState 中的 TS 标志（bit0~2）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebx</span>+_KPCR<span class="number">.</span>PrcbData<span class="number">.</span>NpxThread], <span class="number">0</span>    <span class="comment">; 清除 PRCB 中记录的 FPU 所属线程（表示当前未使用 FPU）</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">SkipFpuSave:</span></span><br><span class="line"><span class="comment">; ------------------------------------------------------------</span></span><br><span class="line"><span class="comment">; 📌切换到新线程的内核栈；</span></span><br><span class="line"><span class="comment">; ------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span>     [<span class="built_in">edi</span>+_KTHREAD<span class="number">.</span>KernelStack], <span class="built_in">esp</span>      <span class="comment">; 保存老线程当前栈顶地址</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">esi</span>+_KTHREAD<span class="number">.</span>InitialStack]     <span class="comment">; 取新线程初始栈指针（备用）</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">esp</span>, [<span class="built_in">esi</span>+_KTHREAD<span class="number">.</span>KernelStack]      <span class="comment">; 切换到新线程的内核栈顶（ESP）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; ------------------------------------------------------------</span></span><br><span class="line"><span class="comment">; 📌若新旧线程属于不同进程，则切换地址空间（更新 CR3）；</span></span><br><span class="line"><span class="comment">; ------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">ebp</span>, [<span class="built_in">esi</span>+_KTHREAD<span class="number">.</span>ApcState<span class="number">.</span>Process] <span class="comment">; 新线程所属进程对象（EPROCESS）</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">edi</span>+_KTHREAD<span class="number">.</span>ApcState<span class="number">.</span>Process] <span class="comment">; 老线程所属进程</span></span><br><span class="line">    <span class="keyword">cmp</span>     <span class="built_in">ebp</span>, <span class="built_in">eax</span></span><br><span class="line">    <span class="keyword">jz</span>      SkipCr3Switch                        <span class="comment">; 若是同一进程，无需切换 CR3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebx</span>+_KPCR<span class="number">.</span>SetMemberCopy]       <span class="comment">; 当前处理器的处理器位图（用于 ActiveProcessors）</span></span><br><span class="line">    <span class="keyword">lock</span> <span class="keyword">xor</span> [<span class="built_in">ebp</span>+_KPROCESS<span class="number">.</span>ActiveProcessors<span class="number">.</span>Bitmap], <span class="built_in">ecx</span> <span class="comment">; 将当前处理器标记为属于新进程</span></span><br><span class="line">    <span class="keyword">lock</span> <span class="keyword">xor</span> [<span class="built_in">eax</span>+_KPROCESS<span class="number">.</span>ActiveProcessors<span class="number">.</span>Bitmap], <span class="built_in">ecx</span> <span class="comment">; 从老进程清除该处理器标记</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+_KPROCESS<span class="number">.</span>LdtDescriptor<span class="number">.</span>LimitLow] <span class="comment">; 检查新进程是否启用 LDT</span></span><br><span class="line">    <span class="keyword">or</span>      <span class="built_in">ecx</span>, [<span class="built_in">eax</span>+_KPROCESS<span class="number">.</span>LdtDescriptor<span class="number">.</span>LimitLow]</span><br><span class="line">    <span class="keyword">jnz</span>     SwitchToLdt                          <span class="comment">; 若任一进程启用了 LDT，则切换 LDT 描述符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+_EPROCESS<span class="number">.</span>Pcb<span class="number">.</span>DirectoryTableBase] <span class="comment">; 新进程页目录表基址</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">cr3</span>, <span class="built_in">eax</span>                             <span class="comment">; 更新页目录寄存器 CR3（切换地址空间）</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">SkipCr3Switch:</span></span><br><span class="line"><span class="comment">; ------------------------------------------------------------</span></span><br><span class="line"><span class="comment">; 📌设置 TSS（任务状态段）中的 esp0 和 IoMapBase 字段；</span></span><br><span class="line"><span class="comment">; esp0 是任务切换后 CPU 自动加载到栈指针的值；</span></span><br><span class="line"><span class="comment">; IoMapBase 定义了 I/O 权限位图的起始位置；</span></span><br><span class="line"><span class="comment">; ------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">ecx</span>, [<span class="built_in">esi</span>+_ETHREAD<span class="number">.</span>Tcb<span class="number">.</span>InitialStack]         <span class="comment">; 获取新线程初始栈（未减偏移）</span></span><br><span class="line">    <span class="keyword">lea</span>     <span class="built_in">eax</span>, [<span class="built_in">ecx</span>-<span class="number">210h</span>]                              <span class="comment">; 计算 FPU 状态保存区首地址（对齐 esp0）</span></span><br><span class="line">    <span class="keyword">test</span>    <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span>-<span class="number">1Ah</span>], <span class="number">2</span>                        <span class="comment">; 检查 EFLAGS 的 bit 17（VM）属性，是否为 Virtual-8086 模式</span></span><br><span class="line">    <span class="keyword">jnz</span>     SetTss                                       <span class="comment">; 若是 V86 模式，直接设置 esp0</span></span><br><span class="line">    <span class="keyword">sub</span>     <span class="built_in">eax</span>, <span class="number">10h</span>                                     <span class="comment">; 否则为普通模式，跳过保存 V86 模式 4 个段寄存器所需的空间</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">SetTss:</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">edx</span>, [<span class="built_in">ebx</span>+_KPCR<span class="number">.</span>TssCopy]                     <span class="comment">; 获取当前处理器的 TSS（任务状态段）地址</span></span><br><span class="line">    <span class="keyword">mov</span>     [<span class="built_in">edx</span>+_KTSS<span class="number">.</span>Esp0], <span class="built_in">eax</span>                        <span class="comment">; 设置 esp0 为当前栈地址（任务切换后 CPU 使用）</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">ax</span>, [<span class="built_in">ebp</span>+_KPROCESS<span class="number">.</span>IopmOffset]               <span class="comment">; 获取新进程的 I/O 位图偏移（决定是否允许直接访问 I/O）</span></span><br><span class="line">    <span class="keyword">mov</span>     [<span class="built_in">edx</span>+_KTSS<span class="number">.</span>IoMapBase], <span class="built_in">ax</span>                    <span class="comment">; 设置 IOPM 基址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; ------------------------------------------------------------</span></span><br><span class="line"><span class="comment">; 若启用了 ETW 上下文切换事件记录，则跳转进入日志记录路径；</span></span><br><span class="line"><span class="comment">; 否则进入正常路径继续上下文切换；</span></span><br><span class="line"><span class="comment">; ------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">test</span>    <span class="built_in">ds</span>:EtwLogFlags, <span class="number">4</span>                            <span class="comment">; 检查 ETW 是否启用了线程切换日志（bit2）</span></span><br><span class="line">    <span class="keyword">jnz</span>     LogEtwContextSwitch                          <span class="comment">; 若启用，进入事件记录流程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; ------------------------------------------------------------</span></span><br><span class="line"><span class="comment">; 清除老线程 Running 标志，标记其不再运行；</span></span><br><span class="line"><span class="comment">; 同时清除 GS 寄存器（常用于 TLS）；</span></span><br><span class="line"><span class="comment">; ------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span>     [<span class="built_in">edi</span>+_ETHREAD<span class="number">.</span>Tcb<span class="number">.</span>Running], <span class="number">0</span>                <span class="comment">; 清除老线程 Running 标志，标记其调度结束</span></span><br><span class="line">    <span class="keyword">xor</span>     <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">gs</span>, <span class="built_in">eax</span>                                      <span class="comment">; 清空 GS（线程局部存储指针），防止误引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; ------------------------------------------------------------</span></span><br><span class="line"><span class="comment">; 判断新线程是否需要恢复 FPU 环境；</span></span><br><span class="line"><span class="comment">; 若需要则执行 xrstor 恢复；</span></span><br><span class="line"><span class="comment">; ------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">movsx</span>   <span class="built_in">eax</span>, [<span class="built_in">esi</span>+_ETHREAD<span class="number">.</span>Tcb<span class="number">.</span>NpxState]             <span class="comment">; 获取新线程的 NPX 状态</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">ebp</span>, <span class="built_in">cr0</span>                                     <span class="comment">; 加载当前 CR0 控制寄存器</span></span><br><span class="line">    <span class="keyword">and</span>     <span class="built_in">eax</span>, <span class="number">0FFFFFFF8h</span>                              <span class="comment">; 清除低 3 位（TS/EM/MP），保留状态高位</span></span><br><span class="line">    <span class="keyword">jz</span>      SkipXrstor                                   <span class="comment">; 若为 0，说明新线程无需恢复 FPU，跳过</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">test</span>    <span class="built_in">ebp</span>, <span class="number">0Eh</span>                                     <span class="comment">; 检查 EM / TS 位是否被置位（不允许浮点操作）</span></span><br><span class="line">    <span class="keyword">jz</span>      RestoreFpu                                   <span class="comment">; 若未置位，可直接执行 xrstor</span></span><br><span class="line">    <span class="keyword">and</span>     <span class="built_in">ebp</span>, <span class="number">0FFFFFFF1h</span>                              <span class="comment">; 否则清除 EM / TS 位</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">cr0</span>, <span class="built_in">ebp</span>                                     <span class="comment">; 写回 CR0，允许浮点操作</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">RestoreFpu:</span></span><br><span class="line">    <span class="keyword">cdq</span>                                                   <span class="comment">; 清空 EDX</span></span><br><span class="line">    <span class="keyword">xrstor</span>  <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ecx</span>-<span class="number">210h</span>]                           <span class="comment">; 恢复新线程的 FPU/MMX/SSE 状态（从已分配栈中恢复）</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">SkipXrstor:</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">edx</span>, [<span class="built_in">ecx</span>-<span class="number">14h</span>]                                <span class="comment">; 恢复栈上的临时 esp 值（作为 context 用）</span></span><br><span class="line">    <span class="keyword">test</span>    [<span class="built_in">esi</span>+_ETHREAD<span class="number">.</span>Tcb<span class="number">.</span>NpxState], <span class="number">7</span>                <span class="comment">; 检查 NpxState 的低 3 位，判断是否需要特殊处理</span></span><br><span class="line">    <span class="keyword">jnz</span>     CheckFpuFlags</span><br><span class="line"></span><br><span class="line">    <span class="keyword">or</span>      <span class="built_in">edx</span>, <span class="built_in">ds</span>:_NpxStateNotLoaded                    <span class="comment">; 若未使用 FPU，则合并标志表示不加载</span></span><br><span class="line"><span class="symbol">CheckFpuFlags:</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">eax</span>, <span class="built_in">ebp</span></span><br><span class="line">    <span class="keyword">and</span>     <span class="built_in">eax</span>, <span class="number">0FFFFFFF1h</span>                               <span class="comment">; 清除 TS/EM 等位</span></span><br><span class="line">    <span class="keyword">or</span>      <span class="built_in">edx</span>, <span class="built_in">eax</span>                                      <span class="comment">; 合并恢复 esp 与控制位</span></span><br><span class="line">    <span class="keyword">cmp</span>     <span class="built_in">edx</span>, <span class="built_in">ebp</span></span><br><span class="line">    <span class="keyword">jnz</span>     ReloadCr0                                     <span class="comment">; 若合并后不一致，更新 CR0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; ------------------------------------------------------------</span></span><br><span class="line"><span class="comment">; 更新 KPCR 中当前进程、线程信息；</span></span><br><span class="line"><span class="comment">; 📌设置 FS 段选择器，用于访问 TEB；</span></span><br><span class="line"><span class="comment">; ------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">ebp</span>, [<span class="built_in">esi</span>+_ETHREAD<span class="number">.</span>Tcb<span class="number">.</span>ApcState<span class="number">.</span>Process]      <span class="comment">; 新线程所属进程</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">esi</span>+_ETHREAD<span class="number">.</span>Tcb<span class="number">.</span>Teb]                   <span class="comment">; 新线程的 TEB 指针</span></span><br><span class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebx</span>+_KPCR<span class="number">.</span>Used_Self], <span class="built_in">eax</span>                    <span class="comment">; 设置 KPCR 中指向当前线程 TEB 的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebx</span>+_KPCR<span class="number">.</span>GDT]                          <span class="comment">; 获取当前处理器 GDT 表基址</span></span><br><span class="line">    <span class="keyword">mov</span>     [<span class="built_in">ecx</span>+<span class="number">3Ah</span>], <span class="built_in">ax</span>                                 <span class="comment">; 设置 FS 段选择器低 16 位</span></span><br><span class="line">    <span class="keyword">shr</span>     <span class="built_in">eax</span>, <span class="number">10h</span></span><br><span class="line">    <span class="keyword">mov</span>     [<span class="built_in">ecx</span>+<span class="number">3Ch</span>], <span class="built_in">al</span>                                 <span class="comment">; 设置 FS 段选择器中间 8 位</span></span><br><span class="line">    <span class="keyword">mov</span>     [<span class="built_in">ecx</span>+<span class="number">3Fh</span>], <span class="number">ah</span>                                 <span class="comment">; 设置 FS 段选择器高 8 位</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">inc</span>     [<span class="built_in">esi</span>+_ETHREAD<span class="number">.</span>Tcb<span class="number">.</span>ContextSwitches]            <span class="comment">; 增加线程的切换次数（用于调度统计）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pop</span>     [<span class="built_in">ebx</span>+_KPCR<span class="number">.</span>NtTib<span class="number">.</span>ExceptionList]               <span class="comment">; 恢复异常处理链</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pop</span>     <span class="built_in">ecx</span>                                           <span class="comment">; 恢复原始 ecx（WaitIrql）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; ------------------------------------------------------------</span></span><br><span class="line"><span class="comment">; 检查当前是否存在活动的 DPC（延迟过程调用）；</span></span><br><span class="line"><span class="comment">; 若存在则进入蓝屏路径（禁止在上下文切换中执行 DPC）；</span></span><br><span class="line"><span class="comment">; ------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">cmp</span>     [<span class="built_in">ebx</span>+_KPCR<span class="number">.</span>PrcbData<span class="number">.</span>DpcRoutineActive], <span class="number">0</span>      <span class="comment">; 判断是否正在运行 DPC</span></span><br><span class="line">    <span class="keyword">jnz</span>     FatalBugcheckDpc                              <span class="comment">; 若是，触发 bugcheck</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">cmp</span>     [<span class="built_in">esi</span>+_ETHREAD<span class="number">.</span>Tcb<span class="number">.</span>ApcState<span class="number">.</span>KernelApcPending], <span class="number">0</span> <span class="comment">; 检查是否存在内核 APC 挂起</span></span><br><span class="line">    <span class="keyword">jnz</span>     DeliverKernelApc                              <span class="comment">; 若有挂起 APC，立即送达</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">xor</span>     <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line">    <span class="keyword">retn</span></span><br></pre></td></tr></table></figure></div>

<h3 id="协作式线程切换"><a href="#协作式线程切换" class="headerlink" title="协作式线程切换"></a>协作式线程切换</h3><p>协作式线程切换即线程主动切换让出 CPU，主要通过 <code>KiSwapThread</code> 函数实现。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// KiSwapThread</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 描述：</span></span><br><span class="line"><span class="comment">//     处理线程切换逻辑，保存当前线程的运行时间，选择可执行线程（NextThread / ReadyList / IdleThread），</span></span><br><span class="line"><span class="comment">//     并根据上下文与 APC 状态决定是否执行实际上下文切换。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     OldKThread - 当前线程（KTHREAD）指针</span></span><br><span class="line"><span class="comment">//     Prcb       - 当前处理器的 PRCB 结构指针</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 返回：</span></span><br><span class="line"><span class="comment">//     返回 OldKThread-&gt;WaitStatus，表示等待完成状态</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">LONG_PTR</span><br><span class="line">FASTCALL</span><br><span class="line"><span class="title function_">KiSwapThread</span> <span class="params">(</span></span><br><span class="line"><span class="params">    IN PKTHREAD OldThread,</span></span><br><span class="line"><span class="params">    IN PKPRCB CurrentPrcb</span></span><br><span class="line"><span class="params">    )</span></span><br><span class="line">&#123;</span><br><span class="line">    PKTHREAD NewThread;</span><br><span class="line">    PKTHREAD IdleThread;</span><br><span class="line">    KIRQL NewIrql;</span><br><span class="line">    ULONGLONG Timestamp, Delta;</span><br><span class="line">    BOOLEAN Success;</span><br><span class="line">    LONG WaitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// 若延迟就绪链非空，先行处理（如 IoReady、ApcReady 等）</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (Prcb-&gt;DeferredReadyListHead.Next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        KiProcessThreadWaitList(Prcb, TRUE, FALSE, FALSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _disable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// 更新当前线程的 TSC 周期并累加至其运行时间</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    PKTHREAD CurrentThread = Prcb-&gt;CurrentThread;</span><br><span class="line">    Prcb-&gt;NestingLevel = <span class="number">1</span>;</span><br><span class="line">    Timestamp = __rdtsc();</span><br><span class="line">    Delta = Timestamp - Prcb-&gt;StartCycles;</span><br><span class="line"></span><br><span class="line">    CurrentThread-&gt;CycleTime.QuadPart += Delta;</span><br><span class="line">    CurrentThread-&gt;HighCycleTime = CurrentThread-&gt;CycleTime.HighPart;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若启用了 TSC Profiling 或性能计数，执行统计更新</span></span><br><span class="line">    <span class="keyword">if</span> (CurrentThread-&gt;Header.CycleProfiling) &#123;</span><br><span class="line">        PsChargeProcessCpuCycles(Prcb, Delta, (ULONG)(Delta &gt;&gt; <span class="number">32</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (CurrentThread-&gt;Header.CounterProfiling) &#123;</span><br><span class="line">        KiEndCounterAccumulation(CurrentThread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Prcb-&gt;StartCycles = Timestamp;</span><br><span class="line"></span><br><span class="line">    _enable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// 📌获取 PRCB 自旋锁，并查找可调度线程（优先 KiSearchForNewThread，其次 NextThread，再次 IdleThread）</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// - KiSearchForNewThread：由调度器找到的下一执行线程，优先调度。</span></span><br><span class="line">    <span class="comment">// - Prcb-&gt;NextThread：当前处理器就绪队列中挑选的最高优先级线程。</span></span><br><span class="line">    <span class="comment">// - Prcb-&gt;IdleThread：当前没有线程可调度时使用的空闲线程。</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    KiAcquirePrcbLock(Prcb);</span><br><span class="line"></span><br><span class="line">    NewThread = KiSearchForNewThread(Prcb, FALSE);</span><br><span class="line">    <span class="keyword">if</span> (!NewThread) &#123;</span><br><span class="line">        NewThread = Prcb-&gt;NextThread;</span><br><span class="line">        <span class="keyword">if</span> (NewThread != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Prcb-&gt;NextThread = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            NewThread = Prcb-&gt;IdleThread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Prcb-&gt;CurrentThread = NewThread;</span><br><span class="line">        NewThread-&gt;State = Running;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// 若新线程已被其他处理器抢占(Running)，退回 IdleThread</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (NewThread != Prcb-&gt;IdleThread &amp;&amp;</span><br><span class="line">        NewThread != OldKThread &amp;&amp;</span><br><span class="line">        NewThread-&gt;Running)</span><br><span class="line">    &#123;</span><br><span class="line">        NewThread-&gt;State = Standby;</span><br><span class="line">        Prcb-&gt;NextThread = NewThread;</span><br><span class="line"></span><br><span class="line">        NewThread = Prcb-&gt;IdleThread;</span><br><span class="line">        NewThread-&gt;State = Running;</span><br><span class="line">        Prcb-&gt;CurrentThread = NewThread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    KiReleasePrcbLock(Prcb);</span><br><span class="line"></span><br><span class="line">    NewIrql = OldKThread-&gt;WaitIrql;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// 若新线程仍为当前线程（即调度未发生），仅执行统计与 APC 检查</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (OldKThread == NewThread) &#123;</span><br><span class="line">        Success = FALSE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!NewThread-&gt;ApcState.KernelApcPending ||</span><br><span class="line">            NewThread-&gt;SpecialApcDisable != <span class="number">0</span> ||</span><br><span class="line">            NewIrql != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Success = FALSE;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Success = TRUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _disable();</span><br><span class="line"></span><br><span class="line">        PKTHREAD NewCurrent = Prcb-&gt;CurrentThread;</span><br><span class="line">        ULONGLONG TscNow = __rdtsc();</span><br><span class="line">        ULONGLONG CpuCycle = TscNow - Prcb-&gt;StartCycles + Prcb-&gt;CycleTime;</span><br><span class="line"></span><br><span class="line">        Prcb-&gt;CycleTime = CpuCycle;</span><br><span class="line">        Prcb-&gt;HighCycleTime = (ULONG)(CpuCycle &gt;&gt; <span class="number">32</span>);</span><br><span class="line">        Prcb-&gt;StartCycles = TscNow;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (NewCurrent-&gt;Header.CounterProfiling) &#123;</span><br><span class="line">            KiBeginCounterAccumulation(NewCurrent, FALSE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Prcb-&gt;NestingLevel = <span class="number">0</span>;</span><br><span class="line">        _enable();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (EtwLogFlags &amp; EVENT_TRACE_FLAG_DISPATCHER) &#123;</span><br><span class="line">            EtwTraceContextSwap(OldKThread, OldKThread);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// 📌执行上下文切换</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Success = KiSwapContext(OldKThread, NewThread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// 返回 WaitStatus；若线程开启了定时器，则维护 WaitBlock 链</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    WaitStatus = OldKThread-&gt;WaitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (OldKThread-&gt;MiscFlagsStruct.TimerActive &amp;&amp;</span><br><span class="line">        !KiCancelTimer(OldKThread-&gt;Timer, TRUE))</span><br><span class="line">    &#123;</span><br><span class="line">        OldKThread-&gt;WaitBlock[<span class="number">3</span>].BlockState = BlockStateInactive;</span><br><span class="line">        OldKThread-&gt;Timer.Header.WaitListHead.Flink = &amp;OldKThread-&gt;WaitBlock[<span class="number">3</span>].WaitListEntry;</span><br><span class="line">        OldKThread-&gt;Timer.Header.WaitListHead.Blink = &amp;OldKThread-&gt;WaitBlock[<span class="number">3</span>].WaitListEntry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// 若发生 APC 调度请求，立即执行 APC 分发</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (Success) &#123;</span><br><span class="line">        KfLowerIrql(APC_LEVEL);</span><br><span class="line">        KiDeliverApc(FALSE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    KfLowerIrql(NewIrql);</span><br><span class="line">    <span class="keyword">return</span> WaitStatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>KiSwapThread</code> 首先通过 <code>KiSearchForNewThread</code> 找到要切换到的线程，然后调用 <code>KiSwapContext</code> 完成线程切换。</p>
<p><code>KiSearchForNewThread</code> 函数会<strong>选择一个最合适的线程来运行在当前处理器上</strong>，涉及 Windows 内核调度器的任务调度算法，在不同版本的具体实现不同。但是总的来说逻辑都是<strong>优先使用本地资源，必要时进行跨核抢占</strong>。</p>
<p>下面这个版本代码的主要逻辑为：</p>
<ul>
<li><p><strong>[Step 1]：使用预选线程（<code>Prcb-&gt;NextThread</code>）</strong></p>
<ul>
<li>若调度器之前已选中线程（例如抢占迁移时设置），直接切换该线程为当前线程；</li>
<li>设置线程状态为 <code>Running</code>，并清除 <code>NextThread</code> 字段；</li>
<li>不进行任何就绪队列遍历，快速完成调度。</li>
</ul>
</li>
<li><p><strong>[Step 2]：本地就绪队列选择线程</strong></p>
<ul>
<li>调用 <code>KiSelectReadyThread</code> 从当前 PRCB 的本地 <code>ReadyList</code> 中选择优先级最高的线程；</li>
<li>若调度为 idle 类型（<code>IsIdleSchedule == TRUE</code>）：<ul>
<li>清除本核心的 <code>NotUsedCoreProcessor</code> 位；</li>
<li>清除本组的 <code>UsedCoreProcessor</code> 中的 <code>CoreProcessorSet</code>，表明该核心已被重新使用。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>[Step 3]：本地无线程且非 idle 调度</strong></p>
<ul>
<li>若 <code>IsIdleSchedule == FALSE</code> 且未找到线程，说明当前核心资源空闲；</li>
<li>将当前核心在 <code>NotUsedCoreProcessor</code> 中置位，表示本核心目前未参与运行；</li>
<li>若该 PRCB 所属的所有核心都 idle（即 <code>CoreProcessorSet</code> 的全部位都在 <code>NotUsedCoreProcessor</code> 中）：<ul>
<li>将 CoreProcessorSet 添加到 <code>UsedCoreProcessor</code>，允许其他节点迁移线程到该组。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>[Step 4]：本地调度失败，释放 PRCB 锁</strong></p>
<ul>
<li>因后续需要访问其他处理器或 Node，为避免死锁，在继续之前先释放当前 <code>PRCB</code> 的锁。</li>
</ul>
</li>
<li><p><strong>[Step 5]：尝试公平调度（<code>PsCpuFairShareEnabled</code>）</strong></p>
<ul>
<li>若启用了公平调度策略，则尝试从 idle-only 队列中拉取待执行线程；</li>
<li>若成功（通过 <code>PsReleaseThreadFromIdleOnlyQueue</code>），则调度完成，返回该线程；</li>
<li>否则进入跨 NUMA 节点线程窃取阶段。</li>
</ul>
</li>
<li><p><strong>[Step 6]：NUMA 感知线程窃取</strong></p>
<ul>
<li>遍历所有与当前 PRCB 属于同一个 Group 的 NUMA 节点，查找活跃核心并尝试从其就绪队列中“抢线程”：<ul>
<li>对每个目标节点：<ul>
<li>构造跨核心调度掩码 <code>ScanSet</code>（仅包含活跃核心）；</li>
<li>遍历活跃核心，获取其对应的 <code>TargetPrcb</code>；</li>
<li>加锁目标 <code>PRCB</code>（按地址顺序双锁当前和目标 <code>PRCB</code>）；</li>
<li>若目标 <code>PRCB</code> 有 <code>ReadySummary</code>，可尝试使用 <code>KiFindReadyThread</code> 抢占线程；</li>
<li>若抢占成功，将该线程设置为 <code>Running</code>，并更新本地 <code>PRCB</code>；</li>
<li>同时清除本核心的空闲标志。</li>
</ul>
</li>
</ul>
</li>
<li>若目标 <code>PRCB</code> 没有可抢线程，则解锁并尝试下一个 NUMA 节点或处理器。</li>
<li>如果在尝试过程中发现本地 <code>Prcb-&gt;NextThread</code> 被设置（例如远程迁移），优先使用它，并终止搜索。</li>
</ul>
</li>
<li><p><strong>[Step 7]：所有路径失败</strong></p>
<ul>
<li>若所有调度路径（本地、本组、NUMA、IdleOnly）均无可调度线程：<ul>
<li>返回 <code>NULL</code>，调度器进入 Idle 状态，当前核心维持空闲；</li>
<li>由 <code>IdleThread</code> 维持处理器活跃，等待下一次中断或调度请求。</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// KiSearchForNewThread</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 函数作用：</span></span><br><span class="line"><span class="comment">//     这是 Windows 内核调度器中的核心函数之一，负责为指定的处理器（PRCB）</span></span><br><span class="line"><span class="comment">//     查找一个可以运行的线程（PKTHREAD），该函数通常在当前处理器处于空闲状态，</span></span><br><span class="line"><span class="comment">//     或者需要进行线程切换时被调用。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 调度策略：</span></span><br><span class="line"><span class="comment">//     - 优先使用 PRCB-&gt;NextThread 中预选线程（如迁移线程）。</span></span><br><span class="line"><span class="comment">//     - 其次尝试从当前处理器本地就绪队列选择线程。</span></span><br><span class="line"><span class="comment">//     - 若本地队列为空，执行 NUMA 感知调度，在组内其他处理器中“偷取”线程。</span></span><br><span class="line"><span class="comment">//     - 若启用了公平调度（Fair Share），则会尝试从 idle-only 队列中获取线程。</span></span><br><span class="line"><span class="comment">//     - 若所有尝试失败，返回 NULL，当前核心保持 idle。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     IN PKPRCB Prcb</span></span><br><span class="line"><span class="comment">//         指向当前处理器的处理器控制块（Processor Control Block）</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     IN BOOLEAN IsIdleSchedule</span></span><br><span class="line"><span class="comment">//         表示本次调度是否由空闲线程触发（如 IdleThread 调度器）</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">//     成功：指向可运行线程的指针（PKTHREAD）</span></span><br><span class="line"><span class="comment">//     失败：返回 NULL 表示没有线程可运行</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line">PKTHREAD</span><br><span class="line"><span class="title function_">KiSearchForNewThread</span><span class="params">(</span></span><br><span class="line"><span class="params">    IN PKPRCB Prcb,</span></span><br><span class="line"><span class="params">    IN BOOLEAN IsIdleSchedule</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    PKTHREAD Thread = Prcb-&gt;NextThread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// [Step 1] 若 PRCB 中已经有预选线程（如抢占迁移设定），直接切换它</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (Thread) &#123;</span><br><span class="line">        Prcb-&gt;NextThread = <span class="literal">NULL</span>;</span><br><span class="line">        Prcb-&gt;CurrentThread = Thread;</span><br><span class="line">        Thread-&gt;State = Running;</span><br><span class="line">        <span class="keyword">return</span> Thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// [Step 2] 本地调度：尝试从当前处理器本地就绪队列中选择线程</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Thread = KiSelectReadyThread(<span class="number">0</span>, Prcb);</span><br><span class="line">    <span class="keyword">if</span> (Thread) &#123;</span><br><span class="line">        Prcb-&gt;CurrentThread = Thread;</span><br><span class="line">        Thread-&gt;State = Running;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (IsIdleSchedule) &#123;</span><br><span class="line">            <span class="comment">// 从空闲状态转为活跃，清除“未使用”状态并更新“活跃核心掩码”</span></span><br><span class="line">            _interlockedbittestandreset(&amp;NotUsedCoreProcessor[Prcb-&gt;Group], (UCHAR)Prcb-&gt;GroupIndex);</span><br><span class="line">            _InterlockedAnd(&amp;UsedCoreProcessor[Prcb-&gt;Group], ~Prcb-&gt;CoreProcessorSet);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// [Step 3] 若本地无线程且非 IdleSchedule，则更新当前核心为“未使用”</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (!IsIdleSchedule) &#123;</span><br><span class="line">        _interlockedbittestandset(&amp;NotUsedCoreProcessor[Prcb-&gt;Group], (UCHAR)Prcb-&gt;GroupIndex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若当前 PRCB 控制的所有核心都处于未使用状态，则将其加入 UsedCoreProcessor</span></span><br><span class="line">        <span class="keyword">if</span> ((Prcb-&gt;CoreProcessorSet &amp; NotUsedCoreProcessor[Prcb-&gt;Group]) == Prcb-&gt;CoreProcessorSet) &#123;</span><br><span class="line">            _InterlockedOr(&amp;UsedCoreProcessor[Prcb-&gt;Group], Prcb-&gt;CoreProcessorSet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// [Step 4] 本地调度失败，释放当前 PRCB 锁，准备进入远程调度路径</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    KiReleasePrcbLock(Prcb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// [Step 5] 若启用了 CPU 公平调度机制，尝试从 idle-only 队列中拉取线程</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (!PsCpuFairShareEnabled ||</span><br><span class="line">        !PsReleaseThreadFromIdleOnlyQueue(Prcb-&gt;Number, Prcb-&gt;Number)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// [Step 6] NUMA 感知调度：遍历处理器所在 Group 的所有 NUMA 节点</span></span><br><span class="line">        <span class="comment">//          若其中有线程可运行，则窃取该线程</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> ((Prcb-&gt;GroupSetMember &amp; KiAllowedProcessorSetInGroup[Prcb-&gt;Group]) != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            PKNODE ParentNode = Prcb-&gt;ParentNode;</span><br><span class="line">            USHORT NodeNumber = ParentNode-&gt;NodeNumber;</span><br><span class="line">            ULONG GroupSetMember = Prcb-&gt;GroupSetMember;</span><br><span class="line">            USHORT NodeIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (NodeIndex &lt; KeNumberNodes) &#123;</span><br><span class="line">                PKNODE Node;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (NodeIndex == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 第一个节点为本地节点</span></span><br><span class="line">                    Node = ParentNode;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 其余节点来自 NUMA 拓扑图（MiNodeGraph）</span></span><br><span class="line">                    USHORT NextNodeId = MiNodeGraph[NodeNumber * KeNumberNodes + NodeIndex];</span><br><span class="line">                    Node = KeNodeBlock[NextNodeId];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 只处理同 Group 的节点</span></span><br><span class="line">                    <span class="keyword">if</span> (Node-&gt;Affinity.Group != Prcb-&gt;Group) &#123;</span><br><span class="line">                        ++NodeIndex;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// 计算当前节点与当前处理器组之间可调度核心集合</span></span><br><span class="line">                <span class="comment">// 差集后再排除未使用核心，得到最终 ScanSet</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                ULONG Mask = GroupSetMember ^ Node-&gt;Affinity.Mask;</span><br><span class="line">                ULONG ScanSet = ~NotUsedCoreProcessor[Node-&gt;Affinity.Group] &amp; Mask;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (ScanSet != <span class="number">0</span>) &#123;</span><br><span class="line">                    ULONG Bit;</span><br><span class="line">                    _BitScanReverse(&amp;Bit, ScanSet);</span><br><span class="line">                    ScanSet ^= KiMask32Array[Bit];</span><br><span class="line"></span><br><span class="line">                    ULONG ProcIndex = KiProcessorNumberToIndexMappingTable[(Node-&gt;Affinity.Group &lt;&lt; <span class="number">6</span>) + Bit];</span><br><span class="line">                    PKPRCB TargetPrcb = KiProcessorBlock[ProcIndex];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (TargetPrcb-&gt;ReadySummary == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="comment">// 处理器间加锁顺序必须遵循地址顺序，避免死锁</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    PKPRCB FirstLock = (Prcb &lt; TargetPrcb) ? Prcb : TargetPrcb;</span><br><span class="line">                    PKPRCB SecondLock = (Prcb &lt; TargetPrcb) ? TargetPrcb : Prcb;</span><br><span class="line"></span><br><span class="line">                    KiAcquirePrcbLock(FirstLock);</span><br><span class="line">                    <span class="keyword">if</span> (FirstLock != SecondLock)</span><br><span class="line">                        KiAcquirePrcbLock(SecondLock);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="comment">// 再次检查本地 NextThread 是否可用</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    Thread = Prcb-&gt;NextThread;</span><br><span class="line">                    <span class="keyword">if</span> (Thread) &#123;</span><br><span class="line">                        Prcb-&gt;NextThread = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (Thread != Prcb-&gt;IdleThread) &#123;</span><br><span class="line">                            Thread-&gt;State = Running;</span><br><span class="line">                            Prcb-&gt;CurrentThread = Thread;</span><br><span class="line"></span><br><span class="line">                            KiReleasePrcbLock(TargetPrcb);</span><br><span class="line">                            <span class="keyword">return</span> Thread;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 如果只是空闲线程，清除 IdleSchedule 并继续</span></span><br><span class="line">                        Prcb-&gt;IdleSchedule = <span class="number">0</span>;</span><br><span class="line">                        KiReleasePrcbLock(Prcb);</span><br><span class="line">                        Thread = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//</span></span><br><span class="line">                        <span class="comment">// 尝试从目标 PRCB 的 ReadySummary 中找线程</span></span><br><span class="line">                        <span class="comment">//</span></span><br><span class="line">                        Thread = KiFindReadyThread(TargetPrcb-&gt;ReadySummary, Prcb, TargetPrcb);</span><br><span class="line">                        <span class="keyword">if</span> (Thread) &#123;</span><br><span class="line">                            Thread-&gt;State = Running;</span><br><span class="line">                            Prcb-&gt;CurrentThread = Thread;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 由于本处理器将获得线程，清除未使用状态</span></span><br><span class="line">                            _interlockedbittestandreset(&amp;NotUsedCoreProcessor[Prcb-&gt;Group], (UCHAR)Prcb-&gt;GroupIndex);</span><br><span class="line">                            _InterlockedAnd(&amp;UsedCoreProcessor[Prcb-&gt;Group], ~Prcb-&gt;CoreProcessorSet);</span><br><span class="line"></span><br><span class="line">                            KiReleasePrcbLock(TargetPrcb);</span><br><span class="line">                            <span class="keyword">return</span> Thread;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 无结果，解锁后继续尝试其他处理器</span></span><br><span class="line">                    KiReleasePrcbLock(Prcb);</span><br><span class="line">                    KiReleasePrcbLock(TargetPrcb);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="comment">// 再次尝试公平调度线程窃取</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="keyword">if</span> (PsCpuFairShareEnabled &amp;&amp;</span><br><span class="line">                        PsReleaseThreadFromIdleOnlyQueue(Prcb-&gt;Number, TargetPrcb-&gt;Number)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ++NodeIndex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// [Step 7] 所有调度路径失败，返回 NULL，当前处理器保持 idle</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p> <code>KiSelectReadyThread</code> 是从当前 PRCB 的本地 <code>ReadyList</code> 中选择优先级最高的线程。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 函数名称:</span></span><br><span class="line"><span class="comment">//     KiSelectReadyThread</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 功能描述:</span></span><br><span class="line"><span class="comment">//     在指定的 PRCB（处理器控制块）中，从不低于指定优先级 (LowPriority)</span></span><br><span class="line"><span class="comment">//     的就绪线程中选择一个可运行线程。该函数用于从每个优先级的就绪线程队列中，</span></span><br><span class="line"><span class="comment">//     快速定位最高优先级的线程并返回其线程对象指针（KTHREAD）。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 参数:</span></span><br><span class="line"><span class="comment">//     LowPriority - 线程调度优先级的下限，仅考虑大于等于该优先级的线程。</span></span><br><span class="line"><span class="comment">//     Prcb        - 指向当前处理器的 PRCB 结构体，包含就绪线程位图和就绪队列。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 返回值:</span></span><br><span class="line"><span class="comment">//     若成功找到一个线程，则返回该线程对象 (PKTHREAD)；</span></span><br><span class="line"><span class="comment">//     若没有线程可运行，则返回 NULL。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">PKTHREAD</span><br><span class="line"><span class="title function_">KiSelectReadyThread</span><span class="params">(</span></span><br><span class="line"><span class="params">    IN ULONG LowPriority,</span></span><br><span class="line"><span class="params">    IN PKPRCB Prcb</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    ULONG PrioritySet;</span><br><span class="line">    ULONG HighPriority;</span><br><span class="line">    PLIST_ENTRY ListEntry;</span><br><span class="line">    PKTHREAD Thread = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 就绪线程概览位图（ReadySummary）右移以忽略低于 LowPriority 的部分，</span></span><br><span class="line">    <span class="comment">// 从而仅检查感兴趣的优先级范围。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    PrioritySet = Prcb-&gt;ReadySummary &gt;&gt; LowPriority;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrioritySet != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 使用 BitScanReverse 找到最高就绪优先级（即最左边的 1）</span></span><br><span class="line">        <span class="comment">// 这是位图中优先级的偏移值，加上 LowPriority 得到全局优先级。</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        _BitScanReverse(&amp;HighPriority, PrioritySet);</span><br><span class="line">        HighPriority += LowPriority;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 获取对应优先级链表的第一个线程。</span></span><br><span class="line">        <span class="comment">// DispatcherReadyListHead 每个优先级维护一个双向链表。</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        ListEntry = Prcb-&gt;DispatcherReadyListHead[HighPriority].Flink;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 根据 WaitListEntry 字段位置，从链表节点还原出线程对象指针。</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        Thread = CONTAINING_RECORD(ListEntry, KTHREAD, WaitListEntry);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 从链表中移除该线程。如果链表移除后变为空，则清除该优先级对应位。</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> (RemoveEntryList(&amp;Thread-&gt;WaitListEntry)) &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// 使用 KiMask32Array 对应位掩码进行位图更新，表示该优先级已无就绪线程。</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            Prcb-&gt;ReadySummary ^= KiMask32Array[HighPriority];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>KiFindReadyThread</code> 函数主要是在与<strong>当前 PRCB 属于同一个 Group 的 NUMA 节点</strong>的就绪队列选择线程，在获取时会按照优先级从高到低依次从调度队列中获取。由于在获取时还要线程是否允许运行在当前处理器上，因此需要遍历链表。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// KiFindReadyThread</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 函数作用：</span></span><br><span class="line"><span class="comment">//     在目标处理器的 ReadySummary 中查找一个可以运行在当前处理器上的线程，</span></span><br><span class="line"><span class="comment">//     按优先级从高到低依次查找，就绪线程列表存放在 DispatcherReadyListHead 中。</span></span><br><span class="line"><span class="comment">//     若找到符合亲和性（Affinity）要求的线程，则将其从队列中移除并返回。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     IN ULONG PrioritySet</span></span><br><span class="line"><span class="comment">//         目标处理器的 ReadySummary 位图（每一位对应一个优先级）</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     IN PKPRCB CurrentPrcb</span></span><br><span class="line"><span class="comment">//         当前尝试调度线程的处理器控制块（用于检查亲和性）</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     IN PKPRCB TargetPrcb</span></span><br><span class="line"><span class="comment">//         目标处理器控制块（其就绪队列中查找线程）</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">//     成功：返回符合亲和性的就绪线程指针（PKTHREAD）</span></span><br><span class="line"><span class="comment">//     失败：返回 NULL 表示无合适线程</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line">PKTHREAD</span><br><span class="line">FASTCALL</span><br><span class="line"><span class="title function_">KiFindReadyThread</span> <span class="params">(</span></span><br><span class="line"><span class="params">    IN ULONG PrioritySet,</span></span><br><span class="line"><span class="params">    IN PKPRCB CurrentPrcb,</span></span><br><span class="line"><span class="params">    IN PKPRCB TargetPrcb</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    ULONG HighPriority;</span><br><span class="line">    ULONG Index;</span><br><span class="line">    PLIST_ENTRY ListHead;</span><br><span class="line">    PLIST_ENTRY Flink;</span><br><span class="line">    PKTHREAD Thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 遍历 PrioritySet 中的所有优先级位（从高到低）</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 使用位扫描查找最高优先级（即 PrioritySet 中最高位为 1 的位置）</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> (!_BitScanReverse(&amp;HighPriority, PrioritySet)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 无可用优先级，跳出主循环</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清除当前优先级位（表示该优先级已尝试）</span></span><br><span class="line">        PrioritySet ^= KiMask32Array[HighPriority];</span><br><span class="line">        Index = HighPriority;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 获取该优先级对应的调度队列头（双向链表）</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        ListHead = &amp;TargetPrcb-&gt;DispatcherReadyListHead[HighPriority];</span><br><span class="line">        Flink = ListHead-&gt;Flink;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 遍历该优先级上的线程列表</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">while</span> (Flink != ListHead) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// 从 WaitListEntry 得到所属线程结构体 KTHREAD</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            Thread = CONTAINING_RECORD(Flink, KTHREAD, WaitListEntry);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// 检查线程是否允许运行在当前处理器上：</span></span><br><span class="line">            <span class="comment">// - 同一 Group；</span></span><br><span class="line">            <span class="comment">// - 当前处理器在其 Affinity 掩码中</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> ((Thread-&gt;Affinity.Group == CurrentPrcb-&gt;Group) &amp;&amp;</span><br><span class="line">                ((Thread-&gt;Affinity.Mask &amp; CurrentPrcb-&gt;GroupSetMember) != <span class="number">0</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// 从调度队列中移除此线程</span></span><br><span class="line">                <span class="comment">// 若移除后队列为空，则清除该优先级的 ReadySummary 位</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="keyword">if</span> (RemoveEntryList(Flink)) &#123;</span><br><span class="line">                    TargetPrcb-&gt;ReadySummary ^= KiMask32Array[Index];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// 设置该线程的下一目标处理器为当前 PRCB</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                Thread-&gt;NextProcessor = (UCHAR)CurrentPrcb-&gt;Number;</span><br><span class="line">                <span class="keyword">return</span> Thread;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历下一个线程</span></span><br><span class="line">            Flink = Flink-&gt;Flink;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 若当前优先级链表未找到合适线程，继续尝试下一个优先级</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> (PrioritySet == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 所有优先级队列均未找到符合亲和性的线程，返回 NULL</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="抢占式线程切换"><a href="#抢占式线程切换" class="headerlink" title="抢占式线程切换"></a>抢占式线程切换</h3><p>以 Windows 在时间片到期后调度线程为例，调用栈如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nt!KiQuantumEnd                      <span class="comment">// 【线程时间片到期】调度器核心函数：检查当前线程量子是否用尽，若需调度则准备切换线程</span></span><br><span class="line">nt!KiDispatchInterrupt              <span class="comment">// 【内核中断分发器】统一入口，检查并触发调度/APC 等软中断</span></span><br><span class="line">hal!HalpDispatchSoftwareInterrupt   <span class="comment">// 【分发软中断】处理 DPC/APC/调度等软中断逻辑</span></span><br><span class="line">hal!HalpCheckForSoftwareInterrupt   <span class="comment">// 【检查是否存在待处理的软中断】决定是否继续调度分发</span></span><br><span class="line">hal!KfLowerIrql                     <span class="comment">// 【降低 IRQL】从中断级别降至 DPC_LEVEL，允许软中断处理</span></span><br><span class="line">hal!HalRequestSoftwareInterrupt     <span class="comment">// 【请求软中断】在时钟中断中发起调度请求（如 DPC）</span></span><br><span class="line">KeUpdateRunTime                     <span class="comment">// 【更新当前线程运行时间】维护线程的 TSC/CycleTime，用于调度决策</span></span><br><span class="line">KeUpdateSystemTime                  <span class="comment">// 【更新系统时间】更新 TickCount、系统时间并判断是否处理线程量子</span></span><br><span class="line">nt!KeUpdateSystemTimeAssist         <span class="comment">// 【辅助系统时间更新】KeUpdateSystemTime 的子过程，处理 Tick 与定时器逻辑</span></span><br><span class="line">hal!HalpHpetClockInterrupt          <span class="comment">// 【HPET 硬件定时器中断】周期性触发，驱动线程调度与系统时钟更新</span></span><br></pre></td></tr></table></figure></div>

<p>其中 <code>KiQuantumEnd</code> 会在时间片用尽后进行线程切换。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// KiQuantumEnd</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 描述：</span></span><br><span class="line"><span class="comment">//     调度器在当前线程时间片用尽时调用该函数，用于判断是否需要发生线程切换，</span></span><br><span class="line"><span class="comment">//     并完成当前线程的调度后处理，包括：</span></span><br><span class="line"><span class="comment">//     - 时间片到期时的优先级调整</span></span><br><span class="line"><span class="comment">//     - NextThread 的选择与迁移逻辑</span></span><br><span class="line"><span class="comment">//     - 执行线程上下文切换（若满足条件）</span></span><br><span class="line"><span class="comment">//     - 周期统计与性能计数更新</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 典型触发：</span></span><br><span class="line"><span class="comment">//     - DPC 层检查到当前线程已运行到 QuantumTarget</span></span><br><span class="line"><span class="comment">//     - 当前处理器调度循环主动调用</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">VOID <span class="title function_">KiQuantumEnd</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    PKPRCB Prcb = KeGetPcr()-&gt;Prcb;</span><br><span class="line">    PETHREAD CurrentThread = (PETHREAD)Prcb-&gt;CurrentThread;</span><br><span class="line">    PKTHREAD Thread = &amp;CurrentThread-&gt;Tcb;</span><br><span class="line">    PKPROCESS Process = Thread-&gt;ApcState.Process;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// 同步读取 Thread-&gt;CycleTime 和 Thread-&gt;HighCycleTime</span></span><br><span class="line">    <span class="comment">// 防止在读取 64 位 CycleTime 的过程中，HighPart 被更新造成不一致。</span></span><br><span class="line">    <span class="comment">// 该机制用于支持 TSC-based profiling，确保周期读数精确。</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread-&gt;CycleTime.HighPart == Thread-&gt;HighCycleTime)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        _mm_pause();  <span class="comment">// 避免总线占用，提示处理器进入 pause 等待状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// 加锁线程和 PRCB，确保当前调度状态被独占修改。</span></span><br><span class="line">    <span class="comment">// 调度器所有线程切换逻辑都要持有这两把锁，避免竞态。</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    KiAcquireThreadLock(Thread);</span><br><span class="line">    KiAcquirePrcbLock(Prcb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// 判断当前线程是否已用完时间片（CycleTime &gt;= QuantumTarget）</span></span><br><span class="line">    <span class="comment">// 若是，则可能进行优先级调整、迁移、调度新线程等操作</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (Thread-&gt;CycleTime.QuadPart &gt;= Thread-&gt;QuantumTarget) &#123;</span><br><span class="line">        UCHAR Quantum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若进程禁用了量子管理（DisableQuantum）且线程是实时优先级</span></span><br><span class="line">        <span class="comment">// 则分配一个极大时间片（MAXCHAR）以延迟下次切换</span></span><br><span class="line">        <span class="keyword">if</span> (Process-&gt;DisableQuantum &amp;&amp; Thread-&gt;Priority &gt;= LOW_REALTIME_PRIORITY) &#123;</span><br><span class="line">            Quantum = MAXCHAR;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Quantum = Thread-&gt;QuantumReset;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若非实时线程，进行优先级衰减（ForegroundBoost + UnusualBoost）</span></span><br><span class="line">            <span class="keyword">if</span> (Thread-&gt;Priority &lt; LOW_REALTIME_PRIORITY) &#123;</span><br><span class="line">                UCHAR Decrement = Thread-&gt;UnusualBoost + Thread-&gt;ForegroundBoost;</span><br><span class="line">                KPRIORITY NewPriority = Thread-&gt;Priority - Decrement;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 最低不能低于 BasePriority，防止优先级跌穿</span></span><br><span class="line">                <span class="keyword">if</span> (NewPriority &lt; Thread-&gt;BasePriority)</span><br><span class="line">                    NewPriority = Thread-&gt;BasePriority;</span><br><span class="line"></span><br><span class="line">                Thread-&gt;Priority = NewPriority;</span><br><span class="line">                Thread-&gt;PriorityDecrement = <span class="number">0</span>;  <span class="comment">// 清除本次衰减</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果没有预设 NextThread，就从就绪队列中抢一个优先线程执行</span></span><br><span class="line">            <span class="keyword">if</span> (!Prcb-&gt;NextThread) &#123;</span><br><span class="line">                KPRIORITY Priority = Thread-&gt;Priority;</span><br><span class="line">                ULONG Summary = Prcb-&gt;ReadySummary &gt;&gt; Priority;</span><br><span class="line">                PKTHREAD Next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (Summary) &#123;</span><br><span class="line">                    ULONG Offset;</span><br><span class="line">                    _BitScanReverse(&amp;Offset, Summary);</span><br><span class="line">                    ULONG Index = Priority + Offset;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 抢占就绪链表头部线程</span></span><br><span class="line">                    PLIST_ENTRY Entry = Prcb-&gt;DispatcherReadyListHead[Index].Flink;</span><br><span class="line">                    Next = CONTAINING_RECORD(Entry, KTHREAD, WaitListEntry);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 从链表中摘除 Entry</span></span><br><span class="line">                    <span class="keyword">if</span> (RemoveEntryList(Entry))</span><br><span class="line">                        Prcb-&gt;ReadySummary ^= KiMask32Array[Index];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Prcb-&gt;NextThread = Next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Thread-&gt;Preempted = FALSE;  <span class="comment">// 没有被其他线程抢占</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置下一次线程时间片截止时间（以 TSC 单位表示）</span></span><br><span class="line">        Thread-&gt;QuantumTarget = Thread-&gt;CycleTime.QuadPart + (Quantum * KiCyclesPerClockQuantum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">        <span class="comment">// 检查是否可以尝试进行 CPU 核迁移（CoreProcessorSet ≠ GroupSetMember）</span></span><br><span class="line">        <span class="comment">// 用于 NUMA/多核系统中资源负载均衡，减少线程驻留延迟</span></span><br><span class="line">        <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">        <span class="keyword">if</span> (Prcb-&gt;GroupSetMember != Prcb-&gt;CoreProcessorSet &amp;&amp;</span><br><span class="line">            Thread-&gt;QuantumEndMigrate)  <span class="comment">// 如果允许量子结束迁移</span></span><br><span class="line">        &#123;</span><br><span class="line">            Thread-&gt;QuantumEndMigrate = FALSE;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 条件：1. 当前没有下一线程，2. 存在可用空闲核</span></span><br><span class="line">            <span class="comment">// 且 3. 理想核可用并允许迁移</span></span><br><span class="line">            <span class="keyword">if</span> (!Prcb-&gt;NextThread &amp;&amp;</span><br><span class="line">                (Prcb-&gt;CoreProcessorSet &amp;</span><br><span class="line">                 (Prcb-&gt;GroupSetMember | NotUsedCoreProcessor[Prcb-&gt;Group])) != Prcb-&gt;CoreProcessorSet &amp;&amp;</span><br><span class="line">                (Thread-&gt;Affinity.Mask &amp;</span><br><span class="line">                 KiProcessorBlock[Thread-&gt;IdealProcessor]-&gt;ParentNode-&gt;Affinity.Mask &amp;</span><br><span class="line">                 UsedCoreProcessor[Thread-&gt;Affinity.Group])) &#123;</span><br><span class="line"></span><br><span class="line">                KiSelectNextThread(Prcb);              <span class="comment">// 从远核选择可调度线程</span></span><br><span class="line">                Thread-&gt;ForceDeferSchedule = TRUE;     <span class="comment">// 强制下次调度</span></span><br><span class="line">                Thread-&gt;QuantumEndMigrate  = TRUE;     <span class="comment">// 设置已迁移标志</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// 已完成本线程调度状态更新，释放线程锁</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    KiReleaseThreadLock(Thread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// 若调度器已选出新线程，则进行上下文切换</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    PKTHREAD NextThread = Prcb-&gt;NextThread;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (NextThread) &#123;</span><br><span class="line">        Prcb-&gt;NextThread = <span class="literal">NULL</span>;</span><br><span class="line">        _disable();  <span class="comment">// 防止切换期间中断</span></span><br><span class="line"></span><br><span class="line">        PKTHREAD OldThread = Prcb-&gt;CurrentThread;</span><br><span class="line">        Prcb-&gt;NestingLevel = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        ULONGLONG Now = __rdtsc();  <span class="comment">// 当前时间戳计数器</span></span><br><span class="line">        ULONGLONG Delta = Now - Prcb-&gt;StartCycles;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 累加当前线程运行的 TSC 周期</span></span><br><span class="line">        OldThread-&gt;CycleTime.QuadPart += Delta;</span><br><span class="line">        OldThread-&gt;HighCycleTime = OldThread-&gt;CycleTime.HighPart;</span><br><span class="line">        Prcb-&gt;StartCycles = Now;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若启用了 CycleProfiling，则对进程累加运行周期</span></span><br><span class="line">        <span class="keyword">if</span> (OldThread-&gt;Header.CycleProfiling)</span><br><span class="line">            PsChargeProcessCpuCycles(Prcb, Delta, Delta &gt;&gt; <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若启用了 CounterProfiling，则停止性能计数累加</span></span><br><span class="line">        <span class="keyword">if</span> (OldThread-&gt;Header.CounterProfiling)</span><br><span class="line">            KiEndCounterAccumulation(OldThread);</span><br><span class="line"></span><br><span class="line">        _enable();  <span class="comment">// 恢复中断</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">        <span class="comment">// 更新调度器当前线程，正式切换</span></span><br><span class="line">        <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">        Prcb-&gt;CurrentThread = NextThread;</span><br><span class="line">        NextThread-&gt;State = Running;</span><br><span class="line"></span><br><span class="line">        Thread-&gt;WaitReason = WrQuantumEnd;  <span class="comment">// 设置当前线程等待原因为时间片结束</span></span><br><span class="line">        KiQueueReadyThread(Thread, Prcb);   <span class="comment">// 放回就绪队列</span></span><br><span class="line">        Thread-&gt;WaitIrql = APC_LEVEL;       <span class="comment">// 当前线程返回后 IRQL 为 APC</span></span><br><span class="line"></span><br><span class="line">        KiSwapContext(Thread, NextThread);  <span class="comment">// 执行上下文切换</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    KiReleasePrcbLock(Prcb);  <span class="comment">// 释放 PRCB 锁并返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中选择下一个可用现成的 <code>KiSelectNextThread</code> 函数本质上还是调用了 <code>KiSelectReadyThread</code> 函数，与主动切换类似。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// KiSelectNextThread</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 描述：</span></span><br><span class="line"><span class="comment">//     在当前处理器的就绪线程队列中选择下一个可运行的线程。</span></span><br><span class="line"><span class="comment">//     若没有可运行线程，则选择 IdleThread，并更新空闲核心状态与调度标志。</span></span><br><span class="line"><span class="comment">//     最终将选中线程设置为 Prcb-&gt;NextThread，并返回之。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">PKTHREAD</span><br><span class="line"><span class="title function_">KiSelectNextThread</span><span class="params">(</span></span><br><span class="line"><span class="params">    IN PKPRCB Prcb</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    PKTHREAD Thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// [Step 1] 从本地 ReadyList 中选择最高优先级的线程</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    Thread = KiSelectReadyThread(<span class="number">0</span>, Prcb);</span><br><span class="line">    <span class="keyword">if</span> (!Thread)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">        <span class="comment">// [Step 2] 若无就绪线程，选择 IdleThread 并标记为 IdleSchedule</span></span><br><span class="line">        <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">        Thread = Prcb-&gt;IdleThread;</span><br><span class="line">        Prcb-&gt;IdleSchedule = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记该核心为 NotUsed</span></span><br><span class="line">        _interlockedbittestandset(</span><br><span class="line">            &amp;NotUsedCoreProcessor[Prcb-&gt;Group],</span><br><span class="line">            (UCHAR)Prcb-&gt;GroupIndex</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">        <span class="comment">// [Step 3] 若该 PRCB 管辖的所有核心都未使用，则标记 UsedCoreProcessor</span></span><br><span class="line">        <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">        <span class="keyword">if</span> ((Prcb-&gt;CoreProcessorSet &amp; NotUsedCoreProcessor[Prcb-&gt;Group]) == Prcb-&gt;CoreProcessorSet)</span><br><span class="line">        &#123;</span><br><span class="line">            _InterlockedOr(</span><br><span class="line">                &amp;UsedCoreProcessor[Prcb-&gt;Group],</span><br><span class="line">                Prcb-&gt;CoreProcessorSet</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// [Step 4] 设置状态为 Standby 并保存为 NextThread</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------</span></span><br><span class="line">    Thread-&gt;State = Standby;</span><br><span class="line">    Prcb-&gt;NextThread = Thread;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> windows 进程线程</li>
        <li><strong>Author:</strong> sky123</li>
        <li><strong>Created at
                :</strong> 2022-09-28 11:45:14</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2025-07-01 10:00:04
            </li>
        
        <li>
            <strong>Link:</strong> https://skyi23.github.io/2022/09/28/windows 进程线程/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/windows-kernel-reverse/">#windows kernel reverse</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2022/09/28/windows%20%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">windows 系统调用</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2022/09/28/windows%20%E9%A9%B1%E5%8A%A8%E5%9F%BA%E7%A1%80/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">windows 驱动基础</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'skyI23/my-giscus-discussions',
                'data-repo-id': 'R_kgDONL9k_w',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDONL9k_84CkEdK',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">windows 进程线程</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#KPCR"><span class="nav-text">KPCR</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3"><span class="nav-text">进程相关</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84"><span class="nav-text">进程结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#KPROCESS"><span class="nav-text">KPROCESS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EPROCESS"><span class="nav-text">EPROCESS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PEB"><span class="nav-text">PEB</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%98%B2%E6%8A%A4%E6%8A%80%E5%B7%A7"><span class="nav-text">进程防护技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%9F%A5%E6%89%BE"><span class="nav-text">进程查找</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E8%BF%9B%E7%A8%8B%E9%93%BE%E8%A1%A8"><span class="nav-text">遍历进程链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E8%BF%9B%E7%A8%8B-Id"><span class="nav-text">枚举进程 Id</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F"><span class="nav-text">进程隐藏</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%96%AD%E9%93%BE"><span class="nav-text">进程断链</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E8%BF%9B%E7%A8%8B-ID"><span class="nav-text">修改进程 ID</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%8A%A4"><span class="nav-text">进程保护</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BreakOnTermination-Flags-bit13"><span class="nav-text">BreakOnTermination (Flags bit13)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ProcessInserted-Flags-bit26"><span class="nav-text">ProcessInserted (Flags bit26)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ProtectedProcess-Flags2-bit11"><span class="nav-text">ProtectedProcess (Flags2 bit11)</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3"><span class="nav-text">线程相关</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9E%84"><span class="nav-text">线程结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#KTHREAD"><span class="nav-text">KTHREAD</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ETHREAD"><span class="nav-text">ETHREAD</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TEB"><span class="nav-text">TEB</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="nav-text">线程切换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="nav-text">线程切换过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E4%BD%9C%E5%BC%8F%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="nav-text">协作式线程切换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%A2%E5%8D%A0%E5%BC%8F%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="nav-text">抢占式线程切换</span></a></li></ol></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2024</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">sky123</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        39 posts in total
                    </span>
                    
                        <span>
                            631.8k words in total
                        </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>



<script src="/js/build/libs/Swup.min.js"></script>

<script src="/js/build/libs/SwupSlideTheme.min.js"></script>

<script src="/js/build/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/build/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/build/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/build/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	
<script src="/js/build/tools/imageViewer.js" type="module"></script>

<script src="/js/build/utils.js" type="module"></script>

<script src="/js/build/main.js" type="module"></script>

<script src="/js/build/layouts/navbarShrink.js" type="module"></script>

<script src="/js/build/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/build/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/build/layouts/categoryList.js" type="module"></script>



    
<script src="/js/build/tools/localSearch.js" type="module"></script>




    
<script src="/js/build/tools/codeBlock.js" type="module"></script>




    
<script src="/js/build/layouts/lazyload.js" type="module"></script>




    
<script src="/js/build/tools/runtime.js"></script>

    
<script src="/js/build/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/build/libs/Typed.min.js"></script>

  
<script src="/js/build/plugins/typed.js" type="module"></script>




    
        
<script src="/js/build/libs/mermaid.min.js"></script>

    
    
<script src="/js/build/plugins/mermaid.js"></script>






    
<script src="/js/build/libs/anime.min.js"></script>





    
<script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script>





    
<script src="/js/build/layouts/bookmarkNav.js" type="module"></script>


	
</body>

</html>