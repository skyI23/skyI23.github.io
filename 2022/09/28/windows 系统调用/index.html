<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="sky123">
    
    <!-- Completely eliminate flash of wrong theme -->
    <script>
        (function() {
            const THEME_KEY = "REDEFINE-THEME-STATUS";
            const DARK = "dark", LIGHT = "light";
            
            // Get preferred theme
            function getTheme() {
                try {
                    const saved = localStorage.getItem(THEME_KEY);
                    if (saved) {
                        const { isDark } = JSON.parse(saved);
                        return isDark ? DARK : LIGHT;
                    }
                } catch (e) {}
                
                return matchMedia("(prefers-color-scheme: dark)").matches ? DARK : LIGHT;
            }
            
            // Apply theme to document
            function applyTheme(theme) {
                const isDark = theme === DARK;
                const root = document.documentElement;
                
                // Set data attribute for CSS variables
                root.setAttribute("data-theme", theme);
                
                // Set classes for compatibility
                root.classList.add(theme);
                root.classList.remove(isDark ? LIGHT : DARK);
                root.style.colorScheme = theme;
            }
            
            // Initial application
            const theme = getTheme();
            applyTheme(theme);
            
            // Listen for system preference changes
            matchMedia("(prefers-color-scheme: dark)").addEventListener("change", ({ matches }) => {
                // Only update if using system preference (no localStorage entry)
                if (!localStorage.getItem(THEME_KEY)) {
                    applyTheme(matches ? DARK : LIGHT);
                }
            });
            
            // Set body classes once DOM is ready
            if (document.readyState !== "loading") {
                document.body.classList.add(theme + "-mode");
            } else {
                document.addEventListener("DOMContentLoaded", () => {
                    document.body.classList.add(theme + "-mode");
                    document.body.classList.remove((theme === DARK ? LIGHT : DARK) + "-mode");
                });
            }
        })();
    </script>
    
    <!-- Critical CSS to prevent flash -->
    <style>
        :root[data-theme="dark"] {
            --background-color: #202124;
            --background-color-transparent: rgba(32, 33, 36, 0.6);
            --second-background-color: #2d2e32;
            --third-background-color: #34353a;
            --third-background-color-transparent: rgba(32, 33, 36, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #ffffff;
            --second-text-color: #eeeeee;
            --third-text-color: #bebec6;
            --fourth-text-color: #999999;
            --default-text-color: #bebec6;
            --invert-text-color: #373D3F;
            --border-color: rgba(255, 255, 255, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(255, 255, 255, 0.08);
            --shadow-color-2: rgba(255, 255, 255, 0.05);
        }
        
        :root[data-theme="light"] {
            --background-color: #fff;
            --background-color-transparent: rgba(255, 255, 255, 0.6);
            --second-background-color: #f8f8f8;
            --third-background-color: #f2f2f2;
            --third-background-color-transparent: rgba(241, 241, 241, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #16171a;
            --second-text-color: #2f3037;
            --third-text-color: #5e5e5e;
            --fourth-text-color: #eeeeee;
            --default-text-color: #373D3F;
            --invert-text-color: #bebec6;
            --border-color: rgba(0, 0, 0, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(0, 0, 0, 0.08);
            --shadow-color-2: rgba(0, 0, 0, 0.05);
        }
        
        body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
        
        /* Apply body classes as soon as DOM is ready */
        :root[data-theme="dark"] body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
    </style>
    
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://skyi23.github.io/2022/09/28/windows 系统调用/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/null" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/null">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/null">
    <!--- Page Info-->
    
    <title>
        
            windows 系统调用 | sky123&#39;s site
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/css/build/tailwind.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" rel="stylesheet">
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"skyi23.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":true,"family":"JetBrains Mono","url":"https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap"}},"toc":{"enable":true,"max_depth":5,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"side_tools":{"gear_rotation":true,"auto_expand":false},"open_graph":{"enable":false,"image":"/images/redefine-og.webp","description":"Hexo Theme Redefine, Redefine Your Hexo Journey."},"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"sky123's blog","subtitle":{"text":["书有未曾经我读，事无不可对人言"],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":true,"version":"11.4.1"}},"version":"2.8.5","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"分类":{"icon":"fa-solid fa-folder","path":"/categories/"},"标签":{"icon":"fa-solid fa-tags","path":"/tags/"},"书签":{"icon":"fa-solid fa-bookmark","path":"/bookmarks/"}},"search":{"enable":true,"preload":true}},"page_templates":{"bookmarks_column":3,"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2024/11/7 00:00:00"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha256-TThEtR+XalhWKkfF383YLOrI50NGNeIqrzS+q08afrY=" crossorigin="anonymous"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>



<body>
	<div class="progress-bar-container">
	
	<span class="scroll-progress-bar"></span>
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                sky123&#39;s site
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/categories/"
                                        >
                                    <i class="fa-solid fa-folder fa-fw"></i>
                                    分类
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/tags/"
                                        >
                                    <i class="fa-solid fa-tags fa-fw"></i>
                                    标签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/bookmarks/"
                                        >
                                    <i class="fa-solid fa-bookmark fa-fw"></i>
                                    书签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/categories/"
                        >
                            <span>
                                分类
                            </span>
                            
                                <i class="fa-solid fa-folder fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/tags/"
                        >
                            <span>
                                标签
                            </span>
                            
                                <i class="fa-solid fa-tags fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/bookmarks/"
                        >
                            <span>
                                书签
                            </span>
                            
                                <i class="fa-solid fa-bookmark fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">14</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">17</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">57</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">windows 系统调用</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/icon.jpg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">sky123</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2022-09-28 11:45:14</span>
        <span class="mobile">2022-09-28 11:45:14</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-08-19 01:14:49</span>
            <span class="mobile">2025-08-19 01:14:49</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/reverse/">reverse</a>&nbsp;
                        </li>
                    
                    
                
                    
                        
                            <li>></li>
                        
                        <li>
                            <a href="/categories/reverse/windows-kernel/">windows kernel</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/windows-kernel-reverse/">windows kernel reverse</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>13.8k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>56 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<p><a class="link"   target="_blank" rel="noopener" href="https://www.vergiliusproject.com/" >https://www.vergiliusproject.com/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h1 id="R3-调用过程"><a href="#R3-调用过程" class="headerlink" title="R3 调用过程"></a>R3 调用过程</h1><p>这里以 <code>OpenProcess</code> 为例分析 Windows API 在 3 环部分的逻辑。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[User App 调用 OpenProcess]</span><br><span class="line">       │</span><br><span class="line">       ▼</span><br><span class="line">kernel32.dll!OpenProcess</span><br><span class="line">(导出 API 函数，实际上是个 IAT 跳板 thunk)</span><br><span class="line">       │</span><br><span class="line">       ▼</span><br><span class="line">kernelbase.dll!OpenProcess</span><br><span class="line">(真正构造参数、调用 Native API)</span><br><span class="line">       │</span><br><span class="line">       ▼</span><br><span class="line">ntdll.dll!NtOpenProcess</span><br><span class="line">(发起系统调用 syscall → Ring0)</span><br></pre></td></tr></table></figure></div>

<h2 id="Kernel32"><a href="#Kernel32" class="headerlink" title="Kernel32"></a>Kernel32</h2><p>在 <code>Kernel32.dll</code> 中，<code>OpenProcess</code> 属于导出名称，实际调用的函数是 <code>OpenProcessStub</code>。</p>
<p><code>OpenProcessStub</code> 函数<strong>并不直接实现核心功能</strong>，它只是一个<strong>导入表跳板（thunk）</strong>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HANDLE NTAPI <span class="title function_">OpenProcess</span><span class="params">(ACCESS_MASK dwDesiredAccess, BOOL bInheritHandle, HANDLE dwProcessId)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __imp__OpenProcess@<span class="number">12</span>(dwDesiredAccess, bInheritHandle, dwProcessId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HANDLE NTAPI <span class="title function_">OpenProcessStub</span><span class="params">(ACCESS_MASK dwDesiredAccess, BOOL bInheritHandle, HANDLE dwProcessId)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> OpenProcess(dwDesiredAccess, bInheritHandle, dwProcessId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>kernel32.dll</code> 是 Windows API 的“用户态兼容壳”与“历史稳定接口”。这个 DLL 本身不执行系统调用逻辑，而是提供类似路由的功能，把老 API 调用映射到 <code>kernelbase.dll</code>、<code>ntdll.dll</code> 的新实现，为 Win32 应用提供熟悉且不变的函数导出。</p>
<p>在 IDA 的分析中我们发现 <code>OpenProcessStub</code> 最终调用的是 <code>API-MS-Win-Core-Synch-L1-1-0.dll</code> 中导出的 <code>OpenProcess</code> 函数。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.idata:77DE1960 ; Imports from API-MS-Win-Core-Synch-L1-1-0.dll</span><br><span class="line">.idata:77DE1960 ;</span><br><span class="line">.idata:77DE1960 ; HANDLE (__stdcall *OpenProcess)(ACCESS_MASK dwDesiredAccess, BOOL bInheritHandle, HANDLE dwProcessId)</span><br><span class="line">.idata:77DE1960                 extrn __imp__OpenProcess@12:dword</span><br></pre></td></tr></table></figure></div>

<p>但是实际调试中我们发现，<code>OpenProcessStub</code> 调用的是 <code>KernelBase.dll</code> 中的 <code>OpenProcess</code> 函。</p>
<p>这实际上是 Windows 使用了一套 <strong>API‑set（虚拟 DLL）机制</strong> 来间接映射 API 调用。API‑set 是一种“协议／契约” DLL 名称，它不是实际存在的物理 DLL，而是一个 <strong>抽象接口</strong>。程序在编译时链接到这个虚拟 DLL，运行时 loader 会根据系统的 <strong>PEB.ApiSetSchema</strong> 表将其<strong>重定向到真正实现接口的模块</strong>（通常是 <code>kernelbase.dll</code> 或 <code>ntdll.dll</code>）。</p>
<h2 id="KernelBase"><a href="#KernelBase" class="headerlink" title="KernelBase"></a>KernelBase</h2><p><code>kernelbase.dll</code> 是 Windows 用户态 API 的核心实现模块，承载了大部分实际 Win32 API 的逻辑。</p>
<p>在 <code>KernelBase.dll</code> 中，<code>OpenProcess</code> 函数调用底层的 <code>NtOpenProcess</code>，并根据传入的参数设置好 <code>OBJECT_ATTRIBUTES</code> 和 <code>CLIENT_ID</code>，返回目标进程的句柄。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">HANDLE NTAPI <span class="title function_">OpenProcess</span><span class="params">(ACCESS_MASK dwDesiredAccess, BOOL bInheritHandle, HANDLE dwProcessId)</span></span><br><span class="line">&#123;</span><br><span class="line">    NTSTATUS status;                       <span class="comment">// 用于存储 NtOpenProcess 的返回状态</span></span><br><span class="line">    HANDLE hProcess = <span class="literal">NULL</span>;               <span class="comment">// 输出的进程句柄</span></span><br><span class="line">    OBJECT_ATTRIBUTES ObjectAttributes;   <span class="comment">// 用于描述打开对象的属性</span></span><br><span class="line">    CLIENT_ID ClientId;                   <span class="comment">// 用于指定目标进程 ID</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置目标进程 ID</span></span><br><span class="line">    ClientId.UniqueProcess = dwProcessId;</span><br><span class="line">    ClientId.UniqueThread = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 OBJECT_ATTRIBUTES</span></span><br><span class="line">    InitializeObjectAttributes(</span><br><span class="line">        &amp;ObjectAttributes,</span><br><span class="line">        <span class="literal">NULL</span>,                                 <span class="comment">// 没有对象名称（非命名对象）</span></span><br><span class="line">        bInheritHandle ? OBJ_INHERIT : <span class="number">0</span>,     <span class="comment">// 是否允许子进程继承句柄</span></span><br><span class="line">        <span class="literal">NULL</span>,                                 <span class="comment">// 根目录句柄为空</span></span><br><span class="line">        <span class="literal">NULL</span>                                  <span class="comment">// 不指定安全描述符</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 Native API（ntdll!NtOpenProcess）进行系统调用</span></span><br><span class="line">    status = NtOpenProcess(&amp;hProcess, dwDesiredAccess, &amp;ObjectAttributes, &amp;ClientId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果成功，则返回句柄</span></span><br><span class="line">    <span class="keyword">if</span> (NT_SUCCESS(status))</span><br><span class="line">        <span class="keyword">return</span> hProcess;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果失败，设置 Win32 错误码（供 GetLastError 使用）</span></span><br><span class="line">    BaseSetLastNTError(status);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Ntdll"><a href="#Ntdll" class="headerlink" title="Ntdll"></a>Ntdll</h2><p>在 <code>Ntdll.dll</code> 中，<code>ZwOpenProcess</code> 函数被导出为 <code>NtOpenProcess</code> 和 <code>ZwOpenProcess</code> 函数。</p>
<blockquote>
<p><code>Nt*</code> 和 <code>Zw*</code> 是微软 Windows 操作系统中用于表示<strong>Native API（原生系统调用接口）</strong>的两套函数前缀。</p>
<p>在<strong>内核</strong>中，系统本身（驱动、内核模块）有时候需要<strong>访问用户态受保护的资源</strong>（比如任意进程的 handle、文件对象等）。</p>
<ul>
<li>如果它还走 <code>Nt</code> 版本，会强制执行 <code>ObCheckObjectAccess</code>（安全访问检查）；</li>
<li>而 <code>Zw*</code> 的设计就是告诉内核：“我知道我在干啥，我是受信任代码，我<strong>不需要再检查 DACL&#x2F;SACL 了</strong>。”</li>
</ul>
<p>而因为<strong>用户态</strong>不能自行决定“跳过权限检查”，所以 <strong><code>Nt</code> 和 <code>Zw</code> 完全等价</strong>，但是为例历史兼容性，Windows 还是保留了两种前缀的函数导出名称。</p>
</blockquote>
<p><code>ntdll.dll!ZwOpenProcess</code> 是真正发起系统调用进 0 环的函数，该函数的实现如下：</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; ===========================================================</span></span><br><span class="line"><span class="comment">; 函数: ZwOpenProcess</span></span><br><span class="line"><span class="comment">; 原型: NTSTATUS NTAPI ZwOpenProcess(</span></span><br><span class="line"><span class="comment">;           _Out_ PHANDLE ProcessHandle,</span></span><br><span class="line"><span class="comment">;           _In_ ACCESS_MASK DesiredAccess,</span></span><br><span class="line"><span class="comment">;           _In_ POBJECT_ATTRIBUTES ObjectAttributes,</span></span><br><span class="line"><span class="comment">;           _In_opt_ PCLIENT_ID ClientId);</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">; 说明:</span></span><br><span class="line"><span class="comment">;   - 位于 ntdll.dll 中</span></span><br><span class="line"><span class="comment">;   - 是用户态系统调用封装（syscall stub）</span></span><br><span class="line"><span class="comment">;   - 最终通过 SYSENTER 进入内核 NtOpenProcess 实现</span></span><br><span class="line"><span class="comment">; ===========================================================</span></span><br><span class="line"></span><br><span class="line">_ZwOpenProcess@<span class="number">16</span> PROC</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">eax</span>, <span class="number">0BEh</span>            <span class="comment">; 设置 syscall 编号，0xBE = NtOpenProcess</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">edx</span>, [0x7FFE0300h]   <span class="comment">; KUSER_SHARED_DATA 中的 SystemCall 地址</span></span><br><span class="line">    <span class="keyword">call</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">edx</span>]      <span class="comment">; 间接调用，触发 sysenter 进入内核</span></span><br><span class="line">    <span class="keyword">retn</span>    <span class="number">10h</span>                  <span class="comment">; stdcall 调用约定：清理 4 个参数（4×4=16 字节）</span></span><br><span class="line">_ZwOpenProcess@<span class="number">16</span> ENDP</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>首先这里 <code>eax</code> 寄存器用于传递系统调用号（SSDT 索引）；<code>0xBE</code> 表示 <code>NtOpenProcess</code> 的系统调用号，供内核用来在 SSDT 表中查找实际实现。</p>
</li>
<li><p><code>0x7FFE0300</code> 是 Windows 的 <code>KUSER_SHARED_DATA</code> 结构中的 <code>SystemCall</code> 字段，该字段默认指向 <code>KiFastSystemCall</code>。</p>
<blockquote>
<p><code>KUSER_SHARED_DATA</code> 是 Windows 中用于优化性能、实现 syscall 跳板等功能的结构。Windows 将该结构所在的<strong>物理页</strong>映射到<strong>每个 3 环进程地址空间</strong>以及 <strong>0 环地址空间</strong>的<strong>固定地址</strong>。</p>
<ul>
<li>对于<strong>用户态</strong>这个结构位于所有进程的 <strong><code>0x7FFE0000</code></strong> 地址处。</li>
<li>对于<strong>内核态</strong>这个结构位于 <strong><code>0xFFDF0000</code>&#x2F;<code>0xFFFFF78000000000</code></strong> 地址处。</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="KiFastSystemCall（SYSENTER）"><a href="#KiFastSystemCall（SYSENTER）" class="headerlink" title="KiFastSystemCall（SYSENTER）"></a>KiFastSystemCall（SYSENTER）</h3><p><code>KiFastSystemCall</code> 函数实现如下：</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; ===========================================================</span></span><br><span class="line"><span class="comment">; 函数: KiFastSystemCall</span></span><br><span class="line"><span class="comment">; 原型: void __stdcall KiFastSystemCall(void);</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">; 说明:</span></span><br><span class="line"><span class="comment">;   - 用户态系统调用入口封装</span></span><br><span class="line"><span class="comment">;   - 被 Zw/Nt* 函数统一调用</span></span><br><span class="line"><span class="comment">;   - 封装 sysenter 指令的调用格式</span></span><br><span class="line"><span class="comment">; ===========================================================</span></span><br><span class="line"></span><br><span class="line">_KiFastSystemCall@<span class="number">0</span> PROC</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">edx</span>, <span class="built_in">esp</span>             <span class="comment">; 将当前用户栈指针传递给 edx（sysenter 需要）</span></span><br><span class="line">    <span class="keyword">sysenter</span>                     <span class="comment">; Intel 快速系统调用指令 → 切入内核态</span></span><br><span class="line">_KiFastSystemCall@<span class="number">0</span> ENDP</span><br><span class="line"></span><br><span class="line"><span class="comment">; ===========================================================</span></span><br><span class="line"><span class="comment">; 函数: KiFastSystemCallRet</span></span><br><span class="line"><span class="comment">; 原型: void __stdcall KiFastSystemCallRet(void);</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">; 说明:</span></span><br><span class="line"><span class="comment">;   - 系统调用返回点</span></span><br><span class="line"><span class="comment">;   - sysexit 返回后，执行此 ret 恢复调用者上下文</span></span><br><span class="line"><span class="comment">;   - 一般由内核代码设定 eip 返回到这里</span></span><br><span class="line"><span class="comment">; ===========================================================</span></span><br><span class="line"></span><br><span class="line">_KiFastSystemCallRet@<span class="number">0</span> PROC</span><br><span class="line">    <span class="keyword">retn</span>                         <span class="comment">; stdcall 返回，恢复用户代码执行</span></span><br><span class="line">_KiFastSystemCallRet@<span class="number">0</span> ENDP</span><br></pre></td></tr></table></figure></div>

<p>这个函数本质上就是执行 <code>sysenter</code> 指令进内核然后返回。</p>
<ul>
<li><code>sysenter</code> 指令本身 <strong>不保存上下文，也不自动切换用户栈到内核栈</strong>，它依赖于寄存器中携带的参数来完成调用，<strong>其中 <code>EDX</code> 传入的是用户态栈地址</strong>，供内核作为参数或上下文恢复使用。</li>
<li><code>KiFastSystemCall</code> 和 <code>KiFastSystemCallRet</code> 两个函数实际上是一个整体。也就是说执行完 <code>sysenter</code> 指令后紧接着就会执行 <code>KiFastSystemCallRet</code> 的 <code>retn</code> 指令返回。</li>
</ul>
<h3 id="KiIntSystemCall（INT-2E）"><a href="#KiIntSystemCall（INT-2E）" class="headerlink" title="KiIntSystemCall（INT 2E）"></a>KiIntSystemCall（INT 2E）</h3><p><code>_KiIntSystemCall</code> 使用的是 <code>INT 2E</code> 并且 <strong><code>EDX</code> 指向的是参数地址</strong>而不是栈顶。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; ------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">; 函数原型（stdcall 调用约定）：</span></span><br><span class="line"><span class="comment">;   DWORD __stdcall KiIntSystemCall(void);</span></span><br><span class="line"><span class="comment">; 描述：</span></span><br><span class="line"><span class="comment">;   使用 INT 2Eh 中断机制进行系统调用封装。</span></span><br><span class="line"><span class="comment">;   EAX 需事先设置为系统调用号，EDX 自动设置为参数表地址。</span></span><br><span class="line"><span class="comment">; ------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">PUBLIC</span> _KiIntSystemCall@<span class="number">0</span></span><br><span class="line">_KiIntSystemCall@<span class="number">0</span> PROC</span><br><span class="line"></span><br><span class="line">    <span class="comment">; ESP + 4 是返回地址</span></span><br><span class="line">    <span class="comment">; ESP + 8 才是第一个真正的参数地址</span></span><br><span class="line">    <span class="comment">; 因为本函数是 __stdcall，无参数，但实际系统调用参数在 ESP+8 开始</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">lea</span>     <span class="built_in">edx</span>, [<span class="built_in">esp</span> + <span class="number">8</span>]    <span class="comment">; 将用户态参数表的起始地址传入 EDX（供内核使用）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>     <span class="number">2Eh</span>               <span class="comment">; 触发中断 2Eh，进入内核，跳转到 IDT[2Eh]，由 _KiSystemService 处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">retn</span>                      <span class="comment">; 返回调用者（不需要额外清理堆栈）</span></span><br><span class="line"></span><br><span class="line">_KiIntSystemCall@<span class="number">0</span> ENDP</span><br></pre></td></tr></table></figure></div>

<h1 id="系统调用指令"><a href="#系统调用指令" class="headerlink" title="系统调用指令"></a>系统调用指令</h1><p>出于性能优化、兼容性和安全性考虑，<strong>Windows 在不同版本和架构中采用了不同的系统调用机制</strong>。</p>
<table>
<thead>
<tr>
<th>系统调用方式</th>
<th>用户态调用封装</th>
<th>内核入口函数</th>
<th>处理器架构</th>
<th>用途 &#x2F; 备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>int 2Eh</code></td>
<td><code>_KiIntSystemCall</code></td>
<td><code>_KiSystemService</code></td>
<td>x86</td>
<td>旧机制，Win9x ~ Windows XP 初期使用</td>
</tr>
<tr>
<td><code>sysenter</code></td>
<td><code>_KiFastSystemCall</code></td>
<td><code>_KiFastCallEntry</code></td>
<td>x86</td>
<td>Windows XP 引入的快速调用机制，默认方式</td>
</tr>
<tr>
<td><code>syscall</code></td>
<td>内联指令（无显式封装）</td>
<td><code>_KiSystemCall64</code></td>
<td>x64</td>
<td>Windows x64 架构的系统调用标准入口（如 Nt 函数内联）</td>
</tr>
</tbody></table>
<h2 id="SYSENTER-SYSEXIT"><a href="#SYSENTER-SYSEXIT" class="headerlink" title="SYSENTER&#x2F;SYSEXIT"></a>SYSENTER&#x2F;SYSEXIT</h2><p><code>SYSENTER</code> 是一种 <strong>快速系统调用机制</strong>，由 Intel 在 P6（Pentium Pro）架构中引入，用于从用户态（Ring3）切换到内核态（Ring0），替代传统的 <code>int 0x2E</code> 中断方式，以减少中断门 IDT 的开销。</p>
<h3 id="SYSENTER"><a href="#SYSENTER" class="headerlink" title="SYSENTER"></a>SYSENTER</h3><p>SYSENTER 的行为由以下三个 MSR 控制，CPU 不会自动保存用户态上下文：</p>
<table>
<thead>
<tr>
<th>MSR 名称</th>
<th>编号（十六进制）</th>
<th>内容说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>IA32_SYSENTER_CS</code></td>
<td><code>0x174</code></td>
<td>内核模式的代码段选择子（CS）</td>
</tr>
<tr>
<td><code>IA32_SYSENTER_ESP</code></td>
<td><code>0x175</code></td>
<td>内核模式栈顶指针（ESP）</td>
</tr>
<tr>
<td><code>IA32_SYSENTER_EIP</code></td>
<td><code>0x176</code></td>
<td>入口函数地址（EIP）</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>MSR（Model-Specific Register，模型特定寄存器）</strong>是由 CPU 厂商（如 Intel、AMD）定义的一类特殊寄存器，用于控制和监视处理器的底层功能。这些寄存器的<strong>功能高度依赖于处理器型号和架构</strong>，因此被称为“模型特定”。</p>
<p>MSR（Model-Specific Register）虽然是寄存器，但不像 <code>EAX/CR0</code> 那样有固定名字，它们通过<strong>编号（索引号）</strong>访问，这些编号是由 Intel&#x2F;AMD 在官方手册中定义的。例如 <code>IA32_SYSENTER_CS(0x174)</code> 是 <code>SYSENTER</code> 设置的 <code>CS</code> 代码段。</p>
<p>Intel 提供了 <code>RDMSR</code>&#x2F;<code>WRMSR</code> 用来读写 MSR 寄存器，编号通过 <code>ECX</code> 传递，读&#x2F;写 64 位的值为 <code>EDX:EAX</code>（高32位在 <code>EDX</code>，低32位在 <code>EAX</code>）。</p>
<p>另外在 WinDbg 可以通过 <code>.rdmsr</code>&#x2F;<code>.wrmsr</code> 命令来读写 MSR 寄存器。</p>
<ul>
<li><p><code>.rdmsr NNN</code>：读取指定编号的 MSR（NNN 是十六进制）</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; .rdmsr 174</span><br><span class="line">msr[174] = 00000000`00000008</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>.wrmsr NNN VALUE</code>：向 MSR 写入值（注意不要误操作系统 MSR）</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; .wrmsr 174 00000000`00000010</span><br></pre></td></tr></table></figure></div></li>
</ul>
</blockquote>
<p>在执行 <code>SYSENTER</code> 指令的过程中，硬件会自动完成如下操作：</p>
<ol>
<li><p><strong>EIP ← <code>IA32_SYSENTER_EIP</code></strong> ：跳转到内核中指定的入口函数（<code>KiFastCallEntry</code>）。</p>
</li>
<li><p><strong>CS ← <code>IA32_SYSENTER_CS &amp; 0xFFFC</code></strong> ：设置代码段寄存器为 Ring 0 代码段选择子。</p>
</li>
<li><p><strong>SS ← <code>IA32_SYSENTER_CS + 8</code></strong> ：设置堆栈段寄存器，必须满足 GDT 中段排列规范（ 要求 GDT 中段排列满足<strong>内核代码段</strong>与<strong>内核数据段</strong>紧邻）。</p>
</li>
<li><p><strong>ESP ← <code>IA32_SYSENTER_ESP</code></strong> ：切换到内核堆栈（栈顶指针）。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p><code>IA32_SYSENTER_ESP</code> 是<strong>全局的、CPU层面的默认值</strong>。它 <strong>不是线程级别的</strong>，不能区分哪个线程用哪个内核栈，所以<strong>必须用线程上下文中的 TSS.Esp0 重新切换到线程专属栈</strong>。</p>

    </div>
  </div>
</li>
<li><p><strong>当前特权级从 CPL&#x3D;3 切换为 CPL&#x3D;0</strong> ：切换到 Ring 0，进入内核模式。</p>
</li>
<li><p><strong>EFLAGS.VM &#x2F; IF 标志位被清除</strong> ：<strong>退出虚拟 8086 模式</strong>且<strong>关闭中断</strong>。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <ul>
<li><p>由于没有自动保存 EFLAGS，<strong>用户态想要恢复中断、TF 状态等，需要内核中手动保存和恢复。</strong></p>
</li>
<li><p><code>IF</code>（bit 9）控制 <strong>是否允许中断（即是否响应外部硬件中断）</strong>。如果中断在进入内核后一开始就触发，可能 <strong>打断尚未完成栈切换、TrapFrame 建立、上下文保存</strong> 的早期内核初始化逻辑，这会导致系统崩溃（比如使用未初始化栈空间、破坏返回地址等）。所以 <strong>进入内核后的第一件事就是关闭中断</strong>，等内核准备好了才通过 <code>sti</code> 指令开启中断。</p>
</li>
</ul>

    </div>
  </div></li>
</ol>
<h3 id="SYSEXIT"><a href="#SYSEXIT" class="headerlink" title="SYSEXIT"></a>SYSEXIT</h3><p><code>SYSEXIT</code> 指令用于<strong>快速返回到特权级为 3 的用户代码</strong>。它是 <code>SYSENTER</code> 指令的配套指令。该指令被优化以在从特权级 0 的系统过程返回到特权级 3 的用户过程时提供<strong>最大性能</strong>。此指令<strong>必须在特权级 0 的代码中执行</strong>。</p>
<p>在执行 <code>SYSEXIT</code> 指令的过程中，硬件会自动完成如下操作：</p>
<ol>
<li><strong>CS ← IA32_SYSENTER_CS + 16（代码段）</strong> ：从 MSR <code>IA32_SYSENTER_CS</code> 中的值，加上 16（表示 Ring 3 的代码段描述符）后写入 <code>CS</code>。</li>
<li><strong>EIP ← EDX</strong> ：将 <code>EDX</code> 的值作为返回到用户态的代码入口。</li>
<li><strong>SS ← IA32_SYSENTER_CS + 24（堆栈段）</strong> ：同样基于 <code>IA32_SYSENTER_CS</code>，加上 24 计算 Ring3 的 <code>SS</code> 段选择子。</li>
<li><strong>ESP ← ECX</strong> ：将 <code>ECX</code> 的值作为用户态堆栈的 ESP。</li>
<li><strong>CPL ← 3</strong> ：当前特权级设置为 3，即从 Ring 0 切换到 Ring 3。</li>
</ol>
<h2 id="INT-2E-IRETD"><a href="#INT-2E-IRETD" class="headerlink" title="INT 2E&#x2F;IRETD"></a>INT 2E&#x2F;IRETD</h2><p>这是早期 Windows（如 Windows NT4 ~ XP）采用的经典系统调用方式。</p>
<h3 id="INT-2E"><a href="#INT-2E" class="headerlink" title="INT 2E"></a>INT 2E</h3><p>中断指令 <code>INT</code> 的功能相对于 <code>SYSENTER</code> 有一些不同：</p>
<ol>
<li><strong>CS:EIP ← <code>IDT[0x2E]</code></strong> ：跳转到内核中指定的入口函数（<code>_KiSystemService</code>）。</li>
<li><strong>SS← <code>TSS.SS0</code></strong> ：加载内核模式的堆栈段（通常为 0x10）。</li>
<li><strong>ESP ← <code>TSS.ESP0</code></strong> ：切换到内核堆栈（栈顶指针）。</li>
<li>在<strong>内核堆栈</strong>中依次压入<strong>用户模式</strong>的寄存器 <code>SS</code>，<code>ESP</code>，<code>EFLAGS</code>，<code>CS</code>，<code>EIP</code>（<code>INT</code> 后的地址）。</li>
<li><strong>当前特权级从 CPL&#x3D;3 切换为 CPL&#x3D;0</strong> ：切换到 Ring 0，进入内核模式。</li>
<li><strong>EFLAGS.IF &#x2F; TF &#x2F; NT &#x2F; VM 标志位被清除</strong> ：关闭中断、退出单步调试与嵌套任务、强制退出虚拟 8086 模式。<ul>
<li><strong>IF（Interrupt Flag）</strong> 被清除：防止系统调用早期被外部中断打断，避免栈未初始化就进入中断处理程序。</li>
<li><strong>TF（Trap Flag）</strong> 被清除：禁止单步调试陷阱，防止调试器干扰内核指令执行。</li>
<li><strong>NT（Nested Task）</strong> 被清除：避免因 <code>IRETD</code> 触发任务切换（Task Gate），保持当前任务上下文。</li>
<li><strong>VM（Virtual 8086 Mode）</strong> 被清除：退出虚拟 8086 模式，进入真实的保护模式 Ring 0。</li>
</ul>
</li>
</ol>
<h3 id="IRETD"><a href="#IRETD" class="headerlink" title="IRETD"></a>IRETD</h3><p>从栈中弹出 <code>EIP</code>、<code>CS</code>、<code>EFLAGS</code>、<code>ESP</code>、<code>SS</code> 寄存器返回用户态。</p>
<h2 id="SYSCALL-SYSRET（仅限-x64）"><a href="#SYSCALL-SYSRET（仅限-x64）" class="headerlink" title="SYSCALL &#x2F; SYSRET（仅限 x64）"></a>SYSCALL &#x2F; SYSRET（仅限 x64）</h2><p>AMD 最先提出，Intel 后跟进，在 x64 架构中标准化。</p>
<h1 id="R0-调用过程"><a href="#R0-调用过程" class="headerlink" title="R0 调用过程"></a>R0 调用过程</h1><h2 id="KiFastCallEntry（SYSENTER）"><a href="#KiFastCallEntry（SYSENTER）" class="headerlink" title="KiFastCallEntry（SYSENTER）"></a>KiFastCallEntry（SYSENTER）</h2><h3 id="清理段寄存器"><a href="#清理段寄存器" class="headerlink" title="清理段寄存器"></a>清理段寄存器</h3><p>因为 <code>SYSENTER</code> <strong>不会设置 DS&#x2F;ES&#x2F;FS&#x2F;GS 段寄存器</strong>，而这些寄存器在内核中仍会被用到，如果它们值非法或残留用户态设置，可能导致<strong>内核访问错误或崩溃</strong>。所以 Windows 进入内核后第一件事就是清理或初始化这些段寄存器。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">PUBLIC</span> _KiFastCallEntry</span><br><span class="line">_KiFastCallEntry proc</span><br><span class="line"></span><br><span class="line"><span class="comment">; =============================================================================</span></span><br><span class="line"><span class="comment">; 初始化段寄存器：</span></span><br><span class="line"><span class="comment">; - 设置 DS/ES 为用户数据段（选择子 0x23 = 0x20 | 3）</span></span><br><span class="line"><span class="comment">; - 设置 FS 为 KPCR（处理器控制块，选择子 0x30）</span></span><br><span class="line"><span class="comment">; =============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span>     <span class="built_in">ecx</span>, KGDT_R3_DATA <span class="keyword">OR</span> RPL_MASK  <span class="comment">; ecx = 用户数据段选择子 (0x20 | 0x3 = 0x23)</span></span><br><span class="line"><span class="keyword">push</span>    KGDT_R0_PCR                    <span class="comment">; KPCR 段选择子压栈 (0x30)</span></span><br><span class="line"><span class="keyword">pop</span>     <span class="built_in">fs</span>                             <span class="comment">; 设置 FS -&gt; KPCR（fs:[0] = KPCR.SelfPcr）</span></span><br><span class="line"><span class="keyword">mov</span>     <span class="built_in">ds</span>, <span class="built_in">ecx</span>                        <span class="comment">; DS = 0x23，用户数据段</span></span><br><span class="line"><span class="keyword">mov</span>     <span class="built_in">es</span>, <span class="built_in">ecx</span>                        <span class="comment">; ES = 0x23，用户数据段</span></span><br></pre></td></tr></table></figure></div>

<h3 id="切换内核栈"><a href="#切换内核栈" class="headerlink" title="切换内核栈"></a>切换内核栈</h3><p><strong><code>SYSENTER</code> 之后，CPU 处于 Ring 0，且中断被关闭</strong>，因此在当前核上执行的 DPC 栈代码是 <strong>线程安全</strong> 的 —— 不会被打断，也不会与别的线程同时访问同一个栈。</p>
<blockquote>
<p>DPC 栈（<strong>Deferred Procedure Call Stack</strong>）是 Windows 操作系统中为每个处理器（CPU）分配的一块专用 <strong>内核栈空间</strong>，用于处理系统调用初期、延迟任务（DPC）、中断服务后的下半部分等<strong>非线程上下文</strong>的代码执行。</p>
</blockquote>
<p>但是 DPC 栈不是为线程准备的栈，不能承载线程级的数据结构（例如 <code>KTRAP_FRAME</code>）,并且后续的系统调用处理必须允许“线程切换”。因此这里需要将堆栈切换为 <code>TSS.Esp0</code>。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; =============================================================================</span></span><br><span class="line"><span class="comment">; 切换栈指针为当前线程的内核栈顶（TSS.Esp0）</span></span><br><span class="line"><span class="comment">; SYSENTER 设置的 ESP 可能是通用的 DPC 栈，此处替换为线程专属栈</span></span><br><span class="line"><span class="comment">; =============================================================================</span></span><br><span class="line"><span class="keyword">mov</span>     <span class="built_in">ecx</span>, PCR[PcTss]        <span class="comment">; 获取当前 CPU 的 TSS 结构地址</span></span><br><span class="line"><span class="keyword">mov</span>     <span class="built_in">esp</span>, [<span class="built_in">ecx</span>]+TssEsp0     <span class="comment">; 设置 ESP = 当前线程的内核栈顶</span></span><br></pre></td></tr></table></figure></div>

<p>这里实际上是从 <code>fs</code> 对应的 <code>KPCR</code> 的 <code>TSS</code> 来定位线程的 <code>TSS</code> 结构地址。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span>     <span class="built_in">ecx</span>, large <span class="built_in">fs</span>:_KPCR<span class="number">.</span>TSS</span><br><span class="line"><span class="keyword">mov</span>     <span class="built_in">esp</span>, [<span class="built_in">ecx</span>+_KTSS<span class="number">.</span>Esp0]</span><br></pre></td></tr></table></figure></div>

<h3 id="保存-TRAP-FRAME"><a href="#保存-TRAP-FRAME" class="headerlink" title="保存 TRAP_FRAME"></a>保存 TRAP_FRAME</h3><p>接下来 <code>KiFastCallEntry</code> 会在<strong>内核线程栈</strong>中构造 <strong>KTRAP_FRAME</strong> 结构，用于建立完整的“系统调用返回环境”，确保系统调用在内核态运行时能保持线程上下文、支持调试、允许中断、并准备好未来的调度。</p>
<p>其中 <code>KTRAP_FRAME</code> 结构定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">KTRAP_FRAME</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 调试器使用的辅助信息（DbgK 命令、栈回溯）</span></span><br><span class="line">    ULONG DbgEbp;                  <span class="comment">// 0x00 上层 EBP</span></span><br><span class="line">    ULONG DbgEip;                  <span class="comment">// 0x04 返回地址（EIP）</span></span><br><span class="line">    ULONG DbgArgMark;              <span class="comment">// 0x08 特定标志 0xBADB0D00</span></span><br><span class="line">    ULONG DbgArgPointer;           <span class="comment">// 0x0C 指向用户参数的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 临时段寄存器和堆栈</span></span><br><span class="line">    USHORT TempSegCs;              <span class="comment">// 0x10 临时的用户代码段（CS）</span></span><br><span class="line">    UCHAR Logging;                 <span class="comment">// 0x12 日志标志（调试器使用）</span></span><br><span class="line">    UCHAR Reserved;                <span class="comment">// 0x13 保留字段</span></span><br><span class="line">    ULONG TempEsp;                 <span class="comment">// 0x14 临时保存的 ESP（用户堆栈）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调试寄存器（如果调试启用）</span></span><br><span class="line">    ULONG Dr0;                     <span class="comment">// 0x18</span></span><br><span class="line">    ULONG Dr1;                     <span class="comment">// 0x1C</span></span><br><span class="line">    ULONG Dr2;                     <span class="comment">// 0x20</span></span><br><span class="line">    ULONG Dr3;                     <span class="comment">// 0x24</span></span><br><span class="line">    ULONG Dr6;                     <span class="comment">// 0x28</span></span><br><span class="line">    ULONG Dr7;                     <span class="comment">// 0x2C</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 段寄存器</span></span><br><span class="line">    ULONG SegGs;                   <span class="comment">// 0x30</span></span><br><span class="line">    ULONG SegEs;                   <span class="comment">// 0x34</span></span><br><span class="line">    ULONG SegDs;                   <span class="comment">// 0x38</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通用寄存器（部分易失）</span></span><br><span class="line">    ULONG Edx;                     <span class="comment">// 0x3C</span></span><br><span class="line">    ULONG Ecx;                     <span class="comment">// 0x40</span></span><br><span class="line">    ULONG Eax;                     <span class="comment">// 0x44</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 系统调用（或中断/异常）发生之前 CPU 处于的特权级（如用户态 CPL=3 时值为 1）</span></span><br><span class="line">    ULONG PreviousPreviousMode;    <span class="comment">// 0x48</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常处理链（SEH）指针，位于 TEB 中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span>* <span class="title">ExceptionList</span>;</span> <span class="comment">// 0x4C</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程环境块（TEB）段</span></span><br><span class="line">    ULONG SegFs;                   <span class="comment">// 0x50</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通用寄存器（非易失性）</span></span><br><span class="line">    ULONG Edi;                     <span class="comment">// 0x54</span></span><br><span class="line">    ULONG Esi;                     <span class="comment">// 0x58</span></span><br><span class="line">    ULONG Ebx;                     <span class="comment">// 0x5C</span></span><br><span class="line">    ULONG Ebp;                     <span class="comment">// 0x60</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误码（如中断错误码）</span></span><br><span class="line">    ULONG ErrCode;                 <span class="comment">// 0x64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制流上下文</span></span><br><span class="line">    ULONG Eip;                     <span class="comment">// 0x68</span></span><br><span class="line">    ULONG SegCs;                   <span class="comment">// 0x6C</span></span><br><span class="line">    ULONG EFlags;                  <span class="comment">// 0x70</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 堆栈上下文</span></span><br><span class="line">    ULONG HardwareEsp;             <span class="comment">// 0x74</span></span><br><span class="line">    ULONG HardwareSegSs;           <span class="comment">// 0x78</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下是 Virtual 8086 模式下的段寄存器（一般为 0）</span></span><br><span class="line">    ULONG V86Es;                   <span class="comment">// 0x7C 👈 TSS.Esp0</span></span><br><span class="line">    ULONG V86Ds;                   <span class="comment">// 0x80</span></span><br><span class="line">    ULONG V86Fs;                   <span class="comment">// 0x84</span></span><br><span class="line">    ULONG V86Gs;                   <span class="comment">// 0x88</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>而 <code>TSS.Esp0</code> 在初始状态下指向 <code>V86Es</code>，因此需要从 <code>SS</code> 寄存器开始构造。</p>
<p>首先依次压入 <code>SS</code>，<code>ESP</code>：</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span>    KGDT_R3_DATA <span class="keyword">OR</span> RPL_MASK       <span class="comment">; 压栈用户 SS(0x23)</span></span><br><span class="line"><span class="keyword">push</span>    <span class="built_in">edx</span>                            <span class="comment">; 压栈 ESP（KiFastSystemCall 中保存的用户态 ESP）</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>用户态的 <code>SS</code> 是固定的 0x23，因此即使在用户态修改了 <code>SS</code> 的值，经过系统调用后也会自动修复。</li>
<li><code>ESP</code> 来自 <code>KiFastSystemCall</code> 函数保存到 <code>EDX</code> 的用户态栈顶。</li>
</ul>
<p>关于 <code>EFLAGS</code> 寄存器这里要做一些特殊处理。除此之外还顺便将指向<strong>用户态栈顶</strong>的 <code>EDX</code> 修改为指向<strong>用户态参数</strong>。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pushfd</span>                                 <span class="comment">; 压栈当前 EFLAGS（注意：此时是内核模式下已被 SYSENTER 修改过的，IF=0、VM=0）</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">Kfsc10:</span></span><br><span class="line"><span class="keyword">push</span>    <span class="number">2</span>                              <span class="comment">; 构造一个干净的 EFLAGS，只有 bit1=1（其他清零）</span></span><br><span class="line"><span class="keyword">add</span>     <span class="built_in">edx</span>, <span class="number">8</span>                         <span class="comment">; EDX 指向用户态参数 (跳过KiFastSystemCall 和 ZwOpenProcess 两个函数的返回地址)</span></span><br><span class="line"><span class="keyword">popfd</span>                                  <span class="comment">; 用 2 替换当前 EFLAGS（清除 IF、DF、TF、NT）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">or</span>      <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esp</span>+<span class="number">1</span>], EFLAGS_INTERRUPT_MASK/<span class="number">0100h</span> <span class="comment">; 把 R3 下的可屏蔽中断打开 (EFLAGS 寄存器第 10 位 IF=1)</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>对于内核态的 <code>EFLAGS</code>：通过 <code>push 2</code> → <code>popfd</code> 设置为干净状态，只保留 bit1，关闭中断（<code>IF=0</code>），清除 <code>DF</code>&#x2F;<code>TF</code>&#x2F;<code>NT</code>。</p>
<blockquote>
<p>EFLAGS 寄存器的 <strong>bit 1</strong> 是一个<strong>保留位</strong>，<strong>始终为 1</strong>，不可清除。</p>
</blockquote>
</li>
<li><p>对于用户态的 <code>EFLAGS</code>：通过修改 <code>pushfd</code> 压栈副本中的 bit10，确保将来返回用户态时中断是打开的（<code>IF=1</code>）。</p>
</li>
</ul>
<p>之后保存 <code>CS</code> 和 <code>EIP</code>。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span>    KGDT_R3_CODE <span class="keyword">OR</span> RPL_MASK       <span class="comment">; 压栈用户 CS(0x1B)</span></span><br><span class="line"><span class="keyword">push</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[USER_SHARED_DATA+UsSystemCallReturn] <span class="comment">; 压栈用户 EIP 为 KiFastSystemCallRet</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>CS</code> 是和 <code>SS</code> 一样是固定的值，这里设置为 0x1B。</li>
<li><code>EIP</code> 设置为 <code>USER_SHARED_DATA.SystemCallReturn</code>，这里默认是 <code>KiFastSystemCallRet</code> 函数。</li>
</ul>
<p>接下来填充 <code>KTRAP_FRAME</code> 的 <code>ErrCode</code> 字段为 0，表示无异常。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span>    <span class="number">0</span>                               <span class="comment">; 压栈填充 ErrCode 用于错误处理</span></span><br></pre></td></tr></table></figure></div>

<p>接下来是一些非易失寄存器，这里直接保存即可。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span>    <span class="built_in">ebp</span>                             <span class="comment">; 保存非易失寄存器 ebp</span></span><br><span class="line"><span class="keyword">push</span>    <span class="built_in">ebx</span>                             <span class="comment">; 保存非易失寄存器 ebx</span></span><br><span class="line"><span class="keyword">push</span>    <span class="built_in">esi</span>                             <span class="comment">; 保存非易失寄存器 esi</span></span><br><span class="line"><span class="keyword">push</span>    <span class="built_in">edi</span>                             <span class="comment">; 保存非易失寄存器 edi</span></span><br></pre></td></tr></table></figure></div>

<p>接下来会把 <code>EBX</code> 和 <code>ESI</code> 两个寄存器分别指向两个重要的结构。另外这里还会保存用户态的 <code>FS(0x3B)</code>，同样是固定的值。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span>     <span class="built_in">ebx</span>, PCR[PcSelfPcr]            <span class="comment">; 获取当前处理器 KPCR 地址</span></span><br><span class="line"><span class="keyword">push</span>    KGDT_R3_TEB <span class="keyword">OR</span> RPL_MASK        <span class="comment">; 压栈用户模式 FS(0x3B) 指向 TEB</span></span><br><span class="line"><span class="keyword">mov</span>     <span class="built_in">esi</span>, [<span class="built_in">ebx</span>].PcPrcbData+PbCurrentThread <span class="comment">; 获取当前线程的地址</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><code>EBX</code> 指向当前处理器的 <code>KPCR</code> 结构。由于 <code>KPCR</code> 结构体的地址位于内核 <code>FS(0x30)</code> 对应段描述符的基址中，因此这里是借助 <code>KPCR</code> 的 <code>SelfPcr</code> 字段获取的 <code>KPCR</code> 地址。 </p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ebx</span>, large <span class="built_in">fs</span>:_KPCR<span class="number">.</span>SelfPcr</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>ESI</code> 指向当前线程对应的 <code>KTHREAD</code> 结构。这个结构是通过 <code>KPCR.PrcbData.CurrentThread</code> 获得的。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">esi</span>, [<span class="built_in">ebx</span>+_KPCR<span class="number">.</span>PrcbData<span class="number">.</span>CurrentThread]</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>为了防止内核执行期间访问用户态的 SEH（结构化异常处理）链，避免异常处理被用户控制的数据干扰或利用。接下来会保存<strong>用户态的异常链地址</strong>，同时<strong>清空当前线程的异常处理链</strong>，防止内核期间意外触发结构化异常时查表失败或被恶意利用。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span>    [<span class="built_in">ebx</span>].PcExceptionList          <span class="comment">; 保存旧的异常链</span></span><br><span class="line"><span class="keyword">mov</span>     [<span class="built_in">ebx</span>].PcExceptionList, EXCEPTION_CHAIN_END <span class="comment">; 设置新的空链 EXCEPTION_CHAIN_END(-1)</span></span><br></pre></td></tr></table></figure></div>

<p>这里 <code>EBX</code> 就是前面获取的 <code>KPCR</code> 结构地址：</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span>    [<span class="built_in">ebx</span>+_KPCR<span class="number">.</span>NtTib<span class="number">.</span>ExceptionList]		<span class="comment">; TRAP_FRAME.ExceptionList = KPCR.NtTib.ExceptionList</span></span><br><span class="line"><span class="keyword">mov</span>     [<span class="built_in">ebx</span>+_KPCR<span class="number">.</span>NtTib<span class="number">.</span>ExceptionList], -<span class="number">1</span>	<span class="comment">; KPCR.NtTib.ExceptionList = -1</span></span><br></pre></td></tr></table></figure></div>

<p>之后会为 <code>KTRAP_FRAME</code> 分配剩余空间并作地址检查。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 保存之前的模式（用户模式），并为 trap frame 分配剩余空间</span></span><br><span class="line"><span class="keyword">mov</span>     <span class="built_in">ebp</span>, [<span class="built_in">esi</span>].ThInitialStack      <span class="comment">; 获取线程的内核栈顶（初始栈地址）</span></span><br><span class="line"><span class="keyword">push</span>    MODE_MASK                      <span class="comment">; 将调用来源（用户模式 1）压入栈中</span></span><br><span class="line"><span class="keyword">sub</span>     <span class="built_in">esp</span>, TsPreviousPreviousMode    <span class="comment">; 为 trap frame 分配剩余空间，TsPreviousPreviousMode(0x48) 是 PreviousPreviousMode 在 KTRAP_FRAME 的偏移</span></span><br><span class="line"><span class="keyword">sub</span>     <span class="built_in">ebp</span>, NPX_FRAME_LENGTH + KTRAP_FRAME_LENGTH <span class="comment">; 0x210 + 0x8C = 0x29C</span></span><br><span class="line"><span class="keyword">mov</span>     <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>].ThPreviousMode, MODE_MASK <span class="comment">; 设置线程的 PreviousMode = UserMode</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 校验 TrapFrame 构造完整性，如果栈异常则拒绝执行</span></span><br><span class="line"><span class="keyword">cmp</span>     <span class="built_in">ebp</span>, <span class="built_in">esp</span></span><br><span class="line"><span class="keyword">jne</span>     short Kfsc91</span><br></pre></td></tr></table></figure></div>

<ul>
<li>设置 <code>KTRAP_FRAME.PreviousPreviousMode</code> 和 <code>KPCR.PrcbData.CurrentThread-&gt;PreviousMode</code> 为 1 表示是来自用户态的调用。</li>
<li>比较 <code>KTRAP_FRAME</code> 地址与 <code>KPCR.PrcbData.CurrentThread-&gt;InitialStack - sizeof(NPX_FRAME) - sizeof(KTRAP_FRAME)</code>，如果不相等则拒绝执行。<ul>
<li><code>KTRAP_FRAME</code> 地址是在当 <code>ESP</code> 指向 <code>KTRAP_FRAME.PreviousPreviousMode</code> 的时候有减去 <code>PreviousPreviousMode</code> 在 <code>KTRAP_FRAME</code> 的偏移得到的。</li>
<li><code>KTHREAD.InitialStack</code> 指向内核栈底，而在内核栈底保存着 <code>NPX_FRAME</code> 和 <code>KTRAP_FRAME</code> 两个结构。</li>
<li>如果两者不相等说明 <code>TSS.Esp0</code> 并没有指向 <code>KTRAP_FRAME.V86Es</code> 位置，即当前线程是以 <strong>虚拟8086（V86）模式</strong> 创建的线程，具有特殊的栈结构。或者栈指针被破坏、异常栈使用错误。</li>
</ul>
</li>
</ul>
<p><code>Kfsc91</code> 会抛出 <code>#UD</code>（Invalid Opcode，非法&#x2F;未定义指令）异常。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">; 如果 sysenter 指令是在非法的用户上下文（如 16 位段或虚拟 8086 模式）中执行的，</span></span><br><span class="line"><span class="comment">; 则无法正确返回用户态代码，也无法安全构造 TrapFrame 进行系统调用处理。</span></span><br><span class="line"><span class="comment">; 因此，模拟构造一个伪造的“用户模式”上下文，然后跳转到非法指令异常处理函数 _KiTrap06。</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">Kfsc90:</span></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">ecx</span>, PCR[PcTss]                      <span class="comment">; 获取当前处理器的 TSS 指针</span></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">esp</span>, [<span class="built_in">ecx</span>]+TssEsp0                   <span class="comment">; 使用 TSS.ESP0 作为新的内核栈顶（当前线程的内核栈）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">push</span>    <span class="number">0</span>                                     <span class="comment">; 模拟保存虚拟 8086 模式下的 ES</span></span><br><span class="line">        <span class="keyword">push</span>    <span class="number">0</span>                                     <span class="comment">; 模拟保存虚拟 8086 模式下的 DS</span></span><br><span class="line">        <span class="keyword">push</span>    <span class="number">0</span>                                     <span class="comment">; 模拟保存虚拟 8086 模式下的 FS</span></span><br><span class="line">        <span class="keyword">push</span>    <span class="number">0</span>                                     <span class="comment">; 模拟保存虚拟 8086 模式下的 GS</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">push</span>    KGDT_R3_DATA <span class="keyword">OR</span> RPL_MASK              <span class="comment">; 用户数据段 SS（0x20 | 0x3 = 0x23）</span></span><br><span class="line">        <span class="keyword">push</span>    <span class="number">0</span>                                     <span class="comment">; 用户栈指针 ESP（由于无法得知，设置为 0 占位）</span></span><br><span class="line">        <span class="keyword">push</span>    EFLAGS_INTERRUPT_MASK + EFLAGS_V86_MASK + <span class="number">2h</span> </span><br><span class="line">                                                     <span class="comment">; 构造 EFLAGS 值，IF=1（允许中断），VM=1（虚拟8086模式），bit1=1（系统要求）</span></span><br><span class="line">        <span class="keyword">push</span>    KGDT_R3_CODE <span class="keyword">OR</span> RPL_MASK              <span class="comment">; 用户代码段 CS（0x18 | 0x3 = 0x1B）</span></span><br><span class="line">        <span class="keyword">push</span>    <span class="number">0</span>                                     <span class="comment">; 用户 EIP（指令指针，未知，设为 0）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">jmp</span>     _KiTrap06                             <span class="comment">; 跳转到非法指令处理函数，相当于抛出 #UD（Invalid Opcode 异常）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">; 如果 Trap Frame 构造时栈指针不一致（说明栈异常或非法线程调用），则跳转处理异常。</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">Kfsc91:</span></span><br><span class="line">        <span class="keyword">jmp</span>     Kfsc90                                <span class="comment">; 回退到异常处理逻辑</span></span><br></pre></td></tr></table></figure></div>

<p>最后再初始化 <code>KTRAP_FRAME</code> 中调试相关字段。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">; 设置当前线程的 Trap Frame 地址，并处理调试相关逻辑</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">and</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>].TsDr7, <span class="number">0</span>                  <span class="comment">; 清除 Trap Frame 中的 DR7（调试寄存器）值，防止继承用户态调试状态</span></span><br><span class="line">        <span class="keyword">test</span>    <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>].ThDebugActive, <span class="number">0ffh</span>       <span class="comment">; 检查当前线程是否启用了调试（ThDebugActive != 0）</span></span><br><span class="line">        <span class="keyword">mov</span>     [<span class="built_in">esi</span>].ThTrapFrame, <span class="built_in">ebp</span>                   <span class="comment">; 将当前 Trap Frame 的地址写入线程结构中的 ThTrapFrame 字段</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">jnz</span>     Dr_FastCallDrSave                        <span class="comment">; 如果线程启用了调试功能，则跳转保存调试寄存器（如 DR0~DR6）</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">Dr_FastCallDrReturn:</span></span><br><span class="line"></span><br><span class="line">        SET_DEBUG_DATA                                   <span class="comment">; 设置调试器辅助信息字段（DbgEbp / DbgEip / ArgPointer 等）</span></span><br><span class="line">                                                         <span class="comment">; 注意：该宏体内会破坏 ebx 和 edi 的值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">sti</span>                                              <span class="comment">; 恢复中断标志位（IF=1），允许内核再次响应该核上的中断请求</span></span><br><span class="line"></span><br><span class="line">        ?FpoValue = <span class="number">0</span>                                    <span class="comment">; 表示当前栈帧未省略帧指针（ebp 保留），供调试器分析使用</span></span><br></pre></td></tr></table></figure></div>

<p><code>Dr_FastCallDrSave</code> 函数会保存用户态的调试寄存器到 <code>KTRAP_FRAME</code> 结构，然后从 <code>KPRCB.ProcessorState.SpecialRegisters</code> 取出调试寄存器对应内核态的值赋值给调试寄存器。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; =============================================================================</span></span><br><span class="line"><span class="comment">; 函数：Dr_FastCallDrSave</span></span><br><span class="line"><span class="comment">; 描述：若线程启用了调试功能（ThDebugActive != 0），则保存用户态调试寄存器，</span></span><br><span class="line"><span class="comment">;       并清除 DR7，防止用户设置的硬件断点影响内核，再恢复内核态默认值。</span></span><br><span class="line"><span class="comment">;       支持 TrapFrame 构造过程。</span></span><br><span class="line"><span class="comment">; =============================================================================</span></span><br><span class="line">Dr_FastCallDrSave proc <span class="built_in">near</span>             <span class="comment">; ← _KiFastCallEntry 调用处跳转</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">; ----------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">; 检查是否处于虚拟 8086 模式（EFLAGS.VM = 1），若是则跳转保存调试寄存器</span></span><br><span class="line">    <span class="comment">; ----------------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">test</span>    [<span class="built_in">ebp</span>+_KTRAP_FRAME<span class="number">.</span>EFlags], EFLAGS_V86_MASK <span class="comment">; = 0x20000</span></span><br><span class="line">    <span class="keyword">jnz</span>     short Dr_SaveDebugRegs</span><br><span class="line"></span><br><span class="line">    <span class="comment">; ----------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">; 检查代码段最低位（CPL=3）是否为用户态调用，若不是则直接返回</span></span><br><span class="line">    <span class="comment">; ----------------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">test</span>    <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+_KTRAP_FRAME<span class="number">.</span>SegCs], <span class="number">1</span></span><br><span class="line">    <span class="keyword">jz</span>      Dr_FastCallDrReturn</span><br><span class="line"></span><br><span class="line"><span class="comment">; ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">; 保存调试寄存器内容到 TrapFrame（用户态调试上下文）</span></span><br><span class="line"><span class="comment">; ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="symbol">Dr_SaveDebugRegs:</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">ebx</span>, <span class="built_in">dr0</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">ecx</span>, <span class="built_in">dr1</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">edi</span>, <span class="built_in">dr2</span></span><br><span class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+_KTRAP_FRAME<span class="number">.</span><span class="built_in">Dr0</span>], <span class="built_in">ebx</span></span><br><span class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+_KTRAP_FRAME<span class="number">.</span><span class="built_in">Dr1</span>], <span class="built_in">ecx</span></span><br><span class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+_KTRAP_FRAME<span class="number">.</span><span class="built_in">Dr2</span>], <span class="built_in">edi</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">ebx</span>, <span class="built_in">dr3</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">ecx</span>, dr6</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">edi</span>, dr7</span><br><span class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+_KTRAP_FRAME<span class="number">.</span><span class="built_in">Dr3</span>], <span class="built_in">ebx</span></span><br><span class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+_KTRAP_FRAME<span class="number">.</span>Dr6], <span class="built_in">ecx</span></span><br><span class="line">    <span class="keyword">xor</span>     <span class="built_in">ebx</span>, <span class="built_in">ebx</span></span><br><span class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+_KTRAP_FRAME<span class="number">.</span>Dr7], <span class="built_in">edi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">; 清除当前 DR7，避免用户态设置影响内核调试状态</span></span><br><span class="line">    <span class="keyword">mov</span>     dr7, <span class="built_in">ebx</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">; ----------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">; 恢复内核态调试寄存器值（来自 KPCR.Prcb.ProcessorState.SpecialRegisters）</span></span><br><span class="line">    <span class="comment">; ----------------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">edi</span>, large <span class="built_in">fs</span>:_KPCR<span class="number">.</span>Prcb</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">ebx</span>, [<span class="built_in">edi</span>+_KPRCB<span class="number">.</span>ProcessorState<span class="number">.</span>SpecialRegisters<span class="number">.</span>KernelDr0]</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">ecx</span>, [<span class="built_in">edi</span>+_KPRCB<span class="number">.</span>ProcessorState<span class="number">.</span>SpecialRegisters<span class="number">.</span>KernelDr1]</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">dr0</span>, <span class="built_in">ebx</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">dr1</span>, <span class="built_in">ecx</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">ebx</span>, [<span class="built_in">edi</span>+_KPRCB<span class="number">.</span>ProcessorState<span class="number">.</span>SpecialRegisters<span class="number">.</span>KernelDr2]</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">ecx</span>, [<span class="built_in">edi</span>+_KPRCB<span class="number">.</span>ProcessorState<span class="number">.</span>SpecialRegisters<span class="number">.</span>KernelDr3]</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">dr2</span>, <span class="built_in">ebx</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">dr3</span>, <span class="built_in">ecx</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">ebx</span>, [<span class="built_in">edi</span>+_KPRCB<span class="number">.</span>ProcessorState<span class="number">.</span>SpecialRegisters<span class="number">.</span>KernelDr6]</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">ecx</span>, [<span class="built_in">edi</span>+_KPRCB<span class="number">.</span>ProcessorState<span class="number">.</span>SpecialRegisters<span class="number">.</span>KernelDr7]</span><br><span class="line">    <span class="keyword">mov</span>     dr6, <span class="built_in">ebx</span></span><br><span class="line">    <span class="keyword">mov</span>     dr7, <span class="built_in">ecx</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">; ----------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">; 跳转回常规流程，继续执行系统调用处理逻辑</span></span><br><span class="line">    <span class="comment">; ----------------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">jmp</span>     Dr_FastCallDrReturn</span><br><span class="line"></span><br><span class="line">Dr_FastCallDrSave endp</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><code>SET_DEBUG_DATA</code> 宏则会保存 <code>EIP</code>，<code>EBP</code>，和参数地址信息，方便我们调试的时候进行栈 0 环到 3 环的回溯。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;++</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">;   从多个寄存器或变量中提取数据并写入 TrapFrame 的调试辅助字段。</span></span><br><span class="line"><span class="comment">;   目的是方便调试器（如 WinDbg 的 KB 命令）追踪系统调用的参数与栈信息。</span></span><br><span class="line"><span class="comment">;   特别适用于从内核态返回用户态的路径上（系统调用、异常、或中断处理）。</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">;   本宏会破坏 ebx 和 edi 的值。</span></span><br><span class="line"><span class="comment">;--</span></span><br><span class="line"></span><br><span class="line">SET_DEBUG_DATA macro</span><br><span class="line"></span><br><span class="line">ife FPO  <span class="comment">; 如果未启用帧指针省略（Frame Pointer Omission）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">; 本宏由 ENTER_SYSCALL、ENTER_TRAP 和 ENTER_INTERRUPT 等入口宏调用，</span></span><br><span class="line"><span class="comment">; 用于设置 TrapFrame 的调试字段（DbgEbp、DbgEip、DbgArgPointer 等）。</span></span><br><span class="line"><span class="comment">; 调试器可以通过这些字段还原调用栈和参数信息。</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">ebx</span>, [<span class="built_in">ebp</span>]+TsEbp                 <span class="comment">; 提取当前帧中的 EBP（调用者帧指针），保存到 ebx</span></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">edi</span>, [<span class="built_in">ebp</span>]+TsEip                 <span class="comment">; 提取当前帧中的 EIP（返回地址），保存到 edi</span></span><br><span class="line">        <span class="keyword">mov</span>     [<span class="built_in">ebp</span>]+TsDbgArgPointer, <span class="built_in">edx</span>       <span class="comment">; 将 edx（指向系统调用参数）保存到 TrapFrame 的 DbgArgPointer 字段</span></span><br><span class="line">        <span class="keyword">mov</span>     [<span class="built_in">ebp</span>]+TsDbgArgMark, <span class="number">0BADB0D00h</span>   <span class="comment">; 设置调试标记，用于调试器识别系统调用帧（0xBADB0D00 是魔数）</span></span><br><span class="line">        <span class="keyword">mov</span>     [<span class="built_in">ebp</span>]+TsDbgEbp, <span class="built_in">ebx</span>              <span class="comment">; 把 EBP 保存到 TrapFrame 的 DbgEbp 字段</span></span><br><span class="line">        <span class="keyword">mov</span>     [<span class="built_in">ebp</span>]+TsDbgEip, <span class="built_in">edi</span>              <span class="comment">; 把 EIP 保存到 TrapFrame 的 DbgEip 字段</span></span><br><span class="line"></span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">endm</span><br></pre></td></tr></table></figure></div>

<h3 id="调用-SSDT-表函数"><a href="#调用-SSDT-表函数" class="headerlink" title="调用 SSDT 表函数"></a>调用 SSDT 表函数</h3><p><strong>系统服务分发表（SSDT，System Service Dispatch Table）</strong>是 Windows 内核中的一个关键数据结构，用来将用户空间的系统调用映射到对应的内核函数。</p>
<p>当用户程序通过 <code>int 0x2e</code>（老版）或 <code>sysenter/syscall</code>（新版） 发起系统调用时：</p>
<ul>
<li>系统调用号（Service ID）被放入 <code>EAX</code>。</li>
<li>内核通过 <code>SSDT[EAX]</code> 查找到该号对应的内核函数指针并调用它。</li>
</ul>
<p>SSDT 实际是一个结构体数组，每一项描述一个服务表（例如 Native API、Win32k GUI API等）。其核心结构如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KSERVICE_TABLE_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    PULONG  ServiceTableBase;         <span class="comment">// SSDT 函数地址表</span></span><br><span class="line">    PULONG  ServiceCounterTableBase;  <span class="comment">// 服务调用计数表（调试用途）</span></span><br><span class="line">    ULONG   NumberOfServices;         <span class="comment">// 系统服务总数</span></span><br><span class="line">    PUCHAR  ParamTableBase;           <span class="comment">// 参数大小表（每个服务的参数字节数）</span></span><br><span class="line">&#125; KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><code>ServiceTableBase</code>：<strong>系统服务函数表</strong>的基地址。</p>
<ul>
<li><p>在 x86 中，它是一个 <strong>函数地址数组</strong>，每个 DWORD 为一个系统调用的实现地址；</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FuncAddr = KeServiceDescriptorTable.ServiceTableBase[index];</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>在 x64 中，它是一个 <strong>偏移值数组</strong>，每项存储的是 <code>(TargetFunctionAddress - KiSystemCall64Base) &lt;&lt; 4</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FuncAddr = ((KeServiceDescriptorTable.ServiceTableBase[index] &gt;&gt; <span class="number">4</span>)</span><br><span class="line">           + KeServiceDescriptorTable.ServiceTableBase);</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><p><code>ServiceCounterTableBase</code>：<strong>服务调用计数表</strong>的基地址。每个服务对应一个计数器，用于记录该系统服务被调用的次数。此字段通常为 <code>NULL</code>，仅在<strong>调试版本</strong>的内核中启用。</p>
</li>
<li><p><code>NumberOfServices</code>：<strong>系统调用的总个数</strong>，即 <code>ServiceTableBase</code> 中可用的函数总数。<strong>系统调用前会验证调用号是否越界（EAX&#x2F;RAX 是否 &lt; 该值）</strong>。</p>
</li>
<li><p><code>ParamTableBase</code>：参数长度表，每项是一个字节，表示对应系统服务调用的<strong>参数总大小</strong>（单位：字节）。</p>
</li>
</ul>
<p>Windows 系统维护一个或多个服务表（内核表、GUI 表等），统一管理在如下符号变量中：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable;</span><br><span class="line">KSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTableShadow[<span class="number">4</span>];</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>KeServiceDescriptorTable</code> 描述的是 ntoskrnl 表（native API），处理 <code>Nt*</code> 系列系统调用。<code>KeServiceDescriptorTable</code> 在低版本系统中是对外导出的。</li>
<li><code>KeServiceDescriptorTableShadow</code> 是一个 <code>KSERVICE_TABLE_DESCRIPTOR</code> 结构体数组，有 4 项，但通常只使用前 2 项。<code>KeServiceDescriptorTableShadow</code> 不对外导出，但是通常位于 <code>KeServiceDescriptorTable</code> 表上方偏移 0x40 处。<ul>
<li><code>KeServiceDescriptorTableShadow[0]</code> 和 <code>KeServiceDescriptorTable</code> 内容相同。</li>
<li><code>KeServiceDescriptorTableShadow[1]</code> 描述的是  GUI&#x2F;GDI（win32k.sys）服务 SSDT，处理 GUI 调用（如 <code>NtUser*</code>、<code>NtGdi*</code>）</li>
</ul>
</li>
</ul>
<p><code>KTHREAD.ServiceTable</code> 会指向其中一个表，具体是哪个取决于当前线程是否是 UI 线程。</p>
<p>首先 Windows 会根据传入的系统调用号 <code>EAX</code> 提取<strong>服务表信息</strong>和<strong>服务号</strong>。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">; 输入寄存器说明：</span></span><br><span class="line"><span class="comment">; (eax) = 系统调用号（包含服务表信息 + 服务号）</span></span><br><span class="line"><span class="comment">; (edx) = 调用者的参数栈地址（用户栈指针）</span></span><br><span class="line"><span class="comment">; (esi) = 当前线程 (_KTHREAD) 结构地址</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">; 所有其他寄存器已保存，此函数可自由使用</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">_KiSystemServiceRepeat:</span></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">edi</span>, <span class="built_in">eax</span>                          <span class="comment">; 备份 EAX（系统调用号）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">shr</span>     <span class="built_in">edi</span>, SERVICE_TABLE_SHIFT          <span class="comment">; 提取服务表标志（默认右移8位，获取 bit8~11）</span></span><br><span class="line">        <span class="keyword">and</span>     <span class="built_in">edi</span>, SERVICE_TABLE_MASK           <span class="comment">; 保留表选择位（0x00 或 0x10），用于构造偏移</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">ecx</span>, <span class="built_in">edi</span>                          <span class="comment">; 将服务表标志保存在 ECX（后面判断 GUI 表用）</span></span><br><span class="line">        <span class="keyword">add</span>     <span class="built_in">edi</span>, [<span class="built_in">esi</span>]+ThServiceTable         <span class="comment">; edi = 当前线程的 ServiceTableBase + 表偏移（0 或 0x10）</span></span><br><span class="line">                                                  <span class="comment">; → 得到 KSERVICE_TABLE_DESCRIPTOR 结构地址</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">ebx</span>, <span class="built_in">eax</span>                          <span class="comment">; 备份原始 syscall 号（后续恢复）</span></span><br><span class="line">        <span class="keyword">and</span>     <span class="built_in">eax</span>, SERVICE_NUMBER_MASK          <span class="comment">; 提取 syscall 号低12位作为服务号（表内函数索引）</span></span><br></pre></td></tr></table></figure></div>

<p>查询 SSDT 表的系统调用号 <code>EAX</code> 不只是一个简单的索引，而是由以下部分组成：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EAX (32-bit syscall number):</span><br><span class="line">[ unused (18 bits) ][ TableOffset (2 bits) ][ ServiceNumber (12 bits) ]</span><br></pre></td></tr></table></figure></div>

<p>即前 12 比特表示的是系统调用处理函数在 SSDT 表中的下标，而之后的 2 比特表示的是 SSDT 表在 <code>KeServiceDescriptorTableShadow</code>（<code>KTHREAD.ServiceTable</code>）中的索引。</p>
<p>这段代码的逻辑是：</p>
<ul>
<li><code>ECX = (EAX &gt;&gt; 8) &amp; 0x10</code>，即将 <code>EDI</code> 赋值为<strong>调用号</strong>对应在 <code>KeServiceDescriptorTableShadow</code> 中的<strong>偏移</strong>。这里右移 8 实际上就是在右移 12 的基础上乘上了 <code>KSERVICE_TABLE_DESCRIPTOR</code> 的大小 0x10，而 <code>&amp; 0x10</code> 是为了清除服务号的高 4 比特且 <code>KeServiceDescriptorTableShadow</code> 只有前 2 项有效。</li>
<li><code>EDI = ECX + KTHREAD.ServiceTable</code>，将 <code>EDI</code> 指向对应的 <code>KSERVICE_TABLE_DESCRIPTOR</code> 结构。</li>
<li><code>EBX = EAX</code>，将原始的调用号备份到 <code>EBX</code> 中。</li>
<li><code>EAX = EAX &amp; 0xFFF</code>，取调用号的低 12 位得到<strong>服务号</strong>。</li>
</ul>
<p>之后会根据 <code>KSERVICE_TABLE_DESCRIPTOR.NumberOfServices</code> 检查服务号范围是否合法。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">; 检查服务号是否在表的有效范围内（超过最大服务数则非法）</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">cmp</span>     <span class="built_in">eax</span>, [<span class="built_in">edi</span>]+SdLimit                <span class="comment">; 比较服务号是否超出 NumberOfServices</span></span><br><span class="line">        <span class="keyword">jae</span>     Kss_ErrorHandler                  <span class="comment">; 如果越界，跳转错误处理（可能切换为 GUI 线程）</span></span><br></pre></td></tr></table></figure></div>

<p>如果是 GUI 服务，并且线程的 GDI 批调用计数不为 0，则调用 <code>KeGdiFlushUserBatch</code> 将批量 GDI 操作刷新提交；这一步是防止内核处理一个系统调用时，用户空间的批处理操作尚未同步，确保图形一致性。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">; 如果当前表是 GUI 表（win32k.sys），并且存在 batched GDI 调用，则刷新批处理</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">cmp</span>     <span class="built_in">ecx</span>, SERVICE_TABLE_TEST           <span class="comment">; 检查是否是 GUI 表（== 0x10）</span></span><br><span class="line">        <span class="keyword">jne</span>     short Kss40                       <span class="comment">; 如果不是 GUI 表，跳过刷新逻辑</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">ecx</span>, PCR[PcTeb]                   <span class="comment">; 获取当前线程的 TEB（Thread Environment Block）地址</span></span><br><span class="line">        <span class="keyword">xor</span>     <span class="built_in">ebx</span>, <span class="built_in">ebx</span>                          <span class="comment">; 清零 ebx，准备检查 GDI 批处理数</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">KiSystemServiceAccessTeb:</span></span><br><span class="line">        <span class="keyword">or</span>      <span class="built_in">ebx</span>, [<span class="built_in">ecx</span>]+TbGdiBatchCount        <span class="comment">; 判断 TEB 中是否有 GDI 批调用（可能触发页错误）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">jz</span>      short Kss40                       <span class="comment">; 如果为0，则没有 GDI 批处理，跳过</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">push</span>    <span class="built_in">edx</span>                               <span class="comment">; 保存用户参数地址</span></span><br><span class="line">        <span class="keyword">push</span>    <span class="built_in">eax</span>                               <span class="comment">; 保存 syscall 编号</span></span><br><span class="line">        <span class="keyword">call</span>    [_KeGdiFlushUserBatch]            <span class="comment">; 调用内核函数刷新 GDI 批处理</span></span><br><span class="line">        <span class="keyword">pop</span>     <span class="built_in">eax</span>                               <span class="comment">; 恢复 syscall 编号</span></span><br><span class="line">        <span class="keyword">pop</span>     <span class="built_in">edx</span>                               <span class="comment">; 恢复用户参数地址</span></span><br></pre></td></tr></table></figure></div>

<p>之后会更新服务调用计数，用于调试分析和性能统计。</p>
<ul>
<li><code>KPCR.PrcbData.KeSystemCalls++</code>，增加当前处理器的系统调用计数。</li>
<li><code>KSERVICE_TABLE_DESCRIPTOR.ServiceCounterTableBase[EAX]++</code>，更新 SSDT 表中的服务调用次数，仅调试版中启用。</li>
</ul>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Kss40:</span></span><br><span class="line">        <span class="keyword">inc</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> PCR[PcPrcbData+PbSystemCalls] <span class="comment">; 增加当前处理器的系统调用计数</span></span><br><span class="line"></span><br><span class="line">if DBG</span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">ecx</span>, [<span class="built_in">edi</span>]+SdCount                <span class="comment">; 获取调试用的调用计数表</span></span><br><span class="line">        <span class="keyword">jecxz</span>   short @f                          <span class="comment">; 如果未定义，跳过；jecxz 表示如果 ECX = 0，则跳转到 label 处执行</span></span><br><span class="line">        <span class="keyword">inc</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ecx</span>+<span class="built_in">eax</span>*<span class="number">4</span>]             <span class="comment">; 当前服务号的调用次数 +1</span></span><br><span class="line">@@:</span><br><span class="line">endif</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><code>@@</code> 和 <code>@f</code> 是 <strong>MASM 汇编语法</strong>中的临时标签：</p>
<ul>
<li><code>@@</code>：表示一个临时标签（label），通常配合 <code>@f</code> 和 <code>@b</code> 使用。</li>
<li><code>@f</code>：表示“向前（forward）跳转”到最近定义的 <code>@@</code>。</li>
<li><code>@b</code>：表示“向后（backward）跳转”到最近定义的 <code>@@</code>。</li>
</ul>
</blockquote>
<p>服务函数的参数总是从用户栈复制到内核栈，参数长度由 <code>SdNumber</code> 表给出（一个字节表示每项服务的参数总大小），复制前栈空间预分配，且防止从非法内核地址读取数据。最后调用对应服务号的函数。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">; 将用户栈上的参数复制到内核栈</span></span><br><span class="line"><span class="comment">; 所有服务都这样做（即使参数为0），因为调用帧空间已提前分配</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">FPOFRAME ?FpoValue, <span class="number">0</span>                             <span class="comment">; 调试器用：设置帧指针省略优化（可忽略）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">esi</span>, <span class="built_in">edx</span>                          <span class="comment">; esi → 用户参数地址</span></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">ebx</span>, [<span class="built_in">edi</span>]+SdNumber               <span class="comment">; ebx → 参数长度表地址</span></span><br><span class="line">        <span class="keyword">xor</span>     <span class="built_in">ecx</span>, <span class="built_in">ecx</span></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">cl</span>, <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ebx</span>+<span class="built_in">eax</span>]            <span class="comment">; ecx = 参数长度（单位：字节）</span></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">edi</span>, [<span class="built_in">edi</span>]+SdBase                 <span class="comment">; edi → SSDT 函数表地址</span></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">ebx</span>, [<span class="built_in">edi</span>+<span class="built_in">eax</span>*<span class="number">4</span>]                  <span class="comment">; ebx = 对应服务号的函数地址</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">sub</span>     <span class="built_in">esp</span>, <span class="built_in">ecx</span>                          <span class="comment">; 为参数在内核栈中分配空间</span></span><br><span class="line">        <span class="keyword">shr</span>     <span class="built_in">ecx</span>, <span class="number">2</span>                            <span class="comment">; 将参数字节数转换为 DWORD 数（用于 rep movsd）</span></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">edi</span>, <span class="built_in">esp</span>                          <span class="comment">; edi → 参数目标地址（即内核栈顶）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">cmp</span>     <span class="built_in">esi</span>, _MmUserProbeAddress          <span class="comment">; 检查参数地址是否为用户空间</span></span><br><span class="line">        <span class="keyword">jae</span>     kss80                             <span class="comment">; 如果不是用户地址，跳过复制（已信任）</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">KiSystemServiceCopyArguments:</span></span><br><span class="line">        <span class="keyword">rep</span>     <span class="keyword">movsd</span>                             <span class="comment">; 将用户参数从用户栈复制到内核栈（ecx 个 DWORD）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">; （仅调试版）判断是否需要模拟低资源内存环境，触发内存修剪</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">if DBG</span><br><span class="line">        <span class="keyword">test</span>    _MmInjectUserInpageErrors, <span class="number">2</span></span><br><span class="line">        <span class="keyword">jz</span>      short @f</span><br><span class="line">        stdCall _MmTrimProcessMemory, &lt;<span class="number">0</span>&gt;         <span class="comment">; 主动回收内存</span></span><br><span class="line">        <span class="keyword">jmp</span>     short kssdoit</span><br><span class="line">@@:</span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">eax</span>, PCR[PcPrcbData+PbCurrentThread]</span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">eax</span>]+ThApcState+AsProcess</span><br><span class="line">        <span class="keyword">test</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span>]+PrFlags, <span class="number">0100000h</span> <span class="comment">; 是否为“页错误测试进程”</span></span><br><span class="line">        <span class="keyword">je</span>      short @f</span><br><span class="line">        stdCall _MmTrimProcessMemory, &lt;<span class="number">0</span>&gt;         <span class="comment">; 是 → 进行内存压缩</span></span><br><span class="line">@@:</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">; 正式调用系统服务函数（ebx → 函数地址，参数已在栈上就绪）</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">kssdoit:</span></span><br><span class="line">        <span class="keyword">call</span>    <span class="built_in">ebx</span>                               <span class="comment">; 调用实际的系统服务函数</span></span><br></pre></td></tr></table></figure></div>

<h3 id="返回用户态"><a href="#返回用户态" class="headerlink" title="返回用户态"></a>返回用户态</h3><p>调用完 SSDT 表中对应的函数后就会返回用户态。在返回用户态的过程中会有一些列的检查。</p>
<p>首先会检查 IRQL 等级。如果是来自用户态的系统调用则需要确保当前 IRQL 等级为 0（<code>PASSIVE_LEVEL</code>），否则就跳转到 <code>kss100</code> 调用 <code>KeBugCheck2</code> 蓝屏报错。因为如果 IRQL 大于 0 则意味着当前中断上下文尚未清理完，系统不允许直接返回用户态。</p>
<blockquote>
<p>IRQL（Interrupt Request Level，中断请求级别）是 <strong>Windows 内核中的一种中断优先级机制</strong>，用来 <strong>控制线程调度、中断响应和同步规则</strong>。Windows 内核会根据<strong>IRQL 的高低</strong>，来决定当前 CPU <strong>允许处理哪些中断、调度哪些线程</strong>，以及能否执行某些操作。</p>
<p>常见的 IRQL 等级如下：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>PASSIVE_LEVEL</code></td>
<td>0</td>
<td>普通线程运行级别（几乎所有代码运行在此）</td>
</tr>
<tr>
<td><code>APC_LEVEL</code></td>
<td>1</td>
<td>异步过程调用（APC）处理级别</td>
</tr>
<tr>
<td><code>DISPATCH_LEVEL</code></td>
<td>2</td>
<td>调度相关（如 DPC）运行在此级别</td>
</tr>
<tr>
<td><code>&gt;=3</code> 到 <code>31</code></td>
<td></td>
<td>用于硬件中断服务例程（ISR）处理，不同设备映射到不同级别</td>
</tr>
<tr>
<td><code>HIGH_LEVEL</code></td>
<td>31</td>
<td>系统最高级别（屏蔽所有中断），只允许极少代码运行</td>
</tr>
</tbody></table>
</blockquote>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">kss60:</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">; 检查是否从用户模式（Ring 3）返回时，当前中断级别 IRQL 不为 PASSIVE_LEVEL。</span></span><br><span class="line"><span class="comment">; 如果是这种情况，这是一个严重的逻辑错误，因为系统只能在 PASSIVE_LEVEL（0）</span></span><br><span class="line"><span class="comment">; 时才能安全地返回到用户模式。</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">if DBG</span><br><span class="line"></span><br><span class="line">    <span class="keyword">test</span>    <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>]+TsSegCs, MODE_MASK     <span class="comment">; 检查当前陷阱帧中的 CS 段寄存器</span></span><br><span class="line">                                                  <span class="comment">; 的最低位（MODE_MASK = 1）。</span></span><br><span class="line">                                                  <span class="comment">; 如果结果为 1，表示从用户模式触发中断。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">jz</span>      short kss50b                          <span class="comment">; 如果是 0（来自内核态），跳过后续检查。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">esi</span>, <span class="built_in">eax</span>                              <span class="comment">; 暂存系统调用的返回值。</span></span><br><span class="line"></span><br><span class="line">    CurrentIrql                                   <span class="comment">; 读取当前中断请求级别（IRQL）到 AL。</span></span><br><span class="line">                                                  <span class="comment">; 实际上这是一个宏，会读取 TPR 寄存器</span></span><br><span class="line">                                                  <span class="comment">; 或 CR8（在 x64 上）来获取当前 CPU IRQL。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">or</span>      <span class="built_in">al</span>, <span class="built_in">al</span>                                <span class="comment">; 检查 AL 是否为 0（PASSIVE_LEVEL）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">jnz</span>     kss100                                <span class="comment">; 如果当前 IRQL &gt; 0，则非法：</span></span><br><span class="line">                                                  <span class="comment">; 在高 IRQL 下不能返回到用户态，</span></span><br><span class="line">                                                  <span class="comment">; 跳转到 kss100 执行 KeBugCheck2 报错。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">eax</span>, <span class="built_in">esi</span>                              <span class="comment">; 恢复返回值。</span></span><br></pre></td></tr></table></figure></div>

<p><code>kss100</code> 的蓝屏代码如下：</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">kss100:</span></span><br><span class="line">        <span class="keyword">push</span>    PCR[PcIrql]                 <span class="comment">; 将当前 IRQL 压栈，用作调试用的虚假参数</span></span><br><span class="line"></span><br><span class="line">        ?FpoValue = ?FpoValue + <span class="number">1</span>           <span class="comment">; 更新 FPO（Frame Pointer Omission）帧编号</span></span><br><span class="line"></span><br><span class="line">FPOFRAME ?FpoValue, <span class="number">0</span></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">byte</span> <span class="built_in">ptr</span> PCR[PcIrql], <span class="number">0</span>     <span class="comment">; 重置当前 IRQL，避免递归陷入调试陷阱</span></span><br><span class="line">        <span class="keyword">cli</span>                                 <span class="comment">; 关闭中断，防止调试过程中被打断</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">;</span></span><br><span class="line">        <span class="comment">; 错误：尝试在中断优先级大于 0 的情况下返回到用户模式。</span></span><br><span class="line">        <span class="comment">; 将触发一个严重系统错误 IRQL_GT_ZERO_AT_SYSTEM_SERVICE。</span></span><br><span class="line">        <span class="comment">;</span></span><br><span class="line">        <span class="comment">; KeBugCheck2(</span></span><br><span class="line">        <span class="comment">;     IRQL_GT_ZERO_AT_SYSTEM_SERVICE,     // 错误码</span></span><br><span class="line">        <span class="comment">;     ebx,                                 // 系统调用处理函数地址</span></span><br><span class="line">        <span class="comment">;     eax,                                 // 当前 IRQL</span></span><br><span class="line">        <span class="comment">;     0,</span></span><br><span class="line">        <span class="comment">;     0,</span></span><br><span class="line">        <span class="comment">;     ebp);                                // 陷阱帧地址</span></span><br><span class="line">        <span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        stdCall _KeBugCheck2, &lt;IRQL_GT_ZERO_AT_SYSTEM_SERVICE, <span class="built_in">ebx</span>, <span class="built_in">eax</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">ebp</span>&gt;</span><br></pre></td></tr></table></figure></div>

<p>之后检查当前线程是否处于一种<strong>不允许从内核返回到用户模式的状态</strong>。如果发现：</p>
<ul>
<li><strong>线程附加到其他进程</strong>（如 <code>KeStackAttachProcess</code> 创建的附加上下文）；</li>
<li>或<strong>当前线程禁用了 APC 调度机制</strong>（即禁止内核异步过程调用）。</li>
</ul>
<p>就<strong>直接触发蓝屏（<code>kss120</code>）</strong>，防止继续错误地返回到用户态。</p>
<blockquote>
<p><strong>APC（Asynchronous Procedure Call）</strong> 是 Windows 内核提供的一种机制，允许<strong>内核或用户模式的函数异步地在指定线程上下文中执行</strong>。它分为两种：</p>
<ul>
<li><strong>用户模式 APC</strong>：线程即将从内核返回用户态时，由内核触发挂起的用户 APC 回调函数。</li>
<li><strong>内核模式 APC</strong>：在内核中异步执行某些回调（例如异步 I&#x2F;O 完成通知）。</li>
</ul>
</blockquote>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">;</span></span><br><span class="line">    <span class="comment">; 检查是否禁止了内核 APC，或线程附加到其他进程（如通过 KeStackAttach）</span></span><br><span class="line">    <span class="comment">; 如果存在这类非法状态，不能返回到用户模式，否则将导致系统不稳定。</span></span><br><span class="line">    <span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">ecx</span>, PCR[PcPrcbData+PbCurrentThread]  <span class="comment">; 获取当前处理器控制块中的当前线程指针（_KTHREAD）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">dl</span>, [<span class="built_in">ecx</span>]+ThApcStateIndex             <span class="comment">; 获取 APC 状态索引（用于判断线程是否 attach 到其他进程）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">or</span>      <span class="built_in">dl</span>, <span class="built_in">dl</span>                                <span class="comment">; 判断 APC 状态索引是否为 0</span></span><br><span class="line">    <span class="keyword">jne</span>     kss120                                <span class="comment">; 如果不为 0，说明线程处于 APC attach 状态，跳转执行 bugcheck（蓝屏）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">edx</span>, [<span class="built_in">ecx</span>]+ThCombinedApcDisable       <span class="comment">; 获取 APC 禁止计数器（包括用户和内核 APC）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">or</span>      <span class="built_in">edx</span>, <span class="built_in">edx</span>                              <span class="comment">; 判断是否有 APC 被禁止</span></span><br><span class="line">    <span class="keyword">jne</span>     kss120                                <span class="comment">; 如果禁止 APC，说明不能切回用户态，跳转报错处理</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">kss50b:</span>                                            <span class="comment">; 否则，检查通过，继续执行返回路径</span></span><br></pre></td></tr></table></figure></div>

<p>在 Windows 内核中，<strong>内核 APC（Asynchronous Procedure Call）机制是安全返回用户态的重要保障</strong>。</p>
<ul>
<li><strong>如果 APC 被禁用（ApcDisable !&#x3D; 0）</strong>，而线程又切回用户态，可能导致内核逻辑失效、死锁或内存破坏。</li>
<li><strong>如果线程附加到另一个进程上下文（ApcStateIndex !&#x3D; 0）</strong>，说明该线程逻辑上“借用了”另一个进程的虚拟内存视图。这种情况下强行返回用户态会让线程执行在错误的进程地址空间，<strong>是非常严重的 bug</strong>。</li>
</ul>
<p><code>kss120</code> 蓝屏代码如下：</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">; APC_INDEX_MISMATCH - 尝试从内核态返回到用户态时，发现当前线程处于非法状态：</span></span><br><span class="line"><span class="comment">; 要么是线程附加到了其他进程（KeStackAttachProcess），</span></span><br><span class="line"><span class="comment">; 要么是内核 APC（Asynchronous Procedure Call）被禁用了。</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">; 因此调用 KeBugCheck2 触发蓝屏（BUGCHECK 0x01）。</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">; 参数含义如下：</span></span><br><span class="line"><span class="comment">; KeBugCheck2(</span></span><br><span class="line"><span class="comment">;     APC_INDEX_MISMATCH,       ; bug 检查码：0x00000001</span></span><br><span class="line"><span class="comment">;     ebx,                      ; 系统调用处理函数地址（system routine）</span></span><br><span class="line"><span class="comment">;     eax = Thread-&gt;ApcStateIndex,  ; 当前线程的 APC 状态索引</span></span><br><span class="line"><span class="comment">;     edx = Thread-&gt;CombinedApcDisable, ; 当前线程的 APC 禁用计数器</span></span><br><span class="line"><span class="comment">;     0,                        ; 保留字段</span></span><br><span class="line"><span class="comment">;     ebp = TrapFrame           ; 当前陷阱帧（CPU 上下文）</span></span><br><span class="line"><span class="comment">; )</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">kss120:</span></span><br><span class="line">    <span class="keyword">movzx</span>   <span class="built_in">eax</span>, <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ecx</span>] + ThApcStateIndex</span><br><span class="line">    <span class="comment">; 将线程结构中的 ApcStateIndex 读入 eax（用于判断是否被附加）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">edx</span>, [<span class="built_in">ecx</span>] + ThCombinedApcDisable</span><br><span class="line">    <span class="comment">; 将线程结构中的 CombinedApcDisable 读入 edx（用于判断是否禁用了内核 APC）</span></span><br><span class="line"></span><br><span class="line">    stdCall _KeBugCheck2, &lt;APC_INDEX_MISMATCH, <span class="built_in">ebx</span>, <span class="built_in">eax</span>, <span class="built_in">edx</span>, <span class="number">0</span>, <span class="built_in">ebp</span>&gt;</span><br><span class="line">    <span class="comment">; 调用 KeBugCheck2 函数触发蓝屏，记录详细调试信息</span></span><br></pre></td></tr></table></figure></div>

<p>之后清理堆栈，恢复之前复制参数时抬升的堆栈。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">kss61:</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">; 服务例程返回路径，eax 中为状态码（返回值）。</span></span><br><span class="line"><span class="comment">; 此代码也可能是 KiCallbackReturn 调用失败后的恢复路径。</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">esp</span>, <span class="built_in">ebp</span>                              <span class="comment">; 清理栈空间（恢复服务调用前 ESP）</span></span><br></pre></td></tr></table></figure></div>

<p>之后会从 <code>TRAP_FRAME.Edx</code> 恢复之前的 <code>TRAP_FRAME</code> 到 <code>KTHREAD.TrapFrame</code>，这一步是针对 <code>INT 2E</code> 指令对应的 <code>_KiSystemService</code> 函数进行的。而 <code>SYSENER</code> 指令对应的 <code>_KiFastCallEntry</code> 是直接返回 3 环，因此并不在乎 <code>KTHREAD.TrapFrame</code> 这个字段。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">kss70:</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">; 恢复调用前的 Trap Frame 指针（供线程异常或中断时恢复上下文用）</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">ecx</span>, PCR[PcPrcbData+PbCurrentThread]  <span class="comment">; 获取当前线程地址</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">edx</span>, [<span class="built_in">ebp</span>].TsEdx                      <span class="comment">; 从当前 Trap Frame 中恢复旧 Trap Frame 指针</span></span><br><span class="line">    <span class="keyword">mov</span>     [<span class="built_in">ecx</span>].ThTrapFrame, <span class="built_in">edx</span>                <span class="comment">; 设置回线程的 Trap Frame 域</span></span><br></pre></td></tr></table></figure></div>

<p>之后会检查当前线程是否有挂起的用户 APC</p>
<ul>
<li>若有，则派发用户 APC 并再次检查；</li>
<li>若无，则恢复 Trap Frame 中保存的用户态上下文，安全返回用户空间；</li>
</ul>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">_KiServiceExit proc</span><br><span class="line"></span><br><span class="line">        <span class="keyword">cli</span></span><br><span class="line">        <span class="comment">; 禁用中断，防止上下文恢复过程被中断，保证返回路径一致性。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">test</span>    <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span> + KTRAP_FRAME<span class="number">.</span>EFlags + <span class="number">2</span>], <span class="number">2</span></span><br><span class="line">        <span class="comment">; 检查 TrapFrame-&gt;EFlags.VM 位（bit 17），判断是否从 V86 模式返回。</span></span><br><span class="line">        <span class="comment">; 如果是，则跳过普通用户态/内核态判断，直接处理 V86 相关逻辑。</span></span><br><span class="line">        <span class="keyword">jnz</span>     CheckApc</span><br><span class="line"></span><br><span class="line">        <span class="keyword">test</span>    <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span> + KTRAP_FRAME<span class="number">.</span>SegCs], <span class="number">1</span></span><br><span class="line">        <span class="comment">; 检查 CS 段选择子的最低位 RPL 是否为 1（用户态为 3，内核为 0）。</span></span><br><span class="line">        <span class="comment">; 如果当前不来自用户模式，说明为嵌套系统调用返回，直接跳到恢复路径。</span></span><br><span class="line">        <span class="keyword">jz</span>      ExitToUser</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">CheckApc:</span></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">ebx</span>, <span class="built_in">fs</span>:KPCR<span class="number">.</span>PrcbData<span class="number">.</span>CurrentThread</span><br><span class="line">        <span class="comment">; 获取当前线程 ETHREAD 指针，用于读取调度与 APC 状态字段。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">test</span>    [<span class="built_in">ebx</span> + KTHREAD<span class="number">.</span>Header<span class="number">.</span>ThreadControlFlags], <span class="number">2</span></span><br><span class="line">        <span class="comment">; 检查线程控制标志（ThreadControlFlags），是否启用了计数器跟踪（bit 1）。</span></span><br><span class="line">        <span class="comment">; 如果开启，则需要调用 KiCopyCounters() 更新统计信息。</span></span><br><span class="line">        <span class="keyword">jz</span>      SkipCounters</span><br><span class="line"></span><br><span class="line">        <span class="keyword">push</span>    <span class="built_in">eax</span></span><br><span class="line">        <span class="keyword">push</span>    <span class="built_in">ebx</span></span><br><span class="line">        <span class="keyword">call</span>    _KiCopyCounters@<span class="number">4</span></span><br><span class="line">        <span class="keyword">pop</span>     <span class="built_in">eax</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">SkipCounters:</span></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ebx</span> + KTHREAD<span class="number">.</span>Alerted], <span class="number">0</span></span><br><span class="line">        <span class="comment">; 清除线程的 Alerted 标志位，表示本次线程已完成 APC 检查。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">cmp</span>     <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ebx</span> + KTHREAD<span class="number">.</span>ApcState<span class="number">.</span>UserApcPending], <span class="number">0</span></span><br><span class="line">        <span class="comment">; 检查 ApcState 中的 UserApcPending 标志是否为真。</span></span><br><span class="line">        <span class="comment">; 如果有用户态 APC 挂起，则需要先执行它们。</span></span><br><span class="line">        <span class="keyword">jz</span>      ExitToUser</span><br><span class="line"></span><br><span class="line">        <span class="comment">; 以下准备恢复 Trap Frame 并执行 APC 调度逻辑</span></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">ebx</span>, <span class="built_in">ebp</span></span><br><span class="line">        <span class="keyword">mov</span>     [<span class="built_in">ebx</span> + KTRAP_FRAME<span class="number">.</span><span class="built_in">Eax</span>], <span class="built_in">eax</span></span><br><span class="line">        <span class="comment">; 将当前系统调用返回值 EAX 保存回 Trap Frame，防止 APC 覆盖。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">; 设置 FS/DS/ES 为用户段，模拟从 Ring3 返回。</span></span><br><span class="line">        <span class="keyword">mov</span>     [<span class="built_in">ebx</span> + KTRAP_FRAME<span class="number">.</span>SegFs], KGDT_R3_TEB | RPL_MASK</span><br><span class="line">        <span class="keyword">mov</span>     [<span class="built_in">ebx</span> + KTRAP_FRAME<span class="number">.</span>SegDs], KGDT_R3_DATA | RPL_MASK</span><br><span class="line">        <span class="keyword">mov</span>     [<span class="built_in">ebx</span> + KTRAP_FRAME<span class="number">.</span>SegEs], KGDT_R3_DATA | RPL_MASK</span><br><span class="line">        <span class="keyword">mov</span>     [<span class="built_in">ebx</span> + KTRAP_FRAME<span class="number">.</span>SegGs], <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">ecx</span>, APC_LEVEL</span><br><span class="line">        <span class="keyword">call</span>    <span class="built_in">ds</span>:__imp_@KfRaiseIrql@<span class="number">4</span></span><br><span class="line">        <span class="comment">; 提升 IRQL 至 APC_LEVEL，以屏蔽普通中断，保障 APC 派发的原子性。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">push</span>    <span class="built_in">eax</span></span><br><span class="line">        <span class="keyword">sti</span></span><br><span class="line">        <span class="comment">; 允许中断再次开启，使得内核 APC 能正常派发。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">push</span>    <span class="built_in">ebx</span>    <span class="comment">; TrapFrame</span></span><br><span class="line">        <span class="keyword">push</span>    <span class="number">0</span>      <span class="comment">; kexcep_frame = NULL</span></span><br><span class="line">        <span class="keyword">push</span>    <span class="number">1</span>      <span class="comment">; PreviousMode = UserMode</span></span><br><span class="line">        <span class="keyword">call</span>    _KiDeliverApc@<span class="number">12</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">pop</span>     <span class="built_in">ecx</span></span><br><span class="line">        <span class="keyword">call</span>    <span class="built_in">ds</span>:__imp_@KfLowerIrql@<span class="number">4</span></span><br><span class="line">        <span class="comment">; 恢复原始 IRQL，重回调度点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">ebx</span> + KTRAP_FRAME<span class="number">.</span><span class="built_in">Eax</span>]</span><br><span class="line">        <span class="comment">; 恢复 EAX 寄存器的系统调用返回值。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">cli</span></span><br><span class="line">        <span class="keyword">jmp</span>     CheckApc</span><br><span class="line">        <span class="comment">; 再次检查是否有新 APC 被挂起（可能派发时新到达）。</span></span><br></pre></td></tr></table></figure></div>

<p>在之后会恢复线程的 <code>ExceptionList</code>，<code>PreviousMode</code> 以及调试寄存器。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ExitToUser:</span></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">edx</span>, [<span class="built_in">esp</span> + KTRAP_FRAME<span class="number">.</span>ExceptionList]</span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">fs</span>:KPCR<span class="number">.</span>NtTib<span class="number">.</span>ExceptionList, <span class="built_in">edx</span></span><br><span class="line">        <span class="comment">; 恢复线程的 ExceptionList，确保 SEH 正常工作。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">ecx</span>, [<span class="built_in">esp</span> + KTRAP_FRAME<span class="number">.</span>PreviousPreviousMode]</span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">esi</span>, <span class="built_in">fs</span>:KPCR<span class="number">.</span>PrcbData<span class="number">.</span>CurrentThread</span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span> + KTHREAD<span class="number">.</span>PreviousMode], <span class="built_in">cl</span></span><br><span class="line">        <span class="comment">; 恢复线程的 PreviousMode 标志，标识系统调用返回来源。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">test</span>    [<span class="built_in">esp</span> + KTRAP_FRAME<span class="number">.</span>Dr7], <span class="number">0FFFF23FFh</span></span><br><span class="line">        <span class="comment">; 判断是否设置了调试寄存器（调试上下文需恢复）。</span></span><br><span class="line">        <span class="keyword">jnz</span>     RestoreDebugRegisters</span><br></pre></td></tr></table></figure></div>

<p><code>RestoreDebugRegisters</code> 就是把 <code>TRAP_FRAME</code> 中的调试寄存器恢复到寄存器中。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; -------------------- 恢复调试寄存器 --------------------</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">RestoreDebugRegisters:</span></span><br><span class="line">        <span class="keyword">xor</span>     <span class="built_in">ebx</span>, <span class="built_in">ebx</span></span><br><span class="line">        <span class="comment">; 清空 ebx 用于临时寄存器。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">esi</span>, [<span class="built_in">ebp</span> + KTRAP_FRAME<span class="number">.</span><span class="built_in">Dr0</span>]</span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">edi</span>, [<span class="built_in">ebp</span> + KTRAP_FRAME<span class="number">.</span><span class="built_in">Dr1</span>]</span><br><span class="line">        <span class="keyword">mov</span>     dr7, <span class="built_in">ebx</span></span><br><span class="line">        <span class="comment">; 清除调试使能标志（防止中间值触发调试异常）。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">dr0</span>, <span class="built_in">esi</span></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">ebx</span>, [<span class="built_in">ebp</span> + KTRAP_FRAME<span class="number">.</span><span class="built_in">Dr2</span>]</span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">dr1</span>, <span class="built_in">edi</span></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">dr2</span>, <span class="built_in">ebx</span></span><br><span class="line">        <span class="comment">; 恢复 dr0 ~ dr2（断点地址寄存器）。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">esi</span>, [<span class="built_in">ebp</span> + KTRAP_FRAME<span class="number">.</span><span class="built_in">Dr3</span>]</span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">edi</span>, [<span class="built_in">ebp</span> + KTRAP_FRAME<span class="number">.</span>Dr6]</span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">ebx</span>, [<span class="built_in">ebp</span> + KTRAP_FRAME<span class="number">.</span>Dr7]</span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">dr3</span>, <span class="built_in">esi</span></span><br><span class="line">        <span class="keyword">mov</span>     dr6, <span class="built_in">edi</span></span><br><span class="line">        <span class="keyword">mov</span>     dr7, <span class="built_in">ebx</span></span><br><span class="line">        <span class="comment">; 恢复 dr3、dr6、dr7，完成调试状态恢复。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">jmp</span>     ContinueReturn</span><br><span class="line">        <span class="comment">; 跳回系统调用返回路径。</span></span><br></pre></td></tr></table></figure></div>

<p>最后就是根据调用者的状态分别调转到不同的返回逻辑中。如果是返回 3 环是通过 <code>iretd</code> 指令返回。这是因为内核在返回用户态的时候不清楚当初系统调用是通过 <code>sysenter</code> 还是 <code>int 2E</code> 完成的。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ContinueReturn:</span></span><br><span class="line">        <span class="keyword">test</span>    [<span class="built_in">esp</span> + KTRAP_FRAME<span class="number">.</span>EFlags], EFLAGS_V86_MASK</span><br><span class="line">        <span class="comment">; 判断是否为 V86 模式返回。</span></span><br><span class="line">        <span class="keyword">jnz</span>     V86Return</span><br><span class="line"></span><br><span class="line">        <span class="keyword">test</span>    <span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">esp</span> + KTRAP_FRAME<span class="number">.</span>SegCs], <span class="number">0FFF8h</span></span><br><span class="line">        <span class="comment">; 检查 CS 段选择子是否合法（是否为 NULL 段选择子）。</span></span><br><span class="line">        <span class="comment">; 如果为 NULL（0x0000），说明 Trap Frame 不可靠，构造伪栈进行返回。</span></span><br><span class="line">        <span class="keyword">jz</span>      V86ReturnFromNullCs</span><br><span class="line"></span><br><span class="line">        <span class="keyword">cmp</span>     <span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">esp</span> + KTRAP_FRAME<span class="number">.</span>SegCs], KGDT_R3_CODE | RPL_MASK</span><br><span class="line">        <span class="comment">; 检查段值是否为用户态代码段（0x1B）</span></span><br><span class="line">        <span class="keyword">bt</span>      <span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">esp</span> + KTRAP_FRAME<span class="number">.</span>SegCs], <span class="number">0</span></span><br><span class="line">        <span class="keyword">cmc</span></span><br><span class="line">        <span class="keyword">ja</span>      KernelReturnFallback</span><br><span class="line"></span><br><span class="line">        <span class="keyword">cmp</span>     <span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span> + KTRAP_FRAME<span class="number">.</span>SegCs], KGDT_R0_CODE</span><br><span class="line">        <span class="keyword">jz</span>      SkipSegmentRestore</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">SkipSegmentRestoreWithFS:</span></span><br><span class="line">        <span class="keyword">lea</span>     <span class="built_in">esp</span>, [<span class="built_in">ebp</span> + KTRAP_FRAME<span class="number">.</span>SegFs]</span><br><span class="line">        <span class="keyword">pop</span>     <span class="built_in">fs</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">SkipSegmentRestore:</span></span><br><span class="line">        <span class="keyword">lea</span>     <span class="built_in">esp</span>, [<span class="built_in">ebp</span> + KTRAP_FRAME<span class="number">.</span><span class="built_in">Edi</span>]</span><br><span class="line">        <span class="keyword">pop</span>     <span class="built_in">edi</span></span><br><span class="line">        <span class="keyword">pop</span>     <span class="built_in">esi</span></span><br><span class="line">        <span class="keyword">pop</span>     <span class="built_in">ebx</span></span><br><span class="line">        <span class="keyword">pop</span>     <span class="built_in">ebp</span></span><br><span class="line">        <span class="comment">; 恢复非易变寄存器。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">cmp</span>     <span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">esp</span> + <span class="number">8</span>], <span class="number">80h</span></span><br><span class="line">        <span class="comment">; 判断是否为 V86 模式的段。</span></span><br><span class="line">        <span class="keyword">ja</span>      V86Fixup</span><br><span class="line"></span><br><span class="line">        <span class="keyword">add</span>     <span class="built_in">esp</span>, <span class="number">4</span></span><br><span class="line">        <span class="keyword">test</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esp</span> + <span class="number">4</span>], MODE_MASK</span><br><span class="line">        <span class="comment">; 判断是否返回至用户态。</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">KiSystemCallExitBranch:</span></span><br><span class="line">        <span class="keyword">jnz</span>     KiSystemCallExit</span><br><span class="line">        <span class="comment">; 如果 Trap Frame 中指示目标是用户态（EFLAGS 中 MODE_MASK 为真），则跳转至用户态返回逻辑。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">pop</span>     <span class="built_in">edx</span>   <span class="comment">; EIP</span></span><br><span class="line">        <span class="keyword">pop</span>     <span class="built_in">ecx</span>   <span class="comment">; CS</span></span><br><span class="line">        <span class="keyword">popfd</span>         <span class="comment">; EFLAGS</span></span><br><span class="line">        <span class="keyword">jmp</span>     <span class="built_in">edx</span></span><br><span class="line">        <span class="comment">; 否则（内核态），弹出 EIP/CS/EFLAGS，并跳转至返回地址（edx）。</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">KiSystemCallExit:</span></span><br><span class="line">        <span class="keyword">iretd</span></span><br><span class="line">        <span class="comment">; 使用 IRETD 返回用户空间，恢复 EIP、CS 和 EFLAGS。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; -------------------- V86 模式：段为 NULL 时的特殊返回 --------------------</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">V86ReturnFromNullCs:</span></span><br><span class="line">        <span class="keyword">movzx</span>   <span class="built_in">ebx</span>, [<span class="built_in">esp</span> + KTRAP_FRAME<span class="number">.</span>TempSegCs]</span><br><span class="line">        <span class="keyword">mov</span>     [<span class="built_in">esp</span> + KTRAP_FRAME<span class="number">.</span>SegCs], <span class="built_in">ebx</span></span><br><span class="line">        <span class="comment">; 使用保存的临时段选择符 TempSegCs 修复 SegCs 字段。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">ebx</span>, [<span class="built_in">esp</span> + KTRAP_FRAME<span class="number">.</span>TempEsp]</span><br><span class="line">        <span class="keyword">sub</span>     <span class="built_in">ebx</span>, <span class="number">0Ch</span></span><br><span class="line">        <span class="comment">; 为伪造的 IRET 栈帧分配空间。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">mov</span>     [<span class="built_in">esp</span> + KTRAP_FRAME<span class="number">.</span>ErrCode], <span class="built_in">ebx</span></span><br><span class="line">        <span class="comment">; 暂存 ErrorCode 位置，作为 IRET 的栈基地址。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">esi</span>, [<span class="built_in">esp</span> + KTRAP_FRAME<span class="number">.</span>EFlags]</span><br><span class="line">        <span class="keyword">mov</span>     [<span class="built_in">ebx</span> + <span class="number">8</span>], <span class="built_in">esi</span></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">esi</span>, [<span class="built_in">esp</span> + KTRAP_FRAME<span class="number">.</span>SegCs]</span><br><span class="line">        <span class="keyword">mov</span>     [<span class="built_in">ebx</span> + <span class="number">4</span>], <span class="built_in">esi</span></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">esi</span>, [<span class="built_in">esp</span> + KTRAP_FRAME<span class="number">.</span><span class="built_in">Eip</span>]</span><br><span class="line">        <span class="keyword">mov</span>     [<span class="built_in">ebx</span>], <span class="built_in">esi</span></span><br><span class="line">        <span class="comment">; 构造仿真的用户栈帧（三元组：EIP, CS, EFLAGS）。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">add</span>     <span class="built_in">esp</span>, <span class="number">54h</span></span><br><span class="line">        <span class="comment">; 跳过 Trap Frame 内容。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">pop</span>     <span class="built_in">edi</span></span><br><span class="line">        <span class="keyword">pop</span>     <span class="built_in">esi</span></span><br><span class="line">        <span class="keyword">pop</span>     <span class="built_in">ebx</span></span><br><span class="line">        <span class="keyword">pop</span>     <span class="built_in">ebp</span></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">esp</span>, [<span class="built_in">esp</span>]</span><br><span class="line">        <span class="comment">; 将 esp 设置为仿真堆栈的指针。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">iret</span></span><br><span class="line">        <span class="comment">; 使用构造的用户空间 IRET 栈帧返回。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; -------------------- V86 模式常规返回 --------------------</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">V86Return:</span></span><br><span class="line">        <span class="keyword">add</span>     <span class="built_in">esp</span>, <span class="number">3Ch</span></span><br><span class="line">        <span class="comment">; 跳过大部分 Trap Frame 区域。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">pop</span>     <span class="built_in">edx</span></span><br><span class="line">        <span class="keyword">pop</span>     <span class="built_in">ecx</span></span><br><span class="line">        <span class="keyword">pop</span>     <span class="built_in">eax</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">lea</span>     <span class="built_in">esp</span>, [<span class="built_in">ebp</span> + <span class="number">54h</span>]</span><br><span class="line">        <span class="comment">; 定位到栈顶尾部（除 Trap Frame 之外的保存区）。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">pop</span>     <span class="built_in">edi</span></span><br><span class="line">        <span class="keyword">pop</span>     <span class="built_in">esi</span></span><br><span class="line">        <span class="keyword">pop</span>     <span class="built_in">ebx</span></span><br><span class="line">        <span class="keyword">pop</span>     <span class="built_in">ebp</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">cmp</span>     <span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">esp</span> + <span class="number">8</span>], <span class="number">80h</span></span><br><span class="line">        <span class="comment">; 检查 CS 是否属于虚拟 8086 模式段范围（如 0xF8xx）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">ja</span>      V86Fixup</span><br><span class="line">        <span class="comment">; 若是异常段值，进入修复逻辑。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">add</span>     <span class="built_in">esp</span>, <span class="number">4</span></span><br><span class="line">        <span class="comment">; 正常补齐 ExceptionCode 槽位。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">iret</span></span><br><span class="line">        <span class="comment">; 执行返回。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; -------------------- 修复非法虚拟 8086 模式堆栈 --------------------</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">V86Fixup:</span></span><br><span class="line">        <span class="keyword">cmp</span>     <span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">esp</span> + <span class="number">2</span>], <span class="number">0</span></span><br><span class="line">        <span class="keyword">jz</span>      short V86PostFixup</span><br><span class="line">        <span class="comment">; 高 16 位为 0，直接跳过</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">cmp</span>     <span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">esp</span>], <span class="number">0</span></span><br><span class="line">        <span class="keyword">jnz</span>     short V86PostFixup</span><br><span class="line">        <span class="comment">; 低 16 位为非 0，说明 SS = 0x0000F8，合法，跳过</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">shr</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esp</span>], <span class="number">10h</span></span><br><span class="line">        <span class="comment">; 提取 SS 段值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">esp</span> + <span class="number">2</span>], <span class="number">0F8h</span></span><br><span class="line">        <span class="comment">; 构造合规 SS = 0x00F8 段</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">lss</span>     <span class="built_in">sp</span>, [<span class="built_in">esp</span>]</span><br><span class="line">        <span class="comment">; 加载 SS:SP 到当前栈</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">movzx</span>   <span class="built_in">esp</span>, <span class="built_in">sp</span></span><br><span class="line">        <span class="comment">; 移除高位扩展，确保 esp 为栈指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">iret</span></span><br><span class="line">        <span class="comment">; 执行返回</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">V86PostFixup:</span></span><br><span class="line">        <span class="keyword">iret</span></span><br><span class="line">        <span class="comment">; 修复完成后正常返回</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; -------------------- 内核调用返回路径（不恢复 FS） --------------------</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">KernelReturnFallback:</span></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">esp</span> + KTRAP_FRAME<span class="number">.</span><span class="built_in">Eax</span>]</span><br><span class="line">        <span class="comment">; 恢复返回值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">add</span>     <span class="built_in">esp</span>, <span class="number">30h</span></span><br><span class="line">        <span class="comment">; 跳过部分 Trap Frame 内容（Segment 寄存器及异常处理信息）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">pop</span>     <span class="built_in">gs</span></span><br><span class="line">        <span class="keyword">pop</span>     <span class="built_in">es</span></span><br><span class="line">        <span class="keyword">pop</span>     <span class="built_in">ds</span></span><br><span class="line">        <span class="keyword">pop</span>     <span class="built_in">edx</span></span><br><span class="line">        <span class="keyword">pop</span>     <span class="built_in">ecx</span></span><br><span class="line">        <span class="comment">; 恢复其他寄存器状态</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">jmp</span>     SkipSegmentRestoreWithFS</span><br><span class="line">        <span class="comment">; 跳至跳过 FS 的恢复逻辑</span></span><br><span class="line"></span><br><span class="line">_KiServiceExit endp</span><br></pre></td></tr></table></figure></div>

<h2 id="KiSystemService（INT-2E）"><a href="#KiSystemService（INT-2E）" class="headerlink" title="KiSystemService（INT 2E）"></a>KiSystemService（INT 2E）</h2><p><code>INT 2E</code> 是旧式的系统调用方式，进入内核态后会跳转到 <code>_KiSystemService</code>。另外很多内核态的函数实际上也是通过调用 <code>_KiSystemService</code> 实现的。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>在内核中，<code>Zw*</code> 函数和 <code>Nt*</code> 函数在功能上是一致的，但是 <code>Zw*</code> 函数会经过 SSDT 表，因此效率低且会被一些 SSDT 相关的 Hook 监控。</p>

    </div>
  </div>

<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; NTSTATUS __stdcall ZwOpenProcess(</span></span><br><span class="line"><span class="comment">;     OUT PHANDLE ProcessHandle,</span></span><br><span class="line"><span class="comment">;     IN ACCESS_MASK DesiredAccess,</span></span><br><span class="line"><span class="comment">;     IN POBJECT_ATTRIBUTES ObjectAttributes,</span></span><br><span class="line"><span class="comment">;     IN PCLIENT_ID ClientId</span></span><br><span class="line"><span class="comment">; )</span></span><br><span class="line"></span><br><span class="line"><span class="meta">public</span> _ZwOpenProcess@<span class="number">16</span></span><br><span class="line">_ZwOpenProcess@<span class="number">16</span> proc <span class="built_in">near</span>             <span class="comment">; Zw 函数在 ntdll 或内核中的封装</span></span><br><span class="line"></span><br><span class="line">ProcessHandle    = <span class="built_in">dword</span> <span class="built_in">ptr</span>  <span class="number">4</span>         <span class="comment">; 第 1 个参数：返回句柄</span></span><br><span class="line">DesiredAccess    = <span class="built_in">dword</span> <span class="built_in">ptr</span>  <span class="number">8</span>         <span class="comment">; 第 2 个参数：访问权限</span></span><br><span class="line">ObjectAttributes = <span class="built_in">dword</span> <span class="built_in">ptr</span>  <span class="number">0Ch</span>       <span class="comment">; 第 3 个参数：对象属性指针</span></span><br><span class="line">ClientId         = <span class="built_in">dword</span> <span class="built_in">ptr</span>  <span class="number">10h</span>       <span class="comment">; 第 4 个参数：客户端 ID 指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; --- 设置系统调用号 ---</span></span><br><span class="line"><span class="keyword">mov</span>     <span class="built_in">eax</span>, <span class="number">0BEh</span>                       <span class="comment">; EAX = 0xBE，系统调用号，代表 ZwOpenProcess</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; --- 设置参数地址 ---</span></span><br><span class="line"><span class="keyword">lea</span>     <span class="built_in">edx</span>, [<span class="built_in">esp</span>+ProcessHandle]        <span class="comment">; EDX = 参数地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; --- 模拟 INT 调用 ---</span></span><br><span class="line"><span class="keyword">pushf</span>                                  <span class="comment">; 模拟 INT 会自动压入的 EFLAGS</span></span><br><span class="line"><span class="keyword">push</span>    <span class="number">8</span>                              <span class="comment">; 模拟 INT 会自动压入的 CS = 0x8（KGDT_R0_CODE，ring 0 代码段选择子）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; --- 调用内核系统调用入口 ---</span></span><br><span class="line"><span class="keyword">call</span>    _KiSystemService               <span class="comment">; 实际执行系统调用，这里还会压入一个 EIP 构成完整的 INT 指令的压栈行为</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; --- 函数返回 ---</span></span><br><span class="line"><span class="keyword">retn</span>    <span class="number">10h</span>                            <span class="comment">; 平衡堆栈：4 个参数 × 4 字节 = 0x10</span></span><br><span class="line">_ZwOpenProcess@<span class="number">16</span> endp</span><br></pre></td></tr></table></figure></div>

<p><code>_KiSystemService</code> 实现比 <code>_KiFastCallEntry</code> 要简洁一些，主要过程是先调用 <code>ENTER_SYSCALL</code> 宏构造 <code>TRAP_FRAME</code> 结构，之后跳转到 <code>_KiFastCallEntry</code> 的 <code>_KiSystemServiceRepeat</code> 调用 SSDT 表中的处理函数然后返回。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">; 通用系统服务入口点（由 INT 2E 调用）</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">PUBLIC</span>  _KiSystemService</span><br><span class="line">_KiSystemService        proc</span><br><span class="line"></span><br><span class="line">        ENTER_SYSCALL   kss_a, kss_t    <span class="comment">; 构造 Trap Frame、保存寄存器状态</span></span><br><span class="line">                                        <span class="comment">; - 保存 EBP/EBX/ESI/EDI/FS</span></span><br><span class="line">                                        <span class="comment">; - 设置当前线程的 TrapFrame 指针</span></span><br><span class="line">                                        <span class="comment">; - 保存 ExceptionList / PreviousMode</span></span><br><span class="line">                                        <span class="comment">; - 设置 FS = 内核 PCR</span></span><br><span class="line">                                        <span class="comment">; - 清空方向位 CLD</span></span><br><span class="line">                                        <span class="comment">; - 开启中断 STI</span></span><br><span class="line">                                        <span class="comment">; 如果启用调试，还会处理调试上下文</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">jmp</span>     _KiSystemServiceRepeat  <span class="comment">; 跳转到通用服务分发处理逻辑</span></span><br><span class="line"></span><br><span class="line">_KiSystemService endp</span><br></pre></td></tr></table></figure></div>

<p>由于对于 <code>SYSENTER</code> 指令 CPU 什么都没压，并且还跑在 per-CPU DPC Stack；内核 prolog 必须<strong>自己构造 IRET Frame、手动换到线程栈，再建完整 TrapFrame</strong>，因而步骤更多、字段也多预留了 NPX 区。</p>
<p>而对于 <code>INT 2E</code> 指令，CPU 已经帮忙切栈、压返回态；内核 prolog 只需<strong>微调</strong>——改 FS、存非易失寄存器、挂 TrapFrame。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;++</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">;   ENTER_SYSCALL       AssistLabel, TargetLabel, NoFSLoad, RejectVdmLabel, SaveEcx</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">;   宏功能说明：</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">;       构造系统调用（syscall）进入时的 Trap Frame，并设置必要的寄存器。</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">;       会保存的内容：</span></span><br><span class="line"><span class="comment">;           - 错误码填充（Errorpad，占位）</span></span><br><span class="line"><span class="comment">;           - 非易失性寄存器（EBP、EBX、ESI、EDI）</span></span><br><span class="line"><span class="comment">;           - FS 段寄存器</span></span><br><span class="line"><span class="comment">;           - ExceptionList（异常处理链）</span></span><br><span class="line"><span class="comment">;           - PreviousMode（线程的先前 CPU 模式）</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">;       不会保存：</span></span><br><span class="line"><span class="comment">;           - 易失性寄存器（EAX、ECX、EDX）</span></span><br><span class="line"><span class="comment">;           - 段寄存器（除了 FS）</span></span><br><span class="line"><span class="comment">;           - 浮点状态</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">;       会设置：</span></span><br><span class="line"><span class="comment">;           - FS 寄存器</span></span><br><span class="line"><span class="comment">;           - ExceptionList</span></span><br><span class="line"><span class="comment">;           - PreviousMode</span></span><br><span class="line"><span class="comment">;           - 清除方向标志位（cld）</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">;   参数说明：</span></span><br><span class="line"><span class="comment">;       AssistLabel - 用于调试的标签，会跳到调试辅助代码（如果调试启用）</span></span><br><span class="line"><span class="comment">;       TargetLabel - 系统调用入口处的目标标签</span></span><br><span class="line"><span class="comment">;       NoFSLoad    - 若指定则不修改 FS，默认会设置 FS=KGDT_R0_PCR</span></span><br><span class="line"><span class="comment">;       SaveEcx     - 若指定则会额外保存 ECX 到 Trap Frame 中</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">;   出口状态：</span></span><br><span class="line"><span class="comment">;       - 不改变中断状态（与进入前一致）</span></span><br><span class="line"><span class="comment">;       - ESP 和 EBP 都指向新的 Trap Frame</span></span><br><span class="line"><span class="comment">;       - 保持入口时的 EAX 和 EDX 不变</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">;   注意事项：</span></span><br><span class="line"><span class="comment">;       - 若去除了 DS: 引用，需要明确加上段前缀覆盖</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">;--</span></span><br><span class="line"></span><br><span class="line">ENTER_SYSCALL macro AssistLabel, TargetLabel, NoFSLoad, RejectVdmLabel, SaveEcx</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">.FPO</span> ( FPO_LOCALS, FPO_PARAMS, FPO_PROLOG, FPO_REGS, FPO_USE_EBP, FPO_TRAPFRAME )</span><br><span class="line"></span><br><span class="line">ifdef KERNELONLY</span><br><span class="line"></span><br><span class="line"><span class="comment">; ========== 开始构造 Trap Frame ==========</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">push</span>    <span class="number">0</span>                       <span class="comment">; 占位，作为 error code pad</span></span><br><span class="line">        <span class="keyword">push</span>    <span class="built_in">ebp</span>                     <span class="comment">; 保存非易失寄存器</span></span><br><span class="line">        <span class="keyword">push</span>    <span class="built_in">ebx</span></span><br><span class="line">        <span class="keyword">push</span>    <span class="built_in">esi</span></span><br><span class="line">        <span class="keyword">push</span>    <span class="built_in">edi</span></span><br><span class="line"></span><br><span class="line">ifb &lt;NoFSLoad&gt;</span><br><span class="line">        <span class="keyword">push</span>    <span class="built_in">fs</span>                      <span class="comment">; 保存 FS 寄存器，并设置为指向内核 PCR</span></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">ebx</span>, KGDT_R0_PCR        <span class="comment">; 加载内核全局描述符表中 PCR 段号</span></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">fs</span>, <span class="built_in">bx</span></span><br><span class="line">else</span><br><span class="line">        <span class="comment">; 如果使用 fast system call 进入，FS 已经设为内核 PCR，不需重复设置</span></span><br><span class="line">        <span class="keyword">push</span>    KGDT_R3_TEB <span class="keyword">OR</span> RPL_MASK <span class="comment">; 直接压入用户态 TEB 段值（用于返回）</span></span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">esi</span>, PCR[PcPrcbData+PbCurrentThread] <span class="comment">; 获取当前线程结构指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; -------- 保存异常处理链并初始化为空 --------</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">push</span>    PCR[PcExceptionList]    <span class="comment">; 保存旧的 ExceptionList</span></span><br><span class="line">        <span class="keyword">mov</span>     PCR[PcExceptionList], EXCEPTION_CHAIN_END <span class="comment">; 清空异常处理链</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; -------- 保存 PreviousMode 并更新为当前调用者的模式 --------</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">push</span>    [<span class="built_in">esi</span>]+ThPreviousMode    <span class="comment">; 保存线程的旧 PreviousMode</span></span><br><span class="line">        <span class="keyword">sub</span>     <span class="built_in">esp</span>, TsPreviousPreviousMode <span class="comment">; 为 Trap Frame 分配剩余空间</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">ebx</span>, [<span class="built_in">esp</span>+TsSegCS]      <span class="comment">; 取调用者的 CS 段寄存器</span></span><br><span class="line">        <span class="keyword">and</span>     <span class="built_in">ebx</span>, MODE_MASK          <span class="comment">; 提取最低位判断是否为用户模式</span></span><br><span class="line">        <span class="keyword">mov</span>     [<span class="built_in">esi</span>]+ThPreviousMode, <span class="built_in">bl</span> <span class="comment">; 更新线程中的 PreviousMode 字段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; -------- 设置新的 Trap Frame 地址并保存旧 Trap Frame 指针 --------</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">ebp</span>, <span class="built_in">esp</span>                <span class="comment">; 设置当前 Trap Frame 基址</span></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">ebx</span>, [<span class="built_in">esi</span>].ThTrapFrame  <span class="comment">; 获取线程中原 Trap Frame 指针</span></span><br><span class="line">        <span class="keyword">mov</span>     [<span class="built_in">ebp</span>].TsEdx, <span class="built_in">ebx</span>        <span class="comment">; 写入 Trap Frame 中的 .Edx 字段，表示“旧 Trap Frame”</span></span><br><span class="line"></span><br><span class="line">ifnb &lt;SaveEcx&gt;</span><br><span class="line">        <span class="keyword">mov</span>     [<span class="built_in">ebp</span>].TsEcx, <span class="built_in">ecx</span>        <span class="comment">; 如果要求保存 ECX，则写入 Trap Frame</span></span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">        <span class="keyword">and</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>].TsDr7, <span class="number">0</span> <span class="comment">; 清空调试寄存器标志</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">test</span>    <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>].ThDebugActive, <span class="number">0FFh</span> <span class="comment">; 若线程启用了调试</span></span><br><span class="line">        <span class="keyword">mov</span>     [<span class="built_in">esi</span>].ThTrapFrame, <span class="built_in">ebp</span>  <span class="comment">; 将新的 Trap Frame 设置到线程结构中</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">cld</span>                             <span class="comment">; 清除方向标志（确保字符串操作前向）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">jnz</span>     Dr_&amp;AssistLabel         <span class="comment">; 若启用调试，跳转到调试处理分支</span></span><br><span class="line"></span><br><span class="line">Dr_&amp;TargetLabel:                        <span class="comment">; 调用系统服务的正式入口标签</span></span><br><span class="line"></span><br><span class="line">        SET_DEBUG_DATA                  <span class="comment">; 设置调试数据（此宏可能破坏 EDI）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">sti</span>                             <span class="comment">; 恢复中断允许状态</span></span><br><span class="line"></span><br><span class="line">else</span><br><span class="line">        %out    ENTER_SYSCAL outside of kernel</span><br><span class="line"><span class="meta">        .err</span></span><br><span class="line">endif</span><br><span class="line">        endm</span><br></pre></td></tr></table></figure></div>

<p><code>_KiSystemService</code> 的 <code>ENTER_SYSCALL</code> 在构造 <code>TRAP_FRAME</code> 时主要有如下不同点：</p>
<ul>
<li><p><strong>栈切换与返回帧构造</strong>：</p>
<ul>
<li><strong>_KiSystemService（INT 2E）</strong> ：CPU 在执行 <code>INT 2E</code> 指令的时候已经完成了栈切换，并且压了 <code>EIP/CS/EFLAGS/SS/ESP</code> 因此直接从 <code>ErrCode</code> 开始构造。</li>
<li><strong>_KiFastCallEntry（SYSENTER）</strong> ：MSR 指定的是 <strong>DPC Stack</strong>（per-CPU）；所以内核需要先切换内核堆栈，然后再在那里建“伪 IRET 帧”。</li>
</ul>
</li>
<li><p><strong>PreviousMode 判定逻辑</strong>：</p>
<ul>
<li><strong>_KiSystemService（INT 2E）</strong> ：根据来时 <code>CS.RPL</code> 动态判定，因为调用方既可能是用户态也可能是内核态。</li>
<li><strong>_KiFastCallEntry（SYSENTER）</strong> ： <code>SYSENTER</code> 指令只能由用户态调用，因此直接强制设置为从用户态调用，另外还会在 <code>KiFastCallEntry</code> 开头“修复”用户态的段寄存器。</li>
</ul>
</li>
<li><p><strong>嵌套保存 TRAP_FRAME</strong>：</p>
<ul>
<li><p><strong>_KiSystemService（INT 2E）</strong> ：会将上一个系统调用的 <code>TRAP_FRAME</code> 地址 <code>KTHREAD.TrapFrame</code> 保存到 <code>TRAP_FRAME.Edx</code> 然后再设置 <code>KTHREAD.TrapFrame</code> 指向当前 <code>TRAP_FRAME</code>。</p>
<p>这是为了支持<strong>系统调用的嵌套 &#x2F; 递归</strong>（例如内核里再次发起 syscall），可通过 <code>TrapFrame.TsEdx</code> 字段找到上一个 Trap Frame，用于 unwind 或调试工具遍历调用链。</p>
</li>
<li><p><strong>_KiFastCallEntry（SYSENTER）</strong> ：  <code>KiFastCallEntry</code> 只会设置设置 <code>KTHREAD.TrapFrame</code> 指向当前 <code>TRAP_FRAME</code>，而不将上一个系统调用的 <code>TRAP_FRAME</code> 地址 <code>KTHREAD.TrapFrame</code> 保存到 <code>TRAP_FRAME.Edx</code>。</p>
<p>主要因为 <code>SYSENTER</code> 是为 <strong>纯用户态到内核</strong> 的快速单向路径设计的，<strong>性能优先</strong>，不考虑内核中间层再发起 syscall 的情形。</p>
</li>
</ul>
</li>
</ul>
<h1 id="SSDT-Hook"><a href="#SSDT-Hook" class="headerlink" title="SSDT Hook"></a>SSDT Hook</h1><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 类型定义 ==========</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 64 位下 SSDT 表项是 PULONG_PTR（即 PVOID*），不是 PULONG</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KSERVICE_TABLE_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    PULONG_PTR ServiceTableBase;        <span class="comment">// 系统服务函数地址表（SSDT）</span></span><br><span class="line">    PULONG     ServiceCounterTableBase; <span class="comment">// 调用次数计数表（可为 NULL）</span></span><br><span class="line">    ULONG_PTR  NumberOfServices;        <span class="comment">// 系统服务数量</span></span><br><span class="line">    PUCHAR     ParamTableBase;          <span class="comment">// 参数长度表（64 位中已无意义）</span></span><br><span class="line">&#125; KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入 SSDT 结构（老系统导出，现代系统可用符号解析等方式获取）</span></span><br><span class="line">__declspec(dllimport) KSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SSDT 中 NtOpenProcess 的索引（Win7 x64 一般为 0xBE，建议动态获取）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSDT_INDEX_NTOPENPROCESS 0xBE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数指针定义：NtOpenProcess 原型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span><span class="params">(*FnNtOpenProcess)</span><span class="params">(</span></span><br><span class="line"><span class="params">    PHANDLE ProcessHandle,</span></span><br><span class="line"><span class="params">    ACCESS_MASK DesiredAccess,</span></span><br><span class="line"><span class="params">    POBJECT_ATTRIBUTES ObjectAttributes,</span></span><br><span class="line"><span class="params">    PCLIENT_ID ClientId</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 全局变量 ==========</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> FnNtOpenProcess g_OriginalNtOpenProcess = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> LONG g_ActiveCallCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 工具函数 ==========</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 睡眠指定毫秒（用于卸载等待）</span></span><br><span class="line">VOID <span class="title function_">SleepMilliseconds</span><span class="params">(ULONG ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    LARGE_INTEGER interval;</span><br><span class="line">    interval.QuadPart = -(<span class="number">10</span> * <span class="number">1000</span> * (LONGLONG)ms); <span class="comment">// 单位：100ns</span></span><br><span class="line">    KeDelayExecutionThread(KernelMode, FALSE, &amp;interval);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将内存映射为可写（使用 MDL）</span></span><br><span class="line">PVOID <span class="title function_">MapMemoryAsWritable</span><span class="params">(PVOID address, SIZE_T size, PMDL* outMdl)</span></span><br><span class="line">&#123;</span><br><span class="line">    PMDL mdl = IoAllocateMdl(address, (ULONG)size, FALSE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!mdl) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    MmBuildMdlForNonPagedPool(mdl);</span><br><span class="line"></span><br><span class="line">    PVOID mapped = MmMapLockedPagesSpecifyCache(</span><br><span class="line">        mdl, KernelMode, MmNonCached, <span class="literal">NULL</span>, FALSE, NormalPagePriority</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mapped)</span><br><span class="line">    &#123;</span><br><span class="line">        IoFreeMdl(mdl);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (outMdl) *outMdl = mdl;</span><br><span class="line">    <span class="keyword">return</span> mapped;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解除映射并释放 MDL</span></span><br><span class="line">VOID <span class="title function_">UnmapMemory</span><span class="params">(PVOID mapped, PMDL mdl)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mapped &amp;&amp; mdl)</span><br><span class="line">    &#123;</span><br><span class="line">        MmUnmapLockedPages(mapped, mdl);</span><br><span class="line">        IoFreeMdl(mdl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== Hook 函数 ==========</span></span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">HookedNtOpenProcess</span><span class="params">(</span></span><br><span class="line"><span class="params">    PHANDLE ProcessHandle,</span></span><br><span class="line"><span class="params">    ACCESS_MASK DesiredAccess,</span></span><br><span class="line"><span class="params">    POBJECT_ATTRIBUTES ObjectAttributes,</span></span><br><span class="line"><span class="params">    PCLIENT_ID ClientId</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    InterlockedIncrement(&amp;g_ActiveCallCount);</span><br><span class="line"></span><br><span class="line">    DbgPrint(<span class="string">&quot;[SSDT Hook] NtOpenProcess called for PID: %u\n&quot;</span>,</span><br><span class="line">        (ULONG)(ULONG_PTR)ClientId-&gt;UniqueProcess);</span><br><span class="line"></span><br><span class="line">    NTSTATUS status = g_OriginalNtOpenProcess(</span><br><span class="line">        ProcessHandle, DesiredAccess, ObjectAttributes, ClientId);</span><br><span class="line"></span><br><span class="line">    InterlockedDecrement(&amp;g_ActiveCallCount);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 驱动入口 ==========</span></span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)</span></span><br><span class="line">&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(RegistryPath);</span><br><span class="line">    DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 SSDT 表地址</span></span><br><span class="line">    PULONG_PTR ssdt = KeServiceDescriptorTable.ServiceTableBase;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 映射为可写</span></span><br><span class="line">    PMDL mdl = <span class="literal">NULL</span>;</span><br><span class="line">    PULONG_PTR mappedSSDT = (PULONG_PTR)MapMemoryAsWritable(ssdt, PAGE_SIZE, &amp;mdl);</span><br><span class="line">    <span class="keyword">if</span> (!mappedSSDT) <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存原函数指针并 Hook</span></span><br><span class="line">    g_OriginalNtOpenProcess = (FnNtOpenProcess)mappedSSDT[SSDT_INDEX_NTOPENPROCESS];</span><br><span class="line">    mappedSSDT[SSDT_INDEX_NTOPENPROCESS] = (ULONG_PTR)HookedNtOpenProcess;</span><br><span class="line"></span><br><span class="line">    UnmapMemory(mappedSSDT, mdl);</span><br><span class="line">    DbgPrint(<span class="string">&quot;[SSDT Hook] Hook installed at index 0x%X\n&quot;</span>, SSDT_INDEX_NTOPENPROCESS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 驱动卸载 ==========</span></span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span><br><span class="line">&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(DriverObject);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 SSDT 表地址</span></span><br><span class="line">    PULONG_PTR ssdt = KeServiceDescriptorTable.ServiceTableBase;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 映射为可写</span></span><br><span class="line">    PMDL mdl = <span class="literal">NULL</span>;</span><br><span class="line">    PULONG_PTR mappedSSDT = (PULONG_PTR)MapMemoryAsWritable(ssdt, PAGE_SIZE, &amp;mdl);</span><br><span class="line">    <span class="keyword">if</span> (!mappedSSDT) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复原函数指针</span></span><br><span class="line">    mappedSSDT[SSDT_INDEX_NTOPENPROCESS] = (ULONG_PTR)g_OriginalNtOpenProcess;</span><br><span class="line"></span><br><span class="line">    UnmapMemory(mappedSSDT, mdl);</span><br><span class="line">    DbgPrint(<span class="string">&quot;[SSDT Hook] Hook removed. Waiting for active calls...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有挂钩函数返回</span></span><br><span class="line">    <span class="keyword">while</span> (InterlockedCompareExchange(&amp;g_ActiveCallCount, <span class="number">0</span>, <span class="number">0</span>) != <span class="number">0</span>)</span><br><span class="line">        SleepMilliseconds(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    SleepMilliseconds(<span class="number">300</span>); <span class="comment">// 额外安全延迟</span></span><br><span class="line">    DbgPrint(<span class="string">&quot;[SSDT Hook] Driver unloaded safely.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> windows 系统调用</li>
        <li><strong>Author:</strong> sky123</li>
        <li><strong>Created at
                :</strong> 2022-09-28 11:45:14</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2025-08-19 01:14:49
            </li>
        
        <li>
            <strong>Link:</strong> https://skyi23.github.io/2022/09/28/windows 系统调用/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/windows-kernel-reverse/">#windows kernel reverse</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2022/09/28/windows%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">windows 保护模式</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2022/09/28/windows%20%E5%8F%A5%E6%9F%84%E8%A1%A8/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">windows 句柄表</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'skyI23/my-giscus-discussions',
                'data-repo-id': 'R_kgDONL9k_w',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDONL9k_84CkEdK',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">windows 系统调用</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#R3-%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B"><span class="nav-text">R3 调用过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Kernel32"><span class="nav-text">Kernel32</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#KernelBase"><span class="nav-text">KernelBase</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ntdll"><span class="nav-text">Ntdll</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#KiFastSystemCall%EF%BC%88SYSENTER%EF%BC%89"><span class="nav-text">KiFastSystemCall（SYSENTER）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KiIntSystemCall%EF%BC%88INT-2E%EF%BC%89"><span class="nav-text">KiIntSystemCall（INT 2E）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="nav-text">系统调用指令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SYSENTER-SYSEXIT"><span class="nav-text">SYSENTER&#x2F;SYSEXIT</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SYSENTER"><span class="nav-text">SYSENTER</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SYSEXIT"><span class="nav-text">SYSEXIT</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#INT-2E-IRETD"><span class="nav-text">INT 2E&#x2F;IRETD</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#INT-2E"><span class="nav-text">INT 2E</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IRETD"><span class="nav-text">IRETD</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SYSCALL-SYSRET%EF%BC%88%E4%BB%85%E9%99%90-x64%EF%BC%89"><span class="nav-text">SYSCALL &#x2F; SYSRET（仅限 x64）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#R0-%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B"><span class="nav-text">R0 调用过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#KiFastCallEntry%EF%BC%88SYSENTER%EF%BC%89"><span class="nav-text">KiFastCallEntry（SYSENTER）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%85%E7%90%86%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">清理段寄存器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%87%E6%8D%A2%E5%86%85%E6%A0%B8%E6%A0%88"><span class="nav-text">切换内核栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E5%AD%98-TRAP-FRAME"><span class="nav-text">保存 TRAP_FRAME</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E7%94%A8-SSDT-%E8%A1%A8%E5%87%BD%E6%95%B0"><span class="nav-text">调用 SSDT 表函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E7%94%A8%E6%88%B7%E6%80%81"><span class="nav-text">返回用户态</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#KiSystemService%EF%BC%88INT-2E%EF%BC%89"><span class="nav-text">KiSystemService（INT 2E）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SSDT-Hook"><span class="nav-text">SSDT Hook</span></a></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2024</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">sky123</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        57 posts in total
                    </span>
                    
                        <span>
                            1212.2k words in total
                        </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.5</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>



<script src="/js/build/libs/Swup.min.js"></script>

<script src="/js/build/libs/SwupSlideTheme.min.js"></script>

<script src="/js/build/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/build/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/build/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/build/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	
<script src="/js/build/tools/imageViewer.js" type="module"></script>

<script src="/js/build/utils.js" type="module"></script>

<script src="/js/build/main.js" type="module"></script>

<script src="/js/build/layouts/navbarShrink.js" type="module"></script>

<script src="/js/build/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/build/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/build/layouts/categoryList.js" type="module"></script>



    
<script src="/js/build/tools/localSearch.js" type="module"></script>




    
<script src="/js/build/tools/codeBlock.js" type="module"></script>




    
<script src="/js/build/layouts/lazyload.js" type="module"></script>




    
<script src="/js/build/tools/runtime.js"></script>

    
<script src="/js/build/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/build/libs/Typed.min.js"></script>

  
<script src="/js/build/plugins/typed.js" type="module"></script>




    
        
<script src="/js/build/libs/mermaid.min.js"></script>

    
    
<script src="/js/build/plugins/mermaid.js"></script>






    
<script src="/js/build/libs/anime.min.js"></script>





    
<script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script>





    
<script src="/js/build/layouts/bookmarkNav.js" type="module"></script>


	
</body>

</html>